{"sha": "5217527a5b2e09342e00cf8571e8af22f50546c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMTc1MjdhNWIyZTA5MzQyZTAwY2Y4NTcxZThhZjIyZjUwNTQ2YzM=", "commit": {"author": {"name": "Kevin Leimkuhler", "email": "kevin@kleimkuhler.com", "date": "2018-10-04T16:36:55Z"}, "committer": {"name": "Kevin Leimkuhler", "email": "kevin@kleimkuhler.com", "date": "2018-10-10T04:10:27Z"}, "message": "Share outer paren trimming logic", "tree": {"sha": "e935b42c323f5718759bfdf7647340dc72a69b1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e935b42c323f5718759bfdf7647340dc72a69b1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5217527a5b2e09342e00cf8571e8af22f50546c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5217527a5b2e09342e00cf8571e8af22f50546c3", "html_url": "https://github.com/rust-lang/rust/commit/5217527a5b2e09342e00cf8571e8af22f50546c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5217527a5b2e09342e00cf8571e8af22f50546c3/comments", "author": {"login": "kleimkuhler", "id": 4572153, "node_id": "MDQ6VXNlcjQ1NzIxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/4572153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kleimkuhler", "html_url": "https://github.com/kleimkuhler", "followers_url": "https://api.github.com/users/kleimkuhler/followers", "following_url": "https://api.github.com/users/kleimkuhler/following{/other_user}", "gists_url": "https://api.github.com/users/kleimkuhler/gists{/gist_id}", "starred_url": "https://api.github.com/users/kleimkuhler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kleimkuhler/subscriptions", "organizations_url": "https://api.github.com/users/kleimkuhler/orgs", "repos_url": "https://api.github.com/users/kleimkuhler/repos", "events_url": "https://api.github.com/users/kleimkuhler/events{/privacy}", "received_events_url": "https://api.github.com/users/kleimkuhler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kleimkuhler", "id": 4572153, "node_id": "MDQ6VXNlcjQ1NzIxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/4572153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kleimkuhler", "html_url": "https://github.com/kleimkuhler", "followers_url": "https://api.github.com/users/kleimkuhler/followers", "following_url": "https://api.github.com/users/kleimkuhler/following{/other_user}", "gists_url": "https://api.github.com/users/kleimkuhler/gists{/gist_id}", "starred_url": "https://api.github.com/users/kleimkuhler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kleimkuhler/subscriptions", "organizations_url": "https://api.github.com/users/kleimkuhler/orgs", "repos_url": "https://api.github.com/users/kleimkuhler/repos", "events_url": "https://api.github.com/users/kleimkuhler/events{/privacy}", "received_events_url": "https://api.github.com/users/kleimkuhler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8552c61c5a8e91b30bd35e4711d39d470c83cbb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8552c61c5a8e91b30bd35e4711d39d470c83cbb1", "html_url": "https://github.com/rust-lang/rust/commit/8552c61c5a8e91b30bd35e4711d39d470c83cbb1"}], "stats": {"total": 130, "additions": 46, "deletions": 84}, "files": [{"sha": "a176bd8302609bff8add5c1277e4d29faf8c1232", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 46, "deletions": 84, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5217527a5b2e09342e00cf8571e8af22f50546c3/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5217527a5b2e09342e00cf8571e8af22f50546c3/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5217527a5b2e09342e00cf8571e8af22f50546c3", "patch": "@@ -273,43 +273,8 @@ impl UnusedParens {\n             let necessary = struct_lit_needs_parens &&\n                             parser::contains_exterior_struct_lit(&inner);\n             if !necessary {\n-                let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n-                let mut err = cx.struct_span_lint(UNUSED_PARENS,\n-                                                  value.span,\n-                                                  &span_msg);\n-                // Remove exactly one pair of parentheses (rather than na\u00efvely\n-                // stripping all paren characters)\n-                let mut ate_left_paren = false;\n-                let mut ate_right_paren = false;\n-                let parens_removed = pprust::expr_to_string(value)\n-                    .trim_matches(|c| {\n-                        match c {\n-                            '(' => {\n-                                if ate_left_paren {\n-                                    false\n-                                } else {\n-                                    ate_left_paren = true;\n-                                    true\n-                                }\n-                            },\n-                            ')' => {\n-                                if ate_right_paren {\n-                                    false\n-                                } else {\n-                                    ate_right_paren = true;\n-                                    true\n-                                }\n-                            },\n-                            _ => false,\n-                        }\n-                    }).to_owned();\n-                err.span_suggestion_short_with_applicability(\n-                    value.span,\n-                    \"remove these parentheses\",\n-                    parens_removed,\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                let pattern = pprust::expr_to_string(value);\n+                Self::remove_outer_parens(cx, value.span, &pattern, msg)\n             }\n         }\n     }\n@@ -320,49 +285,48 @@ impl UnusedParens {\n                                 msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::PatKind::Paren(_) = value.node {\n-            // Does there need to be a check similar to `parser::contains_exterior_struct_lit`\n-            // here?\n             if !struct_lit_needs_parens {\n-                let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n-                let mut err = cx.struct_span_lint(UNUSED_PARENS,\n-                                                  value.span,\n-                                                  &span_msg);\n-                // Remove exactly one pair of parentheses (rather than na\u00efvely\n-                // stripping all paren characters)\n-                let mut ate_left_paren = false;\n-                let mut ate_right_paren = false;\n-                let parens_removed = pprust::pat_to_string(value)\n-                    .trim_matches(|c| {\n-                        match c {\n-                            '(' => {\n-                                if ate_left_paren {\n-                                    false\n-                                } else {\n-                                    ate_left_paren = true;\n-                                    true\n-                                }\n-                            },\n-                            ')' => {\n-                                if ate_right_paren {\n-                                    false\n-                                } else {\n-                                    ate_right_paren = true;\n-                                    true\n-                                }\n-                            },\n-                            _ => false,\n-                        }\n-                    }).to_owned();\n-                err.span_suggestion_short_with_applicability(\n-                    value.span,\n-                    \"remove these parentheses\",\n-                    parens_removed,\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                let pattern = pprust::pat_to_string(value);\n+                Self::remove_outer_parens(cx, value.span, &pattern, msg)\n             }\n         }\n     }\n+\n+    fn remove_outer_parens(cx: &EarlyContext, span: Span, pattern: &str, msg: &str) {\n+        let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+        let mut err = cx.struct_span_lint(UNUSED_PARENS, span, &span_msg);\n+        let mut ate_left_paren = false;\n+        let mut ate_right_paren = false;\n+        let parens_removed = pattern\n+            .trim_matches(|c| {\n+                match c {\n+                    '(' => {\n+                        if ate_left_paren {\n+                            false\n+                        } else {\n+                            ate_left_paren = true;\n+                            true\n+                        }\n+                    },\n+                    ')' => {\n+                        if ate_right_paren {\n+                            false\n+                        } else {\n+                            ate_right_paren = true;\n+                            true\n+                        }\n+                    },\n+                    _ => false,\n+                }\n+            }).to_owned();\n+        err.span_suggestion_short_with_applicability(\n+                span,\n+                \"remove these parentheses\",\n+                parens_removed,\n+                Applicability::MachineApplicable\n+            );\n+        err.emit();\n+    }\n }\n \n impl LintPass for UnusedParens {\n@@ -414,16 +378,14 @@ impl EarlyLintPass for UnusedParens {\n \n     fn check_pat(&mut self, cx: &EarlyContext, p: &ast::Pat) {\n         use ast::PatKind::*;\n-        let (value, msg) = match p.node {\n-            Paren(ref pat) => {\n-                match pat.node {\n-                    Wild => (p, \"wildcard pattern\"),\n-                    _ => return,\n-                }\n-            }\n+        let (value, msg, struct_lit_needs_parens) = match p.node {\n+            Ident(.., Some(ref pat)) => (pat, \"optional subpattern\", false),\n+            Ref(ref pat, _) => (pat, \"reference pattern\", false),\n+            Slice(_, Some(ref pat), _) => (pat, \"optional position pattern\", false),\n+            Paren(_) => (p, \"pattern\", false),\n             _ => return,\n         };\n-        self.check_unused_parens_pat(cx, &value, msg, false);\n+        self.check_unused_parens_pat(cx, &value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {"}]}