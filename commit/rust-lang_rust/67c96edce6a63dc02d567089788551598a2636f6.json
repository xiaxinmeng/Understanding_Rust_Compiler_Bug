{"sha": "67c96edce6a63dc02d567089788551598a2636f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3Yzk2ZWRjZTZhNjNkYzAyZDU2NzA4OTc4ODU1MTU5OGEyNjM2ZjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-06T10:14:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-06T13:00:08Z"}, "message": "revert #52991", "tree": {"sha": "d095b1acf1b2241bfaf9b83ddb8e607c1308be74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d095b1acf1b2241bfaf9b83ddb8e607c1308be74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67c96edce6a63dc02d567089788551598a2636f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67c96edce6a63dc02d567089788551598a2636f6", "html_url": "https://github.com/rust-lang/rust/commit/67c96edce6a63dc02d567089788551598a2636f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67c96edce6a63dc02d567089788551598a2636f6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c98d2e63f732682b057c8c453b08f9e12b262e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c98d2e63f732682b057c8c453b08f9e12b262e6", "html_url": "https://github.com/rust-lang/rust/commit/7c98d2e63f732682b057c8c453b08f9e12b262e6"}], "stats": {"total": 396, "additions": 65, "deletions": 331}, "files": [{"sha": "7e39f3d3b08418618516629ae866807f02ae392c", "filename": "src/librustc_mir/borrow_check/nll/escaping_locals.rs", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/7c98d2e63f732682b057c8c453b08f9e12b262e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c98d2e63f732682b057c8c453b08f9e12b262e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs?ref=7c98d2e63f732682b057c8c453b08f9e12b262e6", "patch": "@@ -1,229 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Identify those variables whose entire value will eventually be\n-//! returned from the fn via the RETURN_PLACE. As an optimization, we\n-//! can skip computing liveness results for those variables. The idea\n-//! is that the return type of the fn only ever contains free\n-//! regions. Therefore, the types of those variables are going to\n-//! ultimately be contrained to outlive those free regions -- since\n-//! free regions are always live for the entire body, this implies\n-//! that the liveness results are not important for those regions.\n-//! This is most important in the \"fns\" that we create to represent static\n-//! values, since those are often really quite large, and all regions in them\n-//! will ultimately be constrained to be `'static`. Two examples:\n-//!\n-//! ```\n-//! fn foo() -> &'static [u32] { &[] }\n-//! static FOO: &[u32] = &[];\n-//! ```\n-//!\n-//! In both these cases, the return value will only have static lifetime.\n-//!\n-//! NB: The simple logic here relies on the fact that outlives\n-//! relations in our analysis don't have locations. Otherwise, we\n-//! would have to restrict ourselves to values that are\n-//! *unconditionally* returned (which would still cover the \"big\n-//! static value\" case).\n-//!\n-//! The way that this code works is to use union-find -- we iterate\n-//! over the MIR and union together two variables X and Y if all\n-//! regions in the value of Y are going to be stored into X -- that\n-//! is, if `typeof(X): 'a` requires that `typeof(Y): 'a`. This means\n-//! that e.g. we can union together `x` and `y` if we have something\n-//! like `x = (y, 22)`, but not something like `x = y.f` (since there\n-//! may be regions in the type of `y` that do not appear in the field\n-//! `f`).\n-\n-use rustc::mir::visit::Visitor;\n-use rustc::mir::*;\n-\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::unify as ut;\n-\n-crate struct EscapingLocals {\n-    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n-}\n-\n-impl EscapingLocals {\n-    crate fn compute(mir: &Mir<'tcx>) -> Self {\n-        let mut visitor = GatherAssignedLocalsVisitor::new();\n-        visitor.visit_mir(mir);\n-\n-        EscapingLocals {\n-            unification_table: visitor.unification_table,\n-        }\n-    }\n-\n-    /// True if `local` is known to escape into static\n-    /// memory.\n-    crate fn escapes_into_return(&mut self, local: Local) -> bool {\n-        let return_place = AssignedLocal::from(RETURN_PLACE);\n-        let other_place = AssignedLocal::from(local);\n-        self.unification_table.unioned(return_place, other_place)\n-    }\n-}\n-\n-/// The MIR visitor gathering the union-find of the locals used in\n-/// assignments.\n-struct GatherAssignedLocalsVisitor {\n-    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-struct AssignedLocal(u32);\n-\n-impl ut::UnifyKey for AssignedLocal {\n-    type Value = ();\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> AssignedLocal {\n-        AssignedLocal(i)\n-    }\n-\n-    fn tag() -> &'static str {\n-        \"AssignedLocal\"\n-    }\n-}\n-\n-impl From<Local> for AssignedLocal {\n-    fn from(item: Local) -> Self {\n-        // newtype_indexes use usize but are u32s.\n-        assert!(item.index() < ::std::u32::MAX as usize);\n-        AssignedLocal(item.index() as u32)\n-    }\n-}\n-\n-impl GatherAssignedLocalsVisitor {\n-    fn new() -> Self {\n-        Self {\n-            unification_table: ut::UnificationTable::new(),\n-        }\n-    }\n-\n-    fn union_locals_if_needed(&mut self, lvalue: Option<Local>, rvalue: Option<Local>) {\n-        if let Some(lvalue) = lvalue {\n-            if let Some(rvalue) = rvalue {\n-                if lvalue != rvalue {\n-                    debug!(\"EscapingLocals: union {:?} and {:?}\", lvalue, rvalue);\n-                    self.unification_table\n-                        .union(AssignedLocal::from(lvalue), AssignedLocal::from(rvalue));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-// Returns the potential `Local` associated to this `Place` or `PlaceProjection`\n-fn find_local_in_place(place: &Place) -> Option<Local> {\n-    match place {\n-        Place::Local(local) => Some(*local),\n-\n-        // If you do e.g. `x = a.f` then only *part* of the type of\n-        // `a` escapes into `x` (the part contained in `f`); if `a`'s\n-        // type has regions that don't appear in `f`, those might not\n-        // escape.\n-        Place::Projection(..) => None,\n-\n-        Place::Static { .. } | Place::Promoted { .. } => None,\n-    }\n-}\n-\n-// Returns the potential `Local` in this `Operand`.\n-fn find_local_in_operand(op: &Operand) -> Option<Local> {\n-    // Conservatively check a subset of `Operand`s we know our\n-    // benchmarks track, for example `html5ever`.\n-    match op {\n-        Operand::Copy(place) | Operand::Move(place) => find_local_in_place(place),\n-        Operand::Constant(_) => None,\n-    }\n-}\n-\n-impl Visitor<'tcx> for GatherAssignedLocalsVisitor {\n-    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        // We need as many union-find keys as there are locals\n-        for _ in 0..mir.local_decls.len() {\n-            self.unification_table.new_key(());\n-        }\n-\n-        self.super_mir(mir);\n-    }\n-\n-    fn visit_assign(\n-        &mut self,\n-        block: BasicBlock,\n-        place: &Place<'tcx>,\n-        rvalue: &Rvalue<'tcx>,\n-        location: Location,\n-    ) {\n-        let local = find_local_in_place(place);\n-\n-        // Find those cases where there is a `Place` consumed by\n-        // `rvalue` and we know that all regions in its type will be\n-        // incorporated into `place`, the `Place` we are assigning to.\n-        match rvalue {\n-            // `x = y` is the simplest possible case.\n-            Rvalue::Use(op) => self.union_locals_if_needed(local, find_local_in_operand(op)),\n-\n-            // `X = &'r P` -- the type of `X` will be `&'r T_P`, where\n-            // `T_P` is the type of `P`.\n-            Rvalue::Ref(_, _, place) => {\n-                // Special case: if you have `X = &*Y` (or `X = &**Y`\n-                // etc), then the outlives relationships will ensure\n-                // that all regions in `Y` are constrained by regions\n-                // in `X` -- this is because the lifetimes of the\n-                // references we deref through are required to outlive\n-                // the borrow lifetime `'r` (which appears in `X`).\n-                //\n-                // (We don't actually need to check the type of `Y`:\n-                // since `ProjectionElem::Deref` represents a built-in\n-                // deref and not an overloaded deref, if the thing we\n-                // deref through is not a reference, then it must be a\n-                // `Box` or `*const`, in which case it contains no\n-                // references.)\n-                let mut place_ref = place;\n-                while let Place::Projection(proj) = place_ref {\n-                    if let ProjectionElem::Deref = proj.elem {\n-                        place_ref = &proj.base;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-\n-                self.union_locals_if_needed(local, find_local_in_place(place_ref))\n-            }\n-\n-            Rvalue::Cast(kind, op, _) => match kind {\n-                CastKind::Unsize => {\n-                    // Casting a `&[T; N]` to `&[T]` or `&Foo` to `&Trait` --\n-                    // in both cases, no regions are \"lost\".\n-                    self.union_locals_if_needed(local, find_local_in_operand(op))\n-                }\n-                _ => (),\n-            },\n-\n-            // Constructing an aggregate like `(x,)` or `Foo { x }`\n-            // includes the full type of `x`.\n-            Rvalue::Aggregate(_, ops) => {\n-                for rvalue in ops.iter().map(find_local_in_operand) {\n-                    self.union_locals_if_needed(local, rvalue);\n-                }\n-            }\n-\n-            // For other things, be conservative and do not union.\n-            _ => (),\n-        };\n-\n-        self.super_assign(block, place, rvalue, location);\n-    }\n-}"}, {"sha": "cbd9c9a4e1a85368906de6d91bd210585a731c7b", "filename": "src/librustc_mir/borrow_check/nll/liveness_map.rs", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -16,10 +16,9 @@\n //! liveness code so that it only operates over variables with regions in their\n //! types, instead of all variables.\n \n-use borrow_check::nll::escaping_locals::EscapingLocals;\n-use rustc::mir::{Local, Mir};\n use rustc::ty::TypeFoldable;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::mir::{Mir, Local};\n use util::liveness::LiveVariableMap;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -30,13 +29,14 @@ use rustc_data_structures::indexed_vec::Idx;\n crate struct NllLivenessMap {\n     /// For each local variable, contains either None (if the type has no regions)\n     /// or Some(i) with a suitable index.\n-    from_local: IndexVec<Local, Option<LocalWithRegion>>,\n-\n+    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n     /// For each LocalWithRegion, maps back to the original Local index.\n-    to_local: IndexVec<LocalWithRegion, Local>,\n+    pub to_local: IndexVec<LocalWithRegion, Local>,\n+\n }\n \n impl LiveVariableMap for NllLivenessMap {\n+\n     fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n         self.from_local[local]\n     }\n@@ -55,43 +55,21 @@ impl LiveVariableMap for NllLivenessMap {\n impl NllLivenessMap {\n     /// Iterates over the variables in Mir and assigns each Local whose type contains\n     /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n-    crate fn compute(mir: &Mir<'tcx>) -> Self {\n-        let mut escaping_locals = EscapingLocals::compute(mir);\n-\n+    pub fn compute(mir: &Mir) -> Self {\n         let mut to_local = IndexVec::default();\n-        let mut escapes_into_return = 0;\n-        let mut no_regions = 0;\n-        let from_local: IndexVec<Local, Option<_>> = mir\n+        let from_local: IndexVec<Local,Option<_>> = mir\n             .local_decls\n             .iter_enumerated()\n             .map(|(local, local_decl)| {\n-                if escaping_locals.escapes_into_return(local) {\n-                    // If the local escapes into the return value,\n-                    // then the return value will force all of the\n-                    // regions in its type to outlive free regions\n-                    // (e.g., `'static`) and hence liveness is not\n-                    // needed. This is particularly important for big\n-                    // statics.\n-                    escapes_into_return += 1;\n-                    None\n-                } else if local_decl.ty.has_free_regions() {\n-                    let l = to_local.push(local);\n-                    debug!(\"liveness_map: {:?} = {:?}\", local, l);\n-                    Some(l)\n-                } else {\n-                    no_regions += 1;\n-                    None\n+                if local_decl.ty.has_free_regions() {\n+                    Some(to_local.push(local))\n                 }\n+                    else {\n+                        None\n+                    }\n             }).collect();\n \n-        debug!(\"liveness_map: {} variables need liveness\", to_local.len());\n-        debug!(\"liveness_map: {} escapes into return\", escapes_into_return);\n-        debug!(\"liveness_map: {} no regions\", no_regions);\n-\n-        Self {\n-            from_local,\n-            to_local,\n-        }\n+        Self { from_local, to_local }\n     }\n }\n "}, {"sha": "973568a67f030e8fdf04c89d45a8e59cfc5376c2", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -39,9 +39,7 @@ use polonius_engine::{Algorithm, Output};\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n \n-mod constraints;\n mod constraint_generation;\n-mod escaping_locals;\n pub mod explain_borrow;\n mod facts;\n mod invalidation;\n@@ -51,6 +49,8 @@ crate mod type_check;\n mod universal_regions;\n crate mod liveness_map;\n \n+mod constraints;\n+\n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n@@ -120,7 +120,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         location_table,\n         borrow_set,\n         &liveness,\n-        &liveness_map,\n         &mut all_facts,\n         flow_inits,\n         move_data,\n@@ -206,7 +205,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     dump_mir_results(\n         infcx,\n         &liveness,\n-        &liveness_map,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -223,7 +221,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n-    liveness_map: &NllLivenessMap,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -233,14 +230,16 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n+    let map = &NllLivenessMap::compute(mir);\n+\n     let regular_liveness_per_location: FxHashMap<_, _> = mir\n         .basic_blocks()\n         .indices()\n         .flat_map(|bb| {\n             let mut results = vec![];\n             liveness\n                 .regular\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results\n@@ -254,7 +253,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n             let mut results = vec![];\n             liveness\n                 .drop\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n+                .simulate_block(&mir, bb, map, |location, local_set| {\n                     results.push((location, local_set.clone()));\n                 });\n             results"}, {"sha": "2b9307db59af9feb3821760f2c52f059845d3d39", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -37,18 +37,17 @@ pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n-    liveness_map: &NllLivenessMap,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let mut generator = TypeLivenessGenerator {\n         cx,\n         mir,\n         liveness,\n-        liveness_map,\n         flow_inits,\n         move_data,\n         drop_data: FxHashMap(),\n+        map: &NllLivenessMap::compute(mir),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -66,10 +65,10 @@ where\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults<LocalWithRegion>,\n-    liveness_map: &'gen NllLivenessMap,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+    map: &'gen NllLivenessMap,\n }\n \n struct DropData<'tcx> {\n@@ -87,9 +86,9 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         self.liveness\n             .regular\n-            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n-                    let local = self.liveness_map.from_live_var(live_local);\n+                    let local = self.map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n@@ -98,7 +97,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n         self.liveness\n             .drop\n-            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n         debug!(\n@@ -125,7 +124,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     });\n                 }\n \n-                let local = self.liveness_map.from_live_var(live_local);\n+                let local = self.map.from_live_var(live_local);\n                 let mpi = self.move_data.rev_lookup.find_local(local);\n                 if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n                     debug!(\n@@ -134,7 +133,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                         self.move_data.move_paths[initialized_child]\n                     );\n \n-                    let local = self.liveness_map.from_live_var(live_local);\n+                    let local = self.map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }"}, {"sha": "a18e2368bf724d55b81f5f5afba76711e8d149d3", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -15,12 +15,9 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::liveness_map::NllLivenessMap;\n-use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n+use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::type_check::free_region_relations::{\n-    CreateResult, UniversalRegionRelations,\n-};\n+use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n@@ -119,7 +116,6 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n-    liveness_map: &NllLivenessMap,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -170,7 +166,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n-                liveness::generate(cx, mir, liveness, liveness_map, flow_inits, move_data);\n+                liveness::generate(cx, mir, liveness, flow_inits, move_data);\n                 cx.equate_inputs_and_outputs(\n                     mir,\n                     mir_def_id,"}, {"sha": "95acdab3e80012e3c7c94d179e2667901c7fc3b2", "filename": "src/test/ui/borrowck/promote-ref-mut-in-let-issue-46557.nll.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fpromote-ref-mut-in-let-issue-46557.nll.stderr?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -1,24 +1,30 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:15:21\n    |\n-LL |     let ref mut x = 1234543; //~ ERROR\n-   |                     ^^^^^^^ temporary value does not live long enough\n-LL |     x\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n+LL |   fn gimme_static_mut_let() -> &'static mut u32 {\n+   |  _______________________________________________-\n+LL | |     let ref mut x = 1234543; //~ ERROR\n+   | |                     ^^^^^^^ temporary value does not live long enough\n+LL | |     x\n+LL | | }\n+   | | -\n+   | | |\n+   | |_temporary value only lives until here\n+   |   borrow later used here\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:20:25\n    |\n-LL |     let (ref mut x, ) = (1234543, ); //~ ERROR\n-   |                         ^^^^^^^^^^^ temporary value does not live long enough\n-LL |     x\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n+LL |   fn gimme_static_mut_let_nested() -> &'static mut u32 {\n+   |  ______________________________________________________-\n+LL | |     let (ref mut x, ) = (1234543, ); //~ ERROR\n+   | |                         ^^^^^^^^^^^ temporary value does not live long enough\n+LL | |     x\n+LL | | }\n+   | | -\n+   | | |\n+   | |_temporary value only lives until here\n+   |   borrow later used here\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/promote-ref-mut-in-let-issue-46557.rs:25:11"}, {"sha": "b955a51e38d73433184f516491839ff030d7074c", "filename": "src/test/ui/nll/get_default.nll.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.nll.stderr?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -63,18 +63,9 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n-   |\n-note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n-  --> $DIR/get_default.rs:41:1\n-   |\n-LL | / fn err(map: &mut Map) -> &String {\n-LL | |     loop {\n-LL | |         match map.get() {\n-LL | |             Some(v) => {\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+...\n+LL |                 return v;\n+   |                        - borrow later used here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "75194bf55bc9f1a3b9864d3648790578ea782852", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -63,18 +63,9 @@ LL |         match map.get() {\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n    |                 ^^^ mutable borrow occurs here\n-   |\n-note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 41:1...\n-  --> $DIR/get_default.rs:41:1\n-   |\n-LL | / fn err(map: &mut Map) -> &String {\n-LL | |     loop {\n-LL | |         match map.get() {\n-LL | |             Some(v) => {\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+...\n+LL |                 return v;\n+   |                        - borrow later used here\n \n error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n   --> $DIR/get_default.rs:51:17"}, {"sha": "f40e38c63f5ac28634c488df2b68d67a60134e13", "filename": "src/test/ui/nll/return-ref-mut-issue-46557.stderr", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67c96edce6a63dc02d567089788551598a2636f6/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn-ref-mut-issue-46557.stderr?ref=67c96edce6a63dc02d567089788551598a2636f6", "patch": "@@ -1,13 +1,16 @@\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/return-ref-mut-issue-46557.rs:17:21\n    |\n-LL |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n-   |                     ^^^^^^^ temporary value does not live long enough\n-LL |     x\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n+LL |   fn gimme_static_mut() -> &'static mut u32 {\n+   |  ___________________________________________-\n+LL | |     let ref mut x = 1234543; //~ ERROR borrowed value does not live long enough [E0597]\n+   | |                     ^^^^^^^ temporary value does not live long enough\n+LL | |     x\n+LL | | }\n+   | | -\n+   | | |\n+   | |_temporary value only lives until here\n+   |   borrow later used here\n \n error: aborting due to previous error\n "}]}