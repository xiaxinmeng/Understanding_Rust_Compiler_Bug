{"sha": "ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDhiMDE4ZDZjOWU4ZTI0YmU3MGY3YzdhMWVmOGFmYzFjZGM1ZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T10:48:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:42Z"}, "message": "extract storage of region values from `RegionVarBindings`", "tree": {"sha": "e31cf2e6d1536d5a98492554dbc2d4e2671c430b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e31cf2e6d1536d5a98492554dbc2d4e2671c430b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "html_url": "https://github.com/rust-lang/rust/commit/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b76978530ca40eaa72f16486edbc12145fd1ddd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76978530ca40eaa72f16486edbc12145fd1ddd0", "html_url": "https://github.com/rust-lang/rust/commit/b76978530ca40eaa72f16486edbc12145fd1ddd0"}], "stats": {"total": 187, "additions": 86, "deletions": 101}, "files": [{"sha": "7dbb5b1ff11ae59942f723d62d34c1ef39b971c2", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "patch": "@@ -15,20 +15,30 @@ use infer::RegionVariableOrigin;\n use infer::region_inference::Constraint;\n use infer::region_inference::GenericKind;\n use infer::region_inference::RegionVarBindings;\n-use infer::region_inference::VarValue;\n use infer::region_inference::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use std::fmt;\n use std::u32;\n-use ty::{self, TyCtxt};\n+use ty;\n use ty::{Region, RegionVid};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n \n mod graphviz;\n \n+pub struct LexicalRegionResolutions<'tcx> {\n+    values: Vec<VarValue<'tcx>>,\n+    error_region: ty::Region<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum VarValue<'tcx> {\n+    Value(Region<'tcx>),\n+    ErrorValue,\n+}\n+\n #[derive(Clone, Debug)]\n pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n@@ -72,27 +82,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn resolve_regions(\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-    ) -> Vec<RegionResolutionError<'tcx>> {\n+    ) -> (\n+        LexicalRegionResolutions<'tcx>,\n+        Vec<RegionResolutionError<'tcx>>,\n+    ) {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec![];\n-        let v = self.infer_variable_values(region_rels, &mut errors);\n-        *self.values.borrow_mut() = Some(v);\n-        errors\n-    }\n-\n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        match *self.values.borrow() {\n-            None => span_bug!(\n-                (*self.var_origins.borrow())[rid.index as usize].span(),\n-                \"attempt to resolve region variable before values have \\\n-                 been computed!\"\n-            ),\n-            Some(ref values) => {\n-                let r = lookup(self.tcx, values, rid);\n-                debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n-                r\n-            }\n-        }\n+        let values = self.infer_variable_values(region_rels, &mut errors);\n+        (values, errors)\n     }\n \n     fn lub_concrete_regions(\n@@ -188,7 +185,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n-    ) -> Vec<VarValue<'tcx>> {\n+    ) -> LexicalRegionResolutions<'tcx> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n@@ -208,10 +205,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         var_data\n     }\n \n-    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n-        (0..self.num_vars() as usize)\n-            .map(|_| VarValue::Value(self.tcx.types.re_empty))\n-            .collect()\n+    fn construct_var_data(&self) -> LexicalRegionResolutions<'tcx> {\n+        LexicalRegionResolutions {\n+            error_region: self.tcx.types.re_static,\n+            values: (0..self.num_vars() as usize)\n+                .map(|_| VarValue::Value(self.tcx.types.re_empty))\n+                .collect(),\n+        }\n     }\n \n     fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n@@ -252,19 +252,19 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn expansion(\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-        var_values: &mut [VarValue<'tcx>],\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n-                    let b_data = &mut var_values[b_vid.index as usize];\n+                    let b_data = var_values.value_mut(b_vid);\n                     self.expand_node(region_rels, a_region, b_vid, b_data)\n                 }\n-                Constraint::VarSubVar(a_vid, b_vid) => match var_values[a_vid.index as usize] {\n+                Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n                     VarValue::ErrorValue => false,\n                     VarValue::Value(a_region) => {\n-                        let b_node = &mut var_values[b_vid.index as usize];\n+                        let b_node = var_values.value_mut(b_vid);\n                         self.expand_node(region_rels, a_region, b_vid, b_node)\n                     }\n                 },\n@@ -327,7 +327,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn collect_errors(\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-        var_data: &mut Vec<VarValue<'tcx>>,\n+        var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         let constraints = self.constraints.borrow();\n@@ -363,7 +363,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 }\n \n                 Constraint::VarSubReg(a_vid, b_region) => {\n-                    let a_data = &mut var_data[a_vid.index as usize];\n+                    let a_data = var_data.value_mut(a_vid);\n                     debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data, b_region);\n \n                     let a_region = match *a_data {\n@@ -391,7 +391,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for verify in self.verifys.borrow().iter() {\n             debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = normalize(self.tcx, var_data, verify.region);\n+            let sub = var_data.normalize(verify.region);\n \n             // This was an inference variable which didn't get\n             // constrained, therefore it can be assume to hold.\n@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn collect_var_errors(\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-        var_data: &[VarValue<'tcx>],\n+        var_data: &LexicalRegionResolutions<'tcx>,\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n@@ -443,8 +443,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // overlapping locations.\n         let mut dup_vec = vec![u32::MAX; self.num_vars() as usize];\n \n-        for idx in 0..self.num_vars() as usize {\n-            match var_data[idx] {\n+        for index in 0..self.num_vars() {\n+            let node_vid = RegionVid { index };\n+            match var_data.value(node_vid) {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n                     /* Inference impossible, this value contains\n@@ -469,8 +470,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n-\n-                    let node_vid = RegionVid { index: idx as u32 };\n                     self.collect_error_for_expanding_node(\n                         region_rels,\n                         graph,\n@@ -704,28 +703,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn normalize<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    values: &Vec<VarValue<'tcx>>,\n-    r: ty::Region<'tcx>,\n-) -> ty::Region<'tcx> {\n-    match *r {\n-        ty::ReVar(rid) => lookup(tcx, values, rid),\n-        _ => r,\n-    }\n-}\n-\n-fn lookup<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    values: &Vec<VarValue<'tcx>>,\n-    rid: ty::RegionVid,\n-) -> ty::Region<'tcx> {\n-    match values[rid.index as usize] {\n-        VarValue::Value(r) => r,\n-        VarValue::ErrorValue => tcx.types.re_static, // Previously reported error.\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"RegionAndOrigin({:?},{:?})\", self.region, self.origin)\n@@ -737,26 +714,47 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     fn is_met(\n         &self,\n         region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n-        var_values: &Vec<VarValue<'tcx>>,\n+        var_values: &LexicalRegionResolutions<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {\n-        let tcx = region_rels.tcx;\n         match self {\n-            &VerifyBound::AnyRegion(ref rs) => rs.iter()\n-                .map(|&r| normalize(tcx, var_values, r))\n+            VerifyBound::AnyRegion(rs) => rs.iter()\n+                .map(|&r| var_values.normalize(r))\n                 .any(|r| region_rels.is_subregion_of(min, r)),\n \n-            &VerifyBound::AllRegions(ref rs) => rs.iter()\n-                .map(|&r| normalize(tcx, var_values, r))\n+            VerifyBound::AllRegions(rs) => rs.iter()\n+                .map(|&r| var_values.normalize(r))\n                 .all(|r| region_rels.is_subregion_of(min, r)),\n \n-            &VerifyBound::AnyBound(ref bs) => {\n-                bs.iter().any(|b| b.is_met(region_rels, var_values, min))\n-            }\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.is_met(region_rels, var_values, min)),\n \n-            &VerifyBound::AllBounds(ref bs) => {\n-                bs.iter().all(|b| b.is_met(region_rels, var_values, min))\n-            }\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.is_met(region_rels, var_values, min)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LexicalRegionResolutions<'tcx> {\n+    fn normalize(&self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReVar(rid) => self.resolve_var(rid),\n+            _ => r,\n         }\n     }\n+\n+    fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n+        &self.values[rid.index as usize]\n+    }\n+\n+    fn value_mut(&mut self, rid: RegionVid) -> &mut VarValue<'tcx> {\n+        &mut self.values[rid.index as usize]\n+    }\n+\n+    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n+        let result = match self.values[rid.index as usize] {\n+            VarValue::Value(r) => r,\n+            VarValue::ErrorValue => self.error_region,\n+        };\n+        debug!(\"resolve_var({:?}) = {:?}\", rid, result);\n+        result\n+    }\n }"}, {"sha": "d50d31d34bb8d945a6a80f60c494134a98c4fe4a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "patch": "@@ -42,6 +42,7 @@ use arena::DroplessArena;\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -105,6 +106,9 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // For region variables.\n     region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n \n+    // Once region inference is done, the values for each variable.\n+    lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n+\n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -421,6 +425,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n             region_vars: RegionVarBindings::new(tcx),\n+            lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             reported_trait_errors: RefCell::new(FxHashMap()),\n@@ -1123,7 +1128,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                region_context,\n                                                region_map,\n                                                free_regions);\n-        let errors = self.region_vars.resolve_regions(&region_rels);\n+        let (lexical_region_resolutions, errors) = self.region_vars.resolve_regions(&region_rels);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n \n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors"}, {"sha": "26c206f1b568055e40903cac6b7fc4e7499309a5", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "patch": "@@ -142,12 +142,6 @@ enum CombineMapType {\n     Glb,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum VarValue<'tcx> {\n-    Value(Region<'tcx>),\n-    ErrorValue,\n-}\n-\n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n@@ -208,10 +202,6 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n \n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n-\n-    /// This contains the results of inference.  It begins as an empty\n-    /// option and only acquires a value after inference is complete.\n-    pub(in infer) values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n \n pub struct RegionSnapshot {\n@@ -250,7 +240,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         RegionVarBindings {\n             tcx,\n             var_origins: RefCell::new(Vec::new()),\n-            values: RefCell::new(None),\n             constraints: RefCell::new(BTreeMap::new()),\n             verifys: RefCell::new(Vec::new()),\n             givens: RefCell::new(FxHashSet()),\n@@ -517,14 +506,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n     }\n \n-    fn values_are_none(&self) -> bool {\n-        self.values.borrow().is_none()\n-    }\n-\n     fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n         debug!(\"RegionVarBindings: add_constraint({:?})\", constraint);\n \n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n@@ -540,8 +523,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn add_verify(&self, verify: Verify<'tcx>) {\n         // cannot add verifys once regions are resolved\n-        assert!(self.values_are_none());\n-\n         debug!(\"RegionVarBindings: add_verify({:?})\", verify);\n \n         // skip no-op cases known to be satisfied\n@@ -560,8 +541,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn add_given(&self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n-        assert!(self.values_are_none());\n-\n         let mut givens = self.givens.borrow_mut();\n         if givens.insert((sub, sup)) {\n             debug!(\"add_given({:?} <= {:?})\", sub, sup);\n@@ -591,8 +570,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                           sub: Region<'tcx>,\n                           sup: Region<'tcx>) {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n                sub,\n                sup,\n@@ -644,8 +621,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        b: Region<'tcx>)\n                        -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n@@ -670,8 +645,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        b: Region<'tcx>)\n                        -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n-        assert!(self.values_are_none());\n-\n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (&ReStatic, r) | (r, &ReStatic) => {"}, {"sha": "f01be0cd9e4a9b574ab6ce7b40854baae98a7989", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "patch": "@@ -185,7 +185,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n+            ty::ReVar(rid) => self.infcx.lexical_region_resolutions\n+                                        .borrow()\n+                                        .as_ref()\n+                                        .expect(\"region resolution not performed\")\n+                                        .resolve_var(rid),\n             _ => r,\n         }\n     }"}, {"sha": "31c09c4cd5756146443952b4cf62890eaa438893", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "patch": "@@ -46,12 +46,14 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(i128_type)]\n+#![feature(match_default_bindings)]\n #![feature(inclusive_range_syntax)]\n #![cfg_attr(windows, feature(libc))]\n #![feature(macro_vis_matcher)]\n #![feature(never_type)]\n #![feature(nonzero)]\n #![feature(quote)]\n+#![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(specialization)]"}]}