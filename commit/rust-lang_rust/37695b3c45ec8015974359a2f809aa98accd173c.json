{"sha": "37695b3c45ec8015974359a2f809aa98accd173c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Njk1YjNjNDVlYzgwMTU5NzQzNTlhMmY4MDlhYTk4YWNjZDE3M2M=", "commit": {"author": {"name": "Ruben Schmidmeister", "email": "ruben.schmidmeister@icloud.com", "date": "2019-07-14T01:22:18Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-07-14T01:22:18Z"}, "message": "Extract configuration snippet tests into own module (#3667)\n\n* Extract configuration snippet tests into own module\r\n\r\n* Move helper function outside of test function", "tree": {"sha": "dc45ac479b0fb2473d5d7be5a3acc2253c99c193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc45ac479b0fb2473d5d7be5a3acc2253c99c193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37695b3c45ec8015974359a2f809aa98accd173c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37695b3c45ec8015974359a2f809aa98accd173c", "html_url": "https://github.com/rust-lang/rust/commit/37695b3c45ec8015974359a2f809aa98accd173c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37695b3c45ec8015974359a2f809aa98accd173c/comments", "author": {"login": "bash", "id": 4602612, "node_id": "MDQ6VXNlcjQ2MDI2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/4602612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bash", "html_url": "https://github.com/bash", "followers_url": "https://api.github.com/users/bash/followers", "following_url": "https://api.github.com/users/bash/following{/other_user}", "gists_url": "https://api.github.com/users/bash/gists{/gist_id}", "starred_url": "https://api.github.com/users/bash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bash/subscriptions", "organizations_url": "https://api.github.com/users/bash/orgs", "repos_url": "https://api.github.com/users/bash/repos", "events_url": "https://api.github.com/users/bash/events{/privacy}", "received_events_url": "https://api.github.com/users/bash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679c8d5f106e8442bf8c4a54609a63df9eb3863c", "url": "https://api.github.com/repos/rust-lang/rust/commits/679c8d5f106e8442bf8c4a54609a63df9eb3863c", "html_url": "https://github.com/rust-lang/rust/commit/679c8d5f106e8442bf8c4a54609a63df9eb3863c"}], "stats": {"total": 570, "additions": 291, "deletions": 279}, "files": [{"sha": "55289f55537bbd9ec52147d4ee1d53f670c6ec8b", "filename": "src/test/configuration_snippet.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/37695b3c45ec8015974359a2f809aa98accd173c/src%2Ftest%2Fconfiguration_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37695b3c45ec8015974359a2f809aa98accd173c/src%2Ftest%2Fconfiguration_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fconfiguration_snippet.rs?ref=37695b3c45ec8015974359a2f809aa98accd173c", "patch": "@@ -0,0 +1,286 @@\n+use std::collections::{HashMap, HashSet};\n+use std::fs;\n+use std::io::{BufRead, BufReader, Write};\n+use std::iter::Enumerate;\n+use std::path::{Path, PathBuf};\n+\n+use super::{print_mismatches, write_message, DIFF_CONTEXT_SIZE};\n+use crate::config::{Config, EmitMode, Verbosity};\n+use crate::rustfmt_diff::{make_diff, Mismatch};\n+use crate::{Input, Session};\n+\n+const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n+\n+// This enum is used to represent one of three text features in Configurations.md: a block of code\n+// with its starting line number, the name of a rustfmt configuration option, or the value of a\n+// rustfmt configuration option.\n+enum ConfigurationSection {\n+    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n+    ConfigName(String),\n+    ConfigValue(String),\n+}\n+\n+impl ConfigurationSection {\n+    fn get_section<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+    ) -> Option<ConfigurationSection> {\n+        lazy_static! {\n+            static ref CONFIG_NAME_REGEX: regex::Regex =\n+                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"failed creating configuration pattern\");\n+            static ref CONFIG_VALUE_REGEX: regex::Regex =\n+                regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+                    .expect(\"failed creating configuration value pattern\");\n+        }\n+\n+        loop {\n+            match file.next() {\n+                Some((i, line)) => {\n+                    if line.starts_with(\"```rust\") {\n+                        // Get the lines of the code block.\n+                        let lines: Vec<String> = file\n+                            .map(|(_i, l)| l)\n+                            .take_while(|l| !l.starts_with(\"```\"))\n+                            .collect();\n+                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n+\n+                        // +1 to translate to one-based indexing\n+                        // +1 to get to first line of code (line after \"```\")\n+                        let start_line = (i + 2) as u32;\n+\n+                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n+                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n+                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n+                    }\n+                }\n+                None => return None, // reached the end of the file\n+            }\n+        }\n+    }\n+}\n+\n+// This struct stores the information about code blocks in the configurations\n+// file, formats the code blocks, and prints formatting errors.\n+struct ConfigCodeBlock {\n+    config_name: Option<String>,\n+    config_value: Option<String>,\n+    code_block: Option<String>,\n+    code_block_start: Option<u32>,\n+}\n+\n+impl ConfigCodeBlock {\n+    fn new() -> ConfigCodeBlock {\n+        ConfigCodeBlock {\n+            config_name: None,\n+            config_value: None,\n+            code_block: None,\n+            code_block_start: None,\n+        }\n+    }\n+\n+    fn set_config_name(&mut self, name: Option<String>) {\n+        self.config_name = name;\n+        self.config_value = None;\n+    }\n+\n+    fn set_config_value(&mut self, value: Option<String>) {\n+        self.config_value = value;\n+    }\n+\n+    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n+        self.code_block = Some(code_block);\n+        self.code_block_start = Some(code_block_start);\n+    }\n+\n+    fn get_block_config(&self) -> Config {\n+        let mut config = Config::default();\n+        config.set().verbose(Verbosity::Quiet);\n+        if self.config_name.is_some() && self.config_value.is_some() {\n+            config.override_value(\n+                self.config_name.as_ref().unwrap(),\n+                self.config_value.as_ref().unwrap(),\n+            );\n+        }\n+        config\n+    }\n+\n+    fn code_block_valid(&self) -> bool {\n+        // We never expect to not have a code block.\n+        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n+\n+        // See if code block begins with #![rustfmt::skip].\n+        let fmt_skip = self\n+            .code_block\n+            .as_ref()\n+            .unwrap()\n+            .lines()\n+            .nth(0)\n+            .unwrap_or(\"\")\n+            == \"#![rustfmt::skip]\";\n+\n+        if self.config_name.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration name for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        if self.config_value.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration value for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n+        if session.has_parsing_errors() {\n+            write_message(&format!(\n+                \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn print_diff(&self, compare: Vec<Mismatch>) {\n+        let mut mismatches = HashMap::new();\n+        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n+        print_mismatches(mismatches, |line_num| {\n+            format!(\n+                \"\\nMismatch at {}:{}:\",\n+                CONFIGURATIONS_FILE_NAME,\n+                line_num + self.code_block_start.unwrap() - 1\n+            )\n+        });\n+    }\n+\n+    fn formatted_has_diff(&self, text: &str) -> bool {\n+        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n+        if !compare.is_empty() {\n+            self.print_diff(compare);\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    // Return a bool indicating if formatting this code block is an idempotent\n+    // operation. This function also triggers printing any formatting failure\n+    // messages.\n+    fn formatted_is_idempotent(&self) -> bool {\n+        // Verify that we have all of the expected information.\n+        if !self.code_block_valid() {\n+            return false;\n+        }\n+\n+        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n+        let mut config = self.get_block_config();\n+        config.set().emit_mode(EmitMode::Stdout);\n+        let mut buf: Vec<u8> = vec![];\n+\n+        {\n+            let mut session = Session::new(config, Some(&mut buf));\n+            session.format(input).unwrap();\n+            if self.has_parsing_errors(&session) {\n+                return false;\n+            }\n+        }\n+\n+        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n+    }\n+\n+    // Extract a code block from the iterator. Behavior:\n+    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n+    // - One explicit configuration setting is supported per code block.\n+    // - Rust code blocks with no configuration setting are illegal and cause an\n+    //   assertion failure, unless the snippet begins with #![rustfmt::skip].\n+    // - Configuration names in Configurations.md must be in the form of\n+    //   \"## `NAME`\".\n+    // - Configuration values in Configurations.md must be in the form of\n+    //   \"#### `VALUE`\".\n+    fn extract<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+        prev: Option<&ConfigCodeBlock>,\n+        hash_set: &mut HashSet<String>,\n+    ) -> Option<ConfigCodeBlock> {\n+        let mut code_block = ConfigCodeBlock::new();\n+        code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n+\n+        loop {\n+            match ConfigurationSection::get_section(file) {\n+                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n+                    code_block.set_code_block(block, start_line);\n+                    break;\n+                }\n+                Some(ConfigurationSection::ConfigName(name)) => {\n+                    assert!(\n+                        Config::is_valid_name(&name),\n+                        \"an unknown configuration option was found: {}\",\n+                        name\n+                    );\n+                    assert!(\n+                        hash_set.remove(&name),\n+                        \"multiple configuration guides found for option {}\",\n+                        name\n+                    );\n+                    code_block.set_config_name(Some(name));\n+                }\n+                Some(ConfigurationSection::ConfigValue(value)) => {\n+                    code_block.set_config_value(Some(value));\n+                }\n+                None => return None, // end of file was reached\n+            }\n+        }\n+\n+        Some(code_block)\n+    }\n+}\n+\n+#[test]\n+fn configuration_snippet_tests() {\n+    let blocks = get_code_blocks();\n+    let failures = blocks\n+        .iter()\n+        .map(ConfigCodeBlock::formatted_is_idempotent)\n+        .fold(0, |acc, r| acc + (!r as u32));\n+\n+    // Display results.\n+    println!(\"Ran {} configurations tests.\", blocks.len());\n+    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n+}\n+\n+// Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n+// entry for each Rust code block found.\n+fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n+    let mut file_iter = BufReader::new(\n+        fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n+            .unwrap_or_else(|_| panic!(\"couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n+    )\n+    .lines()\n+    .map(Result::unwrap)\n+    .enumerate();\n+    let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n+    let mut hash_set = Config::hash_set();\n+\n+    while let Some(cb) = ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n+    {\n+        code_blocks.push(cb);\n+    }\n+\n+    for name in hash_set {\n+        if !Config::is_hidden_option(&name) {\n+            panic!(\"{} does not have a configuration guide\", name);\n+        }\n+    }\n+\n+    code_blocks\n+}"}, {"sha": "10aad268a8df644c328c569d0a880226b51a40ba", "filename": "src/test/mod.rs", "status": "modified", "additions": 5, "deletions": 279, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/37695b3c45ec8015974359a2f809aa98accd173c/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37695b3c45ec8015974359a2f809aa98accd173c/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=37695b3c45ec8015974359a2f809aa98accd173c", "patch": "@@ -1,23 +1,24 @@\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::fs;\n use std::io::{self, BufRead, BufReader, Read, Write};\n-use std::iter::{Enumerate, Peekable};\n+use std::iter::Peekable;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str::Chars;\n use std::thread;\n \n-use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic, Verbosity};\n+use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic};\n use crate::formatting::{ReportedErrors, SourceFile};\n use crate::is_nightly_channel;\n use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, ModifiedChunk, OutputWriter};\n use crate::source_file;\n use crate::{FormatReport, FormatReportFormatterBuilder, Input, Session};\n \n+mod configuration_snippet;\n+\n const DIFF_CONTEXT_SIZE: usize = 3;\n-const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n \n // A list of files on which we want to skip testing.\n const SKIP_FILE_WHITE_LIST: &[&str] = &[\n@@ -768,281 +769,6 @@ fn string_eq_ignore_newline_repr_test() {\n     assert!(!string_eq_ignore_newline_repr(\"a\\r\\nbcd\", \"a\\nbcdefghijk\"));\n }\n \n-// This enum is used to represent one of three text features in Configurations.md: a block of code\n-// with its starting line number, the name of a rustfmt configuration option, or the value of a\n-// rustfmt configuration option.\n-enum ConfigurationSection {\n-    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n-    ConfigName(String),\n-    ConfigValue(String),\n-}\n-\n-impl ConfigurationSection {\n-    fn get_section<I: Iterator<Item = String>>(\n-        file: &mut Enumerate<I>,\n-    ) -> Option<ConfigurationSection> {\n-        lazy_static! {\n-            static ref CONFIG_NAME_REGEX: regex::Regex =\n-                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"failed creating configuration pattern\");\n-            static ref CONFIG_VALUE_REGEX: regex::Regex =\n-                regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n-                    .expect(\"failed creating configuration value pattern\");\n-        }\n-\n-        loop {\n-            match file.next() {\n-                Some((i, line)) => {\n-                    if line.starts_with(\"```rust\") {\n-                        // Get the lines of the code block.\n-                        let lines: Vec<String> = file\n-                            .map(|(_i, l)| l)\n-                            .take_while(|l| !l.starts_with(\"```\"))\n-                            .collect();\n-                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n-\n-                        // +1 to translate to one-based indexing\n-                        // +1 to get to first line of code (line after \"```\")\n-                        let start_line = (i + 2) as u32;\n-\n-                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n-                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n-                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n-                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n-                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n-                    }\n-                }\n-                None => return None, // reached the end of the file\n-            }\n-        }\n-    }\n-}\n-\n-// This struct stores the information about code blocks in the configurations\n-// file, formats the code blocks, and prints formatting errors.\n-struct ConfigCodeBlock {\n-    config_name: Option<String>,\n-    config_value: Option<String>,\n-    code_block: Option<String>,\n-    code_block_start: Option<u32>,\n-}\n-\n-impl ConfigCodeBlock {\n-    fn new() -> ConfigCodeBlock {\n-        ConfigCodeBlock {\n-            config_name: None,\n-            config_value: None,\n-            code_block: None,\n-            code_block_start: None,\n-        }\n-    }\n-\n-    fn set_config_name(&mut self, name: Option<String>) {\n-        self.config_name = name;\n-        self.config_value = None;\n-    }\n-\n-    fn set_config_value(&mut self, value: Option<String>) {\n-        self.config_value = value;\n-    }\n-\n-    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n-        self.code_block = Some(code_block);\n-        self.code_block_start = Some(code_block_start);\n-    }\n-\n-    fn get_block_config(&self) -> Config {\n-        let mut config = Config::default();\n-        config.set().verbose(Verbosity::Quiet);\n-        if self.config_name.is_some() && self.config_value.is_some() {\n-            config.override_value(\n-                self.config_name.as_ref().unwrap(),\n-                self.config_value.as_ref().unwrap(),\n-            );\n-        }\n-        config\n-    }\n-\n-    fn code_block_valid(&self) -> bool {\n-        // We never expect to not have a code block.\n-        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n-\n-        // See if code block begins with #![rustfmt::skip].\n-        let fmt_skip = self\n-            .code_block\n-            .as_ref()\n-            .unwrap()\n-            .lines()\n-            .nth(0)\n-            .unwrap_or(\"\")\n-            == \"#![rustfmt::skip]\";\n-\n-        if self.config_name.is_none() && !fmt_skip {\n-            write_message(&format!(\n-                \"No configuration name for {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return false;\n-        }\n-        if self.config_value.is_none() && !fmt_skip {\n-            write_message(&format!(\n-                \"No configuration value for {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n-        if session.has_parsing_errors() {\n-            write_message(&format!(\n-                \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return true;\n-        }\n-\n-        false\n-    }\n-\n-    fn print_diff(&self, compare: Vec<Mismatch>) {\n-        let mut mismatches = HashMap::new();\n-        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n-        print_mismatches(mismatches, |line_num| {\n-            format!(\n-                \"\\nMismatch at {}:{}:\",\n-                CONFIGURATIONS_FILE_NAME,\n-                line_num + self.code_block_start.unwrap() - 1\n-            )\n-        });\n-    }\n-\n-    fn formatted_has_diff(&self, text: &str) -> bool {\n-        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n-        if !compare.is_empty() {\n-            self.print_diff(compare);\n-            return true;\n-        }\n-\n-        false\n-    }\n-\n-    // Return a bool indicating if formatting this code block is an idempotent\n-    // operation. This function also triggers printing any formatting failure\n-    // messages.\n-    fn formatted_is_idempotent(&self) -> bool {\n-        // Verify that we have all of the expected information.\n-        if !self.code_block_valid() {\n-            return false;\n-        }\n-\n-        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n-        let mut config = self.get_block_config();\n-        config.set().emit_mode(EmitMode::Stdout);\n-        let mut buf: Vec<u8> = vec![];\n-\n-        {\n-            let mut session = Session::new(config, Some(&mut buf));\n-            session.format(input).unwrap();\n-            if self.has_parsing_errors(&session) {\n-                return false;\n-            }\n-        }\n-\n-        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n-    }\n-\n-    // Extract a code block from the iterator. Behavior:\n-    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n-    // - One explicit configuration setting is supported per code block.\n-    // - Rust code blocks with no configuration setting are illegal and cause an\n-    //   assertion failure, unless the snippet begins with #![rustfmt::skip].\n-    // - Configuration names in Configurations.md must be in the form of\n-    //   \"## `NAME`\".\n-    // - Configuration values in Configurations.md must be in the form of\n-    //   \"#### `VALUE`\".\n-    fn extract<I: Iterator<Item = String>>(\n-        file: &mut Enumerate<I>,\n-        prev: Option<&ConfigCodeBlock>,\n-        hash_set: &mut HashSet<String>,\n-    ) -> Option<ConfigCodeBlock> {\n-        let mut code_block = ConfigCodeBlock::new();\n-        code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n-\n-        loop {\n-            match ConfigurationSection::get_section(file) {\n-                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n-                    code_block.set_code_block(block, start_line);\n-                    break;\n-                }\n-                Some(ConfigurationSection::ConfigName(name)) => {\n-                    assert!(\n-                        Config::is_valid_name(&name),\n-                        \"an unknown configuration option was found: {}\",\n-                        name\n-                    );\n-                    assert!(\n-                        hash_set.remove(&name),\n-                        \"multiple configuration guides found for option {}\",\n-                        name\n-                    );\n-                    code_block.set_config_name(Some(name));\n-                }\n-                Some(ConfigurationSection::ConfigValue(value)) => {\n-                    code_block.set_config_value(Some(value));\n-                }\n-                None => return None, // end of file was reached\n-            }\n-        }\n-\n-        Some(code_block)\n-    }\n-}\n-\n-#[test]\n-fn configuration_snippet_tests() {\n-    // Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n-    // entry for each Rust code block found.\n-    fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n-        let mut file_iter = BufReader::new(\n-            fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n-                .unwrap_or_else(|_| panic!(\"couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n-        )\n-        .lines()\n-        .map(Result::unwrap)\n-        .enumerate();\n-        let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n-        let mut hash_set = Config::hash_set();\n-\n-        while let Some(cb) =\n-            ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n-        {\n-            code_blocks.push(cb);\n-        }\n-\n-        for name in hash_set {\n-            if !Config::is_hidden_option(&name) {\n-                panic!(\"{} does not have a configuration guide\", name);\n-            }\n-        }\n-\n-        code_blocks\n-    }\n-\n-    let blocks = get_code_blocks();\n-    let failures = blocks\n-        .iter()\n-        .map(ConfigCodeBlock::formatted_is_idempotent)\n-        .fold(0, |acc, r| acc + (!r as u32));\n-\n-    // Display results.\n-    println!(\"Ran {} configurations tests.\", blocks.len());\n-    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n-}\n-\n struct TempFile {\n     path: PathBuf,\n }"}]}