{"sha": "c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNWZiYzVhMmNiNzJjMmM4MWI5MjU5YjNhM2ZmMjhhMWMzODEwYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-06T10:21:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-06T10:21:32Z"}, "message": "auto merge of #9593 : fhahn/rust/logging-unsafe-removal, r=alexcrichton\n\nThis pull request changes to memory layout of the `CrateMap` struct to use static slices instead of raw pointers. Most of the discussion took place [here](https://github.com/fhahn/rust/commit/63b5975efa10af7df3df0a50d8d7f9c8d5bcf9e9#L1R92) .\r\n\r\nThe memory layout of CrateMap changed, without bumping the version number in the struct. Another, more backward compatible, solution would be to keep the old code and increase the version number in the new struct. On the other hand, the `annihilate_fn` pointer was removed without bumping the version number recently.\r\n\r\nAt the moment, the stage0 compiler does not use the new memory layout, which would lead the segfaults during stage0 compilation, so I've added a dummy `iter_crate_map` function for stage0, which does nothing. Again, this could be avoided if we'd bump the version number in the struct and keep the old code.\r\n\r\nI'd like to use a normal `for` loop [here](https://github.com/fhahn/rust/compare/logging-unsafe-removal?expand=1#L1R109), \r\n\r\n        for child in children.iter() {\r\n            do_iter_crate_map(child, |x| f(x), visited);\r\n        }\r\n\r\n\r\nbut for some reason this only yields `error: unresolved enum variant, struct or const 'Some'` and I have no idea why.", "tree": {"sha": "12f29cf5da68d30c33993b2662fde932589ff19d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12f29cf5da68d30c33993b2662fde932589ff19d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "html_url": "https://github.com/rust-lang/rust/commit/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a623fd339bf420adcaf18b393b5891803f3044e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a623fd339bf420adcaf18b393b5891803f3044e8", "html_url": "https://github.com/rust-lang/rust/commit/a623fd339bf420adcaf18b393b5891803f3044e8"}, {"sha": "23176fc567086715aab062a24e2b68e1f54ce5ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/23176fc567086715aab062a24e2b68e1f54ce5ba", "html_url": "https://github.com/rust-lang/rust/commit/23176fc567086715aab062a24e2b68e1f54ce5ba"}], "stats": {"total": 567, "additions": 343, "deletions": 224}, "files": [{"sha": "16ac802ee157121419f2a7417b5bda6fd6f96d64", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "patch": "@@ -54,7 +54,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of};\n+use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -2911,9 +2911,10 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n-    let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n-    let maptype = Type::array(&elttype, (ccx.module_data.len() + 1) as u64);\n+pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n+    let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n+    let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n+    let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n     let map = do \"_rust_mod_map\".with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n@@ -2931,19 +2932,18 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n     }\n \n     for key in keys.iter() {\n-        let val = *ccx.module_data.find_equiv(key).unwrap();\n-        let s_const = C_cstr(ccx, *key);\n-        let s_ptr = p2i(ccx, s_const);\n-        let v_ptr = p2i(ccx, val);\n-        let elt = C_struct([s_ptr, v_ptr]);\n-        elts.push(elt);\n-    }\n-    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n-    elts.push(term);\n+            let val = *ccx.module_data.find_equiv(key).unwrap();\n+            let v_ptr = p2i(ccx, val);\n+            let elt = C_struct([\n+                C_estr_slice(ccx, *key),\n+                v_ptr\n+            ]);\n+            elts.push(elt);\n+    }\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     }\n-    return map;\n+    return (map, keys.len(), llsize_of_alloc(ccx, elttype));\n }\n \n \n@@ -2959,9 +2959,10 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     } else {\n         ~\"toplevel\"\n     };\n+\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let arrtype = Type::array(&int_type, n_subcrates as u64);\n-    let maptype = Type::struct_([Type::i32(), int_type, arrtype], false);\n+    let slicetype = Type::struct_([int_type, int_type], false);\n+    let maptype = Type::struct_([Type::i32(), slicetype, slicetype], false);\n     let map = do sym_name.with_c_str |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n@@ -2996,14 +2997,29 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n-    subcrates.push(C_int(ccx, 0));\n-\n     unsafe {\n-        let mod_map = create_module_map(ccx);\n+        let maptype = Type::array(&ccx.int_type, subcrates.len() as u64);\n+        let vec_elements = do \"_crate_map_child_vectors\".with_c_str |buf| {\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n+        };\n+        lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n+\n+        llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n+        let (mod_map, mod_count, mod_struct_size) = create_module_map(ccx);\n+\n         llvm::LLVMSetInitializer(map, C_struct(\n-            [C_i32(1),\n-             p2i(ccx, mod_map),\n-             C_array(ccx.int_type, subcrates)]));\n+            [C_i32(2),\n+             C_struct([\n+                p2i(ccx, mod_map),\n+                // byte size of the module map array, an entry consists of two integers\n+                C_int(ccx, ((mod_count * mod_struct_size) as int))\n+             ]),\n+             C_struct([\n+                p2i(ccx, vec_elements),\n+                // byte size of the subcrates array, an entry consists of an integer\n+                C_int(ccx, (subcrates.len() * llsize_of_alloc(ccx, ccx.int_type)) as int)\n+             ])\n+        ]));\n     }\n }\n "}, {"sha": "061c2e53c7c1717b0b5a32ee0a27d7ab68b8d001", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 235, "deletions": 117, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use container::MutableSet;\n+use hashmap::HashSet;\n+use option::{Some, None, Option};\n+use vec::ImmutableVector;\n \n+/// Imports for old crate map versions\n+use cast::transmute;\n use libc::c_char;\n use ptr;\n-use ptr::RawPtr;\n+use str::raw::from_c_str;\n use vec;\n-use hashmap::HashSet;\n-use container::MutableSet;\n \n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n@@ -27,35 +31,52 @@ extern {}\n extern {\n     #[weak_linkage]\n     #[link_name = \"_rust_crate_map_toplevel\"]\n-    static CRATE_MAP: CrateMap;\n+    static CRATE_MAP: CrateMap<'static>;\n }\n \n-pub struct ModEntry {\n+/// structs for old crate map versions\n+pub struct ModEntryV0 {\n     name: *c_char,\n     log_level: *mut u32\n }\n-struct CrateMapV0 {\n-    entries: *ModEntry,\n-    children: [*CrateMap, ..1]\n+pub struct CrateMapV0 {\n+    entries: *ModEntryV0,\n+    children: [*CrateMapV0, ..1]\n }\n \n-struct CrateMap {\n+pub struct CrateMapV1 {\n     version: i32,\n-    entries: *ModEntry,\n+    entries: *ModEntryV0,\n     /// a dynamically sized struct, where all pointers to children are listed adjacent\n     /// to the struct, terminated with NULL\n-    children: [*CrateMap, ..1]\n+    children: [*CrateMapV1, ..1]\n+}\n+\n+pub struct ModEntry<'self> {\n+    name: &'self str,\n+    log_level: *mut u32\n+}\n+\n+pub struct CrateMap<'self> {\n+    version: i32,\n+    entries: &'self [ModEntry<'self>],\n+    children: &'self [&'self CrateMap<'self>]\n }\n \n #[cfg(not(windows))]\n-pub fn get_crate_map() -> *CrateMap {\n-    &'static CRATE_MAP as *CrateMap\n+pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n+    let ptr: (*CrateMap) = &'static CRATE_MAP;\n+    if ptr.is_null() {\n+        return None;\n+    } else {\n+        return Some(&'static CRATE_MAP);\n+    }\n }\n \n #[cfg(windows)]\n #[fixed_stack_segment]\n #[inline(never)]\n-pub fn get_crate_map() -> *CrateMap {\n+pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n     use c_str::ToCStr;\n     use unstable::dynamic_lib::dl;\n \n@@ -67,157 +88,254 @@ pub fn get_crate_map() -> *CrateMap {\n         dl::close(module);\n         sym\n     };\n-\n-    sym as *CrateMap\n+    let ptr: (*CrateMap) = sym as *CrateMap;\n+    if ptr.is_null() {\n+        return None;\n+    } else {\n+        unsafe {\n+            return Some(transmute(sym));\n+        }\n+    }\n }\n \n-unsafe fn version(crate_map: *CrateMap) -> i32 {\n-    match (*crate_map).version {\n+fn version(crate_map: &CrateMap) -> i32 {\n+    match crate_map.version {\n+        2 => return 2,\n         1 => return 1,\n         _ => return 0\n     }\n }\n \n-unsafe fn entries(crate_map: *CrateMap) -> *ModEntry {\n-    match version(crate_map) {\n-        0 => {\n-            let v0 = crate_map as (*CrateMapV0);\n-            return (*v0).entries;\n-        }\n-        1 => return (*crate_map).entries,\n-        _ => fail2!(\"Unknown crate map version!\")\n-    }\n-}\n-\n-unsafe fn iterator(crate_map: *CrateMap) -> **CrateMap {\n-    match version(crate_map) {\n-        0 => {\n-            let v0 = crate_map as (*CrateMapV0);\n-            return vec::raw::to_ptr((*v0).children);\n-        }\n-        1 => return vec::raw::to_ptr((*crate_map).children),\n-        _ => fail2!(\"Unknown crate map version!\")\n+fn iter_module_map(mod_entries: &[ModEntry], f: &fn(&ModEntry)) {\n+    for entry in mod_entries.iter() {\n+        f(entry);\n     }\n }\n \n-unsafe fn iter_module_map(mod_entries: *ModEntry, f: &fn(*mut ModEntry)) {\n-    let mut curr = mod_entries;\n-\n+unsafe fn iter_module_map_v0(entries: *ModEntryV0, f: &fn(&ModEntry)) {\n+    let mut curr = entries;\n     while !(*curr).name.is_null() {\n-        f(curr as *mut ModEntry);\n+        let mod_entry = ModEntry { name: from_c_str((*curr).name), log_level: (*curr).log_level };\n+        f(&mod_entry);\n         curr = curr.offset(1);\n     }\n }\n \n-unsafe fn do_iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry),\n-                            visited: &mut HashSet<*CrateMap>) {\n-    if visited.insert(crate_map) {\n-        iter_module_map(entries(crate_map), |x| f(x));\n-        let child_crates = iterator(crate_map);\n-        do ptr::array_each(child_crates) |child| {\n-            do_iter_crate_map(child, |x| f(x), visited);\n+fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n+                            visited: &mut HashSet<*CrateMap<'a>>) {\n+    if visited.insert(crate_map as *CrateMap) {\n+        match version(crate_map) {\n+            2 => {\n+                let (entries, children) = (crate_map.entries, crate_map.children);\n+                iter_module_map(entries, |x| f(x));\n+                for child in children.iter() {\n+                    do_iter_crate_map(*child, |x| f(x), visited);\n+                }\n+            },\n+            // code for old crate map versions\n+            1 => unsafe {\n+                let v1: *CrateMapV1 = transmute(crate_map);\n+                iter_module_map_v0((*v1).entries, |x| f(x));\n+                let children = vec::raw::to_ptr((*v1).children);\n+                do ptr::array_each(children) |child| {\n+                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n+                }\n+            },\n+            0 => unsafe {\n+                let v0: *CrateMapV0 = transmute(crate_map);\n+                iter_module_map_v0((*v0).entries, |x| f(x));\n+                let children = vec::raw::to_ptr((*v0).children);\n+                do ptr::array_each(children) |child| {\n+                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n+                }\n+            },\n+            _ => fail2!(\"invalid crate map version\")\n         }\n     }\n }\n \n /// Iterates recursively over `crate_map` and all child crate maps\n-pub unsafe fn iter_crate_map(crate_map: *CrateMap, f: &fn(*mut ModEntry)) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n     //        way to do this\n-    let mut v: HashSet<*CrateMap> = HashSet::with_capacity_and_keys(0, 0, 32);\n+    let mut v: HashSet<*CrateMap<'a>> = HashSet::with_capacity_and_keys(0, 0, 32);\n     do_iter_crate_map(crate_map, f, &mut v);\n }\n \n-#[test]\n-fn iter_crate_map_duplicates() {\n-    use c_str::ToCStr;\n-    use cast::transmute;\n-\n-    struct CrateMapT3 {\n-        version: i32,\n-        entries: *ModEntry,\n-        children: [*CrateMap, ..3]\n-    }\n+#[cfg(test)]\n+mod tests {\n+    use rt::crate_map::{CrateMap, ModEntry, iter_crate_map};\n \n-    unsafe {\n-        let mod_name1 = \"c::m1\".to_c_str();\n+    #[test]\n+    fn iter_crate_map_duplicates() {\n         let mut level3: u32 = 3;\n \n-        let entries: ~[ModEntry] = ~[\n-            ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n-            ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n+        let entries = [\n+            ModEntry { name: \"c::m1\", log_level: &mut level3},\n         ];\n+\n         let child_crate = CrateMap {\n-            version: 1,\n-            entries: vec::raw::to_ptr(entries),\n-            children: [ptr::null()]\n+            version: 2,\n+            entries: entries,\n+            children: []\n         };\n \n-        let root_crate = CrateMapT3 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([ModEntry { name: ptr::null(), log_level: ptr::mut_null()}]),\n-            children: [&child_crate as *CrateMap, &child_crate as *CrateMap, ptr::null()]\n+        let root_crate = CrateMap {\n+            version: 2,\n+            entries: [],\n+            children: [&child_crate, &child_crate]\n         };\n \n         let mut cnt = 0;\n-        do iter_crate_map(transmute(&root_crate)) |entry| {\n-            assert!(*(*entry).log_level == 3);\n-            cnt += 1;\n+        unsafe {\n+            do iter_crate_map(&root_crate) |entry| {\n+                assert!(*entry.log_level == 3);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 1);\n         }\n-        assert!(cnt == 1);\n     }\n-}\n-\n-#[test]\n-fn iter_crate_map_follow_children() {\n-    use c_str::ToCStr;\n-    use cast::transmute;\n \n-    struct CrateMapT2 {\n-        version: i32,\n-        entries: *ModEntry,\n-        children: [*CrateMap, ..2]\n-    }\n-\n-    unsafe {\n-        let mod_name1 = \"c::m1\".to_c_str();\n-        let mod_name2 = \"c::m2\".to_c_str();\n+    #[test]\n+    fn iter_crate_map_follow_children() {\n         let mut level2: u32 = 2;\n         let mut level3: u32 = 3;\n         let child_crate2 = CrateMap {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n-                ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [ptr::null()]\n+            version: 2,\n+            entries: [\n+                ModEntry { name: \"c::m1\", log_level: &mut level2},\n+                ModEntry { name: \"c::m2\", log_level: &mut level3},\n+            ],\n+            children: []\n         };\n \n-        let child_crate1 = CrateMapT2 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 1},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [&child_crate2 as *CrateMap, ptr::null()]\n+        let child_crate1 = CrateMap {\n+            version: 2,\n+            entries: [\n+                ModEntry { name: \"t::f1\", log_level: &mut 1},\n+            ],\n+            children: [&child_crate2]\n         };\n \n-        let child_crate1_ptr: *CrateMap = transmute(&child_crate1);\n-        let root_crate = CrateMapT2 {\n-            version: 1,\n-            entries: vec::raw::to_ptr([\n-                ModEntry { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 0},\n-                ModEntry { name: ptr::null(), log_level: ptr::mut_null()}\n-            ]),\n-            children: [child_crate1_ptr, ptr::null()]\n+        let root_crate = CrateMap {\n+            version: 2,\n+            entries: [\n+                ModEntry { name: \"t::f2\", log_level: &mut 0},\n+            ],\n+            children: [&child_crate1]\n         };\n \n         let mut cnt = 0;\n-        do iter_crate_map(transmute(&root_crate)) |entry| {\n-            assert!(*(*entry).log_level == cnt);\n-            cnt += 1;\n+        unsafe {\n+            do iter_crate_map(&root_crate) |entry| {\n+                assert!(*entry.log_level == cnt);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 4);\n+        }\n+    }\n+\n+\n+    /// Tests for old crate map versions\n+    #[test]\n+    fn iter_crate_map_duplicates_v1() {\n+        use c_str::ToCStr;\n+        use cast::transmute;\n+        use ptr;\n+        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n+        use vec;\n+\n+        struct CrateMapT3 {\n+            version: i32,\n+            entries: *ModEntryV0,\n+            children: [*CrateMapV1, ..3]\n+        }\n+\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mut level3: u32 = 3;\n+\n+            let entries: ~[ModEntryV0] = ~[\n+                ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n+                ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+            ];\n+            let child_crate = CrateMapV1 {\n+                version: 1,\n+                entries: vec::raw::to_ptr(entries),\n+                children: [ptr::null()]\n+            };\n+\n+            let root_crate = CrateMapT3 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [&child_crate as *CrateMapV1, &child_crate as *CrateMapV1, ptr::null()]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*(*entry).log_level == 3);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn iter_crate_map_follow_children_v1() {\n+        use c_str::ToCStr;\n+        use cast::transmute;\n+        use ptr;\n+        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n+        use vec;\n+\n+        struct CrateMapT2 {\n+            version: i32,\n+            entries: *ModEntryV0,\n+            children: [*CrateMapV1, ..2]\n+        }\n+\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mod_name2 = \"c::m2\".to_c_str();\n+            let mut level2: u32 = 2;\n+            let mut level3: u32 = 3;\n+            let child_crate2 = CrateMapV1 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n+                    ModEntryV0 { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [ptr::null()]\n+            };\n+\n+            let child_crate1 = CrateMapT2 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 1},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [&child_crate2 as *CrateMapV1, ptr::null()]\n+            };\n+\n+            let child_crate1_ptr: *CrateMapV1 = transmute(&child_crate1);\n+            let root_crate = CrateMapT2 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 0},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [child_crate1_ptr, ptr::null()]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*(*entry).log_level == cnt);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 4);\n         }\n-        assert!(cnt == 4);\n     }\n }"}, {"sha": "8b8e2762381c10675d1ea8f15fb83f5f3bad53bb", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 70, "deletions": 85, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=c05fbc5a2cb72c2c81b9259b3a3ff28a1c3810b0", "patch": "@@ -14,13 +14,11 @@ use libc::{uintptr_t, exit};\n use option::{Some, None, Option};\n use rt;\n use rt::util::dumb_println;\n-use rt::crate_map::{ModEntry, iter_crate_map};\n-use rt::crate_map::get_crate_map;\n+use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n-use str::raw::from_c_str;\n use u32;\n use vec::ImmutableVector;\n-use cast::transmute;\n+#[cfg(test)] use cast::transmute;\n \n struct LogDirective {\n     name: Option<~str>,\n@@ -110,58 +108,52 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n \n /// Set the log level of an entry in the crate map depending on the vector\n /// of log directives\n-fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n+fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n     let mut longest_match = -1i;\n-    unsafe {\n-        for dir in dirs.iter() {\n-            match dir.name {\n-                None => {\n-                    if longest_match == -1 {\n-                        longest_match = 0;\n-                        new_lvl = dir.level;\n-                    }\n+    for dir in dirs.iter() {\n+        match dir.name {\n+            None => {\n+                if longest_match == -1 {\n+                    longest_match = 0;\n+                    new_lvl = dir.level;\n                 }\n-                Some(ref dir_name) => {\n-                    let name = from_c_str((*entry).name);\n-                    let len = dir_name.len() as int;\n-                    if name.starts_with(*dir_name) &&\n-                        len >= longest_match {\n-                        longest_match = len;\n-                        new_lvl = dir.level;\n-                    }\n+            }\n+            Some(ref dir_name) => {\n+                let name = entry.name;\n+                let len = dir_name.len() as int;\n+                if name.starts_with(*dir_name) &&\n+                    len >= longest_match {\n+                    longest_match = len;\n+                    new_lvl = dir.level;\n                 }\n-            };\n-        }\n-        *(*entry).log_level = new_lvl;\n+            }\n+        };\n     }\n+    unsafe { *entry.log_level = new_lvl; }\n     if longest_match >= 0 { return 1; } else { return 0; }\n }\n \n #[fixed_stack_segment] #[inline(never)]\n /// Set log level for every entry in crate_map according to the sepecification\n /// in settings\n-fn update_log_settings(crate_map: *u8, settings: ~str) {\n+fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     let mut dirs = ~[];\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n-            dumb_println(\"\\nCrate log map:\\n\");\n-            unsafe {\n-                do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n-                    dumb_println(\" \"+from_c_str((*entry).name));\n-                }\n-                exit(1);\n+        dumb_println(\"\\nCrate log map:\\n\");\n+            do iter_crate_map(crate_map) |entry| {\n+                dumb_println(\" \"+entry.name);\n             }\n+            unsafe { exit(1); }\n         }\n         dirs = parse_logging_spec(settings);\n     }\n \n     let mut n_matches: u32 = 0;\n-    unsafe {\n-        do iter_crate_map(transmute(crate_map)) |entry: *mut ModEntry| {\n-            let m = update_entry(dirs, entry);\n-            n_matches += m;\n-        }\n+    do iter_crate_map(crate_map) |entry| {\n+        let m = update_entry(dirs, entry);\n+        n_matches += m;\n     }\n \n     if n_matches < (dirs.len() as u32) {\n@@ -207,15 +199,25 @@ impl rt::io::Writer for StdErrLogger {\n pub fn init() {\n     use os;\n \n-    let crate_map = get_crate_map() as *u8;\n-\n     let log_spec = os::getenv(\"RUST_LOG\");\n-    match log_spec {\n-        Some(spec) => {\n-            update_log_settings(crate_map, spec);\n-        }\n-        None => {\n-            update_log_settings(crate_map, ~\"\");\n+    match get_crate_map() {\n+        Some(crate_map) => {\n+            match log_spec {\n+                Some(spec) => {\n+                    update_log_settings(crate_map, spec);\n+                }\n+                None => {\n+                    update_log_settings(crate_map, ~\"\");\n+                }\n+            }\n+        },\n+        _ => {\n+            match log_spec {\n+                Some(_) => {\n+                    dumb_println(\"warning: RUST_LOG set, but no crate map found.\");\n+                },\n+                None => {}\n+            }\n         }\n     }\n }\n@@ -291,88 +293,71 @@ fn parse_logging_spec_global() {\n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate1::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 2);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name:\"crate1::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 2);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_no_match() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate3::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n-            assert!(m == 0);\n-        }\n+        let entry= &ModEntry {name: \"crate3::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n+        assert!(m == 0);\n     }\n }\n \n #[test]\n fn update_entry_match_beginning() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate2::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 3);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name: \"crate2::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 3);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_match_beginning_longest_match() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3},\n                  LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate2::mod1\".with_c_str |ptr| {\n-            let entry = &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 4);\n-            assert!(m == 1);\n-        }\n+        let entry = &ModEntry {name: \"crate2::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 4);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_match_default() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: None, level: 3}\n                 ];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate1::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 2);\n-            assert!(m == 1);\n-        }\n-        do \"crate2::mod2\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 3);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name: \"crate1::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 2);\n+        assert!(m == 1);\n+        let entry= &ModEntry {name: \"crate2::mod2\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 3);\n+        assert!(m == 1);\n     }\n }"}]}