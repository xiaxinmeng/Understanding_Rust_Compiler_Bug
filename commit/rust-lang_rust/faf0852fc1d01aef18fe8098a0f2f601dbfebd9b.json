{"sha": "faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZjA4NTJmYzFkMDFhZWYxOGZlODA5OGEwZjJmNjAxZGJmZWJkOWI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-22T09:55:29Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-26T04:16:58Z"}, "message": "Resolve: fix #23880, a scoping bug\n\nThis fixes a bug in which items in a block are shadowed by local variables and type parameters that are in scope.\nIt is a [breaking-change]. For example, the following code breaks:\n\n```rust\nfn foo() {\n    let mut f = 1;\n    {\n        fn f() {}\n        f += 1; // This will now resolve to the function instead of the local variable\n    }\n}\n```\n\nAny breakage can be fixed by renaming the item that is no longer shadowed.", "tree": {"sha": "476dad97e14b84d094c8ae97bc9de7813e2db37a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476dad97e14b84d094c8ae97bc9de7813e2db37a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "html_url": "https://github.com/rust-lang/rust/commit/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54475e950cf3db909c4dec4a30c72f7636ab4e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/54475e950cf3db909c4dec4a30c72f7636ab4e07", "html_url": "https://github.com/rust-lang/rust/commit/54475e950cf3db909c4dec4a30c72f7636ab4e07"}], "stats": {"total": 108, "additions": 78, "deletions": 30}, "files": [{"sha": "ee1150933e123620b8f13d86602c84e5ffd762b8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "patch": "@@ -723,7 +723,7 @@ enum FallbackSuggestion {\n }\n \n #[derive(Copy, Clone)]\n-enum TypeParameters<'a> {\n+enum TypeParameters<'tcx, 'a> {\n     NoTypeParameters,\n     HasTypeParameters(// Type parameters.\n                       &'a Generics,\n@@ -733,13 +733,13 @@ enum TypeParameters<'a> {\n                       ParamSpace,\n \n                       // The kind of the rib used for type parameters.\n-                      RibKind),\n+                      RibKind<'tcx>),\n }\n \n // The rib kind controls the translation of local\n // definitions (`Def::Local`) to upvars (`Def::Upvar`).\n #[derive(Copy, Clone, Debug)]\n-enum RibKind {\n+enum RibKind<'a> {\n     // No translation needs to be applied.\n     NormalRibKind,\n \n@@ -758,6 +758,9 @@ enum RibKind {\n \n     // We're in a constant item. Can't refer to dynamic stuff.\n     ConstantItemRibKind,\n+\n+    // We passed through an anonymous module.\n+    AnonymousModuleRibKind(Module<'a>),\n }\n \n #[derive(Copy, Clone)]\n@@ -799,13 +802,13 @@ enum BareIdentifierPatternResolution {\n \n /// One local scope.\n #[derive(Debug)]\n-struct Rib {\n+struct Rib<'a> {\n     bindings: HashMap<Name, DefLike>,\n-    kind: RibKind,\n+    kind: RibKind<'a>,\n }\n \n-impl Rib {\n-    fn new(kind: RibKind) -> Rib {\n+impl<'a> Rib<'a> {\n+    fn new(kind: RibKind<'a>) -> Rib<'a> {\n         Rib {\n             bindings: HashMap::new(),\n             kind: kind,\n@@ -1180,13 +1183,13 @@ pub struct Resolver<'a, 'tcx: 'a> {\n \n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n-    value_ribs: Vec<Rib>,\n+    value_ribs: Vec<Rib<'a>>,\n \n     // The current set of local scopes, for types.\n-    type_ribs: Vec<Rib>,\n+    type_ribs: Vec<Rib<'a>>,\n \n     // The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib>,\n+    label_ribs: Vec<Rib<'a>>,\n \n     // The trait that the current context can refer to.\n     current_trait_ref: Option<(DefId, TraitRef)>,\n@@ -1304,6 +1307,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n     }\n \n+    fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n+        match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n+    }\n+\n     #[inline]\n     fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n         if !self.make_glob_map {\n@@ -2122,7 +2129,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn with_type_parameter_rib<F>(&mut self, type_parameters: TypeParameters, f: F)\n+    fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n         match type_parameters {\n@@ -2191,7 +2198,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_function(&mut self, rib_kind: RibKind, declaration: &FnDecl, block: &Block) {\n+    fn resolve_function(&mut self, rib_kind: RibKind<'a>, declaration: &FnDecl, block: &Block) {\n         // Create a value rib for the function.\n         self.value_ribs.push(Rib::new(rib_kind));\n \n@@ -2494,18 +2501,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_block(&mut self, block: &Block) {\n         debug!(\"(resolving block) entering block\");\n-        self.value_ribs.push(Rib::new(NormalRibKind));\n-\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        match orig_module.anonymous_children.borrow().get(&block.id) {\n-            None => {\n-                // Nothing to do.\n-            }\n-            Some(anonymous_module) => {\n-                debug!(\"(resolving block) found anonymous module, moving down\");\n-                self.current_module = anonymous_module;\n-            }\n+        let anonymous_module =\n+            orig_module.anonymous_children.borrow().get(&block.id).map(|module| *module);\n+\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.value_ribs.push(Rib::new(AnonymousModuleRibKind(anonymous_module)));\n+            self.type_ribs.push(Rib::new(AnonymousModuleRibKind(anonymous_module)));\n+            self.current_module = anonymous_module;\n+        } else {\n+            self.value_ribs.push(Rib::new(NormalRibKind));\n         }\n \n         // Check for imports appearing after non-item statements.\n@@ -2538,6 +2545,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !self.resolved {\n             self.current_module = orig_module;\n             self.value_ribs.pop();\n+            if let Some(_) = anonymous_module {\n+                self.type_ribs.pop();\n+            }\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -3072,7 +3082,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Def::Local(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind => {\n+                        NormalRibKind | AnonymousModuleRibKind(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -3120,7 +3130,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Def::TyParam(..) | Def::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n+                        NormalRibKind | MethodRibKind | ClosureRibKind(..) |\n+                        AnonymousModuleRibKind(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {\n@@ -3271,13 +3282,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         namespace: Namespace)\n                                         -> Option<LocalDef> {\n         // Check the local set of ribs.\n-        let (name, ribs) = match namespace {\n-            ValueNS => (ident.name, &self.value_ribs),\n-            TypeNS => (ident.unhygienic_name, &self.type_ribs),\n-        };\n+        let name = match namespace { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n \n-        for (i, rib) in ribs.iter().enumerate().rev() {\n-            if let Some(def_like) = rib.bindings.get(&name).cloned() {\n+        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n+            if let Some(def_like) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n                 match def_like {\n                     DlDef(def) => {\n                         debug!(\"(resolving path in local ribs) resolved `{}` to {:?} at {}\",\n@@ -3297,6 +3305,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n+\n+            if let AnonymousModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n+                if let Success((target, _)) = self.resolve_name_in_module(module,\n+                                                                          ident.unhygienic_name,\n+                                                                          namespace,\n+                                                                          PathSearch,\n+                                                                          true) {\n+                    if let Some(def) = target.binding.def() {\n+                        return Some(LocalDef::from_def(def));\n+                    }\n+                }\n+            }\n         }\n \n         None"}, {"sha": "36604042d0f253162de6a1cf87e63d19ec3c975b", "filename": "src/test/run-pass/lexical-scoping.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b/src%2Ftest%2Frun-pass%2Flexical-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf0852fc1d01aef18fe8098a0f2f601dbfebd9b/src%2Ftest%2Frun-pass%2Flexical-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flexical-scoping.rs?ref=faf0852fc1d01aef18fe8098a0f2f601dbfebd9b", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that items in subscopes can shadow type parameters and local variables (see issue #23880).\n+\n+#![allow(unused)]\n+struct Foo<X> { x: Box<X> }\n+impl<Bar> Foo<Bar> {\n+    fn foo(&self) {\n+        type Bar = i32;\n+        let _: Bar = 42;\n+    }\n+}\n+\n+fn main() {\n+    let f = 1;\n+    {\n+        fn f() {}\n+        f();\n+    }\n+}"}]}