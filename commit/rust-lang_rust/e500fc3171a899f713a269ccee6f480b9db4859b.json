{"sha": "e500fc3171a899f713a269ccee6f480b9db4859b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MDBmYzMxNzFhODk5ZjcxM2EyNjljY2VlNmY0ODBiOWRiNDg1OWI=", "commit": {"author": {"name": "Artyom Pavlov", "email": "newpavlov@gmail.com", "date": "2019-08-20T10:08:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-20T10:08:57Z"}, "message": "Merge branch 'master' into redox_builder", "tree": {"sha": "8aa95c5dd723ddc09ffbe724c44cb701f8bde7e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aa95c5dd723ddc09ffbe724c44cb701f8bde7e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e500fc3171a899f713a269ccee6f480b9db4859b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdW8a5CRBK7hj4Ov3rIwAAdHIIAG3mktfXkinmQknbcTdOrd/+\ng/eW+F0sSZ1jq3TvpgZ3C121/Y16be5hZO918Uw0aqRWc3aODCLDx7U+6BzFq8mz\nz5wLTSNUxrTpS24En7lpXV6AKz0Qkz/iMC+hb4jYDcg3c02WezfxfpiudUim1A/G\n4sYOqxonKaNZvBfrvBBZQvwG2RB8ZTFUo8yMhON0/XDJ1rCF0zFRCQEkPPu1EILR\n/UuLfKmfaCmDpVi4MaKvTEYCmSY8qAW+MECErP7tVWOI7vz/zdBhRiHue/5cyBFZ\nBUCXfxcGhI/RWAePMQi0rM+/zBieNkLlWW53heDNInj8xAe74SdLyhl8pWq17+s=\n=+AX6\n-----END PGP SIGNATURE-----\n", "payload": "tree 8aa95c5dd723ddc09ffbe724c44cb701f8bde7e5\nparent 34c9f8c6490bb1179c504bccd51b2827c05f10db\nparent 7858dc237d70fc0c5a31eb528dfab1ad0baf6a27\nauthor Artyom Pavlov <newpavlov@gmail.com> 1566295737 +0000\ncommitter GitHub <noreply@github.com> 1566295737 +0000\n\nMerge branch 'master' into redox_builder"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e500fc3171a899f713a269ccee6f480b9db4859b", "html_url": "https://github.com/rust-lang/rust/commit/e500fc3171a899f713a269ccee6f480b9db4859b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e500fc3171a899f713a269ccee6f480b9db4859b/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34c9f8c6490bb1179c504bccd51b2827c05f10db", "url": "https://api.github.com/repos/rust-lang/rust/commits/34c9f8c6490bb1179c504bccd51b2827c05f10db", "html_url": "https://github.com/rust-lang/rust/commit/34c9f8c6490bb1179c504bccd51b2827c05f10db"}, {"sha": "7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27", "html_url": "https://github.com/rust-lang/rust/commit/7858dc237d70fc0c5a31eb528dfab1ad0baf6a27"}], "stats": {"total": 8022, "additions": 4795, "deletions": 3227}, "files": [{"sha": "2412d5e9627ffcd67790149007f17d7464d30bde", "filename": "Cargo.lock", "status": "modified", "additions": 1895, "deletions": 1896, "changes": 3791, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e500fc3171a899f713a269ccee6f480b9db4859b"}, {"sha": "dfd8e9db3c5c9cacb236c7d1cacc84791649920f", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -70,7 +70,7 @@ for details on how to format and write long error codes.\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n   [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n-  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n+  [librustc_plugin_impl](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks."}, {"sha": "8ebacb44d37cc2151f4883020e499d23f9bab0ef", "filename": "src/doc/unstable-book/src/language-features/or-patterns.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,36 @@\n+# `or_patterns`\n+\n+The tracking issue for this feature is: [#54883]\n+\n+[#54883]: https://github.com/rust-lang/rust/issues/54883\n+\n+------------------------\n+\n+The `or_pattern` language feature allows `|` to be arbitrarily nested within\n+a pattern, for example, `Some(A(0) | B(1 | 2))` becomes a valid pattern.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(or_patterns)]\n+\n+pub enum Foo {\n+    Bar,\n+    Baz,\n+    Quux,\n+}\n+\n+pub fn example(maybe_foo: Option<Foo>) {\n+    match maybe_foo {\n+        Some(Foo::Bar | Foo::Baz) => {\n+            println!(\"The value contained `Bar` or `Baz`\");\n+        }\n+        Some(_) => {\n+            println!(\"The value did not contain `Bar` or `Baz`\");\n+        }\n+        None => {\n+            println!(\"The value was `None`\");\n+        }\n+    }\n+}\n+```"}, {"sha": "53e8393ec52e462a8a7d1bbcae839dbd91b4d3c1", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -18,7 +18,7 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n A plugin is a dynamic library crate with a designated *registrar* function that\n registers extensions with `rustc`. Other crates can load these extensions using\n the crate attribute `#![plugin(...)]`.  See the\n-`rustc_plugin` documentation for more about the\n+`rustc_driver::plugin` documentation for more about the\n mechanics of defining and loading a plugin.\n \n If present, arguments passed as `#![plugin(foo(... args ...))]` are not\n@@ -54,13 +54,13 @@ that implements Roman numeral integer literals.\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<dyn MacResult + 'static> {\n@@ -180,11 +180,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n+extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");"}, {"sha": "c61e3183409f267fcf83a9565ece1b58efdd096f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -91,8 +91,10 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n+use crate::alloc::{self, Global, Alloc};\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -121,6 +123,34 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Constructs a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe {\n+            Global.alloc(layout)\n+                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+        };\n+        Box(ptr.cast().into())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -130,6 +160,111 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<[T]> {\n+    /// Constructs a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+}\n+\n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Converts to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///"}, {"sha": "7315963cc8b1dd6db5128d0a7c3ab8d6c04f2a8a", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1199,6 +1199,31 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            self.head = self.wrap_sub(self.head, 1);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n+        }\n+    }\n+\n     /// Prepends an element to the `VecDeque`.\n     ///\n     /// # Examples\n@@ -1243,38 +1268,13 @@ impl<T> VecDeque<T> {\n         unsafe { self.buffer_write(head, value) }\n     }\n \n-    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n-    /// it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1);\n-    /// buf.push_back(3);\n-    /// assert_eq!(buf.pop_back(), Some(3));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pop_back(&mut self) -> Option<T> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n-        }\n-    }\n-\n     #[inline]\n     fn is_contiguous(&self) -> bool {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n-    /// last element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it,\n+    /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1288,28 +1288,28 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_back(0), None);\n+    /// assert_eq!(buf.swap_remove_front(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf, [3, 2]);\n+    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_back()\n+        self.pop_front()\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it,\n-    /// replacing it with the first element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n+    /// last element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1323,24 +1323,24 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_front(0), None);\n+    /// assert_eq!(buf.swap_remove_back(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf, [2, 1]);\n+    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n-            self.swap(index, 0);\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_front()\n+        self.pop_back()\n     }\n \n     /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices"}, {"sha": "2b222caf13f3d48c3333aa35ff78a01e1ced57b1", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -327,6 +327,37 @@ impl<T> Rc<T> {\n         }))\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -377,6 +408,118 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Converts to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -560,13 +703,46 @@ impl<T: ?Sized> Rc<T> {\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n             unsafe {\n-                Some(&mut this.ptr.as_mut().value)\n+                Some(Rc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Rc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(String::new());\n+    /// unsafe {\n+    ///     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().value\n+    }\n+\n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Rc`s point to the same value (not\n@@ -704,11 +880,11 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n     ) -> *mut RcBox<T> {\n@@ -737,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n         )\n@@ -768,7 +944,7 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n         )"}, {"sha": "9ffc1673e5ab8e43954374a2f68a70a935c69baa", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 181, "deletions": 9, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -107,10 +107,6 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// // a, b, and foo are all Arcs that point to the same memory location\n /// ```\n ///\n-/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n-/// the meaning of the code. In the example above, this syntax makes it easier to see that\n-/// this code is creating a new reference rather than copying the whole content of foo.\n-///\n /// ## `Deref` behavior\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n@@ -311,6 +307,37 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::into_raw_non_null(x))\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -361,6 +388,118 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Converts to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -593,11 +732,11 @@ impl<T: ?Sized> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n     ) -> *mut ArcInner<T> {\n@@ -625,7 +764,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n         )\n@@ -656,7 +795,7 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n         )\n@@ -945,13 +1084,46 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n+                Some(Arc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Arc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(String::new());\n+    /// unsafe {\n+    ///     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().data\n+    }\n+\n     /// Determine whether this is the unique reference (including weak refs) to\n     /// the underlying data.\n     ///"}, {"sha": "3521dd799795672ab379af6cc25dab307f8ee91e", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -122,6 +122,14 @@ impl<T: ?Sized> Unique<T> {\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n+\n+    /// Casts to a pointer of another type.\n+    #[inline]\n+    pub const fn cast<U>(self) -> Unique<U> {\n+        unsafe {\n+            Unique::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]"}, {"sha": "5c543165bc2b19da1a271b65aa7331da77300b00", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -468,6 +468,14 @@ pub enum ProcMacro {\n }\n \n impl ProcMacro {\n+    pub fn name(&self) -> &'static str {\n+        match self {\n+            ProcMacro::CustomDerive { trait_name, .. } => trait_name,\n+            ProcMacro::Attr { name, .. } => name,\n+            ProcMacro::Bang { name, ..} => name\n+        }\n+    }\n+\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],"}, {"sha": "0dad2dda837b53f236a86499a3fa97db7af725cb", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -140,6 +140,11 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n+            PatKind::Or(ref pats) => {\n+                let branches: Vec<_> = pats.iter().map(|p| self.pat(p, pred)).collect();\n+                self.add_ast_node(pat.hir_id.local_id, &branches)\n+            }\n+\n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);"}, {"sha": "c91ad7858d0bb742e6870fded4f8f11dd2a2f850", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,4 @@\n use crate::ty::{self, TyCtxt};\n-use crate::hir::map::definitions::FIRST_FREE_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt;\n use std::u32;\n@@ -102,31 +101,6 @@ newtype_index! {\n     }\n }\n \n-impl DefIndex {\n-    // Proc macros from a proc-macro crate have a kind of virtual DefIndex. This\n-    // function maps the index of the macro within the crate (which is also the\n-    // index of the macro in the CrateMetadata::proc_macros array) to the\n-    // corresponding DefIndex.\n-    pub fn from_proc_macro_index(proc_macro_index: usize) -> DefIndex {\n-        // DefIndex for proc macros start from FIRST_FREE_DEF_INDEX,\n-        // because the first FIRST_FREE_DEF_INDEX indexes are reserved\n-        // for internal use.\n-        let def_index = DefIndex::from(\n-            proc_macro_index.checked_add(FIRST_FREE_DEF_INDEX)\n-                .expect(\"integer overflow adding `proc_macro_index`\"));\n-        assert!(def_index != CRATE_DEF_INDEX);\n-        def_index\n-    }\n-\n-    // This function is the reverse of from_proc_macro_index() above.\n-    pub fn to_proc_macro_index(self: DefIndex) -> usize {\n-        self.index().checked_sub(FIRST_FREE_DEF_INDEX)\n-            .unwrap_or_else(|| {\n-                bug!(\"using local index {:?} as proc-macro index\", self)\n-            })\n-    }\n-}\n-\n impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n "}, {"sha": "fa274f831b7950267332d6440b6c8cc86567ce96", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -433,6 +433,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n         LifetimeName::Static |\n         LifetimeName::Error |\n         LifetimeName::Implicit |\n+        LifetimeName::ImplicitObjectLifetimeDefault |\n         LifetimeName::Underscore => {}\n     }\n }\n@@ -709,6 +710,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&field.pat)\n             }\n         }\n+        PatKind::Or(ref pats) => walk_list!(visitor, visit_pat, pats),\n         PatKind::Tuple(ref tuple_elements, _) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }"}, {"sha": "7ec321061372782c16a3330fb026d1a71339ca7d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -72,7 +72,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -322,7 +322,7 @@ enum ParenthesizedGenericArgs {\n /// `resolve_lifetime` module. Often we \"fallthrough\" to that code by generating\n /// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n /// everything into HIR lowering.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum AnonymousLifetimeMode {\n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n@@ -715,10 +715,16 @@ impl<'a> LoweringContext<'a> {\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         op: impl FnOnce(&mut Self) -> R,\n     ) -> R {\n+        debug!(\n+            \"with_anonymous_lifetime_mode(anonymous_lifetime_mode={:?})\",\n+            anonymous_lifetime_mode,\n+        );\n         let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n         self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n         let result = op(self);\n         self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n+        debug!(\"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n+               old_anonymous_lifetime_mode);\n         result\n     }\n \n@@ -1033,13 +1039,14 @@ impl<'a> LoweringContext<'a> {\n     /// ```\n     ///\n     /// returns a `hir::TypeBinding` representing `Item`.\n-    fn lower_assoc_ty_constraint(&mut self,\n-                                 c: &AssocTyConstraint,\n-                                 itctx: ImplTraitContext<'_>)\n-                                 -> hir::TypeBinding {\n-        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", c, itctx);\n+    fn lower_assoc_ty_constraint(\n+        &mut self,\n+        constraint: &AssocTyConstraint,\n+        itctx: ImplTraitContext<'_>,\n+    ) -> hir::TypeBinding {\n+        debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n-        let kind = match c.kind {\n+        let kind = match constraint.kind {\n             AssocTyConstraintKind::Equality { ref ty } => hir::TypeBindingKind::Equality {\n                 ty: self.lower_ty(ty, itctx)\n             },\n@@ -1094,15 +1101,15 @@ impl<'a> LoweringContext<'a> {\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n                         ExpnId::root(),\n-                        DUMMY_SP\n+                        constraint.span,\n                     );\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let ty = this.lower_ty(\n                             &Ty {\n                                 id: this.sess.next_node_id(),\n                                 node: TyKind::ImplTrait(impl_trait_node_id, bounds.clone()),\n-                                span: DUMMY_SP,\n+                                span: constraint.span,\n                             },\n                             itctx,\n                         );\n@@ -1124,10 +1131,10 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         hir::TypeBinding {\n-            hir_id: self.lower_node_id(c.id),\n-            ident: c.ident,\n+            hir_id: self.lower_node_id(constraint.id),\n+            ident: constraint.ident,\n             kind,\n-            span: c.span,\n+            span: constraint.span,\n         }\n     }\n \n@@ -1355,6 +1362,13 @@ impl<'a> LoweringContext<'a> {\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext<'_>) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n+        debug!(\n+            \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n+            fn_def_id,\n+            opaque_ty_node_id,\n+            span,\n+        );\n+\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1382,6 +1396,14 @@ impl<'a> LoweringContext<'a> {\n             &hir_bounds,\n         );\n \n+        debug!(\n+            \"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,\n+        );\n+\n+        debug!(\n+            \"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,\n+        );\n+\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -1397,7 +1419,7 @@ impl<'a> LoweringContext<'a> {\n                 origin: hir::OpaqueTyOrigin::FnReturn,\n             };\n \n-            trace!(\"exist ty from impl trait def-index: {:#?}\", opaque_ty_def_index);\n+            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n             let opaque_ty_id = lctx.generate_opaque_type(\n                 opaque_ty_node_id,\n                 opaque_ty_item,\n@@ -1445,6 +1467,13 @@ impl<'a> LoweringContext<'a> {\n         parent_index: DefIndex,\n         bounds: &hir::GenericBounds,\n     ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        debug!(\n+            \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n+             parent_index={:?}, \\\n+             bounds={:#?})\",\n+            opaque_ty_id, parent_index, bounds,\n+        );\n+\n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n@@ -1532,6 +1561,11 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     }\n                     hir::LifetimeName::Param(_) => lifetime.name,\n+\n+                    // Refers to some other lifetime that is \"in\n+                    // scope\" within the type.\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n+\n                     hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n                 };\n \n@@ -2182,6 +2216,14 @@ impl<'a> LoweringContext<'a> {\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FunctionRetTy {\n+        debug!(\n+            \"lower_async_fn_ret_ty(\\\n+             output={:?}, \\\n+             fn_def_id={:?}, \\\n+             opaque_ty_node_id={:?})\",\n+            output, fn_def_id, opaque_ty_node_id,\n+        );\n+\n         let span = output.span();\n \n         let opaque_ty_span = self.mark_span_with_reason(\n@@ -2264,6 +2306,8 @@ impl<'a> LoweringContext<'a> {\n                 ),\n             );\n \n+            debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n+\n             // Calculate all the lifetimes that should be captured\n             // by the opaque type. This should include all in-scope\n             // lifetime parameters, including those defined in-band.\n@@ -2512,6 +2556,12 @@ impl<'a> LoweringContext<'a> {\n                     hir::LifetimeName::Implicit\n                         | hir::LifetimeName::Underscore\n                         | hir::LifetimeName::Static => hir::ParamName::Plain(lt.name.ident()),\n+                    hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                        span_bug!(\n+                            param.ident.span,\n+                            \"object-lifetime-default should not occur here\",\n+                        );\n+                    }\n                     hir::LifetimeName::Error => ParamName::Error,\n                 };\n \n@@ -2524,15 +2574,6 @@ impl<'a> LoweringContext<'a> {\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n-                // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n-                // Instead, use `gensym(\"Self\")` to create a distinct name that looks the same.\n-                let ident = if param.ident.name == kw::SelfUpper {\n-                    param.ident.gensym()\n-                } else {\n-                    param.ident\n-                };\n-\n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     let params = self.lower_param_bounds(add_bounds, itctx.reborrow()).into_iter();\n@@ -2551,7 +2592,7 @@ impl<'a> LoweringContext<'a> {\n                                           .next(),\n                 };\n \n-                (hir::ParamName::Plain(ident), kind)\n+                (hir::ParamName::Plain(param.ident), kind)\n             }\n             GenericParamKind::Const { ref ty } => {\n                 (hir::ParamName::Plain(param.ident), hir::GenericParamKind::Const {\n@@ -2669,6 +2710,9 @@ impl<'a> LoweringContext<'a> {\n                 let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                 hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n+            PatKind::Or(ref pats) => {\n+                hir::PatKind::Or(pats.iter().map(|x| self.lower_pat(x)).collect())\n+            }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -3261,7 +3305,13 @@ impl<'a> LoweringContext<'a> {\n             AnonymousLifetimeMode::PassThrough => {}\n         }\n \n-        self.new_implicit_lifetime(span)\n+        let r = hir::Lifetime {\n+            hir_id: self.next_id(),\n+            span,\n+            name: hir::LifetimeName::ImplicitObjectLifetimeDefault,\n+        };\n+        debug!(\"elided_dyn_bound: r={:?}\", r);\n+        r\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {"}, {"sha": "d725afa40521253843e70072e0abf35324f22f9b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -74,7 +74,7 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n-    fn visit_macro_invoc(&mut self, id: NodeId) {\n+    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }"}, {"sha": "6dc3c7038f5696c625ae4601e4eb9a634d0ba40e", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -411,10 +411,6 @@ impl Definitions {\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n-    ///\n-    /// After the initial definitions are created the first `FIRST_FREE_DEF_INDEX` indexes\n-    /// are taken, so the \"user\" indexes will be allocated starting with `FIRST_FREE_DEF_INDEX`\n-    /// in ascending order.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -589,19 +585,6 @@ impl DefPathData {\n     }\n }\n \n-/// Evaluates to the number of tokens passed to it.\n-///\n-/// Logarithmic counting: every one or two recursive expansions, the number of\n-/// tokens to count is divided by two, instead of being reduced by one.\n-/// Therefore, the recursion depth is the binary logarithm of the number of\n-/// tokens to count, and the expanded tree is likewise very small.\n-macro_rules! count {\n-    ()                     => (0usize);\n-    ($one:tt)              => (1usize);\n-    ($($pairs:tt $_p:tt)*) => (count!($($pairs)*) << 1usize);\n-    ($odd:tt $($rest:tt)*) => (count!($($rest)*) | 1usize);\n-}\n-\n // We define the GlobalMetaDataKind enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n // the corresponding DefIndices in the DefTable.\n@@ -614,8 +597,6 @@ macro_rules! define_global_metadata_kind {\n             $($variant),*\n         }\n \n-        pub const FIRST_FREE_DEF_INDEX: usize = 1 + count!($($variant)*);\n-\n         impl GlobalMetaDataKind {\n             fn allocate_def_indices(definitions: &mut Definitions) {\n                 $({"}, {"sha": "983048188527fd12f9e34aeaaa9050982ac88cc0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -221,6 +221,19 @@ pub enum LifetimeName {\n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n+    /// Implicit lifetime in a context like `dyn Foo`. This is\n+    /// distinguished from implicit lifetimes elsewhere because the\n+    /// lifetime that they default to must appear elsewhere within the\n+    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// don't have to create a parameter for them. That is, `impl\n+    /// Trait<Item = &u32>` expands to an opaque type like `type\n+    /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n+    /// dyn Bar>` expands to `type Foo = impl Trait<Item = dyn Bar +\n+    /// 'static>`. The latter uses `ImplicitObjectLifetimeDefault` so\n+    /// that surrounding code knows not to create a lifetime\n+    /// parameter.\n+    ImplicitObjectLifetimeDefault,\n+\n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n@@ -235,7 +248,9 @@ pub enum LifetimeName {\n impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            LifetimeName::Implicit | LifetimeName::Error => Ident::invalid(),\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+                | LifetimeName::Implicit\n+                | LifetimeName::Error => Ident::invalid(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n             LifetimeName::Param(param_name) => param_name.ident(),\n@@ -244,7 +259,9 @@ impl LifetimeName {\n \n     pub fn is_elided(&self) -> bool {\n         match self {\n-            LifetimeName::Implicit | LifetimeName::Underscore => true,\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code\n@@ -881,6 +898,7 @@ impl Pat {\n             PatKind::TupleStruct(_, ref s, _) | PatKind::Tuple(ref s, _) => {\n                 s.iter().all(|p| p.walk_(it))\n             }\n+            PatKind::Or(ref pats) => pats.iter().all(|p| p.walk_(it)),\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 s.walk_(it)\n             }\n@@ -975,6 +993,10 @@ pub enum PatKind {\n     /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(HirVec<P<Pat>>),\n+\n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n "}, {"sha": "632a13f9183b2c7c7f3b0feb172497cfd54f6972", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1687,6 +1687,9 @@ impl<'a> State<'a> {\n                 self.s.space();\n                 self.s.word(\"}\");\n             }\n+            PatKind::Or(ref pats) => {\n+                self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(&p));\n+            }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen();\n                 if let Some(ddpos) = ddpos {"}, {"sha": "84687b8cab5c0b9160103167a97ab4a149c7efe6", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1329,15 +1329,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(did);\n                     // Account for the case where `did` corresponds to `Self`, which doesn't have\n                     // the expected type argument.\n-                    if !param.is_self() {\n+                    if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n                         hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "c9fd3392a962d2df8e4f22b663576f51ac3348d2", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -127,8 +127,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n-             param_env={:?})\",\n-            value, parent_def_id, body_id, param_env,\n+             param_env={:?}, value_span={:?})\",\n+            value, parent_def_id, body_id, param_env, value_span,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -1108,9 +1108,11 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         // Use the same type variable if the exact same opaque type appears more\n         // than once in the return type (e.g., if it's passed to a type alias).\n         if let Some(opaque_defn) = self.opaque_types.get(&def_id) {\n+            debug!(\"instantiate_opaque_types: returning concrete ty {:?}\", opaque_defn.concrete_ty);\n             return opaque_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n+        debug!(\"fold_opaque_ty {:?} {:?}\", self.value_span, span);\n         let ty_var = infcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n "}, {"sha": "73ca981bbe868513cebb0039080d23097c323509", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1290,6 +1290,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 }\n             }\n \n+            PatKind::Or(ref pats) => {\n+                for pat in pats {\n+                    self.cat_pattern_(cmt.clone(), &pat, op)?;\n+                }\n+            }\n+\n             PatKind::Binding(.., Some(ref subpat)) => {\n                 self.cat_pattern_(cmt, &subpat, op)?;\n             }"}, {"sha": "f5b0af61693be6eba33db255fedb9b9a45f9065c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -5,6 +5,8 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n+// ignore-tidy-filelength\n+\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n@@ -556,6 +558,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n+        debug!(\"visit_ty: ty.node={:?}\", ty.node);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -585,11 +588,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.is_in_fn_syntax = was_in_fn_syntax;\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n+                debug!(\"visit_ty: TraitObject(bounds={:?}, lifetime={:?})\", bounds, lifetime);\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n                 match lifetime.name {\n                     LifetimeName::Implicit => {\n+                        // For types like `dyn Foo`, we should\n+                        // generate a special form of elided.\n+                        span_bug!(\n+                            ty.span,\n+                            \"object-lifetime-default expected, not implict\",\n+                        );\n+                    }\n+                    LifetimeName::ImplicitObjectLifetimeDefault => {\n                         // If the user does not write *anything*, we\n                         // use the object lifetime defaulting\n                         // rules. So e.g., `Box<dyn Debug>` becomes\n@@ -897,6 +909,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"visit_lifetime(lifetime_ref={:?})\", lifetime_ref);\n         if lifetime_ref.is_elided() {\n             self.resolve_elided_lifetimes(vec![lifetime_ref]);\n             return;\n@@ -1911,6 +1924,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+        debug!(\n+            \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n+            res,\n+            depth,\n+            generic_args,\n+        );\n+\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1964,6 +1984,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             _ => None,\n         };\n \n+        debug!(\"visit_segment_args: type_def_id={:?}\", type_def_id);\n+\n+        // Compute a vector of defaults, one for each type parameter,\n+        // per the rules given in RFCs 599 and 1156. Example:\n+        //\n+        // ```rust\n+        // struct Foo<'a, T: 'a, U> { }\n+        // ```\n+        //\n+        // If you have `Foo<'x, dyn Bar, dyn Baz>`, we want to default\n+        // `dyn Bar` to `dyn Bar + 'x` (because of the `T: 'a` bound)\n+        // and `dyn Baz` to `dyn Baz + 'static` (because there is no\n+        // such bound).\n+        //\n+        // Therefore, we would compute `object_lifetime_defaults` to a\n+        // vector like `['x, 'static]`. Note that the vector only\n+        // includes type parameters.\n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n             let in_body = {\n                 let mut scope = self.scope;\n@@ -2003,6 +2040,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             .collect()\n                     })\n             };\n+            debug!(\"visit_segment_args: unsubst={:?}\", unsubst);\n             unsubst\n                 .iter()\n                 .map(|set| match *set {\n@@ -2023,6 +2061,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 .collect()\n         });\n \n+        debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n+\n         let mut i = 0;\n         for arg in &generic_args.args {\n             match arg {\n@@ -2045,8 +2085,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n+        // Hack: when resolving the type `XX` in binding like `dyn\n+        // Foo<'b, Item = XX>`, the current object-lifetime default\n+        // would be to examine the trait `Foo` to check whether it has\n+        // a lifetime bound declared on `Item`. e.g., if `Foo` is\n+        // declared like so, then the default object lifetime bound in\n+        // `XX` should be `'b`:\n+        //\n+        // ```rust\n+        // trait Foo<'a> {\n+        //   type Item: 'a;\n+        // }\n+        // ```\n+        //\n+        // but if we just have `type Item;`, then it would be\n+        // `'static`. However, we don't get all of this logic correct.\n+        //\n+        // Instead, we do something hacky: if there are no lifetime parameters\n+        // to the trait, then we simply use a default object lifetime\n+        // bound of `'static`, because there is no other possibility. On the other hand,\n+        // if there ARE lifetime parameters, then we require the user to give an\n+        // explicit bound for now.\n+        //\n+        // This is intended to leave room for us to implement the\n+        // correct behavior in the future.\n+        let has_lifetime_parameter = generic_args\n+            .args\n+            .iter()\n+            .any(|arg| match arg {\n+                GenericArg::Lifetime(_) => true,\n+                _ => false,\n+            });\n+\n+        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n         for b in &generic_args.bindings {\n-            self.visit_assoc_type_binding(b);\n+            let scope = Scope::ObjectLifetimeDefault {\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(Region::Static)\n+                },\n+                s: self.scope,\n+            };\n+            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n         }\n     }\n \n@@ -2347,6 +2428,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+        debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n+\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2539,6 +2622,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n+        debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let lifetime = loop {\n@@ -2638,6 +2722,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n+                            self.tcx.sess.delay_span_bug(\n+                                lt.span,\n+                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n+                                 outside of an object type\",\n+                            )\n+                        }\n                         hir::LifetimeName::Error => {\n                             // No need to do anything, error already reported.\n                         }"}, {"sha": "84b4cd914563e6574a28d2d94392833d75dfb3be", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -306,7 +306,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// zsts can't be read out of two reasons:\n     /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n+    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand."}, {"sha": "3da5a65c37932d154d755115770bce84db91a32a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -530,7 +530,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::ZERO)),\n         }\n     }\n "}, {"sha": "c1de4939c1d9154a567b4ea8c12342968f8d28b8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -248,10 +248,10 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     /// This is always inlined, despite its size, because it has a single\n     /// callsite and it is called *very* frequently.\n     #[inline(always)]\n-    fn process_obligation(&mut self,\n-                          pending_obligation: &mut Self::Obligation)\n-                          -> ProcessResult<Self::Obligation, Self::Error>\n-    {\n+    fn process_obligation(\n+        &mut self,\n+        pending_obligation: &mut Self::Obligation,\n+    ) -> ProcessResult<Self::Obligation, Self::Error> {\n         // if we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n@@ -277,7 +277,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n-        debug!(\"process_obligation: obligation = {:?}\", obligation);\n+        debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref data) => {\n@@ -425,10 +425,13 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             }\n \n             ty::Predicate::WellFormed(ty) => {\n-                match ty::wf::obligations(self.selcx.infcx(),\n-                                          obligation.param_env,\n-                                          obligation.cause.body_id,\n-                                          ty, obligation.cause.span) {\n+                match ty::wf::obligations(\n+                    self.selcx.infcx(),\n+                    obligation.param_env,\n+                    obligation.cause.body_id,\n+                    ty,\n+                    obligation.cause.span,\n+                ) {\n                     None => {\n                         pending_obligation.stalled_on = vec![ty];\n                         ProcessResult::Unchanged"}, {"sha": "7ea7bf0257cf7d56344833ef458d638c51dbeea7", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 57, "deletions": 52, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                             -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n             .map(|_| ObjectSafetyViolation::SupertraitSelf)\n@@ -106,16 +107,33 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"object_safety_violations: {:?}\", trait_def_id);\n \n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n     }\n \n-    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n-                                          -> Vec<ObjectSafetyViolation>\n-    {\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n+        debug_assert!(self.generics_of(trait_def_id).has_self);\n+        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n+        // Any method that has a `Self : Sized` requisite can't be called.\n+        if self.generics_require_sized_self(method.def_id) {\n+            return false;\n+        }\n+\n+        match self.virtual_call_violation_for_method(trait_def_id, method) {\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            Some(_) => false,\n+        }\n+    }\n+\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId) -> Vec<ObjectSafetyViolation> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n@@ -163,14 +181,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn predicates_reference_self(\n         self,\n         trait_def_id: DefId,\n-        supertraits_only: bool) -> bool\n-    {\n+        supertraits_only: bool,\n+    ) -> bool {\n         let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(self, trait_def_id));\n         let predicates = if supertraits_only {\n             self.super_predicates_of(trait_def_id)\n         } else {\n             self.predicates_of(trait_def_id)\n         };\n+        let self_ty = self.types.self_param;\n+        let has_self_ty = |t: Ty<'tcx>| t.walk().any(|t| t == self_ty);\n         predicates\n             .predicates\n             .iter()\n@@ -179,7 +199,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 match predicate {\n                     ty::Predicate::Trait(ref data) => {\n                         // In the case of a trait predicate, we can skip the \"self\" type.\n-                        data.skip_binder().input_types().skip(1).any(|t| t.has_self_ty())\n+                        data.skip_binder().input_types().skip(1).any(has_self_ty)\n                     }\n                     ty::Predicate::Projection(ref data) => {\n                         // And similarly for projections. This should be redundant with\n@@ -199,7 +219,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .trait_ref(self)\n                             .input_types()\n                             .skip(1)\n-                            .any(|t| t.has_self_ty())\n+                            .any(has_self_ty)\n                     }\n                     ty::Predicate::WellFormed(..) |\n                     ty::Predicate::ObjectSafe(..) |\n@@ -229,11 +249,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.skip_binder().self_ty().is_self()\n+                ty::Predicate::Trait(ref trait_pred) => {\n+                    trait_pred.def_id() == sized_def_id\n+                        && trait_pred.skip_binder().self_ty().is_param(0)\n                 }\n                 ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n                 ty::Predicate::RegionOutlives(..) |\n                 ty::Predicate::WellFormed(..) |\n@@ -248,11 +268,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-    fn object_safety_violation_for_method(self,\n-                                          trait_def_id: DefId,\n-                                          method: &ty::AssocItem)\n-                                          -> Option<MethodViolationCode>\n-    {\n+    fn object_safety_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         debug!(\"object_safety_violation_for_method({:?}, {:?})\", trait_def_id, method);\n         // Any method that has a `Self : Sized` requisite is otherwise\n         // exempt from the regulations.\n@@ -263,36 +283,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n-    pub fn is_vtable_safe_method(self,\n-                                 trait_def_id: DefId,\n-                                 method: &ty::AssocItem)\n-                                 -> bool\n-    {\n-        debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n-        if self.generics_require_sized_self(method.def_id) {\n-            return false;\n-        }\n-\n-        match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n-            Some(_) => false,\n-        }\n-    }\n-\n     /// Returns `Some(_)` if this method cannot be called on a trait\n     /// object; this does not necessarily imply that the enclosing trait\n     /// is not object safe, because the method might have a where clause\n     /// `Self:Sized`.\n-    fn virtual_call_violation_for_method(self,\n-                                         trait_def_id: DefId,\n-                                         method: &ty::AssocItem)\n-                                         -> Option<MethodViolationCode>\n-    {\n+    fn virtual_call_violation_for_method(\n+        self,\n+        trait_def_id: DefId,\n+        method: &ty::AssocItem,\n+    ) -> Option<MethodViolationCode> {\n         // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n@@ -323,7 +322,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .collect::<Vec<_>>()\n                 // Do a shallow visit so that `contains_illegal_self_type_reference`\n                 // may apply it's custom visiting.\n-                .visit_tys_shallow(|t| self.contains_illegal_self_type_reference(trait_def_id, t)) {\n+                .visit_tys_shallow(|t| {\n+                    self.contains_illegal_self_type_reference(trait_def_id, t)\n+                }) {\n             let span = self.def_span(method.def_id);\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n@@ -337,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n         // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n-        if receiver_ty != self.mk_self_type() {\n+        if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n@@ -404,7 +405,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n     /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n-        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+        self,\n+        receiver_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+        method_def_id: DefId,\n     ) -> Ty<'tcx> {\n         debug!(\"receiver_for_self_ty({:?}, {:?}, {:?})\", receiver_ty, self_ty, method_def_id);\n         let substs = InternalSubsts::for_item(self, method_def_id, |param, _| {\n@@ -555,7 +559,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             // Self: Unsize<U>\n             let unsize_predicate = ty::TraitRef {\n                 def_id: unsize_did,\n-                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n+                substs: self.mk_substs_trait(self.types.self_param, &[unsized_self_ty.into()]),\n             }.to_predicate();\n \n             // U: Trait<Arg1, ..., ArgN>\n@@ -608,11 +612,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    fn contains_illegal_self_type_reference(self,\n-                                            trait_def_id: DefId,\n-                                            ty: Ty<'tcx>)\n-                                            -> bool\n-    {\n+    fn contains_illegal_self_type_reference(\n+        self,\n+        trait_def_id: DefId,\n+        ty: Ty<'tcx>,\n+     ) -> bool {\n         // This is somewhat subtle. In general, we want to forbid\n         // references to `Self` in the argument and return types,\n         // since the value of `Self` is erased. However, there is one\n@@ -654,10 +658,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n         let mut error = false;\n+        let self_ty = self.types.self_param;\n         ty.maybe_walk(|ty| {\n             match ty.sty {\n-                ty::Param(ref param_ty) => {\n-                    if param_ty.is_self() {\n+                ty::Param(_) => {\n+                    if ty == self_ty {\n                         error = true;\n                     }\n "}, {"sha": "e72efdb057ab10f08d3d1a59ea229c28880750d8", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -173,6 +173,7 @@ pub struct CommonTypes<'tcx> {\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n+    pub self_param: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n     /// Dummy type used for the `Self` of a `TraitRef` created for converting\n@@ -915,6 +916,10 @@ impl<'tcx> CommonTypes<'tcx> {\n             u128: mk(Uint(ast::UintTy::U128)),\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n+            self_param: mk(ty::Param(ty::ParamTy {\n+                index: 0,\n+                name: kw::SelfUpper.as_interned_str(),\n+            })),\n \n             trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n         }\n@@ -2566,10 +2571,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    #[inline]\n-    pub fn mk_self_type(self) -> Ty<'tcx> {\n-        self.mk_ty_param(0, kw::SelfUpper.as_interned_str())\n-    }\n \n     pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {"}, {"sha": "d6d17a67e01e95ef54529bfdd4eddd790321a612", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -239,13 +239,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n             ty::Projection(_) => \"associated type\".into(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".into(),\n-            ty::Param(ref p) => {\n-                if p.is_self() {\n-                    \"Self\".into()\n-                } else {\n-                    \"type parameter\".into()\n-                }\n-            }\n+            ty::Param(_) => \"type parameter\".into(),\n             ty::Opaque(..) => \"opaque type\".into(),\n             ty::Error => \"type error\".into(),\n         }"}, {"sha": "b2d74f963b0b3db24c494d7505ce3b773ae5edd3", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n use crate::ty::subst::{SubstsRef, UnpackedKind};\n-use crate::ty::{self, Ty, TypeFlags, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, TypeFlags, InferConst};\n use crate::mir::interpret::ConstValue;\n \n #[derive(Debug)]\n@@ -86,13 +86,9 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::HAS_TY_ERR)\n             }\n \n-            &ty::Param(ref p) => {\n+            &ty::Param(_) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES);\n-                if p.is_self() {\n-                    self.add_flags(TypeFlags::HAS_SELF);\n-                } else {\n-                    self.add_flags(TypeFlags::HAS_PARAMS);\n-                }\n+                self.add_flags(TypeFlags::HAS_PARAMS);\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n@@ -143,11 +139,6 @@ impl FlagComputation {\n             }\n \n             &ty::Projection(ref data) => {\n-                // currently we can't normalize projections that\n-                // include bound regions, so track those separately.\n-                if !data.has_escaping_bound_vars() {\n-                    self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n-                }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_projection_ty(data);\n             }\n@@ -243,7 +234,7 @@ impl FlagComputation {\n         match c.val {\n             ConstValue::Unevaluated(_, substs) => {\n                 self.add_substs(substs);\n-                self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION | TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n             },\n             ConstValue::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES | TypeFlags::HAS_CT_INFER);"}, {"sha": "4b30412b41954e98355d645fa988dfd3dbaacac2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -85,9 +85,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_param_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PARAMS)\n     }\n-    fn has_self_ty(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_SELF)\n-    }\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }"}, {"sha": "c71e1ea4e585989d763de4195328aab4fadc272a", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -298,8 +298,9 @@ impl<'tcx> Instance<'tcx> {\n     ) -> Option<Instance<'tcx>> {\n         debug!(\"resolve(def_id={:?}, substs={:?})\", def_id, substs);\n         let fn_sig = tcx.fn_sig(def_id);\n-        let is_vtable_shim =\n-            fn_sig.inputs().skip_binder().len() > 0 && fn_sig.input(0).skip_binder().is_self();\n+        let is_vtable_shim = fn_sig.inputs().skip_binder().len() > 0\n+            && fn_sig.input(0).skip_binder().is_param(0)\n+            && tcx.generics_of(def_id).has_self;\n         if is_vtable_shim {\n             debug!(\" => associated item with unsizeable self: Self\");\n             Some(Instance {"}, {"sha": "8febcfd0754c9e2fefef2474da0b0c3a412c89c3", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1601,7 +1601,6 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // resulting from the final codegen session.\n         if\n             layout.ty.has_param_types() ||\n-            layout.ty.has_self_ty() ||\n             !self.param_env.caller_bounds.is_empty()\n         {\n             return;\n@@ -1767,7 +1766,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.sty {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types() || tail.has_self_ty());\n+                        debug_assert!(tail.has_param_types());\n                         Ok(SizeSkeleton::Pointer {\n                             non_zero,\n                             tail: tcx.erase_regions(&tail)"}, {"sha": "0b81f193df4098c737b51c3ff8c6a5c986662f6d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -414,61 +414,53 @@ pub struct CReaderCacheKey {\n bitflags! {\n     pub struct TypeFlags: u32 {\n         const HAS_PARAMS         = 1 << 0;\n-        const HAS_SELF           = 1 << 1;\n-        const HAS_TY_INFER       = 1 << 2;\n-        const HAS_RE_INFER       = 1 << 3;\n-        const HAS_RE_PLACEHOLDER = 1 << 4;\n+        const HAS_TY_INFER       = 1 << 1;\n+        const HAS_RE_INFER       = 1 << 2;\n+        const HAS_RE_PLACEHOLDER = 1 << 3;\n \n         /// Does this have any `ReEarlyBound` regions? Used to\n         /// determine whether substitition is required, since those\n         /// represent regions that are bound in a `ty::Generics` and\n         /// hence may be substituted.\n-        const HAS_RE_EARLY_BOUND = 1 << 5;\n+        const HAS_RE_EARLY_BOUND = 1 << 4;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS   = 1 << 6;\n+        const HAS_FREE_REGIONS   = 1 << 5;\n \n         /// Is an error type reachable?\n-        const HAS_TY_ERR         = 1 << 7;\n-        const HAS_PROJECTION     = 1 << 8;\n+        const HAS_TY_ERR         = 1 << 6;\n+        const HAS_PROJECTION     = 1 << 7;\n \n         // FIXME: Rename this to the actual property since it's used for generators too\n-        const HAS_TY_CLOSURE     = 1 << 9;\n+        const HAS_TY_CLOSURE     = 1 << 8;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES    = 1 << 10;\n+        const HAS_FREE_LOCAL_NAMES    = 1 << 9;\n \n         /// Present if the type belongs in a local type context.\n         /// Only set for Infer other than Fresh.\n-        const KEEP_IN_LOCAL_TCX  = 1 << 11;\n-\n-        // Is there a projection that does not involve a bound region?\n-        // Currently we can't normalize projections w/ bound regions.\n-        const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n+        const KEEP_IN_LOCAL_TCX  = 1 << 10;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 13;\n+        const HAS_RE_LATE_BOUND = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 12;\n \n-        const HAS_CT_INFER = 1 << 15;\n-        const HAS_CT_PLACEHOLDER = 1 << 16;\n+        const HAS_CT_INFER = 1 << 13;\n+        const HAS_CT_PLACEHOLDER = 1 << 14;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n-                                   TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n \n         /// Flags representing the nominal content of a type,\n         /// computed by FlagsComputation. If you add a new nominal\n         /// flag, it should be added here too.\n         const NOMINAL_FLAGS     = TypeFlags::HAS_PARAMS.bits |\n-                                  TypeFlags::HAS_SELF.bits |\n                                   TypeFlags::HAS_TY_INFER.bits |\n                                   TypeFlags::HAS_RE_INFER.bits |\n-                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_RE_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_RE_EARLY_BOUND.bits |\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n@@ -479,6 +471,7 @@ bitflags! {\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_CT_PLACEHOLDER.bits;\n     }\n }\n@@ -1734,7 +1727,6 @@ impl<'tcx> ParamEnv<'tcx> {\n                 if value.has_placeholders()\n                     || value.needs_infer()\n                     || value.has_param_types()\n-                    || value.has_self_ty()\n                 {\n                     ParamEnvAnd {\n                         param_env: self,"}, {"sha": "2b173068b38e4a610e32c546d502a9c6d3c0a5ad", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1141,13 +1141,6 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n-\n-    pub fn is_self(&self) -> bool {\n-        // FIXME(#50125): Ignoring `Self` with `index != 0` might lead to weird behavior elsewhere,\n-        // but this should only be possible when using `-Z continue-parse-after-error` like\n-        // `compile-fail/issue-36638.rs`.\n-        self.name.as_symbol() == kw::SelfUpper && self.index == 0\n-    }\n }\n \n #[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable,\n@@ -1789,14 +1782,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn is_self(&self) -> bool {\n-        match self.sty {\n-            Param(ref p) => p.is_self(),\n-            _ => false,\n-        }\n-    }\n-\n     #[inline]\n     pub fn is_slice(&self) -> bool {\n         match self.sty {"}, {"sha": "19f18088579b33172594c31e835da33a7443702b", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -333,15 +333,21 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         assert_eq!(alloc.align, layout.align.abi);\n-        let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, alloc.align, None);\n-\n-        let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-            self.const_bitcast(base_addr, self.type_i8p()),\n-            &self.const_usize(offset.bytes()),\n-            1,\n-        )};\n-        let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n+        let llty = self.type_ptr_to(layout.llvm_type(self));\n+        let llval = if layout.size == Size::ZERO {\n+            let llval = self.const_usize(alloc.align.bytes());\n+            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+        } else {\n+            let init = const_alloc_to_llvm(self, alloc);\n+            let base_addr = self.static_addr_of(init, alloc.align, None);\n+\n+            let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n+                self.const_bitcast(base_addr, self.type_i8p()),\n+                &self.const_usize(offset.bytes()),\n+                1,\n+            )};\n+            self.const_bitcast(llval, llty)\n+        };\n         PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n "}, {"sha": "f7a423092acbd52f602aa2dd42bfeb609b2022f0", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -20,6 +20,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_interface = { path = \"../librustc_interface\" }"}, {"sha": "b19ea513b7575d0ceb369030894e49ce81c8b044", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -22,6 +22,8 @@ extern crate libc;\n #[macro_use]\n extern crate log;\n \n+pub extern crate rustc_plugin_impl as plugin;\n+\n use pretty::{PpMode, UserIdentifiedItem};\n \n //use rustc_resolve as resolve;"}, {"sha": "16b377d5bccea240fcc991c63f182d00add2758e", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -30,7 +30,7 @@ rustc_passes = { path = \"../librustc_passes\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n+rustc_plugin = { path = \"../librustc_plugin\", package = \"rustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\""}, {"sha": "afef307a0ed3702b1355a14cffa16a23c57d4f60", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -352,7 +352,6 @@ impl Cursor<'_> {\n         loop {\n             match self.nth_char(0) {\n                 '\\n' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 _ => {\n                     self.bump();\n@@ -525,7 +524,6 @@ impl Cursor<'_> {\n             match self.nth_char(0) {\n                 '/' if !first => break,\n                 '\\n' if self.nth_char(1) != '\\'' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 '\\'' => {\n                     self.bump();"}, {"sha": "c709b7526082f6a3c18ba057cbed48a0bb4a0e11", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -128,11 +128,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     if first_char != '\\\\' {\n         return match first_char {\n             '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n             '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n             '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n             _ => {\n@@ -244,27 +240,15 @@ where\n \n         let unescaped_char = match first_char {\n             '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                let second_char = chars.clone().next();\n+                match second_char {\n+                    Some('\\n') => {\n                         skip_ascii_whitespace(&mut chars);\n                         continue;\n                     }\n                     _ => scan_escape(first_char, &mut chars, mode),\n                 }\n             }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             _ => scan_escape(first_char, &mut chars, mode),\n@@ -298,15 +282,11 @@ where\n     while let Some(curr) = chars.next() {\n         let start = initial_len - chars.as_str().len() - curr.len_utf8();\n \n-        let result = match (curr, chars.clone().next()) {\n-            ('\\r', Some('\\n')) => {\n-                chars.next();\n-                Ok('\\n')\n-            },\n-            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n-            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+        let result = match curr {\n+            '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n+            c if mode.is_bytes() && !c.is_ascii() =>\n                 Err(EscapeError::NonAsciiCharInByteString),\n-            (c, _) => Ok(c),\n+            c => Ok(c),\n         };\n         let end = initial_len - chars.as_str().len();\n "}, {"sha": "e7b1ff6479d88dc4f60888bbd8ccf62fe5e9ff94", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -11,7 +11,6 @@ fn test_unescape_char_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -31,6 +30,7 @@ fn test_unescape_char_bad() {\n     check(r\"\\v\", EscapeError::InvalidEscape);\n     check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n     check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+    check(\"\\\\\\r\", EscapeError::InvalidEscape);\n \n     check(r\"\\x\", EscapeError::TooShortHexEscape);\n     check(r\"\\x0\", EscapeError::TooShortHexEscape);\n@@ -116,10 +116,9 @@ fn test_unescape_str_good() {\n \n     check(\"foo\", \"foo\");\n     check(\"\", \"\");\n-    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+    check(\" \\t\\n\", \" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", \"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n     check(\"thread's\", \"thread's\")\n }\n \n@@ -134,7 +133,6 @@ fn test_unescape_byte_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -238,10 +236,9 @@ fn test_unescape_byte_str_good() {\n \n     check(\"foo\", b\"foo\");\n     check(\"\", b\"\");\n-    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+    check(\" \\t\\n\", b\" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", b\"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n     check(\"thread's\", b\"thread's\")\n }\n \n@@ -253,7 +250,6 @@ fn test_unescape_raw_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n }\n@@ -266,7 +262,6 @@ fn test_unescape_raw_byte_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n     check("}, {"sha": "ce7681c974a5dcf73d1bd6bdcda0a75f8ba2e46d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 111, "deletions": 43, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1876,25 +1876,101 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+        #[derive(Debug, Copy, Clone, PartialEq)]\n+        enum InitKind { Zeroed, Uninit };\n \n         /// Information about why a type cannot be initialized this way.\n         /// Contains an error message and optionally a span to point at.\n         type InitError = (String, Option<Span>);\n \n+        /// Test if this constant is all-0.\n+        fn is_zero(expr: &hir::Expr) -> bool {\n+            use hir::ExprKind::*;\n+            use syntax::ast::LitKind::*;\n+            match &expr.node {\n+                Lit(lit) =>\n+                    if let Int(i, _) = lit.node {\n+                        i == 0\n+                    } else {\n+                        false\n+                    },\n+                Tup(tup) =>\n+                    tup.iter().all(is_zero),\n+                _ =>\n+                    false\n+            }\n+        }\n+\n+        /// Determine if this expression is a \"dangerous initialization\".\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+            // `transmute` is inside an anonymous module (the `extern` block?);\n+            // `Invalid` represents the empty string and matches that.\n+            const TRANSMUTE_PATH: &[Symbol] =\n+                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n+\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                    let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+\n+                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                        return Some(InitKind::Zeroed);\n+                    }\n+                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                        return Some(InitKind::Uninit);\n+                    }\n+                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                        if is_zero(&args[0]) {\n+                            return Some(InitKind::Zeroed);\n+                        }\n+                    }\n+                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n+                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            }\n+\n+            None\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n+        fn ty_find_init_error<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            ty: Ty<'tcx>,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n-                // Recurse for some compound types.\n+                // Primitive types with other constraints.\n+                Bool if init == InitKind::Uninit =>\n+                    Some((format!(\"Booleans must be `true` or `false`\"), None)),\n+                Char if init == InitKind::Uninit =>\n+                    Some((format!(\"Characters must be a valid unicode codepoint\"), None)),\n+                // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    use std::ops::Bound;\n+                    match tcx.layout_scalar_valid_range(adt_def.did) {\n+                        // We exploit here that `layout_scalar_valid_range` will never\n+                        // return `Bound::Excluded`.  (And we have tests checking that we\n+                        // handle the attribute correctly.)\n+                        (Bound::Included(lo), _) if lo > 0 =>\n+                            return Some((format!(\"{} must be non-null\", ty), None)),\n+                        (Bound::Included(_), _) | (_, Bound::Included(_))\n+                        if init == InitKind::Uninit =>\n+                            return Some((\n+                                format!(\"{} must be initialized inside its custom valid range\", ty),\n+                                None,\n+                            )),\n+                        _ => {}\n+                    }\n+                    // Now, recurse.\n                     match adt_def.variants.len() {\n                         0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n                         1 => {\n@@ -1905,6 +1981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n+                                    init,\n                                 ).map(|(mut msg, span)| if span.is_none() {\n                                     // Point to this field, should be helpful for figuring\n                                     // out where the source of the error is.\n@@ -1918,57 +1995,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 })\n                             })\n                         }\n+                        // Multi-variant enums are tricky: if all but one variant are\n+                        // uninhabited, we might actually do layout like for a single-variant\n+                        // enum, and then even leaving them uninitialized could be okay.\n                         _ => None, // Conservative fallback for multi-variant enum.\n                     }\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n-                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n-                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n-                //        `char`, and any multivariant enum.\n                 // Conservative fallback.\n                 _ => None,\n             }\n         }\n \n-        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n-            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n-                        cx.match_def_path(def_id, &UININIT_PATH)\n-                    {\n-                        // This conjures an instance of a type out of nothing,\n-                        // using zeroed or uninitialized memory.\n-                        // We are extremely conservative with what we warn about.\n-                        let conjured_ty = cx.tables.expr_ty(expr);\n-                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n-                            let mut err = cx.struct_span_lint(\n-                                INVALID_VALUE,\n-                                expr.span,\n-                                &format!(\n-                                    \"the type `{}` does not permit {}\",\n-                                    conjured_ty,\n-                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n-                                        \"zero-initialization\"\n-                                    } else {\n-                                        \"being left uninitialized\"\n-                                    }\n-                                ),\n-                            );\n-                            err.span_label(expr.span,\n-                                \"this code causes undefined behavior when executed\");\n-                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n-                            if let Some(span) = span {\n-                                err.span_note(span, &msg);\n-                            } else {\n-                                err.note(&msg);\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n+        if let Some(init) = is_dangerous_init(cx, expr) {\n+            // This conjures an instance of a type out of nothing,\n+            // using zeroed or uninitialized memory.\n+            // We are extremely conservative with what we warn about.\n+            let conjured_ty = cx.tables.expr_ty(expr);\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n+                let mut err = cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    &format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ),\n+                );\n+                err.span_label(expr.span,\n+                    \"this code causes undefined behavior when executed\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                if let Some(span) = span {\n+                    err.span_note(span, &msg);\n+                } else {\n+                    err.note(&msg);\n                 }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "27833161ef23d7b6cf4020828ac08f41042b94e8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,7 +3,7 @@\n //! This currently only contains the definitions and implementations\n //! of most of the lints that `rustc` supports directly, it does not\n //! contain the infrastructure for defining/registering lints. That is\n-//! available in `rustc::lint` and `rustc_plugin` respectively.\n+//! available in `rustc::lint` and `rustc_driver::plugin` respectively.\n //!\n //! ## Note\n //!"}, {"sha": "af41b6a4c857f092101cac0c8286eaeda6e7e136", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 64, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,8 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::decoder::proc_macro_def_path_table;\n-use crate::schema::CrateRoot;\n+use crate::schema::{CrateRoot};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -26,11 +25,11 @@ use std::{cmp, fs};\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n@@ -230,24 +229,13 @@ impl<'a> CrateLoader<'a> {\n \n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n-        let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n+        let raw_proc_macros =  crate_root.proc_macro_data.map(|_| {\n             if self.sess.opts.debugging_opts.dual_proc_macros {\n-                let host_lib = host_lib.unwrap();\n-                self.load_derive_macros(\n-                    &host_lib.metadata.get_root(),\n-                    host_lib.dylib.map(|p| p.0),\n-                    span\n-                )\n+                let host_lib = host_lib.as_ref().unwrap();\n+                self.dlsym_proc_macros(host_lib.dylib.as_ref().map(|p| p.0.clone()),\n+                                       &host_lib.metadata.get_root(), span)\n             } else {\n-                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n-            }\n-        });\n-\n-        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n-            if let Some(proc_macros) = &proc_macros {\n-                proc_macro_def_path_table(&crate_root, proc_macros)\n-            } else {\n-                crate_root.def_path_table.decode((&metadata, self.sess))\n+                self.dlsym_proc_macros(dylib.clone().map(|p| p.0), &crate_root, span)\n             }\n         });\n \n@@ -260,13 +248,16 @@ impl<'a> CrateLoader<'a> {\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n \n+        let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n+            crate_root.def_path_table.decode((&metadata, self.sess))\n+        });\n+\n         let cmeta = cstore::CrateMetadata {\n             name: crate_root.name,\n             imported_name: ident,\n             extern_crate: Lock::new(None),\n             def_path_table: Lrc::new(def_path_table),\n             trait_impls,\n-            proc_macros,\n             root: crate_root,\n             blob: metadata,\n             cnum_map,\n@@ -280,7 +271,10 @@ impl<'a> CrateLoader<'a> {\n                 rlib,\n                 rmeta,\n             },\n-            private_dep\n+            private_dep,\n+            span,\n+            host_lib,\n+            raw_proc_macros\n         };\n \n         let cmeta = Lrc::new(cmeta);\n@@ -389,7 +383,7 @@ impl<'a> CrateLoader<'a> {\n         match result {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n-                if data.root.proc_macro_decls_static.is_some() {\n+                if data.root.proc_macro_data.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n                 }\n                 data.dep_kind.with_lock(|data_dep_kind| {\n@@ -482,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n                           dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n-        if crate_root.proc_macro_decls_static.is_some() {\n+        if crate_root.proc_macro_data.is_some() {\n             return cstore::CrateNumMap::new();\n         }\n \n@@ -574,19 +568,13 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    /// Loads custom derive macros.\n-    ///\n-    /// Note that this is intentionally similar to how we load plugins today,\n-    /// but also intentionally separate. Plugins are likely always going to be\n-    /// implemented as dynamic libraries, but we have a possible future where\n-    /// custom derive (and other macro-1.1 style features) are implemented via\n-    /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, root: &CrateRoot<'_>, dylib: Option<PathBuf>, span: Span)\n-                          -> Vec<(ast::Name, Lrc<SyntaxExtension>)> {\n-        use std::{env, mem};\n+    fn dlsym_proc_macros(&self,\n+                         dylib: Option<PathBuf>,\n+                         root: &CrateRoot<'_>,\n+                         span: Span\n+    ) -> &'static [ProcMacro] {\n+        use std::env;\n         use crate::dynamic_lib::DynamicLibrary;\n-        use proc_macro::bridge::client::ProcMacro;\n-        use syntax::ext::proc_macro::{BangProcMacro, AttrProcMacro, ProcMacroDerive};\n \n         let path = match dylib {\n             Some(dylib) => dylib,\n@@ -608,38 +596,11 @@ impl<'a> CrateLoader<'a> {\n             *(sym as *const &[ProcMacro])\n         };\n \n-        let extensions = decls.iter().map(|&decl| {\n-            let (name, kind, helper_attrs) = match decl {\n-                ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let helper_attrs =\n-                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (\n-                        trait_name,\n-                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                            client, attrs: helper_attrs.clone()\n-                        })),\n-                        helper_attrs,\n-                    )\n-                }\n-                ProcMacro::Attr { name, client } => (\n-                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n-                ),\n-                ProcMacro::Bang { name, client } => (\n-                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n-                )\n-            };\n-\n-            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n-                helper_attrs,\n-                ..SyntaxExtension::default(kind, root.edition)\n-            }))\n-        }).collect();\n-\n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long.\n-        mem::forget(lib);\n+        std::mem::forget(lib);\n \n-        extensions\n+        decls\n     }\n \n     /// Look for a plugin registrar. Returns library path, crate"}, {"sha": "792922a18372225ad2d0060eef53c606f19b8050", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -28,6 +28,9 @@ pub use crate::cstore_impl::{provide, provide_extern};\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n pub use rustc_data_structures::sync::MetadataRef;\n+use crate::creader::Library;\n+use syntax_pos::Span;\n+use proc_macro::bridge::client::ProcMacro;\n \n pub struct MetadataBlob(pub MetadataRef);\n \n@@ -82,11 +85,19 @@ pub struct CrateMetadata {\n     pub dep_kind: Lock<DepKind>,\n     pub source: CrateSource,\n \n-    pub proc_macros: Option<Vec<(ast::Name, Lrc<SyntaxExtension>)>>,\n-\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n-    pub private_dep: bool\n+    pub private_dep: bool,\n+\n+    pub host_lib: Option<Library>,\n+    pub span: Span,\n+\n+    pub raw_proc_macros: Option<&'static [ProcMacro]>,\n+}\n+\n+pub struct FullProcMacro {\n+    pub name: ast::Name,\n+    pub ext: Lrc<SyntaxExtension>\n }\n \n pub struct CStore {"}, {"sha": "a66da32fa4d7560ef79d4931cb35438ae8c077dd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -426,8 +426,8 @@ impl cstore::CStore {\n \n     pub fn load_macro_untracked(&self, id: DefId, sess: &Session) -> LoadedMacro {\n         let data = self.get_crate_data(id.krate);\n-        if let Some(ref proc_macros) = data.proc_macros {\n-            return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n+        if data.is_proc_macro_crate() {\n+            return LoadedMacro::ProcMacro(data.get_proc_macro(id.index, sess).ext);\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n@@ -439,7 +439,8 @@ impl cstore::CStore {\n         }\n \n         let def = data.get_macro(id.index);\n-        let macro_full_name = data.def_path(id.index).to_string_friendly(|_| data.imported_name);\n+        let macro_full_name = data.def_path(id.index)\n+            .to_string_friendly(|_| data.imported_name);\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);"}, {"sha": "d29592a5d686997cf8e4dc4777c1f5805f48eec3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 113, "deletions": 71, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,16 +1,15 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n+use crate::cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule, FullProcMacro};\n use crate::schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Res, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::mir::{self, interpret};\n@@ -30,10 +29,11 @@ use syntax::attr;\n use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n-use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax::ext::base::{MacroKind, SyntaxExtensionKind, SyntaxExtension};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, symbol::{InternedString}};\n use log::debug;\n+use proc_macro::bridge::client::ProcMacro;\n+use syntax::ext::proc_macro::{AttrProcMacro, ProcMacroDerive, BangProcMacro};\n \n pub struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n@@ -138,7 +138,7 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> LazySeq<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         meta: M,\n-    ) -> impl Iterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n+    ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n@@ -442,46 +442,16 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n-/// Creates the \"fake\" DefPathTable for a given proc macro crate.\n-///\n-/// The DefPathTable is as follows:\n-///\n-/// CRATE_ROOT (DefIndex 0:0)\n-///  |- GlobalMetaDataKind data (DefIndex 1:0 .. DefIndex 1:N)\n-///  |- proc macro #0 (DefIndex 1:N)\n-///  |- proc macro #1 (DefIndex 1:N+1)\n-///  \\- ...\n-crate fn proc_macro_def_path_table(crate_root: &CrateRoot<'_>,\n-                                   proc_macros: &[(ast::Name, Lrc<SyntaxExtension>)])\n-                                   -> DefPathTable\n-{\n-    let mut definitions = Definitions::default();\n-\n-    let name = crate_root.name.as_str();\n-    let disambiguator = crate_root.disambiguator;\n-    debug!(\"creating proc macro def path table for {:?}/{:?}\", name, disambiguator);\n-    let crate_root = definitions.create_root_def(&name, disambiguator);\n-    for (index, (name, _)) in proc_macros.iter().enumerate() {\n-        let def_index = definitions.create_def_with_parent(\n-            crate_root,\n-            ast::DUMMY_NODE_ID,\n-            DefPathData::MacroNs(name.as_interned_str()),\n-            ExpnId::root(),\n-            DUMMY_SP);\n-        debug!(\"definition for {:?} is {:?}\", name, def_index);\n-        assert_eq!(def_index, DefIndex::from_proc_macro_index(index));\n-    }\n-\n-    definitions.def_path_table().clone()\n-}\n-\n impl<'a, 'tcx> CrateMetadata {\n+    pub fn is_proc_macro_crate(&self) -> bool {\n+        self.root.proc_macro_decls_static.is_some()\n+    }\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n-        self.proc_macros.is_some() && id != CRATE_DEF_INDEX\n+        self.is_proc_macro_crate() &&\n+            self.root.proc_macro_data.unwrap().decode(self).find(|x| *x == id).is_some()\n     }\n \n     fn maybe_entry(&self, item_id: DefIndex) -> Option<Lazy<Entry<'tcx>>> {\n-        assert!(!self.is_proc_macro(item_id));\n         self.root.entries_index.lookup(self.blob.raw_bytes(), item_id)\n     }\n \n@@ -504,29 +474,89 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n+    fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n+        // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n+        // with items in 'raw_proc_macros'\n+        let pos = self.root.proc_macro_data.unwrap().decode(self).position(|i| i == id).unwrap();\n+        &self.raw_proc_macros.unwrap()[pos]\n+    }\n+\n     pub fn item_name(&self, item_index: DefIndex) -> Symbol {\n-        self.def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .expect(\"no name in item_name\")\n-            .as_symbol()\n+        if !self.is_proc_macro(item_index) {\n+            self.def_key(item_index)\n+                .disambiguated_data\n+                .data\n+                .get_opt_name()\n+                .expect(\"no name in item_name\")\n+                .as_symbol()\n+        } else {\n+            Symbol::intern(self.raw_proc_macro(item_index).name())\n+        }\n     }\n \n     pub fn def_kind(&self, index: DefIndex) -> Option<DefKind> {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n             Some(DefKind::Macro(\n-                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+                macro_kind(self.raw_proc_macro(index))\n             ))\n         }\n     }\n \n     pub fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        match self.is_proc_macro(index) {\n-            true => DUMMY_SP,\n-            false => self.entry(index).span.decode((self, sess)),\n+        self.entry(index).span.decode((self, sess))\n+    }\n+\n+\n+    pub fn get_proc_macro(&self, id: DefIndex, sess: &Session) -> FullProcMacro {\n+        if sess.opts.debugging_opts.dual_proc_macros {\n+            let host_lib = self.host_lib.as_ref().unwrap();\n+            self.load_proc_macro(\n+                &host_lib.metadata.get_root(),\n+                id,\n+                sess\n+            )\n+        } else {\n+            self.load_proc_macro(&self.root, id, sess)\n+        }\n+    }\n+\n+    fn load_proc_macro(&self, root: &CrateRoot<'_>,\n+                        id: DefIndex,\n+                        sess: &Session)\n+                        -> FullProcMacro {\n+\n+        let raw_macro = self.raw_proc_macro(id);\n+        let (name, kind, helper_attrs) = match *raw_macro {\n+            ProcMacro::CustomDerive { trait_name, attributes, client } => {\n+                let helper_attrs =\n+                    attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                (\n+                    trait_name,\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                        client, attrs: helper_attrs.clone()\n+                    })),\n+                    helper_attrs,\n+                )\n+            }\n+            ProcMacro::Attr { name, client } => (\n+                name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+            ),\n+            ProcMacro::Bang { name, client } => (\n+                name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+            )\n+        };\n+\n+        let span = self.get_span(id, sess);\n+\n+        FullProcMacro {\n+            name: Symbol::intern(name),\n+            ext: Lrc::new(SyntaxExtension {\n+                span,\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            })\n         }\n     }\n \n@@ -723,7 +753,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     /// Iterates over the language items in the given crate.\n     pub fn get_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not export any lang-items to the target.\n             &[]\n         } else {\n@@ -738,18 +768,18 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F, sess: &Session)\n         where F: FnMut(def::Export<hir::HirId>)\n     {\n-        if let Some(ref proc_macros) = self.proc_macros {\n+        if let Some(proc_macros_ids) = self.root.proc_macro_data.map(|d| d.decode(self)) {\n             /* If we are loading as a proc macro, we want to return the view of this crate\n-             * as a proc macro crate, not as a Rust crate. See `proc_macro_def_path_table`\n-             * for the DefPathTable we are corresponding to.\n+             * as a proc macro crate.\n              */\n             if id == CRATE_DEF_INDEX {\n-                for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n+                for def_index in proc_macros_ids {\n+                    let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.macro_kind()),\n-                        self.local_def_id(DefIndex::from_proc_macro_index(id)),\n+                        DefKind::Macro(macro_kind(raw_macro)),\n+                        self.local_def_id(def_index),\n                     );\n-                    let ident = Ident::with_dummy_span(name);\n+                    let ident = Ident::from_str(raw_macro.name());\n                     callback(def::Export {\n                         ident: ident,\n                         res: res,\n@@ -960,11 +990,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n-        if self.is_proc_macro(node_id) {\n-            return Lrc::new([]);\n-        }\n \n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Lrc<[ast::Attribute]> {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1022,7 +1049,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n         filter: Option<DefId>,\n     ) -> &'tcx [DefId] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[]\n         }\n@@ -1066,7 +1093,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n \n     pub fn get_native_libraries(&self, sess: &Session) -> Vec<NativeLibrary> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* native libraries.\n             vec![]\n         } else {\n@@ -1075,7 +1102,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_foreign_modules(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ForeignModule] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not have any *target* foreign modules.\n             &[]\n         } else {\n@@ -1098,7 +1125,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_missing_lang_items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [lang_items::LangItem] {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // Proc macro crates do not depend on any target weak lang-items.\n             &[]\n         } else {\n@@ -1122,7 +1149,7 @@ impl<'a, 'tcx> CrateMetadata {\n         &self,\n         tcx: TyCtxt<'tcx>,\n     ) -> Vec<(ExportedSymbol<'tcx>, SymbolExportLevel)> {\n-        if self.proc_macros.is_some() {\n+        if self.is_proc_macro_crate() {\n             // If this crate is a custom derive crate, then we're not even going to\n             // link those in so we skip those crates.\n             vec![]\n@@ -1191,13 +1218,18 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.def_path_table.def_key(index)\n+        let mut key = self.def_path_table.def_key(index);\n+        if self.is_proc_macro(index) {\n+            let name = self.raw_proc_macro(index).name();\n+            key.disambiguated_data.data = DefPathData::MacroNs(InternedString::intern(name));\n+        }\n+        key\n     }\n \n     // Returns the path leading to the thing with this `id`.\n     pub fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n-        DefPath::make(self.cnum, id, |parent| self.def_path_table.def_key(parent))\n+        DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n     #[inline]\n@@ -1310,3 +1342,13 @@ impl<'a, 'tcx> CrateMetadata {\n         self.source_map_import_info.borrow()\n     }\n }\n+\n+// Cannot be implemented on 'ProcMacro', as libproc_macro\n+// does not depend on libsyntax\n+fn macro_kind(raw: &ProcMacro) -> MacroKind {\n+    match raw {\n+        ProcMacro::CustomDerive { .. } => MacroKind::Derive,\n+        ProcMacro::Attr { .. } => MacroKind::Attr,\n+        ProcMacro::Bang { .. } => MacroKind::Bang\n+    }\n+}"}, {"sha": "6058ae99cf4f82372c8d2378f327413d0cc23d5b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -30,6 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym, Ident};\n use syntax_pos::{self, FileName, SourceFile, Span};\n@@ -383,6 +384,8 @@ impl<'tcx> EncodeContext<'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+\n         let mut i = self.position();\n \n         let crate_deps = self.encode_crate_deps();\n@@ -463,16 +466,23 @@ impl<'tcx> EncodeContext<'tcx> {\n             self.lazy_seq(interpret_alloc_index)\n         };\n \n+\n         i = self.position();\n         let entries_index = self.entries_index.write_index(&mut self.opaque);\n         let entries_index_bytes = self.position() - i;\n \n+        // Encode the proc macro data\n+        i = self.position();\n+        let proc_macro_data = self.encode_proc_macros();\n+        let proc_macro_data_bytes = self.position() - i;\n+\n+\n         let attrs = tcx.hir().krate_attrs();\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n         let has_global_allocator = *tcx.sess.has_global_allocator.get();\n         let has_panic_handler = *tcx.sess.has_panic_handler.try_get().unwrap_or(&false);\n \n+\n         let root = self.lazy(&CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n             extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n@@ -491,6 +501,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             } else {\n                 None\n             },\n+            proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n                 tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n             } else {\n@@ -539,6 +550,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"            impl bytes: {}\", impl_bytes);\n             println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"   entries index bytes: {}\", entries_index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n@@ -1470,6 +1482,22 @@ impl EncodeContext<'tcx> {\n         self.lazy_seq(foreign_modules.iter().cloned())\n     }\n \n+    fn encode_proc_macros(&mut self) -> Option<LazySeq<DefIndex>> {\n+        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        if is_proc_macro {\n+            let proc_macros: Vec<_> = self.tcx.hir().krate().items.values().filter_map(|item| {\n+                if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+                    Some(item.hir_id.owner)\n+                } else {\n+                    None\n+                }\n+            }).collect();\n+            Some(self.lazy_seq(proc_macros))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         let crates = self.tcx.crates();\n "}, {"sha": "ceba7cf0fe031c94324f06469b8d6edb33739f0c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -716,7 +716,9 @@ impl<'a> Context<'a> {\n \n         let root = metadata.get_root();\n         if let Some(is_proc_macro) = self.is_proc_macro {\n-            if root.proc_macro_decls_static.is_some() != is_proc_macro {\n+            if root.proc_macro_data.is_some() != is_proc_macro {\n+                info!(\"Rejecting via proc macro: expected {} got {}\",\n+                      is_proc_macro, root.proc_macro_data.is_some());\n                 return None;\n             }\n         }"}, {"sha": "13c599cf997b65a5f400d0f7104e43ea42db7e3b", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -182,6 +182,10 @@ pub struct CrateRoot<'tcx> {\n \n     pub entries_index: LazySeq<index::Index<'tcx>>,\n \n+    /// The DefIndex's of any proc macros delcared by\n+    /// this crate\n+    pub proc_macro_data: Option<LazySeq<DefIndex>>,\n+\n     pub compiler_builtins: bool,\n     pub needs_allocator: bool,\n     pub needs_panic_runtime: bool,"}, {"sha": "247783c420e251d6d32b79835fba3e1dbb303379", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1190,7 +1190,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let suggestion = match tcx.sess.source_map().span_to_snippet(args_span) {\n-            Ok(string) => format!(\"move {}\", string),\n+            Ok(mut string) => {\n+                if string.starts_with(\"async \") {\n+                    string.insert_str(6, \"move \");\n+                } else if string.starts_with(\"async|\") {\n+                    string.insert_str(5, \" move\");\n+                } else {\n+                    string.insert_str(0, \"move \");\n+                };\n+                string\n+            },\n             Err(_) => \"move |<args>| <body>\".to_string()\n         };\n "}, {"sha": "ca68b9e31b6b91337e4fa2b555d7c53f0de24f12", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -578,7 +578,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             }\n \n-            hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "94323b15b696fb3ba91aa1460317ea2eddec56b1", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -657,6 +657,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    self.visit_bindings(&pat, pattern_user_ty.clone(), f);\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "8d049b53988a9197f78c2e4aedd4f839f7a079e9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -195,6 +195,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }\n+\n+            PatternKind::Or { .. } => {\n+                Err(match_pair)\n+            }\n         }\n     }\n }"}, {"sha": "ec85daccd476eb49efa6a7c729dcea23c0a5ad17", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -87,6 +87,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n@@ -130,6 +131,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n+            PatternKind::Or { .. } |\n             PatternKind::Binding { .. } |\n             PatternKind::AscribeUserType { .. } |\n             PatternKind::Leaf { .. } |"}, {"sha": "76ee76a74562bf6e6efd19a84892108bd8d098e5", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -11,9 +11,8 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, subst::Subst};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n-use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -415,7 +414,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         Err(\n             ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n         )"}, {"sha": "222750e602df92f5ff30b37c5230b3c94086e105", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1359,6 +1359,9 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                 Some(vec![Slice(pat_len)])\n             }\n         }\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     }\n }\n \n@@ -1884,6 +1887,10 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n         }\n+\n+        PatternKind::Or { .. } => {\n+            bug!(\"support for or-patterns has not been fully implemented yet.\");\n+        }\n     };\n     debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n "}, {"sha": "6caccfddfa422f6724180e8199b5d1824edae489", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -175,6 +175,12 @@ pub enum PatternKind<'tcx> {\n         slice: Option<Pattern<'tcx>>,\n         suffix: Vec<Pattern<'tcx>>,\n     },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pattern<'tcx>>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -186,6 +192,18 @@ pub struct PatternRange<'tcx> {\n \n impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n         match *self.kind {\n             PatternKind::Wild => write!(f, \"_\"),\n             PatternKind::AscribeUserType { ref subpattern, .. } =>\n@@ -224,9 +242,6 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                     }\n                 };\n \n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n-\n                 if let Some(variant) = variant {\n                     write!(f, \"{}\", variant.ident)?;\n \n@@ -241,12 +256,12 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                                 continue;\n                             }\n                             let name = variant.fields[p.field.index()].ident;\n-                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n+                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n                             printed += 1;\n                         }\n \n                         if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_continue())?;\n+                            write!(f, \"{}..\", start_or_comma())?;\n                         }\n \n                         return write!(f, \" }}\");\n@@ -257,7 +272,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                 if num_fields != 0 || variant.is_none() {\n                     write!(f, \"(\")?;\n                     for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_continue())?;\n+                        write!(f, \"{}\", start_or_comma())?;\n \n                         // Common case: the field is where we expect it.\n                         if let Some(p) = subpatterns.get(i) {\n@@ -305,25 +320,29 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             }\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n             PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n                 write!(f, \"[\")?;\n                 for p in prefix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_continue())?;\n+                    write!(f, \"{}\", start_or_comma())?;\n                     match *slice.kind {\n                         PatternKind::Wild => {}\n                         _ => write!(f, \"{}\", slice)?\n                     }\n                     write!(f, \"..\")?;\n                 }\n                 for p in suffix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n                 }\n                 write!(f, \"]\")\n             }\n+            PatternKind::Or { ref pats } => {\n+                for pat in pats {\n+                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n+            }\n         }\n     }\n }\n@@ -655,6 +674,12 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n                 self.lower_variant_or_leaf(res, pat.hir_id, pat.span, ty, subpatterns)\n             }\n+\n+            PatKind::Or(ref pats) => {\n+                PatternKind::Or {\n+                    pats: pats.iter().map(|p| self.lower_pattern(p)).collect(),\n+                }\n+            }\n         };\n \n         Pattern {\n@@ -1436,6 +1461,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n                 slice: slice.fold_with(folder),\n                 suffix: suffix.fold_with(folder)\n             },\n+            PatternKind::Or { ref pats } => PatternKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }"}, {"sha": "210647ac1e9a3de60307d4490cdd7a26c2000812", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc::ty::layout::{self, TyLayout, Size};\n use rustc::ty::adjustment::{PointerCast};\n use syntax::ast::FloatTy;\n@@ -36,15 +36,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             bug!(\"reifying a fn ptr that requires const arguments\");\n                         }\n-                        let instance = ty::Instance::resolve(\n-                            *self.tcx,\n-                            self.param_env,\n-                            def_id,\n-                            substs,\n-                        ).ok_or_else(|| err_inval!(TooGeneric))?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -67,7 +67,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The src operand does not matter, just its type\n                 match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n-                        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n+                        // All reifications must be monomorphic, bail out otherwise.\n+                        if src.layout.ty.needs_subst() {\n+                            throw_inval!(TooGeneric);\n+                        }\n+\n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,\n                             def_id,"}, {"sha": "6f48396cdd7cfeca0af170637f00b6ccb23d3d5d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 29, "deletions": 60, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -9,7 +9,7 @@ use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n };\n-use rustc::ty::subst::{Subst, SubstsRef};\n+use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -291,41 +291,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n     }\n \n-    pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n-        &self,\n-        substs: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.tcx.subst_and_normalize_erasing_regions(\n-                frame.instance.substs,\n-                self.param_env,\n-                &substs,\n-            )),\n-            None => if substs.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(substs)\n-            },\n-        }\n-    }\n-\n-    pub(super) fn resolve(\n-        &self,\n-        def_id: DefId,\n-        substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n-        trace!(\"param_env: {:#?}\", self.param_env);\n-        let substs = self.subst_and_normalize_erasing_regions(substs)?;\n-        trace!(\"substs: {:#?}\", substs);\n-        ty::Instance::resolve(\n-            *self.tcx,\n-            self.param_env,\n-            def_id,\n-            substs,\n-        ).ok_or_else(|| err_inval!(TooGeneric).into())\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -349,34 +314,34 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub(super) fn monomorphize<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// Call this on things you got out of the MIR (so it is as generic as the current\n+    /// stack frame), to bring it into the proper environment for this interpreter.\n+    pub(super) fn subst_from_frame_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n-        t: T,\n-    ) -> InterpResult<'tcx, T> {\n-        match self.stack.last() {\n-            Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n-            None => if t.needs_subst() {\n-                throw_inval!(TooGeneric)\n-            } else {\n-                Ok(t)\n-            },\n-        }\n+        value: T,\n+    ) -> T {\n+        self.tcx.subst_and_normalize_erasing_regions(\n+            self.frame().instance.substs,\n+            self.param_env,\n+            &value,\n+        )\n     }\n \n-    fn monomorphize_with_substs<T: TypeFoldable<'tcx> + Subst<'tcx>>(\n+    /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n+    pub(super) fn resolve(\n         &self,\n-        t: T,\n+        def_id: DefId,\n         substs: SubstsRef<'tcx>\n-    ) -> InterpResult<'tcx, T> {\n-        // miri doesn't care about lifetimes, and will choke on some crazy ones\n-        // let's simply get rid of them\n-        let substituted = t.subst(*self.tcx, substs);\n-\n-        if substituted.needs_subst() {\n-            throw_inval!(TooGeneric)\n-        }\n-\n-        Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n+    ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n+        trace!(\"param_env: {:#?}\", self.param_env);\n+        trace!(\"substs: {:#?}\", substs);\n+        ty::Instance::resolve(\n+            *self.tcx,\n+            self.param_env,\n+            def_id,\n+            substs,\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn layout_of_local(\n@@ -391,7 +356,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs)?;\n+                    let local_ty = self.tcx.subst_and_normalize_erasing_regions(\n+                        frame.instance.substs,\n+                        self.param_env,\n+                        &local_ty,\n+                    );\n                     self.layout_of(local_ty)\n                 })?;\n                 if let Some(state) = frame.locals.get(local) {"}, {"sha": "4c86c53256e9b67ca7a3d41fc9040a3d9cf84a35", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -137,7 +137,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let l = self.read_immediate(args[0])?;\n                 let r = self.read_immediate(args[1])?;\n                 let is_add = intrinsic_name == \"saturating_add\";\n-                let (val, overflowed) = self.binary_op(if is_add {\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(if is_add {\n                     BinOp::Add\n                 } else {\n                     BinOp::Sub\n@@ -184,7 +184,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     \"unchecked_shr\" => BinOp::Shr,\n                     _ => bug!(\"Already checked for int ops\")\n                 };\n-                let (val, overflowed) = self.binary_op(bin_op, l, r)?;\n+                let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, l, r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = r.to_scalar()?.to_bits(layout.size)?;"}, {"sha": "bb74a50156e564f6c4470aab31412ffa0437adba", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -7,7 +7,7 @@ use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n@@ -176,7 +176,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool, Ty<'tcx>)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc("}, {"sha": "87d36dabb04721b36508d673e9828f1164e4eaf4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -297,7 +297,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// and `align`. On success, returns `None` for zero-sized accesses (where\n     /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n     /// Crucially, if the input is a `Pointer`, we will test it for liveness\n-    /// *even of* the size is 0.\n+    /// *even if* the size is 0.\n     ///\n     /// Everyone accessing memory based on a `Scalar` should use this method to get the\n     /// `Pointer` they need. And even if you already have a `Pointer`, call this method"}, {"sha": "7a545e8ad6f792abbee4190061bf46eed0ac56fd", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -108,7 +108,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag=()> {\n-    pub imm: Immediate<Tag>,\n+    pub(crate) imm: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -155,7 +155,7 @@ impl<Tag> Operand<Tag> {\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct OpTy<'tcx, Tag=()> {\n-    op: Operand<Tag>,\n+    op: Operand<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -187,13 +187,22 @@ impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n-{\n+impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n         ImmTy { imm: val.into(), layout }\n     }\n \n+    #[inline]\n+    pub fn from_uint(i: impl Into<u128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_uint(i, layout.size), layout)\n+    }\n+\n+    #[inline]\n+    pub fn from_int(i: impl Into<i128>, layout: TyLayout<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::from_int(i, layout.size), layout)\n+    }\n+\n     #[inline]\n     pub fn to_bits(self) -> InterpResult<'tcx, u128> {\n         self.to_scalar()?.to_bits(self.layout.size)\n@@ -513,7 +522,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Move(ref place) =>\n                 self.eval_place_to_op(place, layout)?,\n \n-            Constant(ref constant) => self.eval_const_to_op(constant.literal, layout)?,\n+            Constant(ref constant) => {\n+                let val = self.subst_from_frame_and_normalize_erasing_regions(constant.literal);\n+                self.eval_const_to_op(val, layout)?\n+            }\n         };\n         trace!(\"{:?}: {:?}\", mir_op, *op);\n         Ok(op)\n@@ -531,6 +543,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     // Used when the miri-engine runs into a constant and for extracting information from constants\n     // in patterns via the `const_eval` module\n+    /// The `val` and `layout` are assumed to already be in our interpreter\n+    /// \"universe\" (param_env).\n     crate fn eval_const_to_op(\n         &self,\n         val: &'tcx ty::Const<'tcx>,\n@@ -543,7 +557,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Early-return cases.\n         match val.val {\n             ConstValue::Param(_) =>\n-                // FIXME(oli-obk): try to monomorphize\n                 throw_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -556,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n         // Other cases need layout.\n         let layout = from_known_layout(layout, || {\n-            self.layout_of(self.monomorphize(val.ty)?)\n+            self.layout_of(val.ty)\n         })?;\n         let op = match val.val {\n             ConstValue::ByRef { alloc, offset } => {"}, {"sha": "470cc9346ee21407593440891d21eecdbef0a108", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n+use rustc::ty::{self, Ty, layout::{TyLayout, LayoutOf}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n@@ -17,7 +17,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, overflowed) = self.binary_op(op, left, right)?;\n+        let (val, overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        debug_assert_eq!(\n+            self.tcx.intern_tup(&[ty, self.tcx.types.bool]),\n+            dest.layout.ty,\n+            \"type mismatch for result of {:?}\", op,\n+        );\n         let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_immediate(val, dest)\n     }\n@@ -31,7 +36,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n+        assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);\n         self.write_scalar(val, dest)\n     }\n }\n@@ -42,7 +48,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -54,15 +60,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_bool_op(\n         &self,\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -77,32 +83,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return (Scalar::from_bool(res), false);\n+        return (Scalar::from_bool(res), false, self.tcx.types.bool);\n     }\n \n     fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n         &self,\n         bin_op: mir::BinOp,\n+        ty: Ty<'tcx>,\n         l: F,\n         r: F,\n-    ) -> (Scalar<M::PointerTag>, bool) {\n+    ) -> (Scalar<M::PointerTag>, bool, Ty<'tcx>) {\n         use rustc::mir::BinOp::*;\n \n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n-            Add => (l + r).value.into(),\n-            Sub => (l - r).value.into(),\n-            Mul => (l * r).value.into(),\n-            Div => (l / r).value.into(),\n-            Rem => (l % r).value.into(),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n+            Add => ((l + r).value.into(), ty),\n+            Sub => ((l - r).value.into(), ty),\n+            Mul => ((l * r).value.into(), ty),\n+            Div => ((l / r).value.into(), ty),\n+            Rem => ((l % r).value.into(), ty),\n             _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n         };\n-        return (val, false);\n+        return (val, false, ty);\n     }\n \n     fn binary_int_op(\n@@ -113,7 +120,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         left_layout: TyLayout<'tcx>,\n         r: u128,\n         right_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc::mir::BinOp::*;\n \n         // Shift ops can have an RHS with a different numeric type.\n@@ -142,7 +149,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::from_uint(truncated, size), oflo));\n+            return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -167,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n-                return Ok((Scalar::from_bool(op(&l, &r)), false));\n+                return Ok((Scalar::from_bool(op(&l, &r)), false, self.tcx.types.bool));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n                 Div if r == 0 => throw_panic!(DivisionByZero),\n@@ -187,7 +194,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_uint(l, size), true));\n+                            return Ok((Scalar::from_uint(l, size), true, left_layout.ty));\n                         }\n                     },\n                     _ => {},\n@@ -202,25 +209,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // this may be out-of-bounds for the result type, so we have to truncate ourselves\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo));\n+                return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n             }\n         }\n \n         let size = left_layout.size;\n \n-        // only ints left\n-        let val = match bin_op {\n-            Eq => Scalar::from_bool(l == r),\n-            Ne => Scalar::from_bool(l != r),\n+        let (val, ty) = match bin_op {\n+            Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n+            Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n \n-            Lt => Scalar::from_bool(l < r),\n-            Le => Scalar::from_bool(l <= r),\n-            Gt => Scalar::from_bool(l > r),\n-            Ge => Scalar::from_bool(l >= r),\n+            Lt => (Scalar::from_bool(l < r), self.tcx.types.bool),\n+            Le => (Scalar::from_bool(l <= r), self.tcx.types.bool),\n+            Gt => (Scalar::from_bool(l > r), self.tcx.types.bool),\n+            Ge => (Scalar::from_bool(l >= r), self.tcx.types.bool),\n \n-            BitOr => Scalar::from_uint(l | r, size),\n-            BitAnd => Scalar::from_uint(l & r, size),\n-            BitXor => Scalar::from_uint(l ^ r, size),\n+            BitOr => (Scalar::from_uint(l | r, size), left_layout.ty),\n+            BitAnd => (Scalar::from_uint(l & r, size), left_layout.ty),\n+            BitXor => (Scalar::from_uint(l ^ r, size), left_layout.ty),\n \n             Add | Sub | Mul | Rem | Div => {\n                 debug_assert!(!left_layout.abi.is_signed());\n@@ -236,7 +242,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo || truncated != result));\n+                return Ok((\n+                    Scalar::from_uint(truncated, size),\n+                    oflo || truncated != result,\n+                    left_layout.ty,\n+                ));\n             }\n \n             _ => {\n@@ -250,17 +260,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         };\n \n-        Ok((val, false))\n+        Ok((val, false, ty))\n     }\n \n-    /// Returns the result of the specified operation and whether it overflowed.\n-    #[inline]\n-    pub fn binary_op(\n+    /// Returns the result of the specified operation, whether it overflowed, and\n+    /// the result type.\n+    pub fn overflowing_binary_op(\n         &self,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, M::PointerTag>,\n         right: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, *left, left.layout.ty, *right, right.layout.ty);\n \n@@ -279,11 +289,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n+                let ty = left.layout.ty;\n                 let left = left.to_scalar()?;\n                 let right = right.to_scalar()?;\n                 Ok(match fty {\n-                    FloatTy::F32 => self.binary_float_op(bin_op, left.to_f32()?, right.to_f32()?),\n-                    FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n+                    FloatTy::F32 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f32()?, right.to_f32()?),\n+                    FloatTy::F64 =>\n+                        self.binary_float_op(bin_op, ty, left.to_f64()?, right.to_f64()?),\n                 })\n             }\n             _ if left.layout.ty.is_integral() => {\n@@ -312,11 +325,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Typed version of `checked_binary_op`, returning an `ImmTy`. Also ignores overflows.\n+    #[inline]\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        let (val, _overflow, ty) = self.overflowing_binary_op(bin_op, left, right)?;\n+        Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n+    }\n+\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         use rustc::mir::UnOp::*;\n \n         let layout = val.layout;\n@@ -330,15 +355,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Not => !val,\n                     _ => bug!(\"Invalid bool op {:?}\", un_op)\n                 };\n-                Ok(Scalar::from_bool(res))\n+                Ok(ImmTy::from_scalar(Scalar::from_bool(res), self.layout_of(self.tcx.types.bool)?))\n             }\n             ty::Float(fty) => {\n                 let res = match (un_op, fty) {\n                     (Neg, FloatTy::F32) => Scalar::from_f32(-val.to_f32()?),\n                     (Neg, FloatTy::F64) => Scalar::from_f64(-val.to_f64()?),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(res)\n+                Ok(ImmTy::from_scalar(res, layout))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n@@ -351,7 +376,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // res needs tuncating\n-                Ok(Scalar::from_uint(self.truncate(res, layout), layout.size))\n+                Ok(ImmTy::from_uint(self.truncate(res, layout), layout))\n             }\n         }\n     }"}, {"sha": "85f9cbd37589ab2260f0d66211e44d5539759128", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -45,7 +45,7 @@ pub enum Place<Tag=(), Id=AllocId> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag=()> {\n-    place: Place<Tag>,\n+    place: Place<Tag>, // Keep this private, it helps enforce invariants\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -640,8 +640,11 @@ where\n                         // their layout on return.\n                         PlaceTy {\n                             place: *return_place,\n-                            layout: self\n-                                .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n+                            layout: self.layout_of(\n+                                self.subst_from_frame_and_normalize_erasing_regions(\n+                                    self.frame().body.return_ty()\n+                                )\n+                            )?,\n                         }\n                     }\n                     None => throw_unsup!(InvalidNullPointerUsage),"}, {"sha": "ca4da451a1f2d58f9f57879c683073b107fcb980", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -177,7 +177,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val)?;\n-                self.write_scalar(val, dest)?;\n+                assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n+                self.write_immediate(*val, dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n@@ -253,7 +254,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n-                let ty = self.monomorphize(ty)?;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(ty);\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");"}, {"sha": "5de297923ce7bfa4e7060328939acd040d3123c6", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -7,7 +7,7 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    InterpResult, PointerArithmetic, Scalar,\n+    InterpResult, PointerArithmetic,\n     InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n@@ -50,11 +50,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op, to also support pointer values\n-                    let const_int = Scalar::from_uint(const_int, discr.layout.size);\n-                    let (res, _) = self.binary_op(mir::BinOp::Eq,\n+                    let res = self.overflowing_binary_op(mir::BinOp::Eq,\n                         discr,\n-                        ImmTy::from_scalar(const_int, discr.layout),\n-                    )?;\n+                        ImmTy::from_uint(const_int, discr.layout),\n+                    )?.0;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n                         break;"}, {"sha": "a2fc75739ffa0ae34ffe672fb06c6c395a483fbf", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{self, Ty, Instance};\n+use rustc::ty::{self, Ty, Instance, TypeFoldable};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic,};\n \n@@ -20,6 +20,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n+        // All vtables must be monomorphic, bail out otherwise.\n+        if ty.needs_subst() || poly_trait_ref.needs_subst() {\n+            throw_inval!(TooGeneric);\n+        }\n+\n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n             // This means we guarantee that there are no duplicate vtables, we will\n             // always use the same vtable for the same (Type, Trait) combination.\n@@ -77,7 +82,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 // resolve for vtable: insert shims where needed\n-                let substs = self.subst_and_normalize_erasing_regions(substs)?;\n                 let instance = ty::Instance::resolve_for_vtable(\n                     *self.tcx,\n                     self.param_env,"}, {"sha": "3e02f6c3725fdba6e48f359b88de5daea397a73c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -708,7 +708,7 @@ fn build_call_shim<'tcx>(\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n-            assert!(arg_ty.is_self());\n+            debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n             Operand::Move(rcvr_l.deref())"}, {"sha": "98d8ca58ee1647d671f0baf1305f71cf17153167", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -19,7 +19,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout, Size,\n+    LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n use crate::interpret::{\n@@ -396,30 +396,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 if let ty::Slice(_) = mplace.layout.ty.sty {\n                     let len = mplace.meta.unwrap().to_usize(&self.ecx).unwrap();\n \n-                    Some(ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(\n-                                len,\n-                                Size::from_bits(\n-                                    self.tcx.sess.target.usize_ty.bit_width().unwrap() as u64\n-                                )\n-                            ).into(),\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into())\n+                    Some(ImmTy::from_uint(\n+                        len,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into())\n                 } else {\n                     trace!(\"not slice: {:?}\", mplace.layout.ty.sty);\n                     None\n                 }\n             },\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n-                    ImmTy {\n-                        imm: Immediate::Scalar(\n-                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n-                        ),\n-                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into()\n+                    ImmTy::from_uint(\n+                        n,\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ).into()\n                 ))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n@@ -452,11 +443,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim)\n                 })?;\n-                let res = ImmTy {\n-                    imm: Immediate::Scalar(val.into()),\n-                    layout: place_layout,\n-                };\n-                Some(res.into())\n+                Some(val.into())\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -510,8 +497,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     this.ecx.read_immediate(left)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n-                let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, r)\n+                let (val, overflow, _ty) = self.use_ecx(source_info, |this| {\n+                    this.ecx.overflowing_binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Immediate::ScalarPair("}, {"sha": "1547e607b9c61a2842471530b9025d72e2195023", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::TyCtxt;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::{self, Node, Destination};\n+use rustc::hir::{self, Node, Destination, GeneratorMovability};\n use syntax::struct_span_err;\n use syntax_pos::Span;\n use errors::Applicability;\n@@ -17,6 +17,7 @@ enum Context {\n     Normal,\n     Loop(hir::LoopSource),\n     Closure,\n+    AsyncClosure,\n     LabeledBlock,\n     AnonConst,\n }\n@@ -57,9 +58,14 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprKind::Loop(ref b, _, source) => {\n                 self.with_context(Loop(source), |v| v.visit_block(&b));\n             }\n-            hir::ExprKind::Closure(_, ref function_decl, b, _, _) => {\n+            hir::ExprKind::Closure(_, ref function_decl, b, _, movability) => {\n+                let cx = if let Some(GeneratorMovability::Static) = movability {\n+                    AsyncClosure\n+                } else {\n+                    Closure\n+                };\n                 self.visit_fn_decl(&function_decl);\n-                self.with_context(Closure, |v| v.visit_nested_body(b));\n+                self.with_context(cx, |v| v.visit_nested_body(b));\n             }\n             hir::ExprKind::Block(ref b, Some(_label)) => {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n@@ -171,6 +177,11 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n                 .span_label(span, \"cannot break inside of a closure\")\n                 .emit();\n             }\n+            AsyncClosure => {\n+                struct_span_err!(self.sess, span, E0267, \"`{}` inside of an async block\", name)\n+                    .span_label(span, \"cannot break inside of an async block\")\n+                    .emit();\n+            }\n             Normal | AnonConst => {\n                 struct_span_err!(self.sess, span, E0268, \"`{}` outside of loop\", name)\n                 .span_label(span, \"cannot break outside of a loop\")"}, {"sha": "84a743ed1ad7d0d11752f3237463a4106a401dcf", "filename": "src/librustc_plugin/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,12 +1,12 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n build = false\n edition = \"2018\"\n \n [lib]\n-name = \"rustc_plugin\"\n+name = \"rustc_plugin_impl\"\n path = \"lib.rs\"\n doctest = false\n "}, {"sha": "cc75f7b9ab20d1e8e20a20c3af6cd46539307554", "filename": "src/librustc_plugin/deprecated/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2FCargo.toml?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+build = false\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_plugin\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+rustc_plugin_impl = { path = \"..\" }"}, {"sha": "5fb18066759c638212258d4dce436f2a67849d3e", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,8 @@\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(staged_api)]\n+#![unstable(feature = \"rustc_plugin\", issue = \"29597\")]\n+#![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n+    import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n+    See https://github.com/rust-lang/rust/issues/62717\")]\n+\n+pub use rustc_plugin_impl::*;"}, {"sha": "952bc9fff6a712dd436918856740606270066a18", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -16,12 +16,11 @@\n //! #![feature(plugin_registrar)]\n //! #![feature(rustc_private)]\n //!\n-//! extern crate rustc_plugin;\n //! extern crate rustc_driver;\n //! extern crate syntax;\n //! extern crate syntax_pos;\n //!\n-//! use rustc_plugin::Registry;\n+//! use rustc_driver::plugin::Registry;\n //! use syntax::ext::base::{ExtCtxt, MacResult};\n //! use syntax_pos::Span;\n //! use syntax::tokenstream::TokenTree;"}, {"sha": "42428456b6eec39de4c2640a129c0428714a18c4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -160,12 +160,25 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     crate fn build_reduced_graph(\n-        &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n+        &mut self,\n+        fragment: &AstFragment,\n+        extra_placeholders: &[NodeId],\n+        parent_scope: ParentScope<'a>,\n     ) -> LegacyScope<'a> {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n+        let mut def_collector = DefCollector::new(&mut self.definitions, parent_scope.expansion);\n+        fragment.visit_with(&mut def_collector);\n+        for placeholder in extra_placeholders {\n+            def_collector.visit_macro_invoc(*placeholder);\n+        }\n+\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n+        for placeholder in extra_placeholders {\n+            visitor.parent_scope.legacy = visitor.visit_invoc(*placeholder);\n+        }\n+\n         visitor.parent_scope.legacy\n     }\n \n@@ -871,7 +884,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n@@ -1060,10 +1073,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");"}, {"sha": "2dd0ad13c526d80b4d653db5df3e474b69a94d01", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -448,7 +448,7 @@ pub struct ModuleData<'a> {\n     populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -478,7 +478,7 @@ impl<'a> ModuleData<'a> {\n             normal_ancestor_id,\n             lazy_resolutions: Default::default(),\n             populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n-            unresolved_invocations: Default::default(),\n+            unexpanded_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),"}, {"sha": "01ad67252a387886f630a7e01ed12f14ad33bd15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -10,7 +10,7 @@ use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n@@ -26,7 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Res = def::Res<ast::NodeId>;\n+type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n@@ -91,11 +91,11 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn next_node_id(&mut self) -> ast::NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n         let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n@@ -115,23 +115,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     fn visit_ast_fragment_with_placeholders(\n-        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, extra_placeholders: &[NodeId]\n     ) {\n-        // Fill in some data for derives if the fragment is from a derive container.\n+        // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let parent_def = self.definitions.invocation_parent(expansion);\n-        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n-        for &derive_invoc_id in derives {\n-            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n-        }\n-        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n-        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n-\n-        // Integrate the new AST fragment into all the definition and module structures.\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n+        let output_legacy_scope =\n+            self.build_reduced_graph(fragment, extra_placeholders, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+\n+        parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -485,7 +480,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n                     Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n@@ -508,7 +503,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n                     Some(binding) => Ok((binding, Flags::PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {"}, {"sha": "fd222a132a3f8589c53df38bff1849c8edb759e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n                     Err((Determined, Weak::No))\n                 } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     Ok(binding)\n-                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n                     Err((Undetermined, Weak::No))\n                 } else {\n@@ -348,7 +348,7 @@ impl<'a> Resolver<'a> {\n         // progress, we have to ignore those potential unresolved invocations from other modules\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n         if let Some(binding) = resolution.binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);"}, {"sha": "9e52eae88ef45fbdf411a0ad5794b59dad58f42e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -635,8 +635,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n-                if is_object && has_default {\n-                    if tcx.at(span).type_of(param.def_id).has_self_ty() {\n+                if is_object && has_default && has_self {\n+                    let self_param = tcx.types.self_param;\n+                    if tcx.at(span).type_of(param.def_id).walk().any(|ty| ty == self_param) {\n                         // There is no suitable inference default for a type parameter\n                         // that references self, in an object type.\n                         return true;\n@@ -2030,7 +2031,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n-                tcx.mk_self_type()\n+                tcx.types.self_param\n             }\n             Res::SelfTy(_, Some(def_id)) => {\n                 // `Self` in impl (we know the concrete type)."}, {"sha": "fc25eb44cbd888888c1b01b47622e16472754230", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -53,6 +53,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_non_ref_pat = match pat.node {\n             PatKind::Struct(..) |\n             PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n             PatKind::Tuple(..) |\n             PatKind::Box(_) |\n             PatKind::Range(..) |\n@@ -309,6 +310,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::Struct(ref qpath, ref fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n             }\n+            PatKind::Or(ref pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n             PatKind::Tuple(ref elements, ddpos) => {\n                 let mut expected_len = elements.len();\n                 if ddpos.is_some() {"}, {"sha": "8e187b7e05b51ab0e10a0b7729be4ce1b947cd57", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -518,7 +518,7 @@ fn compare_self_type<'tcx>(\n     let self_string = |method: &ty::AssocItem| {\n         let untransformed_self_ty = match method.container {\n             ty::ImplContainer(_) => impl_trait_ref.self_ty(),\n-            ty::TraitContainer(_) => tcx.mk_self_type()\n+            ty::TraitContainer(_) => tcx.types.self_param\n         };\n         let self_arg_ty = *tcx.fn_sig(method.def_id).input(0).skip_binder();\n         let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "9c6ea7d30ccf980830c33f22f9815c02cbd5a521", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -191,7 +191,7 @@ fn check_associated_item(\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n-            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.types.self_param),\n             ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n                                           fcx.tcx.type_of(def_id))\n         };"}, {"sha": "312a598af02bf20962c6a67e6abe8f725afec00f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -716,7 +716,7 @@ fn super_predicates_of(\n     let icx = ItemCtxt::new(tcx, trait_def_id);\n \n     // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.mk_self_type();\n+    let self_param_ty = tcx.types.self_param;\n     let superbounds1 = AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No,\n         item.span);\n \n@@ -900,6 +900,20 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n             Some(tcx.hir().local_def_id(parent_id))\n         }\n+        // FIXME(#43408) enable this in all cases when we get lazy normalization.\n+        Node::AnonConst(&anon_const) => {\n+            // HACK(eddyb) this provides the correct generics when the workaround\n+            // for a const parameter `AnonConst` is being used elsewhere, as then\n+            // there won't be the kind of cyclic dependency blocking #43408.\n+            let expr = &tcx.hir().body(anon_const.body).value;\n+            let icx = ItemCtxt::new(tcx, def_id);\n+            if AstConv::const_param_def_id(&icx, expr).is_some() {\n+                let parent_id = tcx.hir().get_parent_item(hir_id);\n+                Some(tcx.hir().local_def_id(parent_id))\n+            } else {\n+                None\n+            }\n+        }\n         Node::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n@@ -1014,13 +1028,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         synthetic,\n                         ..\n                     } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\"\n-                            );\n-                        }\n-\n                         if !allow_defaults && default.is_some() {\n                             if !tcx.features().default_type_parameter_fallback {\n                                 tcx.lint_hir(\n@@ -1044,13 +1051,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                         }\n                     }\n                     GenericParamKind::Const { .. } => {\n-                        if param.name.ident().name == kw::SelfUpper {\n-                            span_bug!(\n-                                param.span,\n-                                \"`Self` should not be the name of a regular parameter\",\n-                            );\n-                        }\n-\n                         ty::GenericParamDefKind::Const\n                     }\n                     _ => return None,\n@@ -1567,7 +1567,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                     &format!(\n                                         \"defining opaque type use restricts opaque \\\n                                          type by using the generic parameter `{}` twice\",\n-                                        p.name\n+                                        p,\n                                     ),\n                                 );\n                                 return;"}, {"sha": "644d723ded5d96e60a3369ea7fb4d6aff0ac114a", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,7 +3,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::TypeFoldable;\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -178,11 +177,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 // let _: () = substs.region_at(0);\n                 check_explicit_predicates(\n                     tcx,\n-                    &def.did,\n+                    def.did,\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -208,11 +207,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                         .substs;\n                     check_explicit_predicates(\n                         tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n+                        ex_trait_ref.skip_binder().def_id,\n                         substs,\n                         required_predicates,\n                         explicit_map,\n-                        IgnoreSelfTy(true),\n+                        Some(tcx.types.self_param),\n                     );\n                 }\n             }\n@@ -223,11 +222,11 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Projection\");\n                 check_explicit_predicates(\n                     tcx,\n-                    &tcx.associated_item(obj.item_def_id).container.id(),\n+                    tcx.associated_item(obj.item_def_id).container.id(),\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    IgnoreSelfTy(false),\n+                    None,\n                 );\n             }\n \n@@ -236,9 +235,6 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n-#[derive(Debug)]\n-pub struct IgnoreSelfTy(bool);\n-\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -256,25 +252,25 @@ pub struct IgnoreSelfTy(bool);\n /// applying the substitution as above.\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: &DefId,\n+    def_id: DefId,\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: IgnoreSelfTy,\n+    ignored_self_ty: Option<Ty<'tcx>>,\n ) {\n     debug!(\n         \"check_explicit_predicates(def_id={:?}, \\\n          substs={:?}, \\\n          explicit_map={:?}, \\\n          required_predicates={:?}, \\\n-         ignore_self_ty={:?})\",\n+         ignored_self_ty={:?})\",\n         def_id,\n         substs,\n         explicit_map,\n         required_predicates,\n-        ignore_self_ty,\n+        ignored_self_ty,\n     );\n-    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, *def_id);\n+    let explicit_predicates = explicit_map.explicit_predicates_of(tcx, def_id);\n \n     for outlives_predicate in explicit_predicates.iter() {\n         debug!(\"outlives_predicate = {:?}\", &outlives_predicate);\n@@ -313,9 +309,9 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if ignore_self_ty.0 {\n+        if let Some(self_ty) = ignored_self_ty {\n             if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.has_self_ty() {\n+                if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "9b4803ce41e290718ebb9ef7a609b4cccf5a7564", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2303,7 +2303,7 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(def_id) => {\n                             cx.tcx.type_of(def_id)\n                         }\n-                        ty::TraitContainer(_) => cx.tcx.mk_self_type()\n+                        ty::TraitContainer(_) => cx.tcx.types.self_param,\n                     };\n                     let self_arg_ty = *sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -4107,6 +4107,9 @@ fn name_from_pat(p: &hir::Pat) -> String {\n                 if etc { \", ..\" } else { \"\" }\n             )\n         }\n+        PatKind::Or(ref pats) => {\n+            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n+        }\n         PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n                                             .collect::<Vec<String>>().join(\", \")),\n         PatKind::Box(ref p) => name_from_pat(&**p),"}, {"sha": "3801c42307fc6f00099bfb01217c258dfa809dda", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -149,9 +149,11 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n         return true\n     }\n     let predicates = cx.tcx.super_predicates_of(child);\n+    debug_assert!(cx.tcx.generics_of(child).has_self);\n+    let self_ty = cx.tcx.types.self_param;\n     predicates.predicates.iter().filter_map(|(pred, _)| {\n         if let ty::Predicate::Trait(ref pred) = *pred {\n-            if pred.skip_binder().trait_ref.self_ty().is_self() {\n+            if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                 Some(pred.def_id())\n             } else {\n                 None"}, {"sha": "bb77a5bdea493e1eb2d820e6fe5824981dbca4a6", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -26,7 +26,7 @@ unwind = { path = \"../libunwind\" }\n hashbrown = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [dependencies.backtrace]\n-version = \"0.3.34\"\n+version = \"0.3.35\"\n default-features = false # don't use coresymbolication on OSX\n features = [\n   \"rustc-dep-of-std\", # enable build support for integrating into libstd"}, {"sha": "ba797354a7380f30935297b4dcf3110571e51f6d", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -155,7 +155,7 @@ impl Command {\n         _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>,\n     ) {\n         // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n-        unimplemented!();;\n+        unimplemented!();\n     }\n \n     pub fn stdin(&mut self, stdin: Stdio) {"}, {"sha": "50e428ea0cca6ce1702303a1453033182e5a6922", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -572,9 +572,10 @@ impl Pat {\n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n             PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n-            PatKind::TupleStruct(_, s) | PatKind::Tuple(s) | PatKind::Slice(s) => {\n-                s.iter().all(|p| p.walk(it))\n-            }\n+            PatKind::TupleStruct(_, s)\n+            | PatKind::Tuple(s)\n+            | PatKind::Slice(s)\n+            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n             PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n@@ -648,6 +649,10 @@ pub enum PatKind {\n     /// A tuple struct/variant pattern (`Variant(x, y, .., z)`).\n     TupleStruct(Path, Vec<P<Pat>>),\n \n+    /// An or-pattern `A | B | C`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or(Vec<P<Pat>>),\n+\n     /// A possibly qualified path pattern.\n     /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n     /// or associated constants. Qualified path patterns `<A>::B::C`/`<A as Trait>::B::C` can"}, {"sha": "b0a4a6af9839c4fd91e6f33541b241c3f313593c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Attribute, Name, PatKind};\n+use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n@@ -671,13 +671,13 @@ bitflags::bitflags! {\n }\n \n pub trait Resolver {\n-    fn next_node_id(&mut self) -> ast::NodeId;\n+    fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]);\n+                                            extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);"}, {"sha": "c1d52c9745529125ddcfed00d900d8bd5d65731c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n+        let mut all_derive_placeholders: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -347,13 +347,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derives = derives.entry(invoc.expansion_data.id).or_default();\n+                let derive_placeholders =\n+                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n \n-                derives.reserve(traits.len());\n+                derive_placeholders.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n                     let expn_id = ExpnId::fresh(None);\n-                    derives.push(expn_id);\n+                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n@@ -365,7 +366,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 let fragment = invoc.fragment_kind\n                     .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derives)\n+                self.collect_invocations(fragment, derive_placeholders)\n             } else {\n                 unreachable!()\n             };\n@@ -384,10 +385,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n-            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n-                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n-                                         expanded_fragment, derives);\n+            for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n+                let derive_placeholders =\n+                    all_derive_placeholders.remove(&expn_id).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(expn_id),\n+                                         expanded_fragment, derive_placeholders);\n             }\n         }\n         fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n@@ -404,7 +406,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, extra_placeholders: &[NodeId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -423,9 +425,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             collector.invocations\n         };\n \n+        // FIXME: Merge `extra_placeholders` into the `fragment` as regular placeholders.\n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.id, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, extra_placeholders);\n         }\n \n         (fragment, invocations)"}, {"sha": "d800cfedcfb4b27796b7a01f34ba3081479f0a2e", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -86,11 +85,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, placeholders: Vec<NodeId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n-            for derive in derives {\n-                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n+            for placeholder in placeholders {\n+                match self.remove(placeholder) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "bbc3ae28225587491bc700aa5633de2eb25736d8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -559,6 +559,9 @@ declare_features! (\n     // Allows `impl Trait` to be used inside type aliases (RFC 2515).\n     (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n \n+    // Allows the use of or-patterns, e.g. `0 | 1`.\n+    (active, or_patterns, \"1.38.0\", Some(54883), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -571,6 +574,7 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::impl_trait_in_bindings,\n     sym::generic_associated_types,\n     sym::const_generics,\n+    sym::or_patterns,\n     sym::let_chains,\n ];\n \n@@ -2443,6 +2447,7 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(let_chains_spans, let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure_spans, async_closure, \"async closures are unstable\");\n     gate_all!(yield_spans, generators, \"yield syntax is experimental\");\n+    gate_all!(or_pattern_spans, or_patterns, \"or-patterns syntax is experimental\");\n \n     let visitor = &mut PostExpansionVisitor {\n         context: &ctx,"}, {"sha": "9785f8e2de0980e2f4e5ebe9e3f95226d33da5c9", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1050,15 +1050,16 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n                 vis.visit_span(span);\n             };\n         }\n-        PatKind::Tuple(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Box(inner) => vis.visit_pat(inner),\n         PatKind::Ref(inner, _mutbl) => vis.visit_pat(inner),\n         PatKind::Range(e1, e2, Spanned { span: _, node: _ }) => {\n             vis.visit_expr(e1);\n             vis.visit_expr(e2);\n             vis.visit_span(span);\n         }\n-        PatKind::Slice(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n+        PatKind::Tuple(elems)\n+        | PatKind::Slice(elems)\n+        | PatKind::Or(elems) => visit_vec(elems, |elem| vis.visit_pat(elem)),\n         PatKind::Paren(inner) => vis.visit_pat(inner),\n         PatKind::Mac(mac) => vis.visit_mac(mac),\n     }"}, {"sha": "bdf468a52bb3999d1140cd0aaac5f1c11e6aca00", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 15, "deletions": 66, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,9 +8,7 @@ use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n-use std::borrow::Cow;\n use std::char;\n-use std::iter;\n use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n@@ -181,18 +179,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n                 let tok = if is_doc_comment(string) {\n-                    let mut idx = 0;\n-                    loop {\n-                        idx = match string[idx..].find('\\r') {\n-                            None => break,\n-                            Some(it) => idx + it + 1\n-                        };\n-                        if string[idx..].chars().next() != Some('\\n') {\n-                            self.err_span_(start + BytePos(idx as u32 - 1),\n-                                            start + BytePos(idx as u32),\n-                                            \"bare CR not allowed in doc-comment\");\n-                        }\n-                    }\n+                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n@@ -217,15 +204,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let tok = if is_doc_comment {\n-                    let has_cr = string.contains('\\r');\n-                    let string = if has_cr {\n-                        self.translate_crlf(start,\n-                                            string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else {\n-                        string.into()\n-                    };\n-                    token::DocComment(Symbol::intern(&string[..]))\n+                    self.forbid_bare_cr(start,\n+                                        string,\n+                                        \"bare CR not allowed in block doc-comment\");\n+                    token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n                 };\n@@ -516,49 +498,16 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n-        let mut chars = s.char_indices().peekable();\n-        while let Some((i, ch)) = chars.next() {\n-            if ch == '\\r' {\n-                if let Some((lf_idx, '\\n')) = chars.peek() {\n-                    return translate_crlf_(self, start, s, *lf_idx, chars, errmsg).into();\n-                }\n-                let pos = start + BytePos(i as u32);\n-                let end_pos = start + BytePos((i + ch.len_utf8()) as u32);\n-                self.err_span_(pos, end_pos, errmsg);\n-            }\n-        }\n-        return s.into();\n-\n-        fn translate_crlf_(rdr: &StringReader<'_>,\n-                           start: BytePos,\n-                           s: &str,\n-                           mut j: usize,\n-                           mut chars: iter::Peekable<impl Iterator<Item = (usize, char)>>,\n-                           errmsg: &str)\n-                           -> String {\n-            let mut buf = String::with_capacity(s.len());\n-            // Skip first CR\n-            buf.push_str(&s[.. j - 1]);\n-            while let Some((i, ch)) = chars.next() {\n-                if ch == '\\r' {\n-                    if j < i {\n-                        buf.push_str(&s[j..i]);\n-                    }\n-                    let next = i + ch.len_utf8();\n-                    j = next;\n-                    if chars.peek().map(|(_, ch)| *ch) != Some('\\n') {\n-                        let pos = start + BytePos(i as u32);\n-                        let end_pos = start + BytePos(next as u32);\n-                        rdr.err_span_(pos, end_pos, errmsg);\n-                    }\n-                }\n-            }\n-            if j < s.len() {\n-                buf.push_str(&s[j..]);\n-            }\n-            buf\n+    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n+        let mut idx = 0;\n+        loop {\n+            idx = match s[idx..].find('\\r') {\n+                None => break,\n+                Some(it) => idx + it + 1\n+            };\n+            self.err_span_(start + BytePos(idx as u32 - 1),\n+                           start + BytePos(idx as u32),\n+                           errmsg);\n         }\n     }\n "}, {"sha": "b1f3612a839a2cb41bbe106053a9187257ef7ae6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -66,6 +66,8 @@ pub struct ParseSess {\n     // Places where `yield e?` exprs were used and should be feature gated.\n     pub yield_spans: Lock<Vec<Span>>,\n     pub injected_crate_name: Once<Symbol>,\n+    // Places where or-patterns e.g. `Some(Foo | Bar)` were used and should be feature gated.\n+    pub or_pattern_spans: Lock<Vec<Span>>,\n }\n \n impl ParseSess {\n@@ -96,6 +98,7 @@ impl ParseSess {\n             async_closure_spans: Lock::new(Vec::new()),\n             yield_spans: Lock::new(Vec::new()),\n             injected_crate_name: Once::new(),\n+            or_pattern_spans: Lock::new(Vec::new()),\n         }\n     }\n "}, {"sha": "fd458aec743315792463c1e3d0024734b6d3a5a3", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -14,7 +14,10 @@ use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a> Parser<'a> {\n     /// Parses a pattern.\n-    pub fn parse_pat(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+    pub fn parse_pat(\n+        &mut self,\n+        expected: Option<&'static str>\n+    ) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n@@ -97,6 +100,34 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n+    /// Parses a pattern, that may be a or-pattern (e.g. `Some(Foo | Bar)`).\n+    fn parse_pat_with_or(&mut self, expected: Option<&'static str>) -> PResult<'a, P<Pat>> {\n+        // Parse the first pattern.\n+        let first_pat = self.parse_pat(expected)?;\n+\n+        // If the next token is not a `|`, this is not an or-pattern and\n+        // we should exit here.\n+        if !self.check(&token::BinOp(token::Or)) {\n+            return Ok(first_pat)\n+        }\n+\n+        let lo = first_pat.span;\n+\n+        let mut pats = vec![first_pat];\n+\n+        while self.eat(&token::BinOp(token::Or)) {\n+            pats.push(self.parse_pat_with_range_pat(\n+                true, expected\n+            )?);\n+        }\n+\n+        let or_pattern_span = lo.to(self.prev_span);\n+\n+        self.sess.or_pattern_spans.borrow_mut().push(or_pattern_span);\n+\n+        Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n+    }\n+\n     /// Parses a pattern, with a setting whether modern range patterns (e.g., `a..=b`, `a..b` are\n     /// allowed).\n     fn parse_pat_with_range_pat(\n@@ -240,7 +271,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n-        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_with_or(None)\n+        })?;\n \n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n@@ -483,7 +516,7 @@ impl<'a> Parser<'a> {\n             err.span_label(self.token.span, msg);\n             return Err(err);\n         }\n-        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or(None))?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n@@ -627,7 +660,7 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form \"fieldname: pat\"\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat(None)?;\n+            let pat = self.parse_pat_with_or(None)?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}, {"sha": "4dc00af486013c6973958a3d3eac9d9618eb1afa", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -436,18 +436,30 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_ident(&mut self, ident: ast::Ident);\n     fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n \n-    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n+    fn strsep<T, F>(&mut self, sep: &'static str, space_before: bool,\n+                    b: Breaks, elts: &[T], mut op: F)\n         where F: FnMut(&mut Self, &T),\n     {\n         self.rbox(0, b);\n-        let mut first = true;\n-        for elt in elts {\n-            if first { first = false; } else { self.word_space(\",\"); }\n-            op(self, elt);\n+        if let Some((first, rest)) = elts.split_first() {\n+            op(self, first);\n+            for elt in rest {\n+                if space_before {\n+                    self.space();\n+                }\n+                self.word_space(sep);\n+                op(self, elt);\n+            }\n         }\n         self.end();\n     }\n \n+    fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], op: F)\n+        where F: FnMut(&mut Self, &T),\n+    {\n+        self.strsep(\",\", false, b, elts, op)\n+    }\n+\n     fn maybe_print_comment(&mut self, pos: BytePos) {\n         while let Some(ref cmnt) = self.next_comment() {\n             if cmnt.pos < pos {\n@@ -2353,6 +2365,9 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p));\n                 self.pclose();\n             }\n+            PatKind::Or(ref pats) => {\n+                self.strsep(\"|\", true, Inconsistent, &pats[..], |s, p| s.print_pat(p));\n+            }\n             PatKind::Path(None, ref path) => {\n                 self.print_path(path, true, 0);\n             }\n@@ -2429,16 +2444,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_pats(&mut self, pats: &[P<ast::Pat>]) {\n-        let mut first = true;\n-        for p in pats {\n-            if first {\n-                first = false;\n-            } else {\n-                self.s.space();\n-                self.word_space(\"|\");\n-            }\n-            self.print_pat(p);\n-        }\n+        self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n     }\n \n     fn print_arm(&mut self, arm: &ast::Arm) {"}, {"sha": "91b92d84a811fde2a3336ca6e4c2000bb1391264", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -447,9 +447,6 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n                 visitor.visit_pat(&field.pat)\n             }\n         }\n-        PatKind::Tuple(ref elems) => {\n-            walk_list!(visitor, visit_pat, elems);\n-        }\n         PatKind::Box(ref subpattern) |\n         PatKind::Ref(ref subpattern, _) |\n         PatKind::Paren(ref subpattern) => {\n@@ -465,7 +462,9 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_expr(upper_bound);\n         }\n         PatKind::Wild | PatKind::Rest => {},\n-        PatKind::Slice(ref elems) => {\n+        PatKind::Tuple(ref elems)\n+        | PatKind::Slice(ref elems)\n+        | PatKind::Or(ref elems) => {\n             walk_list!(visitor, visit_pat, elems);\n         }\n         PatKind::Mac(ref mac) => visitor.visit_mac(mac),"}, {"sha": "a17cd7625fb1907ec1b398c27c3d696df9679e75", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1043,6 +1043,7 @@ impl SourceFile {\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n         remove_bom(&mut src);\n+        normalize_newlines(&mut src);\n \n         let src_hash = {\n             let mut hasher: StableHasher<u128> = StableHasher::new();\n@@ -1210,6 +1211,61 @@ fn remove_bom(src: &mut String) {\n     }\n }\n \n+\n+/// Replaces `\\r\\n` with `\\n` in-place in `src`.\n+///\n+/// Returns error if there's a lone `\\r` in the string\n+fn normalize_newlines(src: &mut String) {\n+    if !src.as_bytes().contains(&b'\\r') {\n+        return;\n+    }\n+\n+    // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n+    // While we *can* call `as_mut_vec` and do surgery on the live string\n+    // directly, let's rather steal the contents of `src`. This makes the code\n+    // safe even if a panic occurs.\n+\n+    let mut buf = std::mem::replace(src, String::new()).into_bytes();\n+    let mut gap_len = 0;\n+    let mut tail = buf.as_mut_slice();\n+    loop {\n+        let idx = match find_crlf(&tail[gap_len..]) {\n+            None => tail.len(),\n+            Some(idx) => idx + gap_len,\n+        };\n+        tail.copy_within(gap_len..idx, 0);\n+        tail = &mut tail[idx - gap_len..];\n+        if tail.len() == gap_len {\n+            break;\n+        }\n+        gap_len += 1;\n+    }\n+\n+    // Account for removed `\\r`.\n+    // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n+    let new_len = buf.len() - gap_len;\n+    unsafe {\n+        buf.set_len(new_len);\n+        *src = String::from_utf8_unchecked(buf);\n+    }\n+\n+    fn find_crlf(src: &[u8]) -> Option<usize> {\n+        let mut search_idx = 0;\n+        while let Some(idx) = find_cr(&src[search_idx..]) {\n+            if src[search_idx..].get(idx + 1) != Some(&b'\\n') {\n+                search_idx += idx + 1;\n+                continue;\n+            }\n+            return Some(search_idx + idx);\n+        }\n+        None\n+    }\n+\n+    fn find_cr(src: &[u8]) -> Option<usize> {\n+        src.iter().position(|&b| b == b'\\r')\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //"}, {"sha": "0b8f16bbc3b990859a99d426cf1f654443d0ce58", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -470,6 +470,7 @@ symbols! {\n         option_env,\n         opt_out_copy,\n         or,\n+        or_patterns,\n         Ord,\n         Ordering,\n         Output,"}, {"sha": "6bd6016020a27a94ed6d9f75e7022b961389abc9", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -16,3 +16,23 @@ fn test_lookup_line() {\n     assert_eq!(lookup_line(lines, BytePos(28)), 2);\n     assert_eq!(lookup_line(lines, BytePos(29)), 2);\n }\n+\n+#[test]\n+fn test_normalize_newlines() {\n+    fn check(before: &str, after: &str) {\n+        let mut actual = before.to_string();\n+        normalize_newlines(&mut actual);\n+        assert_eq!(actual.as_str(), after);\n+    }\n+    check(\"\", \"\");\n+    check(\"\\n\", \"\\n\");\n+    check(\"\\r\", \"\\r\");\n+    check(\"\\r\\r\", \"\\r\\r\");\n+    check(\"\\r\\n\", \"\\n\");\n+    check(\"hello world\", \"hello world\");\n+    check(\"hello\\nworld\", \"hello\\nworld\");\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n+    check(\"\\r\\r\\n\", \"\\r\\n\");\n+    check(\"hello\\rworld\", \"hello\\rworld\");\n+}"}, {"sha": "619cce685d75f581a9c204f7bfefba50c9e55dde", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -259,8 +259,6 @@ fn _12() {\n     }\n }\n \n-/////////////////\n-\n fn foo() { }\n fn foo3(_: i32, _: (), _: ()) { }\n fn qux(_: i32) { }"}, {"sha": "c053c715248769649c14dffdf83342b47ae3d22e", "filename": "src/test/ui-fulldeps/auxiliary/attr-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fattr-plugin-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc_driver;\n-extern crate rustc_plugin;\n extern crate syntax;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::AttributeType;\n use syntax::symbol::Symbol;"}, {"sha": "6fb99b2c98361dec7155763b48e04fefb5cda351", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,11 +3,10 @@\n \n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::attr;\n use syntax::ext::base::*;\n use syntax::feature_gate::AttributeType::Whitelisted;"}, {"sha": "17386d7e1aa5fe46e7cbd559c8cc8eba6412e5b7", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax)]\n \n #[macro_use] extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;"}, {"sha": "000e10392e827118438a665fa41e69b91c47cd65", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax)]\n \n #[macro_use] extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax;\n \n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n use syntax::symbol::Symbol;"}, {"sha": "a377b07bd3dd21562cd4ad475d14829568608aac", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,12 +6,11 @@\n // Load rustc as a plugin to get macros.\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::hir;\n use rustc::lint::{LateContext, LintContext, LintPass, LateLintPass, LateLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "02675191f785ea7366d24e8b476722b4375ea8f3", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,12 +8,11 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n                   EarlyLintPassObject, LintArray};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n "}, {"sha": "40f8d490ac87cec58f98939ebd5bda79789b1537", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,11 +6,10 @@ extern crate syntax;\n // Load rustc as a plugin to get macros\n #[macro_use]\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n declare_tool_lint!("}, {"sha": "2ff1c2e363d50c86ddeb3c3cdf4f529dea716c82", "filename": "src/test/ui-fulldeps/auxiliary/llvm-pass-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fllvm-pass-plugin.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "89bc9a2b9dbf490ad5b1f3cb117a95ace50051ac", "filename": "src/test/ui-fulldeps/auxiliary/lto-syntax-extension-plugin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flto-syntax-extension-plugin.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,10 +4,9 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_reg: &mut Registry) {}"}, {"sha": "ee82c0adc86042a9ca72a8be0d601e7d2deab4b3", "filename": "src/test/ui-fulldeps/auxiliary/macro-crate-test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro-crate-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,7 +6,6 @@\n \n extern crate syntax;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n extern crate syntax_pos;\n extern crate proc_macro;"}, {"sha": "e5c4f5b8f7a664a57926a67e55f837ef9aa62bde", "filename": "src/test/ui-fulldeps/auxiliary/outlive-expansion-phase.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Foutlive-expansion-phase.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,12 +4,11 @@\n #![feature(box_syntax, rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use std::any::Any;\n use std::cell::RefCell;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n struct Foo {\n     foo: isize"}, {"sha": "5ff24cff23c558aae7bee040c8c298b32e9dcd93", "filename": "src/test/ui-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,7 +6,6 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use std::borrow::ToOwned;\n@@ -17,7 +16,7 @@ use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenStream;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n struct Expander {\n     args: Vec<ast::NestedMetaItem>,"}, {"sha": "1c0de98da56f21faa30af030d0a7bcc05bd9430a", "filename": "src/test/ui-fulldeps/auxiliary/rlib-crate-test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Frlib-crate-test.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,10 +4,9 @@\n #![feature(plugin_registrar, rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n #[plugin_registrar]\n pub fn plugin_registrar(_: &mut Registry) {}"}, {"sha": "027025b72b31bff52fd0bb71d444fc7ce6b47c64", "filename": "src/test/ui-fulldeps/auxiliary/roman-numerals.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Froman-numerals.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -12,14 +12,13 @@\n extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc;\n-extern crate rustc_plugin;\n extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n-use rustc_plugin::Registry;\n+use rustc_driver::plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         -> Box<dyn MacResult + 'static> {"}, {"sha": "a58cec53421427b972603994a504677f27b8e752", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,32 @@\n+// This test documents that `type Out = Box<dyn Bar<Assoc: Copy>>;`\n+// is allowed and will correctly reject an opaque `type Out` which\n+// does not satisfy the bound `<TheType as Bar>::Assoc: Copy`.\n+//\n+// FIXME(rust-lang/lang): I think this behavior is logical if we want to allow\n+// `dyn Trait<Assoc: Bound>` but we should decide if we want that. // Centril\n+//\n+// Additionally, as reported in https://github.com/rust-lang/rust/issues/63594,\n+// we check that the spans for the error message are sane here.\n+\n+#![feature(associated_type_bounds)]\n+\n+fn main() {}\n+\n+trait Bar { type Assoc; }\n+\n+trait Thing {\n+    type Out;\n+    fn func() -> Self::Out;\n+}\n+\n+struct AssocNoCopy;\n+impl Bar for AssocNoCopy { type Assoc = String; }\n+\n+impl Thing for AssocNoCopy {\n+    type Out = Box<dyn Bar<Assoc: Copy>>;\n+    //~^ ERROR the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+\n+    fn func() -> Self::Out {\n+        Box::new(AssocNoCopy)\n+    }\n+}"}, {"sha": "b6b49c2e903508d75e01d7def22695f2975e15ad", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:26:28\n+   |\n+LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n+   |                            ^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a89fd9807da8f0ee9f970eb48621909622c79926", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 94, "deletions": 71, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,161 +1,184 @@\n // compile-fail\n // ignore-tidy-linelength\n-// error-pattern:could not find defining uses\n \n #![feature(associated_type_bounds)]\n #![feature(type_alias_impl_trait)]\n-#![feature(impl_trait_in_bindings)]\n+#![feature(impl_trait_in_bindings)] //~ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash [incomplete_features]\n #![feature(untagged_unions)]\n \n use std::iter;\n \n struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n \n trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS1: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n \n type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n-//~^ the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~| ERROR could not find defining uses\n+//~| ERROR could not find defining uses\n \n fn main() {}"}, {"sha": "e5e85d6856fd315aafc6259e271dec85b7b138b8", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 148, "deletions": 76, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,634 +1,706 @@\n warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n-  --> $DIR/duplicate.rs:7:12\n+  --> $DIR/duplicate.rs:6:12\n    |\n LL | #![feature(impl_trait_in_bindings)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:12:36\n+  --> $DIR/duplicate.rs:11:36\n    |\n LL | struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:14:36\n+  --> $DIR/duplicate.rs:13:36\n    |\n LL | struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:16:39\n+  --> $DIR/duplicate.rs:15:39\n    |\n LL | struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:18:45\n+  --> $DIR/duplicate.rs:17:45\n    |\n LL | struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:20:45\n+  --> $DIR/duplicate.rs:19:45\n    |\n LL | struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:22:48\n+  --> $DIR/duplicate.rs:21:48\n    |\n LL | struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:25:34\n+  --> $DIR/duplicate.rs:24:34\n    |\n LL | enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:27:34\n+  --> $DIR/duplicate.rs:26:34\n    |\n LL | enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:29:37\n+  --> $DIR/duplicate.rs:28:37\n    |\n LL | enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:31:43\n+  --> $DIR/duplicate.rs:30:43\n    |\n LL | enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:33:43\n+  --> $DIR/duplicate.rs:32:43\n    |\n LL | enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:35:46\n+  --> $DIR/duplicate.rs:34:46\n    |\n LL | enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:38:35\n+  --> $DIR/duplicate.rs:37:35\n    |\n LL | union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:40:35\n+  --> $DIR/duplicate.rs:39:35\n    |\n LL | union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:42:38\n+  --> $DIR/duplicate.rs:41:38\n    |\n LL | union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:44:44\n+  --> $DIR/duplicate.rs:43:44\n    |\n LL | union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:46:44\n+  --> $DIR/duplicate.rs:45:44\n    |\n LL | union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:48:47\n+  --> $DIR/duplicate.rs:47:47\n    |\n LL | union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:51:32\n+  --> $DIR/duplicate.rs:50:32\n    |\n LL | fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:53:32\n+  --> $DIR/duplicate.rs:52:32\n    |\n LL | fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:55:35\n+  --> $DIR/duplicate.rs:54:35\n    |\n LL | fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n    |                    -------------  ^^^^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:57:43\n+  --> $DIR/duplicate.rs:56:43\n    |\n LL | fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:59:43\n+  --> $DIR/duplicate.rs:58:43\n    |\n LL | fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:61:46\n+  --> $DIR/duplicate.rs:60:46\n    |\n LL | fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:70:40\n+  --> $DIR/duplicate.rs:69:40\n    |\n LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:72:40\n+  --> $DIR/duplicate.rs:71:40\n    |\n LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:74:43\n+  --> $DIR/duplicate.rs:73:43\n    |\n LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:64:42\n+  --> $DIR/duplicate.rs:63:42\n    |\n LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:66:42\n+  --> $DIR/duplicate.rs:65:42\n    |\n LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:68:45\n+  --> $DIR/duplicate.rs:67:45\n    |\n LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n    |                              -------------  ^^^^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:77:39\n+  --> $DIR/duplicate.rs:76:39\n    |\n LL | const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:79:39\n+  --> $DIR/duplicate.rs:78:39\n    |\n LL | const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:81:42\n+  --> $DIR/duplicate.rs:80:42\n    |\n LL | const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                           -------------  ^^^^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:83:40\n+  --> $DIR/duplicate.rs:82:40\n    |\n LL | static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:85:40\n+  --> $DIR/duplicate.rs:84:40\n    |\n LL | static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:87:43\n+  --> $DIR/duplicate.rs:86:43\n    |\n LL | static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:90:46\n+  --> $DIR/duplicate.rs:89:46\n    |\n LL | fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:92:46\n+  --> $DIR/duplicate.rs:91:46\n    |\n LL | fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:94:49\n+  --> $DIR/duplicate.rs:93:49\n    |\n LL | fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:97:35\n+  --> $DIR/duplicate.rs:96:35\n    |\n LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:99:35\n+  --> $DIR/duplicate.rs:98:35\n    |\n LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:101:38\n+  --> $DIR/duplicate.rs:100:38\n    |\n LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:103:44\n+  --> $DIR/duplicate.rs:102:44\n    |\n LL | type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:105:44\n+  --> $DIR/duplicate.rs:104:44\n    |\n LL | type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:107:47\n+  --> $DIR/duplicate.rs:106:47\n    |\n LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n    |                                -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:110:1\n+  --> $DIR/duplicate.rs:109:1\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:110:36\n+  --> $DIR/duplicate.rs:109:36\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:112:1\n+  --> $DIR/duplicate.rs:114:1\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:112:36\n+  --> $DIR/duplicate.rs:114:36\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:114:1\n+  --> $DIR/duplicate.rs:119:1\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:114:39\n+  --> $DIR/duplicate.rs:119:39\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:116:1\n+  --> $DIR/duplicate.rs:124:1\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:116:40\n+  --> $DIR/duplicate.rs:124:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:118:1\n+  --> $DIR/duplicate.rs:129:1\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:118:40\n+  --> $DIR/duplicate.rs:129:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n-  --> $DIR/duplicate.rs:120:1\n+  --> $DIR/duplicate.rs:134:1\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:120:43\n+  --> $DIR/duplicate.rs:134:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:123:36\n+  --> $DIR/duplicate.rs:140:36\n    |\n LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:125:36\n+  --> $DIR/duplicate.rs:142:36\n    |\n LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:127:39\n+  --> $DIR/duplicate.rs:144:39\n    |\n LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:129:34\n+  --> $DIR/duplicate.rs:146:34\n    |\n LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:131:34\n+  --> $DIR/duplicate.rs:148:34\n    |\n LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:133:37\n+  --> $DIR/duplicate.rs:150:37\n    |\n LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:135:45\n+  --> $DIR/duplicate.rs:152:45\n    |\n LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:137:45\n+  --> $DIR/duplicate.rs:154:45\n    |\n LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:139:48\n+  --> $DIR/duplicate.rs:156:48\n    |\n LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:141:46\n+  --> $DIR/duplicate.rs:158:46\n    |\n LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:143:46\n+  --> $DIR/duplicate.rs:160:46\n    |\n LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:145:49\n+  --> $DIR/duplicate.rs:162:49\n    |\n LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:147:43\n+  --> $DIR/duplicate.rs:164:43\n    |\n LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:149:43\n+  --> $DIR/duplicate.rs:166:43\n    |\n LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:151:46\n+  --> $DIR/duplicate.rs:168:46\n    |\n LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:154:40\n+  --> $DIR/duplicate.rs:171:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:156:44\n+  --> $DIR/duplicate.rs:175:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n-  --> $DIR/duplicate.rs:158:43\n+  --> $DIR/duplicate.rs:179:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:109:24\n+   |\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:109:36\n+   |\n+LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n+   |                                    ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:24\n+   |\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:114:36\n+   |\n+LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n+   |                                    ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:119:24\n+   |\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                        ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:119:39\n+   |\n+LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n+   |                                       ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:124:28\n+   |\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:124:40\n+   |\n+LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:129:28\n+   |\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:129:40\n+   |\n+LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:134:28\n+   |\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:134:43\n+   |\n+LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n+   |                                           ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:171:28\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:171:40\n+   |\n+LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n+   |                                        ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:175:32\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:175:44\n+   |\n+LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n+   |                                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:179:28\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                            ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/duplicate.rs:179:43\n+   |\n+LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n+   |                                           ^^^^^^^^^^^^^\n \n error: aborting due to 93 previous errors\n "}, {"sha": "83a60825d84cdcabcaa2177f29f6001e319966b9", "filename": "src/test/ui/associated-type-bounds/inside-adt.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,36 +1,33 @@\n // compile-fail\n-// ignore-tidy-linelength\n-// error-pattern:could not find defining uses\n-\n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]\n \n struct S1 { f: dyn Iterator<Item: Copy> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n struct S3 { f: dyn Iterator<Item: 'static> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n \n enum E1 { V(dyn Iterator<Item: Copy>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n enum E3 { V(dyn Iterator<Item: 'static>) }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n \n union U1 { f: dyn Iterator<Item: Copy> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n union U2 { f: Box<dyn Iterator<Item: Copy>> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses\n union U3 { f: dyn Iterator<Item: 'static> }\n-//~^ associated type bounds are not allowed within structs, enums, or unions\n-//~| the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified [E0191]\n+//~^ ERROR associated type bounds are not allowed within structs, enums, or unions\n+//~| ERROR could not find defining uses"}, {"sha": "d0e0ceccd37253a3931eb2cb905ef7bc24e57e52", "filename": "src/test/ui/associated-type-bounds/inside-adt.stderr", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Finside-adt.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,53 +1,53 @@\n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:8:29\n+  --> $DIR/inside-adt.rs:5:29\n    |\n LL | struct S1 { f: dyn Iterator<Item: Copy> }\n    |                             ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:11:33\n+  --> $DIR/inside-adt.rs:8:33\n    |\n LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n    |                                 ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:14:29\n+  --> $DIR/inside-adt.rs:11:29\n    |\n LL | struct S3 { f: dyn Iterator<Item: 'static> }\n    |                             ^^^^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:18:26\n+  --> $DIR/inside-adt.rs:15:26\n    |\n LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n    |                          ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:21:30\n+  --> $DIR/inside-adt.rs:18:30\n    |\n LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n    |                              ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:24:26\n+  --> $DIR/inside-adt.rs:21:26\n    |\n LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n    |                          ^^^^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:28:28\n+  --> $DIR/inside-adt.rs:25:28\n    |\n LL | union U1 { f: dyn Iterator<Item: Copy> }\n    |                            ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:31:32\n+  --> $DIR/inside-adt.rs:28:32\n    |\n LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n    |                                ^^^^^^^^^^\n \n error: associated type bounds are not allowed within structs, enums, or unions\n-  --> $DIR/inside-adt.rs:34:28\n+  --> $DIR/inside-adt.rs:31:28\n    |\n LL | union U3 { f: dyn Iterator<Item: 'static> }\n    |                            ^^^^^^^^^^^^^\n@@ -57,22 +57,58 @@ error[E0601]: `main` function not found in crate `inside_adt`\n    = note: consider adding a `main` function to `$DIR/inside-adt.rs`\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:5:29\n+   |\n+LL | struct S1 { f: dyn Iterator<Item: Copy> }\n+   |                             ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:8:33\n+   |\n+LL | struct S2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                 ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:11:29\n+   |\n+LL | struct S3 { f: dyn Iterator<Item: 'static> }\n+   |                             ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:15:26\n+   |\n+LL | enum E1 { V(dyn Iterator<Item: Copy>) }\n+   |                          ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:18:30\n+   |\n+LL | enum E2 { V(Box<dyn Iterator<Item: Copy>>) }\n+   |                              ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:21:26\n+   |\n+LL | enum E3 { V(dyn Iterator<Item: 'static>) }\n+   |                          ^^^^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:25:28\n+   |\n+LL | union U1 { f: dyn Iterator<Item: Copy> }\n+   |                            ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:28:32\n+   |\n+LL | union U2 { f: Box<dyn Iterator<Item: Copy>> }\n+   |                                ^^^^^^^^^^\n \n error: could not find defining uses\n+  --> $DIR/inside-adt.rs:31:28\n+   |\n+LL | union U3 { f: dyn Iterator<Item: 'static> }\n+   |                            ^^^^^^^^^^^^^\n \n error: aborting due to 19 previous errors\n "}, {"sha": "7e05bcd309a4ff3efa52d1da6c915a0f58d67736", "filename": "src/test/ui/associated-type/associated-type-projection-from-supertrait.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -12,30 +12,22 @@ pub trait Car : Vehicle {\n     fn chip_paint(&self, c: Self::Color) { }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Black;\n struct ModelT;\n impl Vehicle for ModelT { type Color = Black; }\n impl Car for ModelT { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Blue;\n struct ModelU;\n impl Vehicle for ModelU { type Color = Blue; }\n impl Car for ModelU { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn dent<C:Car>(c: C, color: C::Color) { c.chip_paint(color) }\n fn a() { dent(ModelT, Black); }\n fn b() { dent(ModelT, Blue); } //~ ERROR mismatched types\n fn c() { dent(ModelU, Black); } //~ ERROR mismatched types\n fn d() { dent(ModelU, Blue); }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn e() { ModelT.chip_paint(Black); }\n fn f() { ModelT.chip_paint(Blue); } //~ ERROR mismatched types\n fn g() { ModelU.chip_paint(Black); } //~ ERROR mismatched types"}, {"sha": "4ba4925ef1b378c8dd91d9c648c34096c6a029e6", "filename": "src/test/ui/associated-type/associated-type-projection-from-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:33:23\n+  --> $DIR/associated-type-projection-from-supertrait.rs:27:23\n    |\n LL | fn b() { dent(ModelT, Blue); }\n    |                       ^^^^ expected struct `Black`, found struct `Blue`\n@@ -8,7 +8,7 @@ LL | fn b() { dent(ModelT, Blue); }\n               found type `Blue`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:34:23\n+  --> $DIR/associated-type-projection-from-supertrait.rs:28:23\n    |\n LL | fn c() { dent(ModelU, Black); }\n    |                       ^^^^^ expected struct `Blue`, found struct `Black`\n@@ -17,7 +17,7 @@ LL | fn c() { dent(ModelU, Black); }\n               found type `Black`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:40:28\n+  --> $DIR/associated-type-projection-from-supertrait.rs:32:28\n    |\n LL | fn f() { ModelT.chip_paint(Blue); }\n    |                            ^^^^ expected struct `Black`, found struct `Blue`\n@@ -26,7 +26,7 @@ LL | fn f() { ModelT.chip_paint(Blue); }\n               found type `Blue`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:41:28\n+  --> $DIR/associated-type-projection-from-supertrait.rs:33:28\n    |\n LL | fn g() { ModelU.chip_paint(Black); }\n    |                            ^^^^^ expected struct `Blue`, found struct `Black`"}, {"sha": "6b2bbbe2e4fb971632055ec1740587d66bd6c6ef", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -11,22 +11,16 @@ pub trait Car : Vehicle {\n     fn honk(&self) { }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Black;\n struct ModelT;\n impl Vehicle for ModelT { type Color = Black; }\n impl Car for ModelT { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Blue;\n struct ModelU;\n impl Vehicle for ModelU { type Color = Blue; }\n impl Car for ModelU { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn black_car<C:Car<Color=Black>>(c: C) {\n }\n "}, {"sha": "89c48d50cdb65334d40bc14bcb5fb0da926774e4", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,27 +1,27 @@\n error[E0271]: type mismatch resolving `<ModelT as Vehicle>::Color == Blue`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:37:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:31:10\n    |\n LL | fn b() { blue_car(ModelT); }\n    |          ^^^^^^^^ expected struct `Black`, found struct `Blue`\n    |\n    = note: expected type `Black`\n               found type `Blue`\n note: required by `blue_car`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:33:1\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:27:1\n    |\n LL | fn blue_car<C:Car<Color=Blue>>(c: C) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:38:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:32:10\n    |\n LL | fn c() { black_car(ModelU); }\n    |          ^^^^^^^^^ expected struct `Blue`, found struct `Black`\n    |\n    = note: expected type `Blue`\n               found type `Black`\n note: required by `black_car`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:30:1\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:24:1\n    |\n LL | fn black_car<C:Car<Color=Black>>(c: C) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c89f6046e6bf2cae138912276c9110d60ea44cd1", "filename": "src/test/ui/associated-types/associated-types-ref-from-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -9,8 +9,6 @@ trait Test {\n     fn test(&self, value: &Self::V) -> bool;\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct TesterPair<T:Test> {\n     tester: T,\n     value: T::V,\n@@ -26,8 +24,6 @@ impl<T:Test> TesterPair<T> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct EqU32(u32);\n impl Test for EqU32 {\n     type V = u32;"}, {"sha": "4ddcdcac822823f6a701d605e78f5d161ded3add", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -32,15 +32,14 @@ async fn return_targets_async_block_not_async_fn() -> u8 {\n \n fn no_break_in_async_block() {\n     async {\n-        break 0u8; //~ ERROR `break` inside of a closure\n-        // FIXME: This diagnostic is pretty bad.\n+        break 0u8; //~ ERROR `break` inside of an async block\n     };\n }\n \n fn no_break_in_async_block_even_with_outer_loop() {\n     loop {\n         async {\n-            break 0u8; //~ ERROR `break` inside of a closure\n+            break 0u8; //~ ERROR `break` inside of an async block\n         };\n     }\n }"}, {"sha": "a0a5ac63d84270204d1c2c54c84ae6261bb1fb02", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,14 +1,14 @@\n-error[E0267]: `break` inside of a closure\n+error[E0267]: `break` inside of an async block\n   --> $DIR/async-block-control-flow-static-semantics.rs:35:9\n    |\n LL |         break 0u8;\n-   |         ^^^^^^^^^ cannot break inside of a closure\n+   |         ^^^^^^^^^ cannot break inside of an async block\n \n-error[E0267]: `break` inside of a closure\n-  --> $DIR/async-block-control-flow-static-semantics.rs:43:13\n+error[E0267]: `break` inside of an async block\n+  --> $DIR/async-block-control-flow-static-semantics.rs:42:13\n    |\n LL |             break 0u8;\n-   |             ^^^^^^^^^ cannot break inside of a closure\n+   |             ^^^^^^^^^ cannot break inside of an async block\n \n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:15:43\n@@ -52,7 +52,7 @@ LL | async fn return_targets_async_block_not_async_fn() -> u8 {\n    = note: the return type of a function must have a statically known size\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:51:44\n+  --> $DIR/async-block-control-flow-static-semantics.rs:50:44\n    |\n LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()\n@@ -63,7 +63,7 @@ LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n               found type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:60:50\n+  --> $DIR/async-block-control-flow-static-semantics.rs:59:50\n    |\n LL | fn rethrow_targets_async_block_not_async_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found ()"}, {"sha": "d2fa5d0a3d0f189b5507dd4c6c1566f866fbba5c", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+#![feature(async_closure,async_await)]\n+fn foo() -> Box<dyn std::future::Future<Output = u32>> {\n+    let x = 0u32;\n+    Box::new((async || x)())\n+    //~^ ERROR E0373\n+}\n+\n+fn main() {\n+}"}, {"sha": "8bcfcf989208e05fbdbd5eba66d2176e1f09c824", "filename": "src/test/ui/async-await/async-borrowck-escaping-closure-error.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-borrowck-escaping-closure-error.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,21 @@\n+error[E0373]: closure may outlive the current function, but it borrows `x`, which is owned by the current function\n+  --> $DIR/async-borrowck-escaping-closure-error.rs:5:15\n+   |\n+LL |     Box::new((async || x)())\n+   |               ^^^^^^^^ - `x` is borrowed here\n+   |               |\n+   |               may outlive borrowed value `x`\n+   |\n+note: closure is returned here\n+  --> $DIR/async-borrowck-escaping-closure-error.rs:5:5\n+   |\n+LL |     Box::new((async || x)())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |     Box::new((async move || x)())\n+   |               ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "5955d9751afbbf3afe57767893c046c1eaa2a590", "filename": "src/test/ui/async-await/issues/issue-62517-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-1.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait FirstTrait {}\n+trait SecondTrait {\n+    type Item: ?Sized;\n+}\n+\n+async fn foo(x: &str) -> impl SecondTrait<Item = dyn FirstTrait> {\n+}\n+\n+\n+impl<T> SecondTrait for T {\n+    type Item = dyn FirstTrait;\n+}\n+\n+fn main() { }"}, {"sha": "17fac408151eaeb359771c8c9e8c55b957dd2517", "filename": "src/test/ui/async-await/issues/issue-62517-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62517-2.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for #62517. We used to ICE when you had an `async\n+// fn` with an `impl Trait` return that mentioned a `dyn Bar` with no\n+// explicit lifetime bound.\n+//\n+// edition:2018\n+// check-pass\n+\n+#![feature(async_await)]\n+\n+trait Object {}\n+\n+trait Alpha<Param: ?Sized> {}\n+\n+async fn foo<'a>(_: &'a ()) -> impl Alpha<dyn Object> {}\n+\n+impl<T> Alpha<dyn Object> for T { }\n+\n+fn main() { }"}, {"sha": "832095ce542062b89c2d76fd8332bfb7eae21950", "filename": "src/test/ui/const-generics/issue-61432.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn promote<const N: i32>() {\n+    // works:\n+    //\n+    // let n = N;\n+    // &n;\n+\n+    &N;\n+}\n+\n+fn main() {\n+    promote::<0>();\n+}"}, {"sha": "33f77b028104eb40ab44c3c247d56d2221db237f", "filename": "src/test/ui/const-generics/issue-61432.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61432.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/issue-61432.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "9edae1965ce1609f51706e775585d225a8fbee5c", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n #![feature(rustc_attrs, const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n use std::ptr::NonNull;"}, {"sha": "bbab85c2121a5b3fc9963fa84291cd3a92a540b7", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-linelength\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "baab14dc161412e5fa34f03f9e578f48f61f5f0e", "filename": "src/test/ui/consts/const-eval/ub-upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "7a299169bc4e19e59a5c0d63749140049a14fe9a", "filename": "src/test/ui/consts/too_generic_eval_ice.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,13 @@\n+pub struct Foo<A, B>(A, B);\n+\n+impl<A, B> Foo<A, B> {\n+    const HOST_SIZE: usize = std::mem::size_of::<B>();\n+\n+    pub fn crash() -> bool {\n+        [5; Self::HOST_SIZE] == [6; 0] //~ ERROR no associated item named `HOST_SIZE`\n+        //~^ the size for values of type `A` cannot be known\n+        //~| the size for values of type `B` cannot be known\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eef79421270ce6c917c774a9ef08648acb0201ce", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,47 @@\n+error[E0599]: no associated item named `HOST_SIZE` found for type `Foo<A, B>` in the current scope\n+  --> $DIR/too_generic_eval_ice.rs:7:19\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | --------------------------- associated item `HOST_SIZE` not found for this\n+...\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |                   ^^^^^^^^^ associated item not found in `Foo<A, B>`\n+   |\n+   = note: the method `HOST_SIZE` exists but the following trait bounds were not satisfied:\n+           `A : std::marker::Sized`\n+           `B : std::marker::Sized`\n+\n+error[E0277]: the size for values of type `A` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `A`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where A: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `B` cannot be known at compilation time\n+  --> $DIR/too_generic_eval_ice.rs:7:13\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `B`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = help: consider adding a `where B: std::marker::Sized` bound\n+note: required by `Foo`\n+  --> $DIR/too_generic_eval_ice.rs:1:1\n+   |\n+LL | pub struct Foo<A, B>(A, B);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "5d779355400ccf6c0ee8040a568776999191c96a", "filename": "src/test/ui/consts/zst_no_llvm_alloc.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fzst_no_llvm_alloc.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#[repr(align(4))]\n+struct Foo;\n+\n+static FOO: Foo = Foo;\n+\n+fn main() {\n+    let x: &'static () = &();\n+    assert_eq!(x as *const () as usize, 1);\n+    let x: &'static Foo = &Foo;\n+    assert_eq!(x as *const Foo as usize, 4);\n+\n+    // statics must have a unique address\n+    assert_ne!(&FOO as *const Foo as usize, 4);\n+\n+    assert_eq!(<Vec<i32>>::new().as_ptr(), <&[i32]>::default().as_ptr());\n+    assert_eq!(<Box<[i32]>>::default().as_ptr(), (&[]).as_ptr());\n+}"}, {"sha": "036a6095965bdd0c6689284b0db25d832d60d375", "filename": "src/test/ui/feature-gate/feature-gate-or_patterns.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,9 @@\n+#![crate_type=\"lib\"]\n+\n+pub fn example(x: Option<usize>) {\n+    match x {\n+        Some(0 | 1 | 2) => {}\n+        //~^ ERROR: or-patterns syntax is experimental\n+        _ => {}\n+    }\n+}"}, {"sha": "aaabb54c1f017914a818f45d9f2f3516b51a8fa0", "filename": "src/test/ui/feature-gate/feature-gate-or_patterns.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Ffeature-gate-or_patterns.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: or-patterns syntax is experimental\n+  --> $DIR/feature-gate-or_patterns.rs:5:14\n+   |\n+LL |         Some(0 | 1 | 2) => {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/54883\n+   = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "88d396101dba23106de9a1daf0e6e3c325e9f8f6", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-type-outlives.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -14,7 +14,6 @@ fn want_foo<T>()\n {\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as a where clause\n \n struct SomeStruct<X> {\n@@ -30,7 +29,6 @@ fn one() {\n     want_foo::<SomeStruct<usize>>();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as shorthand\n \n struct AnotherStruct<X> {"}, {"sha": "004d62ac513ffe86bfc0917c1844cc4dd69284d1", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -15,7 +15,6 @@ fn want_foo1<T>()\n {\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as a where clause\n \n struct SomeStruct;"}, {"sha": "20265d66c6f43abdc1b8f5ad3f9d58879a18fe46", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `for<'a, 'b> SomeStruct: Foo<(&'a isize, &'b isize)>` is not satisfied\n-  --> $DIR/hrtb-conflate-regions.rs:28:10\n+  --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n LL | fn b() { want_foo2::<SomeStruct>(); }\n    |          ^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a, 'b> Foo<(&'a isize, &'b isize)>` is not implemented for `SomeStruct`"}, {"sha": "ce1550568c19dd4c53a5f8273c58b7415ac7b068", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,7 +8,6 @@\n \n // See issue 60414\n \n-/////////////////////////////////////////////\n // Reduction to `impl Trait`\n \n struct Foo<T>(T);\n@@ -33,7 +32,6 @@ mod impl_trait {\n     }\n }\n \n-/////////////////////////////////////////////\n // Same with lifetimes in the trait\n \n mod lifetimes {"}, {"sha": "4811b1e0ff39ebef500c8a0e0eb14d0e8c588f77", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -7,7 +7,7 @@ LL | #![feature(impl_trait_in_bindings)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:30:32\n+  --> $DIR/bound-normalization-fail.rs:29:32\n    |\n LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type\n@@ -17,13 +17,13 @@ LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    = note: the return type of a function must have a statically known size\n \n error: `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-  --> $DIR/bound-normalization-fail.rs:47:41\n+  --> $DIR/bound-normalization-fail.rs:45:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:47:41\n+  --> $DIR/bound-normalization-fail.rs:45:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type"}, {"sha": "b0ed4be54b8999cd8487396ba6482cfffc8a2cc6", "filename": "src/test/ui/impl-trait/bound-normalization-pass.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,7 +8,6 @@\n \n // See issue 60414\n \n-/////////////////////////////////////////////\n // Reduction to `impl Trait`\n \n struct Foo<T>(T);\n@@ -32,7 +31,6 @@ mod impl_trait {\n     }\n }\n \n-/////////////////////////////////////////////\n // Same with lifetimes in the trait\n \n mod lifetimes {\n@@ -59,7 +57,6 @@ mod lifetimes {\n     }\n }\n \n-/////////////////////////////////////////////\n // Reduction using `impl Trait` in bindings\n \n mod impl_trait_in_bindings {\n@@ -80,7 +77,6 @@ mod impl_trait_in_bindings {\n     }\n }\n \n-/////////////////////////////////////////////\n // The same applied to `type Foo = impl Bar`s\n \n mod opaque_types {"}, {"sha": "3b7141573847f6fe39c554ef505553b6f824d488", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-assoc.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-assoc.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,16 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo { type Item: ?Sized; }\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn foo(x: &str, y: &str) -> impl Foo<Item = dyn Bar> { () }\n+\n+fn main() { }"}, {"sha": "e8da52aad0eac01b8a9ddfb16875dcdb3d3b77e3", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-param.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-param.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,11 @@\n+// Test that we don't get an error with `dyn Object` in an impl Trait\n+// when there are multiple inputs.  The `dyn Object` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {}\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn main() { }"}, {"sha": "aad9d89fe2433ecaaa4479c7cc2d1e6672d99dd0", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-assoc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-assoc.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,27 @@\n+// Test that we don't get an error with `dyn Bar` in an impl Trait\n+// when there are multiple inputs.  The `dyn Bar` should default to `+\n+// 'static`. This used to erroneously generate an error (cc #62517).\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "8d34c1b6c2af7a90bcddd6ba5c29384fd7193e6a", "filename": "src/test/ui/impl-trait/dyn-trait-elided-two-inputs-ref-param.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-elided-two-inputs-ref-param.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,23 @@\n+// Test that `impl Alpha<dyn Object>` resets the object-lifetime\n+// default to `'static`.\n+//\n+// check-pass\n+\n+trait Alpha<Item: ?Sized> {\n+    fn item(&self) -> Box<Item> {\n+        panic!()\n+    }\n+}\n+\n+trait Object {}\n+impl<T> Alpha<dyn Object> for T {}\n+fn alpha(x: &str, y: &str) -> impl Alpha<dyn Object> { () }\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+fn bar(x: &str) -> &impl Alpha<dyn Object> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "7c2b0d69c8b2568de550058321ddd25a69600b8b", "filename": "src/test/ui/issues/issue-12028.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -17,8 +17,6 @@ trait StreamHasher {\n     fn stream(&self) -> Self::S;\n }\n \n-//////////////////////////////////////////////////////////////////////////////\n-\n trait StreamHash<H: StreamHasher>: Hash<H> {\n     fn input_stream(&self, stream: &mut H::S);\n }"}, {"sha": "24aa88c3fa379f42c3888943a879edfd63d5943f", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error[E0284]: type annotations required: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n-  --> $DIR/issue-12028.rs:29:14\n+  --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);\n    |              ^^^^^^^^^^^^"}, {"sha": "94da2ca5cab815e2bc2251f8e7a7d8666633dc74", "filename": "src/test/ui/issues/issue-16739.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -16,8 +16,6 @@ impl FnOnce<()> for Foo {\n     extern \"rust-call\" fn call_once(mut self, _: ()) -> u32 { self.call_mut(()) }\n }\n \n-/////////////////////////////////////////////////////////////////////////\n-\n impl FnMut<(u32,)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (u32,)) -> u32 { self.foo + x }\n }\n@@ -27,8 +25,6 @@ impl FnOnce<(u32,)> for Foo {\n     extern \"rust-call\" fn call_once(mut self, args: (u32,)) -> u32 { self.call_mut(args) }\n }\n \n-/////////////////////////////////////////////////////////////////////////\n-\n impl FnMut<(u32,u32)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x, y): (u32, u32)) -> u32 { self.foo + x + y }\n }"}, {"sha": "ea0d0ccbc553270c9fc290f10065a3080571377d", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,7 +6,7 @@ trait Future {\n use std::error::Error;\n \n fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-//~^ ERROR missing lifetime\n+//~^ ERROR not satisfied\n     Ok(())\n }\n "}, {"sha": "228582d0001daafdf6bca1198a862316cc9e1da0", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,11 +1,11 @@\n-error[E0106]: missing lifetime specifier\n-  --> $DIR/lifetime-elision-return-type-trait.rs:8:44\n+error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisfied\n+  --> $DIR/lifetime-elision-return-type-trait.rs:8:13\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n-   |                                            ^^^^^^^^^ help: consider giving it a 'static lifetime: `dyn Error + 'static`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n    |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "5cf62b869123975f0a7c43568a0f5199c8475e92", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,11 +2,13 @@\n // This test checks that calling `mem::{uninitialized,zeroed}` with certain types results\n // in a lint.\n \n-#![feature(never_type)]\n+#![feature(never_type, rustc_attrs)]\n #![allow(deprecated)]\n #![deny(invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n+use std::ptr::NonNull;\n+use std::num::NonZeroU32;\n \n enum Void {}\n \n@@ -16,6 +18,11 @@ struct RefPair((&'static i32, i32));\n struct Wrap<T> { wrapped: T }\n enum WrapEnum<T> { Wrapped(T) }\n \n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(128)]\n+#[repr(transparent)]\n+pub(crate) struct NonBig(u64);\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -29,6 +36,7 @@ fn generic<T: 'static>() {\n \n fn main() {\n     unsafe {\n+        // Things that cannot even be zero.\n         let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n@@ -56,11 +64,28 @@ fn main() {\n         let _val: Wrap<(RefPair, i32)> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: Wrap<(RefPair, i32)> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n-        // Some types that should work just fine.\n+        let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Things that can be zero, but not uninit.\n+        let _val: bool = mem::zeroed();\n+        let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<char> = mem::zeroed();\n+        let _val: Wrap<char> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: NonBig = mem::zeroed();\n+        let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Transmute-from-0\n+        let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n+        let _val: NonZeroU32 = mem::transmute(0); //~ ERROR: does not permit zero-initialization\n+\n+        // Some more types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n-        let _val: bool = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n     }\n }"}, {"sha": "a36a32a39a11b3ab2675883f838ce6bca3ef0e2b", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: the type `&'static T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:22:32\n+  --> $DIR/uninitialized-zeroed.rs:29:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: References must be non-null\n \n error: the type `&'static T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:23:32\n+  --> $DIR/uninitialized-zeroed.rs:30:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Wrap<&'static T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:25:38\n+  --> $DIR/uninitialized-zeroed.rs:32:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&'static T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:26:38\n+  --> $DIR/uninitialized-zeroed.rs:33:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:32:23\n+  --> $DIR/uninitialized-zeroed.rs:40:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:33:23\n+  --> $DIR/uninitialized-zeroed.rs:41:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:35:30\n+  --> $DIR/uninitialized-zeroed.rs:43:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:36:30\n+  --> $DIR/uninitialized-zeroed.rs:44:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:38:26\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: 0-variant enums have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:39:26\n+  --> $DIR/uninitialized-zeroed.rs:47:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: 0-variant enums have no valid value\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:41:34\n+  --> $DIR/uninitialized-zeroed.rs:49:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: References must be non-null\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:42:34\n+  --> $DIR/uninitialized-zeroed.rs:50:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:44:25\n+  --> $DIR/uninitialized-zeroed.rs:52:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +153,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:45:25\n+  --> $DIR/uninitialized-zeroed.rs:53:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +168,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:47:26\n+  --> $DIR/uninitialized-zeroed.rs:55:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: Function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:48:26\n+  --> $DIR/uninitialized-zeroed.rs:56:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: Function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:50:32\n+  --> $DIR/uninitialized-zeroed.rs:58:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +205,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:51:32\n+  --> $DIR/uninitialized-zeroed.rs:59:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,13 +220,13 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:53:36\n+  --> $DIR/uninitialized-zeroed.rs:61:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -235,13 +235,13 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:54:36\n+  --> $DIR/uninitialized-zeroed.rs:62:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -250,13 +250,13 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:56:42\n+  --> $DIR/uninitialized-zeroed.rs:64:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +265,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:57:42\n+  --> $DIR/uninitialized-zeroed.rs:65:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,10 +280,102 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:67:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::zeroed();\n+   |                                  ^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:68:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::uninitialized();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `bool` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:72:26\n+   |\n+LL |         let _val: bool = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n+   |\n+   = note: Booleans must be `true` or `false`\n+\n+error: the type `Wrap<char>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:75:32\n+   |\n+LL |         let _val: Wrap<char> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Characters must be a valid unicode codepoint (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+\n+error: the type `NonBig` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:78:28\n+   |\n+LL |         let _val: NonBig = mem::uninitialized();\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+   |                            |\n+   |                            this code causes undefined behavior when executed\n+   |                            help: use `MaybeUninit<T>` instead\n+   |\n+   = note: NonBig must be initialized inside its custom valid range\n+\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:81:34\n+   |\n+LL |         let _val: &'static i32 = mem::transmute(0usize);\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `&'static [i32]` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:82:36\n+   |\n+LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `std::num::NonZeroU32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:83:32\n+   |\n+LL |         let _val: NonZeroU32 = mem::transmute(0);\n+   |                                ^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::num::NonZeroU32 must be non-null\n+\n+error: aborting due to 30 previous errors\n "}, {"sha": "250773a1853ec32a18745ead74d89516ba14e4f8", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -18,15 +18,21 @@ error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fra\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n \n error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n   --> $DIR/same-sequence-span.rs:20:1\n    |\n LL | proc_macro_sequence::make_foo!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not allowed after `expr` fragments\n+   | in this macro invocation\n    |\n    = note: allowed there are: `=>`, `,` or `;`\n "}, {"sha": "21d983f192ab6b490ffc34fdeab5165056665714", "filename": "src/test/ui/methods/method-projection.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,9 +2,6 @@\n // Test that we can use method notation to call methods based on a\n // projection bound from a trait. Issue #20469.\n \n-///////////////////////////////////////////////////////////////////////////\n-\n-\n trait MakeString {\n     fn make_string(&self) -> String;\n }\n@@ -21,8 +18,6 @@ impl MakeString for usize {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n trait Foo {\n     type F: MakeString;\n \n@@ -33,8 +28,6 @@ fn foo<F:Foo>(f: &F) -> String {\n     f.get().make_string()\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeStruct {\n     field: isize,\n }\n@@ -47,8 +40,6 @@ impl Foo for SomeStruct {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeOtherStruct {\n     field: usize,\n }"}, {"sha": "7337383e2978425a83715e9fe4a978bc38eb04e0", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,27 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9dbf7a78ed7a7406ace2e3185c9b1db8a3742d83", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic1.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic1.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic1.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a7415174f8a0ca20f3df9378520953e77da2216", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,30 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: 'a + ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo<'_> for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'a`.  Or, we *should*, but the\n+// current code forces us into a conservative, hacky path.\n+fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+\n+    // If it weren't for the conservative path above, we'd expect an\n+    // error here.\n+    is_static(r.item());\n+}"}, {"sha": "d069f52ce47db4ef1cb13fff4d4ca2bf33b910de", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic2.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic2.rs:20:50\n+   |\n+LL | fn bar<'a>(x: &'a str) -> &'a dyn Foo<'a, Item = dyn Bar> { &() }\n+   |                                                  ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "51be999a6329d09f85cda3e7a804827eba0765cc", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,23 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+\n+trait Foo<'a> {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we should default to `dyn Bar + 'static`, but the current\n+// code forces us into a conservative, hacky path.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+//~^ ERROR please supply an explicit bound\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "9c7b6b98f2e3620375fca614ca63f47114dc634b", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-nonstatic3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-nonstatic3.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,8 @@\n+error[E0228]: the lifetime bound for this object type cannot be deduced from context; please supply an explicit bound\n+  --> $DIR/object-lifetime-default-dyn-binding-nonstatic3.rs:16:36\n+   |\n+LL | fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+   |                                    ^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "339f3356bd71ea66f2a1dc1df6130ac63f8cbf30", "filename": "src/test/ui/object-lifetime/object-lifetime-default-dyn-binding-static.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-dyn-binding-static.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,28 @@\n+// Test that `dyn Bar<Item = XX>` uses `'static` as the default object\n+// lifetime bound for the type `XX`.\n+//\n+// check-pass\n+\n+trait Foo {\n+    type Item: ?Sized;\n+\n+    fn item(&self) -> Box<Self::Item> { panic!() }\n+}\n+\n+trait Bar { }\n+\n+impl<T> Foo for T {\n+    type Item = dyn Bar;\n+}\n+\n+fn is_static<T>(_: T) where T: 'static { }\n+\n+// Here, we default to `dyn Bar + 'static`, and not `&'x dyn Foo<Item\n+// = dyn Bar + 'x>`.\n+fn bar(x: &str) -> &dyn Foo<Item = dyn Bar> { &() }\n+\n+fn main() {\n+    let s = format!(\"foo\");\n+    let r = bar(&s);\n+    is_static(r.item());\n+}"}, {"sha": "f27caa5d78c8eaf42be834c1f8963dbadea97f53", "filename": "src/test/ui/parser/pat-lt-bracket-6.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,8 +2,9 @@ fn main() {\n     struct Test(&'static u8, [u8; 0]);\n     let x = Test(&0, []);\n \n-    let Test(&desc[..]) = x; //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n-    //~^ ERROR subslice patterns are unstable\n+    let Test(&desc[..]) = x;\n+    //~^ ERROR: expected one of `)`, `,`, `@`, or `|`, found `[`\n+    //~^^ ERROR subslice patterns are unstable\n }\n \n const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "6f08f0a9d95ef117bf83899a3b28a08e725f7ada", "filename": "src/test/ui/parser/pat-lt-bracket-6.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-6.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `)`, `,`, or `@`, found `[`\n+error: expected one of `)`, `,`, `@`, or `|`, found `[`\n   --> $DIR/pat-lt-bracket-6.rs:5:19\n    |\n LL |     let Test(&desc[..]) = x;\n-   |                   ^ expected one of `)`, `,`, or `@` here\n+   |                   ^ expected one of `)`, `,`, `@`, or `|` here\n \n error[E0658]: subslice patterns are unstable\n   --> $DIR/pat-lt-bracket-6.rs:5:20\n@@ -14,7 +14,7 @@ LL |     let Test(&desc[..]) = x;\n    = help: add `#![feature(slice_patterns)]` to the crate attributes to enable\n \n error[E0308]: mismatched types\n-  --> $DIR/pat-lt-bracket-6.rs:9:30\n+  --> $DIR/pat-lt-bracket-6.rs:10:30\n    |\n LL | const RECOVERY_WITNESS: () = 0;\n    |                              ^ expected (), found integer"}, {"sha": "327aef5ad15703cd16770ccdcd00dd8803c5e0ea", "filename": "src/test/ui/parser/pat-lt-bracket-7.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,8 @@ fn main() {\n     struct Thing(u8, [u8; 0]);\n     let foo = core::iter::empty();\n \n-    for Thing(x[]) in foo {} //~ ERROR: expected one of `)`, `,`, or `@`, found `[`\n+    for Thing(x[]) in foo {}\n+    //~^ ERROR: expected one of `)`, `,`, `@`, or `|`, found `[`\n }\n \n const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types"}, {"sha": "196f1c0ae914f51b5f1a963e9bbd723277c8333c", "filename": "src/test/ui/parser/pat-lt-bracket-7.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-lt-bracket-7.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,11 +1,11 @@\n-error: expected one of `)`, `,`, or `@`, found `[`\n+error: expected one of `)`, `,`, `@`, or `|`, found `[`\n   --> $DIR/pat-lt-bracket-7.rs:5:16\n    |\n LL |     for Thing(x[]) in foo {}\n-   |                ^ expected one of `)`, `,`, or `@` here\n+   |                ^ expected one of `)`, `,`, `@`, or `|` here\n \n error[E0308]: mismatched types\n-  --> $DIR/pat-lt-bracket-7.rs:8:30\n+  --> $DIR/pat-lt-bracket-7.rs:9:30\n    |\n LL | const RECOVERY_WITNESS: () = 0;\n    |                              ^ expected (), found integer"}, {"sha": "c6be2c90667c2626242fb4ea62b3dabd365023f5", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     let vec = vec![1, 2, 3];\n \n     for ( elem in vec ) {\n-        //~^ ERROR expected one of `)`, `,`, or `@`, found `in`\n+        //~^ ERROR expected one of `)`, `,`, `@`, or `|`, found `in`\n         //~| ERROR unexpected closing `)`\n         const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types\n     }"}, {"sha": "1b5b6cca09243a63f1746cf1d836933148611bd5", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `)`, `,`, or `@`, found `in`\n+error: expected one of `)`, `,`, `@`, or `|`, found `in`\n   --> $DIR/recover-for-loop-parens-around-head.rs:10:16\n    |\n LL |     for ( elem in vec ) {\n-   |                ^^ expected one of `)`, `,`, or `@` here\n+   |                ^^ expected one of `)`, `,`, `@`, or `|` here\n \n error: unexpected closing `)`\n   --> $DIR/recover-for-loop-parens-around-head.rs:10:23"}, {"sha": "d4b67d6b0b07c419a2a72ef63aec4ef7a348473e", "filename": "src/test/ui/proc-macro/auxiliary/gen-macro-rules.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(repro)]\n+pub fn proc_macro_hack_expr(_input: TokenStream) -> TokenStream {\n+    \"macro_rules! m {()=>{}}\".parse().unwrap()\n+}"}, {"sha": "13ad27f9372521acd2dfe32f864efd04526ec21e", "filename": "src/test/ui/proc-macro/gen-macro-rules.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -0,0 +1,13 @@\n+// Derive macros can generate `macro_rules` items, regression test for issue #63651.\n+\n+// check-pass\n+// aux-build:gen-macro-rules.rs\n+\n+extern crate gen_macro_rules as repro;\n+\n+#[derive(repro::repro)]\n+pub struct S;\n+\n+m!(); // OK\n+\n+fn main() {}"}, {"sha": "829d8bf4c81dae86f65e7061d5919ca1252c552c", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,13 +2,19 @@ error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `Outer` in this scope\n   --> $DIR/generate-mod.rs:9:1\n    |\n LL | generate_mod::check!();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | not found in this scope\n+   | in this macro invocation\n \n error[E0412]: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:12:1"}, {"sha": "65e40172ef539b24a03e36abaffff8ce6b25d736", "filename": "src/test/ui/proc-macro/invalid-punct-ident-4.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-4.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,10 @@ error: unexpected close delimiter: `)`\n   --> $DIR/invalid-punct-ident-4.rs:6:1\n    |\n LL | lexer_failure!();\n-   | ^^^^^^^^^^^^^^^^^ unexpected close delimiter\n+   | ^^^^^^^^^^^^^^^^^\n+   | |\n+   | unexpected close delimiter\n+   | in this macro invocation\n \n error: proc macro panicked\n   --> $DIR/invalid-punct-ident-4.rs:6:1"}, {"sha": "f28b8c9fb73e9650b650668779a9581dfd9b685b", "filename": "src/test/ui/proc-macro/lints_in_proc_macros.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Flints_in_proc_macros.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,10 @@ error[E0425]: cannot find value `foobar2` in this scope\n   --> $DIR/lints_in_proc_macros.rs:12:5\n    |\n LL |     bang_proc_macro2!();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `foobar`\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: a local variable with a similar name exists: `foobar`\n+   |     in this macro invocation\n \n error: aborting due to previous error\n "}, {"sha": "a0c1f9cd5c05f9dcd2d387e0cddf347f5d1c1990", "filename": "src/test/ui/proc-macro/multispan.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmultispan.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:14:5\n    |\n LL |     hello!(hi);\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:14:12\n@@ -14,7 +14,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:17:5\n    |\n LL |     hello!(hi hi);\n-   |     ^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:17:12\n@@ -26,7 +26,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:20:5\n    |\n LL |     hello!(hi hi hi);\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:20:12\n@@ -38,7 +38,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:23:5\n    |\n LL |     hello!(hi hey hi yo hi beep beep hi hi);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:23:12\n@@ -50,7 +50,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:24:5\n    |\n LL |     hello!(hi there, hi how are you? hi... hi.);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:24:12\n@@ -62,7 +62,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:25:5\n    |\n LL |     hello!(whoah. hi di hi di ho);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:25:19\n@@ -74,7 +74,7 @@ error: hello to you, too!\n   --> $DIR/multispan.rs:26:5\n    |\n LL |     hello!(hi good hi and good bye);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: found these 'hi's\n   --> $DIR/multispan.rs:26:12"}, {"sha": "06715c197bc5975c2a7894c88398281a79c0480c", "filename": "src/test/ui/proc-macro/subspan.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fsubspan.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:11:1\n    |\n LL | subspan!(\"hi\");\n-   | ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:11:11\n@@ -14,7 +14,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:14:1\n    |\n LL | subspan!(\"hihi\");\n-   | ^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:14:11\n@@ -26,7 +26,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:17:1\n    |\n LL | subspan!(\"hihihi\");\n-   | ^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:17:11\n@@ -38,7 +38,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:20:1\n    |\n LL | subspan!(\"why I hide? hi!\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:20:17\n@@ -50,7 +50,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:21:1\n    |\n LL | subspan!(\"hey, hi, hidy, hidy, hi hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:21:16\n@@ -62,7 +62,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:22:1\n    |\n LL | subspan!(\"this is a hi, and this is another hi\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:22:12\n@@ -74,7 +74,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:23:1\n    |\n LL | subspan!(\"how are you this evening\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:23:24\n@@ -86,7 +86,7 @@ error: found 'hi's\n   --> $DIR/subspan.rs:24:1\n    |\n LL | subspan!(\"this is highly eradic\");\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n note: here\n   --> $DIR/subspan.rs:24:12"}, {"sha": "0a6cbe13098a8c20f849b09962dcc5c4b5b8b05b", "filename": "src/test/ui/proc-macro/three-equals.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fthree-equals.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,7 @@ error: found 2 equal signs, need exactly 3\n   --> $DIR/three-equals.rs:15:5\n    |\n LL |     three_equals!(==);\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^ in this macro invocation\n    |\n    = help: input must be: `===`\n "}, {"sha": "eed9934be121dc0bdf5f564f0c51470348403208", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   -- -- lifetime `'b` defined here"}, {"sha": "ed5800940ee3192597abbceea1d05fdba9d45078", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,33 +1,33 @@\n error[E0491]: in type `&'a WithHrAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 32:15\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 32:18\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^\n \n error[E0491]: in type `&'a WithHrAssocSub<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 53:19\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:19\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 46:19\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:19\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 53:22\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:22\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 46:22\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:22\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                      ^^"}, {"sha": "eed9934be121dc0bdf5f564f0c51470348403208", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   -- -- lifetime `'b` defined here"}, {"sha": "cee741184ca2ab68a0ddb8b35bf7864274b13533", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -6,9 +6,6 @@\n \n #![allow(dead_code)]\n \n-\n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait<'b> {\n     type TheAssocType;\n }\n@@ -21,8 +18,6 @@ impl<'a,'b> TheTrait<'a> for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithHrAssoc<T>\n     where for<'a> T : TheTrait<'a>\n {\n@@ -37,8 +32,6 @@ fn with_assoc<'a,'b>() {\n     //[nll]~^^ ERROR lifetime may not live long enough\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheSubTrait : for<'a> TheTrait<'a> {\n }\n "}, {"sha": "8c54d8da0a06395ec758611beed2908be37d665f", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "152e6c5600c4e63e7ab775abe989d05cd30613f0", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,16 +1,16 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 31:15\n-  --> $DIR/regions-outlives-projection-container-wc.rs:31:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+  --> $DIR/regions-outlives-projection-container-wc.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 31:18\n-  --> $DIR/regions-outlives-projection-container-wc.rs:31:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+  --> $DIR/regions-outlives-projection-container-wc.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^"}, {"sha": "8c54d8da0a06395ec758611beed2908be37d665f", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "99965f333907bff77772640989900ecc090fc93d", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -8,8 +8,6 @@\n \n #![allow(dead_code)]\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait {\n     type TheAssocType;\n }\n@@ -22,8 +20,6 @@ impl<'b> TheTrait for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithAssoc<T> where T : TheTrait {\n     m: [T; 0]\n }"}, {"sha": "2cf6e245d19f65a506f84261a087dbefeddb3352", "filename": "src/test/ui/regions/regions-outlives-projection-container.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:40:13\n+  --> $DIR/regions-outlives-projection-container.rs:36:13\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:58:13\n+  --> $DIR/regions-outlives-projection-container.rs:54:13\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                  -- -- lifetime `'b` defined here\n@@ -21,7 +21,7 @@ LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:67:5\n+  --> $DIR/regions-outlives-projection-container.rs:63:5\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                    -- -- lifetime `'b` defined here\n@@ -32,7 +32,7 @@ LL |     call::<&'a WithAssoc<TheType<'b>>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:74:5\n+  --> $DIR/regions-outlives-projection-container.rs:70:5\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                       -- -- lifetime `'b` defined here"}, {"sha": "3afc600becb6e4c7309b65b5d2e7ef251b24c1cf", "filename": "src/test/ui/regions/regions-outlives-projection-container.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -5,8 +5,6 @@\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait {\n     type TheAssocType;\n }\n@@ -19,8 +17,6 @@ impl<'b> TheTrait for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithAssoc<T:TheTrait> {\n     m: [T; 0]\n }"}, {"sha": "3c1a98a3c018fa589a358ef0dd2ee58d46bbdbb6", "filename": "src/test/ui/regions/regions-outlives-projection-container.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,67 +1,67 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:40:13\n+  --> $DIR/regions-outlives-projection-container.rs:36:13\n    |\n LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 32:15\n-  --> $DIR/regions-outlives-projection-container.rs:32:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 28:15\n+  --> $DIR/regions-outlives-projection-container.rs:28:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 32:18\n-  --> $DIR/regions-outlives-projection-container.rs:32:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 28:18\n+  --> $DIR/regions-outlives-projection-container.rs:28:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^\n \n error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:58:13\n+  --> $DIR/regions-outlives-projection-container.rs:54:13\n    |\n LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 54:18\n-  --> $DIR/regions-outlives-projection-container.rs:54:18\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 50:18\n+  --> $DIR/regions-outlives-projection-container.rs:50:18\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                  ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 54:21\n-  --> $DIR/regions-outlives-projection-container.rs:54:21\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 50:21\n+  --> $DIR/regions-outlives-projection-container.rs:50:21\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                     ^^\n \n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:67:12\n+  --> $DIR/regions-outlives-projection-container.rs:63:12\n    |\n LL |     call::<&'a WithAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 62:20\n-  --> $DIR/regions-outlives-projection-container.rs:62:20\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 58:20\n+  --> $DIR/regions-outlives-projection-container.rs:58:20\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                    ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 62:23\n-  --> $DIR/regions-outlives-projection-container.rs:62:23\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 58:23\n+  --> $DIR/regions-outlives-projection-container.rs:58:23\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                       ^^\n \n error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:74:12\n+  --> $DIR/regions-outlives-projection-container.rs:70:12\n    |\n LL |     call::<&'a WithoutAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 71:23\n-  --> $DIR/regions-outlives-projection-container.rs:71:23\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 67:23\n+  --> $DIR/regions-outlives-projection-container.rs:67:23\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                       ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 71:26\n-  --> $DIR/regions-outlives-projection-container.rs:71:26\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 67:26\n+  --> $DIR/regions-outlives-projection-container.rs:67:26\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                          ^^"}, {"sha": "37005f839d4889225f682689417af88a55fc234d", "filename": "src/test/ui/specialization/defaultimpl/specialization-no-default.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,9 +3,7 @@\n // Check a number of scenarios in which one impl tries to override another,\n // without correctly using `default`.\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 1: one layer of specialization, multiple methods, missing `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Foo {\n     fn foo(&self);\n@@ -25,9 +23,7 @@ impl Foo for u32 {\n     fn bar(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 2: one layer of specialization, missing `default` on associated type\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Bar {\n     type T;\n@@ -41,9 +37,7 @@ impl Bar for u8 {\n     type T = (); //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3a: multiple layers of specialization, missing interior `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Baz {\n     fn baz(&self);\n@@ -61,10 +55,8 @@ impl Baz for i32 {\n     fn baz(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3b: multiple layers of specialization, missing interior `default`,\n // redundant `default` in bottom layer.\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Redundant {\n     fn redundant(&self);"}, {"sha": "13636b28b126c675f5e54eb7ea75b733a3e0310d", "filename": "src/test/ui/specialization/defaultimpl/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error[E0520]: `foo` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:22:5\n+  --> $DIR/specialization-no-default.rs:20:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -13,7 +13,7 @@ LL |       fn foo(&self) {}\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n error[E0520]: `bar` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:25:5\n+  --> $DIR/specialization-no-default.rs:23:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -27,7 +27,7 @@ LL |       fn bar(&self) {}\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n error[E0520]: `T` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:41:5\n+  --> $DIR/specialization-no-default.rs:37:5\n    |\n LL | / impl<T> Bar for T {\n LL | |     type T = u8;\n@@ -40,7 +40,7 @@ LL |       type T = ();\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n error[E0520]: `baz` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:61:5\n+  --> $DIR/specialization-no-default.rs:55:5\n    |\n LL | / impl<T: Clone> Baz for T {\n LL | |     fn baz(&self) {}\n@@ -53,7 +53,7 @@ LL |       fn baz(&self) {}\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n error[E0520]: `redundant` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:82:5\n+  --> $DIR/specialization-no-default.rs:74:5\n    |\n LL | / impl<T: Clone> Redundant for T {\n LL | |     fn redundant(&self) {}"}, {"sha": "57346b26d24ec2d8e85544aee516d8261e75dd1d", "filename": "src/test/ui/specialization/specialization-no-default.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,9 +3,7 @@\n // Check a number of scenarios in which one impl tries to override another,\n // without correctly using `default`.\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 1: one layer of specialization, multiple methods, missing `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Foo {\n     fn foo(&self);\n@@ -25,9 +23,7 @@ impl Foo for u32 {\n     fn bar(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 2: one layer of specialization, missing `default` on associated type\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Bar {\n     type T;\n@@ -41,9 +37,7 @@ impl Bar for u8 {\n     type T = (); //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3a: multiple layers of specialization, missing interior `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Baz {\n     fn baz(&self);\n@@ -61,10 +55,8 @@ impl Baz for i32 {\n     fn baz(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3b: multiple layers of specialization, missing interior `default`,\n // redundant `default` in bottom layer.\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Redundant {\n     fn redundant(&self);"}, {"sha": "992e9abbd4ce2e4db90a339393e1dc94e95bf2b9", "filename": "src/test/ui/specialization/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,5 +1,5 @@\n error[E0520]: `foo` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:22:5\n+  --> $DIR/specialization-no-default.rs:20:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -13,7 +13,7 @@ LL |       fn foo(&self) {}\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n error[E0520]: `bar` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:25:5\n+  --> $DIR/specialization-no-default.rs:23:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -27,7 +27,7 @@ LL |       fn bar(&self) {}\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n error[E0520]: `T` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:41:5\n+  --> $DIR/specialization-no-default.rs:37:5\n    |\n LL | / impl<T> Bar for T {\n LL | |     type T = u8;\n@@ -40,7 +40,7 @@ LL |       type T = ();\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n error[E0520]: `baz` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:61:5\n+  --> $DIR/specialization-no-default.rs:55:5\n    |\n LL | / impl<T: Clone> Baz for T {\n LL | |     fn baz(&self) {}\n@@ -53,7 +53,7 @@ LL |       fn baz(&self) {}\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n error[E0520]: `redundant` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:82:5\n+  --> $DIR/specialization-no-default.rs:74:5\n    |\n LL | / impl<T: Clone> Redundant for T {\n LL | |     fn redundant(&self) {}"}, {"sha": "c938ce8dad98d69a9beef006d41fb432d1b04d49", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -3,13 +3,13 @@ struct S;\n trait Tr {\n     fn f() {\n         let s = Self {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n-        //~^ ERROR expected struct, variant or union type, found Self\n+        //~^ ERROR expected struct, variant or union type, found type parameter\n         //~| ERROR type arguments are not allowed for this type\n         match s {\n             Self { .. } => {}\n-            //~^ ERROR expected struct, variant or union type, found Self\n+            //~^ ERROR expected struct, variant or union type, found type parameter\n         }\n     }\n }"}, {"sha": "8c88cacc69e315f8607e7e91de664c50908bbef7", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -1,4 +1,4 @@\n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:5:17\n    |\n LL |         let s = Self {};\n@@ -10,13 +10,13 @@ error[E0109]: type arguments are not allowed for this type\n LL |         let z = Self::<u8> {};\n    |                        ^^ type argument not allowed\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:7:17\n    |\n LL |         let z = Self::<u8> {};\n    |                 ^^^^^^^^^^ not a struct\n \n-error[E0071]: expected struct, variant or union type, found Self\n+error[E0071]: expected struct, variant or union type, found type parameter\n   --> $DIR/struct-path-self.rs:11:13\n    |\n LL |             Self { .. } => {}"}, {"sha": "afdfb96394bd0d8e1c4bc13d1c137ee46ec2760a", "filename": "src/test/ui/traits/traits-conditional-model-fn.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -14,8 +14,6 @@ use go_trait::{Go, GoMut, GoOnce, go, go_mut, go_once};\n use std::rc::Rc;\n use std::cell::Cell;\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeGoableThing {\n     counter: Rc<Cell<isize>>\n }\n@@ -26,8 +24,6 @@ impl Go for SomeGoableThing {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeGoOnceableThing {\n     counter: Rc<Cell<isize>>\n }\n@@ -38,8 +34,6 @@ impl GoOnce for SomeGoOnceableThing {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn main() {\n     let counter = Rc::new(Cell::new(0));\n     let mut x = SomeGoableThing { counter: counter.clone() };"}, {"sha": "71fb7f380aeac6e72a36a6f6c8371bfc82f50ecb", "filename": "src/test/ui/type/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.rs?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -5,7 +5,7 @@ trait BrokenAdd: Copy + Add<Output=Self> {\n         *self + rhs //~  ERROR mismatched types\n                     //~| expected type `Self`\n                     //~| found type `T`\n-                    //~| expected Self, found type parameter\n+                    //~| expected type parameter, found a different type parameter\n     }\n }\n "}, {"sha": "0448a28ea8e2721b7722fa7ab09c2dd484f89bd9", "filename": "src/test/ui/type/type-params-in-different-spaces-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-1.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/type-params-in-different-spaces-1.rs:5:17\n    |\n LL |         *self + rhs\n-   |                 ^^^ expected Self, found type parameter\n+   |                 ^^^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `T`"}, {"sha": "e25f79947c73233c0128a9f253b06fe9c42219f2", "filename": "src/test/ui/type/type-params-in-different-spaces-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e500fc3171a899f713a269ccee6f480b9db4859b/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-3.stderr?ref=e500fc3171a899f713a269ccee6f480b9db4859b", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     fn test<X>(u: X) -> Self {\n    |                         ---- expected `Self` because of return type\n LL |         u\n-   |         ^ expected Self, found type parameter\n+   |         ^ expected type parameter, found a different type parameter\n    |\n    = note: expected type `Self`\n               found type `X`"}]}