{"sha": "0f1dec05dde67d6def6645ba82e8e7de68776766", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMWRlYzA1ZGRlNjdkNmRlZjY2NDViYTgyZThlN2RlNjg3NzY3NjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T08:41:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T08:41:03Z"}, "message": "Auto merge of #1129 - christianpoveda:stat64-shim, r=RalfJung\n\nadd stat shim for macos\n\nHere we go. I'm apologizing in advice for the constant torture that Travis will suffer.", "tree": {"sha": "30b803018d23e700a11d62734ad4d31be5bedd40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30b803018d23e700a11d62734ad4d31be5bedd40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f1dec05dde67d6def6645ba82e8e7de68776766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f1dec05dde67d6def6645ba82e8e7de68776766", "html_url": "https://github.com/rust-lang/rust/commit/0f1dec05dde67d6def6645ba82e8e7de68776766", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f1dec05dde67d6def6645ba82e8e7de68776766/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aafb7c931d54358b5cdc8175a42b2f760b3a0f4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aafb7c931d54358b5cdc8175a42b2f760b3a0f4d", "html_url": "https://github.com/rust-lang/rust/commit/aafb7c931d54358b5cdc8175a42b2f760b3a0f4d"}, {"sha": "c8190e8de79b22843c4d0976def95aee120f0329", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8190e8de79b22843c4d0976def95aee120f0329", "html_url": "https://github.com/rust-lang/rust/commit/c8190e8de79b22843c4d0976def95aee120f0329"}], "stats": {"total": 238, "additions": 171, "deletions": 67}, "files": [{"sha": "1e655ca821d811d6394305cbc62df830fdbfa81c", "filename": "src/shims/env.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=0f1dec05dde67d6def6645ba82e8e7de68776766", "patch": "@@ -20,8 +20,7 @@ impl EnvVars {\n         ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'tcx>>,\n         mut excluded_env_vars: Vec<String>,\n     ) {\n-\n-        // FIXME: this can be removed when we have the `stat64` shim for macos.\n+        // FIXME: this can be removed when we fix the behavior of the `close` shim for macos.\n         if ecx.tcx.sess.target.target.target_os.to_lowercase() != \"linux\" {\n             // Exclude `TERM` var to avoid terminfo trying to open the termcap file.\n             excluded_env_vars.push(\"TERM\".to_owned());"}, {"sha": "51c43b28b68aaa324c6223f6b140c43b44b78acb", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=0f1dec05dde67d6def6645ba82e8e7de68776766", "patch": "@@ -494,6 +494,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            \"stat$INODE64\" => {\n+                let result = this.stat(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             \"clock_gettime\" => {\n                 let result = this.clock_gettime(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;"}, {"sha": "63aa750bdd54897eb3793f95a791ae6bcde78bdf", "filename": "src/shims/fs.rs", "status": "modified", "additions": 164, "deletions": 55, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1dec05dde67d6def6645ba82e8e7de68776766/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=0f1dec05dde67d6def6645ba82e8e7de68776766", "patch": "@@ -261,6 +261,84 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n+    fn stat(\n+        &mut self,\n+        path_op: OpTy<'tcx, Tag>,\n+        buf_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if this.tcx.sess.target.target.target_os.to_lowercase() != \"macos\" {\n+            throw_unsup_format!(\"The `stat` shim is only available for `macos` targets.\")\n+        }\n+\n+        let path_scalar = this.read_scalar(path_op)?.not_undef()?;\n+        let path: PathBuf = this.read_os_str_from_c_str(path_scalar)?.into();\n+\n+        let buf = this.deref_operand(buf_op)?;\n+\n+        // `stat` always follows symlinks. `lstat` is used to get symlink metadata.\n+        let metadata = match FileMetadata::new(this, path, true)? {\n+            Some(metadata) => metadata,\n+            None => return Ok(-1),\n+        };\n+\n+        // FIXME: use Scalar::to_u16\n+        let mode: u16 = metadata.mode.to_bits(Size::from_bits(16))? as u16;\n+\n+        let (access_sec, access_nsec) = metadata.accessed.unwrap_or((0, 0));\n+        let (created_sec, created_nsec) = metadata.created.unwrap_or((0, 0));\n+        let (modified_sec, modified_nsec) = metadata.modified.unwrap_or((0, 0));\n+\n+        let dev_t_layout = this.libc_ty_layout(\"dev_t\")?;\n+        let mode_t_layout = this.libc_ty_layout(\"mode_t\")?;\n+        let nlink_t_layout = this.libc_ty_layout(\"nlink_t\")?;\n+        let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n+        let uid_t_layout = this.libc_ty_layout(\"uid_t\")?;\n+        let gid_t_layout = this.libc_ty_layout(\"gid_t\")?;\n+        let time_t_layout = this.libc_ty_layout(\"time_t\")?;\n+        let long_layout = this.libc_ty_layout(\"c_long\")?;\n+        let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n+        let blkcnt_t_layout = this.libc_ty_layout(\"blkcnt_t\")?;\n+        let blksize_t_layout = this.libc_ty_layout(\"blksize_t\")?;\n+        let uint32_t_layout = this.libc_ty_layout(\"uint32_t\")?;\n+\n+        // We need to add 32 bits of padding after `st_rdev` if we are on a 64-bit platform.\n+        let pad_layout = if this.tcx.sess.target.ptr_width == 64 {\n+            uint32_t_layout\n+        } else {\n+            this.layout_of(this.tcx.mk_unit())?\n+        };\n+\n+        let imms = [\n+            immty_from_uint_checked(0u128, dev_t_layout)?, // st_dev\n+            immty_from_uint_checked(mode, mode_t_layout)?, // st_mode\n+            immty_from_uint_checked(0u128, nlink_t_layout)?, // st_nlink\n+            immty_from_uint_checked(0u128, ino_t_layout)?, // st_ino\n+            immty_from_uint_checked(0u128, uid_t_layout)?, // st_uid\n+            immty_from_uint_checked(0u128, gid_t_layout)?, // st_gid\n+            immty_from_uint_checked(0u128, dev_t_layout)?, // st_rdev\n+            immty_from_uint_checked(0u128, pad_layout)?, // padding for 64-bit targets\n+            immty_from_uint_checked(access_sec, time_t_layout)?, // st_atime\n+            immty_from_uint_checked(access_nsec, long_layout)?, // st_atime_nsec\n+            immty_from_uint_checked(modified_sec, time_t_layout)?, // st_mtime\n+            immty_from_uint_checked(modified_nsec, long_layout)?, // st_mtime_nsec\n+            immty_from_uint_checked(0u128, time_t_layout)?, // st_ctime\n+            immty_from_uint_checked(0u128, long_layout)?, // st_ctime_nsec\n+            immty_from_uint_checked(created_sec, time_t_layout)?, // st_birthtime\n+            immty_from_uint_checked(created_nsec, long_layout)?, // st_birthtime_nsec\n+            immty_from_uint_checked(metadata.size, off_t_layout)?, // st_size\n+            immty_from_uint_checked(0u128, blkcnt_t_layout)?, // st_blocks\n+            immty_from_uint_checked(0u128, blksize_t_layout)?, // st_blksize\n+            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_flags\n+            immty_from_uint_checked(0u128, uint32_t_layout)?, // st_gen\n+        ];\n+\n+        this.write_packed_immediates(&buf, &imms)?;\n+\n+        Ok(0)\n+    }\n+\n     fn statx(\n         &mut self,\n         dirfd_op: OpTy<'tcx, Tag>,    // Should be an `int`\n@@ -273,6 +351,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"statx\")?;\n \n+        if this.tcx.sess.target.target.target_os.to_lowercase() != \"linux\" {\n+            throw_unsup_format!(\"The `statx` shim is only available for `linux` targets.\")\n+        }\n+\n         let statxbuf_scalar = this.read_scalar(statxbuf_op)?.not_undef()?;\n         let pathname_scalar = this.read_scalar(pathname_op)?.not_undef()?;\n \n@@ -330,68 +412,46 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n         // symbolic links.\n-        let metadata = if flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? != 0 {\n-            // FIXME: metadata for symlinks need testing.\n-            std::fs::symlink_metadata(path)\n-        } else {\n-            std::fs::metadata(path)\n-        };\n-\n-        let metadata = match metadata {\n-            Ok(metadata) => metadata,\n-            Err(e) => {\n-                this.set_last_error_from_io_error(e)?;\n-                return Ok(-1);\n-            }\n-        };\n+        let follow_symlink = flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? == 0;\n \n-        let file_type = metadata.file_type();\n-\n-        let mode_name = if file_type.is_file() {\n-            \"S_IFREG\"\n-        } else if file_type.is_dir() {\n-            \"S_IFDIR\"\n-        } else {\n-            \"S_IFLNK\"\n+        let metadata = match FileMetadata::new(this, path, follow_symlink)? {\n+            Some(metadata) => metadata,\n+            None => return Ok(-1),\n         };\n \n         // The `mode` field specifies the type of the file and the permissions over the file for\n         // the owner, its group and other users. Given that we can only provide the file type\n         // without using platform specific methods, we only set the bits corresponding to the file\n         // type. This should be an `__u16` but `libc` provides its values as `u32`.\n-        let mode: u16 = this\n-            .eval_libc(mode_name)?\n+        let mode: u16 = metadata\n+            .mode\n             .to_u32()?\n             .try_into()\n-            .unwrap_or_else(|_| bug!(\"libc contains bad value for `{}` constant\", mode_name));\n-\n-        let size = metadata.len();\n+            .unwrap_or_else(|_| bug!(\"libc contains bad value for constant\"));\n \n-        let (access_sec, access_nsec) = extract_sec_and_nsec(\n-            metadata.accessed(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_ATIME\")?.to_u32()?,\n-        )?;\n+        // We need to set the corresponding bits of `mask` if the access, creation and modification\n+        // times were available. Otherwise we let them be zero.\n+        let (access_sec, access_nsec) = metadata.accessed.map(|tup| {\n+            mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n+            InterpResult::Ok(tup)\n+        }).unwrap_or(Ok((0, 0)))?;\n \n-        let (created_sec, created_nsec) = extract_sec_and_nsec(\n-            metadata.created(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_BTIME\")?.to_u32()?,\n-        )?;\n+        let (created_sec, created_nsec) = metadata.created.map(|tup| {\n+            mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n+            InterpResult::Ok(tup)\n+        }).unwrap_or(Ok((0, 0)))?;\n \n-        let (modified_sec, modified_nsec) = extract_sec_and_nsec(\n-            metadata.modified(),\n-            &mut mask,\n-            this.eval_libc(\"STATX_MTIME\")?.to_u32()?,\n-        )?;\n+        let (modified_sec, modified_nsec) = metadata.modified.map(|tup| {\n+            mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n+            InterpResult::Ok(tup)\n+        }).unwrap_or(Ok((0, 0)))?;\n \n         let __u32_layout = this.libc_ty_layout(\"__u32\")?;\n         let __u64_layout = this.libc_ty_layout(\"__u64\")?;\n         let __u16_layout = this.libc_ty_layout(\"__u16\")?;\n \n         // Now we transform all this fields into `ImmTy`s and write them to `statxbuf`. We write a\n         // zero for the unavailable fields.\n-        // FIXME: Provide more fields using platform specific methods.\n         let imms = [\n             immty_from_uint_checked(mask, __u32_layout)?, // stx_mask\n             immty_from_uint_checked(0u128, __u32_layout)?, // stx_blksize\n@@ -402,7 +462,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             immty_from_uint_checked(mode, __u16_layout)?, // stx_mode\n             immty_from_uint_checked(0u128, __u16_layout)?, // statx padding\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_ino\n-            immty_from_uint_checked(size, __u64_layout)?, // stx_size\n+            immty_from_uint_checked(metadata.size, __u64_layout)?, // stx_size\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_blocks\n             immty_from_uint_checked(0u128, __u64_layout)?, // stx_attributes\n             immty_from_uint_checked(access_sec, __u64_layout)?, // stx_atime.tv_sec\n@@ -440,19 +500,68 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch, and\n-// then sets the `mask` bits determined by `flag` when `time` is Ok. If `time` is an error, it\n-// returns `(0, 0)` without setting any bits.\n+/// Extracts the number of seconds and nanoseconds elapsed between `time` and the unix epoch when\n+/// `time` is Ok. Returns `None` if `time` is an error. Fails if `time` happens before the unix\n+/// epoch.\n fn extract_sec_and_nsec<'tcx>(\n-    time: std::io::Result<SystemTime>,\n-    mask: &mut u32,\n-    flag: u32,\n-) -> InterpResult<'tcx, (u64, u32)> {\n-    if let Ok(time) = time {\n+    time: std::io::Result<SystemTime>\n+) -> InterpResult<'tcx, Option<(u64, u32)>> {\n+    time.ok().map(|time| {\n         let duration = system_time_to_duration(&time)?;\n-        *mask |= flag;\n         Ok((duration.as_secs(), duration.subsec_nanos()))\n-    } else {\n-        Ok((0, 0))\n+    }).transpose()\n+}\n+\n+/// Stores a file's metadata in order to avoid code duplication in the different metadata related\n+/// shims.\n+struct FileMetadata {\n+    mode: Scalar<Tag>,\n+    size: u64,\n+    created: Option<(u64, u32)>,\n+    accessed: Option<(u64, u32)>,\n+    modified: Option<(u64, u32)>,\n+}\n+\n+impl FileMetadata {\n+    fn new<'tcx, 'mir>(\n+        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        path: PathBuf,\n+        follow_symlink: bool\n+    ) -> InterpResult<'tcx, Option<FileMetadata>> {\n+        let metadata = if follow_symlink {\n+            std::fs::metadata(path)\n+        } else {\n+            // FIXME: metadata for symlinks need testing.\n+            std::fs::symlink_metadata(path)\n+        };\n+\n+        let metadata = match metadata {\n+            Ok(metadata) => metadata,\n+            Err(e) => {\n+                ecx.set_last_error_from_io_error(e)?;\n+                return Ok(None);\n+            }\n+        };\n+\n+        let file_type = metadata.file_type();\n+\n+        let mode_name = if file_type.is_file() {\n+            \"S_IFREG\"\n+        } else if file_type.is_dir() {\n+            \"S_IFDIR\"\n+        } else {\n+            \"S_IFLNK\"\n+        };\n+\n+        let mode = ecx.eval_libc(mode_name)?;\n+\n+        let size = metadata.len();\n+\n+        let created = extract_sec_and_nsec(metadata.created())?;\n+        let accessed = extract_sec_and_nsec(metadata.accessed())?;\n+        let modified = extract_sec_and_nsec(metadata.modified())?;\n+\n+        // FIXME: Provide more fields using platform specific methods.\n+        Ok(Some(FileMetadata { mode, size, created, accessed, modified }))\n     }\n }"}, {"sha": "85e39bc45112b0602032fada148730f29ad9d4eb", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f1dec05dde67d6def6645ba82e8e7de68776766/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f1dec05dde67d6def6645ba82e8e7de68776766/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=0f1dec05dde67d6def6645ba82e8e7de68776766", "patch": "@@ -5,7 +5,6 @@ use std::fs::{File, remove_file};\n use std::io::{Read, Write, ErrorKind, Result};\n use std::path::{PathBuf, Path};\n \n-#[cfg(target_os = \"linux\")]\n fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n     // Test that the file metadata is correct.\n     let metadata = path.metadata()?;\n@@ -16,12 +15,6 @@ fn test_metadata(bytes: &[u8], path: &Path) -> Result<()> {\n     Ok(())\n }\n \n-// FIXME: Implement stat64 for macos.\n-#[cfg(not(target_os = \"linux\"))]\n-fn test_metadata(_bytes: &[u8], _path: &Path) -> Result<()> {\n-    Ok(())\n-}\n-\n fn main() {\n     let tmp = std::env::temp_dir();\n     let filename = PathBuf::from(\"miri_test_fs.txt\");\n@@ -58,7 +51,5 @@ fn main() {\n     // Removing a non-existing file should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, remove_file(&path).unwrap_err().kind());\n     // Reading the metadata of a non-existing file should fail with a \"not found\" error.\n-    if cfg!(target_os = \"linux\") { // FIXME: Implement stat64 for macos.\n-        assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n-    }\n+    assert_eq!(ErrorKind::NotFound, test_metadata(bytes, &path).unwrap_err().kind());\n }"}]}