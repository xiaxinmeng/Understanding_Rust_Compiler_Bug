{"sha": "08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YzExNTVhMjIzZWI3OTk2MGU3YTVkYmIwZWE2Mjc2ZWY5NzU0ZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T08:52:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-16T08:52:09Z"}, "message": "auto merge of #7142 : alexcrichton/rust/deriving-zero, r=pcwalton\n\nThis allows mass-initialization of large structs without having to specify all the fields.\r\n\r\nI'm a bit hesitant, but I wanted to get this out there. I don't really like using the `Zero` trait, because it doesn't really make sense for a type like `HashMap` to use `Zero` as the 'blank allocation' trait. In theory there'd be a new trait, but then that's adding cruft to the language which may not necessarily need to be there.\r\n\r\nI do think that this can be useful, but I only implemented `Zero` on the basic types where I thought it made sense, so it may not be all that usable yet. (opinions?)", "tree": {"sha": "fdbb9cbe16c75d9cb615fc651a3946fb6391ed17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdbb9cbe16c75d9cb615fc651a3946fb6391ed17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "html_url": "https://github.com/rust-lang/rust/commit/08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1927d295013e19e57a9773c37ded698e89392eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1927d295013e19e57a9773c37ded698e89392eb", "html_url": "https://github.com/rust-lang/rust/commit/d1927d295013e19e57a9773c37ded698e89392eb"}, {"sha": "893c70d7bc670054ef646b71d4d503298cc50d76", "url": "https://api.github.com/repos/rust-lang/rust/commits/893c70d7bc670054ef646b71d4d503298cc50d76", "html_url": "https://github.com/rust-lang/rust/commit/893c70d7bc670054ef646b71d4d503298cc50d76"}], "stats": {"total": 203, "additions": 201, "deletions": 2}, "files": [{"sha": "7bfac2927c8dcc3b9856bb29f5b8ca27d3f8b7a4", "filename": "src/libstd/char.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -17,8 +17,8 @@ use u32;\n use uint;\n use unicode::{derived_property, general_category};\n \n-#[cfg(not(test))]\n-use cmp::{Eq, Ord};\n+#[cfg(not(test))] use cmp::{Eq, Ord};\n+#[cfg(not(test))] use num::Zero;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -328,6 +328,12 @@ impl Ord for char {\n     fn ge(&self, other: &char) -> bool { *self >= *other }\n }\n \n+#[cfg(not(test))]\n+impl Zero for char {\n+    fn zero() -> char { 0 as char }\n+    fn is_zero(&self) -> bool { *self == 0 as char }\n+}\n+\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());"}, {"sha": "4681e4f4f53ff2da03bdcb916a5c4f53e6fa7295", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -418,6 +418,21 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(radix: uint, pow\n     total\n }\n \n+impl<T: Zero> Zero for @mut T {\n+    fn zero() -> @mut T { @mut Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n+impl<T: Zero> Zero for @T {\n+    fn zero() -> @T { @Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n+impl<T: Zero> Zero for ~T {\n+    fn zero() -> ~T { ~Zero::zero() }\n+    fn is_zero(&self) -> bool { (**self).is_zero() }\n+}\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {"}, {"sha": "7627270644594c07fa8ac9db1e84ed1bca7d0668", "filename": "src/libstd/option.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -350,6 +350,11 @@ impl<T:Copy + Zero> Option<T> {\n     }\n }\n \n+impl<T> Zero for Option<T> {\n+    fn zero() -> Option<T> { None }\n+    fn is_zero(&self) -> bool { self.is_none() }\n+}\n+\n /// Immutable iterator over an `Option<A>`\n pub struct OptionIterator<'self, A> {\n     priv opt: Option<&'self A>"}, {"sha": "aa6b1470b264babc222a19e72d45b184d8cc7806", "filename": "src/libstd/str.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -27,6 +27,7 @@ use container::Container;\n use iter::Times;\n use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIterator};\n use libc;\n+use num::Zero;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n use ptr;\n@@ -2201,6 +2202,16 @@ impl<'self> Iterator<u8> for StrBytesRevIterator<'self> {\n     }\n }\n \n+impl Zero for ~str {\n+    fn zero() -> ~str { ~\"\" }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl Zero for @str {\n+    fn zero() -> @str { @\"\" }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use iterator::IteratorUtil;"}, {"sha": "b80f152a5b1da75153696df30a5f5e9572798218", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -135,6 +135,7 @@ macro_rules! tuple_impls {\n         pub mod inner {\n             use clone::Clone;\n             #[cfg(not(test))] use cmp::*;\n+            #[cfg(not(test))] use num::Zero;\n \n             $(\n                 pub trait $cloneable_trait<$($T),+> {\n@@ -210,6 +211,18 @@ macro_rules! tuple_impls {\n                         lexical_cmp!($(self.$get_ref_fn(), other.$get_ref_fn()),+)\n                     }\n                 }\n+\n+                #[cfg(not(test))]\n+                impl<$($T:Zero),+> Zero for ($($T),+) {\n+                    #[inline]\n+                    fn zero() -> ($($T),+) {\n+                        ($(Zero::zero::<$T>()),+)\n+                    }\n+                    #[inline]\n+                    fn is_zero(&self) -> bool {\n+                        $(self.$get_ref_fn().is_zero())&&+\n+                    }\n+                }\n             )+\n         }\n     }"}, {"sha": "1a236a49a322e93c5486fb78c27d693a57a78634", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -23,6 +23,7 @@ use iterator::{Iterator, IteratorUtil};\n use iter::FromIter;\n use kinds::Copy;\n use libc;\n+use num::Zero;\n use old_iter::CopyableIter;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n@@ -2628,6 +2629,16 @@ impl<A:Clone> Clone for ~[A] {\n     }\n }\n \n+impl<A> Zero for ~[A] {\n+    fn zero() -> ~[A] { ~[] }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<A> Zero for @[A] {\n+    fn zero() -> @[A] { @[] }\n+    fn is_zero(&self) -> bool { self.len() == 0 }\n+}\n+\n macro_rules! iterator {\n     /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {"}, {"sha": "f5170d284c60850d2033b1f9f7cdee570f35f387", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -31,6 +31,7 @@ pub mod encodable;\n pub mod decodable;\n pub mod rand;\n pub mod to_str;\n+pub mod zero;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -98,6 +99,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"Zero\" => expand!(zero::expand_deriving_zero),\n \n                             ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\"}, {"sha": "121d8351ee477f6f941aadd0abe71feeef214444", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast::{meta_item, item, expr};\n+use codemap::span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+use core::vec;\n+\n+pub fn expand_deriving_zero(cx: @ExtCtxt,\n+                            span: span,\n+                            mitem: @meta_item,\n+                            in_items: ~[@item])\n+    -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[],\n+                ret_ty: Self,\n+                const_nonmatching: false,\n+                combine_substructure: zero_substructure\n+            },\n+            MethodDef {\n+                name: \"is_zero\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: ~[],\n+                ret_ty: Literal(Path::new(~[\"bool\"])),\n+                const_nonmatching: false,\n+                combine_substructure: |cx, span, substr| {\n+                    cs_and(|cx, span, _, _| cx.span_bug(span,\n+                                                        \"Non-matching enum \\\n+                                                         variant in \\\n+                                                         deriving(Zero)\"),\n+                           cx, span, substr)\n+                }\n+            }\n+        ]\n+    };\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn zero_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    let zero_ident = ~[\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"num\"),\n+        cx.ident_of(\"Zero\"),\n+        cx.ident_of(\"zero\")\n+    ];\n+    let zero_call = || {\n+        cx.expr_call_global(span, copy zero_ident, ~[])\n+    };\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            match *summary {\n+                Left(count) => {\n+                    if count == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let exprs = vec::from_fn(count, |_| zero_call());\n+                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let zero_fields = do fields.map |ident| {\n+                        cx.field_imm(span, *ident, zero_call())\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n+                }\n+            }\n+        }\n+        StaticEnum(*) => {\n+            cx.span_fatal(span, \"`Zero` cannot be derived for enums, \\\n+                                 only structs\")\n+        }\n+        _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n+    };\n+}"}, {"sha": "2ee57624112fae4ecf4b0aa62c69fb3aaab0063b", "filename": "src/test/run-pass/deriving-zero.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08c1155a223eb79960e7a5dbb0ea6276ef9754ea/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=08c1155a223eb79960e7a5dbb0ea6276ef9754ea", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::util;\n+use std::num::Zero;\n+\n+#[deriving(Zero)]\n+struct A;\n+#[deriving(Zero)]\n+struct B(int);\n+#[deriving(Zero)]\n+struct C(int, int);\n+#[deriving(Zero)]\n+struct D { a: int }\n+#[deriving(Zero)]\n+struct E { a: int, b: int }\n+\n+#[deriving(Zero)]\n+struct Lots {\n+    a: ~str,\n+    b: @str,\n+    c: Option<util::NonCopyable>,\n+    d: u8,\n+    e: char,\n+    f: float,\n+    g: (f32, char),\n+    h: ~[util::NonCopyable],\n+    i: @mut (int, int),\n+}\n+\n+fn main() {\n+    assert!(Zero::zero::<Lots>().is_zero());\n+}"}]}