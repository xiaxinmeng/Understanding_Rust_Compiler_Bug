{"sha": "1dac3adc34a85670d81f86345054ec58e658b68b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYWMzYWRjMzRhODU2NzBkODFmODYzNDUwNTRlYzU4ZTY1OGI2OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-05T21:51:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-05T21:51:29Z"}, "message": "Auto merge of #29648 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #29609, #29611, #29613, #29614, #29619, #29624, #29630\n- Failed merges:", "tree": {"sha": "2a7bc70a264f0e46a904cc6f49da6944c4bc4d18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a7bc70a264f0e46a904cc6f49da6944c4bc4d18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dac3adc34a85670d81f86345054ec58e658b68b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dac3adc34a85670d81f86345054ec58e658b68b", "html_url": "https://github.com/rust-lang/rust/commit/1dac3adc34a85670d81f86345054ec58e658b68b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dac3adc34a85670d81f86345054ec58e658b68b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96c95f160fd23c0bb815cefc9f2228d677b7f34a", "url": "https://api.github.com/repos/rust-lang/rust/commits/96c95f160fd23c0bb815cefc9f2228d677b7f34a", "html_url": "https://github.com/rust-lang/rust/commit/96c95f160fd23c0bb815cefc9f2228d677b7f34a"}, {"sha": "1036d64db0fdc928f061ce25de5cc049de189511", "url": "https://api.github.com/repos/rust-lang/rust/commits/1036d64db0fdc928f061ce25de5cc049de189511", "html_url": "https://github.com/rust-lang/rust/commit/1036d64db0fdc928f061ce25de5cc049de189511"}], "stats": {"total": 264, "additions": 51, "deletions": 213}, "files": [{"sha": "e0c2f4e5c3078cde0d3da6a5b63aeb7eecd6539e", "filename": "src/doc/reference.md", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -547,9 +547,20 @@ a `$` literally, including delimiters. For parsing reasons, delimiters must be\n balanced, but they are otherwise not special.\n \n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the Rust\n-syntax named by _designator_. Valid designators are `item`, `block`, `stmt`,\n-`pat`, `expr`, `ty` (type), `ident`, `path`, `tt` (either side of the `=>`\n-in macro rules), and `meta` (contents of an attribute). In the transcriber, the\n+syntax named by _designator_. Valid designators are:\n+\n+* `item`: an [item](#items)\n+* `block`: a [block](#block-expressions)\n+* `stmt`: a [statement](#statements)\n+* `pat`: a [pattern](#match-expressions)\n+* `expr`: an [expression](#expressions)\n+* `ty`: a [type](#types)\n+* `ident`: an [identifier](#identifiers)\n+* `path`: a [path](#paths)\n+* `tt`: either side of the `=>` in macro rules\n+* `meta`: the contents of an [attribute](#attributes)\n+\n+In the transcriber, the\n designator is already known, and so only the name of a matched nonterminal comes\n after the dollar sign.\n "}, {"sha": "7acb7f835b8ddbab7f3398bbbe787c9d2e7906c9", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 3, "deletions": 153, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -41,158 +41,8 @@ Copious cross-linking connects these parts together.\n \n ### Contributing\n \n-The source files from which this book is generated can be found on GitHub:\n-[github.com/rust-lang/rust/tree/master/src/doc/trpl](https://github.com/rust-lang/rust/tree/master/src/doc/trpl)\n+The source files from which this book is generated can be found on\n+[GitHub][trpl].\n \n-## A brief introduction to Rust\n+[trpl]: https://github.com/rust-lang/rust/tree/master/src/doc/trpl\n \n-Is Rust a language you might be interested in? Let\u2019s examine a few small code\n-samples to show off a few of its strengths.\n-\n-The main concept that makes Rust unique is called \u2018ownership\u2019. Consider this\n-small example:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-}\n-```\n-\n-This program makes a [variable binding][var] named `x`. The value of this\n-binding is a `Vec<T>`, a \u2018vector\u2019, that we create through a [macro][macro]\n-defined in the standard library. This macro is called `vec`, and we invoke\n-macros with a `!`. This follows a general principle of Rust: make things\n-explicit. Macros can do significantly more complicated things than function\n-calls, and so they\u2019re visually distinct. The `!` also helps with parsing,\n-making tooling easier to write, which is also important.\n-\n-We used `mut` to make `x` mutable: bindings are immutable by default in Rust.\n-We\u2019ll be mutating this vector later in the example.\n-\n-It\u2019s also worth noting that we didn\u2019t need a type annotation here: while Rust\n-is statically typed, we didn\u2019t need to explicitly annotate the type. Rust has\n-type inference to balance out the power of static typing with the verbosity of\n-annotating types.\n-\n-Rust prefers stack allocation to heap allocation: `x` is placed directly on the\n-stack. However, the `Vec<T>` type allocates space for the elements of the vector\n-on the heap. If you\u2019re not familiar with this distinction, you can ignore it for\n-now, or check out [\u2018The Stack and the Heap\u2019][heap]. As a systems programming\n-language, Rust gives us the ability to control how our memory is allocated, but\n-when we\u2019re getting started, it\u2019s less of a big deal.\n-\n-[var]: variable-bindings.html\n-[macro]: macros.html\n-[heap]: the-stack-and-the-heap.html\n-\n-Earlier, we mentioned that \u2018ownership\u2019 is the key new concept in Rust. In Rust\n-parlance, `x` is said to \u2018own\u2019 the vector. This means that when `x` goes out of\n-scope, the vector\u2019s memory will be de-allocated. This is done deterministically\n-by the Rust compiler, rather than through a mechanism such as a garbage\n-collector. In other words, in Rust, we don\u2019t call functions like `malloc` and\n-`free` ourselves: the compiler statically determines when we need to allocate or\n-deallocate memory, and inserts those calls itself. To err is to be human, but\n-compilers never forget.\n-\n-Let\u2019s add another line to our example:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = &x[0];\n-}\n-```\n-\n-We\u2019ve introduced another binding, `y`. In this case, `y` is a \u2018reference\u2019 to the\n-first element of the vector. Rust\u2019s references are similar to pointers in other\n-languages, but with additional compile-time safety checks. References interact\n-with the ownership system by [\u2018borrowing\u2019][borrowing] what they point to, rather\n-than owning it. The difference is, when the reference goes out of scope, it\n-won't deallocate the underlying memory. If it did, we\u2019d de-allocate twice, which\n-is bad!\n-\n-[borrowing]: references-and-borrowing.html\n-\n-Let\u2019s add a third line. It looks innocent enough, but causes a compiler error:\n-\n-```rust,ignore\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = &x[0];\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-`push` is a method on vectors that appends another element to the end of the\n-vector. When we try to compile this program, we get an error:\n-\n-```text\n-error: cannot borrow `x` as mutable because it is also borrowed as immutable\n-    x.push(\"foo\");\n-    ^\n-note: previous borrow of `x` occurs here; the immutable borrow prevents\n-subsequent moves or mutable borrows of `x` until the borrow ends\n-    let y = &x[0];\n-             ^\n-note: previous borrow ends here\n-fn main() {\n-\n-}\n-^\n-```\n-\n-Whew! The Rust compiler gives quite detailed errors at times, and this is one\n-of those times. As the error explains, while we made our binding mutable, we\n-still can't call `push`. This is because we already have a reference to an\n-element of the vector, `y`. Mutating something while another reference exists\n-is dangerous, because we may invalidate the reference. In this specific case,\n-when we create the vector, we may have only allocated space for two elements.\n-Adding a third would mean allocating a new chunk of memory for all those elements,\n-copying the old values over, and updating the internal pointer to that memory.\n-That all works just fine. The problem is that `y` wouldn\u2019t get updated, and so\n-we\u2019d have a \u2018dangling pointer\u2019. That\u2019s bad. Any use of `y` would be an error in\n-this case, and so the compiler has caught this for us.\n-\n-So how do we solve this problem? There are two approaches we can take. The first\n-is making a copy rather than using a reference:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    let y = x[0].clone();\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-Rust has [move semantics][move] by default, so if we want to make a copy of some\n-data, we call the `clone()` method. In this example, `y` is no longer a reference\n-to the vector stored in `x`, but a copy of its first element, `\"Hello\"`. Now\n-that we don\u2019t have a reference, our `push()` works just fine.\n-\n-[move]: ownership.html#move-semantics\n-\n-If we truly want a reference, we need the other option: ensure that our reference\n-goes out of scope before we try to do the mutation. That looks like this:\n-\n-```rust\n-fn main() {\n-    let mut x = vec![\"Hello\", \"world\"];\n-\n-    {\n-        let y = &x[0];\n-    }\n-\n-    x.push(\"foo\");\n-}\n-```\n-\n-We created an inner scope with an additional set of curly braces. `y` will go out of\n-scope before we call `push()`, and so we\u2019re all good.\n-\n-This concept of ownership isn\u2019t just good for preventing dangling pointers, but an\n-entire set of related problems, like iterator invalidation, concurrency, and more."}, {"sha": "6a513fb2c5963dc84743e2011ebb2953ee341a07", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 27, "deletions": 49, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -83,7 +83,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"Failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -189,7 +188,6 @@ Let\u2019s move forward:\n \n ```rust,ignore\n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"Failed to read line\");\n ```\n \n@@ -245,7 +243,6 @@ a single line of text, it\u2019s only the first part of the single logical line of\n code:\n \n ```rust,ignore\n-        .ok()\n         .expect(\"Failed to read line\");\n ```\n \n@@ -254,33 +251,27 @@ and other whitespace. This helps you split up long lines. We _could_ have\n done:\n \n ```rust,ignore\n-    io::stdin().read_line(&mut guess).ok().expect(\"failed to read line\");\n+    io::stdin().read_line(&mut guess).expect(\"failed to read line\");\n ```\n \n-But that gets hard to read. So we\u2019ve split it up, three lines for three\n-method calls. We already talked about `read_line()`, but what about `ok()`\n-and `expect()`? Well, we already mentioned that `read_line()` puts what\n-the user types into the `&mut String` we pass it. But it also returns\n-a value: in this case, an [`io::Result`][ioresult]. Rust has a number of\n-types named `Result` in its standard library: a generic [`Result`][result],\n-and then specific versions for sub-libraries, like `io::Result`.\n+But that gets hard to read. So we\u2019ve split it up, three lines for three method\n+calls. We already talked about `read_line()`, but what about `expect()`? Well,\n+we already mentioned that `read_line()` puts what the user types into the `&mut\n+String` we pass it. But it also returns a value: in this case, an\n+[`io::Result`][ioresult]. Rust has a number of types named `Result` in its\n+standard library: a generic [`Result`][result], and then specific versions for\n+sub-libraries, like `io::Result`.\n \n [ioresult]: ../std/io/type.Result.html\n [result]: ../std/result/enum.Result.html\n \n The purpose of these `Result` types is to encode error handling information.\n Values of the `Result` type, like any type, have methods defined on them. In\n-this case, `io::Result` has an `ok()` method, which says \u2018we want to assume\n-this value is a successful one. If not, just throw away the error\n-information\u2019. Why throw it away? Well, for a basic program, we just want to\n-print a generic error, as basically any issue means we can\u2019t continue. The\n-[`ok()` method][ok] returns a value which has another method defined on it:\n-`expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n-if it isn\u2019t a successful one, [`panic!`][panic]s with a message you\n-passed it. A `panic!` like this will cause our program to crash, displaying\n-the message.\n-\n-[ok]: ../std/result/enum.Result.html#method.ok\n+this case, `io::Result` has an [`expect()` method][expect] that takes a value\n+it\u2019s called on, and if it isn\u2019t a successful one, [`panic!`][panic]s with a\n+message you passed it. A `panic!` like this will cause our program to crash,\n+displaying the message.\n+\n [expect]: ../std/option/enum.Option.html#method.expect\n [panic]: error-handling.html\n \n@@ -468,7 +459,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -557,7 +547,6 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -668,11 +657,9 @@ fn main() {\n     let mut guess = String::new();\n \n     io::stdin().read_line(&mut guess)\n-        .ok()\n         .expect(\"failed to read line\");\n \n     let guess: u32 = guess.trim().parse()\n-        .ok()\n         .expect(\"Please type a number!\");\n \n     println!(\"You guessed: {}\", guess);\n@@ -689,7 +676,6 @@ The new three lines:\n \n ```rust,ignore\n     let guess: u32 = guess.trim().parse()\n-        .ok()\n         .expect(\"Please type a number!\");\n ```\n \n@@ -706,27 +692,26 @@ We bind `guess` to an expression that looks like something we wrote earlier:\n guess.trim().parse()\n ```\n \n-Followed by an `ok().expect()` invocation. Here, `guess` refers to the old\n-`guess`, the one that was a `String` with our input in it. The `trim()`\n-method on `String`s will eliminate any white space at the beginning and end of\n-our string. This is important, as we had to press the \u2018return\u2019 key to satisfy\n-`read_line()`. This means that if we type `5` and hit return, `guess` looks\n-like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the enter key. `trim()` gets\n-rid of this, leaving our string with just the `5`. The [`parse()` method on\n-strings][parse] parses a string into some kind of number. Since it can parse a\n-variety of numbers, we need to give Rust a hint as to the exact type of number\n-we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n-we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n-integer. Rust has [a number of built-in number types][number], but we\u2019ve\n-chosen `u32`. It\u2019s a good default choice for a small positive number.\n+Here, `guess` refers to the old `guess`, the one that was a `String` with our\n+input in it. The `trim()` method on `String`s will eliminate any white space at\n+the beginning and end of our string. This is important, as we had to press the\n+\u2018return\u2019 key to satisfy `read_line()`. This means that if we type `5` and hit\n+return, `guess` looks like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the\n+enter key. `trim()` gets rid of this, leaving our string with just the `5`. The\n+[`parse()` method on strings][parse] parses a string into some kind of number.\n+Since it can parse a variety of numbers, we need to give Rust a hint as to the\n+exact type of number we want. Hence, `let guess: u32`. The colon (`:`) after\n+`guess` tells Rust we\u2019re going to annotate its type. `u32` is an unsigned,\n+thirty-two bit integer. Rust has [a number of built-in number types][number],\n+but we\u2019ve chosen `u32`. It\u2019s a good default choice for a small positive number.\n \n [parse]: ../std/primitive.str.html#method.parse\n [number]: primitive-types.html#numeric-types\n \n Just like `read_line()`, our call to `parse()` could cause an error. What if\n our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As\n-such, we\u2019ll do the same thing we did with `read_line()`: use the `ok()` and\n-`expect()` methods to crash if there\u2019s an error.\n+such, we\u2019ll do the same thing we did with `read_line()`: use the `expect()`\n+method to crash if there\u2019s an error.\n \n Let\u2019s try our program out!\n \n@@ -773,11 +758,9 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = guess.trim().parse()\n-            .ok()\n             .expect(\"Please type a number!\");\n \n         println!(\"You guessed: {}\", guess);\n@@ -841,11 +824,9 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = guess.trim().parse()\n-            .ok()\n             .expect(\"Please type a number!\");\n \n         println!(\"You guessed: {}\", guess);\n@@ -888,7 +869,6 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = match guess.trim().parse() {\n@@ -920,7 +900,6 @@ let guess: u32 = match guess.trim().parse() {\n ```\n \n This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n-error\u2019, by switching from `ok().expect()` to a `match` statement. The `Result`\n returned by `parse()` is an `enum` just like `Ordering`, but in this case, each\n variant has some data associated with it: `Ok` is a success, and `Err` is a\n failure. Each contains more information: the successfully parsed integer, or an\n@@ -977,7 +956,6 @@ fn main() {\n         let mut guess = String::new();\n \n         io::stdin().read_line(&mut guess)\n-            .ok()\n             .expect(\"failed to read line\");\n \n         let guess: u32 = match guess.trim().parse() {"}, {"sha": "95158054d656ecb36fe43510f49cd3f4b80c6881", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -1384,10 +1384,6 @@ impl<T: Ord> Ord for Vec<T> {\n impl<T> Drop for Vec<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        // NOTE: this is currently abusing the fact that ZSTs can't impl Drop.\n-        // Or rather, that impl'ing Drop makes them not zero-sized. This is\n-        // OK because exactly when this stops being a valid assumption, we\n-        // don't need unsafe_no_drop_flag shenanigans anymore.\n         if self.buf.unsafe_no_drop_flag_needs_drop() {\n             unsafe {\n                 // The branch on needs_drop() is an -O1 performance optimization."}, {"sha": "2f2dcc41a1c5e97f4cff1931748033efd782a42a", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -23,7 +23,7 @@ use option::Option;\n use hash::Hash;\n use hash::Hasher;\n \n-/// Types able to be transferred across thread boundaries.\n+/// Types that can be transferred across thread boundaries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -382,7 +382,7 @@ mod impls {\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n \n-/// A marker trait indicates a type that can be reflected over.\n+/// Types that can be reflected over.\n ///\n /// This trait is implemented for all types. Its purpose is to ensure\n /// that when you write a generic function that will employ"}, {"sha": "8844ed82bb5e29cd73c956d28ad56bee6d1a7451", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -101,6 +101,10 @@\n         if (document.activeElement.tagName == \"INPUT\")\n             return;\n \n+        // Don't interfere with browser shortcuts\n+        if (ev.ctrlKey || ev.altKey || ev.metaKey)\n+            return;\n+\n         switch (getVirtualKey(ev)) {\n         case \"Escape\":\n             if (!$(\"#help\").hasClass(\"hidden\")) {"}, {"sha": "01effcadb3acad15d38b541c1d0ef635ea12b6ab", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dac3adc34a85670d81f86345054ec58e658b68b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1dac3adc34a85670d81f86345054ec58e658b68b", "patch": "@@ -76,7 +76,7 @@\n //! `i32`](primitive.i32.html) that lists all the methods that can be called on\n //! 32-bit integers (very useful), and there is a [page for the module\n //! `std::i32`](i32/index.html) that documents the constant values [`MIN`] and\n-//! [`MAX`] (rarely useful).\n+//! [`MAX`](i32/constant.MAX.html) (rarely useful).\n //!\n //! Note the documentation for the primitives [`str`] and [`[T]`][slice] (also\n //! called 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\n@@ -153,7 +153,6 @@\n //!\n //! [I/O]: io/index.html\n //! [MIN]: i32/constant.MIN.html\n-//! [MAX]: i32/constant.MAX.html\n //! [TCP]: net/struct.TcpStream.html\n //! [The Rust Prelude]: prelude/index.html\n //! [UDP]: net/struct.UdpSocket.html"}]}