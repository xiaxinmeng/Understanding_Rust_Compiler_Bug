{"sha": "fe151194e9a919ab23c2bb356767a5cbfa3811e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMTUxMTk0ZTlhOTE5YWIyM2MyYmIzNTY3NjdhNWNiZmEzODExZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-30T06:48:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-30T06:48:52Z"}, "message": "Auto merge of #40597 - jseyfried:improve_span_expn_info, r=jseyfried\n\nmacros: improve `Span`'s expansion information\n\nThis PR improves `Span`'s expansion information. More specifically:\n - It refactors AST node span construction to preserve expansion information.\n   - Today, we only use the underlying tokens' `BytePos`s, throwing away the `ExpnId`s.\n   - This improves the accuracy of AST nodes' expansion information, fixing #30506.\n - It refactors `span.expn_id: ExpnId` to `span.ctxt: SyntaxContext` and removes `ExpnId`.\n   - This gives all tokens as much hygiene information as `Ident`s.\n   - This is groundwork for procedural macros 2.0 `TokenStream` API.\n   - This is also groundwork for declarative macros 2.0, which will need this hygiene information for some non-`Ident` tokens.\n - It simplifies processing of spans' expansion information throughout the compiler.\n - It fixes #40649.\n - It fixes #39450 and fixes part of #23480.\n\nr? @nrc", "tree": {"sha": "b51d7a522884fedf038037c75dc12e99e0474650", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b51d7a522884fedf038037c75dc12e99e0474650"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe151194e9a919ab23c2bb356767a5cbfa3811e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe151194e9a919ab23c2bb356767a5cbfa3811e7", "html_url": "https://github.com/rust-lang/rust/commit/fe151194e9a919ab23c2bb356767a5cbfa3811e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe151194e9a919ab23c2bb356767a5cbfa3811e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6afa0d42ff55591fdcbd2dc7da54970538ab3f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6afa0d42ff55591fdcbd2dc7da54970538ab3f3e", "html_url": "https://github.com/rust-lang/rust/commit/6afa0d42ff55591fdcbd2dc7da54970538ab3f3e"}, {"sha": "8fde04b4a295792249d4a01f87a9f66143aa7c83", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fde04b4a295792249d4a01f87a9f66143aa7c83", "html_url": "https://github.com/rust-lang/rust/commit/8fde04b4a295792249d4a01f87a9f66143aa7c83"}], "stats": {"total": 2340, "additions": 932, "deletions": 1408}, "files": [{"sha": "029b27b40f04d2120597b6994d6b7b5ed46d70f1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -57,6 +57,7 @@ use std::mem;\n use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::codemap::{self, respan, Spanned};\n use syntax::std_inject;\n@@ -392,14 +393,16 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n-        span.expn_id = self.sess.codemap().record_expansion(codemap::ExpnInfo {\n+        let mark = Mark::fresh();\n+        mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n                 format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n         });\n+        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n         span\n     }\n \n@@ -1993,7 +1996,7 @@ impl<'a> LoweringContext<'a> {\n                     volatile: asm.volatile,\n                     alignstack: asm.alignstack,\n                     dialect: asm.dialect,\n-                    expn_id: asm.expn_id,\n+                    ctxt: asm.ctxt,\n                 };\n                 let outputs =\n                     asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect();"}, {"sha": "afdb9059ea7c012ccf21de861bf492fcb59b35d9", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -92,7 +92,7 @@ impl<'a> DefCollector<'a> {\n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n-                mark: Mark::from_placeholder_id(id),\n+                mark: id.placeholder_to_mark(),\n                 const_expr: const_expr,\n                 def_index: self.parent_def.unwrap(),\n             })"}, {"sha": "3ca75dc6c00c90ea0fcc8f9914bf523c77d5708a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -33,11 +33,12 @@ use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n-use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n@@ -1367,7 +1368,7 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub expn_id: ExpnId,\n+    pub ctxt: SyntaxContext,\n }\n \n /// represents an argument in a function header"}, {"sha": "1278d9f5171b3be590be3880fd4804a4d6f7242a", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -47,10 +47,6 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         }\n     }\n \n-    pub fn codemap(&self) -> &'tcx CodeMap {\n-        self.codemap\n-    }\n-\n     pub fn byte_pos_to_line_and_col(&mut self,\n                                     pos: BytePos)\n                                     -> Option<(Rc<FileMap>, usize, BytePos)> {"}, {"sha": "0676075930dc3c99f28d4845126e6a1dcfec0617", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -236,7 +236,7 @@ impl CodeExtent {\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n                         let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, expn_id: stmt_span.expn_id })\n+                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, ctxt: stmt_span.ctxt })\n                     }\n                 }\n             }"}, {"sha": "8037570d24a808bb6ab7983d85d4ae7c4686d400", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -29,7 +29,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n-use syntax_pos::{mk_sp, Span};\n+use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n use rustc_back::slice;\n@@ -1468,8 +1468,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     self.resolve_lifetime_ref(bound);\n                 } else {\n                     self.insert_lifetime(bound, Region::Static);\n-                    let full_span = mk_sp(lifetime_i.lifetime.span.lo, bound.span.hi);\n-                    self.sess.struct_span_warn(full_span,\n+                    self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n                         &format!(\"unnecessary lifetime parameter `{}`\", lifetime_i.lifetime.name))\n                         .help(&format!(\"you can use the `'static` lifetime directly, in place \\\n                                         of `{}`\", lifetime_i.lifetime.name))"}, {"sha": "2b5ea61d4e85454a181d8cf8aeefb7c31b3db6fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n-        if self.sess.codemap().span_allows_unstable(span) {\n+        if span.allows_unstable() {\n             debug!(\"stability: \\\n                     skipping span={:?} since it is internal\", span);\n             return;"}, {"sha": "977382b33adf75a429eb566390c9471f3793d65c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -580,7 +580,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n     krate = time(time_passes, \"crate injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.clone();\n-        syntax::std_inject::maybe_inject_crates_ref(&sess.parse_sess, krate, alt_std_name)\n+        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name)\n     });\n \n     let mut addl_plugins = Some(addl_plugins);\n@@ -798,7 +798,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n-        syntax::ext::hygiene::reset_hygiene_data();\n+        syntax::ext::hygiene::clear_markings();\n     }\n \n     Ok(ExpansionResult {"}, {"sha": "367b85ac726db0aa49be0add1b7a59971713e526", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -10,7 +10,7 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n+use syntax_pos::{DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n@@ -151,7 +151,7 @@ impl EmitterWriter {\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n-                if span_label.span == DUMMY_SP || span_label.span == COMMAND_LINE_SP {\n+                if span_label.span == DUMMY_SP {\n                     continue;\n                 }\n                 let lo = cm.lookup_char_pos(span_label.span.lo);\n@@ -615,15 +615,15 @@ impl EmitterWriter {\n         let mut max = 0;\n         if let Some(ref cm) = self.cm {\n             for primary_span in msp.primary_spans() {\n-                if primary_span != &DUMMY_SP && primary_span != &COMMAND_LINE_SP {\n+                if primary_span != &DUMMY_SP {\n                     let hi = cm.lookup_char_pos(primary_span.hi);\n                     if hi.line > max {\n                         max = hi.line;\n                     }\n                 }\n             }\n             for span_label in msp.span_labels() {\n-                if span_label.span != DUMMY_SP && span_label.span != COMMAND_LINE_SP {\n+                if span_label.span != DUMMY_SP {\n                     let hi = cm.lookup_char_pos(span_label.span.hi);\n                     if hi.line > max {\n                         max = hi.line;\n@@ -659,20 +659,20 @@ impl EmitterWriter {\n \n             // First, find all the spans in <*macros> and point instead at their use site\n             for sp in span.primary_spans() {\n-                if (*sp == COMMAND_LINE_SP) || (*sp == DUMMY_SP) {\n+                if *sp == DUMMY_SP {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp.clone()).contains(\"macros>\") {\n-                    let v = cm.macro_backtrace(sp.clone());\n+                    let v = sp.macro_backtrace();\n                     if let Some(use_site) = v.last() {\n                         before_after.push((sp.clone(), use_site.call_site.clone()));\n                     }\n                 }\n-                for trace in cm.macro_backtrace(sp.clone()).iter().rev() {\n+                for trace in sp.macro_backtrace().iter().rev() {\n                     // Only show macro locations that are local\n                     // and display them like a span_note\n                     if let Some(def_site) = trace.def_site_span {\n-                        if (def_site == COMMAND_LINE_SP) || (def_site == DUMMY_SP) {\n+                        if def_site == DUMMY_SP {\n                             continue;\n                         }\n                         // Check to make sure we're not in any <*macros>\n@@ -689,11 +689,11 @@ impl EmitterWriter {\n                 span.push_span_label(label_span, label_text);\n             }\n             for sp_label in span.span_labels() {\n-                if (sp_label.span == COMMAND_LINE_SP) || (sp_label.span == DUMMY_SP) {\n+                if sp_label.span == DUMMY_SP {\n                     continue;\n                 }\n                 if cm.span_to_filename(sp_label.span.clone()).contains(\"macros>\") {\n-                    let v = cm.macro_backtrace(sp_label.span.clone());\n+                    let v = sp_label.span.macro_backtrace();\n                     if let Some(use_site) = v.last() {\n                         before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n                     }\n@@ -848,7 +848,7 @@ impl EmitterWriter {\n         // Make sure our primary file comes first\n         let primary_lo = if let (Some(ref cm), Some(ref primary_span)) =\n             (self.cm.as_ref(), msp.primary_span().as_ref()) {\n-            if primary_span != &&DUMMY_SP && primary_span != &&COMMAND_LINE_SP {\n+            if primary_span != &&DUMMY_SP {\n                 cm.lookup_char_pos(primary_span.lo)\n             } else {\n                 emit_to_destination(&buffer.render(), level, &mut self.dst)?;"}, {"sha": "2efdaa57fba36bf68ad45c2f635745574a1b2791", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -48,7 +48,6 @@ pub mod styled_buffer;\n mod lock;\n \n use syntax_pos::{BytePos, Loc, FileLinesResult, FileName, MultiSpan, Span, NO_EXPANSION};\n-use syntax_pos::MacroBacktrace;\n \n #[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum RenderSpan {\n@@ -75,7 +74,6 @@ pub trait CodeMapper {\n     fn span_to_lines(&self, sp: Span) -> FileLinesResult;\n     fn span_to_string(&self, sp: Span) -> String;\n     fn span_to_filename(&self, sp: Span) -> FileName;\n-    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace>;\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span>;\n }\n \n@@ -120,7 +118,7 @@ impl CodeSuggestion {\n         let bounding_span = Span {\n             lo: lo,\n             hi: hi,\n-            expn_id: NO_EXPANSION,\n+            ctxt: NO_EXPANSION,\n         };\n         let lines = cm.span_to_lines(bounding_span).unwrap();\n         assert!(!lines.lines.is_empty());"}, {"sha": "5401b371888e939c58b6b3145b5f3faf67aa5315", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -17,9 +17,10 @@ use self::SawTraitOrImplItemComponent::*;\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n+use syntax::ext::hygiene::SyntaxContext;\n use syntax::parse::token;\n use syntax::symbol::InternedString;\n-use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n+use syntax_pos::{Span, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n@@ -92,10 +93,10 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             span.hi\n         };\n \n-        let expn_kind = match span.expn_id {\n-            NO_EXPANSION => SawSpanExpnKind::NoExpansion,\n-            COMMAND_LINE_EXPN => SawSpanExpnKind::CommandLine,\n-            _ => SawSpanExpnKind::SomeExpansion,\n+        let expn_kind = if span.ctxt == SyntaxContext::empty() {\n+            SawSpanExpnKind::NoExpansion\n+        } else {\n+            SawSpanExpnKind::SomeExpansion\n         };\n \n         let loc1 = self.codemap.byte_pos_to_line_and_col(span.lo);\n@@ -121,8 +122,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         saw.hash(self.st);\n \n         if expn_kind == SawSpanExpnKind::SomeExpansion {\n-            let call_site = self.codemap.codemap().source_callsite(span);\n-            self.hash_span(call_site);\n+            self.hash_span(span.source_callsite());\n         }\n     }\n \n@@ -483,7 +483,6 @@ fn saw_impl_item(ii: &ImplItemKind) -> SawTraitOrImplItemComponent {\n #[derive(Clone, Copy, Hash, Eq, PartialEq)]\n enum SawSpanExpnKind {\n     NoExpansion,\n-    CommandLine,\n     SomeExpansion,\n }\n \n@@ -501,7 +500,7 @@ impl<'a> Hash for StableInlineAsm<'a> {\n             volatile,\n             alignstack,\n             dialect,\n-            expn_id: _, // This is used for error reporting\n+            ctxt: _, // This is used for error reporting\n         } = *self.0;\n \n         asm.as_str().hash(state);"}, {"sha": "41a2e8a8d55e3e2da627f460fe7a5faef3e571b8", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -36,7 +36,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n-use syntax_pos::{mk_sp, Span};\n+use syntax_pos::{Span, NO_EXPANSION};\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -395,7 +395,7 @@ impl CrateStore for cstore::CStore {\n         let source_name = format!(\"<{} macros>\", name);\n \n         let filemap = sess.parse_sess.codemap().new_filemap(source_name, None, def.body);\n-        let local_span = mk_sp(filemap.start_pos, filemap.end_pos);\n+        let local_span = Span { lo: filemap.start_pos, hi: filemap.end_pos, ctxt: NO_EXPANSION };\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n \n         // Mark the attrs as used"}, {"sha": "43e076e799b3d07fedf223d537fdee94813e7666", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -39,7 +39,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::codemap;\n use syntax::ext::base::MacroKind;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n-            return Ok(syntax_pos::mk_sp(lo, hi));\n+            return Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION });\n         };\n \n         let (lo, hi) = if lo > hi {\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n         let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n \n-        Ok(syntax_pos::mk_sp(lo, hi))\n+        Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n     }\n }\n "}, {"sha": "9d236bd013c43114db3ef0f13921c839fd933e78", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             // This comes from a macro that has #[allow_internal_unstable].\n-            if self.tcx.sess.codemap().span_allows_unstable(self.span) {\n+            if self.span.allows_unstable() {\n                 return;\n             }\n \n@@ -805,7 +805,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     self.def_id.is_local() &&\n \n                     // this doesn't come from a macro that has #[allow_internal_unstable]\n-                    !self.tcx.sess.codemap().span_allows_unstable(self.span)\n+                    !self.span.allows_unstable()\n                 {\n                     let mut err = self.tcx.sess.struct_span_err(self.span,\n                         \"const fns are an unstable feature\");"}, {"sha": "e884f3bdbb122f24ff546440dbb7366a84e3a81f", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -20,7 +20,7 @@ use std::env;\n use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n-use syntax_pos::{Span, COMMAND_LINE_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n pub type PluginRegistrarFun =\n@@ -81,7 +81,7 @@ pub fn load_plugins(sess: &Session,\n \n     if let Some(plugins) = addl_plugins {\n         for plugin in plugins {\n-            loader.load_plugin(COMMAND_LINE_SP, &plugin, vec![]);\n+            loader.load_plugin(DUMMY_SP, &plugin, vec![]);\n         }\n     }\n "}, {"sha": "a15431afc164b66e14a5cab7e2bd1a598263e3cd", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -680,7 +680,7 @@ pub struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n \n impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) -> &'b InvocationData<'b> {\n-        let mark = Mark::from_placeholder_id(id);\n+        let mark = id.placeholder_to_mark();\n         self.resolver.current_module.unresolved_invocations.borrow_mut().insert(mark);\n         let invocation = self.resolver.invocations[&mark];\n         invocation.module.set(self.resolver.current_module);"}, {"sha": "1de9fbc8e4941f04e02d2de4c226c714050f7a31", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -690,9 +690,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // Note we take care to use the source callsite/callee, to handle\n         // nested expansions and ensure we only generate data for source-visible\n         // macro uses.\n-        let callsite = self.tcx.sess.codemap().source_callsite(span);\n-        let callee = self.tcx.sess.codemap().source_callee(span);\n-        let callee = option_try!(callee);\n+        let callsite = span.source_callsite();\n+        let callee = option_try!(span.source_callee());\n         let callee_span = option_try!(callee.span);\n \n         // Ignore attribute macros, their spans are usually mangled\n@@ -743,7 +742,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let ident_start = text.find(&name).expect(\"Name not in signature?\");\n         let ident_end = ident_start + name.len();\n         Signature {\n-            span: mk_sp(item.span.lo, item.span.lo + BytePos(text.len() as u32)),\n+            span: Span { hi: item.span.lo + BytePos(text.len() as u32), ..item.span },\n             text: text,\n             ident_start: ident_start,\n             ident_end: ident_end,\n@@ -1013,5 +1012,5 @@ fn escape(s: String) -> String {\n // Helper function to determine if a span came from a\n // macro expansion or syntax extension.\n pub fn generated_code(span: Span) -> bool {\n-    span.expn_id != NO_EXPANSION || span == DUMMY_SP\n+    span.ctxt != NO_EXPANSION || span == DUMMY_SP\n }"}, {"sha": "af3efb48090810a602e53a51b6f634de54fa8744", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -305,10 +305,10 @@ impl<'a> SpanUtils<'a> {\n                 continue;\n             }\n             if let TokenTree::Token(_, token::Semi) = tok {\n-                return self.snippet(mk_sp(first_span.lo, prev.span().hi));\n+                return self.snippet(first_span.to(prev.span()));\n             } else if let TokenTree::Delimited(_, ref d) = tok {\n                 if d.delim == token::Brace {\n-                    return self.snippet(mk_sp(first_span.lo, prev.span().hi));\n+                    return self.snippet(first_span.to(prev.span()));\n                 }\n             }\n             prev = tok;\n@@ -462,8 +462,7 @@ impl<'a> SpanUtils<'a> {\n \n         // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n         // callsite. This filters out macro internal variables and most malformed spans.\n-        let span = self.sess.codemap().source_callsite(parent);\n-        !(span.contains(parent))\n+        !parent.source_callsite().contains(parent)\n     }\n }\n "}, {"sha": "3e270b7928ebc28127af2ab9d8228ce937286fa3", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -111,14 +111,14 @@ pub fn trans_inline_asm<'a, 'tcx>(\n         bcx.store(v, val, None);\n     }\n \n-    // Store expn_id in a metadata node so we can map LLVM errors\n+    // Store mark in a metadata node so we can map LLVM errors\n     // back to source locations.  See #17552.\n     unsafe {\n         let key = \"srcloc\";\n         let kind = llvm::LLVMGetMDKindIDInContext(bcx.ccx.llcx(),\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.expn_id.into_u32() as i32);\n+        let val: llvm::ValueRef = C_i32(bcx.ccx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bcx.ccx.llcx(), &val, 1));"}, {"sha": "ccb3f7ac882aa8b209a2492fc551df8a6d5ee0b8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -371,14 +371,14 @@ struct HandlerFreeVars<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    use syntax_pos::ExpnId;\n+    use syntax::ext::hygiene::Mark;\n \n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n-            sess.codemap().with_expn_info(ExpnId::from_u32(cookie), |info| match info {\n+            match Mark::from_u32(cookie).expn_info() {\n                 Some(ei) => sess.span_err(ei.call_site, msg),\n                 None     => sess.err(msg),\n-            });\n+            };\n         }\n \n         None => {"}, {"sha": "21bbbea77d442aa98f625df2ada73c179496bc46", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -26,7 +26,7 @@ use monomorphize::{self, Instance};\n use abi::FnType;\n use type_of;\n \n-use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos, Span};\n+use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n \n use std::iter;\n@@ -124,24 +124,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // In order to have a good line stepping behavior in debugger, we overwrite debug\n         // locations of macro expansions with that of the outermost expansion site\n         // (unless the crate is being compiled with `-Z debug-macros`).\n-        if source_info.span.expn_id == NO_EXPANSION ||\n-            source_info.span.expn_id == COMMAND_LINE_EXPN ||\n-            self.ccx.sess().opts.debugging_opts.debug_macros {\n-\n+        if source_info.span.ctxt == NO_EXPANSION ||\n+           self.ccx.sess().opts.debugging_opts.debug_macros {\n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo);\n             (scope, source_info.span)\n         } else {\n-            let cm = self.ccx.sess().codemap();\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             // We also stop at the function body level because no line stepping can occurr\n             // at the level above that.\n             let mut span = source_info.span;\n-            while span.expn_id != NO_EXPANSION &&\n-                  span.expn_id != COMMAND_LINE_EXPN &&\n-                  span.expn_id != self.mir.span.expn_id {\n-                if let Some(callsite_span) = cm.with_expn_info(span.expn_id,\n-                                                    |ei| ei.map(|ei| ei.call_site.clone())) {\n-                    span = callsite_span;\n+            while span.ctxt != NO_EXPANSION && span.ctxt != self.mir.span.ctxt {\n+                if let Some(info) = span.ctxt.outer().expn_info() {\n+                    span = info.call_site;\n                 } else {\n                     break;\n                 }"}, {"sha": "afa1e0557dc8b0019f621fde8374f68732c102d1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -4163,12 +4163,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 if let Some(last_stmt) = extra_semi {\n-                    let original_span = original_sp(self.tcx.sess.codemap(),\n-                                                    last_stmt.span, blk.span);\n+                    let original_span = original_sp(last_stmt.span, blk.span);\n                     let span_semi = Span {\n                         lo: original_span.hi - BytePos(1),\n                         hi: original_span.hi,\n-                        expn_id: original_span.expn_id\n+                        ctxt: original_span.ctxt,\n                     };\n                     err.span_help(span_semi, \"consider removing this semicolon:\");\n                 }"}, {"sha": "9eb86aa006d171f4ca0af868bdb13bd66921a237", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 17, "deletions": 58, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -14,74 +14,25 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n-pub use symbol::Symbol as Name;\n+pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n \n-use syntax_pos::{mk_sp, BytePos, Span, DUMMY_SP, ExpnId};\n+use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n use abi::Abi;\n-use ext::hygiene::SyntaxContext;\n+use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n use rustc_data_structures::indexed_vec;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n+use serialize::{self, Encoder, Decoder};\n use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n-use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n-\n-/// An identifier contains a Name (index into the interner\n-/// table) and a SyntaxContext to track renaming and\n-/// macro expansion per Flatt et al., \"Macros That Work Together\"\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    pub name: Symbol,\n-    pub ctxt: SyntaxContext\n-}\n-\n-impl Ident {\n-    pub const fn with_empty_ctxt(name: Name) -> Ident {\n-        Ident { name: name, ctxt: SyntaxContext::empty() }\n-    }\n-\n-    /// Maps a string to an identifier with an empty syntax context.\n-    pub fn from_str(s: &str) -> Ident {\n-        Ident::with_empty_ctxt(Symbol::intern(s))\n-    }\n-\n-    pub fn unhygienize(&self) -> Ident {\n-        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n-    }\n-}\n-\n-impl fmt::Debug for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{:?}\", self.name, self.ctxt)\n-    }\n-}\n-\n-impl fmt::Display for Ident {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.name, f)\n-    }\n-}\n-\n-impl Encodable for Ident {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.name.encode(s)\n-    }\n-}\n-\n-impl Decodable for Ident {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n-        Ok(Ident::with_empty_ctxt(Name::decode(d)?))\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -256,6 +207,14 @@ impl NodeId {\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    pub fn placeholder_from_mark(mark: Mark) -> Self {\n+        NodeId(mark.as_u32())\n+    }\n+\n+    pub fn placeholder_to_mark(self) -> Mark {\n+        Mark::from_u32(self.0)\n+    }\n }\n \n impl fmt::Display for NodeId {\n@@ -1437,7 +1396,7 @@ pub struct InlineAsm {\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n-    pub expn_id: ExpnId,\n+    pub ctxt: SyntaxContext,\n }\n \n /// An argument in a function header.\n@@ -1474,7 +1433,7 @@ impl Arg {\n                     TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n-                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                    _ => Some(respan(self.pat.span.to(self.ty.span),\n                                      SelfKind::Explicit(self.ty.clone(), mutbl))),\n                 }\n             }\n@@ -1491,7 +1450,7 @@ impl Arg {\n     }\n \n     pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n-        let span = mk_sp(eself.span.lo, eself_ident.span.hi);\n+        let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n@@ -1728,11 +1687,11 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, lo: BytePos, hi: BytePos) -> Self {\n+    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_lifetimes: lifetimes,\n             trait_ref: TraitRef { path: path, ref_id: DUMMY_NODE_ID },\n-            span: mk_sp(lo, hi),\n+            span: span,\n         }\n     }\n }"}, {"sha": "6f5f52ff1e953fa4b5798d90df7be07a434ddca3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -18,8 +18,8 @@ use ast;\n use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n-use codemap::{Spanned, spanned, dummy_spanned, mk_sp};\n-use syntax_pos::{Span, BytePos, DUMMY_SP};\n+use codemap::{Spanned, respan, dummy_spanned};\n+use syntax_pos::{Span, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -447,17 +447,16 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n-                           -> Attribute {\n+pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = spanned(lo, hi, LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit = respan(span, LitKind::Str(text, ast::StrStyle::Cooked));\n     Attribute {\n         id: id,\n         style: style,\n-        path: ast::Path::from_ident(mk_sp(lo, hi), ast::Ident::from_str(\"doc\")),\n-        tokens: MetaItemKind::NameValue(lit).tokens(mk_sp(lo, hi)),\n+        path: ast::Path::from_ident(span, ast::Ident::from_str(\"doc\")),\n+        tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n-        span: mk_sp(lo, hi),\n+        span: span,\n     }\n }\n \n@@ -1016,9 +1015,10 @@ impl MetaItem {\n     {\n         let (mut span, name) = match tokens.next() {\n             Some(TokenTree::Token(span, Token::Ident(ident))) => (span, ident.name),\n-            Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => return match **nt {\n-                token::Nonterminal::NtMeta(ref meta) => Some(meta.clone()),\n-                _ => None,\n+            Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match **nt {\n+                token::Nonterminal::NtIdent(ident) => (ident.span, ident.node.name),\n+                token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n+                _ => return None,\n             },\n             _ => return None,\n         };"}, {"sha": "4d67390d442343da534036c7d30f049e8050af34", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 14, "deletions": 466, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -17,6 +17,8 @@\n //! within the CodeMap, which upon request can be converted to line and column\n //! information, source code snippets, etc.\n \n+pub use syntax_pos::*;\n+pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n use std::cell::RefCell;\n@@ -26,45 +28,27 @@ use std::rc::Rc;\n use std::env;\n use std::fs;\n use std::io::{self, Read};\n-pub use syntax_pos::*;\n use errors::CodeMapper;\n \n-use ast::Name;\n-\n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n-pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = cm.with_expn_info(sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n-    let call_site2 = cm.with_expn_info(enclosing_sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n+    let call_site1 = sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n+    let call_site2 = enclosing_sp.ctxt.outer().expn_info().map(|ei| ei.call_site);\n     match (call_site1, call_site2) {\n         (None, _) => sp,\n         (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n-        (Some(call_site1), _) => original_sp(cm, call_site1, enclosing_sp),\n+        (Some(call_site1), _) => original_sp(call_site1, enclosing_sp),\n     }\n }\n \n-/// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n-pub enum ExpnFormat {\n-    /// e.g. #[derive(...)] <item>\n-    MacroAttribute(Name),\n-    /// e.g. `format!()`\n-    MacroBang(Name),\n-    /// Desugaring done by the compiler during HIR lowering.\n-    CompilerDesugaring(Name)\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n }\n \n-pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n-    respan(mk_sp(lo, hi), t)\n-}\n-\n pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n     Spanned {node: t, span: sp}\n }\n@@ -73,47 +57,6 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n     respan(DUMMY_SP, t)\n }\n \n-#[derive(Clone, Hash, Debug)]\n-pub struct NameAndSpan {\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n-    /// Whether the macro is allowed to use #[unstable]/feature-gated\n-    /// features internally without forcing the whole crate to opt-in\n-    /// to them.\n-    pub allow_internal_unstable: bool,\n-    /// The span of the macro definition itself. The macro may not\n-    /// have a sensible definition span (e.g. something defined\n-    /// completely inside libsyntax) in which case this is None.\n-    pub span: Option<Span>\n-}\n-\n-impl NameAndSpan {\n-    pub fn name(&self) -> Name {\n-        match self.format {\n-            ExpnFormat::MacroAttribute(s) |\n-            ExpnFormat::MacroBang(s) |\n-            ExpnFormat::CompilerDesugaring(s) => s,\n-        }\n-    }\n-}\n-\n-/// Extra information for tracking spans of macro and syntax sugar expansion\n-#[derive(Hash, Debug)]\n-pub struct ExpnInfo {\n-    /// The location of the actual macro invocation or syntax sugar , e.g.\n-    /// `let x = foo!();` or `if let Some(y) = x {}`\n-    ///\n-    /// This may recursively refer to other macro invocations, e.g. if\n-    /// `foo!()` invoked `bar!()` internally, and there was an\n-    /// expression inside `bar!`; the call_site of the expression in\n-    /// the expansion would point to the `bar!` invocation; that\n-    /// call_site span would have its own ExpnInfo, with the call_site\n-    /// pointing to the `foo!` invocation.\n-    pub call_site: Span,\n-    /// Information about the expansion.\n-    pub callee: NameAndSpan\n-}\n-\n // _____________________________________________________________________________\n // FileMap, MultiByteChar, FileName, FileLines\n //\n@@ -161,23 +104,20 @@ impl FileLoader for RealFileLoader {\n \n pub struct CodeMap {\n     pub files: RefCell<Vec<Rc<FileMap>>>,\n-    expansions: RefCell<Vec<ExpnInfo>>,\n     file_loader: Box<FileLoader>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            expansions: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader)\n         }\n     }\n \n     pub fn with_file_loader(file_loader: Box<FileLoader>) -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n-            expansions: RefCell::new(Vec::new()),\n             file_loader: file_loader\n         }\n     }\n@@ -353,14 +293,14 @@ impl CodeMap {\n     /// Returns `Some(span)`, a union of the lhs and rhs span.  The lhs must precede the rhs. If\n     /// there are gaps between lhs and rhs, the resulting union will cross these gaps.\n     /// For this to work, the spans have to be:\n-    ///    * the expn_id of both spans much match\n+    ///    * the ctxt of both spans much match\n     ///    * the lhs span needs to end on the same line the rhs span begins\n     ///    * the lhs span must start at or before the rhs span\n     pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n         use std::cmp;\n \n         // make sure we're at the same expansion id\n-        if sp_lhs.expn_id != sp_rhs.expn_id {\n+        if sp_lhs.ctxt != sp_rhs.ctxt {\n             return None;\n         }\n \n@@ -383,18 +323,14 @@ impl CodeMap {\n             Some(Span {\n                 lo: cmp::min(sp_lhs.lo, sp_rhs.lo),\n                 hi: cmp::max(sp_lhs.hi, sp_rhs.hi),\n-                expn_id: sp_lhs.expn_id,\n+                ctxt: sp_lhs.ctxt,\n             })\n         } else {\n             None\n         }\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if sp == COMMAND_LINE_SP {\n-            return \"<command line option>\".to_string();\n-        }\n-\n         if self.files.borrow().is_empty() && sp.source_equal(&DUMMY_SP) {\n             return \"no-location\".to_string();\n         }\n@@ -409,157 +345,6 @@ impl CodeMap {\n                         hi.col.to_usize() + 1)).to_string()\n     }\n \n-    // Returns true if two spans have the same callee\n-    // (Assumes the same ExpnFormat implies same callee)\n-    fn match_callees(&self, sp_a: &Span, sp_b: &Span) -> bool {\n-        let fmt_a = self\n-            .with_expn_info(sp_a.expn_id,\n-                            |ei| ei.map(|ei| ei.callee.format.clone()));\n-\n-        let fmt_b = self\n-            .with_expn_info(sp_b.expn_id,\n-                            |ei| ei.map(|ei| ei.callee.format.clone()));\n-        fmt_a == fmt_b\n-    }\n-\n-    /// Returns a formatted string showing the expansion chain of a span\n-    ///\n-    /// Spans are printed in the following format:\n-    ///\n-    /// filename:start_line:col: end_line:col\n-    /// snippet\n-    ///   Callee:\n-    ///   Callee span\n-    ///   Callsite:\n-    ///   Callsite span\n-    ///\n-    /// Callees and callsites are printed recursively (if available, otherwise header\n-    /// and span is omitted), expanding into their own callee/callsite spans.\n-    /// Each layer of recursion has an increased indent, and snippets are truncated\n-    /// to at most 50 characters. Finally, recursive calls to the same macro are squashed,\n-    /// with '...' used to represent any number of recursive calls.\n-    pub fn span_to_expanded_string(&self, sp: Span) -> String {\n-        self.span_to_expanded_string_internal(sp, \"\")\n-    }\n-\n-    fn span_to_expanded_string_internal(&self, sp:Span, indent: &str) -> String {\n-        let mut indent = indent.to_owned();\n-        let mut output = \"\".to_owned();\n-        let span_str = self.span_to_string(sp);\n-        let mut span_snip = self.span_to_snippet(sp)\n-            .unwrap_or(\"Snippet unavailable\".to_owned());\n-\n-        // Truncate by code points - in worst case this will be more than 50 characters,\n-        // but ensures at least 50 characters and respects byte boundaries.\n-        let char_vec: Vec<(usize, char)> = span_snip.char_indices().collect();\n-        if char_vec.len() > 50 {\n-            span_snip.truncate(char_vec[49].0);\n-            span_snip.push_str(\"...\");\n-        }\n-\n-        output.push_str(&format!(\"{}{}\\n{}`{}`\\n\", indent, span_str, indent, span_snip));\n-\n-        if sp.expn_id == NO_EXPANSION || sp.expn_id == COMMAND_LINE_EXPN {\n-            return output;\n-        }\n-\n-        let mut callee = self.with_expn_info(sp.expn_id,\n-                                             |ei| ei.and_then(|ei| ei.callee.span.clone()));\n-        let mut callsite = self.with_expn_info(sp.expn_id,\n-                                               |ei| ei.map(|ei| ei.call_site.clone()));\n-\n-        indent.push_str(\"  \");\n-        let mut is_recursive = false;\n-\n-        while callee.is_some() && self.match_callees(&sp, &callee.unwrap()) {\n-            callee = self.with_expn_info(callee.unwrap().expn_id,\n-                                         |ei| ei.and_then(|ei| ei.callee.span.clone()));\n-            is_recursive = true;\n-        }\n-        if let Some(span) = callee {\n-            output.push_str(&indent);\n-            output.push_str(\"Callee:\\n\");\n-            if is_recursive {\n-                output.push_str(&indent);\n-                output.push_str(\"...\\n\");\n-            }\n-            output.push_str(&(self.span_to_expanded_string_internal(span, &indent)));\n-        }\n-\n-        is_recursive = false;\n-        while callsite.is_some() && self.match_callees(&sp, &callsite.unwrap()) {\n-            callsite = self.with_expn_info(callsite.unwrap().expn_id,\n-                                           |ei| ei.map(|ei| ei.call_site.clone()));\n-            is_recursive = true;\n-        }\n-        if let Some(span) = callsite {\n-            output.push_str(&indent);\n-            output.push_str(\"Callsite:\\n\");\n-            if is_recursive {\n-                output.push_str(&indent);\n-                output.push_str(\"...\\n\");\n-            }\n-            output.push_str(&(self.span_to_expanded_string_internal(span, &indent)));\n-        }\n-        output\n-    }\n-\n-    /// Return the source span - this is either the supplied span, or the span for\n-    /// the macro callsite that expanded to it.\n-    pub fn source_callsite(&self, sp: Span) -> Span {\n-        let mut span = sp;\n-        // Special case - if a macro is parsed as an argument to another macro, the source\n-        // callsite is the first callsite, which is also source-equivalent to the span.\n-        let mut first = true;\n-        while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n-            if let Some(callsite) = self.with_expn_info(span.expn_id,\n-                                               |ei| ei.map(|ei| ei.call_site.clone())) {\n-                if first && span.source_equal(&callsite) {\n-                    if self.lookup_char_pos(span.lo).file.is_real_file() {\n-                        return Span { expn_id: NO_EXPANSION, .. span };\n-                    }\n-                }\n-                first = false;\n-                span = callsite;\n-            }\n-            else {\n-                break;\n-            }\n-        }\n-        span\n-    }\n-\n-    /// Return the source callee.\n-    ///\n-    /// Returns None if the supplied span has no expansion trace,\n-    /// else returns the NameAndSpan for the macro definition\n-    /// corresponding to the source callsite.\n-    pub fn source_callee(&self, sp: Span) -> Option<NameAndSpan> {\n-        let mut span = sp;\n-        // Special case - if a macro is parsed as an argument to another macro, the source\n-        // callsite is source-equivalent to the span, and the source callee is the first callee.\n-        let mut first = true;\n-        while let Some(callsite) = self.with_expn_info(span.expn_id,\n-                                            |ei| ei.map(|ei| ei.call_site.clone())) {\n-            if first && span.source_equal(&callsite) {\n-                if self.lookup_char_pos(span.lo).file.is_real_file() {\n-                    return self.with_expn_info(span.expn_id,\n-                                               |ei| ei.map(|ei| ei.callee.clone()));\n-                }\n-            }\n-            first = false;\n-            if let Some(_) = self.with_expn_info(callsite.expn_id,\n-                                                 |ei| ei.map(|ei| ei.call_site.clone())) {\n-                span = callsite;\n-            }\n-            else {\n-                return self.with_expn_info(span.expn_id,\n-                                           |ei| ei.map(|ei| ei.callee.clone()));\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n@@ -723,111 +508,9 @@ impl CodeMap {\n         return a;\n     }\n \n-    pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n-        let mut expansions = self.expansions.borrow_mut();\n-        expansions.push(expn_info);\n-        let len = expansions.len();\n-        if len > u32::max_value() as usize {\n-            panic!(\"too many ExpnInfo's!\");\n-        }\n-        ExpnId(len as u32 - 1)\n-    }\n-\n-    pub fn with_expn_info<T, F>(&self, id: ExpnId, f: F) -> T where\n-        F: FnOnce(Option<&ExpnInfo>) -> T,\n-    {\n-        match id {\n-            NO_EXPANSION | COMMAND_LINE_EXPN => f(None),\n-            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as usize]))\n-        }\n-    }\n-\n-    /// Check if a span is \"internal\" to a macro in which #[unstable]\n-    /// items can be used (that is, a macro marked with\n-    /// `#[allow_internal_unstable]`).\n-    pub fn span_allows_unstable(&self, span: Span) -> bool {\n-        debug!(\"span_allows_unstable(span = {:?})\", span);\n-        let mut allows_unstable = false;\n-        let mut expn_id = span.expn_id;\n-        loop {\n-            let quit = self.with_expn_info(expn_id, |expninfo| {\n-                debug!(\"span_allows_unstable: expninfo = {:?}\", expninfo);\n-                expninfo.map_or(/* hit the top level */ true, |info| {\n-\n-                    let span_comes_from_this_expansion =\n-                        info.callee.span.map_or(span.source_equal(&info.call_site), |mac_span| {\n-                            mac_span.contains(span)\n-                        });\n-\n-                    debug!(\"span_allows_unstable: span: {:?} call_site: {:?} callee: {:?}\",\n-                           (span.lo, span.hi),\n-                           (info.call_site.lo, info.call_site.hi),\n-                           info.callee.span.map(|x| (x.lo, x.hi)));\n-                    debug!(\"span_allows_unstable: from this expansion? {}, allows unstable? {}\",\n-                           span_comes_from_this_expansion,\n-                           info.callee.allow_internal_unstable);\n-                    if span_comes_from_this_expansion {\n-                        allows_unstable = info.callee.allow_internal_unstable;\n-                        // we've found the right place, stop looking\n-                        true\n-                    } else {\n-                        // not the right place, keep looking\n-                        expn_id = info.call_site.expn_id;\n-                        false\n-                    }\n-                })\n-            });\n-            if quit {\n-                break\n-            }\n-        }\n-        debug!(\"span_allows_unstable? {}\", allows_unstable);\n-        allows_unstable\n-    }\n-\n     pub fn count_lines(&self) -> usize {\n         self.files.borrow().iter().fold(0, |a, f| a + f.count_lines())\n     }\n-\n-    pub fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n-        let mut prev_span = DUMMY_SP;\n-        let mut span = span;\n-        let mut result = vec![];\n-        loop {\n-            let span_name_span = self.with_expn_info(span.expn_id, |expn_info| {\n-                expn_info.map(|ei| {\n-                    let (pre, post) = match ei.callee.format {\n-                        MacroAttribute(..) => (\"#[\", \"]\"),\n-                        MacroBang(..) => (\"\", \"!\"),\n-                        CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n-                    };\n-                    let macro_decl_name = format!(\"{}{}{}\",\n-                                                  pre,\n-                                                  ei.callee.name(),\n-                                                  post);\n-                    let def_site_span = ei.callee.span;\n-                    (ei.call_site, macro_decl_name, def_site_span)\n-                })\n-            });\n-\n-            match span_name_span {\n-                None => break,\n-                Some((call_site, macro_decl_name, def_site_span)) => {\n-                    // Don't print recursive invocations\n-                    if !call_site.source_equal(&prev_span) {\n-                        result.push(MacroBacktrace {\n-                            call_site: call_site,\n-                            macro_decl_name: macro_decl_name,\n-                            def_site_span: def_site_span,\n-                        });\n-                    }\n-                    prev_span = span;\n-                    span = call_site;\n-                }\n-            }\n-        }\n-        result\n-    }\n }\n \n impl CodeMapper for CodeMap {\n@@ -843,9 +526,6 @@ impl CodeMapper for CodeMap {\n     fn span_to_filename(&self, sp: Span) -> FileName {\n         self.span_to_filename(sp)\n     }\n-    fn macro_backtrace(&self, span: Span) -> Vec<MacroBacktrace> {\n-        self.macro_backtrace(span)\n-    }\n     fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n         self.merge_spans(sp_lhs, sp_rhs)\n     }\n@@ -858,7 +538,6 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use symbol::keywords;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1007,7 +686,7 @@ mod tests {\n     fn t7() {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n@@ -1023,7 +702,7 @@ mod tests {\n         assert_eq!(input.len(), selection.len());\n         let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), ctxt: NO_EXPANSION }\n     }\n \n     /// Test span_to_snippet and span_to_lines for a span coverting 3\n@@ -1053,7 +732,7 @@ mod tests {\n     fn t8() {\n         // Test span_to_snippet for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n         assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -1063,65 +742,12 @@ mod tests {\n     fn t9() {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), ctxt: NO_EXPANSION};\n         let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n     }\n \n-    #[test]\n-    fn t10() {\n-        // Test span_to_expanded_string works in base case (no expansion)\n-        let cm = init_code_map();\n-        let span = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-        let sstr = cm.span_to_expanded_string(span);\n-        assert_eq!(sstr, \"blork.rs:1:1: 1:12\\n`first line.`\\n\");\n-\n-        let span = Span { lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION };\n-        let sstr =  cm.span_to_expanded_string(span);\n-        assert_eq!(sstr, \"blork.rs:2:1: 2:12\\n`second line`\\n\");\n-    }\n-\n-    #[test]\n-    fn t11() {\n-        // Test span_to_expanded_string works with expansion\n-        let cm = init_code_map();\n-        let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-        let format = ExpnFormat::MacroBang(keywords::Invalid.name());\n-        let callee = NameAndSpan { format: format,\n-                                   allow_internal_unstable: false,\n-                                   span: None };\n-\n-        let info = ExpnInfo { call_site: root, callee: callee };\n-        let id = cm.record_expansion(info);\n-        let sp = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id };\n-\n-        let sstr = cm.span_to_expanded_string(sp);\n-        assert_eq!(sstr,\n-                   \"blork.rs:2:1: 2:12\\n`second line`\\n  Callsite:\\n  \\\n-                    blork.rs:1:1: 1:12\\n  `first line.`\\n\");\n-    }\n-\n-    /// Test merging two spans on the same line\n-    #[test]\n-    fn span_merging() {\n-        let cm = CodeMap::new();\n-        let inputtext  = \"bbbb BB bb CCC\\n\";\n-        let selection1 = \"     ~~       \\n\";\n-        let selection2 = \"           ~~~\\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", None, inputtext);\n-        let span1 = span_from_selection(inputtext, selection1);\n-        let span2 = span_from_selection(inputtext, selection2);\n-\n-        if let Some(sp) = cm.merge_spans(span1, span2) {\n-            let sstr = cm.span_to_expanded_string(sp);\n-            assert_eq!(sstr, \"blork.rs:1:6: 1:15\\n`BB bb CCC`\\n\");\n-        }\n-        else {\n-            assert!(false);\n-        }\n-    }\n-\n     /// Test failing to merge two spans on different lines\n     #[test]\n     fn span_merging_fail() {\n@@ -1170,7 +796,7 @@ mod tests {\n                     let span = Span {\n                         lo: BytePos(lo as u32 + file.start_pos.0),\n                         hi: BytePos(hi as u32 + file.start_pos.0),\n-                        expn_id: NO_EXPANSION,\n+                        ctxt: NO_EXPANSION,\n                     };\n                     assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                             substring);\n@@ -1180,82 +806,4 @@ mod tests {\n             }\n         }\n     }\n-\n-    fn init_expansion_chain(cm: &CodeMap) -> Span {\n-        // Creates an expansion chain containing two recursive calls\n-        // root -> expA -> expA -> expB -> expB -> end\n-        let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-\n-        let format_root = ExpnFormat::MacroBang(keywords::Invalid.name());\n-        let callee_root = NameAndSpan { format: format_root,\n-                                        allow_internal_unstable: false,\n-                                        span: Some(root) };\n-\n-        let info_a1 = ExpnInfo { call_site: root, callee: callee_root };\n-        let id_a1 = cm.record_expansion(info_a1);\n-        let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n-\n-        let format_a = ExpnFormat::MacroBang(keywords::As.name());\n-        let callee_a = NameAndSpan { format: format_a,\n-                                      allow_internal_unstable: false,\n-                                      span: Some(span_a1) };\n-\n-        let info_a2 = ExpnInfo { call_site: span_a1, callee: callee_a.clone() };\n-        let id_a2 = cm.record_expansion(info_a2);\n-        let span_a2 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a2 };\n-\n-        let info_b1 = ExpnInfo { call_site: span_a2, callee: callee_a };\n-        let id_b1 = cm.record_expansion(info_b1);\n-        let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n-\n-        let format_b = ExpnFormat::MacroBang(keywords::Box.name());\n-        let callee_b = NameAndSpan { format: format_b,\n-                                     allow_internal_unstable: false,\n-                                     span: None };\n-\n-        let info_b2 = ExpnInfo { call_site: span_b1, callee: callee_b.clone() };\n-        let id_b2 = cm.record_expansion(info_b2);\n-        let span_b2 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b2 };\n-\n-        let info_end = ExpnInfo { call_site: span_b2, callee: callee_b };\n-        let id_end = cm.record_expansion(info_end);\n-        Span { lo: BytePos(37), hi: BytePos(48), expn_id: id_end }\n-    }\n-\n-    #[test]\n-    fn t12() {\n-        // Test span_to_expanded_string collapses recursive macros and handles\n-        // recursive callsite and callee expansions\n-        let cm = init_code_map();\n-        let end = init_expansion_chain(&cm);\n-        let sstr = cm.span_to_expanded_string(end);\n-        let res_str =\n-r\"blork2.rs:2:1: 2:12\n-`second line`\n-  Callsite:\n-  ...\n-  blork2.rs:1:1: 1:12\n-  `first line.`\n-    Callee:\n-    blork.rs:2:1: 2:12\n-    `second line`\n-      Callee:\n-      blork.rs:1:1: 1:12\n-      `first line.`\n-      Callsite:\n-      blork.rs:1:1: 1:12\n-      `first line.`\n-    Callsite:\n-    ...\n-    blork.rs:2:1: 2:12\n-    `second line`\n-      Callee:\n-      blork.rs:1:1: 1:12\n-      `first line.`\n-      Callsite:\n-      blork.rs:1:1: 1:12\n-      `first line.`\n-\";\n-        assert_eq!(sstr, res_str);\n-    }\n }"}, {"sha": "fda026fec64ef3d1ebf3e7da501c5aa98b42bd0f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -12,11 +12,11 @@ pub use self::SyntaxExtension::{MultiDecorator, MultiModifier, NormalTT, IdentTT\n \n use ast::{self, Attribute, Name, PatKind, MetaItem};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n-use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n-use errors::{DiagnosticBuilder, FatalError};\n+use codemap::{self, CodeMap, Spanned, respan};\n+use syntax_pos::{Span, DUMMY_SP};\n+use errors::DiagnosticBuilder;\n use ext::expand::{self, Expansion, Invocation};\n-use ext::hygiene::Mark;\n+use ext::hygiene::{Mark, SyntaxContext};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n@@ -56,6 +56,14 @@ impl HasAttrs for Annotatable {\n }\n \n impl Annotatable {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            Annotatable::Item(ref item) => item.span,\n+            Annotatable::TraitItem(ref trait_item) => trait_item.span,\n+            Annotatable::ImplItem(ref impl_item) => impl_item.span,\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -201,7 +209,26 @@ impl<F> TTMacroExpander for F\n {\n     fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)\n                    -> Box<MacResult+'cx> {\n-        (*self)(ecx, span, &input.trees().collect::<Vec<_>>())\n+        struct AvoidInterpolatedIdents;\n+\n+        impl Folder for AvoidInterpolatedIdents {\n+            fn fold_tt(&mut self, tt: tokenstream::TokenTree) -> tokenstream::TokenTree {\n+                if let tokenstream::TokenTree::Token(_, token::Interpolated(ref nt)) = tt {\n+                    if let token::NtIdent(ident) = **nt {\n+                        return tokenstream::TokenTree::Token(ident.span, token::Ident(ident.node));\n+                    }\n+                }\n+                fold::noop_fold_tt(tt, self)\n+            }\n+\n+            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+                fold::noop_fold_mac(mac, self)\n+            }\n+        }\n+\n+        let input: Vec<_> =\n+            input.trees().map(|tt| AvoidInterpolatedIdents.fold_tt(tt)).collect();\n+        (*self)(ecx, span, &input)\n     }\n }\n \n@@ -602,7 +629,6 @@ pub struct ModuleData {\n pub struct ExpansionData {\n     pub mark: Mark,\n     pub depth: usize,\n-    pub backtrace: ExpnId,\n     pub module: Rc<ModuleData>,\n     pub directory_ownership: DirectoryOwnership,\n }\n@@ -633,7 +659,6 @@ impl<'a> ExtCtxt<'a> {\n             current_expansion: ExpansionData {\n                 mark: Mark::root(),\n                 depth: 0,\n-                backtrace: NO_EXPANSION,\n                 module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n                 directory_ownership: DirectoryOwnership::Owned,\n             },\n@@ -658,59 +683,37 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n+        match self.current_expansion.mark.expn_info() {\n             Some(expn_info) => expn_info.call_site,\n-            None => self.bug(\"missing top span\")\n-        })\n+            None => DUMMY_SP,\n+        }\n+    }\n+    pub fn backtrace(&self) -> SyntaxContext {\n+        SyntaxContext::empty().apply_mark(self.current_expansion.mark)\n     }\n-    pub fn backtrace(&self) -> ExpnId { self.current_expansion.backtrace }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Span {\n-        let mut expn_id = self.backtrace();\n+        let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if self.codemap().with_expn_info(expn_id, |info| {\n-                info.map_or(None, |i| {\n-                    if i.callee.name() == \"include\" {\n-                        // Stop going up the backtrace once include! is encountered\n-                        return None;\n-                    }\n-                    expn_id = i.call_site.expn_id;\n-                    last_macro = Some(i.call_site);\n-                    return Some(());\n-                })\n+            if ctxt.outer().expn_info().map_or(None, |info| {\n+                if info.callee.name() == \"include\" {\n+                    // Stop going up the backtrace once include! is encountered\n+                    return None;\n+                }\n+                ctxt = info.call_site.ctxt;\n+                last_macro = Some(info.call_site);\n+                return Some(());\n             }).is_none() {\n                 break\n             }\n         }\n         last_macro.expect(\"missing expansion backtrace\")\n     }\n \n-    pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        if self.current_expansion.depth > self.ecfg.recursion_limit {\n-            let suggested_limit = self.ecfg.recursion_limit * 2;\n-            let mut err = self.struct_span_fatal(ei.call_site,\n-                &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         ei.callee.name()));\n-            err.help(&format!(\n-                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                suggested_limit));\n-            err.emit();\n-            panic!(FatalError);\n-        }\n-\n-        let mut call_site = ei.call_site;\n-        call_site.expn_id = self.backtrace();\n-        self.current_expansion.backtrace = self.codemap().record_expansion(ExpnInfo {\n-            call_site: call_site,\n-            callee: ei.callee\n-        });\n-    }\n-    pub fn bt_pop(&mut self) {}\n-\n     pub fn struct_span_warn(&self,\n                             sp: Span,\n                             msg: &str)\n@@ -792,9 +795,9 @@ impl<'a> ExtCtxt<'a> {\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n                               -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n-    // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n+    // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.expn_id = cx.backtrace();\n+        expr.span.ctxt = expr.span.ctxt.apply_mark(cx.current_expansion.mark);\n         expr\n     });\n "}, {"sha": "c79040424f619e0c4c8a745f3fae66138d235408", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use attr::HasAttrs;\n-use {ast, codemap};\n+use ast;\n+use codemap::{ExpnInfo, NameAndSpan, ExpnFormat};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use parse::parser::PathStyle;\n use symbol::Symbol;\n use syntax_pos::Span;\n \n+use std::collections::HashSet;\n+\n pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {\n@@ -41,36 +44,35 @@ pub fn collect_derives(cx: &mut ExtCtxt, attrs: &mut Vec<ast::Attribute>) -> Vec\n     result\n }\n \n-fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n-    Span {\n-        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: span,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n-                span: Some(span),\n-                allow_internal_unstable: true,\n-            },\n-        }),\n-        ..span\n+pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path], item: T) -> T\n+    where T: HasAttrs,\n+{\n+    let (mut names, mut pretty_name) = (HashSet::new(), \"derive(\".to_owned());\n+    for (i, path) in traits.iter().enumerate() {\n+        if i > 0 {\n+            pretty_name.push_str(\", \");\n+        }\n+        pretty_name.push_str(&path.to_string());\n+        names.insert(unwrap_or!(path.segments.get(0), continue).identifier.name);\n     }\n-}\n+    pretty_name.push(')');\n \n-pub fn add_derived_markers<T: HasAttrs>(cx: &mut ExtCtxt, traits: &[ast::Path], item: T) -> T {\n-    let span = match traits.get(0) {\n-        Some(path) => path.span,\n-        None => return item,\n-    };\n+    cx.current_expansion.mark.set_expn_info(ExpnInfo {\n+        call_site: span,\n+        callee: NameAndSpan {\n+            format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n+            span: None,\n+            allow_internal_unstable: true,\n+        },\n+    });\n \n+    let span = Span { ctxt: cx.backtrace(), ..span };\n     item.map_attrs(|mut attrs| {\n-        if traits.iter().any(|path| *path == \"PartialEq\") &&\n-           traits.iter().any(|path| *path == \"Eq\") {\n-            let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n+        if names.contains(&Symbol::intern(\"Eq\")) && names.contains(&Symbol::intern(\"PartialEq\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"structural_match\"));\n             attrs.push(cx.attribute(span, meta));\n         }\n-        if traits.iter().any(|path| *path == \"Copy\") &&\n-           traits.iter().any(|path| *path == \"Clone\") {\n-            let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n+        if names.contains(&Symbol::intern(\"Copy\")) && names.contains(&Symbol::intern(\"Clone\")) {\n             let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n             attrs.push(cx.attribute(span, meta));\n         }"}, {"sha": "1b3352f73ade794e9ee9da45730a72f5df9475b8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 49, "deletions": 68, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{self, Block, Ident, PatKind, Path};\n+use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use config::{is_test_or_bench, StripUnconfigured};\n+use errors::FatalError;\n use ext::base::*;\n use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::Mark;\n@@ -27,7 +28,7 @@ use ptr::P;\n use std_inject;\n use symbol::Symbol;\n use symbol::keywords;\n-use syntax_pos::{Span, ExpnId, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::TokenStream;\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -273,7 +274,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let item = item\n                         .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n                     let item_with_markers =\n-                        add_derived_markers(&mut self.cx, &traits, item.clone());\n+                        add_derived_markers(&mut self.cx, item.span(), &traits, item.clone());\n                     let derives = derives.entry(invoc.expansion_data.mark).or_insert_with(Vec::new);\n \n                     for path in &traits {\n@@ -321,7 +322,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(mark.as_placeholder_id(), expansion, derives);\n+                placeholder_expander.add(NodeId::placeholder_from_mark(mark), expansion, derives);\n             }\n         }\n \n@@ -363,11 +364,26 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n-        match invoc.kind {\n+        let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n             InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n             InvocationKind::Derive { .. } => self.expand_derive_invoc(invoc, ext),\n+        };\n+\n+        if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n+            let info = self.cx.current_expansion.mark.expn_info().unwrap();\n+            let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n+            let mut err = self.cx.struct_span_fatal(info.call_site,\n+                &format!(\"recursion limit reached while expanding the macro `{}`\",\n+                         info.callee.name()));\n+            err.help(&format!(\n+                \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                suggested_limit));\n+            err.emit();\n+            panic!(FatalError);\n         }\n+\n+        result\n     }\n \n     fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n@@ -378,11 +394,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        self.cx.bt_push(ExpnInfo {\n+        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n-                span: Some(attr.span),\n+                span: None,\n                 allow_internal_unstable: false,\n             }\n         });\n@@ -403,19 +419,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n                 let item_toks = stream_for_item(&item, &self.cx.parse_sess);\n \n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n-                            span: None,\n-                            allow_internal_unstable: false,\n-                        },\n-                    }),\n-                    ..attr.span\n-                };\n-\n-                let tok_result = mac.expand(self.cx, attr.span, attr.tokens.clone(), item_toks);\n+                let span = Span { ctxt: self.cx.backtrace(), ..attr.span };\n+                let tok_result = mac.expand(self.cx, attr.span, attr.tokens, item_toks);\n                 self.parse_expansion(tok_result, kind, &attr.path, span)\n             }\n             SyntaxExtension::ProcMacroDerive(..) | SyntaxExtension::BuiltinDerive(..) => {\n@@ -440,8 +445,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n-        let marked_tts =\n-            noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n+        let marked_tts = noop_fold_tts(mac.node.stream(), &mut Marker(mark));\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -451,7 +455,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 }\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -470,7 +474,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 };\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -502,7 +506,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     return kind.dummy(span);\n                 }\n \n-                self.cx.bt_push(ExpnInfo {\n+                invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n@@ -528,10 +532,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return kind.dummy(span);\n         };\n \n-        expanded.fold_with(&mut Marker {\n-            mark: mark,\n-            expn_id: Some(self.cx.backtrace()),\n-        })\n+        expanded.fold_with(&mut Marker(mark))\n     }\n \n     /// Expand a derive invocation. Returns the result of expansion.\n@@ -550,50 +551,33 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n         };\n \n-        self.cx.bt_push(ExpnInfo {\n+        let mut expn_info = ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n                 format: MacroAttribute(pretty_name),\n                 span: None,\n                 allow_internal_unstable: false,\n             }\n-        });\n+        };\n \n         match *ext {\n             SyntaxExtension::ProcMacroDerive(ref ext, _) => {\n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(pretty_name),\n-                            span: None,\n-                            allow_internal_unstable: false,\n-                        },\n-                    }),\n-                    ..span\n-                };\n+                invoc.expansion_data.mark.set_expn_info(expn_info);\n+                let span = Span { ctxt: self.cx.backtrace(), ..span };\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n                     name: keywords::Invalid.name(),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n-                return kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item));\n+                kind.expect_from_annotatables(ext.expand(self.cx, span, &dummy, item))\n             }\n             SyntaxExtension::BuiltinDerive(func) => {\n-                let span = Span {\n-                    expn_id: self.cx.codemap().record_expansion(ExpnInfo {\n-                        call_site: span,\n-                        callee: NameAndSpan {\n-                            format: MacroAttribute(pretty_name),\n-                            span: None,\n-                            allow_internal_unstable: true,\n-                        },\n-                    }),\n-                    ..span\n-                };\n+                expn_info.callee.allow_internal_unstable = true;\n+                invoc.expansion_data.mark.set_expn_info(expn_info);\n+                let span = Span { ctxt: self.cx.backtrace(), ..span };\n                 let mut items = Vec::new();\n                 func(self.cx, span, &attr.meta().unwrap(), &item, &mut |a| items.push(a));\n-                return kind.expect_from_annotatables(items);\n+                kind.expect_from_annotatables(items)\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n@@ -703,7 +687,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(expansion_kind, mark.as_placeholder_id())\n+        placeholder(expansion_kind, NodeId::placeholder_from_mark(mark))\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion {\n@@ -753,10 +737,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     // Detect use of feature-gated or invalid attributes on macro invocations\n     // since they will not be detected after macro expansion.\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n-        let codemap = &self.cx.parse_sess.codemap();\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess, codemap, features);\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess, features);\n         }\n     }\n }\n@@ -1065,23 +1048,21 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n }\n \n-// A Marker adds the given mark to the syntax context and\n-// sets spans' `expn_id` to the given expn_id (unless it is `None`).\n-struct Marker { mark: Mark, expn_id: Option<ExpnId> }\n+// A Marker adds the given mark to the syntax context.\n+struct Marker(Mark);\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, mut ident: Ident) -> Ident {\n-        ident.ctxt = ident.ctxt.apply_mark(self.mark);\n+        ident.ctxt = ident.ctxt.apply_mark(self.0);\n         ident\n     }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        noop_fold_mac(mac, self)\n-    }\n \n     fn new_span(&mut self, mut span: Span) -> Span {\n-        if let Some(expn_id) = self.expn_id {\n-            span.expn_id = expn_id;\n-        }\n+        span.ctxt = span.ctxt.apply_mark(self.0);\n         span\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        noop_fold_mac(mac, self)\n+    }\n }"}, {"sha": "4fb138d506a8e60eef95a4eba651584d3f88371c", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, NodeId};\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n@@ -88,7 +88,7 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         let mut expansion = expansion.fold_with(self);\n         if let Expansion::Items(mut items) = expansion {\n             for derive in derives {\n-                match self.remove(derive.as_placeholder_id()) {\n+                match self.remove(NodeId::placeholder_from_mark(derive)) {\n                     Expansion::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "0103d6ea959dd84dd93606d8a0d9203cab1dbaa8", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -185,7 +185,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute() {\n-        let callsite = cx.codemap().source_callsite(sp);\n+        let callsite = sp.source_callsite();\n         let mut cu = PathBuf::from(&cx.codemap().span_to_filename(callsite));\n         cu.pop();\n         cu.push(arg);"}, {"sha": "6cd1fea2e75e2ccf8749c0f0afcef19b9c4ab030", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -79,7 +79,7 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast::Ident;\n-use syntax_pos::{self, BytePos, mk_sp, Span};\n+use syntax_pos::{self, BytePos, Span};\n use codemap::Spanned;\n use errors::FatalError;\n use ext::tt::quoted::{self, TokenTree};\n@@ -285,7 +285,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                     eof_eis: &mut SmallVector<Box<MatcherPos>>,\n                     bb_eis: &mut SmallVector<Box<MatcherPos>>,\n                     token: &Token,\n-                    span: &syntax_pos::Span)\n+                    span: syntax_pos::Span)\n                     -> ParseResult<()> {\n     while let Some(mut ei) = cur_eis.pop() {\n         // When unzipped trees end, remove them\n@@ -323,8 +323,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                     for idx in ei.match_lo..ei.match_hi {\n                         let sub = ei.matches[idx].clone();\n                         new_pos.matches[idx]\n-                            .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n-                                                                span.hi))));\n+                            .push(Rc::new(MatchedSeq(sub, Span { lo: ei.sp_lo, ..span })));\n                     }\n \n                     new_pos.match_cur = ei.match_hi;\n@@ -426,7 +425,7 @@ pub fn parse(sess: &ParseSess, tts: TokenStream, ms: &[TokenTree], directory: Op\n         assert!(next_eis.is_empty());\n \n         match inner_parse_loop(sess, &mut cur_eis, &mut next_eis, &mut eof_eis, &mut bb_eis,\n-                               &parser.token, &parser.span) {\n+                               &parser.token, parser.span) {\n             Success(_) => {},\n             Failure(sp, tok) => return Failure(sp, tok),\n             Error(sp, msg) => return Error(sp, msg),\n@@ -493,7 +492,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         _ => {}\n     }\n     // check at the beginning and the parser checks after each bump\n-    p.check_unknown_macro_variable();\n+    p.process_potential_macro_variable();\n     match name {\n         \"item\" => match panictry!(p.parse_item()) {\n             Some(i) => token::NtItem(i),"}, {"sha": "93348c8f0837677faddbd7b437e17e63328536a4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -121,7 +121,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 p.root_module_name = cx.current_expansion.module.mod_path.last()\n                     .map(|id| id.name.as_str().to_string());\n \n-                p.check_unknown_macro_variable();\n+                p.process_potential_macro_variable();\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return Box::new(ParserAnyMacro {"}, {"sha": "d216effbd450812502d4a1c675cb933474f6ab9c", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -34,17 +34,19 @@ impl Delimited {\n     }\n \n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span },\n+        let open_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n \n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span },\n+        let close_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }\n@@ -134,11 +136,14 @@ pub fn parse(input: tokenstream::TokenStream, expect_matchers: bool, sess: &Pars\n             TokenTree::Token(start_sp, token::SubstNt(ident)) if expect_matchers => {\n                 let span = match trees.next() {\n                     Some(tokenstream::TokenTree::Token(span, token::Colon)) => match trees.next() {\n-                        Some(tokenstream::TokenTree::Token(end_sp, token::Ident(kind))) => {\n-                            let span = Span { lo: start_sp.lo, ..end_sp };\n-                            result.push(TokenTree::MetaVarDecl(span, ident, kind));\n-                            continue\n-                        }\n+                        Some(tokenstream::TokenTree::Token(end_sp, ref tok)) => match tok.ident() {\n+                            Some(kind) => {\n+                                let span = Span { lo: start_sp.lo, ..end_sp };\n+                                result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                continue\n+                            }\n+                            _ => end_sp,\n+                        },\n                         tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n                     },\n                     tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),"}, {"sha": "947089b0b9ac4b977686c26603f47b06664545f9", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -12,7 +12,7 @@ use ast::Ident;\n use errors::Handler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::quoted;\n-use parse::token::{self, SubstNt, Token, NtIdent, NtTT};\n+use parse::token::{self, SubstNt, Token, NtTT};\n use syntax_pos::{Span, DUMMY_SP};\n use tokenstream::{TokenStream, TokenTree, Delimited};\n use util::small_vector::SmallVector;\n@@ -154,13 +154,6 @@ pub fn transcribe(sp_diag: &Handler,\n                     None => result.push(TokenTree::Token(sp, SubstNt(ident)).into()),\n                     Some(cur_matched) => if let MatchedNonterminal(ref nt) = *cur_matched {\n                         match **nt {\n-                            // sidestep the interpolation tricks for ident because\n-                            // (a) idents can be in lots of places, so it'd be a pain\n-                            // (b) we actually can, since it's a token.\n-                            NtIdent(ref sn) => {\n-                                let token = TokenTree::Token(sn.span, token::Ident(sn.node));\n-                                result.push(token.into());\n-                            }\n                             NtTT(ref tt) => result.push(tt.clone().into()),\n                             _ => {\n                                 let token = TokenTree::Token(sp, token::Interpolated(nt.clone()));"}, {"sha": "12d25ca4274fea1fe09ef93cbcd49784b407b4ec", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -28,7 +28,7 @@ use self::AttributeGate::*;\n use abi::Abi;\n use ast::{self, NodeId, PatKind, RangeEnd};\n use attr;\n-use codemap::{CodeMap, Spanned};\n+use codemap::Spanned;\n use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n@@ -831,7 +831,7 @@ impl GatedCfg {\n \n     pub fn check_and_emit(&self, sess: &ParseSess, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n-        if !has_feature(features) && !sess.codemap().span_allows_unstable(self.span) {\n+        if !has_feature(features) && !self.span.allows_unstable() {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n             emit_feature_err(sess, feature, self.span, GateIssue::Language, &explain);\n         }\n@@ -841,7 +841,6 @@ impl GatedCfg {\n struct Context<'a> {\n     features: &'a Features,\n     parse_sess: &'a ParseSess,\n-    cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n \n@@ -850,7 +849,7 @@ macro_rules! gate_feature_fn {\n         let (cx, has_feature, span, name, explain) = ($cx, $has_feature, $span, $name, $explain);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n-        if !has_feature && !cx.cm.span_allows_unstable(span) {\n+        if !has_feature && !span.allows_unstable() {\n             emit_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain);\n         }\n     }}\n@@ -908,12 +907,8 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess,\n-                       cm: &CodeMap, features: &Features) {\n-    let cx = Context {\n-        features: features, parse_sess: parse_sess,\n-        cm: cm, plugin_attributes: &[]\n-    };\n+pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n+    let cx = Context { features: features, parse_sess: parse_sess, plugin_attributes: &[] };\n     cx.check_attribute(attr, true);\n }\n \n@@ -1016,7 +1011,7 @@ struct PostExpansionVisitor<'a> {\n macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n         let (cx, span) = ($cx, $span);\n-        if !cx.context.cm.span_allows_unstable(span) {\n+        if !span.allows_unstable() {\n             gate_feature!(cx.context, $feature, span, $explain)\n         }\n     }}\n@@ -1096,7 +1091,7 @@ fn starts_with_digit(s: &str) -> bool {\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if !self.context.cm.span_allows_unstable(attr.span) {\n+        if !attr.span.allows_unstable() {\n             // check for gated attributes\n             self.context.check_attribute(attr, false);\n         }\n@@ -1530,7 +1525,6 @@ pub fn check_crate(krate: &ast::Crate,\n     let ctx = Context {\n         features: features,\n         parse_sess: sess,\n-        cm: sess.codemap(),\n         plugin_attributes: plugin_attributes,\n     };\n     visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);"}, {"sha": "dec1b7d1d87be4bf09bcec60d3981061682ff962", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -202,7 +202,7 @@ impl DiagnosticSpan {\n         // backtrace ourselves, but the `macro_backtrace` helper makes\n         // some decision, such as dropping some frames, and I don't\n         // want to duplicate that logic here.\n-        let backtrace = je.cm.macro_backtrace(span).into_iter();\n+        let backtrace = span.macro_backtrace().into_iter();\n         DiagnosticSpan::from_span_full(span,\n                                        is_primary,\n                                        label,"}, {"sha": "86ee1c5336dfeb3f6a46038d524ac92c14cdd4e6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -125,7 +125,7 @@ pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n pub mod str;\n-pub mod symbol;\n+pub use syntax_pos::symbol;\n pub mod test;\n pub mod tokenstream;\n pub mod visit;\n@@ -136,12 +136,12 @@ pub mod print {\n }\n \n pub mod ext {\n+    pub use syntax_pos::hygiene;\n     pub mod base;\n     pub mod build;\n     pub mod derive;\n     pub mod expand;\n     pub mod placeholders;\n-    pub mod hygiene;\n     pub mod quote;\n     pub mod source_util;\n "}, {"sha": "92cec462ffb7cefbdd623490c125dab5a4e5f4bf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -10,8 +10,7 @@\n \n use attr;\n use ast;\n-use syntax_pos::{mk_sp, Span};\n-use codemap::spanned;\n+use codemap::respan;\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token::{self, Nonterminal};\n@@ -49,8 +48,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -94,7 +92,7 @@ impl<'a> Parser<'a> {\n                self.token);\n         let (span, path, tokens, mut style) = match self.token {\n             token::Pound => {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 self.bump();\n \n                 if inner_parse_policy == InnerAttributeParsePolicy::Permitted {\n@@ -122,9 +120,9 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let (path, tokens) = self.parse_path_and_tokens()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n-                (mk_sp(lo, hi), path, tokens, style)\n+                (lo.to(hi), path, tokens, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n@@ -189,8 +187,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n-                    let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n@@ -238,11 +235,10 @@ impl<'a> Parser<'a> {\n             return Ok(meta);\n         }\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let ident = self.parse_ident()?;\n         let node = self.parse_meta_item_kind()?;\n-        let hi = self.prev_span.hi;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: lo.to(self.prev_span) })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n@@ -258,26 +254,25 @@ impl<'a> Parser<'a> {\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        let sp = self.span;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => {\n-                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::Literal(lit)))\n+                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::Literal(lit)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n-                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n+                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::MetaItem(mi)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         let found = self.this_token_to_string();\n         let msg = format!(\"expected unsuffixed literal or identifier, found {}\", found);\n-        Err(self.diagnostic().struct_span_err(sp, &msg))\n+        Err(self.diagnostic().struct_span_err(lo, &msg))\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item_inner) )"}, {"sha": "920b2c401e2bd2914c6806ee1887675617059d32", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Ident};\n-use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n+use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n use codemap::CodeMap;\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n@@ -68,6 +68,10 @@ pub struct StringReader<'a> {\n     open_braces: Vec<(token::DelimToken, Span)>,\n }\n \n+fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n+    Span { lo: lo, hi: hi, ctxt: NO_EXPANSION }\n+}\n+\n impl<'a> StringReader<'a> {\n     fn next_token(&mut self) -> TokenAndSpan where Self: Sized {\n         let res = self.try_next_token();\n@@ -225,12 +229,12 @@ impl<'a> StringReader<'a> {\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n     fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n-        self.fatal_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n+        self.fatal_span(mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`).\n     fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.err_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n+        self.err_span(mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -254,7 +258,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.sess.span_diagnostic.struct_span_fatal(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n+        self.sess.span_diagnostic.struct_span_fatal(mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -278,7 +282,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.sess.span_diagnostic.struct_span_err(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n+        self.sess.span_diagnostic.struct_span_err(mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -302,11 +306,11 @@ impl<'a> StringReader<'a> {\n             None => {\n                 if self.is_eof() {\n                     self.peek_tok = token::Eof;\n-                    self.peek_span = syntax_pos::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n+                    self.peek_span = mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n                 } else {\n                     let start_bytepos = self.pos;\n                     self.peek_tok = self.next_token_inner()?;\n-                    self.peek_span = syntax_pos::mk_sp(start_bytepos, self.pos);\n+                    self.peek_span = mk_sp(start_bytepos, self.pos);\n                 };\n             }\n         }\n@@ -489,7 +493,7 @@ impl<'a> StringReader<'a> {\n         if let Some(c) = self.ch {\n             if c.is_whitespace() {\n                 let msg = \"called consume_any_line_comment, but there was whitespace\";\n-                self.sess.span_diagnostic.span_err(syntax_pos::mk_sp(self.pos, self.pos), msg);\n+                self.sess.span_diagnostic.span_err(mk_sp(self.pos, self.pos), msg);\n             }\n         }\n \n@@ -532,13 +536,13 @@ impl<'a> StringReader<'a> {\n \n                             Some(TokenAndSpan {\n                                 tok: tok,\n-                                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                                sp: mk_sp(start_bpos, self.pos),\n                             })\n                         })\n                     } else {\n                         Some(TokenAndSpan {\n                             tok: token::Comment,\n-                            sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                            sp: mk_sp(start_bpos, self.pos),\n                         })\n                     };\n                 }\n@@ -571,7 +575,7 @@ impl<'a> StringReader<'a> {\n                     }\n                     return Some(TokenAndSpan {\n                         tok: token::Shebang(self.name_from(start)),\n-                        sp: syntax_pos::mk_sp(start, self.pos),\n+                        sp: mk_sp(start, self.pos),\n                     });\n                 }\n             }\n@@ -599,7 +603,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 let c = Some(TokenAndSpan {\n                     tok: token::Whitespace,\n-                    sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                    sp: mk_sp(start_bpos, self.pos),\n                 });\n                 debug!(\"scanning whitespace: {:?}\", c);\n                 c\n@@ -661,7 +665,7 @@ impl<'a> StringReader<'a> {\n \n             Some(TokenAndSpan {\n                 tok: tok,\n-                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                sp: mk_sp(start_bpos, self.pos),\n             })\n         })\n     }\n@@ -858,7 +862,7 @@ impl<'a> StringReader<'a> {\n                                 let valid = if self.ch_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n-                                    let span = syntax_pos::mk_sp(start, self.pos);\n+                                    let span = mk_sp(start, self.pos);\n                                     self.sess.span_diagnostic\n                                         .struct_span_err(span, \"incorrect unicode escape sequence\")\n                                         .span_help(span,\n@@ -896,13 +900,13 @@ impl<'a> StringReader<'a> {\n                                                                         },\n                                                                         c);\n                                 if e == '\\r' {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n+                                    err.span_help(mk_sp(escaped_pos, pos),\n                                                   \"this is an isolated carriage return; consider \\\n                                                    checking your editor and version control \\\n                                                    settings\");\n                                 }\n                                 if (e == '{' || e == '}') && !ascii_only {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n+                                    err.span_help(mk_sp(escaped_pos, pos),\n                                                   \"if used in a formatting string, curly braces \\\n                                                    are escaped with `{{` and `}}`\");\n                                 }\n@@ -1735,7 +1739,7 @@ mod tests {\n             sp: Span {\n                 lo: BytePos(21),\n                 hi: BytePos(23),\n-                expn_id: NO_EXPANSION,\n+                ctxt: NO_EXPANSION,\n             },\n         };\n         assert_eq!(tok1, tok2);\n@@ -1749,7 +1753,7 @@ mod tests {\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n-                expn_id: NO_EXPANSION,\n+                ctxt: NO_EXPANSION,\n             },\n         };\n         assert_eq!(tok3, tok4);\n@@ -1908,7 +1912,7 @@ mod tests {\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n-        assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n+        assert_eq!((comment.sp.lo, comment.sp.hi), (BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n                    token::DocComment(Symbol::intern(\"/// test\")));"}, {"sha": "4df23da3c9ce3464bf1cb760352e5bd7df68b144", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -11,7 +11,7 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/revision-06/confusables.txt\n \n-use syntax_pos::mk_sp as make_span;\n+use syntax_pos::{Span, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use super::StringReader;\n \n@@ -234,7 +234,7 @@ pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n     .map(|&(_, u_name, ascii_char)| {\n-        let span = make_span(reader.pos, reader.next_pos);\n+        let span = Span { lo: reader.pos, hi: reader.next_pos, ctxt: NO_EXPANSION };\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n                 let msg ="}, {"sha": "c63a6524f7459e32e5154cbbb8278574f9715bbb", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -12,7 +12,7 @@\n \n use ast::{self, CrateConfig};\n use codemap::CodeMap;\n-use syntax_pos::{self, Span, FileMap};\n+use syntax_pos::{self, Span, FileMap, NO_EXPANSION};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -178,7 +178,7 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Par\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap));\n \n     if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n-        parser.span = syntax_pos::mk_sp(end_pos, end_pos);\n+        parser.span = Span { lo: end_pos, hi: end_pos, ctxt: NO_EXPANSION };\n     }\n \n     parser\n@@ -218,9 +218,7 @@ pub fn filemap_to_stream(sess: &ParseSess, filemap: Rc<FileMap>) -> TokenStream\n \n /// Given stream and the ParseSess, produce a parser\n pub fn stream_to_parser<'a>(sess: &'a ParseSess, stream: TokenStream) -> Parser<'a> {\n-    let mut p = Parser::new(sess, stream, None, false);\n-    p.check_unknown_macro_variable();\n-    p\n+    Parser::new(sess, stream, None, false)\n }\n \n /// Parse a string representing a character literal into its final form.\n@@ -665,7 +663,7 @@ mod tests {\n \n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n-        Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n+        Span {lo: BytePos(a), hi: BytePos(b), ctxt: NO_EXPANSION}\n     }\n \n     fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {"}, {"sha": "db2878c6b1e729ed4d4f61b911b936cbe51cb8a3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 315, "deletions": 360, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -40,8 +40,8 @@ use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n use ast::RangeEnd;\n use {ast, attr};\n-use codemap::{self, CodeMap, Spanned, spanned, respan};\n-use syntax_pos::{self, Span, BytePos, mk_sp};\n+use codemap::{self, CodeMap, Spanned, respan};\n+use syntax_pos::{self, Span, BytePos};\n use errors::{self, DiagnosticBuilder};\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n@@ -108,13 +108,13 @@ macro_rules! maybe_whole_expr {\n                     $p.bump();\n                     let span = $p.span;\n                     let kind = ExprKind::Path(None, (*path).clone());\n-                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n                 }\n                 token::NtBlock(ref block) => {\n                     $p.bump();\n                     let span = $p.span;\n                     let kind = ExprKind::Block((*block).clone());\n-                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n                 }\n                 _ => {},\n             };\n@@ -160,6 +160,7 @@ pub struct Parser<'a> {\n     /// the span of the current token:\n     pub span: Span,\n     /// the span of the previous token:\n+    pub meta_var_span: Option<Span>,\n     pub prev_span: Span,\n     /// the previous token kind\n     prev_token_kind: PrevTokenKind,\n@@ -417,6 +418,7 @@ impl<'a> Parser<'a> {\n             token: token::Underscore,\n             span: syntax_pos::DUMMY_SP,\n             prev_span: syntax_pos::DUMMY_SP,\n+            meta_var_span: None,\n             prev_token_kind: PrevTokenKind::Other,\n             restrictions: Restrictions::empty(),\n             obsolete_set: HashSet::new(),\n@@ -443,6 +445,7 @@ impl<'a> Parser<'a> {\n             parser.directory.path = PathBuf::from(sess.codemap().span_to_filename(parser.span));\n             parser.directory.path.pop();\n         }\n+        parser.process_potential_macro_variable();\n         parser\n     }\n \n@@ -731,7 +734,7 @@ impl<'a> Parser<'a> {\n             token::AndAnd => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::BinOp(token::And), lo, span.hi))\n+                Ok(self.bump_with(token::BinOp(token::And), Span { lo: lo, ..span }))\n             }\n             _ => self.unexpected()\n         }\n@@ -765,7 +768,7 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Shl) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                self.bump_with(token::Lt, lo, span.hi);\n+                self.bump_with(token::Lt, Span { lo: lo, ..span });\n                 true\n             }\n             _ => false,\n@@ -793,17 +796,17 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Shr) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Gt, lo, span.hi))\n+                Ok(self.bump_with(token::Gt, Span { lo: lo, ..span }))\n             }\n             token::BinOpEq(token::Shr) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Ge, lo, span.hi))\n+                Ok(self.bump_with(token::Ge, Span { lo: lo, ..span }))\n             }\n             token::Ge => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Eq, lo, span.hi))\n+                Ok(self.bump_with(token::Eq, Span { lo: lo, ..span }))\n             }\n             _ => self.unexpected()\n         }\n@@ -997,12 +1000,12 @@ impl<'a> Parser<'a> {\n                            -> PResult<'a, Spanned<Vec<T>>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         self.expect(bra)?;\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.bump();\n-        Ok(spanned(lo, hi, result))\n+        Ok(respan(lo.to(hi), result))\n     }\n \n     /// Advance the parser by one token\n@@ -1012,7 +1015,7 @@ impl<'a> Parser<'a> {\n             self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n         }\n \n-        self.prev_span = self.span;\n+        self.prev_span = self.meta_var_span.take().unwrap_or(self.span);\n \n         // Record last token kind for possible error recovery.\n         self.prev_token_kind = match self.token {\n@@ -1028,21 +1031,18 @@ impl<'a> Parser<'a> {\n         self.token = next.tok;\n         self.expected_tokens.clear();\n         // check after each token\n-        self.check_unknown_macro_variable();\n+        self.process_potential_macro_variable();\n     }\n \n     /// Advance the parser using provided token as a next one. Use this when\n     /// consuming a part of a token. For example a single `<` from `<<`.\n-    pub fn bump_with(&mut self,\n-                     next: token::Token,\n-                     lo: BytePos,\n-                     hi: BytePos) {\n-        self.prev_span = mk_sp(self.span.lo, lo);\n+    pub fn bump_with(&mut self, next: token::Token, span: Span) {\n+        self.prev_span = Span { hi: span.lo, ..self.span };\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n         // prev_token_kind will be of no use anyway.\n         self.prev_token_kind = PrevTokenKind::Other;\n-        self.span = mk_sp(lo, hi);\n+        self.span = span;\n         self.token = next;\n         self.expected_tokens.clear();\n     }\n@@ -1173,7 +1173,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n         let mut attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let TyParam {ident, bounds, default, ..} = self.parse_ty_param(vec![])?;\n@@ -1197,7 +1197,7 @@ impl<'a> Parser<'a> {\n         } else if self.token.is_path_start() {\n             // trait item macro.\n             // code copied from parse_macro_use_or_failure... abstraction!\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n@@ -1207,7 +1207,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n         } else {\n             let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n@@ -1277,7 +1277,7 @@ impl<'a> Parser<'a> {\n             ident: name,\n             attrs: attrs,\n             node: node,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n         })\n     }\n \n@@ -1298,8 +1298,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::RArrow) {\n             Ok(FunctionRetTy::Ty(self.parse_ty_no_plus()?))\n         } else {\n-            let pos = self.span.lo;\n-            Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n+            Ok(FunctionRetTy::Default(Span { hi: self.span.lo, ..self.span }))\n         }\n     }\n \n@@ -1320,7 +1319,7 @@ impl<'a> Parser<'a> {\n     fn parse_ty_common(&mut self, allow_plus: bool) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let node = if self.eat(&token::OpenDelim(token::Paren)) {\n             // `(TYPE)` is a parenthesized type.\n             // `(TYPE,)` is a tuple with a single field of type TYPE.\n@@ -1344,7 +1343,7 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, ref path)\n                             if allow_plus && self.token == token::BinOp(token::Plus) => {\n                         self.bump(); // `+`\n-                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo, self.prev_span.hi);\n+                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo.to(self.prev_span));\n                         let mut bounds = vec![TraitTyParamBound(pt, TraitBoundModifier::None)];\n                         bounds.append(&mut self.parse_ty_param_bounds()?);\n                         TyKind::TraitObject(bounds)\n@@ -1394,13 +1393,13 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n                 let (_, tts) = self.expect_delimited_token_tree()?;\n-                TyKind::Mac(spanned(lo, self.span.hi, Mac_ { path: path, tts: tts }))\n+                TyKind::Mac(respan(lo.to(self.span), Mac_ { path: path, tts: tts }))\n             } else {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n                 //   `Trait1 + Trait2 + 'a`\n                 if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo, self.prev_span.hi);\n+                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo.to(self.prev_span));\n                     let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n                     bounds.append(&mut self.parse_ty_param_bounds()?);\n                     TyKind::TraitObject(bounds)\n@@ -1415,13 +1414,13 @@ impl<'a> Parser<'a> {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.token_is_bare_fn_keyword() {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n                 let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n                 if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n                     bounds.append(&mut self.parse_ty_param_bounds()?)\n@@ -1440,7 +1439,7 @@ impl<'a> Parser<'a> {\n             return Err(self.fatal(&msg));\n         };\n \n-        let span = mk_sp(lo, self.prev_span.hi);\n+        let span = lo.to(self.prev_span);\n         let ty = Ty { node: node, span: span, id: ast::DUMMY_NODE_ID };\n \n         // Try to recover from use of `+` with incorrect priority.\n@@ -1457,7 +1456,7 @@ impl<'a> Parser<'a> {\n \n         self.bump(); // `+`\n         let bounds = self.parse_ty_param_bounds()?;\n-        let sum_span = mk_sp(ty.span.lo, self.prev_span.hi);\n+        let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, ty.span, E0178,\n             \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(&ty));\n@@ -1577,7 +1576,7 @@ impl<'a> Parser<'a> {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyKind::Infer,\n-                span: mk_sp(self.span.lo, self.span.hi),\n+                span: self.span,\n             })\n         };\n         Ok(Arg {\n@@ -1625,7 +1624,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches lit = true | false | token_lit\n     pub fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let lit = if self.eat_keyword(keywords::True) {\n             LitKind::Bool(true)\n         } else if self.eat_keyword(keywords::False) {\n@@ -1634,22 +1633,22 @@ impl<'a> Parser<'a> {\n             let lit = self.parse_lit_token()?;\n             lit\n         };\n-        Ok(codemap::Spanned { node: lit, span: mk_sp(lo, self.prev_span.hi) })\n+        Ok(codemap::Spanned { node: lit, span: lo.to(self.prev_span) })\n     }\n \n     /// matches '-' lit | lit\n     pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n-        let minus_lo = self.span.lo;\n+        let minus_lo = self.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let literal = P(self.parse_lit()?);\n-        let hi = self.prev_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n+        let hi = self.prev_span;\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n-            let minus_hi = self.prev_span.hi;\n+            let minus_hi = self.prev_span;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -1726,7 +1725,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.meta_var_span.unwrap_or(self.span);\n         let is_global = self.eat(&token::ModSep);\n \n         // Parse any number of segments and bound sets. A segment is an\n@@ -1748,13 +1747,9 @@ impl<'a> Parser<'a> {\n             segments.insert(0, PathSegment::crate_root());\n         }\n \n-        // Assemble the span.\n-        // FIXME(#39450) This is bogus if part of the path is macro generated.\n-        let span = mk_sp(lo, self.prev_span.hi);\n-\n         // Assemble the result.\n         Ok(ast::Path {\n-            span: span,\n+            span: lo.to(self.prev_span),\n             segments: segments,\n         })\n     }\n@@ -1767,8 +1762,8 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n+            let ident_span = self.span;\n             let identifier = self.parse_path_segment_ident()?;\n-            let ident_span = self.prev_span;\n \n             if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n                 self.bump();\n@@ -1791,7 +1786,7 @@ impl<'a> Parser<'a> {\n                     bindings: bindings,\n                 }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n-                let lo = self.prev_span.lo;\n+                let lo = self.prev_span;\n \n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n@@ -1804,10 +1799,10 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n \n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n                 Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n-                    span: mk_sp(lo, hi),\n+                    span: lo.to(hi),\n                     inputs: inputs,\n                     output: output_ty,\n                 })))\n@@ -1835,8 +1830,8 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n+            let ident_span = self.span;\n             let identifier = self.parse_path_segment_ident()?;\n-            let ident_span = self.prev_span;\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n@@ -1877,10 +1872,11 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n+            let ident_span = self.span;\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(PathSegment::from_ident(identifier, self.prev_span));\n+            segments.push(PathSegment::from_ident(identifier, ident_span));\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {\n@@ -1900,8 +1896,9 @@ impl<'a> Parser<'a> {\n     fn expect_lifetime(&mut self) -> Lifetime {\n         match self.token {\n             token::Lifetime(ident) => {\n+                let ident_span = self.span;\n                 self.bump();\n-                Lifetime { name: ident.name, span: self.prev_span, id: ast::DUMMY_NODE_ID }\n+                Lifetime { name: ident.name, span: ident_span, id: ast::DUMMY_NODE_ID }\n             }\n             _ => self.span_bug(self.span, \"not a lifetime\")\n         }\n@@ -1928,38 +1925,37 @@ impl<'a> Parser<'a> {\n     /// Parse ident (COLON expr)?\n     pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let hi;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            hi = self.prev_span.hi;\n+            hi = self.prev_span;\n             (fieldname, self.parse_expr()?, false)\n         } else {\n             let fieldname = self.parse_ident()?;\n-            hi = self.prev_span.hi;\n+            hi = self.prev_span;\n \n             // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(mk_sp(lo, hi), fieldname);\n-            (fieldname, self.mk_expr(lo, hi, ExprKind::Path(None, path), ThinVec::new()), true)\n+            let path = ast::Path::from_ident(lo.to(hi), fieldname);\n+            (fieldname, self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new()), true)\n         };\n         Ok(ast::Field {\n-            ident: spanned(lo, hi, fieldname),\n-            span: mk_sp(lo, expr.span.hi),\n+            ident: respan(lo.to(hi), fieldname),\n+            span: lo.to(expr.span),\n             expr: expr,\n             is_shorthand: is_shorthand,\n             attrs: attrs.into(),\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: ExprKind, attrs: ThinVec<Attribute>)\n-                   -> P<Expr> {\n+    pub fn mk_expr(&mut self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n-            span: mk_sp(lo, hi),\n+            span: span,\n             attrs: attrs.into(),\n         })\n     }\n@@ -2013,12 +2009,11 @@ impl<'a> Parser<'a> {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n-                       m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n-            span: mk_sp(lo, hi),\n+            node: ExprKind::Mac(codemap::Spanned {node: m, span: span}),\n+            span: span,\n             attrs: attrs,\n         })\n     }\n@@ -2065,8 +2060,8 @@ impl<'a> Parser<'a> {\n         // attributes by giving them a empty \"already parsed\" list.\n         let mut attrs = ThinVec::new();\n \n-        let lo = self.span.lo;\n-        let mut hi = self.span.hi;\n+        let lo = self.span;\n+        let mut hi = self.span;\n \n         let ex: ExprKind;\n \n@@ -2095,18 +2090,19 @@ impl<'a> Parser<'a> {\n                 }\n                 self.bump();\n \n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n+                let span = lo.to(hi);\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n+                    Ok(self.mk_expr(span, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprKind::Tup(es), attrs))\n+                    Ok(self.mk_expr(span, ExprKind::Tup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n                 return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n             },\n             token::OpenDelim(token::Bracket) => {\n@@ -2144,34 +2140,34 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Array(vec![first_expr]);\n                     }\n                 }\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n             }\n             _ => {\n                 if self.eat_lt() {\n                     let (qself, path) =\n                         self.parse_qualified_path(PathStyle::Expr)?;\n-                    hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n+                    hi = path.span;\n+                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_lambda_expr(lo, CaptureBy::Value, attrs);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr(attrs);\n                 }\n                 if self.eat_keyword(keywords::For) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_for_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::While) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n                     let label = Spanned { node: self.get_label(),\n                                           span: self.span };\n-                    let lo = self.span.lo;\n+                    let lo = self.span;\n                     self.bump();\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n@@ -2186,7 +2182,7 @@ impl<'a> Parser<'a> {\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if self.eat_keyword(keywords::Loop) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n@@ -2200,8 +2196,8 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ExprKind::Continue(None)\n                     };\n-                    let hi = self.prev_span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ex, attrs));\n+                    let hi = self.prev_span;\n+                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n                 }\n                 if self.eat_keyword(keywords::Match) {\n                     return self.parse_match_expr(attrs);\n@@ -2215,13 +2211,13 @@ impl<'a> Parser<'a> {\n                 if self.is_catch_expr() {\n                     assert!(self.eat_keyword(keywords::Do));\n                     assert!(self.eat_keyword(keywords::Catch));\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_catch_expr(lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n-                        hi = e.span.hi;\n+                        hi = e.span;\n                         ex = ExprKind::Ret(Some(e));\n                     } else {\n                         ex = ExprKind::Ret(None);\n@@ -2246,7 +2242,7 @@ impl<'a> Parser<'a> {\n                         None\n                     };\n                     ex = ExprKind::Break(lt, e);\n-                    hi = self.prev_span.hi;\n+                    hi = self.prev_span;\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `check_strict_keywords`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n@@ -2260,8 +2256,8 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n                         let (_, tts) = self.expect_delimited_token_tree()?;\n-                        let hi = self.prev_span.hi;\n-                        return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n+                        let hi = self.prev_span;\n+                        return Ok(self.mk_mac_expr(lo.to(hi), Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2274,12 +2270,12 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n \n-                    hi = pth.span.hi;\n+                    hi = pth.span;\n                     ex = ExprKind::Path(None, pth);\n                 } else {\n                     match self.parse_lit() {\n                         Ok(lit) => {\n-                            hi = lit.span.hi;\n+                            hi = lit.span;\n                             ex = ExprKind::Lit(P(lit));\n                         }\n                         Err(mut err) => {\n@@ -2293,10 +2289,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n     }\n \n-    fn parse_struct_expr(&mut self, lo: BytePos, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n+    fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n                          -> PResult<'a, P<Expr>> {\n         self.bump();\n         let mut fields = Vec::new();\n@@ -2338,9 +2334,9 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.span.hi;\n+        let span = lo.to(self.span);\n         self.expect(&token::CloseDelim(token::Brace))?;\n-        return Ok(self.mk_expr(lo, hi, ExprKind::Struct(pth, fields, base), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n     }\n \n     fn parse_or_use_outer_attributes(&mut self,\n@@ -2354,7 +2350,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a block or unsafe block\n-    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n+    pub fn parse_block_expr(&mut self, lo: Span, blk_mode: BlockCheckMode,\n                             outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n \n@@ -2364,7 +2360,7 @@ impl<'a> Parser<'a> {\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n+        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n@@ -2375,12 +2371,12 @@ impl<'a> Parser<'a> {\n \n         let b = self.parse_bottom_expr();\n         let (span, b) = self.interpolated_or_expr_span(b)?;\n-        self.parse_dot_or_call_expr_with(b, span.lo, attrs)\n+        self.parse_dot_or_call_expr_with(b, span, attrs)\n     }\n \n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n-                                       lo: BytePos,\n+                                       lo: Span,\n                                        mut attrs: ThinVec<Attribute>)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n@@ -2411,11 +2407,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.foo` (i.e., a dot and an ident), continue\n     // parsing into an expression.\n-    fn parse_dot_suffix(&mut self,\n-                        ident: Ident,\n-                        ident_span: Span,\n-                        self_value: P<Expr>,\n-                        lo: BytePos)\n+    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>, lo: Span)\n                         -> PResult<'a, P<Expr>> {\n         let (_, tys, bindings) = if self.eat(&token::ModSep) {\n             self.expect_lt()?;\n@@ -2440,12 +2432,12 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n                 es.insert(0, self_value);\n-                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let id = respan(ident_span.to(ident_span), ident);\n                 let nd = self.mk_method_call(id, tys, es);\n-                self.mk_expr(lo, hi, nd, ThinVec::new())\n+                self.mk_expr(lo.to(hi), nd, ThinVec::new())\n             }\n             // Field access.\n             _ => {\n@@ -2456,49 +2448,47 @@ impl<'a> Parser<'a> {\n                                    have type parameters\");\n                 }\n \n-                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let id = respan(ident_span.to(ident_span), ident);\n                 let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo, ident_span.hi, field, ThinVec::new())\n+                self.mk_expr(lo.to(ident_span), field, ThinVec::new())\n             }\n         })\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: BytePos) -> PResult<'a, P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n         loop {\n             // expr?\n             while self.eat(&token::Question) {\n-                let hi = self.prev_span.hi;\n-                e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n+                let hi = self.prev_span;\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n                   token::Ident(i) => {\n-                    let dot_pos = self.prev_span.hi;\n-                    hi = self.span.hi;\n+                    let ident_span = self.span;\n                     self.bump();\n-\n-                    e = self.parse_dot_suffix(i, mk_sp(dot_pos, hi), e, lo)?;\n+                    e = self.parse_dot_suffix(i, ident_span, e, lo)?;\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n \n                     // A tuple index may not have a suffix\n                     self.expect_no_suffix(sp, \"tuple index\", suf);\n \n-                    let dot = self.prev_span.hi;\n-                    hi = self.span.hi;\n+                    let dot_span = self.prev_span;\n+                    hi = self.span;\n                     self.bump();\n \n                     let index = n.as_str().parse::<usize>().ok();\n                     match index {\n                         Some(n) => {\n-                            let id = spanned(dot, hi, n);\n+                            let id = respan(dot_span.to(hi), n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, ThinVec::new());\n+                            e = self.mk_expr(lo.to(hi), field, ThinVec::new());\n                         }\n                         None => {\n                             let prev_span = self.prev_span;\n@@ -2541,10 +2531,8 @@ impl<'a> Parser<'a> {\n                     let actual = self.this_token_to_string();\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n-                    let dot_pos = self.prev_span.hi;\n-                    e = self.parse_dot_suffix(keywords::Invalid.ident(),\n-                                              mk_sp(dot_pos, dot_pos),\n-                                              e, lo)?;\n+                    let dot_span = self.prev_span;\n+                    e = self.parse_dot_suffix(keywords::Invalid.ident(), dot_span, e, lo)?;\n                   }\n                 }\n                 continue;\n@@ -2559,32 +2547,45 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd, ThinVec::new());\n+                e = self.mk_expr(lo.to(hi), nd, ThinVec::new());\n               }\n \n               // expr[...]\n               // Could be either an index expression or a slicing expression.\n               token::OpenDelim(token::Bracket) => {\n                 self.bump();\n                 let ix = self.parse_expr()?;\n-                hi = self.span.hi;\n+                hi = self.span;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index, ThinVec::new())\n+                e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n               }\n               _ => return Ok(e)\n             }\n         }\n         return Ok(e);\n     }\n \n-    pub fn check_unknown_macro_variable(&mut self) {\n-        if let token::SubstNt(name) = self.token {\n-            self.fatal(&format!(\"unknown macro variable `{}`\", name)).emit()\n-        }\n+    pub fn process_potential_macro_variable(&mut self) {\n+        let ident = match self.token {\n+            token::SubstNt(name) => {\n+                self.fatal(&format!(\"unknown macro variable `{}`\", name)).emit();\n+                return\n+            }\n+            token::Interpolated(ref nt) => {\n+                self.meta_var_span = Some(self.span);\n+                match **nt {\n+                    token::NtIdent(ident) => ident,\n+                    _ => return,\n+                }\n+            }\n+            _ => return,\n+        };\n+        self.token = token::Ident(ident.node);\n+        self.span = ident.span;\n     }\n \n     /// parse a single token tree from the input.\n@@ -2602,9 +2603,9 @@ impl<'a> Parser<'a> {\n             },\n             token::CloseDelim(_) | token::Eof => unreachable!(),\n             _ => {\n-                let token = mem::replace(&mut self.token, token::Underscore);\n+                let (token, span) = (mem::replace(&mut self.token, token::Underscore), self.span);\n                 self.bump();\n-                TokenTree::Token(self.prev_span, token)\n+                TokenTree::Token(span, token)\n             }\n         }\n     }\n@@ -2635,38 +2636,33 @@ impl<'a> Parser<'a> {\n                              already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span.lo;\n-        let hi;\n+        let lo = self.span;\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n-        let ex = match self.token {\n+        let (hi, ex) = match self.token {\n             token::Not => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Not, e)\n+                (span, self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Neg, e)\n+                (span, self.mk_unary(UnOp::Neg, e))\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Deref, e)\n+                (span, self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 self.expect_and()?;\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                ExprKind::AddrOf(m, e)\n+                (span, ExprKind::AddrOf(m, e))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2676,20 +2672,18 @@ impl<'a> Parser<'a> {\n                 )?;\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n-                hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, hi, ExprKind::Block(blk), ThinVec::new());\n-                ExprKind::InPlace(place, blk_expr)\n+                let blk_expr = self.mk_expr(span, ExprKind::Block(blk), ThinVec::new());\n+                (span, ExprKind::InPlace(place, blk_expr))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                ExprKind::Box(e)\n+                (span, ExprKind::Box(e))\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n-        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n     }\n \n     /// Parse an associative expression\n@@ -2750,13 +2744,11 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = self.parse_ty_no_plus()?;\n-                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n-                lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty_no_plus()?;\n-                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n-                lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n                 // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n@@ -2782,7 +2774,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = try!(self.mk_range(Some(lhs), rhs, limits));\n-                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n                 break\n             }\n \n@@ -2809,7 +2801,7 @@ impl<'a> Parser<'a> {\n                 }),\n             }?;\n \n-            let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+            let span = lhs_span.to(rhs.span);\n             lhs = match op {\n                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n                 AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n@@ -2818,12 +2810,12 @@ impl<'a> Parser<'a> {\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lo, hi, binary, ThinVec::new())\n+                    self.mk_expr(span, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lo, hi, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                    self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lo, hi, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n+                    self.mk_expr(span, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -2838,7 +2830,7 @@ impl<'a> Parser<'a> {\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lo, hi, aopexpr, ThinVec::new())\n+                    self.mk_expr(span, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n                     self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n@@ -2858,7 +2850,7 @@ impl<'a> Parser<'a> {\n         match lhs.node {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n-                let op_span = mk_sp(op.span.lo, self.span.hi);\n+                let op_span = op.span.to(self.span);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BinOpKind::Lt &&\n@@ -2881,16 +2873,16 @@ impl<'a> Parser<'a> {\n         debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span.lo;\n-        let mut hi = self.span.hi;\n+        let lo = self.span;\n+        let mut hi = self.span;\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n             let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n             Some(self.parse_assoc_expr_with(next_prec,\n                                             LhsExpr::NotYetParsed)\n                 .map(|x|{\n-                    hi = x.span.hi;\n+                    hi = x.span;\n                     x\n                 })?)\n          } else {\n@@ -2905,7 +2897,7 @@ impl<'a> Parser<'a> {\n         let r = try!(self.mk_range(None,\n                                    opt_end,\n                                    limits));\n-        Ok(self.mk_expr(lo, hi, r, attrs))\n+        Ok(self.mk_expr(lo.to(hi), r, attrs))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -2925,60 +2917,59 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n-        let mut hi = thn.span.hi;\n+        let mut hi = thn.span;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr()?;\n-            hi = elexpr.span.hi;\n+            hi = elexpr.span;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n     pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n-            (expr.span.hi, Some(expr))\n+            (expr.span, Some(expr))\n         } else {\n-            (thn.span.hi, None)\n+            (thn.span, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprKind::IfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `move |args| expr`\n     pub fn parse_lambda_expr(&mut self,\n-                             lo: BytePos,\n+                             lo: Span,\n                              capture_clause: CaptureBy,\n                              attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.prev_span.hi;\n+        let decl_hi = self.prev_span;\n         let body = match decl.output {\n             FunctionRetTy::Default(_) => self.parse_expr()?,\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n-                let body_lo = self.span.lo;\n+                let body_lo = self.span;\n                 self.parse_block_expr(body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n \n         Ok(self.mk_expr(\n-            lo,\n-            body.span.hi,\n-            ExprKind::Closure(capture_clause, decl, body, mk_sp(lo, decl_hi)),\n+            lo.to(body.span),\n+            ExprKind::Closure(capture_clause, decl, body, lo.to(decl_hi)),\n             attrs))\n     }\n \n@@ -2988,13 +2979,13 @@ impl<'a> Parser<'a> {\n             return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), ThinVec::new()));\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), ThinVec::new()));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                          span_lo: BytePos,\n+                          span_lo: Span,\n                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n@@ -3004,66 +2995,61 @@ impl<'a> Parser<'a> {\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n-        let hi = self.prev_span.hi;\n-\n-        Ok(self.mk_expr(span_lo, hi,\n-                        ExprKind::ForLoop(pat, expr, loop_block, opt_ident),\n-                        attrs))\n+        let hi = self.prev_span;\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_ident), attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                            span_lo: BytePos,\n+                            span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n-                               attrs));\n+        let span = span_lo.to(body.span);\n+        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_ident), attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                                span_lo: BytePos,\n+                                span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n+        let span = span_lo.to(body.span);\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                           span_lo: BytePos,\n+                           span_lo: Span,\n                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)\n-    pub fn parse_catch_expr(&mut self, span_lo: BytePos, mut attrs: ThinVec<Attribute>)\n+    pub fn parse_catch_expr(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)\n         -> PResult<'a, P<Expr>>\n     {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprKind::Catch(body), attrs))\n+        Ok(self.mk_expr(span_lo.to(body.span), ExprKind::Catch(body), attrs))\n     }\n \n     // `match` token already eaten\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n@@ -3082,17 +3068,17 @@ impl<'a> Parser<'a> {\n                     // Recover by skipping to the end of the block.\n                     e.emit();\n                     self.recover_stmt();\n-                    let hi = self.span.hi;\n+                    let span = lo.to(self.span);\n                     if self.token == token::CloseDelim(token::Brace) {\n                         self.bump();\n                     }\n-                    return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n+                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n                 }\n             }\n         }\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.bump();\n-        return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n@@ -3266,7 +3252,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let attrs = self.parse_outer_attributes()?;\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let hi;\n \n             if self.check(&token::DotDot) {\n@@ -3286,16 +3272,16 @@ impl<'a> Parser<'a> {\n                 let fieldname = self.parse_field_name()?;\n                 self.bump();\n                 let pat = self.parse_pat()?;\n-                hi = pat.span.hi;\n+                hi = pat.span;\n                 (pat, fieldname, false)\n             } else {\n                 // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n                 let is_box = self.eat_keyword(keywords::Box);\n-                let boxed_span_lo = self.span.lo;\n+                let boxed_span = self.span;\n                 let is_ref = self.eat_keyword(keywords::Ref);\n                 let is_mut = self.eat_keyword(keywords::Mut);\n                 let fieldname = self.parse_ident()?;\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n \n                 let bind_type = match (is_ref, is_mut) {\n                     (true, true) => BindingMode::ByRef(Mutability::Mutable),\n@@ -3307,22 +3293,22 @@ impl<'a> Parser<'a> {\n                 let fieldpat = P(ast::Pat{\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatKind::Ident(bind_type, fieldpath, None),\n-                    span: mk_sp(boxed_span_lo, hi),\n+                    span: boxed_span.to(hi),\n                 });\n \n                 let subpat = if is_box {\n                     P(ast::Pat{\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatKind::Box(fieldpat),\n-                        span: mk_sp(lo, hi),\n+                        span: lo.to(hi),\n                     })\n                 } else {\n                     fieldpat\n                 };\n                 (subpat, fieldname, true)\n             };\n \n-            fields.push(codemap::Spanned { span: mk_sp(lo, hi),\n+            fields.push(codemap::Spanned { span: lo.to(hi),\n                                            node: ast::FieldPat {\n                                                ident: fieldname,\n                                                pat: subpat,\n@@ -3336,7 +3322,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n         if self.token.is_path_start() {\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n                 let (qself, path) =\n@@ -3346,8 +3332,8 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let hi = self.prev_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n+            let hi = self.prev_span;\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3373,7 +3359,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n         maybe_whole!(self, NtPat, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let pat;\n         match self.token {\n             token::Underscore => {\n@@ -3439,7 +3425,7 @@ impl<'a> Parser<'a> {\n                         // Parse macro invocation\n                         self.bump();\n                         let (_, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = spanned(lo, self.prev_span.hi, Mac_ { path: path, tts: tts });\n+                        let mac = respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot | token::DotDot => {\n@@ -3449,9 +3435,8 @@ impl<'a> Parser<'a> {\n                             _ => panic!(\"can only parse `..` or `...` for ranges (checked above)\"),\n                         };\n                         // Parse range\n-                        let hi = self.prev_span.hi;\n-                        let begin =\n-                              self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n+                        let span = lo.to(self.prev_span);\n+                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end, end_kind);\n@@ -3505,11 +3490,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.prev_span.hi;\n         Ok(P(ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(self.prev_span),\n         }))\n     }\n \n@@ -3519,9 +3503,9 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n                        -> PResult<'a, PatKind> {\n+        let ident_span = self.span;\n         let ident = self.parse_ident()?;\n-        let prev_span = self.prev_span;\n-        let name = codemap::Spanned{span: prev_span, node: ident};\n+        let name = codemap::Spanned{span: ident_span, node: ident};\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat()?)\n         } else {\n@@ -3545,7 +3529,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a local variable declaration\n     fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let pat = self.parse_pat()?;\n \n         let mut ty = None;\n@@ -3558,22 +3542,22 @@ impl<'a> Parser<'a> {\n             pat: pat,\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             attrs: attrs,\n         }))\n     }\n \n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self,\n-                         lo: BytePos,\n+                         lo: Span,\n                          vis: Visibility,\n                          attrs: Vec<Attribute>)\n                          -> PResult<'a, StructField> {\n         let name = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         Ok(StructField {\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             ident: Some(name),\n             vis: vis,\n             id: ast::DUMMY_NODE_ID,\n@@ -3683,7 +3667,7 @@ impl<'a> Parser<'a> {\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n                      -> PResult<'a, Option<P<Item>>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         match self.token {\n             token::Ident(ident) if ident.name == \"macro_rules\" => {\n                 if self.look_ahead(1, |t| *t == token::Not) {\n@@ -3706,9 +3690,9 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.prev_span.hi;\n+        let span = lo.to(self.prev_span);\n         let kind = ItemKind::MacroDef(tts);\n-        Ok(Some(self.mk_item(lo, hi, id, kind, Visibility::Inherited, attrs.to_owned())))\n+        Ok(Some(self.mk_item(span, id, kind, Visibility::Inherited, attrs.to_owned())))\n     }\n \n     fn parse_stmt_without_recovery(&mut self,\n@@ -3717,19 +3701,19 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         Ok(Some(if self.eat_keyword(keywords::Let) {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: mk_sp(lo, self.prev_span.hi),\n+                span: lo.to(self.prev_span),\n             }\n         } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited)? {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Item(macro_def),\n-                span: mk_sp(lo, self.prev_span.hi),\n+                span: lo.to(self.prev_span),\n             }\n         // Starts like a simple path, but not a union item.\n         } else if self.token.is_path_start() &&\n@@ -3741,8 +3725,8 @@ impl<'a> Parser<'a> {\n                 let expr = if self.check(&token::OpenDelim(token::Brace)) {\n                     self.parse_struct_expr(lo, pth, ThinVec::new())?\n                 } else {\n-                    let hi = self.prev_span.hi;\n-                    self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n+                    let hi = self.prev_span;\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n                 let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n@@ -3753,7 +3737,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     node: StmtKind::Expr(expr),\n-                    span: mk_sp(lo, self.prev_span.hi),\n+                    span: lo.to(self.prev_span),\n                 }));\n             }\n \n@@ -3784,7 +3768,7 @@ impl<'a> Parser<'a> {\n             };\n \n             let (_, tts) = self.expect_delimited_token_tree()?;\n-            let hi = self.prev_span.hi;\n+            let hi = self.prev_span;\n \n             let style = if delim == token::Brace {\n                 MacStmtStyle::Braces\n@@ -3793,7 +3777,7 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                let mac = respan(lo.to(hi), Mac_ { path: pth, tts: tts });\n                 let node = if delim == token::Brace ||\n                               self.token == token::Semi || self.token == token::Eof {\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n@@ -3813,14 +3797,14 @@ impl<'a> Parser<'a> {\n                     self.warn_missing_semicolon();\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n                 } else {\n-                    let e = self.mk_mac_expr(lo, hi, mac.node, ThinVec::new());\n+                    let e = self.mk_mac_expr(lo.to(hi), mac.node, ThinVec::new());\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n                     StmtKind::Expr(e)\n                 };\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n+                    span: lo.to(hi),\n                     node: node,\n                 }\n             } else {\n@@ -3835,13 +3819,14 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n+                let span = lo.to(hi);\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n+                    span: span,\n                     node: StmtKind::Item({\n                         self.mk_item(\n-                            lo, hi, id /*id is good here*/,\n-                            ItemKind::Mac(spanned(lo, hi, Mac_ { path: pth, tts: tts })),\n+                            span, id /*id is good here*/,\n+                            ItemKind::Mac(respan(span, Mac_ { path: pth, tts: tts })),\n                             Visibility::Inherited,\n                             attrs)\n                     }),\n@@ -3856,7 +3841,7 @@ impl<'a> Parser<'a> {\n             match item {\n                 Some(i) => Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, i.span.hi),\n+                    span: lo.to(i.span),\n                     node: StmtKind::Item(i),\n                 },\n                 None => {\n@@ -3887,7 +3872,7 @@ impl<'a> Parser<'a> {\n                         Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, e.span.hi),\n+                        span: lo.to(e.span),\n                         node: StmtKind::Expr(e),\n                     }\n                 }\n@@ -3905,7 +3890,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         if !self.eat(&token::OpenDelim(token::Brace)) {\n             let sp = self.span;\n@@ -3950,15 +3935,15 @@ impl<'a> Parser<'a> {\n     fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         self.expect(&token::OpenDelim(token::Brace))?;\n         Ok((self.parse_inner_attributes()?,\n             self.parse_block_tail(lo, BlockCheckMode::Default)?))\n     }\n \n     /// Parse the rest of a block expression or function body\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n+    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n@@ -3976,7 +3961,7 @@ impl<'a> Parser<'a> {\n             stmts: stmts,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n         }))\n     }\n \n@@ -4042,10 +4027,10 @@ impl<'a> Parser<'a> {\n                 }\n                 bounds.push(RegionTyParamBound(self.expect_lifetime()));\n             } else if self.check_keyword(keywords::For) || self.check_path() {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n                 let modifier = if question.is_some() {\n                     TraitBoundModifier::Maybe\n                 } else {\n@@ -4166,7 +4151,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics, |x| x);\n \n-        let span_lo = self.span.lo;\n+        let span_lo = self.span;\n         if self.eat_lt() {\n             let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n             self.expect_gt()?;\n@@ -4177,7 +4162,7 @@ impl<'a> Parser<'a> {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n                 },\n-                span: mk_sp(span_lo, self.prev_span.hi),\n+                span: span_lo.to(self.prev_span),\n             })\n         } else {\n             Ok(ast::Generics::default())\n@@ -4202,15 +4187,15 @@ impl<'a> Parser<'a> {\n                 }\n             } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n                 // Parse associated type binding.\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 let ident = self.parse_ident()?;\n                 self.bump();\n                 let ty = self.parse_ty()?;\n                 bindings.push(TypeBinding {\n                     id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     ty: ty,\n-                    span: mk_sp(lo, self.prev_span.hi),\n+                    span: lo.to(self.prev_span),\n                 });\n                 seen_binding = true;\n             } else if self.check_type() {\n@@ -4267,15 +4252,15 @@ impl<'a> Parser<'a> {\n         }\n \n         loop {\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n                 let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n                 where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n                     ast::WhereRegionPredicate {\n-                        span: mk_sp(lo, self.prev_span.hi),\n+                        span: lo.to(self.prev_span),\n                         lifetime: lifetime,\n                         bounds: bounds,\n                     }\n@@ -4296,7 +4281,7 @@ impl<'a> Parser<'a> {\n                     let bounds = self.parse_ty_param_bounds()?;\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n-                            span: mk_sp(lo, self.prev_span.hi),\n+                            span: lo.to(self.prev_span),\n                             bound_lifetimes: lifetime_defs,\n                             bounded_ty: ty,\n                             bounds: bounds,\n@@ -4307,7 +4292,7 @@ impl<'a> Parser<'a> {\n                     let rhs_ty = self.parse_ty()?;\n                     where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n                         ast::WhereEqPredicate {\n-                            span: mk_sp(lo, self.prev_span.hi),\n+                            span: lo.to(self.prev_span),\n                             lhs_ty: ty,\n                             rhs_ty: rhs_ty,\n                             id: ast::DUMMY_NODE_ID,\n@@ -4393,7 +4378,7 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n             // Preserve hygienic context.\n-            token::Ident(ident) => { this.bump(); codemap::respan(this.prev_span, ident) }\n+            token::Ident(ident) => { let sp = this.span; this.bump(); codemap::respan(sp, ident) }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n@@ -4404,7 +4389,7 @@ impl<'a> Parser<'a> {\n         // Parse optional self parameter of a method.\n         // Only a limited set of initial token sequences is considered self parameters, anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n-        let eself_lo = self.span.lo;\n+        let eself_lo = self.span;\n         let (eself, eself_ident) = match self.token {\n             token::BinOp(token::And) => {\n                 // &self\n@@ -4486,7 +4471,7 @@ impl<'a> Parser<'a> {\n             _ => return Ok(None),\n         };\n \n-        let eself = codemap::respan(mk_sp(eself_lo, self.prev_span.hi), eself);\n+        let eself = codemap::respan(eself_lo.to(self.prev_span), eself);\n         Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n \n@@ -4558,16 +4543,15 @@ impl<'a> Parser<'a> {\n         Ok((id, generics))\n     }\n \n-    fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n-               node: ItemKind, vis: Visibility,\n+    fn mk_item(&mut self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident: ident,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             vis: vis,\n-            span: mk_sp(lo, hi)\n+            span: span,\n         })\n     }\n \n@@ -4625,7 +4609,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtImplItem, |x| x);\n \n         let mut attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness()?;\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n@@ -4651,7 +4635,7 @@ impl<'a> Parser<'a> {\n \n         Ok(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             ident: name,\n             vis: vis,\n             defaultness: defaultness,\n@@ -4694,7 +4678,7 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&vis, prev_span);\n \n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n@@ -4704,7 +4688,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n@@ -4938,11 +4922,11 @@ impl<'a> Parser<'a> {\n             SeqSep::trailing_allowed(token::Comma),\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n-                let lo = p.span.lo;\n+                let lo = p.span;\n                 let vis = p.parse_visibility(true)?;\n                 let ty = p.parse_ty()?;\n                 Ok(StructField {\n-                    span: mk_sp(lo, p.span.hi),\n+                    span: lo.to(p.span),\n                     vis: vis,\n                     ident: None,\n                     id: ast::DUMMY_NODE_ID,\n@@ -4956,7 +4940,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a structure field declaration\n     pub fn parse_single_struct_field(&mut self,\n-                                     lo: BytePos,\n+                                     lo: Span,\n                                      vis: Visibility,\n                                      attrs: Vec<Attribute> )\n                                      -> PResult<'a, StructField> {\n@@ -4978,7 +4962,7 @@ impl<'a> Parser<'a> {\n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         self.parse_single_struct_field(lo, vis, attrs)\n     }\n@@ -5036,11 +5020,7 @@ impl<'a> Parser<'a> {\n                                        the path:\",\n                                        path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let sp = Span {\n-                    lo: start_span.lo,\n-                    hi: self.prev_span.hi,\n-                    expn_id: start_span.expn_id,\n-                };\n+                let sp = start_span.to(self.prev_span);\n                 let mut err = self.span_fatal_help(sp, &msg, &suggestion);\n                 err.span_suggestion(path_span, &help_msg, format!(\"in {}\", path));\n                 err.emit();  // emit diagnostic, but continue with public visibility\n@@ -5060,7 +5040,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Given a termination token, parse all of the items in a module\n-    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<'a, Mod> {\n+    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: Span) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = self.parse_item()? {\n             items.push(item);\n@@ -5074,11 +5054,11 @@ impl<'a> Parser<'a> {\n         let hi = if self.span == syntax_pos::DUMMY_SP {\n             inner_lo\n         } else {\n-            self.prev_span.hi\n+            self.prev_span\n         };\n \n         Ok(ast::Mod {\n-            inner: mk_sp(inner_lo, hi),\n+            inner: inner_lo.to(hi),\n             items: items\n         })\n     }\n@@ -5141,7 +5121,7 @@ impl<'a> Parser<'a> {\n             let old_directory = self.directory.clone();\n             self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            let mod_inner_lo = self.span.lo;\n+            let mod_inner_lo = self.span;\n             let attrs = self.parse_inner_attributes()?;\n             let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n             self.directory = old_directory;\n@@ -5284,50 +5264,50 @@ impl<'a> Parser<'a> {\n         let mut p0 =\n             new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         p0.cfg_mods = self.cfg_mods;\n-        let mod_inner_lo = p0.span.lo;\n+        let mod_inner_lo = p0.span;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n         self.sess.included_mod_stack.borrow_mut().pop();\n         Ok((ast::ItemKind::Mod(m0), mod_attrs))\n     }\n \n     /// Parse a function declaration from a foreign module\n-    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: BytePos,\n-                             attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n+    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                             -> PResult<'a, ForeignItem> {\n         self.expect_keyword(keywords::Fn)?;\n \n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(true)?;\n         generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.expect(&token::Semi)?;\n         Ok(ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Fn(decl, generics),\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(hi),\n             vis: vis\n         })\n     }\n \n     /// Parse a static item from a foreign module\n-    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: BytePos,\n-                                 attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n+    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                                 -> PResult<'a, ForeignItem> {\n         self.expect_keyword(keywords::Static)?;\n         let mutbl = self.eat_keyword(keywords::Mut);\n \n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.expect(&token::Semi)?;\n         Ok(ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Static(ty, mutbl),\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(hi),\n             vis: vis\n         })\n     }\n@@ -5339,7 +5319,7 @@ impl<'a> Parser<'a> {\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     fn parse_item_extern_crate(&mut self,\n-                               lo: BytePos,\n+                               lo: Span,\n                                visibility: Visibility,\n                                attrs: Vec<Attribute>)\n                                 -> PResult<'a, P<Item>> {\n@@ -5353,8 +5333,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Semi)?;\n \n         let prev_span = self.prev_span;\n-        Ok(self.mk_item(lo,\n-                        prev_span.hi,\n+        Ok(self.mk_item(lo.to(prev_span),\n                         ident,\n                         ItemKind::ExternCrate(maybe_path),\n                         visibility,\n@@ -5372,7 +5351,7 @@ impl<'a> Parser<'a> {\n     /// extern \"C\" {}\n     /// extern {}\n     fn parse_item_foreign_mod(&mut self,\n-                              lo: BytePos,\n+                              lo: Span,\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n                               mut attrs: Vec<Attribute>)\n@@ -5394,12 +5373,8 @@ impl<'a> Parser<'a> {\n             abi: abi,\n             items: foreign_items\n         };\n-        Ok(self.mk_item(lo,\n-                     prev_span.hi,\n-                     keywords::Invalid.ident(),\n-                     ItemKind::ForeignMod(m),\n-                     visibility,\n-                     attrs))\n+        let invalid = keywords::Invalid.ident();\n+        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n     /// Parse type Foo = Bar;\n@@ -5420,7 +5395,7 @@ impl<'a> Parser<'a> {\n         let mut any_disr = None;\n         while self.token != token::CloseDelim(token::Brace) {\n             let variant_attrs = self.parse_outer_attributes()?;\n-            let vlo = self.span.lo;\n+            let vlo = self.span;\n \n             let struct_def;\n             let mut disr_expr = None;\n@@ -5448,7 +5423,7 @@ impl<'a> Parser<'a> {\n                 data: struct_def,\n                 disr_expr: disr_expr,\n             };\n-            variants.push(spanned(vlo, self.prev_span.hi, vr));\n+            variants.push(respan(vlo.to(self.prev_span), vr));\n \n             if !self.eat(&token::Comma) { break; }\n         }\n@@ -5518,7 +5493,7 @@ impl<'a> Parser<'a> {\n             Some(P(item))\n         });\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         let visibility = self.parse_visibility(false)?;\n \n@@ -5528,12 +5503,8 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Semi)?;\n \n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n-                                    keywords::Invalid.ident(),\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n+            let invalid = keywords::Invalid.ident();\n+            let item = self.mk_item(lo.to(prev_span), invalid, item_, visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -5553,8 +5524,7 @@ impl<'a> Parser<'a> {\n                                        respan(fn_span, Constness::NotConst),\n                                        abi)?;\n                 let prev_span = self.prev_span;\n-                let item = self.mk_item(lo,\n-                                        prev_span.hi,\n+                let item = self.mk_item(lo.to(prev_span),\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5576,8 +5546,7 @@ impl<'a> Parser<'a> {\n             };\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5601,8 +5570,7 @@ impl<'a> Parser<'a> {\n                                        respan(const_span, Constness::Const),\n                                        Abi::Rust)?;\n                 let prev_span = self.prev_span;\n-                let item = self.mk_item(lo,\n-                                        prev_span.hi,\n+                let item = self.mk_item(lo.to(prev_span),\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5619,8 +5587,7 @@ impl<'a> Parser<'a> {\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5636,8 +5603,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Unsafe)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5652,8 +5618,7 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Impl)?;\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Unsafe)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5669,8 +5634,7 @@ impl<'a> Parser<'a> {\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5693,8 +5657,7 @@ impl<'a> Parser<'a> {\n                                    respan(fn_span, Constness::NotConst),\n                                    abi)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5706,8 +5669,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(&attrs[..])?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5718,8 +5680,7 @@ impl<'a> Parser<'a> {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5730,8 +5691,7 @@ impl<'a> Parser<'a> {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5743,8 +5703,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Normal)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5755,8 +5714,7 @@ impl<'a> Parser<'a> {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Normal)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5767,8 +5725,7 @@ impl<'a> Parser<'a> {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5780,8 +5737,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5798,7 +5754,7 @@ impl<'a> Parser<'a> {\n     /// Parse a foreign item.\n     fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let visibility = self.parse_visibility(false)?;\n \n         if self.check_keyword(keywords::Static) {\n@@ -5825,7 +5781,7 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n         attributes_allowed: bool,\n-        lo: BytePos,\n+        lo: Span,\n         visibility: Visibility\n     ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && self.token.is_path_start() {\n@@ -5834,7 +5790,7 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&visibility, prev_span);\n \n-            let mac_lo = self.span.lo;\n+            let mac_lo = self.span;\n \n             // item macro.\n             let pth = self.parse_path(PathStyle::Mod)?;\n@@ -5860,9 +5816,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let hi = self.prev_span.hi;\n-            let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n-            let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n+            let hi = self.prev_span;\n+            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts: tts });\n+            let item = self.mk_item(lo.to(hi), id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -5890,7 +5846,7 @@ impl<'a> Parser<'a> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n                                  &token::CloseDelim(token::Brace),\n                                  SeqSep::trailing_allowed(token::Comma), |this| {\n-            let lo = this.span.lo;\n+            let lo = this.span;\n             let ident = if this.eat_keyword(keywords::SelfValue) {\n                 keywords::SelfValue.ident()\n             } else {\n@@ -5902,8 +5858,7 @@ impl<'a> Parser<'a> {\n                 rename: rename,\n                 id: ast::DUMMY_NODE_ID\n             };\n-            let hi = this.prev_span.hi;\n-            Ok(spanned(lo, hi, node))\n+            Ok(respan(lo.to(this.prev_span), node))\n         })\n     }\n \n@@ -5921,38 +5876,38 @@ impl<'a> Parser<'a> {\n     /// MOD_SEP? non_global_path MOD_SEP LBRACE item_seq RBRACE\n     /// MOD_SEP? LBRACE item_seq RBRACE\n     fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         if self.check(&token::OpenDelim(token::Brace)) || self.check(&token::BinOp(token::Star)) ||\n            self.is_import_coupler() {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             self.eat(&token::ModSep);\n             let prefix = ast::Path {\n                 segments: vec![PathSegment::crate_root()],\n-                span: mk_sp(lo, self.span.hi),\n+                span: lo.to(self.span),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {\n                 ViewPathGlob(prefix)\n             } else {\n                 ViewPathList(prefix, self.parse_path_list_items()?)\n             };\n-            Ok(P(spanned(lo, self.span.hi, view_path_kind)))\n+            Ok(P(respan(lo.to(self.span), view_path_kind)))\n         } else {\n             let prefix = self.parse_path(PathStyle::Mod)?.default_to_global();\n             if self.is_import_coupler() {\n                 // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();\n                 if self.check(&token::BinOp(token::Star)) {\n                     self.bump();\n-                    Ok(P(spanned(lo, self.span.hi, ViewPathGlob(prefix))))\n+                    Ok(P(respan(lo.to(self.span), ViewPathGlob(prefix))))\n                 } else {\n                     let items = self.parse_path_list_items()?;\n-                    Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n+                    Ok(P(respan(lo.to(self.span), ViewPathList(prefix, items))))\n                 }\n             } else {\n                 // `foo::bar` or `foo::bar as baz`\n                 let rename = self.parse_rename()?.\n                                   unwrap_or(prefix.segments.last().unwrap().identifier);\n-                Ok(P(spanned(lo, self.prev_span.hi, ViewPathSimple(rename, prefix))))\n+                Ok(P(respan(lo.to(self.prev_span), ViewPathSimple(rename, prefix))))\n             }\n         }\n     }\n@@ -5968,11 +5923,11 @@ impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main\n     /// entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n-            span: mk_sp(lo, self.span.lo),\n+            span: lo.to(self.span),\n         })\n     }\n "}, {"sha": "74aa3984a9a42a1f2917c59d5f1e69b7d6260bed", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -211,9 +211,7 @@ impl Token {\n             ModSep                      => true, // global path\n             Pound                       => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n-                NtExpr(..) => true,\n-                NtBlock(..) => true,\n-                NtPath(..) => true,\n+                NtIdent(..) | NtExpr(..) | NtBlock(..) | NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -236,8 +234,7 @@ impl Token {\n             Lt | BinOp(Shl)             => true, // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n-                NtTy(..) => true,\n-                NtPath(..) => true,\n+                NtIdent(..) | NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n             _ => false,\n@@ -252,14 +249,22 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is an identifier.\n-    pub fn is_ident(&self) -> bool {\n+    pub fn ident(&self) -> Option<ast::Ident> {\n         match *self {\n-            Ident(..)   => true,\n-            _           => false,\n+            Ident(ident) => Some(ident),\n+            Interpolated(ref nt) => match **nt {\n+                NtIdent(ident) => Some(ident.node),\n+                _ => None,\n+            },\n+            _ => None,\n         }\n     }\n \n+    /// Returns `true` if the token is an identifier.\n+    pub fn is_ident(&self) -> bool {\n+        self.ident().is_some()\n+    }\n+\n     /// Returns `true` if the token is a documentation comment.\n     pub fn is_doc_comment(&self) -> bool {\n         match *self {\n@@ -311,18 +316,15 @@ impl Token {\n \n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n-        match *self {\n-            Ident(id) => id.name == kw.name(),\n-            _ => false,\n-        }\n+        self.ident().map(|ident| ident.name == kw.name()).unwrap_or(false)\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n-        match *self {\n-            Ident(id) => id.name == keywords::Super.name() ||\n-                         id.name == keywords::SelfValue.name() ||\n-                         id.name == keywords::SelfType.name(),\n-            _ => false,\n+        match self.ident() {\n+            Some(id) => id.name == keywords::Super.name() ||\n+                        id.name == keywords::SelfValue.name() ||\n+                        id.name == keywords::SelfType.name(),\n+            None => false,\n         }\n     }\n \n@@ -333,18 +335,16 @@ impl Token {\n \n     /// Returns `true` if the token is a strict keyword.\n     pub fn is_strict_keyword(&self) -> bool {\n-        match *self {\n-            Ident(id) => id.name >= keywords::As.name() &&\n-                         id.name <= keywords::While.name(),\n+        match self.ident() {\n+            Some(id) => id.name >= keywords::As.name() && id.name <= keywords::While.name(),\n             _ => false,\n         }\n     }\n \n     /// Returns `true` if the token is a keyword reserved for possible future use.\n     pub fn is_reserved_keyword(&self) -> bool {\n-        match *self {\n-            Ident(id) => id.name >= keywords::Abstract.name() &&\n-                         id.name <= keywords::Yield.name(),\n+        match self.ident() {\n+            Some(id) => id.name >= keywords::Abstract.name() && id.name <= keywords::Yield.name(),\n             _ => false,\n         }\n     }"}, {"sha": "c7820a15fb3d23d9f8c0a6fb41c59e2e2af45012", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -10,29 +10,27 @@\n \n use ast;\n use attr;\n+use ext::hygiene::{Mark, SyntaxContext};\n use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::ParseSess;\n use ptr::P;\n use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n /// call to codemap's is_internal check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n-fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n-    let info = ExpnInfo {\n+fn ignored_span(sp: Span) -> Span {\n+    let mark = Mark::fresh();\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n-    };\n-    let expn_id = sess.codemap().record_expansion(info);\n-    let mut sp = sp;\n-    sp.expn_id = expn_id;\n-    return sp;\n+    });\n+    Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..sp }\n }\n \n pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n@@ -45,10 +43,7 @@ pub fn injected_crate_name(krate: &ast::Crate) -> Option<&'static str> {\n     }\n }\n \n-pub fn maybe_inject_crates_ref(sess: &ParseSess,\n-                               mut krate: ast::Crate,\n-                               alt_std_name: Option<String>)\n-                               -> ast::Crate {\n+pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<String>) -> ast::Crate {\n     let name = match injected_crate_name(&krate) {\n         Some(name) => name,\n         None => return krate,\n@@ -67,7 +62,7 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         span: DUMMY_SP,\n     }));\n \n-    let span = ignored_span(sess, DUMMY_SP);\n+    let span = ignored_span(DUMMY_SP);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,"}, {"sha": "50380626d7f0d484fc169440404d443be1087be9", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -31,6 +31,7 @@ use entry::{self, EntryPointType};\n use ext::base::{ExtCtxt, Resolver};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n+use ext::hygiene::{Mark, SyntaxContext};\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n@@ -62,6 +63,7 @@ struct TestCtxt<'a> {\n     testfns: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_test_crate: bool,\n+    ctxt: SyntaxContext,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -275,6 +277,7 @@ fn generate_test_harness(sess: &ParseSess,\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n+    let mark = Mark::fresh();\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n@@ -284,15 +287,16 @@ fn generate_test_harness(sess: &ParseSess,\n         reexport_test_harness_main: reexport_test_harness_main,\n         is_test_crate: is_test_crate(&krate),\n         toplevel_reexport: None,\n+        ctxt: SyntaxContext::empty().apply_mark(mark),\n     };\n     cx.ext_cx.crate_root = Some(\"std\");\n \n-    cx.ext_cx.bt_push(ExpnInfo {\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n-            allow_internal_unstable: false,\n+            allow_internal_unstable: true,\n         }\n     });\n \n@@ -307,18 +311,7 @@ fn generate_test_harness(sess: &ParseSess,\n /// call to codemap's is_internal check.\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n-    let info = ExpnInfo {\n-        call_site: sp,\n-        callee: NameAndSpan {\n-            format: MacroAttribute(Symbol::intern(\"test\")),\n-            span: None,\n-            allow_internal_unstable: true,\n-        }\n-    };\n-    let expn_id = cx.sess.codemap().record_expansion(info);\n-    let mut sp = sp;\n-    sp.expn_id = expn_id;\n-    return sp;\n+    Span { ctxt: cx.ctxt, ..sp }\n }\n \n #[derive(PartialEq)]"}, {"sha": "c537a0ee16644d7e241a9a157488a46c9f47e613", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -83,7 +83,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     Span {\n         lo: BytePos(start as u32),\n         hi: BytePos(end as u32),\n-        expn_id: NO_EXPANSION,\n+        ctxt: NO_EXPANSION,\n     }\n }\n "}, {"sha": "86bfdebe42b0082e206b6a836b66916ce4061846", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -56,18 +56,20 @@ impl Delimited {\n \n     /// Returns the opening delimiter as a token tree.\n     pub fn open_tt(&self, span: Span) -> TokenTree {\n-        let open_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span },\n+        let open_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { hi: span.lo + BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(open_span, self.open_token())\n     }\n \n     /// Returns the closing delimiter as a token tree.\n     pub fn close_tt(&self, span: Span) -> TokenTree {\n-        let close_span = match span {\n-            DUMMY_SP => DUMMY_SP,\n-            _ => Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span },\n+        let close_span = if span == DUMMY_SP {\n+            DUMMY_SP\n+        } else {\n+            Span { lo: span.hi - BytePos(self.delim.len() as u32), ..span }\n         };\n         TokenTree::Token(close_span, self.close_token())\n     }\n@@ -425,7 +427,7 @@ mod tests {\n         Span {\n             lo: BytePos(a),\n             hi: BytePos(b),\n-            expn_id: NO_EXPANSION,\n+            ctxt: NO_EXPANSION,\n         }\n     }\n "}, {"sha": "923e8072f43462ba10ab69acd40f2c935948d877", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -13,7 +13,6 @@\n use self::State::*;\n \n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n@@ -240,15 +239,6 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         }\n     }\n \n-    let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-        call_site: sp,\n-        callee: codemap::NameAndSpan {\n-            format: codemap::MacroBang(Symbol::intern(\"asm\")),\n-            span: None,\n-            allow_internal_unstable: false,\n-        },\n-    });\n-\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n@@ -260,7 +250,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n             volatile: volatile,\n             alignstack: alignstack,\n             dialect: dialect,\n-            expn_id: expn_id,\n+            ctxt: cx.backtrace(),\n         })),\n         span: sp,\n         attrs: ast::ThinVec::new(),"}, {"sha": "1993d6ebe5b493fc778e74c0455301da599da3b3", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -111,7 +111,7 @@ fn cs_clone_shallow(name: &str,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = super::allow_unstable(cx, span, \"derive(Clone)\");\n+        let span = Span { ctxt: cx.backtrace(), ..span};\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"clone\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "eef21492debc32440790ae38cb4049a745e48ba6", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -58,7 +58,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n-        let span = super::allow_unstable(cx, span, \"derive(Eq)\");\n+        let span = Span { ctxt: cx.backtrace(), ..span };\n         let assert_path = cx.path_all(span, true,\n                                         cx.std_path(&[\"cmp\", helper_name]),\n                                         vec![], vec![ty], vec![]);"}, {"sha": "ec4cb815960d1b6b35ca03f4eec966b90e384819", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -66,8 +66,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n     };\n \n-    // We want to make sure we have the expn_id set so that we can use unstable methods\n-    let span = Span { expn_id: cx.backtrace(), ..span };\n+    // We want to make sure we have the ctxt set so that we can use unstable methods\n+    let span = Span { ctxt: cx.backtrace(), ..span };\n     let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());"}, {"sha": "1ff0fec1c96a6c70959d6bddf2b75942cb00718f", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -375,7 +375,7 @@ fn find_type_parameters(ty: &ast::Ty,\n         }\n \n         fn visit_mac(&mut self, mac: &ast::Mac) {\n-            let span = Span { expn_id: self.span.expn_id, ..mac.span };\n+            let span = Span { ctxt: self.span.ctxt, ..mac.span };\n             self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n         }\n     }\n@@ -1458,7 +1458,7 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let ident = v.node.name;\n-                let sp = Span { expn_id: trait_.span.expn_id, ..v.span };\n+                let sp = Span { ctxt: trait_.span.ctxt, ..v.span };\n                 let summary = trait_.summarise_struct(cx, &v.node.data);\n                 (ident, sp, summary)\n             })\n@@ -1478,7 +1478,7 @@ impl<'a> TraitDef<'a> {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n         for field in struct_def.fields() {\n-            let sp = Span { expn_id: self.span.expn_id, ..field.span };\n+            let sp = Span { ctxt: self.span.ctxt, ..field.span };\n             match field.ident {\n                 Some(ident) => named_idents.push((ident, sp)),\n                 _ => just_spans.push(sp),\n@@ -1523,7 +1523,7 @@ impl<'a> TraitDef<'a> {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n-            let sp = Span { expn_id: self.span.expn_id, ..struct_field.span };\n+            let sp = Span { ctxt: self.span.ctxt, ..struct_field.span };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned {\n                 span: sp,\n@@ -1544,7 +1544,7 @@ impl<'a> TraitDef<'a> {\n                             cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n                         }\n                         codemap::Spanned {\n-                            span: Span { expn_id: self.span.expn_id, ..pat.span },\n+                            span: Span { ctxt: self.span.ctxt, ..pat.span },\n                             node: ast::FieldPat {\n                                 ident: ident.unwrap(),\n                                 pat: pat,\n@@ -1576,7 +1576,7 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n-        let sp = Span { expn_id: self.span.expn_id, ..variant.span };\n+        let sp = Span { ctxt: self.span.ctxt, ..variant.span };\n         let variant_path = cx.path(sp, vec![enum_ident, variant_ident]);\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }"}, {"sha": "b2bb43e41ed9ee0763c67208736cf36e558ee556", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -12,9 +12,9 @@\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver};\n use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -74,20 +74,6 @@ pub mod ord;\n \n pub mod generic;\n \n-fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n-    Span {\n-        expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-            call_site: span,\n-            callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n-                span: Some(span),\n-                allow_internal_unstable: true,\n-            },\n-        }),\n-        ..span\n-    }\n-}\n-\n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n         pub fn is_builtin_trait(name: ast::Name) -> bool {\n@@ -177,15 +163,15 @@ fn call_intrinsic(cx: &ExtCtxt,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n-        call_site: span,\n-        callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(Symbol::intern(\"derive\")),\n-            span: Some(span),\n-            allow_internal_unstable: true,\n-        },\n-    });\n-\n+    if cx.current_expansion.mark.expn_info().unwrap().callee.allow_internal_unstable {\n+        span.ctxt = cx.backtrace();\n+    } else { // Avoid instability errors with user defined curstom derives, cc #36316\n+        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n+        info.callee.allow_internal_unstable = true;\n+        let mark = Mark::fresh();\n+        mark.set_expn_info(info);\n+        span.ctxt = SyntaxContext::empty().apply_mark(mark);\n+    }\n     let path = cx.std_path(&[\"intrinsics\", intrinsic]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "6f5ab50b2fe6fd410b2d48d12ec5e462d0f854a7", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -559,11 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n-                locals.push(Context::format_arg(self.ecx,\n-                                                self.macsp,\n-                                                e.span,\n-                                                arg_ty,\n-                                                self.ecx.expr_ident(e.span, name)));\n+                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n             }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n@@ -576,11 +572,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 Exact(i) => spans_pos[i],\n                 _ => panic!(\"should never happen\"),\n             };\n-            counts.push(Context::format_arg(self.ecx,\n-                                            self.macsp,\n-                                            span,\n-                                            &Count,\n-                                            self.ecx.expr_ident(span, name)));\n+            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count, name));\n         }\n \n         // Now create a vector containing all the arguments\n@@ -641,10 +633,12 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn format_arg(ecx: &ExtCtxt,\n                   macsp: Span,\n-                  sp: Span,\n+                  mut sp: Span,\n                   ty: &ArgumentType,\n-                  arg: P<ast::Expr>)\n+                  arg: ast::Ident)\n                   -> P<ast::Expr> {\n+        sp.ctxt = sp.ctxt.apply_mark(ecx.current_expansion.mark);\n+        let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n                 match &tyname[..] {"}, {"sha": "bb89caab709b0e8831c0eee51d742c7e4c120e9a", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -17,6 +17,7 @@ use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::fold::Folder;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n@@ -360,15 +361,16 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                 custom_derives: &[ProcMacroDerive],\n                 custom_attrs: &[ProcMacroDef],\n                 custom_macros: &[ProcMacroDef]) -> P<ast::Item> {\n-    let eid = cx.codemap().record_expansion(ExpnInfo {\n+    let mark = Mark::fresh();\n+    mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n             format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n     });\n-    let span = Span { expn_id: eid, ..DUMMY_SP };\n+    let span = Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..DUMMY_SP };\n \n     let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,"}, {"sha": "8a9ff647b3ea1b9a4504aa55f3ccd4f0766a212c", "filename": "src/libsyntax_pos/hygiene.rs", "status": "renamed", "additions": 89, "deletions": 14, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -15,13 +15,16 @@\n //! and definition contexts*. J. Funct. Program. 22, 2 (March 2012), 181-216.\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n-use ast::NodeId;\n+use Span;\n+use symbol::Symbol;\n+\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Default)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n #[derive(Copy, Clone)]\n@@ -37,8 +40,8 @@ pub struct Mark(u32);\n impl Mark {\n     pub fn fresh() -> Self {\n         HygieneData::with(|data| {\n-            let next_mark = Mark(data.next_mark.0 + 1);\n-            ::std::mem::replace(&mut data.next_mark, next_mark)\n+            data.marks.push(None);\n+            Mark(data.marks.len() as u32 - 1)\n         })\n     }\n \n@@ -47,34 +50,38 @@ impl Mark {\n         Mark(0)\n     }\n \n-    pub fn from_placeholder_id(id: NodeId) -> Self {\n-        Mark(id.as_u32())\n+    pub fn as_u32(self) -> u32 {\n+        self.0\n     }\n \n-    pub fn as_placeholder_id(self) -> NodeId {\n-        NodeId::from_u32(self.0)\n+    pub fn from_u32(raw: u32) -> Mark {\n+        Mark(raw)\n     }\n \n-    pub fn as_u32(self) -> u32 {\n-        self.0\n+    pub fn expn_info(self) -> Option<ExpnInfo> {\n+        HygieneData::with(|data| data.marks[self.0 as usize].clone())\n+    }\n+\n+    pub fn set_expn_info(self, info: ExpnInfo) {\n+        HygieneData::with(|data| data.marks[self.0 as usize] = Some(info))\n     }\n }\n \n struct HygieneData {\n+    marks: Vec<Option<ExpnInfo>>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    next_mark: Mark,\n }\n \n impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n+            marks: vec![None],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n                 prev_ctxt: SyntaxContext::empty(),\n             }],\n             markings: HashMap::new(),\n-            next_mark: Mark(1),\n         }\n     }\n \n@@ -86,8 +93,8 @@ impl HygieneData {\n     }\n }\n \n-pub fn reset_hygiene_data() {\n-    HygieneData::with(|data| *data = HygieneData::new())\n+pub fn clear_markings() {\n+    HygieneData::with(|data| data.markings = HashMap::new());\n }\n \n impl SyntaxContext {\n@@ -118,10 +125,78 @@ impl SyntaxContext {\n             })\n         })\n     }\n+\n+    pub fn outer(self) -> Mark {\n+        HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"#{}\", self.0)\n     }\n }\n+\n+/// Extra information for tracking spans of macro and syntax sugar expansion\n+#[derive(Clone, Hash, Debug)]\n+pub struct ExpnInfo {\n+    /// The location of the actual macro invocation or syntax sugar , e.g.\n+    /// `let x = foo!();` or `if let Some(y) = x {}`\n+    ///\n+    /// This may recursively refer to other macro invocations, e.g. if\n+    /// `foo!()` invoked `bar!()` internally, and there was an\n+    /// expression inside `bar!`; the call_site of the expression in\n+    /// the expansion would point to the `bar!` invocation; that\n+    /// call_site span would have its own ExpnInfo, with the call_site\n+    /// pointing to the `foo!` invocation.\n+    pub call_site: Span,\n+    /// Information about the expansion.\n+    pub callee: NameAndSpan\n+}\n+\n+#[derive(Clone, Hash, Debug)]\n+pub struct NameAndSpan {\n+    /// The format with which the macro was invoked.\n+    pub format: ExpnFormat,\n+    /// Whether the macro is allowed to use #[unstable]/feature-gated\n+    /// features internally without forcing the whole crate to opt-in\n+    /// to them.\n+    pub allow_internal_unstable: bool,\n+    /// The span of the macro definition itself. The macro may not\n+    /// have a sensible definition span (e.g. something defined\n+    /// completely inside libsyntax) in which case this is None.\n+    pub span: Option<Span>\n+}\n+\n+impl NameAndSpan {\n+    pub fn name(&self) -> Symbol {\n+        match self.format {\n+            ExpnFormat::MacroAttribute(s) |\n+            ExpnFormat::MacroBang(s) |\n+            ExpnFormat::CompilerDesugaring(s) => s,\n+        }\n+    }\n+}\n+\n+/// The source of expansion.\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+pub enum ExpnFormat {\n+    /// e.g. #[derive(...)] <item>\n+    MacroAttribute(Symbol),\n+    /// e.g. `format!()`\n+    MacroBang(Symbol),\n+    /// Desugaring done by the compiler during HIR lowering.\n+    CompilerDesugaring(Symbol)\n+}\n+\n+impl Encodable for SyntaxContext {\n+    fn encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n+        Ok(()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}\n+\n+impl Decodable for SyntaxContext {\n+    fn decode<D: Decoder>(_: &mut D) -> Result<SyntaxContext, D::Error> {\n+        Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n+    }\n+}", "previous_filename": "src/libsyntax/ext/hygiene.rs"}, {"sha": "947192a0a23e0760e34b3a7e39ad40a5ff871d7f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 86, "deletions": 36, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -23,7 +23,9 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![deny(warnings)]\n \n+#![feature(const_fn)]\n #![feature(custom_attribute)]\n+#![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -41,6 +43,11 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n+pub mod hygiene;\n+pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan};\n+\n+pub mod symbol;\n+\n pub type FileName = String;\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n@@ -57,7 +64,7 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_id: ExpnId\n+    pub ctxt: SyntaxContext,\n }\n \n /// A collection of spans. Spans have two orthogonal attributes:\n@@ -76,7 +83,7 @@ impl Span {\n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(self) -> Span {\n         let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n-        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n+        Span { lo: BytePos(lo), hi: self.hi, ctxt: self.ctxt }\n     }\n \n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n@@ -104,6 +111,78 @@ impl Span {\n             None\n         }\n     }\n+\n+    /// Return the source span - this is either the supplied span, or the span for\n+    /// the macro callsite that expanded to it.\n+    pub fn source_callsite(self) -> Span {\n+        self.ctxt.outer().expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+    }\n+\n+    /// Return the source callee.\n+    ///\n+    /// Returns None if the supplied span has no expansion trace,\n+    /// else returns the NameAndSpan for the macro definition\n+    /// corresponding to the source callsite.\n+    pub fn source_callee(self) -> Option<NameAndSpan> {\n+        fn source_callee(info: ExpnInfo) -> NameAndSpan {\n+            match info.call_site.ctxt.outer().expn_info() {\n+                Some(info) => source_callee(info),\n+                None => info.callee,\n+            }\n+        }\n+        self.ctxt.outer().expn_info().map(source_callee)\n+    }\n+\n+    /// Check if a span is \"internal\" to a macro in which #[unstable]\n+    /// items can be used (that is, a macro marked with\n+    /// `#[allow_internal_unstable]`).\n+    pub fn allows_unstable(&self) -> bool {\n+        match self.ctxt.outer().expn_info() {\n+            Some(info) => info.callee.allow_internal_unstable,\n+            None => false,\n+        }\n+    }\n+\n+    pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n+        let mut prev_span = DUMMY_SP;\n+        let mut result = vec![];\n+        loop {\n+            let info = match self.ctxt.outer().expn_info() {\n+                Some(info) => info,\n+                None => break,\n+            };\n+\n+            let (pre, post) = match info.callee.format {\n+                ExpnFormat::MacroAttribute(..) => (\"#[\", \"]\"),\n+                ExpnFormat::MacroBang(..) => (\"\", \"!\"),\n+                ExpnFormat::CompilerDesugaring(..) => (\"desugaring of `\", \"`\"),\n+            };\n+            let macro_decl_name = format!(\"{}{}{}\", pre, info.callee.name(), post);\n+            let def_site_span = info.callee.span;\n+\n+            // Don't print recursive invocations\n+            if !info.call_site.source_equal(&prev_span) {\n+                result.push(MacroBacktrace {\n+                    call_site: info.call_site,\n+                    macro_decl_name: macro_decl_name,\n+                    def_site_span: def_site_span,\n+                });\n+            }\n+\n+            prev_span = self;\n+            self = info.call_site;\n+        }\n+        result\n+    }\n+\n+    pub fn to(self, end: Span) -> Span {\n+        // FIXME(jseyfried): self.ctxt should always equal end.ctxt here (c.f. issue #23480)\n+        if end.ctxt == SyntaxContext::empty() {\n+            Span { lo: self.lo, ..end }\n+        } else {\n+            Span { hi: end.hi, ..self }\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -138,14 +217,14 @@ impl serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(mk_sp(lo, hi))\n+            Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n         })\n     }\n }\n \n fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n-    write!(f, \"Span {{ lo: {:?}, hi: {:?}, expn_id: {:?} }}\",\n-           span.lo, span.hi, span.expn_id)\n+    write!(f, \"Span {{ lo: {:?}, hi: {:?}, ctxt: {:?} }}\",\n+           span.lo, span.hi, span.ctxt)\n }\n \n impl fmt::Debug for Span {\n@@ -154,12 +233,7 @@ impl fmt::Debug for Span {\n     }\n }\n \n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n-\n-// Generic span to be used for code originating from the command line\n-pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n-                                         hi: BytePos(0),\n-                                         expn_id: COMMAND_LINE_EXPN };\n+pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n \n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n@@ -253,26 +327,7 @@ impl From<Span> for MultiSpan {\n     }\n }\n \n-#[derive(PartialEq, Eq, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Copy, Ord, PartialOrd)]\n-pub struct ExpnId(pub u32);\n-\n-pub const NO_EXPANSION: ExpnId = ExpnId(!0);\n-// For code appearing from the command line\n-pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(!1);\n-\n-// For code generated by a procedural macro, without knowing which\n-// Used in `qquote!`\n-pub const PROC_EXPN: ExpnId = ExpnId(!2);\n-\n-impl ExpnId {\n-    pub fn from_u32(id: u32) -> ExpnId {\n-        ExpnId(id)\n-    }\n-\n-    pub fn into_u32(self) -> u32 {\n-        self.0\n-    }\n-}\n+pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n \n /// Identifies an offset of a multi-byte character in a FileMap\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n@@ -650,11 +705,6 @@ pub struct FileLines {\n thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::Result> =\n                 Cell::new(default_span_debug));\n \n-/* assuming that we're not in macro expansion */\n-pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n-}\n-\n pub struct MacroBacktrace {\n     /// span where macro was applied to generate this code\n     pub call_site: Span,"}, {"sha": "b866652c49f854c67d7ab415c2753cc508bb4710", "filename": "src/libsyntax_pos/symbol.rs", "status": "renamed", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -12,11 +12,58 @@\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n+use hygiene::SyntaxContext;\n+\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Ident {\n+    pub name: Symbol,\n+    pub ctxt: SyntaxContext,\n+}\n+\n+impl Ident {\n+    pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n+        Ident { name: name, ctxt: SyntaxContext::empty() }\n+    }\n+\n+    /// Maps a string to an identifier with an empty syntax context.\n+    pub fn from_str(string: &str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::intern(string))\n+    }\n+\n+    pub fn unhygienize(self) -> Ident {\n+        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    }\n+}\n+\n+impl fmt::Debug for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}{:?}\", self.name, self.ctxt)\n+    }\n+}\n+\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.name, f)\n+    }\n+}\n+\n+impl Encodable for Ident {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.name.encode(s)\n+    }\n+}\n+\n+impl Decodable for Ident {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n+        Ok(Ident::with_empty_ctxt(Symbol::decode(d)?))\n+    }\n+}\n+\n /// A symbol is an interned or gensymed string.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Symbol(u32);\n@@ -128,19 +175,19 @@ macro_rules! declare_keywords {(\n     $( ($index: expr, $konst: ident, $string: expr) )*\n ) => {\n     pub mod keywords {\n-        use ast;\n+        use super::{Symbol, Ident};\n         #[derive(Clone, Copy, PartialEq, Eq)]\n         pub struct Keyword {\n-            ident: ast::Ident,\n+            ident: Ident,\n         }\n         impl Keyword {\n-            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n-            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n+            #[inline] pub fn ident(self) -> Ident { self.ident }\n+            #[inline] pub fn name(self) -> Symbol { self.ident.name }\n         }\n         $(\n             #[allow(non_upper_case_globals)]\n             pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(super::Symbol($index))\n+                ident: Ident::with_empty_ctxt(super::Symbol($index))\n             };\n         )*\n     }", "previous_filename": "src/libsyntax/symbol.rs"}, {"sha": "272bf1150cacbfa77a8fa06c736b36dd87fa766b", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -27,14 +27,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");"}, {"sha": "7c19917acc476b398b6ffa4545a774dd5fa507e3", "filename": "src/test/compile-fail/imports/macro-paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -25,7 +25,6 @@ fn f() {\n     bar::m! { //~ ERROR ambiguous\n               //~| NOTE macro-expanded items do not shadow when used in a macro invocation path\n         mod bar { pub use two_macros::m; } //~ NOTE could refer to the name defined here\n-                                           //~^^^ NOTE in this expansion\n     }\n }\n \n@@ -37,6 +36,5 @@ fn g() {\n     baz::m! { //~ ERROR ambiguous\n               //~| NOTE macro-expanded items do not shadow when used in a macro invocation path\n         mod baz { pub use two_macros::m; } //~ NOTE could refer to the name defined here\n-                                           //~^^^ NOTE in this expansion\n     }\n }"}, {"sha": "06b0964a3b14528f1eaf71845d344b6a516f7fa0", "filename": "src/test/compile-fail/imports/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -28,7 +28,6 @@ mod m2 {\n     m! { //~ ERROR ambiguous\n          //~| NOTE macro-expanded macro imports do not shadow\n         use foo::m; //~ NOTE could refer to the name imported here\n-                    //~^^^ NOTE in this expansion\n     }\n }\n \n@@ -43,7 +42,6 @@ mod m3 {\n         m! { //~ ERROR ambiguous\n              //~| NOTE macro-expanded macro imports do not shadow\n             use two_macros::n as m; //~ NOTE could refer to the name imported here\n-                                    //~^^^ NOTE in this expansion\n         }\n     }\n }"}, {"sha": "a7f1cf3c9d3ef92b37dedb4103f5650b5ccc09b6", "filename": "src/test/compile-fail/imports/shadow_builtin_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -31,7 +31,6 @@ mod m2 {\n \n mod m3 {\n     ::two_macros::m!(use foo::panic;); //~ NOTE `panic` could refer to the name imported here\n-    //~| NOTE in this expansion\n     fn f() { panic!(); } //~ ERROR ambiguous\n     //~| NOTE `panic` is also a builtin macro\n     //~| NOTE macro-expanded macro imports do not shadow"}, {"sha": "4aacb6840e9d51f22a578ba7c8cc950c08aed1e5", "filename": "src/test/compile-fail/issue-25385.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -21,5 +21,4 @@ fn main() {\n \n     foo!(1i32.foo());\n     //~^ ERROR no method named `foo` found for type `i32` in the current scope\n-    //~^^ NOTE in this expansion of foo!\n }"}, {"sha": "5518ab47c2bd2e0570965a81b39ba2005d7d9759", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -30,14 +30,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     println!(\"{}\", pprust::expr_to_string(&*quote_expr!(&cx, 23)));"}, {"sha": "4a8246ec429c0d1849f5b43879c2e1544f4095f6", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -26,14 +26,6 @@ fn main() {\n         &ps,\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n         &mut resolver);\n-    cx.bt_push(syntax::codemap::ExpnInfo {\n-        call_site: DUMMY_SP,\n-        callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n-            allow_internal_unstable: false,\n-            span: None,\n-        }\n-    });\n     let cx = &mut cx;\n \n     macro_rules! check {"}, {"sha": "25c7417f7eb21a8d94dec38b35865b2207b485d2", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -22,7 +22,7 @@ macro_rules! indirect_line { () => ( line!() ) }\n \n pub fn main() {\n     assert_eq!(line!(), 24);\n-    assert_eq!(column!(), 4);\n+    assert_eq!(column!(), 15);\n     assert_eq!(indirect_line!(), 26);\n     assert!((file!().ends_with(\"syntax-extension-source-utils.rs\")));\n     assert_eq!(stringify!((2*3) + 5).to_string(), \"( 2 * 3 ) + 5\".to_string());"}, {"sha": "e4044f5aaf2be36fb528efdf369ea57eca5b3032", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe151194e9a919ab23c2bb356767a5cbfa3811e7/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=fe151194e9a919ab23c2bb356767a5cbfa3811e7", "patch": "@@ -2,10 +2,7 @@ error[E0433]: failed to resolve. Use of undeclared type or module `m`\n   --> $DIR/macro_path_as_generic_bound.rs:17:6\n    |\n 17 | foo!(m::m2::A);\n-   | -----^^^^^^^^--\n-   | |    |\n-   | |    Use of undeclared type or module `m`\n-   | in this macro invocation\n+   |      ^^^^^^^^ Use of undeclared type or module `m`\n \n error: cannot continue compilation due to previous error\n "}]}