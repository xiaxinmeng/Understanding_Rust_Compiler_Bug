{"sha": "06c371605b3e2ad8068e359f28d4c77dccad0237", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YzM3MTYwNWIzZTJhZDgwNjhlMzU5ZjI4ZDRjNzdkY2NhZDAyMzc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T03:39:10Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-03-26T13:59:17Z"}, "message": "Fixed all use sites and tests", "tree": {"sha": "c278469b73160ec34c7d79a35b646aeb28e11c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c278469b73160ec34c7d79a35b646aeb28e11c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c371605b3e2ad8068e359f28d4c77dccad0237", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c371605b3e2ad8068e359f28d4c77dccad0237", "html_url": "https://github.com/rust-lang/rust/commit/06c371605b3e2ad8068e359f28d4c77dccad0237", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c371605b3e2ad8068e359f28d4c77dccad0237/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c99488b3a4045171e36bcd2a89e742ac06d3ba72", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99488b3a4045171e36bcd2a89e742ac06d3ba72", "html_url": "https://github.com/rust-lang/rust/commit/c99488b3a4045171e36bcd2a89e742ac06d3ba72"}], "stats": {"total": 380, "additions": 204, "deletions": 176}, "files": [{"sha": "5a35c56c075a7b61350badb5ca155738057a399b", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -142,7 +142,8 @@ fn parse_check_line(line: ~str) -> Option<~str> {\n fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let strs = str::splitn_char(*nv, '=', 1u);\n+        let mut strs = ~[];\n+        for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n         match strs.len() {\n           1u => (strs[0], ~\"\"),\n           2u => (strs[0], strs[1]),"}, {"sha": "ed66aea4f0ce7d56ef75e15b799882705e275cc4", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -267,7 +267,7 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::lines_each(ProcRes.stdout) |line| {\n+        for str::each_line(ProcRes.stdout) |line| {\n             if props.check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -297,7 +297,7 @@ fn check_error_patterns(props: TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::lines_each(ProcRes.stderr) |line| {\n+    for str::each_line(ProcRes.stderr) |line| {\n         if str::contains(line, next_err_pat) {\n             debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -347,7 +347,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::lines_each(ProcRes.stderr) |line| {\n+    for str::each_line(ProcRes.stderr) |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n@@ -596,8 +596,12 @@ fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n     }\n \n     match argstr {\n-      Some(s) => rm_whitespace(str::split_char(s, ' ')),\n-      None => ~[]\n+        Some(s) => {\n+            let mut ss = ~[];\n+            for str::each_split_char(s, ' ') |s| { ss.push(s.to_owned()) }\n+            rm_whitespace(ss)\n+        }\n+        None => ~[]\n     }\n }\n "}, {"sha": "1b3761a0db8a7f063256f03c6ceadd53d551227a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 141, "deletions": 137, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -2586,36 +2586,40 @@ mod tests {\n     fn test_split_char() {\n         fn t(s: &str, c: char, u: &[~str]) {\n             debug!(~\"split_byte: \" + s);\n-            let v = split_char(s, c);\n+            let mut v = ~[];\n+            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]\n-                     == split_char(~\"...hello.there.\", '.'));\n-\n-        fail_unless!(~[~\"\"] == split_char(~\"\", 'z'));\n-        fail_unless!(~[~\"\",~\"\"] == split_char(~\"z\", 'z'));\n-        fail_unless!(~[~\"ok\"] == split_char(~\"ok\", 'z'));\n+        t(~\"\", 'z', ~[~\"\"]);\n+        t(~\"z\", 'z', ~[~\"\",~\"\"]);\n+        t(~\"ok\", 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_2() {\n+        fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let mut v = ~[];\n+            for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == split_char(data, 'V'));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == split_char(data, '\u0e17'));\n+        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_splitn_char() {\n         fn t(s: &str, c: char, n: uint, u: &[~str]) {\n             debug!(~\"splitn_byte: \" + s);\n-            let v = splitn_char(s, c, n);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n@@ -2627,188 +2631,188 @@ mod tests {\n         t(~\".hello.there\", '.', 0u, ~[~\".hello.there\"]);\n         t(~\".hello.there\", '.', 1u, ~[~\"\", ~\"hello.there\"]);\n         t(~\"...hello.there.\", '.', 3u, ~[~\"\", ~\"\", ~\"\", ~\"hello.there.\"]);\n-        t(~\"...hello.there.\", '.', 5u,\n-          ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"...hello.there.\", '.', 5u, ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n \n-        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n-        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n-        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n-        fail_unless!(~[~\"z\"] == splitn_char(~\"z\", 'z', 0u));\n-        fail_unless!(~[~\"w.x.y\"] == splitn_char(~\"w.x.y\", '.', 0u));\n-        fail_unless!(~[~\"w\",~\"x.y\"] == splitn_char(~\"w.x.y\", '.', 1u));\n+        t(~\"\", 'z', 5u, ~[~\"\"]);\n+        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n+        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n+        t(~\"z\", 'z', 0u, ~[~\"z\"]);\n+        t(~\"w.x.y\", '.', 0u, ~[~\"w.x.y\"]);\n+        t(~\"w.x.y\", '.', 1u, ~[~\"w\",~\"x.y\"]);\n     }\n \n     #[test]\n     fn test_splitn_char_2 () {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == splitn_char(data, '\u534e', 1u));\n+        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n+            debug!(~\"splitn_byte: \" + s);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            debug!(\"comparing vs. %?\", u);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]\n-                     == splitn_char(~\"zzXXXzYYYzWWWz\", 'z', 3u));\n-        fail_unless!(~[~\"\",~\"\"] == splitn_char(~\"z\", 'z', 5u));\n-        fail_unless!(~[~\"\"] == splitn_char(~\"\", 'z', 5u));\n-        fail_unless!(~[~\"ok\"] == splitn_char(~\"ok\", 'z', 5u));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYzWWWz\", 'z', 3u, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYYzWWWz\"]);\n+        t(~\"z\", 'z', 5u, ~[~\"\",~\"\"]);\n+        t(~\"\", 'z', 5u, ~[~\"\"]);\n+        t(~\"ok\", 'z', 5u, ~[~\"ok\"]);\n     }\n \n \n     #[test]\n     fn test_splitn_char_3() {\n+        fn t(s: &str, c: char, n: uint, u: &[~str]) {\n+            debug!(~\"splitn_byte: \" + s);\n+            let mut v = ~[];\n+            for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            debug!(\"comparing vs. %?\", u);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == splitn_char(data, 'V', 1u));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == splitn_char(data, '\u0e17', 1u));\n-\n+        t(data, 'V', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', 1u, ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing() {\n-     fn t(s: &str, c: char, u: &[~str]) {\n+        fn t(s: &str, c: char, u: &[~str]) {\n             debug!(~\"split_byte: \" + s);\n-            let v = split_char_no_trailing(s, c);\n+            let mut v = ~[];\n+            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n         t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n         t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n \n-        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]\n-                     == split_char_no_trailing(~\"...hello.there.\", '.'));\n-\n-        fail_unless!(~[] == split_char_no_trailing(~\"\", 'z'));\n-        fail_unless!(~[~\"\"] == split_char_no_trailing(~\"z\", 'z'));\n-        fail_unless!(~[~\"ok\"] == split_char_no_trailing(~\"ok\", 'z'));\n+        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"\", 'z', ~[]);\n+        t(~\"z\", 'z', ~[~\"\"]);\n+        t(~\"ok\", 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_char_no_trailing_2() {\n+        fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let mut v = ~[];\n+            for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n-                     == split_char_no_trailing(data, 'V'));\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n-                     == split_char_no_trailing(data, '\u0e17'));\n+        t(data, 'V', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n+        t(data, '\u0e17', ~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]);\n     }\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: &str, sep: &'a str, i: int, k: &str) {\n-            fn borrow(x: &'a str) -> &'a str { x }\n-            let v = split_str(s, sep);\n-            fail_unless!(borrow(v[i]) == k);\n+        fn t(s: &str, sep: &'a str, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n         }\n-\n-        t(~\"--1233345--\", ~\"12345\", 0, ~\"--1233345--\");\n-        t(~\"abc::hello::there\", ~\"::\", 0, ~\"abc\");\n-        t(~\"abc::hello::there\", ~\"::\", 1, ~\"hello\");\n-        t(~\"abc::hello::there\", ~\"::\", 2, ~\"there\");\n-        t(~\"::hello::there\", ~\"::\", 0, ~\"\");\n-        t(~\"hello::there::\", ~\"::\", 2, ~\"\");\n-        t(~\"::hello::there::\", ~\"::\", 3, ~\"\");\n-\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]\n-                     == split_str (data, ~\"\u4e2d\u534e\"));\n-\n-        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-                     == split_str(~\"zzXXXzzYYYzz\", ~\"zz\"));\n-\n-        fail_unless!(~[~\"zz\", ~\"zYYYz\"] == split_str(~\"zzXXXzYYYz\", ~\"XXX\"));\n-\n-\n-        fail_unless!(~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"] ==\n-                     split_str(~\".XXX.YYY.\", ~\".\"));\n-        fail_unless!(~[~\"\"] == split_str(~\"\", ~\".\"));\n-        fail_unless!(~[~\"\",~\"\"] == split_str(~\"zz\", ~\"zz\"));\n-        fail_unless!(~[~\"ok\"] == split_str(~\"ok\", ~\"z\"));\n-        fail_unless!(~[~\"\",~\"z\"] == split_str(~\"zzz\", ~\"zz\"));\n-        fail_unless!(~[~\"\",~\"\",~\"z\"] == split_str(~\"zzzzz\", ~\"zz\"));\n+        t(~\"--1233345--\", ~\"12345\", ~[~\"--1233345--\"]);\n+        t(~\"abc::hello::there\", ~\"::\", ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\"::hello::there\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"hello::there::\", ~\"::\", ~[~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"::hello::there::\", ~\"::\", ~[~\"\", ~\"hello\", ~\"there\", ~\"\"]);\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", ~\"\u4e2d\u534e\", ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzzYYYzz\", ~\"zz\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"zzXXXzYYYz\", ~\"XXX\", ~[~\"zz\", ~\"zYYYz\"]);\n+        t(~\".XXX.YYY.\", ~\".\", ~[~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"\", ~\".\", ~[~\"\"]);\n+        t(~\"zz\", ~\"zz\", ~[~\"\",~\"\"]);\n+        t(~\"ok\", ~\"z\", ~[~\"ok\"]);\n+        t(~\"zzz\", ~\"zz\", ~[~\"\",~\"z\"]);\n+        t(~\"zzzzz\", ~\"zz\", ~[~\"\",~\"\",~\"z\"]);\n     }\n \n \n     #[test]\n     fn test_split() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == split (data, |cc| cc == '\u534e'));\n-\n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]\n-                     == split(~\"zzXXXzYYYz\", char::is_lowercase));\n-\n-        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-                     == split(~\"zzXXXzYYYz\", char::is_uppercase));\n+        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\",~\"\"] == split(~\"z\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"\"] == split(~\"\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\", ~\"\"]);\n+        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(~\"z\", |cc| cc == 'z', ~[~\"\",~\"\"]);\n+        t(~\"\", |cc| cc == 'z', ~[~\"\"]);\n+        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_split_no_trailing() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n-                     == split_no_trailing (data, |cc| cc == '\u534e'));\n-\n-        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]\n-                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_lowercase));\n-\n-        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n-                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_uppercase));\n+        fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[~\"\"] == split_no_trailing(~\"z\", |cc| cc == 'z'));\n-        fail_unless!(~[] == split_no_trailing(~\"\", |cc| cc == 'z'));\n-        fail_unless!(~[~\"ok\"] == split_no_trailing(~\"ok\", |cc| cc == 'z'));\n+        t(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', ~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n+        t(~\"zzXXXzYYYz\", char::is_lowercase, ~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]);\n+        t(~\"zzXXXzYYYz\", char::is_uppercase, ~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]);\n+        t(~\"z\", |cc| cc == 'z', ~[~\"\"]);\n+        t(~\"\", |cc| cc == 'z', ~[]);\n+        t(~\"ok\", |cc| cc == 'z', ~[~\"ok\"]);\n     }\n \n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-                     == lines(lf));\n-\n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-                     == lines_any(lf));\n-\n-        fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n-                       ~\"Little lamb\\r\"]\n-            == lines(crlf));\n-\n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n-            == lines_any(crlf));\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+            let mut v = ~[];\n+            for f(s) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n \n-        fail_unless!(~[] == lines    (~\"\"));\n-        fail_unless!(~[] == lines_any(~\"\"));\n-        fail_unless!(~[~\"\"] == lines    (~\"\\n\"));\n-        fail_unless!(~[~\"\"] == lines_any(~\"\\n\"));\n-        fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n-        fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n+        t(lf, each_line ,~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(lf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(crlf, each_line, ~[~\"\\r\", ~\"Mary had a little lamb\\r\", ~\"Little lamb\\r\"]);\n+        t(crlf, each_line_any, ~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n+        t(~\"\", each_line, ~[]);\n+        t(~\"\", each_line_any, ~[]);\n+        t(~\"\\n\", each_line, ~[~\"\"]);\n+        t(~\"\\n\", each_line_any, ~[~\"\"]);\n+        t(~\"banana\", each_line, ~[~\"banana\"]);\n+        t(~\"banana\", each_line_any, ~[~\"banana\"]);\n     }\n \n     #[test]\n     fn test_words () {\n+        fn t(s: &str, f: &fn(&str, &fn(&str) -> bool), u: &[~str]) {\n+            let mut v = ~[];\n+            for f(s) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        fail_unless!(~[\n-            ~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]\n-            == words(data));\n \n-        fail_unless!(~[~\"ok\"] == words(~\"ok\"));\n-        fail_unless!(~[] == words(~\"\"));\n+        t(data, each_word, ~[~\"Mary\",~\"had\",~\"a\",~\"little\",~\"lamb\",~\"Little\",~\"lamb\"]);\n+        t(~\"ok\", each_word, ~[~\"ok\"]);\n+        t(~\"\", each_word, ~[]);\n     }\n \n     #[test]\n     fn test_split_within() {\n-        fail_unless!(split_within(~\"\", 0) == ~[]);\n-        fail_unless!(split_within(~\"\", 15) == ~[]);\n-        fail_unless!(split_within(~\"hello\", 15) == ~[~\"hello\"]);\n-\n-        let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n-        error!(\"~~~~ %?\", split_within(data, 15));\n-        fail_unless!(split_within(data, 15) == ~[~\"Mary had a\",\n-                                                 ~\"little lamb\",\n-                                                 ~\"Little lamb\"]);\n+        fn t(s: &str, i: uint, u: &[~str]) {\n+            let mut v = ~[];\n+            for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n+        t(~\"\", 0, ~[]);\n+        t(~\"\", 15, ~[]);\n+        t(~\"hello\", 15, ~[~\"hello\"]);\n+        t(~\"\\nMary had a little lamb\\nLittle lamb\\n\", 15,\n+            ~[~\"Mary had a\", ~\"little lamb\", ~\"Little lamb\"]);\n     }\n \n     #[test]\n@@ -3338,7 +3342,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for split_char_each(data, ' ') |xx| {\n+        for each_split_char(data, ' ') |xx| {\n             match ii {\n               0 => fail_unless!(\"\\nMary\" == xx),\n               1 => fail_unless!(\"had\"    == xx),\n@@ -3356,7 +3360,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for splitn_char_each(data, ' ', 2u) |xx| {\n+        for each_splitn_char(data, ' ', 2u) |xx| {\n             match ii {\n               0 => fail_unless!(\"\\nMary\" == xx),\n               1 => fail_unless!(\"had\"    == xx),\n@@ -3373,7 +3377,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for words_each(data) |ww| {\n+        for each_word(data) |ww| {\n             match ii {\n               0 => fail_unless!(\"Mary\"   == ww),\n               1 => fail_unless!(\"had\"    == ww),\n@@ -3384,7 +3388,7 @@ mod tests {\n             ii += 1;\n         }\n \n-        words_each(~\"\", |_x| fail!()); // should not fail\n+        each_word(~\"\", |_x| fail!()); // should not fail\n     }\n \n     #[test]\n@@ -3393,7 +3397,7 @@ mod tests {\n \n         let mut ii = 0;\n \n-        for lines_each(lf) |x| {\n+        for each_line(lf) |x| {\n             match ii {\n                 0 => fail_unless!(\"\" == x),\n                 1 => fail_unless!(\"Mary had a little lamb\" == x),\n@@ -3437,7 +3441,7 @@ mod tests {\n         let ss = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         fail_unless!(~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a',\n                        'm']\n-            == chars(ss));\n+            == to_chars(ss));\n     }\n \n     #[test]"}, {"sha": "ffd7669c2d2eebe948cc339f9c888ac7393e5a48", "filename": "src/librust/rust.rc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // rust - central access to other rust tools\n-// FIXME #2238 Make commands run and test emit proper file endings on winds\n+// FIXME #2238 Make commands run and test emit proper file endings on windows\n // FIXME #2238 Make run only accept source that emits an executable\n \n #[link(name = \"rust\",\n@@ -29,10 +29,12 @@ enum ValidUsage {\n }\n \n impl ValidUsage {\n-    fn is_valid(&self) -> bool { match *self {\n-        Valid   => true,\n-        Invalid => false\n-    }}\n+    fn is_valid(&self) -> bool {\n+        match *self {\n+            Valid   => true,\n+            Invalid => false\n+        }\n+    }\n }\n \n enum Action {\n@@ -128,7 +130,9 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n                 match command.usage_full {\n                     UsgStr(msg)          => io::println(fmt!(\"%s\\n\", msg)),\n                     UsgExec(commandline) => {\n-                        let words = str::words(commandline);\n+                        let mut words = ~[];\n+                        for str::each_word(commandline) |word| { words.push(word.to_owned()) }\n+                        let words = words;\n                         let (prog, args) = (words.head(), words.tail());\n                         run::run_program(*prog, args);\n                     }\n@@ -184,7 +188,9 @@ fn do_command(command: &Command, args: &[~str]) -> ValidUsage {\n     match command.action {\n         Call(f) => f(args),\n         Exec(commandline) => {\n-            let words = str::words(commandline);\n+            let mut words = ~[];\n+            for str::each_word(commandline) |word| { words.push(word.to_owned()) }\n+            let words = words;\n             let (prog, prog_args) = (words.head(), words.tail());\n             let exitstatus = run::run_program(\n                 *prog,"}, {"sha": "012a56c5b720a8cce5ae660afc5852ca27435a24", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -183,7 +183,8 @@ fn first_sentence_(s: &str) -> ~str {\n }\n \n fn paragraphs(s: &str) -> ~[~str] {\n-    let lines = str::lines_any(s);\n+    let mut lines = ~[];\n+    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n     let paras = do vec::foldl(~[], lines) |paras, line| {"}, {"sha": "1e39373d9a5bec4a6b11bab9a790e850504c5d2f", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -534,9 +534,11 @@ fn write_sig(ctxt: &Ctxt, sig: Option<~str>) {\n }\n \n fn code_block_indent(s: ~str) -> ~str {\n-    let lines = str::lines_any(s);\n-    let indented = vec::map(lines, |line| fmt!(\"    %s\", *line) );\n-    str::connect(indented, ~\"\\n\")\n+    let mut indented = ~[];\n+    for str::each_line_any(s) |line| {\n+        indented.push(fmt!(\"    %s\", line));\n+    }\n+    str::connect(indented, \"\\n\")\n }\n \n #[test]"}, {"sha": "33003a59611d41a301e9d45ff088eb461e253a1b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -104,8 +104,8 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n     if desc.is_none() {\n         return (None, ~[]);\n     }\n-\n-    let lines = str::lines((copy desc).get());\n+    let mut lines = ~[];\n+    for str::each_line_any(*desc.get_ref()) |line| { lines.push(line.to_owned()); }\n \n     let mut new_desc = None::<~str>;\n     let mut current_section = None;"}, {"sha": "6207e2252e40bd49c12373797fd044ebfa586e38", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -33,7 +33,8 @@ pub fn mk_pass() -> Pass {\n }\n \n fn unindent(s: &str) -> ~str {\n-    let lines = str::lines_any(s);\n+    let mut lines = ~[];\n+    for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n     let min_indent = do vec::foldl(uint::max_value, lines)"}, {"sha": "ddde66157bb4452d2d4418b64593a474d0a16a73", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -337,7 +337,8 @@ fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str)\n     -> Option<Repl> {\n     if line.starts_with(~\":\") {\n         let full = line.substr(1, line.len() - 1);\n-        let split = str::words(full);\n+        let mut split = ~[];\n+        for str::each_word(full) |word| { split.push(word.to_owned()) }\n         let len = split.len();\n \n         if len > 0 {"}, {"sha": "35698bb235a38f277458d59b24453f4310ffa5c0", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -270,14 +270,11 @@ impl Ctx {\n         fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n             let mut name = None;\n             let mut vers = None;\n-            let parts = str::split_char(in, '@');\n \n-            if parts.len() >= 1 {\n-                name = Some(parts[0]);\n-\n-                if parts.len() >= 2 {\n-                    vers = Some(parts[1]);\n-                }\n+            for str::each_split_char(in, '@') |s| {\n+                if      name.is_none() { name = Some(s.to_owned()); }\n+                else if vers.is_none() { vers = Some(s.to_owned()); }\n+                else                   { break;               }\n             }\n \n             (name, vers)\n@@ -733,8 +730,12 @@ impl Ctx {\n \n         for package.bins.each |&bin| {\n             let path = Path(bin);\n-            let name = str::split_char(path.file_path().to_str(), '-')[0];\n-            let out = bin_dir.push(name);\n+            let mut name = None;\n+            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n+                name = Some(s.to_owned());\n+                break;\n+            }\n+            let out = bin_dir.push(name.unwrap());\n \n             util::link_exe(&path, &out);\n             util::note(fmt!(\"linked %s\", out.to_str()));\n@@ -847,8 +848,12 @@ impl Ctx {\n \n         for package.bins.each |&bin| {\n             let path = Path(bin);\n-            let name = str::split_char(path.file_path().to_str(), '-')[0];\n-            let out = bin_dir.push(name);\n+            let mut name = None;\n+            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n+                name = Some(s.to_owned());\n+                break;\n+            }\n+            let out = bin_dir.push(name.unwrap());\n \n             if os::path_exists(&out) {\n                 if os::remove_file(&out) {"}, {"sha": "58a286a1854ee4e62f19b581d78d29a864b66047", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -44,10 +44,10 @@ pub fn is_cmd(cmd: ~str) -> bool {\n }\n \n pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n-    let parts = str::split_char(id, '.');\n+    let mut last_part = None;\n \n-    for parts.each |&part| {\n-        for str::chars(part).each |&char| {\n+    for str::each_split_char(id, '.') |part| {\n+        for str::each_char(part) |char| {\n             if char::is_whitespace(char) {\n                 return result::Err(\n                     ~\"could not parse id: contains whitespace\");\n@@ -56,9 +56,11 @@ pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n                     ~\"could not parse id: should be all lowercase\");\n             }\n         }\n+        last_part = Some(part.to_owned());\n     }\n+    if last_part.is_none() { return result::Err(~\"could not parse id: is empty\"); }\n \n-    result::Ok(copy *parts.last())\n+    result::Ok(last_part.unwrap())\n }\n \n struct ListenerFn {"}, {"sha": "dcc5fe58755228c2585fa0c6fc044994ec5b7d58", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -68,7 +68,8 @@ pub impl Sudoku {\n         let mut g = vec::from_fn(10u, { |_i| ~[0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8] });\n         while !reader.eof() {\n             let line = reader.read_line();\n-            let comps = str::split_char(line.trim(), ',');\n+            let mut comps = ~[];\n+            for str::each_split_char(line.trim(), ',') |s| { comps.push(s.to_owned()) }\n             if vec::len(comps) == 3u {\n                 let row     = uint::from_str(comps[0]).get() as u8;\n                 let col     = uint::from_str(comps[1]).get() as u8;"}, {"sha": "247fd2d712a16349b012b11501e18b68533ab04c", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c371605b3e2ad8068e359f28d4c77dccad0237/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=06c371605b3e2ad8068e359f28d4c77dccad0237", "patch": "@@ -17,8 +17,8 @@ pub fn main() {\n \n     fail_unless!((str::len(s) == 10u));\n     fail_unless!((str::char_len(s) == 4u));\n-    fail_unless!((vec::len(str::chars(s)) == 4u));\n-    fail_unless!((str::from_chars(str::chars(s)) == s));\n+    fail_unless!((vec::len(str::to_chars(s)) == 4u));\n+    fail_unless!((str::from_chars(str::to_chars(s)) == s));\n     fail_unless!((str::char_at(s, 0u) == 'e'));\n     fail_unless!((str::char_at(s, 1u) == '\u00e9'));\n "}]}