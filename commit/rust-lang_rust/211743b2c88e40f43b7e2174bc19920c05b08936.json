{"sha": "211743b2c88e40f43b7e2174bc19920c05b08936", "node_id": "C_kwDOAAsO6NoAKDIxMTc0M2IyYzg4ZTQwZjQzYjdlMjE3NGJjMTk5MjBjMDViMDg5MzY", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-10-07T20:23:34Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:36:08Z"}, "message": "make const `align_offset` useful", "tree": {"sha": "3f87fb31eeb5676a1362a00dd2e626a9b1b0032a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f87fb31eeb5676a1362a00dd2e626a9b1b0032a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/211743b2c88e40f43b7e2174bc19920c05b08936", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/211743b2c88e40f43b7e2174bc19920c05b08936", "html_url": "https://github.com/rust-lang/rust/commit/211743b2c88e40f43b7e2174bc19920c05b08936", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/211743b2c88e40f43b7e2174bc19920c05b08936/comments", "author": null, "committer": null, "parents": [{"sha": "f770fecfe1cf3415675ac6165a200dff564bd00f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f770fecfe1cf3415675ac6165a200dff564bd00f", "html_url": "https://github.com/rust-lang/rust/commit/f770fecfe1cf3415675ac6165a200dff564bd00f"}], "stats": {"total": 180, "additions": 152, "deletions": 28}, "files": [{"sha": "97d168ceb01a6c8d935edc00c1022831d95e747a", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 106, "deletions": 23, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/211743b2c88e40f43b7e2174bc19920c05b08936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211743b2c88e40f43b7e2174bc19920c05b08936/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=211743b2c88e40f43b7e2174bc19920c05b08936", "patch": "@@ -1,8 +1,11 @@\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::PointerArithmetic;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::borrow::Borrow;\n use std::hash::Hash;\n+use std::ops::ControlFlow;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::fx::IndexEntry;\n@@ -17,8 +20,8 @@ use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n+    InterpResult, OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n@@ -145,15 +148,19 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    /// \"Intercept\" a function call to a panic-related function\n-    /// because we have something special to do for it.\n-    /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n+    /// \"Intercept\" a function call, because we have something special to do for it.\n+    /// All `#[rustc_do_not_const_check]` functions should be hooked here.\n+    /// If this returns `Some` function, which may be `instance` or a different function with\n+    /// compatible arguments, then evaluation should continue with that function.\n+    /// If this returns `None`, the function call has been handled and the function has returned.\n     fn hook_special_const_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n+        _abi: CallAbi,\n         args: &[OpTy<'tcx>],\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<ty::Instance<'tcx>>> {\n-        // All `#[rustc_do_not_const_check]` functions should be hooked here.\n         let def_id = instance.def_id();\n \n         if Some(def_id) == self.tcx.lang_items().panic_display()\n@@ -173,20 +180,91 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             return Err(ConstEvalErrKind::Panic { msg, file, line, col }.into());\n         } else if Some(def_id) == self.tcx.lang_items().panic_fmt() {\n             // For panic_fmt, call const_panic_fmt instead.\n-            if let Some(const_panic_fmt) = self.tcx.lang_items().const_panic_fmt() {\n-                return Ok(Some(\n-                    ty::Instance::resolve(\n-                        *self.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        const_panic_fmt,\n-                        self.tcx.intern_substs(&[]),\n-                    )\n-                    .unwrap()\n-                    .unwrap(),\n-                ));\n+            let Some(const_def_id) = self.tcx.lang_items().const_panic_fmt() else {\n+                bug!(\"`const_panic_fmt` must be defined to call `panic_fmt` in const eval\")\n+            };\n+            let new_instance = ty::Instance::resolve(\n+                *self.tcx,\n+                ty::ParamEnv::reveal_all(),\n+                const_def_id,\n+                instance.substs,\n+            )\n+            .unwrap()\n+            .unwrap();\n+\n+            return Ok(Some(new_instance));\n+        } else if Some(def_id) == self.tcx.lang_items().align_offset_fn() {\n+            // For align_offset, we replace the function call if the pointer has no address.\n+            match self.align_offset(instance, args, dest, ret)? {\n+                ControlFlow::Continue(()) => return Ok(Some(instance)),\n+                ControlFlow::Break(()) => return Ok(None),\n+            }\n+        }\n+        Ok(Some(instance))\n+    }\n+\n+    /// `align_offset(ptr, target_align)` needs special handling in const eval, because the pointer\n+    /// may not have an address.\n+    ///\n+    /// If `ptr` does have a known address, then we return `CONTINUE` and the function call should\n+    /// proceed as normal.\n+    ///\n+    /// If `ptr` doesn't have an address, but its underlying allocation's alignment is at most\n+    /// `target_align`, then we call the function again with an dummy address relative to the\n+    /// allocation.\n+    ///\n+    /// If `ptr` doesn't have an address and `target_align` is stricter than the underlying\n+    /// allocation's alignment, then we return `usize::MAX` immediately.\n+    fn align_offset(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, ControlFlow<()>> {\n+        assert_eq!(args.len(), 2);\n+\n+        let ptr = self.read_pointer(&args[0])?;\n+        let target_align = self.read_scalar(&args[1])?.to_machine_usize(self)?;\n+\n+        if !target_align.is_power_of_two() {\n+            throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n+        }\n+\n+        match self.ptr_try_get_alloc_id(ptr) {\n+            Ok((alloc_id, offset, _extra)) => {\n+                let (_size, alloc_align, _kind) = self.get_alloc_info(alloc_id);\n+\n+                if target_align <= alloc_align.bytes() {\n+                    // Extract the address relative to the allocation base that is definitely\n+                    // sufficiently aligned and call `align_offset` again.\n+                    let addr = ImmTy::from_uint(offset.bytes(), args[0].layout).into();\n+                    let align = ImmTy::from_uint(target_align, args[1].layout).into();\n+\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n+                    self.eval_fn_call(\n+                        FnVal::Instance(instance),\n+                        (CallAbi::Rust, fn_abi),\n+                        &[addr, align],\n+                        false,\n+                        dest,\n+                        ret,\n+                        StackPopUnwind::NotAllowed,\n+                    )?;\n+                    Ok(ControlFlow::BREAK)\n+                } else {\n+                    // Not alignable in const, return `usize::MAX`.\n+                    let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n+                    self.write_scalar(usize_max, dest)?;\n+                    self.return_to_block(ret)?;\n+                    Ok(ControlFlow::BREAK)\n+                }\n+            }\n+            Err(_addr) => {\n+                // The pointer has an address, continue with function call.\n+                Ok(ControlFlow::CONTINUE)\n             }\n         }\n-        Ok(None)\n     }\n \n     /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n@@ -269,8 +347,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         _abi: CallAbi,\n         args: &[OpTy<'tcx>],\n-        _dest: &PlaceTy<'tcx>,\n-        _ret: Option<mir::BasicBlock>,\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -289,7 +367,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             }\n \n-            if let Some(new_instance) = ecx.hook_special_const_fn(instance, args)? {\n+            let Some(new_instance) = ecx.hook_special_const_fn(instance, _abi, args, dest, ret)? else {\n+                return Ok(None);\n+            };\n+\n+            if new_instance != instance {\n                 // We call another const fn instead.\n                 // However, we return the *original* instance to make backtraces work out\n                 // (and we hope this does not confuse the FnAbi checks too much).\n@@ -298,13 +380,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     new_instance,\n                     _abi,\n                     args,\n-                    _dest,\n-                    _ret,\n+                    dest,\n+                    ret,\n                     _unwind,\n                 )?\n                 .map(|(body, _instance)| (body, instance)));\n             }\n         }\n+\n         // This is a const fn. Call it.\n         Ok(Some((ecx.load_mir(instance.def, None)?, instance)))\n     }"}, {"sha": "f0cdc3d839998c42393b0184a6caeaeb271a1c08", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=211743b2c88e40f43b7e2174bc19920c05b08936", "patch": "@@ -1322,6 +1322,21 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n+    #[cfg(not(bootstrap))]\n+    pub const fn align_offset(self, align: usize) -> usize\n+    where\n+        T: Sized,\n+    {\n+        assert!(align.is_power_of_two(), \"align_offset: align is not a power-of-two\");\n+\n+        // SAFETY: `align` has been checked to be a power of 2 above\n+        unsafe { align_offset(self, align) }\n+    }\n+\n+    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n+    #[allow(missing_docs)]\n+    #[cfg(bootstrap)]\n     pub const fn align_offset(self, align: usize) -> usize\n     where\n         T: Sized,"}, {"sha": "1ebd9dca098389575f713a1ef3a9f4ffeb0d64dd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=211743b2c88e40f43b7e2174bc19920c05b08936", "patch": "@@ -1574,10 +1574,14 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n \n /// Align pointer `p`.\n ///\n-/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n+/// Calculate offset (in terms of elements of `size_of::<T>()` stride) that has to be applied\n /// to pointer `p` so that pointer `p` would get aligned to `a`.\n ///\n-/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n+/// # Safety\n+/// `a` must be a power of two.\n+///\n+/// # Notes\n+/// This implementation has been carefully tailored to not panic. It is UB for this to panic.\n /// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n /// constants.\n ///\n@@ -1586,8 +1590,10 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n /// than trying to adapt this to accommodate that change.\n ///\n /// Any questions go to @nagisa.\n+// #[cfg(not(bootstrap))] -- Calling this function in a const context from the bootstrap\n+// compiler will always cause an error.\n #[lang = \"align_offset\"]\n-pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n+pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n@@ -1604,7 +1610,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     ///\n     /// Implementation of this function shall not panic. Ever.\n     #[inline]\n-    unsafe fn mod_inv(x: usize, m: usize) -> usize {\n+    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e., for\n@@ -1646,8 +1652,13 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         inverse & m_minus_one\n     }\n \n-    let addr = p.addr();\n     let stride = mem::size_of::<T>();\n+\n+    // SAFETY: At runtime transmuting a pointer to `usize` is always safe, because they have the\n+    // same layout. During const eval we hook this function to ensure that the pointer always has\n+    // an address (only the standard library can do this).\n+    let addr = unsafe { mem::transmute(p) };\n+\n     // SAFETY: `a` is a power-of-two, therefore non-zero.\n     let a_minus_one = unsafe { unchecked_sub(a, 1) };\n "}, {"sha": "eb1a6a07c6b89d29a42953a97d14e7aa7efb6d75", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/211743b2c88e40f43b7e2174bc19920c05b08936/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=211743b2c88e40f43b7e2174bc19920c05b08936", "patch": "@@ -1590,6 +1590,21 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n+    #[cfg(not(bootstrap))]\n+    pub const fn align_offset(self, align: usize) -> usize\n+    where\n+        T: Sized,\n+    {\n+        assert!(align.is_power_of_two(), \"align_offset: align is not a power-of-two\");\n+\n+        // SAFETY: `align` has been checked to be a power of 2 above\n+        unsafe { align_offset(self, align) }\n+    }\n+\n+    #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n+    #[allow(missing_docs)]\n+    #[cfg(bootstrap)]\n     pub const fn align_offset(self, align: usize) -> usize\n     where\n         T: Sized,"}]}