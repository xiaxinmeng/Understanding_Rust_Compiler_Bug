{"sha": "fba0bf63a90379e8825012a817167774e14a627f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTBiZjYzYTkwMzc5ZTg4MjUwMTJhODE3MTY3Nzc0ZTE0YTYyN2Y=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-16T04:00:09Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-21T15:45:45Z"}, "message": "Stabilize Index traits and most range notation\n\nThis commit marks as `#[stable]`:\n\n* The `Index` and `IndexMut` traits. These are stabilized as taking the\n  index itself *by reference*; after extensive discussion it was\n  determined that this is a better match with our choices\n  elsewhere (e.g. making comparison operators auto-reference), and that\n  the use cases for by-value indices are better handled through\n  `IndexSet`.\n\n* The `Range`, `RangeFrom` and `RangeTo` structs, introduced for range\n  notation.\n\n* Various impls of `Index` and `IndexMut`.\n\nThe `FullRange` struct is left unstable as we may wish to rename it to\n`RangeFull` in the future.\n\nThis commit also *removes* the `Step` trait in favor of direct\nimplementation of iterator traits on ranges for integers. The `Step`\ntrait was not a terribly useful factoring internally, and it is likely\nthat external integer types are best off implementing range iterators\ndirectly. It was removed to simplify the API surface. We can always\nreintroduce `Step` later if it turns out to be useful.\n\nDue to this removal, this is a:\n\n[breaking-change]", "tree": {"sha": "daf820961ab234dc6bf343dc171649f9741dfa3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daf820961ab234dc6bf343dc171649f9741dfa3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba0bf63a90379e8825012a817167774e14a627f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba0bf63a90379e8825012a817167774e14a627f", "html_url": "https://github.com/rust-lang/rust/commit/fba0bf63a90379e8825012a817167774e14a627f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba0bf63a90379e8825012a817167774e14a627f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6869645e86c91544b8737b89809bdf10bef536d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6869645e86c91544b8737b89809bdf10bef536d9", "html_url": "https://github.com/rust-lang/rust/commit/6869645e86c91544b8737b89809bdf10bef536d9"}], "stats": {"total": 191, "additions": 89, "deletions": 102}, "files": [{"sha": "7596973ea23bb5f3f2fcff430a1859ee7670386f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=fba0bf63a90379e8825012a817167774e14a627f", "patch": "@@ -1229,7 +1229,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Index stability\"]\n+#[stable]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1239,6 +1239,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1249,27 +1250,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1278,27 +1283,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1307,7 +1316,6 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-\n #[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];"}, {"sha": "faf8ccbc90eb912d43ef39ddfe4172b7e9e9188f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 67, "deletions": 37, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=fba0bf63a90379e8825012a817167774e14a627f", "patch": "@@ -2701,63 +2701,93 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n-\n-/// The `Step` trait identifies objects which can be stepped over in both\n-/// directions. The `steps_between` function provides a way to\n-/// compare two Step objects (it could be provided using `step()` and `Ord`,\n-/// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"design of range notation/iteration is in flux\"]\n-pub trait Step: Ord {\n-    /// Change self to the next object.\n-    fn step(&mut self);\n-    /// Change self to the previous object.\n-    fn step_back(&mut self);\n-    /// The steps_between two step objects.\n-    /// start should always be less than end, so the result should never be negative.\n-    /// Return None if it is not possible to calculate steps_between without\n-    /// overflow.\n-    fn steps_between(start: &Self, end: &Self) -> Option<uint>;\n-}\n-\n-macro_rules! step_impl {\n+macro_rules! range_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n-            #[inline]\n-            fn step(&mut self) { *self += 1; }\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+\n             #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<uint> {\n-                debug_assert!(end >= start);\n-                Some((*end - *start) as uint)\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                debug_assert!(self.end >= self.start);\n+                let hint = (self.end - self.start) as uint;\n+                (hint, Some(hint))\n             }\n         }\n+\n+        #[stable]\n+        impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n+macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn step(&mut self) { *self += 1; }\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! range_other_impls {\n+    ($($t:ty)*) => ($(\n+        #[stable]\n+        impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next_back(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    self.end -= 1;\n+                    return Some(self.end);\n+                }\n+\n+                return None;\n+            }\n+        }\n+\n+        #[stable]\n+        impl Iterator for ::ops::RangeFrom<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn steps_between(_start: &$t, _end: &$t) -> Option<uint> {\n-                None\n+            fn next(&mut self) -> Option<$t> {\n+                let result = self.start;\n+                self.start += 1;\n+                debug_assert!(result < self.start);\n+                return Some(result);\n             }\n         }\n     )*)\n }\n \n-step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+range_impl!(uint u8 u16 u32 int i8 i16 i32);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl!(u64 i64);\n+range_impl!(u64 i64);\n #[cfg(target_pointer_width = \"32\")]\n-step_impl_no_between!(u64 i64);\n+range_impl_no_hint!(u64 i64);\n \n+range_other_impls!(uint u8 u16 u32 u64 int i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]"}, {"sha": "e5186f9335aa814a156c6d605486e1e083b7f294", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 12, "deletions": 63, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba0bf63a90379e8825012a817167774e14a627f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=fba0bf63a90379e8825012a817167774e14a627f", "patch": "@@ -69,10 +69,7 @@\n \n #![stable]\n \n-use clone::Clone;\n-use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use marker::Sized;\n-use option::Option::{self, Some, None};\n use fmt;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -924,10 +921,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n+#[stable]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -960,20 +959,22 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n+#[stable]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"API still in development\"]\n+#[unstable = \"may be renamed to RangeFull\"]\n pub struct FullRange;\n \n-#[unstable = \"API still in development\"]\n+#[stable]\n impl fmt::Show for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(\"..\", fmt)\n@@ -983,56 +984,15 @@ impl fmt::Show for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for Range<Idx> {\n-    type Item = Idx;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            let result = self.start.clone();\n-            self.start.step();\n-            return Some(result);\n-        }\n-\n-        return None;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if let Some(hint) = Step::steps_between(&self.start, &self.end) {\n-            (hint, Some(hint))\n-        } else {\n-            (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            self.end.step_back();\n-            return Some(self.end.clone());\n-        }\n-\n-        return None;\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n-\n-#[unstable = \"API still in development\"]\n+#[stable]\n impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n@@ -1042,26 +1002,15 @@ impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n-    type Item = Idx;\n \n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        // Deliberately overflow so we loop forever.\n-        let result = self.start.clone();\n-        self.start.step();\n-        return Some(result);\n-    }\n-}\n \n-#[unstable = \"API still in development\"]\n+#[stable]\n impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n@@ -1071,13 +1020,13 @@ impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n+#[stable]\n impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)"}]}