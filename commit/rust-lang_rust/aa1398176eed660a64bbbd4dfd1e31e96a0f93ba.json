{"sha": "aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMTM5ODE3NmVlZDY2MGE2NGJiYmQ0ZGZkMWUzMWU5NmEwZjkzYmE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-28T08:52:47Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-30T12:10:44Z"}, "message": "Mucho debug instrumentation.", "tree": {"sha": "f97ed596c263bea6c6a1d277e589674887ab18b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f97ed596c263bea6c6a1d277e589674887ab18b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "html_url": "https://github.com/rust-lang/rust/commit/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0fd67b3e75dc2cc52a941733bd5dde574338779", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0fd67b3e75dc2cc52a941733bd5dde574338779", "html_url": "https://github.com/rust-lang/rust/commit/b0fd67b3e75dc2cc52a941733bd5dde574338779"}], "stats": {"total": 134, "additions": 91, "deletions": 43}, "files": [{"sha": "c9fc843ac525d5164ed6e7f924dedbd6465648c2", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "patch": "@@ -295,23 +295,29 @@ pub trait Typer<'tcx> : ty::ClosureTyper<'tcx> {\n \n impl MutabilityCategory {\n     pub fn from_mutbl(m: ast::Mutability) -> MutabilityCategory {\n-        match m {\n+        let ret = match m {\n             MutImmutable => McImmutable,\n             MutMutable => McDeclared\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_mutbl\", m, ret);\n+        ret\n     }\n \n     pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n-        match borrow_kind {\n+        let ret = match borrow_kind {\n             ty::ImmBorrow => McImmutable,\n             ty::UniqueImmBorrow => McImmutable,\n             ty::MutBorrow => McDeclared,\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n+               \"from_borrow_kind\", borrow_kind, ret);\n+        ret\n     }\n \n     pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n                              ptr: PointerKind) -> MutabilityCategory {\n-        match ptr {\n+        let ret = match ptr {\n             Unique => {\n                 base_mutbl.inherit()\n             }\n@@ -321,11 +327,14 @@ impl MutabilityCategory {\n             UnsafePtr(m) => {\n                 MutabilityCategory::from_mutbl(m)\n             }\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}({:?}, {:?}) => {:?}\",\n+               \"from_pointer_kind\", base_mutbl, ptr, ret);\n+        ret\n     }\n \n     fn from_local(tcx: &ty::ctxt, id: ast::NodeId) -> MutabilityCategory {\n-        match tcx.map.get(id) {\n+        let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) | ast_map::NodeArg(p) => match p.node {\n                 ast::PatIdent(bind_mode, _, _) => {\n                     if bind_mode == ast::BindByValue(ast::MutMutable) {\n@@ -337,30 +346,39 @@ impl MutabilityCategory {\n                 _ => tcx.sess.span_bug(p.span, \"expected identifier pattern\")\n             },\n             _ => tcx.sess.span_bug(tcx.map.span(id), \"expected identifier pattern\")\n-        }\n+        };\n+        debug!(\"MutabilityCategory::{}(tcx, id={:?}) => {:?}\",\n+               \"from_local\", id, ret);\n+        ret\n     }\n \n     pub fn inherit(&self) -> MutabilityCategory {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => McImmutable,\n             McDeclared => McInherited,\n             McInherited => McInherited,\n-        }\n+        };\n+        debug!(\"{:?}.inherit() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_mutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => false,\n             McInherited => true,\n             McDeclared => true,\n-        }\n+        };\n+        debug!(\"{:?}.is_mutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn is_immutable(&self) -> bool {\n-        match *self {\n+        let ret = match *self {\n             McImmutable => true,\n             McDeclared | McInherited => false\n-        }\n+        };\n+        debug!(\"{:?}.is_immutable() => {:?}\", self, ret);\n+        ret\n     }\n \n     pub fn to_user_str(&self) -> &'static str {\n@@ -733,7 +751,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n         };\n \n-        Ok(Rc::new(cmt_result))\n+        let ret = Rc::new(cmt_result);\n+        debug!(\"cat_upvar ret={}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     fn env_deref(&self,\n@@ -794,14 +814,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             McDeclared | McInherited => { }\n         }\n \n-        cmt_ {\n+        let ret = cmt_ {\n             id: id,\n             span: span,\n             cat: cat_deref(Rc::new(cmt_result), 0, env_ptr),\n             mutbl: deref_mutbl,\n             ty: var_ty,\n             note: NoteClosureEnv(upvar_id)\n-        }\n+        };\n+\n+        debug!(\"env_deref ret {}\", ret.repr(self.tcx()));\n+\n+        ret\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -831,22 +855,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 }\n             }\n         };\n-        self.cat_rvalue(id, span, re, expr_ty)\n+        let ret = self.cat_rvalue(id, span, re, expr_ty);\n+        debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n             cat:cat_rvalue(temp_scope),\n             mutbl:McDeclared,\n             ty:expr_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_rvalue ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_field<N:ast_node>(&self,\n@@ -855,14 +883,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                  f_name: ast::Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_tup_field<N:ast_node>(&self,\n@@ -871,14 +901,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                      f_idx: uint,\n                                      f_ty: Ty<'tcx>)\n                                      -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, InteriorField(PositionalField(f_idx))),\n             ty: f_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_tup_field ret {}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     fn cat_deref<N:ast_node>(&self,\n@@ -913,10 +945,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n         let base_cmt_ty = base_cmt.ty;\n         match ty::deref(base_cmt_ty, true) {\n-            Some(mt) => self.cat_deref_common(node, base_cmt, deref_cnt,\n+            Some(mt) => {\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n                                               mt.ty,\n                                               deref_context,\n-                                              /* implicit: */ false),\n+                                                /* implicit: */ false);\n+                debug!(\"cat_deref ret {}\", ret.repr(self.tcx()));\n+                ret\n+            }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {}\",\n                        base_cmt_ty.repr(self.tcx()));\n@@ -954,14 +990,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 (base_cmt.mutbl.inherit(), cat_interior(base_cmt, interior))\n             }\n         };\n-        Ok(Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             cat: cat,\n             mutbl: m,\n             ty: deref_ty,\n             note: NoteNone\n-        }))\n+        });\n+        debug!(\"cat_deref_common ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1009,8 +1047,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         };\n \n         let m = base_cmt.mutbl.inherit();\n-        return Ok(interior(elt, base_cmt.clone(), base_cmt.ty,\n-                           m, context, element_ty));\n+        let ret = interior(elt, base_cmt.clone(), base_cmt.ty,\n+                           m, context, element_ty);\n+        debug!(\"cat_index ret {}\", ret.repr(self.tcx()));\n+        return Ok(ret);\n \n         fn interior<'tcx, N: ast_node>(elt: &N,\n                                        of_cmt: cmt<'tcx>,\n@@ -1039,14 +1079,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              context: InteriorOffsetKind)\n                              -> McResult<cmt<'tcx>>\n     {\n-        match try!(deref_kind(base_cmt.ty, Some(context))) {\n+        let ret = match try!(deref_kind(base_cmt.ty, Some(context))) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n                 let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n                 // the deref is explicit in the resulting cmt\n-                Ok(Rc::new(cmt_ {\n+                Rc::new(cmt_ {\n                     id:elt.id(),\n                     span:elt.span(),\n                     cat:cat_deref(base_cmt.clone(), 0, ptr),\n@@ -1056,13 +1096,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         None => self.tcx().sess.bug(\"Found non-derefable type\")\n                     },\n                     note: NoteNone\n-                }))\n+                })\n             }\n \n             deref_interior(_) => {\n-                Ok(base_cmt)\n+                base_cmt\n             }\n-        }\n+        };\n+        debug!(\"deref_vec ret {}\", ret.repr(self.tcx()));\n+        Ok(ret)\n     }\n \n     /// Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is the cmt for `P`, `slice_pat` is\n@@ -1112,14 +1154,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                         interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n                                         -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_interior(base_cmt, interior),\n             ty: interior_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_imm_interior ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_downcast<N:ast_node>(&self,\n@@ -1128,14 +1172,16 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                     downcast_ty: Ty<'tcx>,\n                                     variant_did: ast::DefId)\n                                     -> cmt<'tcx> {\n-        Rc::new(cmt_ {\n+        let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n             cat: cat_downcast(base_cmt, variant_did),\n             ty: downcast_ty,\n             note: NoteNone\n-        })\n+        });\n+        debug!(\"cat_downcast ret={}\", ret.repr(self.tcx()));\n+        ret\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) -> McResult<()>"}, {"sha": "60c6e37768dd00511f2ec4113323dca504155c88", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1398176eed660a64bbbd4dfd1e31e96a0f93ba/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=aa1398176eed660a64bbbd4dfd1e31e96a0f93ba", "patch": "@@ -151,10 +151,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n-               assignment_id, assignee_cmt.repr(self.tcx()));\n+        let opt_lp = opt_loan_path(&assignee_cmt);\n+        debug!(\"mutate(assignment_id={}, assignee_cmt={}) opt_lp={:?}\",\n+               assignment_id, assignee_cmt.repr(self.tcx()), opt_lp);\n \n-        match opt_loan_path(&assignee_cmt) {\n+        match opt_lp {\n             Some(lp) => {\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n                                                 assignment_id, assignment_span,\n@@ -376,7 +377,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n             //! Implements the M-* rules in README.md.\n-\n+            debug!(\"check_mutability(cause={:?} cmt={} req_kind={:?}\",\n+                   cause, cmt.repr(bccx.tcx), req_kind);\n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {\n                     match cmt.mutbl {"}]}