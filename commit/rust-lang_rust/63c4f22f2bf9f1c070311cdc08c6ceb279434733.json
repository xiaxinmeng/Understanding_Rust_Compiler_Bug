{"sha": "63c4f22f2bf9f1c070311cdc08c6ceb279434733", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYzRmMjJmMmJmOWYxYzA3MDMxMWNkYzA4YzZjZWIyNzk0MzQ3MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T22:31:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-05T22:31:44Z"}, "message": "auto merge of #18486 : nikomatsakis/rust/operator-dispatch, r=pcwalton\n\nThis branch cleans up overloaded operator resolution so that it is strictly based on the traits in `ops`, rather than going through the normal method lookup mechanism. It also adds full support for autoderef to overloaded index (whereas before autoderef only worked for non-overloaded index) as well as for the slicing operators.\r\n\r\nThis is a [breaking-change]: in the past, we were accepting combinations of operands that were not intended to be accepted. For example, it was possible to compare a fixed-length array and a slice, or apply the `!` operator to a `&int`. See the first two commits in this pull-request for examples.\r\n\r\nOne downside of this change is that comparing fixed-length arrays doesn't always work as smoothly as it did before. Before this, comparisons sometimes worked due to various coercions to slices. I've added impls for `Eq`, `Ord`, etc for fixed-lengths arrays up to and including length 32, but if the array is longer than that you'll need to either newtype the array or convert to slices. Note that this plays better with deriving in any case than the previous scheme.\r\n\r\nFixes #4920.\r\nFixes #16821.\r\nFixes #15757.\r\n\r\ncc @alexcrichton \r\ncc @aturon", "tree": {"sha": "7815bb12ca160450170b49198e111f71f6818f2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7815bb12ca160450170b49198e111f71f6818f2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63c4f22f2bf9f1c070311cdc08c6ceb279434733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63c4f22f2bf9f1c070311cdc08c6ceb279434733", "html_url": "https://github.com/rust-lang/rust/commit/63c4f22f2bf9f1c070311cdc08c6ceb279434733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63c4f22f2bf9f1c070311cdc08c6ceb279434733/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c1fd5f8b7351085765217b198c6d5a8c0026b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1fd5f8b7351085765217b198c6d5a8c0026b74", "html_url": "https://github.com/rust-lang/rust/commit/5c1fd5f8b7351085765217b198c6d5a8c0026b74"}, {"sha": "81c00e66f564ca67c391a5f24f2ad43189245d75", "url": "https://api.github.com/repos/rust-lang/rust/commits/81c00e66f564ca67c391a5f24f2ad43189245d75", "html_url": "https://github.com/rust-lang/rust/commit/81c00e66f564ca67c391a5f24f2ad43189245d75"}], "stats": {"total": 1272, "additions": 1009, "deletions": 263}, "files": [{"sha": "9a1a42478d3703178da968861eaa79ba5635e8b9", "filename": "src/doc/guide.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -4601,20 +4601,24 @@ returns `true` or `false`. The new iterator `filter()` produces\n only the elements that that closure returns `true` for:\n \n ```{rust}\n-for i in range(1i, 100i).filter(|x| x % 2 == 0) {\n+for i in range(1i, 100i).filter(|&x| x % 2 == 0) {\n     println!(\"{}\", i);\n }\n ```\n \n This will print all of the even numbers between one and a hundred.\n+(Note that because `filter` doesn't consume the elements that are\n+being iterated over, it is passed a reference to each element, and\n+thus the filter predicate uses the `&x` pattern to extract the integer\n+itself.)\n \n You can chain all three things together: start with an iterator, adapt it\n a few times, and then consume the result. Check it out:\n \n ```{rust}\n range(1i, 1000i)\n-    .filter(|x| x % 2 == 0)\n-    .filter(|x| x % 3 == 0)\n+    .filter(|&x| x % 2 == 0)\n+    .filter(|&x| x % 3 == 0)\n     .take(5)\n     .collect::<Vec<int>>();\n ```"}, {"sha": "3e93430eb6937cdf7b64fa0399504e592867a8ca", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -132,7 +132,7 @@ impl Drop for Arena {\n \n #[inline]\n fn round_up(base: uint, align: uint) -> uint {\n-    (base.checked_add(&(align - 1))).unwrap() & !(&(align - 1))\n+    (base.checked_add(&(align - 1))).unwrap() & !(align - 1)\n }\n \n // Walk down a chunk, running the destructors for any objects stored"}, {"sha": "eb4ff345b5133614d5f0111c270f17e3e6de7bbe", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -1598,15 +1598,15 @@ mod tests {\n     #[test]\n     fn test_total_ord() {\n         let c: &[int] = &[1, 2, 3];\n-        [1, 2, 3, 4].cmp(& c) == Greater;\n+        [1, 2, 3, 4][].cmp(& c) == Greater;\n         let c: &[int] = &[1, 2, 3, 4];\n-        [1, 2, 3].cmp(& c) == Less;\n+        [1, 2, 3][].cmp(& c) == Less;\n         let c: &[int] = &[1, 2, 3, 6];\n-        [1, 2, 3, 4].cmp(& c) == Equal;\n+        [1, 2, 3, 4][].cmp(& c) == Equal;\n         let c: &[int] = &[1, 2, 3, 4, 5, 6];\n-        [1, 2, 3, 4, 5, 5, 5, 5].cmp(& c) == Less;\n+        [1, 2, 3, 4, 5, 5, 5, 5][].cmp(& c) == Less;\n         let c: &[int] = &[1, 2, 3, 4];\n-        [2, 2].cmp(& c) == Greater;\n+        [2, 2][].cmp(& c) == Greater;\n     }\n \n     #[test]\n@@ -1980,15 +1980,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n+                assert!(left[0..left.len()] == [1, 2][]);\n             }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n+                assert!(right[0..right.len()] == [3, 4, 5][]);\n             }\n             for p in right.iter_mut() {\n                 *p += 2;"}, {"sha": "40e7c949972b53483486100fe25179e5a0497e3c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -919,7 +919,7 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i, 2, 3, 4];\n-    /// vec.retain(|x| x%2 == 0);\n+    /// vec.retain(|&x| x%2 == 0);\n     /// assert_eq!(vec, vec![2, 4]);\n     /// ```\n     #[unstable = \"the closure argument may become an unboxed closure\"]\n@@ -1800,15 +1800,15 @@ mod tests {\n             let (left, right) = values.split_at_mut(2);\n             {\n                 let left: &[_] = left;\n-                assert!(left[0..left.len()] == [1, 2]);\n+                assert!(left[0..left.len()] == [1, 2][]);\n             }\n             for p in left.iter_mut() {\n                 *p += 1;\n             }\n \n             {\n                 let right: &[_] = right;\n-                assert!(right[0..right.len()] == [3, 4, 5]);\n+                assert!(right[0..right.len()] == [3, 4, 5][]);\n             }\n             for p in right.iter_mut() {\n                 *p += 2;\n@@ -1863,7 +1863,7 @@ mod tests {\n     #[test]\n     fn test_retain() {\n         let mut vec = vec![1u, 2, 3, 4];\n-        vec.retain(|x| x%2 == 0);\n+        vec.retain(|&x| x % 2 == 0);\n         assert!(vec == vec![2u, 4]);\n     }\n "}, {"sha": "829605ce7cc1b686200c9a6a3519876e32aaf461", "filename": "src/libcore/array.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Implementations of things like `Eq` for fixed-length arrays\n+ * up to a certain length. Eventually we should able to generalize\n+ * to all lengths.\n+ */\n+\n+#![stable]\n+#![experimental] // not yet reviewed\n+\n+use cmp::*;\n+use option::{Option};\n+\n+// macro for implementing n-ary tuple functions and operations\n+macro_rules! array_impls {\n+    ($($N:expr)+) => {\n+        $(\n+            #[unstable = \"waiting for PartialEq to stabilize\"]\n+            impl<T:PartialEq> PartialEq for [T, ..$N] {\n+                #[inline]\n+                fn eq(&self, other: &[T, ..$N]) -> bool {\n+                    self[] == other[]\n+                }\n+                #[inline]\n+                fn ne(&self, other: &[T, ..$N]) -> bool {\n+                    self[] != other[]\n+                }\n+            }\n+\n+            #[unstable = \"waiting for Eq to stabilize\"]\n+            impl<T:Eq> Eq for [T, ..$N] { }\n+\n+            #[unstable = \"waiting for PartialOrd to stabilize\"]\n+            impl<T:PartialOrd> PartialOrd for [T, ..$N] {\n+                #[inline]\n+                fn partial_cmp(&self, other: &[T, ..$N]) -> Option<Ordering> {\n+                    PartialOrd::partial_cmp(&self[], &other[])\n+                }\n+                #[inline]\n+                fn lt(&self, other: &[T, ..$N]) -> bool {\n+                    PartialOrd::lt(&self[], &other[])\n+                }\n+                #[inline]\n+                fn le(&self, other: &[T, ..$N]) -> bool {\n+                    PartialOrd::le(&self[], &other[])\n+                }\n+                #[inline]\n+                fn ge(&self, other: &[T, ..$N]) -> bool {\n+                    PartialOrd::ge(&self[], &other[])\n+                }\n+                #[inline]\n+                fn gt(&self, other: &[T, ..$N]) -> bool {\n+                    PartialOrd::gt(&self[], &other[])\n+                }\n+            }\n+\n+            #[unstable = \"waiting for Ord to stabilize\"]\n+            impl<T:Ord> Ord for [T, ..$N] {\n+                #[inline]\n+                fn cmp(&self, other: &[T, ..$N]) -> Ordering {\n+                    Ord::cmp(&self[], &other[])\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+array_impls! {\n+     0  1  2  3  4  5  6  7  8  9\n+    10 11 12 13 14 15 16 17 18 19\n+    20 21 22 23 24 25 26 27 28 29\n+    30 31 32\n+}\n+"}, {"sha": "d9a0c398605e112afb0e3df019e30af8487f5ed5", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -126,6 +126,10 @@ pub mod tuple;\n pub mod unit;\n pub mod fmt;\n \n+// note: does not need to be public\n+#[cfg(not(stage0))]\n+mod array;\n+\n #[doc(hidden)]\n mod core {\n     pub use panicking;"}, {"sha": "b787de4423aac71b30ff37fe490be3792b92eaf0", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -787,8 +787,8 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// use std::uint;\n     ///\n     /// let v = vec!(1u, 2u);\n-    /// let res: Option<Vec<uint>> = v.iter().map(|x: &uint|\n-    ///     if *x == uint::MAX { None }\n+    /// let res: Option<Vec<uint>> = v.iter().map(|&x: &uint|\n+    ///     if x == uint::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n     /// assert!(res == Some(vec!(2u, 3u)));"}, {"sha": "2ad5521bb76cd044b332f0e303a71bb1da1cc3df", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -894,8 +894,8 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// use std::uint;\n     ///\n     /// let v = vec!(1u, 2u);\n-    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|x: &uint|\n-    ///     if *x == uint::MAX { Err(\"Overflow!\") }\n+    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|&x: &uint|\n+    ///     if x == uint::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n     /// assert!(res == Ok(vec!(2u, 3u)));"}, {"sha": "aeab18ca05e30565d553bcd5257f433b8cc448a3", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -356,7 +356,7 @@ fn test_iterator_size_hint() {\n     assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n     assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n     assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-    assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.map(|&i| i+1).size_hint(), (10, Some(10)));\n     assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n }\n \n@@ -388,9 +388,9 @@ fn test_any() {\n #[test]\n fn test_find() {\n     let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n-    assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n-    assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n-    assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n+    assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n+    assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n+    assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n }\n \n #[test]"}, {"sha": "76caa42b850230ef07a398c1fd8bda8d9161a54a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -1167,25 +1167,25 @@ impl cmp::PartialEq for InferRegion {\n \n impl fmt::Show for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n-        write!(f, \"<generic #{}>\", self.index)\n+        write!(f, \"_#{}t\", self.index)\n     }\n }\n \n impl fmt::Show for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"<generic integer #{}>\", self.index)\n+        write!(f, \"_#{}i\", self.index)\n     }\n }\n \n impl fmt::Show for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"<generic float #{}>\", self.index)\n+        write!(f, \"_#{}f\", self.index)\n     }\n }\n \n impl fmt::Show for RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"'<generic lifetime #{}>\", self.index)\n+        write!(f, \"'_#{}r\", self.index)\n     }\n }\n \n@@ -5566,3 +5566,18 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T)\n         Some(d) => f(d.as_slice())\n     }\n }\n+\n+impl AutoAdjustment {\n+    pub fn is_identity(&self) -> bool {\n+        match *self {\n+            AdjustAddEnv(..) => false,\n+            AdjustDerefRef(ref r) => r.is_identity(),\n+        }\n+    }\n+}\n+\n+impl AutoDerefRef {\n+    pub fn is_identity(&self) -> bool {\n+        self.autoderefs == 0 && self.autoref.is_none()\n+    }\n+}"}, {"sha": "abffa857a089a79558dee7b88578be509e2b50b3", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 237, "deletions": 54, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -96,6 +96,7 @@ use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::TypeAndSubsts;\n+use middle::typeck::check::vtable;\n use middle::ty_fold::TypeFoldable;\n use util::common::indenter;\n use util::ppaux;\n@@ -173,46 +174,178 @@ pub fn lookup<'a, 'tcx>(\n \n pub fn lookup_in_trait<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-    // In a call `a.b::<X, Y, ...>(...)`:\n-    span: Span,                         // The expression `a.b(...)`'s span.\n-    self_expr: Option<&'a ast::Expr>,   // The expression `a`, if available.\n-    m_name: ast::Name,                  // The name `b`.\n-    trait_did: DefId,                   // The trait to limit the lookup to.\n-    self_ty: ty::t,                     // The type of `a`.\n-    supplied_tps: &'a [ty::t])          // The list of types X, Y, ... .\n+    span: Span,\n+    self_expr: Option<&'a ast::Expr>,\n+    m_name: ast::Name,\n+    trait_def_id: DefId,\n+    self_ty: ty::t,\n+    opt_input_types: Option<Vec<ty::t>>)\n     -> Option<MethodCallee>\n {\n-    let mut lcx = LookupContext {\n-        fcx: fcx,\n-        span: span,\n-        self_expr: self_expr,\n-        m_name: m_name,\n-        supplied_tps: supplied_tps,\n-        impl_dups: HashSet::new(),\n-        inherent_candidates: Vec::new(),\n-        extension_candidates: Vec::new(),\n-        static_candidates: Vec::new(),\n-        deref_args: check::DoDerefArgs,\n-        check_traits: CheckTraitsOnly,\n-        autoderef_receiver: DontAutoderefReceiver,\n-    };\n+    lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n+                             ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                             self_ty, opt_input_types)\n+}\n \n-    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_did={})\",\n+pub fn lookup_in_trait_adjusted<'a, 'tcx>(\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    span: Span,\n+    self_expr: Option<&'a ast::Expr>,\n+    m_name: ast::Name,\n+    trait_def_id: DefId,\n+    autoderefref: ty::AutoDerefRef,\n+    self_ty: ty::t,\n+    opt_input_types: Option<Vec<ty::t>>)\n+    -> Option<MethodCallee>\n+{\n+    debug!(\"method lookup_in_trait(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n            self_ty.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()),\n            m_name.repr(fcx.tcx()),\n-           trait_did.repr(fcx.tcx()));\n+           trait_def_id.repr(fcx.tcx()));\n+\n+    let trait_def = ty::lookup_trait_def(fcx.tcx(), trait_def_id);\n+\n+    let expected_number_of_input_types = trait_def.generics.types.len(subst::TypeSpace);\n+    let input_types = match opt_input_types {\n+        Some(input_types) => {\n+            assert_eq!(expected_number_of_input_types, input_types.len());\n+            input_types\n+        }\n+\n+        None => {\n+            fcx.inh.infcx.next_ty_vars(expected_number_of_input_types)\n+        }\n+    };\n+\n+    let number_assoc_types = trait_def.generics.types.len(subst::AssocSpace);\n+    let assoc_types = fcx.inh.infcx.next_ty_vars(number_assoc_types);\n \n-    lcx.push_bound_candidates(self_ty, Some(trait_did));\n-    lcx.push_extension_candidate(trait_did);\n+    assert_eq!(trait_def.generics.types.len(subst::FnSpace), 0);\n+    assert!(trait_def.generics.regions.is_empty());\n \n-    // when doing a trait search, ambiguity can't really happen except\n-    // as part of the trait-lookup in general\n-    match lcx.search(self_ty) {\n-        Ok(callee) => Some(callee),\n-        Err(_) => None\n+    // Construct a trait-reference `self_ty : Trait<input_tys>`\n+    let substs = subst::Substs::new_trait(input_types, Vec::new(), assoc_types, self_ty);\n+    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n+\n+    // Construct an obligation\n+    let obligation = traits::Obligation::misc(span, trait_ref.clone());\n+\n+    // Now we want to know if this can be matched\n+    let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n+                                                  &fcx.inh.param_env,\n+                                                  fcx);\n+    if !selcx.evaluate_obligation_intracrate(&obligation) {\n+        debug!(\"--> Cannot match obligation\");\n+        return None; // Cannot be matched, no such method resolution is possible.\n+    }\n+\n+    // Trait must have a method named `m_name` and it should not have\n+    // type parameters or early-bound regions.\n+    let tcx = fcx.tcx();\n+    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n+    assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n+    assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n+\n+    // Substitute the trait parameters into the method type and\n+    // instantiate late-bound regions to get the actual method type.\n+    let ref bare_fn_ty = method_ty.fty;\n+    let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n+    let fn_sig = replace_late_bound_regions_with_fresh_var(fcx.infcx(), span,\n+                                                           fn_sig.binder_id, &fn_sig);\n+    let transformed_self_ty = fn_sig.inputs[0];\n+    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+        sig: fn_sig,\n+        fn_style: bare_fn_ty.fn_style,\n+        abi: bare_fn_ty.abi.clone(),\n+    });\n+\n+    debug!(\"matched method fty={} obligation={}\",\n+           fty.repr(fcx.tcx()),\n+           obligation.repr(fcx.tcx()));\n+\n+    // Register obligations for the parameters.  This will include the\n+    // `Self` parameter, which in turn has a bound of the main trait,\n+    // so this also effectively registers `obligation` as well.  (We\n+    // used to register `obligation` explicitly, but that resulted in\n+    // double error messages being reported.)\n+    fcx.add_obligations_for_parameters(\n+        traits::ObligationCause::misc(span),\n+        &trait_ref.substs,\n+        &method_ty.generics);\n+\n+    // FIXME(#18653) -- Try to resolve obligations, giving us more\n+    // typing information, which can sometimes be needed to avoid\n+    // pathological region inference failures.\n+    vtable::select_new_fcx_obligations(fcx);\n+\n+    // Insert any adjustments needed (always an autoref of some mutability).\n+    match self_expr {\n+        None => { }\n+\n+        Some(self_expr) => {\n+            debug!(\"inserting adjustment if needed (self-id = {}, \\\n+                   base adjustment = {}, explicit self = {})\",\n+                   self_expr.id, autoderefref, method_ty.explicit_self);\n+\n+            match method_ty.explicit_self {\n+                ty::ByValueExplicitSelfCategory => {\n+                    // Trait method is fn(self), no transformation needed.\n+                    if !autoderefref.is_identity() {\n+                        fcx.write_adjustment(\n+                            self_expr.id,\n+                            span,\n+                            ty::AdjustDerefRef(autoderefref));\n+                    }\n+                }\n+\n+                ty::ByReferenceExplicitSelfCategory(..) => {\n+                    // Trait method is fn(&self) or fn(&mut self), need an\n+                    // autoref. Pull the region etc out of the type of first argument.\n+                    match ty::get(transformed_self_ty).sty {\n+                        ty::ty_rptr(region, ty::mt { mutbl, ty: _ }) => {\n+                            let ty::AutoDerefRef { autoderefs, autoref } = autoderefref;\n+                            let autoref = autoref.map(|r| box r);\n+                            fcx.write_adjustment(\n+                                self_expr.id,\n+                                span,\n+                                ty::AdjustDerefRef(ty::AutoDerefRef {\n+                                    autoderefs: autoderefs,\n+                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n+                                }));\n+                        }\n+\n+                        _ => {\n+                            fcx.tcx().sess.span_bug(\n+                                span,\n+                                format!(\n+                                    \"trait method is &self but first arg is: {}\",\n+                                    transformed_self_ty.repr(fcx.tcx())).as_slice());\n+                        }\n+                    }\n+                }\n+\n+                _ => {\n+                    fcx.tcx().sess.span_bug(\n+                        span,\n+                        format!(\n+                            \"unexpected explicit self type in operator method: {}\",\n+                            method_ty.explicit_self).as_slice());\n+                }\n+            }\n+        }\n     }\n+\n+    let callee = MethodCallee {\n+        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n+                                            method_num: method_num}),\n+        ty: fty,\n+        substs: trait_ref.substs.clone()\n+    };\n+\n+    debug!(\"callee = {}\", callee.repr(fcx.tcx()));\n+\n+    Some(callee)\n }\n \n pub fn report_error(fcx: &FnCtxt,\n@@ -1446,9 +1579,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n-    fn fixup_derefs_on_method_receiver_if_necessary(\n-            &self,\n-            method_callee: &MethodCallee) {\n+    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n+                                                    method_callee: &MethodCallee) {\n         let sig = match ty::get(method_callee.ty).sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n@@ -1485,6 +1617,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n+        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={}\",\n+               exprs.repr(self.tcx()));\n+\n         // Fix up autoderefs and derefs.\n         for (i, expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n@@ -1500,6 +1635,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 Some(_) | None => 0,\n             };\n \n+            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={} autoderef_count={}\",\n+                   i, expr.repr(self.tcx()), autoderef_count);\n+\n             if autoderef_count > 0 {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n@@ -1518,24 +1656,59 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             // Don't retry the first one or we might infinite loop!\n             if i != 0 {\n                 match expr.node {\n-                    ast::ExprIndex(ref base_expr, ref index_expr) => {\n-                        check::try_overloaded_index(\n-                                self.fcx,\n-                                Some(MethodCall::expr(expr.id)),\n-                                *expr,\n+                    ast::ExprIndex(ref base_expr, _) => {\n+                        let mut base_adjustment =\n+                            match self.fcx.inh.adjustments.borrow().find(&base_expr.id) {\n+                                Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n+                                None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n+                                Some(_) => {\n+                                    self.tcx().sess.span_bug(\n+                                        base_expr.span,\n+                                        \"unexpected adjustment type\");\n+                                }\n+                            };\n+\n+                        // If this is an overloaded index, the\n+                        // adjustment will include an extra layer of\n+                        // autoref because the method is an &self/&mut\n+                        // self method. We have to peel it off to get\n+                        // the raw adjustment that `try_index_step`\n+                        // expects. This is annoying and horrible. We\n+                        // ought to recode this routine so it doesn't\n+                        // (ab)use the normal type checking paths.\n+                        base_adjustment.autoref = match base_adjustment.autoref {\n+                            None => { None }\n+                            Some(AutoPtr(_, _, None)) => { None }\n+                            Some(AutoPtr(_, _, Some(box r))) => { Some(r) }\n+                            Some(_) => {\n+                                self.tcx().sess.span_bug(\n+                                    base_expr.span,\n+                                    \"unexpected adjustment autoref\");\n+                            }\n+                        };\n+\n+                        let adjusted_base_ty =\n+                            self.fcx.adjust_expr_ty(\n                                 &**base_expr,\n-                                self.fcx.expr_ty(&**base_expr),\n-                                index_expr,\n-                                PreferMutLvalue);\n+                                Some(&ty::AdjustDerefRef(base_adjustment.clone())));\n+\n+                        check::try_index_step(\n+                            self.fcx,\n+                            MethodCall::expr(expr.id),\n+                            *expr,\n+                            &**base_expr,\n+                            adjusted_base_ty,\n+                            base_adjustment,\n+                            PreferMutLvalue);\n                     }\n                     ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n                         check::try_overloaded_deref(\n-                                self.fcx,\n-                                expr.span,\n-                                Some(MethodCall::expr(expr.id)),\n-                                Some(&**base_expr),\n-                                self.fcx.expr_ty(&**base_expr),\n-                                PreferMutLvalue);\n+                            self.fcx,\n+                            expr.span,\n+                            Some(MethodCall::expr(expr.id)),\n+                            Some(&**base_expr),\n+                            self.fcx.expr_ty(&**base_expr),\n+                            PreferMutLvalue);\n                     }\n                     _ => {}\n                 }\n@@ -1623,15 +1796,25 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn replace_late_bound_regions_with_fresh_var<T>(&self, binder_id: ast::NodeId, value: &T) -> T\n         where T : TypeFoldable + Repr\n     {\n-        let (_, value) = replace_late_bound_regions(\n-            self.fcx.tcx(),\n-            binder_id,\n-            value,\n-            |br| self.fcx.infcx().next_region_var(infer::LateBoundRegion(self.span, br)));\n-        value\n+        replace_late_bound_regions_with_fresh_var(self.fcx.infcx(), self.span, binder_id, value)\n     }\n }\n \n+fn replace_late_bound_regions_with_fresh_var<T>(infcx: &infer::InferCtxt,\n+                                                span: Span,\n+                                                binder_id: ast::NodeId,\n+                                                value: &T)\n+                                                -> T\n+    where T : TypeFoldable + Repr\n+{\n+    let (_, value) = replace_late_bound_regions(\n+        infcx.tcx,\n+        binder_id,\n+        value,\n+        |br| infcx.next_region_var(infer::LateBoundRegion(span, br)));\n+    value\n+}\n+\n fn trait_method(tcx: &ty::ctxt,\n                 trait_def_id: ast::DefId,\n                 method_name: ast::Name)"}, {"sha": "0e3a77ba9639c78db9ca9d24c6eb8228454359e0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 325, "deletions": 161, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -1630,6 +1630,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             adj: ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n+        if adj.is_identity() {\n+            return;\n+        }\n+\n         // Careful: adjustments can imply trait obligations if we are\n         // casting from a concrete type to an object type. I think\n         // it'd probably be nicer to move the logic that creates the\n@@ -1813,6 +1817,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> ty::t {\n+        /*!\n+         * Fetch type of `expr` after applying adjustments that\n+         * have been recorded in the fcx.\n+         */\n+\n+        let adjustments = self.inh.adjustments.borrow();\n+        let adjustment = adjustments.find(&expr.id);\n+        self.adjust_expr_ty(expr, adjustment)\n+    }\n+\n+    pub fn adjust_expr_ty(&self,\n+                          expr: &ast::Expr,\n+                          adjustment: Option<&ty::AutoAdjustment>)\n+                          -> ty::t\n+    {\n+        /*!\n+         * Apply `adjustment` to the type of `expr`\n+         */\n+\n+        let raw_ty = self.expr_ty(expr);\n+        let raw_ty = self.infcx().shallow_resolve(raw_ty);\n+        ty::adjust_ty(self.tcx(),\n+                      expr.span,\n+                      expr.id,\n+                      raw_ty,\n+                      adjustment,\n+                      |method_call| self.inh.method_map.borrow()\n+                                                       .find(&method_call)\n+                                                       .map(|method| method.ty))\n+    }\n+\n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n         match self.inh.node_types.borrow().find(&id) {\n             Some(&t) => t,\n@@ -2062,6 +2098,10 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n+        if ty::type_is_error(resolved_t) {\n+            return (resolved_t, autoderefs, None);\n+        }\n+\n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n             None => {}\n@@ -2117,17 +2157,17 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n             None => continue,\n             Some(function_trait) => function_trait,\n         };\n-        let method_callee = match method::lookup_in_trait(\n-                fcx,\n-                call_expression.span,\n-                Some(&*callee),\n-                method_name,\n-                function_trait,\n-                callee_type,\n-                []) {\n-            None => continue,\n-            Some(method_callee) => method_callee,\n-        };\n+        let method_callee =\n+            match method::lookup_in_trait(fcx,\n+                                          call_expression.span,\n+                                          Some(&*callee),\n+                                          method_name,\n+                                          function_trait,\n+                                          callee_type,\n+                                          None) {\n+                None => continue,\n+                Some(method_callee) => method_callee,\n+            };\n         let method_call = MethodCall::expr(call_expression.id);\n         let output_type = check_method_argument_types(fcx,\n                                                       call_expression.span,\n@@ -2159,13 +2199,14 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n                         base_expr: Option<&ast::Expr>,\n                         base_ty: ty::t,\n                         lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt> {\n+                        -> Option<ty::mt>\n+{\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref_mut\"), trait_did,\n-                                    base_ty, [])\n+                                    base_ty, None)\n         }\n         _ => None\n     };\n@@ -2175,25 +2216,27 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait(fcx, span, base_expr.map(|x| &*x),\n                                     token::intern(\"deref\"), trait_did,\n-                                    base_ty, [])\n+                                    base_ty, None)\n         }\n         (method, _) => method\n     };\n \n-    make_return_type(fcx, method_call, method)\n+    make_overloaded_lvalue_return_type(fcx, method_call, method)\n }\n \n-fn get_method_ty(method: &Option<MethodCallee>) -> ty::t {\n-    match method {\n-        &Some(ref method) => method.ty,\n-        &None => ty::mk_err()\n-    }\n-}\n+fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n+                                      method_call: Option<MethodCall>,\n+                                      method: Option<MethodCallee>)\n+                                      -> Option<ty::mt>\n+{\n+    /*!\n+     * For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n+     * returns a type of `&T`, but the actual type we assign to the\n+     * *expression* is `T`. So this function just peels off the return\n+     * type by one layer to yield `T`. It also inserts the\n+     * `method-callee` into the method map.\n+     */\n \n-fn make_return_type(fcx: &FnCtxt,\n-                    method_call: Option<MethodCall>,\n-                    method: Option<MethodCallee>)\n-                    -> Option<ty::mt> {\n     match method {\n         Some(method) => {\n             let ref_ty = ty::ty_fn_ret(method.ty);\n@@ -2205,26 +2248,126 @@ fn make_return_type(fcx: &FnCtxt,\n                 None => {}\n             }\n             match ref_ty {\n-                ty::FnConverging(ref_ty) =>\n-                    ty::deref(ref_ty, true),\n-                ty::FnDiverging =>\n-                    None\n+                ty::FnConverging(ref_ty) => {\n+                    ty::deref(ref_ty, true)\n+                }\n+                ty::FnDiverging => {\n+                    fcx.tcx().sess.bug(\"index/deref traits do not define a `!` return\")\n+                }\n             }\n         }\n         None => None,\n     }\n }\n \n+fn autoderef_for_index<T>(fcx: &FnCtxt,\n+                          base_expr: &ast::Expr,\n+                          base_ty: ty::t,\n+                          lvalue_pref: LvaluePreference,\n+                          step: |ty::t, ty::AutoDerefRef| -> Option<T>)\n+                          -> Option<T>\n+{\n+    let (ty, autoderefs, final_mt) =\n+        autoderef(fcx, base_expr.span, base_ty, Some(base_expr.id), lvalue_pref, |adj_ty, idx| {\n+            let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n+            step(adj_ty, autoderefref)\n+        });\n+\n+    if final_mt.is_some() {\n+        return final_mt;\n+    }\n+\n+    // After we have fully autoderef'd, if the resulting type is [T, ..n], then\n+    // do a final unsized coercion to yield [T].\n+    match ty::get(ty).sty {\n+        ty::ty_vec(element_ty, Some(n)) => {\n+            let adjusted_ty = ty::mk_vec(fcx.tcx(), element_ty, None);\n+            let autoderefref = ty::AutoDerefRef {\n+                autoderefs: autoderefs,\n+                autoref: Some(ty::AutoUnsize(ty::UnsizeLength(n)))\n+            };\n+            step(adjusted_ty, autoderefref)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+\n fn try_overloaded_slice(fcx: &FnCtxt,\n-                        method_call: Option<MethodCall>,\n+                        method_call: MethodCall,\n                         expr: &ast::Expr,\n                         base_expr: &ast::Expr,\n                         base_ty: ty::t,\n                         start_expr: &Option<P<ast::Expr>>,\n                         end_expr: &Option<P<ast::Expr>>,\n-                        mutbl: &ast::Mutability)\n-                        -> Option<ty::mt> {\n-    let method = if mutbl == &ast::MutMutable {\n+                        mutbl: ast::Mutability)\n+                        -> Option<ty::t> // return type is result of slice\n+{\n+    /*!\n+     * Autoderefs `base_expr`, looking for a `Slice` impl. If it\n+     * finds one, installs the relevant method info and returns the\n+     * result type (else None).\n+     */\n+\n+    let lvalue_pref = match mutbl {\n+        ast::MutMutable => PreferMutLvalue,\n+        ast::MutImmutable => NoPreference\n+    };\n+\n+    let opt_method_ty =\n+        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n+            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n+                                      adjusted_ty, autoderefref, mutbl,\n+                                      start_expr, end_expr)\n+        });\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_ty_or_err = opt_method_ty.unwrap_or(ty::mk_err());\n+\n+    let mut args = vec![];\n+    start_expr.as_ref().map(|x| args.push(x));\n+    end_expr.as_ref().map(|x| args.push(x));\n+\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_ty_or_err,\n+                                expr,\n+                                args.as_slice(),\n+                                DoDerefArgs,\n+                                DontTupleArguments);\n+\n+    opt_method_ty.map(|method_ty| {\n+        let result_ty = ty::ty_fn_ret(method_ty);\n+        match result_ty {\n+            ty::FnConverging(result_ty) => result_ty,\n+            ty::FnDiverging => {\n+                fcx.tcx().sess.span_bug(expr.span,\n+                                        \"slice trait does not define a `!` return\")\n+            }\n+        }\n+    })\n+}\n+\n+fn try_overloaded_slice_step(fcx: &FnCtxt,\n+                             method_call: MethodCall,\n+                             expr: &ast::Expr,\n+                             base_expr: &ast::Expr,\n+                             base_ty: ty::t, // autoderef'd type\n+                             autoderefref: ty::AutoDerefRef,\n+                             mutbl: ast::Mutability,\n+                             start_expr: &Option<P<ast::Expr>>,\n+                             end_expr: &Option<P<ast::Expr>>)\n+                             -> Option<ty::t> // result type is type of method being called\n+{\n+    /*!\n+     * Checks for a `Slice` (or `SliceMut`) impl at the relevant level\n+     * of autoderef. If it finds one, installs method info and returns\n+     * type of method (else None).\n+     */\n+\n+    let method = if mutbl == ast::MutMutable {\n         // Try `SliceMut` first, if preferred.\n         match fcx.tcx().lang_items.slice_mut_trait() {\n             Some(trait_did) => {\n@@ -2235,13 +2378,14 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                     (&None, &None) => \"as_mut_slice_\",\n                 };\n \n-                method::lookup_in_trait(fcx,\n-                                        expr.span,\n-                                        Some(&*base_expr),\n-                                        token::intern(method_name),\n-                                        trait_did,\n-                                        base_ty,\n-                                        [])\n+                method::lookup_in_trait_adjusted(fcx,\n+                                                 expr.span,\n+                                                 Some(&*base_expr),\n+                                                 token::intern(method_name),\n+                                                 trait_did,\n+                                                 autoderefref,\n+                                                 base_ty,\n+                                                 None)\n             }\n             _ => None,\n         }\n@@ -2258,104 +2402,99 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n                     (&None, &None) => \"as_slice_\",\n                 };\n \n-                method::lookup_in_trait(fcx,\n-                                        expr.span,\n-                                        Some(&*base_expr),\n-                                        token::intern(method_name),\n-                                        trait_did,\n-                                        base_ty,\n-                                        [])\n+                method::lookup_in_trait_adjusted(fcx,\n+                                                 expr.span,\n+                                                 Some(&*base_expr),\n+                                                 token::intern(method_name),\n+                                                 trait_did,\n+                                                 autoderefref,\n+                                                 base_ty,\n+                                                 None)\n             }\n             _ => None,\n         }\n     };\n \n+    // If some lookup succeeded, install method in table\n+    method.map(|method| {\n+        let ty = method.ty;\n+        fcx.inh.method_map.borrow_mut().insert(method_call, method);\n+        ty\n+    })\n+}\n \n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = get_method_ty(&method);\n-\n-    let mut args = vec![];\n-    start_expr.as_ref().map(|x| args.push(x));\n-    end_expr.as_ref().map(|x| args.push(x));\n+fn try_index_step(fcx: &FnCtxt,\n+                  method_call: MethodCall,\n+                  expr: &ast::Expr,\n+                  base_expr: &ast::Expr,\n+                  adjusted_ty: ty::t,\n+                  adjustment: ty::AutoDerefRef,\n+                  lvalue_pref: LvaluePreference)\n+                  -> Option<(/*index type*/ ty::t, /*element type*/ ty::t)>\n+{\n+    /*!\n+     * To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n+     * `base_expr`, looking for a type which either supports builtin indexing or overloaded\n+     * indexing. This loop implements one step in that search; the autoderef loop is implemented\n+     * by `autoderef_for_index`.\n+     */\n \n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_type,\n-                                expr,\n-                                args.as_slice(),\n-                                DoDerefArgs,\n-                                DontTupleArguments);\n+    debug!(\"try_index_step(expr={}, base_expr.id={}, adjusted_ty={}, adjustment={})\",\n+           expr.repr(fcx.tcx()),\n+           base_expr.repr(fcx.tcx()),\n+           adjusted_ty.repr(fcx.tcx()),\n+           adjustment);\n \n-    match method {\n-        Some(method) => {\n-            let result_ty = ty::ty_fn_ret(method.ty);\n-            match method_call {\n-                Some(method_call) => {\n-                    fcx.inh.method_map.borrow_mut().insert(method_call,\n-                                                           method);\n-                }\n-                None => {}\n-            }\n-            match result_ty {\n-                ty::FnConverging(result_ty) =>\n-                    Some(ty::mt { ty: result_ty, mutbl: ast::MutImmutable }),\n-                ty::FnDiverging =>\n-                    None\n-            }\n+    // Try built-in indexing first.\n+    match ty::index(adjusted_ty) {\n+        Some(ty) => {\n+            fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n+            return Some((ty::mk_uint(), ty));\n         }\n-        None => None,\n+\n+        None => { }\n     }\n-}\n \n-fn try_overloaded_index(fcx: &FnCtxt,\n-                        method_call: Option<MethodCall>,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n-                        base_ty: ty::t,\n-                        index_expr: &P<ast::Expr>,\n-                        lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt> {\n+    let input_ty = fcx.infcx().next_ty_var();\n+    let return_ty = fcx.infcx().next_ty_var();\n+\n     // Try `IndexMut` first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.index_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx,\n-                                    expr.span,\n-                                    Some(&*base_expr),\n-                                    token::intern(\"index_mut\"),\n-                                    trait_did,\n-                                    base_ty,\n-                                    [])\n+            method::lookup_in_trait_adjusted(fcx,\n+                                             expr.span,\n+                                             Some(&*base_expr),\n+                                             token::intern(\"index_mut\"),\n+                                             trait_did,\n+                                             adjustment.clone(),\n+                                             adjusted_ty,\n+                                             Some(vec![input_ty, return_ty]))\n         }\n         _ => None,\n     };\n \n     // Otherwise, fall back to `Index`.\n     let method = match (method, fcx.tcx().lang_items.index_trait()) {\n         (None, Some(trait_did)) => {\n-            method::lookup_in_trait(fcx,\n-                                    expr.span,\n-                                    Some(&*base_expr),\n-                                    token::intern(\"index\"),\n-                                    trait_did,\n-                                    base_ty,\n-                                    [])\n+            method::lookup_in_trait_adjusted(fcx,\n+                                             expr.span,\n+                                             Some(&*base_expr),\n+                                             token::intern(\"index\"),\n+                                             trait_did,\n+                                             adjustment,\n+                                             adjusted_ty,\n+                                             Some(vec![input_ty, return_ty]))\n         }\n         (method, _) => method,\n     };\n \n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = get_method_ty(&method);\n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_type,\n-                                expr,\n-                                &[index_expr],\n-                                DoDerefArgs,\n-                                DontTupleArguments);\n-\n-    make_return_type(fcx, method_call, method)\n+    // If some lookup succeeds, write callee into table and extract index/element\n+    // type from the method signature.\n+    // If some lookup succeeded, install method in table\n+    method.map(|method| {\n+        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n+        (input_ty, return_ty)\n+    })\n }\n \n /// Given the head of a `for` expression, looks up the `next` method in the\n@@ -2383,7 +2522,7 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                                          token::intern(\"next\"),\n                                          trait_did,\n                                          expr_type,\n-                                         []);\n+                                         None);\n \n     // Regardless of whether the lookup succeeds, check the method arguments\n     // so that we have *some* type for each argument.\n@@ -2427,10 +2566,15 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n                 }\n+                ty::ty_err => {\n+                    ty::mk_err()\n+                }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            \"`next` method of the `Iterator` \\\n-                                             trait has an unexpected type\");\n+                                            format!(\"`next` method of the `Iterator` \\\n+                                                    trait has an unexpected type `{}`\",\n+                                                    fcx.infcx().ty_to_string(return_type))\n+                                            .as_slice());\n                     ty::mk_err()\n                 }\n             }\n@@ -2457,7 +2601,7 @@ fn check_method_argument_types<'a>(fcx: &FnCtxt,\n                              deref_args,\n                              false,\n                              tuple_arguments);\n-        ty::FnConverging(method_fn_ty)\n+        ty::FnConverging(ty::mk_err())\n     } else {\n         match ty::get(method_fn_ty).sty {\n             ty::ty_bare_fn(ref fty) => {\n@@ -3060,8 +3204,36 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                   unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex.span, Some(lhs), opname,\n-                                        trait_did, lhs_ty, &[])\n+                // We do eager coercions to make using operators\n+                // more ergonomic:\n+                //\n+                // - If the input is of type &'a T (resp. &'a mut T),\n+                //   then reborrow it to &'b T (resp. &'b mut T) where\n+                //   'b <= 'a.  This makes things like `x == y`, where\n+                //   `x` and `y` are both region pointers, work.  We\n+                //   could also solve this with variance or different\n+                //   traits that don't force left and right to have same\n+                //   type.\n+                let (adj_ty, adjustment) = match ty::get(lhs_ty).sty {\n+                    ty::ty_rptr(r_in, mt) => {\n+                        let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n+                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n+                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n+                        let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n+                        let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n+                        (adjusted_ty, adjustment)\n+                    }\n+                    _ => {\n+                        (lhs_ty, ty::AutoDerefRef { autoderefs: 0, autoref: None })\n+                    }\n+                };\n+\n+                debug!(\"adjusted_ty={} adjustment={}\",\n+                       adj_ty.repr(fcx.tcx()),\n+                       adjustment);\n+\n+                method::lookup_in_trait_adjusted(fcx, op_ex.span, Some(lhs), opname,\n+                                                 trait_did, adjustment, adj_ty, None)\n             }\n             None => None\n         };\n@@ -4338,55 +4510,47 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n           check_expr(fcx, &**idx);\n-          let raw_base_t = fcx.expr_ty(&**base);\n+          let base_t = fcx.expr_ty(&**base);\n           let idx_t = fcx.expr_ty(&**idx);\n-          if ty::type_is_error(raw_base_t) {\n-              fcx.write_ty(id, raw_base_t);\n+          if ty::type_is_error(base_t) {\n+              fcx.write_ty(id, base_t);\n           } else if ty::type_is_error(idx_t) {\n               fcx.write_ty(id, idx_t);\n           } else {\n-              let (_, autoderefs, field_ty) =\n-                autoderef(fcx, expr.span, raw_base_t, Some(base.id),\n-                          lvalue_pref, |base_t, _| ty::index(base_t));\n-              match field_ty {\n-                  Some(ty) => {\n-                      check_expr_has_type(fcx, &**idx, ty::mk_uint());\n-                      fcx.write_ty(id, ty);\n-                      fcx.write_autoderef_adjustment(base.id, base.span, autoderefs);\n+              let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+\n+              let result =\n+                  autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                      try_index_step(fcx,\n+                                     MethodCall::expr(expr.id),\n+                                     expr,\n+                                     &**base,\n+                                     adj_ty,\n+                                     adj,\n+                                     lvalue_pref)\n+                  });\n+\n+              match result {\n+                  Some((index_ty, element_ty)) => {\n+                      check_expr_has_type(fcx, &**idx, index_ty);\n+                      fcx.write_ty(id, element_ty);\n                   }\n                   _ => {\n-                      // This is an overloaded method.\n-                      let base_t = structurally_resolved_type(fcx,\n-                                                              expr.span,\n-                                                              raw_base_t);\n-                      let method_call = MethodCall::expr(expr.id);\n-                      match try_overloaded_index(fcx,\n-                                                 Some(method_call),\n-                                                 expr,\n-                                                 &**base,\n-                                                 base_t,\n-                                                 idx,\n-                                                 lvalue_pref) {\n-                          Some(mt) => fcx.write_ty(id, mt.ty),\n-                          None => {\n-                                fcx.type_error_message(expr.span,\n-                                                       |actual| {\n-                                                        format!(\"cannot \\\n-                                                                 index a \\\n-                                                                 value of \\\n-                                                                 type `{}`\",\n-                                                                actual)\n-                                                       },\n-                                                       base_t,\n-                                                       None);\n-                                fcx.write_ty(id, ty::mk_err())\n-                          }\n-                      }\n+                      check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                      fcx.type_error_message(\n+                          expr.span,\n+                          |actual| {\n+                              format!(\"cannot index a value of type `{}`\",\n+                                      actual)\n+                          },\n+                          base_t,\n+                          None);\n+                      fcx.write_ty(id, ty::mk_err())\n                   }\n               }\n           }\n        }\n-       ast::ExprSlice(ref base, ref start, ref end, ref mutbl) => {\n+       ast::ExprSlice(ref base, ref start, ref end, mutbl) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n           let raw_base_t = fcx.expr_ty(&**base);\n \n@@ -4415,19 +4579,19 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                       raw_base_t);\n               let method_call = MethodCall::expr(expr.id);\n               match try_overloaded_slice(fcx,\n-                                         Some(method_call),\n+                                         method_call,\n                                          expr,\n                                          &**base,\n                                          base_t,\n                                          start,\n                                          end,\n                                          mutbl) {\n-                  Some(mt) => fcx.write_ty(id, mt.ty),\n+                  Some(ty) => fcx.write_ty(id, ty),\n                   None => {\n                         fcx.type_error_message(expr.span,\n                            |actual| {\n                                 format!(\"cannot take a {}slice of a value with type `{}`\",\n-                                        if mutbl == &ast::MutMutable {\n+                                        if mutbl == ast::MutMutable {\n                                             \"mutable \"\n                                         } else {\n                                             \"\""}, {"sha": "cdc45890c09ea71d9df79ea44fe2572639970760", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -952,6 +952,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                              -> Vec<VarValue>\n     {\n         let mut var_data = self.construct_var_data();\n+\n+        // Dorky hack to cause `dump_constraints` to only get called\n+        // if debug mode is enabled:\n+        debug!(\"----() End constraint listing {}---\", self.dump_constraints());\n+\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n@@ -974,6 +979,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         })\n     }\n \n+    fn dump_constraints(&self) {\n+        debug!(\"----() Start constraint listing ()----\");\n+        for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n+            debug!(\"Constraint {} => {}\", idx, constraint.repr(self.tcx));\n+        }\n+    }\n+\n     fn expansion(&self, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={} origin={}\","}, {"sha": "33e1419753249453245ad72a3fa9adc5edd23b8f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -32,6 +32,7 @@ use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n@@ -372,14 +373,10 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n         let print_var_ids = cx.sess.verbose();\n         match ty {\n-            ty::TyVar(ty::TyVid { index: vid }) if print_var_ids =>\n-                format!(\"_#{}\", vid),\n-            ty::IntVar(ty::IntVid { index: vid }) if print_var_ids =>\n-                format!(\"_#{}i\", vid),\n-            ty::FloatVar(ty::FloatVid { index: vid }) if print_var_ids =>\n-                format!(\"_#{}f\", vid),\n-            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) =>\n-                \"_\".to_string(),\n+            ty::TyVar(ref vid) if print_var_ids => vid.repr(cx),\n+            ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n+            ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n+            ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n             ty::SkolemizedTy(v) => format!(\"SkolemizedTy({})\", v),\n             ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v)\n         }\n@@ -561,6 +558,12 @@ impl<T:Repr> Repr for Option<T> {\n     }\n }\n \n+impl<T:Repr> Repr for P<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        (*self).repr(tcx)\n+    }\n+}\n+\n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match self {\n@@ -851,7 +854,7 @@ impl Repr for ty::Region {\n             }\n \n             ty::ReInfer(ReVar(ref vid)) => {\n-                format!(\"ReInfer({})\", vid.index)\n+                format!(\"{}\", vid)\n             }\n \n             ty::ReInfer(ReSkolemized(id, ref bound_region)) => {"}, {"sha": "d8023dd3e4e3bcf2c1be18d6b685fedc9fe2ba8d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -177,13 +177,13 @@ macro_rules! bitflags {\n             /// Returns `true` if there are flags common to both `self` and `other`.\n             #[inline]\n             pub fn intersects(&self, other: $BitFlags) -> bool {\n-                !(self & other).is_empty()\n+                !(*self & other).is_empty()\n             }\n \n             /// Returns `true` all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub fn contains(&self, other: $BitFlags) -> bool {\n-                (self & other) == other\n+                (*self & other) == other\n             }\n \n             /// Inserts the specified flags in-place."}, {"sha": "688036d22dd6e583573b468c875969b714f670c9", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -792,7 +792,7 @@ mod test_set {\n         };\n \n         let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(['a', 'b'] == v.as_slice() || ['b', 'a'] == v.as_slice());\n+        assert!(['a', 'b'][] == v.as_slice() || ['b', 'a'][] == v.as_slice());\n     }\n \n     #[test]"}, {"sha": "c3adae8cff83930253b76e3584abe0326158774d", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -319,7 +319,7 @@ impl fmt::Show for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,\n         // but we need to print it anyway.\n-        let (abs, sign) = if self.secs < 0 { (-self, \"-\") } else { (*self, \"\") };\n+        let (abs, sign) = if self.secs < 0 { (-*self, \"-\") } else { (*self, \"\") };\n \n         let days = abs.secs / SECS_PER_DAY;\n         let secs = abs.secs - days * SECS_PER_DAY;"}, {"sha": "ac3574f5a03ee55859db873ddbfbcc9f9448c162", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -96,7 +96,7 @@ impl Add<Duration, Timespec> for Timespec {\n         let d_sec = other.num_seconds();\n         // It is safe to unwrap the nanoseconds, because there cannot be\n         // more than one second left, which fits in i64 and in i32.\n-        let d_nsec = (other - Duration::seconds(d_sec))\n+        let d_nsec = (*other - Duration::seconds(d_sec))\n                      .num_nanoseconds().unwrap() as i32;\n         let mut sec = self.sec + d_sec;\n         let mut nsec = self.nsec + d_nsec;"}, {"sha": "47e1969172d2f0cb49bd3abe2dab0f0ae0ad587b", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -290,7 +290,7 @@ fn search(\n     let masks_at = &masks[i];\n \n     // for every unused piece\n-    for id in range(0u, 10).filter(|id| board & (1 << (id + 50)) == 0) {\n+    for id in range(0u, 10).filter(|&id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n         for m in masks_at[id].iter().filter(|&m| board & *m == 0) {\n             // This check is too costly."}, {"sha": "2253d7512c053c5615c45dbd5f702a5f789a28b0", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we still see borrowck errors of various kinds when using\n+// indexing and autoderef in combination.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<String,int> for Foo {\n+    fn index<'a>(&'a self, z: &String) -> &'a int {\n+        if z.as_slice() == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<String,int> for Foo {\n+    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut int {\n+        if z.as_slice() == \"x\" {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+fn test1(mut f: Box<Foo>, s: String) {\n+    let _p = &mut f[s];\n+    let _q = &f[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test2(mut f: Box<Foo>, s: String) {\n+    let _p = &mut f[s];\n+    let _q = &mut f[s]; //~ ERROR cannot borrow\n+}\n+\n+struct Bar {\n+    foo: Foo\n+}\n+\n+fn test3(mut f: Box<Bar>, s: String) {\n+    let _p = &mut f.foo[s];\n+    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test4(mut f: Box<Bar>, s: String) {\n+    let _p = &f.foo[s];\n+    let _q = &f.foo[s];\n+}\n+\n+fn test5(mut f: Box<Bar>, s: String) {\n+    let _p = &f.foo[s];\n+    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+}\n+\n+fn test6(mut f: Box<Bar>, g: Foo, s: String) {\n+    let _p = &f.foo[s];\n+    f.foo = g; //~ ERROR cannot assign\n+}\n+\n+fn test7(mut f: Box<Bar>, g: Bar, s: String) {\n+    let _p = &f.foo[s];\n+    *f = g; //~ ERROR cannot assign\n+}\n+\n+fn test8(mut f: Box<Bar>, g: Foo, s: String) {\n+    let _p = &mut f.foo[s];\n+    f.foo = g; //~ ERROR cannot assign\n+}\n+\n+fn test9(mut f: Box<Bar>, g: Bar, s: String) {\n+    let _p = &mut f.foo[s];\n+    *f = g; //~ ERROR cannot assign\n+}\n+\n+fn main() {\n+}\n+\n+"}, {"sha": "4ec8c2b1b7ea580773294a6a374395b9321886a7", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = [1,2];\n     let y = match x {\n         [] => None,\n-        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7, ..0]`\n+        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7t, ..0]`\n         //         (expected array of 2 elements, found array of 0 elements)\n         [a,_] => Some(a)\n     };"}, {"sha": "61877775269d1f049e1a778153a05368d8ba4a50", "filename": "src/test/compile-fail/issue-15207.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15207.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     loop {\n         break.push(1) //~ ERROR the type of this value must be known in this context\n-        //~^ ERROR multiple applicable methods in scope\n         ;\n     }\n }"}, {"sha": "5048a9aa919c6e3dc8381b035bf31ac3ef4fb796", "filename": "src/test/compile-fail/issue-17033.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17033.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -11,7 +11,7 @@\n #![feature(overloaded_calls)]\n \n fn f<'r>(p: &'r mut fn(p: &mut ())) {\n-    p(()) //~ ERROR mismatched types: expected `&mut ()`, found `()`\n+    (*p)(()) //~ ERROR mismatched types: expected `&mut ()`, found `()`\n }\n \n fn main() {}"}, {"sha": "1150f40db762f7849622dc7b6f1b6d3fb62efa27", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -18,7 +18,6 @@ impl<A> vec_monad<A> for Vec<A> {\n         let mut r = panic!();\n         for elt in self.iter() { r = r + f(*elt); }\n         //~^ ERROR the type of this value must be known\n-        //~^^ ERROR not implemented\n    }\n }\n fn main() {"}, {"sha": "6778ed88ff70bf69dd6b33d6fee6e17eb5b1528f", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n-    let y = x[mut 2..4]; //~ ERROR cannot take a mutable slice of a value with type `&[int]`\n+    let y = x[mut 2..4]; //~ ERROR cannot borrow\n }"}, {"sha": "c87e85417582d953501dfbb2765073b91967f664", "filename": "src/test/compile-fail/type-params-in-different-spaces-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-params-in-different-spaces-1.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -12,7 +12,7 @@ use std::num::Num;\n \n trait BrokenAdd: Num {\n     fn broken_add<T>(&self, rhs: T) -> Self {\n-        *self + rhs //~ ERROR mismatched types\n+        *self + rhs //~ ERROR expected `Self`, found `T`\n     }\n }\n "}, {"sha": "fc79e4f0edb368035c5bd6693480836dae27e3cf", "filename": "src/test/run-pass/operator-multidispatch.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can overload the `+` operator for points so that two\n+// points can be added, and a point can be added to an integer.\n+\n+use std::ops;\n+\n+#[deriving(Show,PartialEq,Eq)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl ops::Add<Point,Point> for Point {\n+    fn add(&self, other: &Point) -> Point {\n+        Point {x: self.x + (*other).x, y: self.y + (*other).y}\n+    }\n+}\n+\n+impl ops::Add<int,Point> for Point {\n+    fn add(&self, &other: &int) -> Point {\n+        Point {x: self.x + other,\n+               y: self.y + other}\n+    }\n+}\n+\n+pub fn main() {\n+    let mut p = Point {x: 10, y: 20};\n+    p = p + Point {x: 101, y: 102};\n+    assert_eq!(p, Point {x: 111, y: 122});\n+    p = p + 1;\n+    assert_eq!(p, Point {x: 112, y: 123});\n+}"}, {"sha": "7c6ad45a9efe1ce84088467bab71e2d3b2c872ca", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "previous_filename": "src/test/run-pass/overload-index-operator.rs"}, {"sha": "d51956da89409733dbb5e3edd7470ae1148f2801", "filename": "src/test/run-pass/overloaded-index-autoderef.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test overloaded indexing combined with autoderef.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+impl Index<int,int> for Foo {\n+    fn index(&self, z: &int) -> &int {\n+        if *z == 0 {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<int,int> for Foo {\n+    fn index_mut(&mut self, z: &int) -> &mut int {\n+        if *z == 0 {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n+fn main() {\n+    let mut f = box Foo {\n+        x: 1,\n+        y: 2,\n+    };\n+\n+    assert_eq!(f[1], 2);\n+\n+    f[0] = 3;\n+\n+    assert_eq!(f[0], 3);\n+\n+    // Test explicit IndexMut where `f` must be autoderef:\n+    {\n+        let p = &mut f[1];\n+        *p = 4;\n+    }\n+\n+    // Test explicit Index where `f` must be autoderef:\n+    {\n+        let p = &f[1];\n+        assert_eq!(*p, 4);\n+    }\n+\n+    // Test calling methods with `&mut self`, `self, and `&self` receivers:\n+    f[1].inc();\n+    assert_eq!(f[1].get(), 5);\n+    assert_eq!(f[1].get_from_ref(), 5);\n+}\n+"}, {"sha": "e8b0408ca0dc00499fa53db06086c374e115de37", "filename": "src/test/run-pass/overloaded-index-in-field.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test using overloaded indexing when the \"map\" is stored in a\n+// field. This caused problems at some point.\n+\n+struct Foo {\n+    x: int,\n+    y: int,\n+}\n+\n+struct Bar {\n+    foo: Foo\n+}\n+\n+impl Index<int,int> for Foo {\n+    fn index(&self, z: &int) -> &int {\n+        if *z == 0 {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n+fn main() {\n+    let f = Bar { foo: Foo {\n+        x: 1,\n+        y: 2,\n+    } };\n+    assert_eq!(f.foo[1].get(), 2);\n+}\n+"}, {"sha": "23bebfa35d7f305238ce801e1532c72aab545ef8", "filename": "src/test/run-pass/overloaded-index.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63c4f22f2bf9f1c070311cdc08c6ceb279434733/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=63c4f22f2bf9f1c070311cdc08c6ceb279434733", "patch": "@@ -33,6 +33,18 @@ impl IndexMut<int,int> for Foo {\n     }\n }\n \n+trait Int {\n+    fn get(self) -> int;\n+    fn get_from_ref(&self) -> int;\n+    fn inc(&mut self);\n+}\n+\n+impl Int for int {\n+    fn get(self) -> int { self }\n+    fn get_from_ref(&self) -> int { *self }\n+    fn inc(&mut self) { *self += 1; }\n+}\n+\n fn main() {\n     let mut f = Foo {\n         x: 1,\n@@ -49,5 +61,10 @@ fn main() {\n         let p = &f[1];\n         assert_eq!(*p, 4);\n     }\n+\n+    // Test calling methods with `&mut self`, `self, and `&self` receivers:\n+    f[1].inc();\n+    assert_eq!(f[1].get(), 5);\n+    assert_eq!(f[1].get_from_ref(), 5);\n }\n "}]}