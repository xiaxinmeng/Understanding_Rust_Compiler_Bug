{"sha": "471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MWY1YTFmOWE4YmYyNGVmZjM1MTgzMDMxYWQzOGI5ZTExZWViMGE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-10-15T12:51:30Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2015-10-27T19:55:04Z"}, "message": "Generalise associative operator parsing\n\nThis commit generalises parsing of associative operators from left-associative\nonly (with some ugly hacks to support right-associative assignment) to properly\nleft/right-associative operators.\n\nParsing still is not general enough to handle non-associative,\nnon-highest-precedence prefix or non-highest-precedence postfix operators (e.g.\n`..` range syntax), though. That should be fixed in the future.\n\nLastly, this commit adds support for parsing right-associative `<-` (left arrow)\noperator with precedence higher than assignment as the operator for placement-in\nfeature.", "tree": {"sha": "01d9a1c7f23e05e0181ad624ab012d0f63143c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d9a1c7f23e05e0181ad624ab012d0f63143c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "html_url": "https://github.com/rust-lang/rust/commit/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "url": "https://api.github.com/repos/rust-lang/rust/commits/540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "html_url": "https://github.com/rust-lang/rust/commit/540fd3aa715c8af7efb4b06b7f9ab6da398deb62"}], "stats": {"total": 528, "additions": 334, "deletions": 194}, "files": [{"sha": "f1c88232fc45a4b3fad6f2646d5d5d28a48bb2ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -242,26 +242,6 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     }\n }\n \n-/// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp_) -> usize {\n-  match op {\n-      // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11,\n-      BiAdd | BiSub             => 10,\n-      BiShl | BiShr             =>  9,\n-      BiBitAnd                  =>  8,\n-      BiBitXor                  =>  7,\n-      BiBitOr                   =>  6,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3,\n-      BiAnd                     =>  2,\n-      BiOr                      =>  1\n-  }\n-}\n-\n-/// Precedence of the `as` operator, which is a binary operator\n-/// not appearing in the prior table.\n-pub const AS_PREC: usize = 12;\n-\n pub fn empty_generics() -> Generics {\n     Generics {\n         lifetimes: Vec::new(),"}, {"sha": "406b763ca4654026b97a6167176df5c711e843d9", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -66,6 +66,7 @@ pub mod util {\n     #[cfg(test)]\n     pub mod parser_testing;\n     pub mod small_vector;\n+    pub mod parser;\n }\n \n pub mod diagnostics {"}, {"sha": "f4e14a6ee36e396ebab29aaf1b1a3177a6c7e4f6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 132, "deletions": 131, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -15,7 +15,7 @@ use ast::BareFnTy;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n-use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n+use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n use ast::{Constness, ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n@@ -60,7 +60,7 @@ use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n-use ast_util::{self, AS_PREC, ident_to_path, operator_prec};\n+use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n use diagnostic;\n use ext::tt::macro_parser;\n@@ -73,6 +73,7 @@ use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n+use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use owned_slice::OwnedSlice;\n@@ -2597,7 +2598,7 @@ impl<'a> Parser<'a> {\n         Ok(tts)\n     }\n \n-    /// Parse a prefix-operator expr\n+    /// Parse a prefix-unary-operator expr\n     pub fn parse_prefix_expr(&mut self) -> PResult<P<Expr>> {\n         let lo = self.span.lo;\n         let hi;\n@@ -2634,8 +2635,10 @@ impl<'a> Parser<'a> {\n               try!(self.bump());\n               let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n               let blk = try!(self.parse_block());\n-              hi = blk.span.hi;\n-              let blk_expr = self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk));\n+              let span = blk.span;\n+              hi = span.hi;\n+              let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n+              self.span_warn(span, \"in PLACE BLOCK syntax is deprecated and will be removed soon\");\n               ex = ExprInPlace(place, blk_expr);\n           }\n           token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n@@ -2649,65 +2652,146 @@ impl<'a> Parser<'a> {\n         return Ok(self.mk_expr(lo, hi, ex));\n     }\n \n-    /// Parse an expression of binops\n-    pub fn parse_binops(&mut self) -> PResult<P<Expr>> {\n-        let prefix_expr = try!(self.parse_prefix_expr());\n-        self.parse_more_binops(prefix_expr, 0)\n+    /// Parse an associative expression\n+    ///\n+    /// This parses an expression accounting for associativity and precedence of the operators in\n+    /// the expression.\n+    pub fn parse_assoc_expr(&mut self) -> PResult<P<Expr>> {\n+        if self.token == token::DotDot {\n+            // prefix-form of range notation `..expr` and `..`\n+            // This has the precedence just higher than assignment expressions (much lower than\n+            // other prefix expressions) to be consistent with the postfix-form `expr..`\n+            // If it isn\u2019t clear yet, this is a hack of the worst kind (one that also probably\n+            // can\u2019t be fixed anymore because stability guarantees).\n+            let lo = self.span.lo;\n+            let mut hi = self.span.hi;\n+            try!(self.bump());\n+            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n+                // RHS must be parsed with more associativity than DotDot.\n+                let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n+                let end = try!(self.parse_assoc_expr_with(next_prec, None));\n+                hi = end.span.hi;\n+                Some(end)\n+            } else {\n+                None\n+            };\n+            let r = self.mk_range(None, opt_end);\n+            Ok(self.mk_expr(lo, hi, r))\n+        } else {\n+            self.parse_assoc_expr_with(0, None)\n+        }\n     }\n \n-    /// Parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: usize) -> PResult<P<Expr>> {\n-        if self.expr_is_complete(&*lhs) { return Ok(lhs); }\n-\n+    /// Parse an associative expression with operators of at least `min_prec` precedence\n+    pub fn parse_assoc_expr_with(&mut self, min_prec: usize, lhs: Option<P<Expr>>) -> PResult<P<Expr>> {\n+        let mut lhs = if lhs.is_some() {\n+            lhs.unwrap()\n+        } else {\n+            try!(self.parse_prefix_expr())\n+        };\n+        if self.expr_is_complete(&*lhs) && min_prec == 0 {\n+            // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n+            return Ok(lhs);\n+        }\n+        let cur_op_span = self.span;\n         self.expected_tokens.push(TokenType::Operator);\n+        while let Some(op) = AssocOp::from_token(&self.token) {\n+            if op.precedence() < min_prec {\n+                break;\n+            }\n+            try!(self.bump());\n+            if op.is_comparison() {\n+                self.check_no_chained_comparison(&*lhs, &op);\n+            }\n+            // Special cases:\n+            if op == AssocOp::As {\n+                let rhs = try!(self.parse_ty_nopanic());\n+                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprCast(lhs, rhs));\n+                continue\n+            } else if op == AssocOp::DotDot {\n+                    // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n+                    // here by simply doing something along the lines of\n+                    //\n+                    //     break_from_this_loop_after_setting_lhs = true;\n+                    //     rhs = self.parse_assoc_expr_with(op.precedence() + 1, None);\n+                    //\n+                    // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n+                    // handled in `parse_assoc_expr`\n+                    let rhs = if self.is_at_start_of_range_notation_rhs() {\n+                        self.parse_assoc_expr_with(op.precedence() + 1, None).ok()\n+                    } else {\n+                        None\n+                    };\n+                    let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                        x.span\n+                    } else {\n+                        cur_op_span\n+                    });\n+                    let r = self.mk_range(Some(lhs), rhs);\n+                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r);\n+                    break\n+            }\n \n-        let cur_op_span = self.span;\n-        let cur_opt = self.token.to_binop();\n-        match cur_opt {\n-            Some(cur_op) => {\n-                if ast_util::is_comparison_binop(cur_op) {\n-                    self.check_no_chained_comparison(&*lhs, cur_op)\n-                }\n-                let cur_prec = operator_prec(cur_op);\n-                if cur_prec >= min_prec {\n-                    try!(self.bump());\n-                    let expr = try!(self.parse_prefix_expr());\n-                    let rhs = try!(self.parse_more_binops(expr, cur_prec + 1));\n-                    let lhs_span = lhs.span;\n-                    let rhs_span = rhs.span;\n-                    let binary = self.mk_binary(codemap::respan(cur_op_span, cur_op), lhs, rhs);\n-                    let bin = self.mk_expr(lhs_span.lo, rhs_span.hi, binary);\n-                    self.parse_more_binops(bin, min_prec)\n-                } else {\n-                    Ok(lhs)\n+            let rhs = try!(match op.fixity() {\n+                Fixity::Right => self.parse_assoc_expr_with(op.precedence(), None),\n+                Fixity::Left => self.parse_assoc_expr_with(op.precedence() + 1, None),\n+                // We currently have no non-associative operators that are not handled above by\n+                // the special cases. The code is here only for future convenience.\n+                Fixity::None => self.parse_assoc_expr_with(op.precedence() + 1, None),\n+            });\n+\n+            lhs = match op {\n+                AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n+                AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n+                AssocOp::BitAnd | AssocOp::BitOr | AssocOp::ShiftLeft | AssocOp::ShiftRight |\n+                AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n+                AssocOp::Greater | AssocOp::GreaterEqual => {\n+                    let ast_op = op.to_ast_binop().unwrap();\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary)\n                 }\n-            }\n-            None => {\n-                if AS_PREC >= min_prec && try!(self.eat_keyword_noexpect(keywords::As) ){\n-                    let rhs = try!(self.parse_ty_nopanic());\n-                    let _as = self.mk_expr(lhs.span.lo,\n-                                           rhs.span.hi,\n-                                           ExprCast(lhs, rhs));\n-                    self.parse_more_binops(_as, min_prec)\n-                } else {\n-                    Ok(lhs)\n+                AssocOp::Assign =>\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)),\n+                AssocOp::Inplace =>\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs)),\n+                AssocOp::AssignOp(k) => {\n+                    let aop = match k {\n+                        token::Plus =>    BiAdd,\n+                        token::Minus =>   BiSub,\n+                        token::Star =>    BiMul,\n+                        token::Slash =>   BiDiv,\n+                        token::Percent => BiRem,\n+                        token::Caret =>   BiBitXor,\n+                        token::And =>     BiBitAnd,\n+                        token::Or =>      BiBitOr,\n+                        token::Shl =>     BiShl,\n+                        token::Shr =>     BiShr\n+                    };\n+                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr)\n                 }\n-            }\n+                AssocOp::As | AssocOp::DotDot => self.bug(\"As or DotDot branch reached\")\n+            };\n+\n+            if op.fixity() == Fixity::None { break }\n         }\n+        Ok(lhs)\n     }\n \n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp_) {\n-        debug_assert!(ast_util::is_comparison_binop(outer_op));\n+    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n+        debug_assert!(outer_op.is_comparison());\n         match lhs.node {\n             ExprBinary(op, _, _) if ast_util::is_comparison_binop(op.node) => {\n                 // respan to include both operators\n                 let op_span = mk_sp(op.span.lo, self.span.hi);\n                 self.span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n-                if op.node == BiLt && outer_op == BiGt {\n+                if op.node == BiLt && *outer_op == AssocOp::Greater {\n                     self.fileline_help(op_span,\n                         \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n                 }\n@@ -2716,88 +2800,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse an assignment expression....\n-    /// actually, this seems to be the main entry point for\n-    /// parsing an arbitrary expression.\n-    pub fn parse_assign_expr(&mut self) -> PResult<P<Expr>> {\n-        match self.token {\n-          token::DotDot => {\n-            // prefix-form of range notation '..expr'\n-            // This has the same precedence as assignment expressions\n-            // (much lower than other prefix expressions) to be consistent\n-            // with the postfix-form 'expr..'\n-            let lo = self.span.lo;\n-            let mut hi = self.span.hi;\n-            try!(self.bump());\n-            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-                let end = try!(self.parse_binops());\n-                hi = end.span.hi;\n-                Some(end)\n-            } else {\n-                None\n-            };\n-            let ex = self.mk_range(None, opt_end);\n-            Ok(self.mk_expr(lo, hi, ex))\n-          }\n-          _ => {\n-            let lhs = try!(self.parse_binops());\n-            self.parse_assign_expr_with(lhs)\n-          }\n-        }\n-    }\n-\n-    pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> PResult<P<Expr>> {\n-        let restrictions = self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL;\n-        let op_span = self.span;\n-        match self.token {\n-          token::Eq => {\n-              try!(self.bump());\n-              let rhs = try!(self.parse_expr_res(restrictions));\n-              Ok(self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)))\n-          }\n-          token::BinOpEq(op) => {\n-              try!(self.bump());\n-              let rhs = try!(self.parse_expr_res(restrictions));\n-              let aop = match op {\n-                  token::Plus =>    BiAdd,\n-                  token::Minus =>   BiSub,\n-                  token::Star =>    BiMul,\n-                  token::Slash =>   BiDiv,\n-                  token::Percent => BiRem,\n-                  token::Caret =>   BiBitXor,\n-                  token::And =>     BiBitAnd,\n-                  token::Or =>      BiBitOr,\n-                  token::Shl =>     BiShl,\n-                  token::Shr =>     BiShr\n-              };\n-              let rhs_span = rhs.span;\n-              let span = lhs.span;\n-              let assign_op = self.mk_assign_op(codemap::respan(op_span, aop), lhs, rhs);\n-              Ok(self.mk_expr(span.lo, rhs_span.hi, assign_op))\n-          }\n-          // A range expression, either `expr..expr` or `expr..`.\n-          token::DotDot => {\n-            let lo = lhs.span.lo;\n-            let mut hi = self.span.hi;\n-            try!(self.bump());\n-\n-            let opt_end = if self.is_at_start_of_range_notation_rhs() {\n-                let end = try!(self.parse_binops());\n-                hi = end.span.hi;\n-                Some(end)\n-            } else {\n-                None\n-            };\n-            let range = self.mk_range(Some(lhs), opt_end);\n-            return Ok(self.mk_expr(lo, hi, range));\n-          }\n-\n-          _ => {\n-              Ok(lhs)\n-          }\n-        }\n-    }\n-\n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n@@ -2982,7 +2984,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_expr_res(&mut self, r: Restrictions) -> PResult<P<Expr>> {\n         let old = self.restrictions;\n         self.restrictions = r;\n-        let e = try!(self.parse_assign_expr());\n+        let e = try!(self.parse_assoc_expr());\n         self.restrictions = old;\n         return Ok(e);\n     }\n@@ -3624,8 +3626,7 @@ impl<'a> Parser<'a> {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n                                                      mac.and_then(|m| m.node));\n                             let e = try!(self.parse_dot_or_call_expr_with(e));\n-                            let e = try!(self.parse_more_binops(e, 0));\n-                            let e = try!(self.parse_assign_expr_with(e));\n+                            let e = try!(self.parse_assoc_expr_with(0, Some(e)));\n                             try!(self.handle_expression_like_statement(\n                                 e,\n                                 span,"}, {"sha": "0bdbf132cb8d2cff822e07f6e9fb847057a6fb93", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -14,6 +14,7 @@ use abi;\n use ast;\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast_util;\n+use util::parser::AssocOp;\n use attr;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -445,7 +446,8 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprAssign(..) | ast::ExprBinary(..) |\n         ast::ExprClosure(..) |\n-        ast::ExprAssignOp(..) | ast::ExprCast(..) => true,\n+        ast::ExprAssignOp(..) | ast::ExprCast(..) |\n+        ast::ExprInPlace(..) => true,\n         _ => false,\n     }\n }\n@@ -1776,8 +1778,8 @@ impl<'a> State<'a> {\n                                       binop: ast::BinOp) -> bool {\n         match sub_expr.node {\n             ast::ExprBinary(ref sub_op, _, _) => {\n-                if ast_util::operator_prec(sub_op.node) <\n-                    ast_util::operator_prec(binop.node) {\n+                if AssocOp::from_ast_binop(sub_op.node).precedence() <\n+                    AssocOp::from_ast_binop(binop.node).precedence() {\n                     true\n                 } else {\n                     false\n@@ -1802,10 +1804,10 @@ impl<'a> State<'a> {\n     fn print_expr_in_place(&mut self,\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n-        try!(self.word_space(\"in\"));\n-        try!(self.print_expr(place));\n+        try!(self.print_expr_maybe_paren(place));\n         try!(space(&mut self.s));\n-        self.print_expr(expr)\n+        try!(self.word_space(\"<-\"));\n+        self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {"}, {"sha": "c12cd8e89dbbadc86fd2f39c898b3fdc5d172d0e", "filename": "src/libsyntax/util/parser.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -0,0 +1,191 @@\n+use parse::token::{Token, BinOpToken, keywords};\n+use ast;\n+\n+/// Associative operator with precedence.\n+///\n+/// This is the enum which specifies operator precedence and fixity to the parser.\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum AssocOp {\n+    /// `+`\n+    Add,\n+    /// `-`\n+    Subtract,\n+    /// `*`\n+    Multiply,\n+    /// `/`\n+    Divide,\n+    /// `%`\n+    Modulus,\n+    /// `&&`\n+    LAnd,\n+    /// `||`\n+    LOr,\n+    /// `^`\n+    BitXor,\n+    /// `&`\n+    BitAnd,\n+    /// `|`\n+    BitOr,\n+    /// `<<`\n+    ShiftLeft,\n+    /// `>>`\n+    ShiftRight,\n+    /// `==`\n+    Equal,\n+    /// `<`\n+    Less,\n+    /// `<=`\n+    LessEqual,\n+    /// `!=`\n+    NotEqual,\n+    /// `>`\n+    Greater,\n+    /// `>=`\n+    GreaterEqual,\n+    /// `=`\n+    Assign,\n+    /// `<-`\n+    Inplace,\n+    /// `?=` where ? is one of the BinOpToken\n+    AssignOp(BinOpToken),\n+    /// `as`\n+    As,\n+    /// `..` range\n+    DotDot\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum Fixity {\n+    /// The operator is left-associative\n+    Left,\n+    /// The operator is right-associative\n+    Right,\n+    /// The operator is not associative\n+    None\n+}\n+\n+impl AssocOp {\n+    /// Create a new AssocOP from a token\n+    pub fn from_token(t: &Token) -> Option<AssocOp> {\n+        use self::AssocOp::*;\n+        match *t {\n+            Token::BinOpEq(k) => Some(AssignOp(k)),\n+            Token::LArrow => Some(Inplace),\n+            Token::Eq => Some(Assign),\n+            Token::BinOp(BinOpToken::Star) => Some(Multiply),\n+            Token::BinOp(BinOpToken::Slash) => Some(Divide),\n+            Token::BinOp(BinOpToken::Percent) => Some(Modulus),\n+            Token::BinOp(BinOpToken::Plus) => Some(Add),\n+            Token::BinOp(BinOpToken::Minus) => Some(Subtract),\n+            Token::BinOp(BinOpToken::Shl) => Some(ShiftLeft),\n+            Token::BinOp(BinOpToken::Shr) => Some(ShiftRight),\n+            Token::BinOp(BinOpToken::And) => Some(BitAnd),\n+            Token::BinOp(BinOpToken::Caret) => Some(BitXor),\n+            Token::BinOp(BinOpToken::Or) => Some(BitOr),\n+            Token::Lt => Some(Less),\n+            Token::Le => Some(LessEqual),\n+            Token::Ge => Some(GreaterEqual),\n+            Token::Gt => Some(Greater),\n+            Token::EqEq => Some(Equal),\n+            Token::Ne => Some(NotEqual),\n+            Token::AndAnd => Some(LAnd),\n+            Token::OrOr => Some(LOr),\n+            Token::DotDot => Some(DotDot),\n+            _ if t.is_keyword(keywords::As) => Some(As),\n+            _ => None\n+        }\n+    }\n+\n+    /// Create a new AssocOp from ast::BinOp_.\n+    pub fn from_ast_binop(op: ast::BinOp_) -> Self {\n+        use self::AssocOp::*;\n+        match op {\n+            ast::BiLt => Less,\n+            ast::BiGt => Greater,\n+            ast::BiLe => LessEqual,\n+            ast::BiGe => GreaterEqual,\n+            ast::BiEq => Equal,\n+            ast::BiNe => NotEqual,\n+            ast::BiMul => Multiply,\n+            ast::BiDiv => Divide,\n+            ast::BiRem => Modulus,\n+            ast::BiAdd => Add,\n+            ast::BiSub => Subtract,\n+            ast::BiShl => ShiftLeft,\n+            ast::BiShr => ShiftRight,\n+            ast::BiBitAnd => BitAnd,\n+            ast::BiBitXor => BitXor,\n+            ast::BiBitOr => BitOr,\n+            ast::BiAnd => LAnd,\n+            ast::BiOr => LOr\n+        }\n+    }\n+\n+    /// Gets the precedence of this operator\n+    pub fn precedence(&self) -> usize {\n+        use self::AssocOp::*;\n+        match *self {\n+            As => 14,\n+            Multiply | Divide | Modulus => 13,\n+            Add | Subtract => 12,\n+            ShiftLeft | ShiftRight => 11,\n+            BitAnd => 10,\n+            BitXor => 9,\n+            BitOr => 8,\n+            Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n+            LAnd => 6,\n+            LOr => 5,\n+            DotDot => 4,\n+            Inplace => 3,\n+            Assign | AssignOp(_) => 2,\n+        }\n+    }\n+\n+    /// Gets the fixity of this operator\n+    pub fn fixity(&self) -> Fixity {\n+        use self::AssocOp::*;\n+        // NOTE: it is a bug to have an operators that has same precedence but different fixities!\n+        match *self {\n+            Inplace | Assign | AssignOp(_) => Fixity::Right,\n+            As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n+            BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n+            LAnd | LOr => Fixity::Left,\n+            DotDot => Fixity::None\n+        }\n+    }\n+\n+    pub fn is_comparison(&self) -> bool {\n+        use self::AssocOp::*;\n+        match *self {\n+            Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n+            Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n+            ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot => false\n+        }\n+    }\n+\n+    pub fn to_ast_binop(&self) -> Option<ast::BinOp_> {\n+        use self::AssocOp::*;\n+        match *self {\n+            Less => Some(ast::BiLt),\n+            Greater => Some(ast::BiGt),\n+            LessEqual => Some(ast::BiLe),\n+            GreaterEqual => Some(ast::BiGe),\n+            Equal => Some(ast::BiEq),\n+            NotEqual => Some(ast::BiNe),\n+            Multiply => Some(ast::BiMul),\n+            Divide => Some(ast::BiDiv),\n+            Modulus => Some(ast::BiRem),\n+            Add => Some(ast::BiAdd),\n+            Subtract => Some(ast::BiSub),\n+            ShiftLeft => Some(ast::BiShl),\n+            ShiftRight => Some(ast::BiShr),\n+            BitAnd => Some(ast::BiBitAnd),\n+            BitXor => Some(ast::BiBitXor),\n+            BitOr => Some(ast::BiBitOr),\n+            LAnd => Some(ast::BiAnd),\n+            LOr => Some(ast::BiOr),\n+            Inplace | Assign | AssignOp(_) | As | DotDot => None\n+        }\n+    }\n+\n+}"}, {"sha": "080364c08554f98cb1b055922dbda9f9af141d0e", "filename": "src/test/compile-fail/feature-gate-placement-expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-placement-expr.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -19,6 +19,6 @@\n fn main() {\n     use std::boxed::HEAP;\n \n-    let x = in HEAP { 'c' }; //~ ERROR placement-in expression syntax is experimental\n+    let x = HEAP <- 'c'; //~ ERROR placement-in expression syntax is experimental\n     println!(\"x: {}\", x);\n }"}, {"sha": "8cbec549dda96fc9384a49966235fdf972760f51", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/471f5a1f9a8bf24eff35183031ad38b9e11eeb0a/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=471f5a1f9a8bf24eff35183031ad38b9e11eeb0a", "patch": "@@ -12,6 +12,6 @@\n #![feature(placement_in_syntax)]\n \n fn main() {\n-    in () { 0 };\n+    () <- 0;\n     //~^ ERROR: the trait `core::ops::Placer<_>` is not implemented\n }"}, {"sha": "1388f8745df57aebfe9470b4e174d404275aba38", "filename": "src/test/parse-fail/removed-syntax-larrow-init.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-init.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn removed_moves() {\n-    let mut x = 0;\n-    let y <- x;\n-    //~^ ERROR expected one of `:`, `;`, `=`, or `@`, found `<-`\n-}"}, {"sha": "0736e483a49792e0f80b9a9806cf0bf5afd6b41f", "filename": "src/test/parse-fail/removed-syntax-larrow-move.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/540fd3aa715c8af7efb4b06b7f9ab6da398deb62/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-larrow-move.rs?ref=540fd3aa715c8af7efb4b06b7f9ab6da398deb62", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn removed_moves() {\n-    let mut x = 0;\n-    let y = 0;\n-    y <- x;\n-    //~^ ERROR expected one of `!`, `.`, `::`, `;`, `{`, `}`, or an operator, found `<-`\n-}"}]}