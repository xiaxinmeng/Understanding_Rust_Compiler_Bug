{"sha": "d582ed5684de1951774b637ccfe8b4cf8bd2008b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ODJlZDU2ODRkZTE5NTE3NzRiNjM3Y2NmZThiNGNmOGJkMjAwOGI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T16:10:50Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-05T18:32:26Z"}, "message": "Inline max_slice_length\n\nNote that where we previously ran `max_slice_len` with input having not\nonly matrix.heads() but also v.head(). Now we run it on matrix.heads()\nonly, but also take into account the currently processed constructor.\nThis preserves behavior since `pat_constructors` returns only one\nconstructor in the case that is of interest for us.", "tree": {"sha": "4bf2dda35d2a3a0f6d618a6caf72ad40d6128836", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bf2dda35d2a3a0f6d618a6caf72ad40d6128836"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d582ed5684de1951774b637ccfe8b4cf8bd2008b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d582ed5684de1951774b637ccfe8b4cf8bd2008b", "html_url": "https://github.com/rust-lang/rust/commit/d582ed5684de1951774b637ccfe8b4cf8bd2008b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d582ed5684de1951774b637ccfe8b4cf8bd2008b/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "149792b6080f40875c0072aae378a0eb31d23df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/149792b6080f40875c0072aae378a0eb31d23df0", "html_url": "https://github.com/rust-lang/rust/commit/149792b6080f40875c0072aae378a0eb31d23df0"}], "stats": {"total": 205, "additions": 99, "deletions": 106}, "files": [{"sha": "15f88334e8d5e2e6f36273bf489d61231ab94998", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 99, "deletions": 106, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/d582ed5684de1951774b637ccfe8b4cf8bd2008b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d582ed5684de1951774b637ccfe8b4cf8bd2008b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d582ed5684de1951774b637ccfe8b4cf8bd2008b", "patch": "@@ -985,7 +985,6 @@ pub enum WitnessPreference {\n #[derive(Copy, Clone, Debug)]\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n-    max_slice_length: u64,\n     span: Span,\n }\n \n@@ -1143,108 +1142,6 @@ fn all_constructors<'a, 'tcx>(\n     ctors\n }\n \n-fn max_slice_length<'p, 'a, 'tcx, I>(cx: &mut MatchCheckCtxt<'a, 'tcx>, patterns: I) -> u64\n-where\n-    I: Iterator<Item = &'p Pat<'tcx>>,\n-    'tcx: 'p,\n-{\n-    // The exhaustiveness-checking paper does not include any details on\n-    // checking variable-length slice patterns. However, they are matched\n-    // by an infinite collection of fixed-length array patterns.\n-    //\n-    // Checking the infinite set directly would take an infinite amount\n-    // of time. However, it turns out that for each finite set of\n-    // patterns `P`, all sufficiently large array lengths are equivalent:\n-    //\n-    // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n-    // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n-    // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n-    // the same subset of `P`.\n-    //\n-    // Because of that, each witness for reachability-checking from one\n-    // of the sufficiently-large lengths can be transformed to an\n-    // equally-valid witness from any other length, so we only have\n-    // to check slice lengths from the \"minimal sufficiently-large length\"\n-    // and below.\n-    //\n-    // Note that the fact that there is a *single* `s\u2098` for each `m`\n-    // not depending on the specific pattern in `P` is important: if\n-    // you look at the pair of patterns\n-    //     `[true, ..]`\n-    //     `[.., false]`\n-    // Then any slice of length \u22651 that matches one of these two\n-    // patterns can be trivially turned to a slice of any\n-    // other length \u22651 that matches them and vice-versa - for\n-    // but the slice from length 2 `[false, true]` that matches neither\n-    // of these patterns can't be turned to a slice from length 1 that\n-    // matches neither of these patterns, so we have to consider\n-    // slices from length 2 there.\n-    //\n-    // Now, to see that that length exists and find it, observe that slice\n-    // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n-    // \"variable-length\" patterns (`[_, .., _]`).\n-    //\n-    // For fixed-length patterns, all slices with lengths *longer* than\n-    // the pattern's length have the same outcome (of not matching), so\n-    // as long as `L` is greater than the pattern's length we can pick\n-    // any `s\u2098` from that length and get the same result.\n-    //\n-    // For variable-length patterns, the situation is more complicated,\n-    // because as seen above the precise value of `s\u2098` matters.\n-    //\n-    // However, for each variable-length pattern `p` with a prefix of length\n-    // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n-    // `sl\u209a` elements are examined.\n-    //\n-    // Therefore, as long as `L` is positive (to avoid concerns about empty\n-    // types), all elements after the maximum prefix length and before\n-    // the maximum suffix length are not examined by any variable-length\n-    // pattern, and therefore can be added/removed without affecting\n-    // them - creating equivalent patterns from any sufficiently-large\n-    // length.\n-    //\n-    // Of course, if fixed-length patterns exist, we must be sure\n-    // that our length is large enough to miss them all, so\n-    // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n-    //\n-    // for example, with the above pair of patterns, all elements\n-    // but the first and last can be added/removed, so any\n-    // witness of length \u22652 (say, `[false, false, true]`) can be\n-    // turned to a witness from any other length \u22652.\n-\n-    let mut max_prefix_len = 0;\n-    let mut max_suffix_len = 0;\n-    let mut max_fixed_len = 0;\n-\n-    for row in patterns {\n-        match *row.kind {\n-            PatKind::Constant { value } => {\n-                // extract the length of an array/slice from a constant\n-                match (value.val, &value.ty.kind) {\n-                    (_, ty::Array(_, n)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, n.eval_usize(cx.tcx, cx.param_env))\n-                    }\n-                    (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n-                        max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n-                let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n-                max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n-            }\n-            PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n-                max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n-                max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n-}\n-\n /// An inclusive interval, used for precise integer exhaustiveness checking.\n /// `IntRange`s always store a contiguous range. This means that values are\n /// encoded such that `0` encodes the minimum value for the integer,\n@@ -1609,7 +1506,6 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n         ty,\n-        max_slice_length: max_slice_length(cx, matrix.heads().chain(Some(v.head()))),\n         span,\n     };\n \n@@ -2088,8 +1984,105 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n-            VarLenSlice(prefix, suffix) => {\n-                split_ctors.extend((prefix + suffix..pcx.max_slice_length + 1).map(FixedLenSlice))\n+            VarLenSlice(self_prefix, self_suffix) => {\n+                // The exhaustiveness-checking paper does not include any details on\n+                // checking variable-length slice patterns. However, they are matched\n+                // by an infinite collection of fixed-length array patterns.\n+                //\n+                // Checking the infinite set directly would take an infinite amount\n+                // of time. However, it turns out that for each finite set of\n+                // patterns `P`, all sufficiently large array lengths are equivalent:\n+                //\n+                // Each slice `s` with a \"sufficiently-large\" length `l \u2265 L` that applies\n+                // to exactly the subset `P\u209c` of `P` can be transformed to a slice\n+                // `s\u2098` for each sufficiently-large length `m` that applies to exactly\n+                // the same subset of `P`.\n+                //\n+                // Because of that, each witness for reachability-checking from one\n+                // of the sufficiently-large lengths can be transformed to an\n+                // equally-valid witness from any other length, so we only have\n+                // to check slice lengths from the \"minimal sufficiently-large length\"\n+                // and below.\n+                //\n+                // Note that the fact that there is a *single* `s\u2098` for each `m`\n+                // not depending on the specific pattern in `P` is important: if\n+                // you look at the pair of patterns\n+                //     `[true, ..]`\n+                //     `[.., false]`\n+                // Then any slice of length \u22651 that matches one of these two\n+                // patterns can be trivially turned to a slice of any\n+                // other length \u22651 that matches them and vice-versa - for\n+                // but the slice from length 2 `[false, true]` that matches neither\n+                // of these patterns can't be turned to a slice from length 1 that\n+                // matches neither of these patterns, so we have to consider\n+                // slices from length 2 there.\n+                //\n+                // Now, to see that that length exists and find it, observe that slice\n+                // patterns are either \"fixed-length\" patterns (`[_, _, _]`) or\n+                // \"variable-length\" patterns (`[_, .., _]`).\n+                //\n+                // For fixed-length patterns, all slices with lengths *longer* than\n+                // the pattern's length have the same outcome (of not matching), so\n+                // as long as `L` is greater than the pattern's length we can pick\n+                // any `s\u2098` from that length and get the same result.\n+                //\n+                // For variable-length patterns, the situation is more complicated,\n+                // because as seen above the precise value of `s\u2098` matters.\n+                //\n+                // However, for each variable-length pattern `p` with a prefix of length\n+                // `pl\u209a` and suffix of length `sl\u209a`, only the first `pl\u209a` and the last\n+                // `sl\u209a` elements are examined.\n+                //\n+                // Therefore, as long as `L` is positive (to avoid concerns about empty\n+                // types), all elements after the maximum prefix length and before\n+                // the maximum suffix length are not examined by any variable-length\n+                // pattern, and therefore can be added/removed without affecting\n+                // them - creating equivalent patterns from any sufficiently-large\n+                // length.\n+                //\n+                // Of course, if fixed-length patterns exist, we must be sure\n+                // that our length is large enough to miss them all, so\n+                // we can pick `L = max(FIXED_LEN+1 \u222a {max(PREFIX_LEN) + max(SUFFIX_LEN)})`\n+                //\n+                // for example, with the above pair of patterns, all elements\n+                // but the first and last can be added/removed, so any\n+                // witness of length \u22652 (say, `[false, false, true]`) can be\n+                // turned to a witness from any other length \u22652.\n+\n+                let mut max_prefix_len = self_prefix;\n+                let mut max_suffix_len = self_suffix;\n+                let mut max_fixed_len = 0;\n+\n+                for row in matrix.heads() {\n+                    match *row.kind {\n+                        PatKind::Constant { value } => {\n+                            // extract the length of an array/slice from a constant\n+                            match (value.val, &value.ty.kind) {\n+                                (_, ty::Array(_, n)) => {\n+                                    max_fixed_len =\n+                                        cmp::max(max_fixed_len, n.eval_usize(tcx, param_env))\n+                                }\n+                                (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n+                                    max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                        PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n+                            let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n+                            max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n+                        }\n+                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix } => {\n+                            max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n+                            max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                let max_slice_length = cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len);\n+                split_ctors\n+                    .extend((self_prefix + self_suffix..=max_slice_length).map(FixedLenSlice))\n             }\n             // Any other constructor can be used unchanged.\n             _ => split_ctors.push(ctor),"}]}