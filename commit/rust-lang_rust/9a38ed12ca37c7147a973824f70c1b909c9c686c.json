{"sha": "9a38ed12ca37c7147a973824f70c1b909c9c686c", "node_id": "C_kwDOAAsO6NoAKDlhMzhlZDEyY2EzN2M3MTQ3YTk3MzgyNGY3MGMxYjkwOWM5YzY4NmM", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-24T19:31:17Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-24T19:35:36Z"}, "message": "Rename args to check_argument_types  and add some comments for what they are", "tree": {"sha": "54cd15448d26676fbd4b0b11504d53423b6f043f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54cd15448d26676fbd4b0b11504d53423b6f043f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a38ed12ca37c7147a973824f70c1b909c9c686c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a38ed12ca37c7147a973824f70c1b909c9c686c", "html_url": "https://github.com/rust-lang/rust/commit/9a38ed12ca37c7147a973824f70c1b909c9c686c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a38ed12ca37c7147a973824f70c1b909c9c686c/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e100ec5bc7cd768ec17d75448b29c9ab4a39272b", "html_url": "https://github.com/rust-lang/rust/commit/e100ec5bc7cd768ec17d75448b29c9ab4a39272b"}], "stats": {"total": 83, "additions": 46, "deletions": 37}, "files": [{"sha": "3ef939df755fdb93ad6fc68be1668e1b304d24d6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9a38ed12ca37c7147a973824f70c1b909c9c686c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a38ed12ca37c7147a973824f70c1b909c9c686c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=9a38ed12ca37c7147a973824f70c1b909c9c686c", "patch": "@@ -96,34 +96,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// method calls and overloaded operators.\n     pub(in super::super) fn check_argument_types(\n         &self,\n-        sp: Span,\n-        expr: &'tcx hir::Expr<'tcx>,\n-        fn_inputs: &[Ty<'tcx>],\n-        expected_arg_tys: &[Ty<'tcx>],\n-        args: &'tcx [hir::Expr<'tcx>],\n+        // Span enclosing the call site\n+        call_span: Span,\n+        // Expression of the call site\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        // Types (as defined in the *signature* of the target function)\n+        formal_input_tys: &[Ty<'tcx>],\n+        // More specific expected types, after unifying with caller output types\n+        expected_input_tys: &[Ty<'tcx>],\n+        // The expressions for each provided argument\n+        provided_args: &'tcx [hir::Expr<'tcx>],\n+        // Whether the function is variadic, for example when imported from C\n         c_variadic: bool,\n+        // Whether the arguments have been bundled in a tuple (ex: closures)\n         tuple_arguments: TupleArgumentsFlag,\n-        def_id: Option<DefId>,\n+        // The DefId for the function being called, for better error messages\n+        fn_def_id: Option<DefId>,\n     ) {\n         let tcx = self.tcx;\n         // Grab the argument types, supplying fresh type variables\n         // if the wrong number of arguments were supplied\n-        let supplied_arg_count = if tuple_arguments == DontTupleArguments { args.len() } else { 1 };\n+        let supplied_arg_count =\n+            if tuple_arguments == DontTupleArguments { provided_args.len() } else { 1 };\n \n         // All the input types from the fn signature must outlive the call\n         // so as to validate implied bounds.\n-        for (&fn_input_ty, arg_expr) in iter::zip(fn_inputs, args) {\n+        for (&fn_input_ty, arg_expr) in iter::zip(formal_input_tys, provided_args) {\n             self.register_wf_obligation(fn_input_ty.into(), arg_expr.span, traits::MiscObligation);\n         }\n \n-        let expected_arg_count = fn_inputs.len();\n+        let expected_arg_count = formal_input_tys.len();\n \n         let param_count_error = |expected_count: usize,\n                                  arg_count: usize,\n                                  error_code: &str,\n                                  c_variadic: bool,\n                                  sugg_unit: bool| {\n-            let (span, start_span, args, ctor_of) = match &expr.kind {\n+            let (span, start_span, args, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n                     hir::Expr {\n                         span,\n@@ -156,14 +165,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     &args[1..], // Skip the receiver.\n                     None,       // methods are never ctors\n                 ),\n-                k => span_bug!(sp, \"checking argument types on a non-call: `{:?}`\", k),\n+                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n             };\n-            let arg_spans = if args.is_empty() {\n+            let arg_spans = if provided_args.is_empty() {\n                 // foo()\n                 // ^^^-- supplied 0 arguments\n                 // |\n                 // expected 2 arguments\n-                vec![tcx.sess.source_map().next_point(start_span).with_hi(sp.hi())]\n+                vec![tcx.sess.source_map().next_point(start_span).with_hi(call_span.hi())]\n             } else {\n                 // foo(1, 2, 3)\n                 // ^^^ -  -  - supplied 3 arguments\n@@ -196,7 +205,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n \n-            if let Some(def_id) = def_id {\n+            if let Some(def_id) = fn_def_id {\n                 if let Some(def_span) = tcx.def_ident_span(def_id) {\n                     let mut spans: MultiSpan = def_span.into();\n \n@@ -218,7 +227,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             if sugg_unit {\n-                let sugg_span = tcx.sess.source_map().end_point(expr.span);\n+                let sugg_span = tcx.sess.source_map().end_point(call_expr.span);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n                 err.span_suggestion(\n@@ -240,15 +249,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.emit();\n         };\n \n-        let mut expected_arg_tys = expected_arg_tys.to_vec();\n+        let mut expected_arg_tys = expected_input_tys.to_vec();\n \n         let formal_tys = if tuple_arguments == TupleArguments {\n-            let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n+            let tuple_type = self.structurally_resolved_type(call_span, formal_input_tys[0]);\n             match tuple_type.kind() {\n-                ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n-                    param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n+                ty::Tuple(arg_types) if arg_types.len() != provided_args.len() => {\n+                    param_count_error(arg_types.len(), provided_args.len(), \"E0057\", false, false);\n                     expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                    self.err_args(provided_args.len())\n                 }\n                 ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n@@ -263,21 +272,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => {\n                     struct_span_err!(\n                         tcx.sess,\n-                        sp,\n+                        call_span,\n                         E0059,\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n                     .emit();\n                     expected_arg_tys = vec![];\n-                    self.err_args(args.len())\n+                    self.err_args(provided_args.len())\n                 }\n             }\n         } else if expected_arg_count == supplied_arg_count {\n-            fn_inputs.to_vec()\n+            formal_input_tys.to_vec()\n         } else if c_variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.to_vec()\n+                formal_input_tys.to_vec()\n             } else {\n                 param_count_error(expected_arg_count, supplied_arg_count, \"E0060\", true, false);\n                 expected_arg_tys = vec![];\n@@ -287,8 +296,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n                 self.resolve_vars_if_possible(expected_arg_tys[0]).is_unit()\n-            } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_vars_if_possible(fn_inputs[0]).is_unit()\n+            } else if formal_input_tys.len() == 1 && supplied_arg_count == 0 {\n+                self.resolve_vars_if_possible(formal_input_tys[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -322,13 +331,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // the call. This helps coercions.\n             if check_closures {\n                 self.select_obligations_where_possible(false, |errors| {\n-                    self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                     self.point_at_arg_instead_of_call_if_possible(\n                         errors,\n                         &final_arg_types,\n-                        expr,\n-                        sp,\n-                        &args,\n+                        call_expr,\n+                        call_span,\n+                        &provided_args,\n                     );\n                 })\n             }\n@@ -339,11 +348,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let t = if c_variadic {\n                 expected_arg_count\n             } else if tuple_arguments == TupleArguments {\n-                args.len()\n+                provided_args.len()\n             } else {\n                 supplied_arg_count\n             };\n-            for (i, arg) in args.iter().take(t).enumerate() {\n+            for (i, arg) in provided_args.iter().take(t).enumerate() {\n                 // Warn only for the first loop (the \"no closures\" one).\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n@@ -380,13 +389,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let _ = self.resolve_vars_with_obligations_and_mutate_fulfillment(\n                     coerce_ty,\n                     |errors| {\n-                        self.point_at_type_arg_instead_of_call_if_possible(errors, expr);\n+                        self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n                         self.point_at_arg_instead_of_call_if_possible(\n                             errors,\n                             &final_arg_types,\n-                            expr,\n-                            sp,\n-                            args,\n+                            call_expr,\n+                            call_span,\n+                            provided_args,\n                         );\n                     },\n                 );\n@@ -410,7 +419,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit()\n             }\n \n-            for arg in args.iter().skip(expected_arg_count) {\n+            for arg in provided_args.iter().skip(expected_arg_count) {\n                 let arg_ty = self.check_expr(&arg);\n \n                 // There are a few types which get autopromoted when passed via varargs"}]}