{"sha": "86b1581ea0e0e47196e1ea70b2d980b3eee72623", "node_id": "C_kwDOAAsO6NoAKDg2YjE1ODFlYTBlMGU0NzE5NmUxZWE3MGIyZDk4MGIzZWVlNzI2MjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-17T23:01:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-17T23:01:35Z"}, "message": "Auto merge of #93009 - matthiaskrgr:rollup-3fkxg6i, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #90498 (Clarifications in the target tier policy)\n - #92164 (Implement `#[rustc_must_implement_one_of]` attribute)\n - #92729 (rustc_codegen_llvm: Remove (almost) unused span parameter from many functions in metadata.rs)\n - #92752 (Correct minor typos in some long error code explanations)\n - #92801 (Enable wrapping words by default)\n - #92825 (Rename environment variable for overriding rustc version)\n - #92877 (Remove LLVMRustMarkAllFunctionsNounwind)\n - #92936 (rustdoc: Remove `collect` in `html::markdown::parse`)\n - #92956 (Add `log2` and `log10` to `NonZeroU*`)\n - #92960 (Use `carrying_{mul|add}` in `num::bignum`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8a54ed3035f97f62f60564089a2ba1bfecc32f0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a54ed3035f97f62f60564089a2ba1bfecc32f0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86b1581ea0e0e47196e1ea70b2d980b3eee72623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86b1581ea0e0e47196e1ea70b2d980b3eee72623", "html_url": "https://github.com/rust-lang/rust/commit/86b1581ea0e0e47196e1ea70b2d980b3eee72623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86b1581ea0e0e47196e1ea70b2d980b3eee72623/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5d8d37baaf5b5a81a98396952839c73ae41c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5d8d37baaf5b5a81a98396952839c73ae41c68", "html_url": "https://github.com/rust-lang/rust/commit/ee5d8d37baaf5b5a81a98396952839c73ae41c68"}, {"sha": "68d47def017ff062270fd553bb4c7f8fbcc672c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d47def017ff062270fd553bb4c7f8fbcc672c0", "html_url": "https://github.com/rust-lang/rust/commit/68d47def017ff062270fd553bb4c7f8fbcc672c0"}], "stats": {"total": 1175, "additions": 793, "deletions": 382}, "files": [{"sha": "6afa649b6de325a19b40e8df10619b1002f371fd", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -349,13 +349,6 @@ fn fat_lto(\n             );\n             save_temp_bitcode(cgcx, &module, \"lto.after-restriction\");\n         }\n-\n-        if cgcx.no_landing_pads {\n-            unsafe {\n-                llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            }\n-            save_temp_bitcode(cgcx, &module, \"lto.after-nounwind\");\n-        }\n     }\n \n     Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: serialized_bitcode })\n@@ -770,16 +763,6 @@ pub unsafe fn optimize_thin_module(\n             return Err(write::llvm_err(&diag_handler, msg));\n         }\n \n-        // Like with \"fat\" LTO, get some better optimizations if landing pads\n-        // are disabled by removing all landing pads.\n-        if cgcx.no_landing_pads {\n-            let _timer = cgcx\n-                .prof\n-                .generic_activity_with_arg(\"LLVM_thin_lto_remove_landing_pads\", thin_module.name());\n-            llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            save_temp_bitcode(cgcx, &module, \"thin-lto-after-nounwind\");\n-        }\n-\n         // Up next comes the per-module local analyses that we do for Thin LTO.\n         // Each of these functions is basically copied from the LLVM\n         // implementation and then tailored to suit this implementation. Ideally"}, {"sha": "3d5fd2f354e55980a11a2b6f11d6ebbf4941df40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 44, "deletions": 118, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -27,18 +27,18 @@ use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::bug;\n use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{self, IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, AdtKind, GeneratorSubsts, Instance, ParamEnv, Ty, TyCtxt, COMMON_VTABLE_ENTRIES,\n };\n-use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileNameDisplayPreference;\n-use rustc_span::{self, SourceFile, SourceFileHash, Span};\n+use rustc_span::{self, SourceFile, SourceFileHash};\n use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n@@ -381,9 +381,8 @@ fn fixed_vec_metadata<'ll, 'tcx>(\n     unique_type_id: UniqueTypeId,\n     array_or_slice_type: Ty<'tcx>,\n     element_type: Ty<'tcx>,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n-    let element_type_metadata = type_metadata(cx, element_type, span);\n+    let element_type_metadata = type_metadata(cx, element_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -416,11 +415,10 @@ fn vec_slice_metadata<'ll, 'tcx>(\n     slice_ptr_type: Ty<'tcx>,\n     element_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n     let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n-    let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n+    let data_ptr_metadata = type_metadata(cx, data_ptr_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -442,7 +440,7 @@ fn vec_slice_metadata<'ll, 'tcx>(\n         },\n         MemberDescription {\n             name: \"length\".to_owned(),\n-            type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n+            type_metadata: type_metadata(cx, cx.tcx.types.usize),\n             offset: pointer_size,\n             size: usize_size,\n             align: usize_align,\n@@ -452,17 +450,13 @@ fn vec_slice_metadata<'ll, 'tcx>(\n         },\n     ];\n \n-    let file_metadata = unknown_file_metadata(cx);\n-\n     let metadata = composite_type_metadata(\n         cx,\n         slice_ptr_type,\n         &slice_type_name,\n         unique_type_id,\n         member_descriptions,\n         NO_SCOPE_METADATA,\n-        file_metadata,\n-        span,\n     );\n     MetadataCreationResult::new(metadata, false)\n }\n@@ -471,7 +465,6 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId,\n     signature: ty::PolyFnSig<'tcx>,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n     let signature =\n         cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), signature);\n@@ -480,12 +473,12 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n         // return type\n         match signature.output().kind() {\n             ty::Tuple(tys) if tys.is_empty() => None,\n-            _ => Some(type_metadata(cx, signature.output(), span)),\n+            _ => Some(type_metadata(cx, signature.output())),\n         },\n     )\n     .chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type, span))),\n+        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type))),\n     )\n     .collect();\n \n@@ -541,8 +534,6 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         None => (NO_SCOPE_METADATA, compute_debuginfo_type_name(cx.tcx, trait_type, true)),\n     };\n \n-    let file_metadata = unknown_file_metadata(cx);\n-\n     let layout = cx.layout_of(cx.tcx.mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n@@ -553,11 +544,7 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n     let member_descriptions = vec![\n         MemberDescription {\n             name: \"pointer\".to_owned(),\n-            type_metadata: type_metadata(\n-                cx,\n-                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n-                rustc_span::DUMMY_SP,\n-            ),\n+            type_metadata: type_metadata(cx, cx.tcx.mk_mut_ptr(cx.tcx.types.u8)),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n             align: data_ptr_field.align.abi,\n@@ -567,7 +554,7 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         },\n         MemberDescription {\n             name: \"vtable\".to_owned(),\n-            type_metadata: type_metadata(cx, vtable_field.ty, rustc_span::DUMMY_SP),\n+            type_metadata: type_metadata(cx, vtable_field.ty),\n             offset: layout.fields.offset(1),\n             size: vtable_field.size,\n             align: vtable_field.align.abi,\n@@ -584,16 +571,10 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         unique_type_id,\n         member_descriptions,\n         containing_scope,\n-        file_metadata,\n-        rustc_span::DUMMY_SP,\n     )\n }\n \n-pub fn type_metadata<'ll, 'tcx>(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    t: Ty<'tcx>,\n-    usage_site_span: Span,\n-) -> &'ll DIType {\n+pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     // Get the unique type ID of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -630,14 +611,14 @@ pub fn type_metadata<'ll, 'tcx>(\n     debug!(\"type_metadata: {:?}\", t);\n \n     let ptr_metadata = |ty: Ty<'tcx>| match *ty.kind() {\n-        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)),\n-        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span)),\n+        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id)),\n+        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id)),\n         ty::Dynamic(..) => Ok(MetadataCreationResult::new(\n             trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n             false,\n         )),\n         _ => {\n-            let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n+            let pointee_metadata = type_metadata(cx, ty);\n \n             if let Some(metadata) =\n                 debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n@@ -656,10 +637,8 @@ pub fn type_metadata<'ll, 'tcx>(\n         ty::Tuple(elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::Array(typ, _) | ty::Slice(typ) => {\n-            fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n-        }\n-        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span),\n+        ty::Array(typ, _) | ty::Slice(typ) => fixed_vec_metadata(cx, unique_type_id, t, typ),\n+        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8),\n         ty::Dynamic(..) => {\n             MetadataCreationResult::new(trait_pointer_metadata(cx, t, None, unique_type_id), false)\n         }\n@@ -710,8 +689,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n \n             let fn_metadata =\n-                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx), usage_site_span)\n-                    .metadata;\n+                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx)).metadata;\n \n             type_map.borrow_mut().remove_type(t);\n \n@@ -721,41 +699,27 @@ pub fn type_metadata<'ll, 'tcx>(\n         ty::Closure(def_id, substs) => {\n             let upvar_tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n-            prepare_tuple_metadata(\n-                cx,\n-                t,\n-                &upvar_tys,\n-                unique_type_id,\n-                usage_site_span,\n-                Some(containing_scope),\n-            )\n-            .finalize(cx)\n+            prepare_tuple_metadata(cx, t, &upvar_tys, unique_type_id, Some(containing_scope))\n+                .finalize(cx)\n         }\n         ty::Generator(def_id, substs, _) => {\n             let upvar_tys: Vec<_> = substs\n                 .as_generator()\n                 .prefix_tys()\n                 .map(|t| cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n                 .collect();\n-            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span, upvar_tys)\n-                .finalize(cx)\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, upvar_tys).finalize(cx)\n         }\n         ty::Adt(def, ..) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                prepare_struct_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n-            }\n-            AdtKind::Union => {\n-                prepare_union_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n-            }\n+            AdtKind::Struct => prepare_struct_metadata(cx, t, unique_type_id).finalize(cx),\n+            AdtKind::Union => prepare_union_metadata(cx, t, unique_type_id).finalize(cx),\n             AdtKind::Enum => {\n-                prepare_enum_metadata(cx, t, def.did, unique_type_id, usage_site_span, vec![])\n-                    .finalize(cx)\n+                prepare_enum_metadata(cx, t, def.did, unique_type_id, vec![]).finalize(cx)\n             }\n         },\n         ty::Tuple(elements) => {\n             let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n-            prepare_tuple_metadata(cx, t, &tys, unique_type_id, usage_site_span, NO_SCOPE_METADATA)\n-                .finalize(cx)\n+            prepare_tuple_metadata(cx, t, &tys, unique_type_id, NO_SCOPE_METADATA).finalize(cx)\n         }\n         // Type parameters from polymorphized functions.\n         ty::Param(_) => MetadataCreationResult::new(param_type_metadata(cx, t), false),\n@@ -770,8 +734,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    span_bug!(\n-                        usage_site_span,\n+                    bug!(\n                         \"expected type metadata for unique \\\n                                type ID '{}' to already be in \\\n                                the `debuginfo::TypeMap` but it \\\n@@ -785,8 +748,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        span_bug!(\n-                            usage_site_span,\n+                        bug!(\n                             \"mismatch between `Ty` and \\\n                                    `UniqueTypeId` maps in \\\n                                    `debuginfo::TypeMap`. \\\n@@ -1283,7 +1245,6 @@ impl<'ll, 'tcx> MemberDescriptionFactory<'ll, 'tcx> {\n struct StructMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n@@ -1305,7 +1266,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 let field = layout.field(cx, i);\n                 MemberDescription {\n                     name,\n-                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    type_metadata: type_metadata(cx, field.ty),\n                     offset: layout.fields.offset(i),\n                     size: field.size,\n                     align: field.align.abi,\n@@ -1322,7 +1283,6 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n@@ -1348,7 +1308,7 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n         unique_type_id,\n         struct_metadata_stub,\n         struct_metadata_stub,\n-        StructMDF(StructMemberDescriptionFactory { ty: struct_type, variant, span }),\n+        StructMDF(StructMemberDescriptionFactory { ty: struct_type, variant }),\n     )\n }\n \n@@ -1385,7 +1345,6 @@ fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) ->\n struct TupleMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     component_types: Vec<Ty<'tcx>>,\n-    span: Span,\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n@@ -1412,7 +1371,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 };\n                 MemberDescription {\n                     name,\n-                    type_metadata: type_metadata(cx, component_type, self.span),\n+                    type_metadata: type_metadata(cx, component_type),\n                     offset: layout.fields.offset(i),\n                     size,\n                     align,\n@@ -1430,7 +1389,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n     tuple_type: Ty<'tcx>,\n     component_types: &[Ty<'tcx>],\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n     containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n@@ -1453,7 +1411,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n-            span,\n         }),\n     )\n }\n@@ -1465,7 +1422,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n struct UnionMemberDescriptionFactory<'tcx> {\n     layout: TyAndLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    span: Span,\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n@@ -1481,7 +1437,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                 let field = self.layout.field(cx, i);\n                 MemberDescription {\n                     name: f.name.to_string(),\n-                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    type_metadata: type_metadata(cx, field.ty),\n                     offset: Size::ZERO,\n                     size: field.size,\n                     align: field.align.abi,\n@@ -1498,7 +1454,6 @@ fn prepare_union_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n@@ -1518,7 +1473,7 @@ fn prepare_union_metadata<'ll, 'tcx>(\n         unique_type_id,\n         union_metadata_stub,\n         union_metadata_stub,\n-        UnionMDF(UnionMemberDescriptionFactory { layout: cx.layout_of(union_type), variant, span }),\n+        UnionMDF(UnionMemberDescriptionFactory { layout: cx.layout_of(union_type), variant }),\n     )\n }\n \n@@ -1573,7 +1528,6 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     layout: TyAndLayout<'tcx>,\n     tag_type_metadata: Option<&'ll DIType>,\n     common_members: Vec<Option<&'ll DIType>>,\n-    span: Span,\n }\n \n impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n@@ -1605,7 +1559,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n         // msvc, then we need to use a different, fallback encoding of the debuginfo.\n         let fallback = cpp_like_debuginfo(cx.tcx);\n         // This will always find the metadata in the type map.\n-        let self_metadata = type_metadata(cx, self.enum_type, self.span);\n+        let self_metadata = type_metadata(cx, self.enum_type);\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1617,7 +1571,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                 let variant_info = variant_info_for(index);\n                 let (variant_type_metadata, member_description_factory) =\n-                    describe_enum_variant(cx, self.layout, variant_info, self_metadata, self.span);\n+                    describe_enum_variant(cx, self.layout, variant_info, self_metadata);\n \n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n@@ -1682,13 +1636,8 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     .map(|(i, _)| {\n                         let variant = self.layout.for_variant(cx, i);\n                         let variant_info = variant_info_for(i);\n-                        let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n-                            cx,\n-                            variant,\n-                            variant_info,\n-                            self_metadata,\n-                            self.span,\n-                        );\n+                        let (variant_type_metadata, member_desc_factory) =\n+                            describe_enum_variant(cx, variant, variant_info, self_metadata);\n \n                         let member_descriptions =\n                             member_desc_factory.create_member_descriptions(cx);\n@@ -1807,7 +1756,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             tag.value.size(cx).bits(),\n                             tag.value.align(cx).abi.bits() as u32,\n                             create_DIArray(DIB(cx), &tags),\n-                            type_metadata(cx, discr_enum_ty, self.span),\n+                            type_metadata(cx, discr_enum_ty),\n                             true,\n                         )\n                     };\n@@ -1818,7 +1767,6 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         dataful_variant_layout,\n                         variant_info,\n                         self_metadata,\n-                        self.span,\n                     );\n \n                     let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n@@ -1864,13 +1812,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             let variant = self.layout.for_variant(cx, i);\n                             let variant_info = variant_info_for(i);\n                             let (variant_type_metadata, member_desc_factory) =\n-                                describe_enum_variant(\n-                                    cx,\n-                                    variant,\n-                                    variant_info,\n-                                    self_metadata,\n-                                    self.span,\n-                                );\n+                                describe_enum_variant(cx, variant, variant_info, self_metadata);\n \n                             let member_descriptions =\n                                 member_desc_factory.create_member_descriptions(cx);\n@@ -1908,7 +1850,6 @@ struct VariantMemberDescriptionFactory<'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    span: Span,\n }\n \n impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n@@ -1923,7 +1864,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n                 let (size, align) = cx.size_and_align_of(ty);\n                 MemberDescription {\n                     name: name.to_string(),\n-                    type_metadata: type_metadata(cx, ty, self.span),\n+                    type_metadata: type_metadata(cx, ty),\n                     offset: self.offsets[i],\n                     size,\n                     align,\n@@ -2011,7 +1952,6 @@ fn describe_enum_variant<'ll, 'tcx>(\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n     containing_scope: &'ll DIScope,\n-    span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let metadata_stub = variant.map_struct_name(|variant_name| {\n         let unique_type_id = debug_context(cx)\n@@ -2033,8 +1973,7 @@ fn describe_enum_variant<'ll, 'tcx>(\n         .map(|i| (variant.field_name(i), layout.field(cx, i).ty))\n         .collect();\n \n-    let member_description_factory =\n-        VariantMDF(VariantMemberDescriptionFactory { offsets, args, span });\n+    let member_description_factory = VariantMDF(VariantMemberDescriptionFactory { offsets, args });\n \n     (metadata_stub, member_description_factory)\n }\n@@ -2044,7 +1983,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n     enum_type: Ty<'tcx>,\n     enum_def_id: DefId,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n     outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tcx = cx.tcx;\n@@ -2109,8 +2047,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n                 let (discriminant_size, discriminant_align) = (discr.size(cx), discr.align(cx));\n-                let discriminant_base_type_metadata =\n-                    type_metadata(cx, discr.to_ty(tcx), rustc_span::DUMMY_SP);\n+                let discriminant_base_type_metadata = type_metadata(cx, discr.to_ty(tcx));\n \n                 let item_name;\n                 let discriminant_name = match enum_type.kind() {\n@@ -2202,7 +2139,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n                 layout,\n                 tag_type_metadata: discriminant_type_metadata,\n                 common_members: vec![],\n-                span,\n             }),\n         );\n     }\n@@ -2272,11 +2208,8 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n     let outer_fields = match layout.variants {\n         Variants::Single { .. } => vec![],\n         Variants::Multiple { .. } => {\n-            let tuple_mdf = TupleMemberDescriptionFactory {\n-                ty: enum_type,\n-                component_types: outer_field_tys,\n-                span,\n-            };\n+            let tuple_mdf =\n+                TupleMemberDescriptionFactory { ty: enum_type, component_types: outer_field_tys };\n             tuple_mdf\n                 .create_member_descriptions(cx)\n                 .into_iter()\n@@ -2352,7 +2285,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n             layout,\n             tag_type_metadata: None,\n             common_members: outer_fields,\n-            span,\n         }),\n     )\n }\n@@ -2368,11 +2300,6 @@ fn composite_type_metadata<'ll, 'tcx>(\n     composite_type_unique_id: UniqueTypeId,\n     member_descriptions: Vec<MemberDescription<'ll>>,\n     containing_scope: Option<&'ll DIScope>,\n-\n-    // Ignore source location information as long as it\n-    // can't be reconstructed for non-local crates.\n-    _file_metadata: &'ll DIFile,\n-    _definition_span: Span,\n ) -> &'ll DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(\n@@ -2450,8 +2377,7 @@ fn compute_type_parameters<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type =\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                        let actual_type_metadata =\n-                            type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n+                        let actual_type_metadata = type_metadata(cx, actual_type);\n                         let name = name.as_str();\n                         Some(unsafe {\n                             Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -2593,7 +2519,7 @@ pub fn create_global_var_metadata<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId, g\n \n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx, ty::ParamEnv::reveal_all());\n-    let type_metadata = type_metadata(cx, variable_type, span);\n+    let type_metadata = type_metadata(cx, variable_type);\n     let var_name = tcx.item_name(def_id);\n     let var_name = var_name.as_str();\n     let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id)).name;\n@@ -2648,7 +2574,7 @@ fn vtable_type_metadata<'ll, 'tcx>(\n     //        things simple instead of adding some ad-hoc disambiguation scheme.\n     let vtable_type = tcx.mk_array(tcx.mk_imm_ptr(tcx.types.unit), vtable_entries.len() as u64);\n \n-    type_metadata(cx, vtable_type, rustc_span::DUMMY_SP)\n+    type_metadata(cx, vtable_type)\n }\n \n /// Creates debug information for the given vtable, which is for the"}, {"sha": "61e49fab6ff8876e7cf9b3c058c8e871b7a2f962", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -390,7 +390,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             signature.push(if fn_abi.ret.is_ignore() {\n                 None\n             } else {\n-                Some(type_metadata(cx, fn_abi.ret.layout.ty, rustc_span::DUMMY_SP))\n+                Some(type_metadata(cx, fn_abi.ret.layout.ty))\n             });\n \n             // Arguments types\n@@ -415,15 +415,11 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         _ => t,\n                     };\n-                    Some(type_metadata(cx, t, rustc_span::DUMMY_SP))\n+                    Some(type_metadata(cx, t))\n                 }));\n             } else {\n-                signature.extend(\n-                    fn_abi\n-                        .args\n-                        .iter()\n-                        .map(|arg| Some(type_metadata(cx, arg.layout.ty, rustc_span::DUMMY_SP))),\n-                );\n+                signature\n+                    .extend(fn_abi.args.iter().map(|arg| Some(type_metadata(cx, arg.layout.ty))));\n             }\n \n             create_DIArray(DIB(cx), &signature[..])\n@@ -453,8 +449,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type =\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                            let actual_type_metadata =\n-                                type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n+                            let actual_type_metadata = type_metadata(cx, actual_type);\n                             let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -509,7 +504,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n                                 && !impl_self_ty.needs_subst()\n                             {\n-                                Some(type_metadata(cx, impl_self_ty, rustc_span::DUMMY_SP))\n+                                Some(type_metadata(cx, impl_self_ty))\n                             } else {\n                                 Some(namespace::item_namespace(cx, def.did))\n                             }\n@@ -584,7 +579,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n \n-        let type_metadata = type_metadata(self, variable_type, span);\n+        let type_metadata = type_metadata(self, variable_type);\n \n         let (argument_index, dwarf_tag) = match variable_kind {\n             ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),"}, {"sha": "a1c7d2b4f6156d9bdb3f76f07d1e20905cd57e0a", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -2320,7 +2320,6 @@ extern \"C\" {\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n-    pub fn LLVMRustMarkAllFunctionsNounwind(M: &Module);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;\n     pub fn LLVMRustArchiveIteratorNew(AR: &Archive) -> &mut ArchiveIterator<'_>;"}, {"sha": "540979ce02d8fde47e148478b5cfb5d34c7ff466", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -32,7 +32,7 @@ use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n-use rustc_target::spec::{MergeFunctions, PanicStrategy, SanitizerSet};\n+use rustc_target::spec::{MergeFunctions, SanitizerSet};\n \n use std::any::Any;\n use std::fs;\n@@ -313,7 +313,6 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub backend: B,\n     pub prof: SelfProfilerRef,\n     pub lto: Lto,\n-    pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub fewer_names: bool,\n     pub time_trace: bool,\n@@ -1039,7 +1038,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         crate_types: sess.crate_types().to_vec(),\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n-        no_landing_pads: sess.panic_strategy() == PanicStrategy::Abort,\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,\n         time_trace: sess.opts.debugging_opts.llvm_time_trace,"}, {"sha": "584b78554ef88f1ac9d42a93df6af10d47bcbeb7", "filename": "compiler/rustc_error_codes/src/error_codes/E0038.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -15,7 +15,7 @@ Two general aspects of trait object types give rise to the restrictions:\n      these types can only be accessed through pointers, such as `&dyn Trait` or\n      `Box<dyn Trait>`. The size of such a pointer is known, but the size of the\n      `dyn Trait` object pointed-to by the pointer is _opaque_ to code working\n-     with it, and different tait objects with the same trait object type may\n+     with it, and different trait objects with the same trait object type may\n      have different sizes.\n \n   2. The pointer used to access a trait object is paired with an extra pointer\n@@ -167,7 +167,7 @@ implementation on-demand. If you call `foo()` with a `bool` parameter, the\n compiler will only generate code for `foo::<bool>()`. When we have additional\n type parameters, the number of monomorphized implementations the compiler\n generates does not grow drastically, since the compiler will only generate an\n-implementation if the function is called with unparametrized substitutions\n+implementation if the function is called with unparameterized substitutions\n (i.e., substitutions where none of the substituted types are themselves\n parameterized).\n "}, {"sha": "92fa4c7c21e72d84eece06829af306f34b77fe98", "filename": "compiler/rustc_error_codes/src/error_codes/E0183.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0183.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0183.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0183.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1,4 +1,4 @@\n-Manual implemetation of a `Fn*` trait.\n+Manual implementation of a `Fn*` trait.\n \n Erroneous code example:\n \n@@ -33,7 +33,7 @@ impl FnOnce<()> for MyClosure {  // ok!\n }\n ```\n \n-The argumements must be a tuple representing the argument list.\n+The arguments must be a tuple representing the argument list.\n For more info, see the [tracking issue][iss29625]:\n \n [iss29625]: https://github.com/rust-lang/rust/issues/29625"}, {"sha": "fedf6365fb5590d10489e4a04dd7081fa26d4a2b", "filename": "compiler/rustc_error_codes/src/error_codes/E0521.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0521.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0521.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0521.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -10,7 +10,7 @@ let _add = |el: &str| {\n };\n ```\n \n-A type anotation of a closure parameter implies a new lifetime declaration.\n+A type annotation of a closure parameter implies a new lifetime declaration.\n Consider to drop it, the compiler is reliably able to infer them.\n \n ```"}, {"sha": "02468dd946646eb25e0d31001076fe138118836a", "filename": "compiler/rustc_error_codes/src/error_codes/E0581.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0581.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0581.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0581.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -10,7 +10,7 @@ fn main() {\n }\n ```\n \n-The problem here is that the lifetime isn't contrained by any of the arguments,\n+The problem here is that the lifetime isn't constrained by any of the arguments,\n making it impossible to determine how long it's supposed to live.\n \n To fix this issue, either use the lifetime in the arguments, or use the"}, {"sha": "5309f217b4adaa755cbb47f12e0635dd497f9282", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -682,6 +682,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"the `#[rustc_skip_array_during_method_dispatch]` attribute is used to exclude a trait \\\n         from method dispatch when the receiver is an array, for compatibility in editions < 2021.\"\n     ),\n+    rustc_attr!(\n+        rustc_must_implement_one_of, Normal, template!(List: \"function1, function2, ...\"), ErrorFollowing,\n+        \"the `#[rustc_must_implement_one_of]` attribute is used to change minimal complete \\\n+        definition of a trait, it's currently in experimental form and should be changed before \\\n+        being exposed outside of the std\"\n+    ),\n \n     // ==========================================================================\n     // Internal attributes, Testing:"}, {"sha": "68180a2214a50aa84b8d78cd5cae51978e884417", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -190,7 +190,7 @@ fn report_format_mismatch(report_incremental_info: bool, file: &Path, message: &\n \n fn rustc_version(nightly_build: bool) -> String {\n     if nightly_build {\n-        if let Some(val) = env::var_os(\"RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER\") {\n+        if let Some(val) = env::var_os(\"RUSTC_FORCE_RUSTC_VERSION\") {\n             return val.to_string_lossy().into_owned();\n         }\n     }"}, {"sha": "7030fd53704dd74efa27fae77a252d932767997a", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1168,25 +1168,6 @@ extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n   passes.run(*unwrap(M));\n }\n \n-extern \"C\" void LLVMRustMarkAllFunctionsNounwind(LLVMModuleRef M) {\n-  for (Module::iterator GV = unwrap(M)->begin(), E = unwrap(M)->end(); GV != E;\n-       ++GV) {\n-    GV->setDoesNotThrow();\n-    Function *F = dyn_cast<Function>(GV);\n-    if (F == nullptr)\n-      continue;\n-\n-    for (Function::iterator B = F->begin(), BE = F->end(); B != BE; ++B) {\n-      for (BasicBlock::iterator I = B->begin(), IE = B->end(); I != IE; ++I) {\n-        if (isa<InvokeInst>(I)) {\n-          InvokeInst *CI = cast<InvokeInst>(I);\n-          CI->setDoesNotThrow();\n-        }\n-      }\n-    }\n-  }\n-}\n-\n extern \"C\" void\n LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module,\n                                        LLVMTargetMachineRef TMR) {"}, {"sha": "220bc9c5f752f556bcf41e55b433f3043e68ef56", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -820,6 +820,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     data.skip_array_during_method_dispatch,\n                     data.specialization_kind,\n                     self.def_path_hash(item_id),\n+                    data.must_implement_one_of,\n                 )\n             }\n             EntryKind::TraitAlias => ty::TraitDef::new(\n@@ -831,6 +832,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 false,\n                 ty::trait_def::TraitSpecializationKind::None,\n                 self.def_path_hash(item_id),\n+                None,\n             ),\n             _ => bug!(\"def-index does not refer to trait or trait alias\"),\n         }"}, {"sha": "ebb78adf343ced020eee4149784ef86687934eb5", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1513,6 +1513,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     is_marker: trait_def.is_marker,\n                     skip_array_during_method_dispatch: trait_def.skip_array_during_method_dispatch,\n                     specialization_kind: trait_def.specialization_kind,\n+                    must_implement_one_of: trait_def.must_implement_one_of.clone(),\n                 };\n \n                 EntryKind::Trait(self.lazy(data))"}, {"sha": "8424a31d59fce72a8b2ebddd8badee4b684ef5be", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -378,6 +378,7 @@ struct TraitData {\n     is_marker: bool,\n     skip_array_during_method_dispatch: bool,\n     specialization_kind: ty::trait_def::TraitSpecializationKind,\n+    must_implement_one_of: Option<Box<[Ident]>>,\n }\n \n #[derive(TyEncodable, TyDecodable)]"}, {"sha": "9f8053d4a4eac7893c57dc9743f402638732c0c1", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1,7 +1,7 @@\n use crate::traits::specialization_graph;\n use crate::ty::fast_reject::{self, SimplifiedType, SimplifyParams, StripReferences};\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::{Ty, TyCtxt};\n+use crate::ty::{Ident, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::DefPathHash;\n@@ -44,6 +44,10 @@ pub struct TraitDef {\n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n     pub def_path_hash: DefPathHash,\n+\n+    /// List of functions from `#[rustc_must_implement_one_of]` attribute one of which\n+    /// must be implemented.\n+    pub must_implement_one_of: Option<Box<[Ident]>>,\n }\n \n /// Whether this trait is treated specially by the standard library\n@@ -87,6 +91,7 @@ impl<'tcx> TraitDef {\n         skip_array_during_method_dispatch: bool,\n         specialization_kind: TraitSpecializationKind,\n         def_path_hash: DefPathHash,\n+        must_implement_one_of: Option<Box<[Ident]>>,\n     ) -> TraitDef {\n         TraitDef {\n             def_id,\n@@ -97,6 +102,7 @@ impl<'tcx> TraitDef {\n             skip_array_during_method_dispatch,\n             specialization_kind,\n             def_path_hash,\n+            must_implement_one_of,\n         }\n     }\n "}, {"sha": "5390eed89fadc70f168f201e4c069f3fc8daa56c", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -176,9 +176,9 @@ impl StableCrateId {\n         // and no -Cmetadata, symbols from the same crate compiled with different versions of\n         // rustc are named the same.\n         //\n-        // RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER is used to inject rustc version information\n+        // RUSTC_FORCE_RUSTC_VERSION is used to inject rustc version information\n         // during testing.\n-        if let Some(val) = std::env::var_os(\"RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER\") {\n+        if let Some(val) = std::env::var_os(\"RUSTC_FORCE_RUSTC_VERSION\") {\n             hasher.write(val.to_string_lossy().into_owned().as_bytes())\n         } else {\n             hasher.write(option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\").as_bytes());"}, {"sha": "21f4312de351631721098656995eed71465f0469", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1162,6 +1162,7 @@ symbols! {\n         rustc_macro_transparency,\n         rustc_main,\n         rustc_mir,\n+        rustc_must_implement_one_of,\n         rustc_nonnull_optimization_guaranteed,\n         rustc_object_lifetime_default,\n         rustc_on_unimplemented,"}, {"sha": "eb49cc0233d835600a1937a35db002b98780a90d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -978,6 +978,10 @@ fn check_impl_items_against_trait<'tcx>(\n     if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n         // Check for missing items from trait\n         let mut missing_items = Vec::new();\n+\n+        let mut must_implement_one_of: Option<&[Ident]> =\n+            trait_def.must_implement_one_of.as_deref();\n+\n         for &trait_item_id in tcx.associated_item_def_ids(impl_trait_ref.def_id) {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item_id)\n@@ -986,12 +990,37 @@ fn check_impl_items_against_trait<'tcx>(\n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n+\n+            if let Some(required_items) = &must_implement_one_of {\n+                // true if this item is specifically implemented in this impl\n+                let is_implemented_here = ancestors\n+                    .leaf_def(tcx, trait_item_id)\n+                    .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n+\n+                if is_implemented_here {\n+                    let trait_item = tcx.associated_item(trait_item_id);\n+                    if required_items.contains(&trait_item.ident) {\n+                        must_implement_one_of = None;\n+                    }\n+                }\n+            }\n         }\n \n         if !missing_items.is_empty() {\n             let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n         }\n+\n+        if let Some(missing_items) = must_implement_one_of {\n+            let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n+            let attr_span = tcx\n+                .get_attrs(impl_trait_ref.def_id)\n+                .iter()\n+                .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+                .map(|attr| attr.span);\n+\n+            missing_items_must_implement_one_of_err(tcx, impl_span, missing_items, attr_span);\n+        }\n     }\n }\n "}, {"sha": "059d4a7f3a4bc0cf62cd21abf7016191b0ed78cf", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -637,6 +637,31 @@ fn missing_items_err(\n     err.emit();\n }\n \n+fn missing_items_must_implement_one_of_err(\n+    tcx: TyCtxt<'_>,\n+    impl_span: Span,\n+    missing_items: &[Ident],\n+    annotation_span: Option<Span>,\n+) {\n+    let missing_items_msg =\n+        missing_items.iter().map(Ident::to_string).collect::<Vec<_>>().join(\"`, `\");\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0046,\n+        \"not all trait items implemented, missing one of: `{}`\",\n+        missing_items_msg\n+    );\n+    err.span_label(impl_span, format!(\"missing one of `{}` in implementation\", missing_items_msg));\n+\n+    if let Some(annotation_span) = annotation_span {\n+        err.span_note(annotation_span, \"required because of this annotation\");\n+    }\n+\n+    err.emit();\n+}\n+\n /// Resugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n fn bounds_from_generic_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "314174e0f8501e5c63a3f79b2ebd480b49463589", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 103, "deletions": 3, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1190,9 +1190,11 @@ fn super_predicates_that_define_assoc_type(\n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n \n-    let (is_auto, unsafety) = match item.kind {\n-        hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n-        hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal),\n+    let (is_auto, unsafety, items) = match item.kind {\n+        hir::ItemKind::Trait(is_auto, unsafety, .., items) => {\n+            (is_auto == hir::IsAuto::Yes, unsafety, items)\n+        }\n+        hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal, &[][..]),\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n@@ -1219,6 +1221,103 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         ty::trait_def::TraitSpecializationKind::None\n     };\n     let def_path_hash = tcx.def_path_hash(def_id);\n+\n+    let must_implement_one_of = tcx\n+        .get_attrs(def_id)\n+        .iter()\n+        .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+        // Check that there are at least 2 arguments of `#[rustc_must_implement_one_of]`\n+        // and that they are all identifiers\n+        .and_then(|attr| match attr.meta_item_list() {\n+            Some(items) if items.len() < 2 => {\n+                tcx.sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        \"the `#[rustc_must_implement_one_of]` attribute must be \\\n+                        used with at least 2 args\",\n+                    )\n+                    .emit();\n+\n+                None\n+            }\n+            Some(items) => items\n+                .into_iter()\n+                .map(|item| item.ident().ok_or(item.span()))\n+                .collect::<Result<Box<[_]>, _>>()\n+                .map_err(|span| {\n+                    tcx.sess\n+                        .struct_span_err(span, \"must be a name of an associated function\")\n+                        .emit();\n+                })\n+                .ok()\n+                .zip(Some(attr.span)),\n+            // Error is reported by `rustc_attr!`\n+            None => None,\n+        })\n+        // Check that all arguments of `#[rustc_must_implement_one_of]` reference\n+        // functions in the trait with default implementations\n+        .and_then(|(list, attr_span)| {\n+            let errors = list.iter().filter_map(|ident| {\n+                let item = items.iter().find(|item| item.ident == *ident);\n+\n+                match item {\n+                    Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n+                        if !item.defaultness.has_value() {\n+                            tcx.sess\n+                                .struct_span_err(\n+                                    item.span,\n+                                    \"This function doesn't have a default implementation\",\n+                                )\n+                                .span_note(attr_span, \"required by this annotation\")\n+                                .emit();\n+\n+                            return Some(());\n+                        }\n+\n+                        return None;\n+                    }\n+                    Some(item) => tcx\n+                        .sess\n+                        .struct_span_err(item.span, \"Not a function\")\n+                        .span_note(attr_span, \"required by this annotation\")\n+                        .note(\n+                            \"All `#[rustc_must_implement_one_of]` arguments \\\n+                            must be associated function names\",\n+                        )\n+                        .emit(),\n+                    None => tcx\n+                        .sess\n+                        .struct_span_err(ident.span, \"Function not found in this trait\")\n+                        .emit(),\n+                }\n+\n+                Some(())\n+            });\n+\n+            (errors.count() == 0).then_some(list)\n+        })\n+        // Check for duplicates\n+        .and_then(|list| {\n+            let mut set: FxHashMap<Symbol, Span> = FxHashMap::default();\n+            let mut no_dups = true;\n+\n+            for ident in &*list {\n+                if let Some(dup) = set.insert(ident.name, ident.span) {\n+                    tcx.sess\n+                        .struct_span_err(vec![dup, ident.span], \"Functions names are duplicated\")\n+                        .note(\n+                            \"All `#[rustc_must_implement_one_of]` arguments \\\n+                            must be unique\",\n+                        )\n+                        .emit();\n+\n+                    no_dups = false;\n+                }\n+            }\n+\n+            no_dups.then_some(list)\n+        });\n+\n     ty::TraitDef::new(\n         def_id,\n         unsafety,\n@@ -1228,6 +1327,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         skip_array_during_method_dispatch,\n         spec_kind,\n         def_path_hash,\n+        must_implement_one_of,\n     )\n }\n "}, {"sha": "de85fdd6ed2462dcd48c83e7d90144ff34089f34", "filename": "library/core/src/num/bignum.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fbignum.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -19,18 +19,8 @@\n )]\n #![macro_use]\n \n-use crate::intrinsics;\n-\n /// Arithmetic operations required by bignums.\n pub trait FullOps: Sized {\n-    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n-    /// where `W` is the number of bits in `Self`.\n-    fn full_add(self, other: Self, carry: bool) -> (bool /* carry */, Self);\n-\n-    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n-    /// where `W` is the number of bits in `Self`.\n-    fn full_mul(self, other: Self, carry: Self) -> (Self /* carry */, Self);\n-\n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n     /// where `W` is the number of bits in `Self`.\n     fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /* carry */, Self);\n@@ -45,22 +35,6 @@ macro_rules! impl_full_ops {\n     ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n         $(\n             impl FullOps for $ty {\n-                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n-                    // This cannot overflow; the output is between `0` and `2 * 2^nbits - 1`.\n-                    // FIXME: will LLVM optimize this into ADC or similar?\n-                    let (v, carry1) = intrinsics::add_with_overflow(self, other);\n-                    let (v, carry2) = intrinsics::add_with_overflow(v, if carry {1} else {0});\n-                    (carry1 || carry2, v)\n-                }\n-\n-                fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n-                    // This cannot overflow;\n-                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n-                    // FIXME: will LLVM optimize this into ADC or similar?\n-                    let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n-                    ((v >> <$ty>::BITS) as $ty, v as $ty)\n-                }\n-\n                 fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n                     // This cannot overflow;\n                     // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n@@ -173,12 +147,11 @@ macro_rules! define_bignum {\n             pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                 use crate::cmp;\n                 use crate::iter;\n-                use crate::num::bignum::FullOps;\n \n                 let mut sz = cmp::max(self.size, other.size);\n                 let mut carry = false;\n                 for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n-                    let (c, v) = (*a).full_add(*b, carry);\n+                    let (v, c) = (*a).carrying_add(*b, carry);\n                     *a = v;\n                     carry = c;\n                 }\n@@ -191,13 +164,11 @@ macro_rules! define_bignum {\n             }\n \n             pub fn add_small(&mut self, other: $ty) -> &mut $name {\n-                use crate::num::bignum::FullOps;\n-\n-                let (mut carry, v) = self.base[0].full_add(other, false);\n+                let (v, mut carry) = self.base[0].carrying_add(other, false);\n                 self.base[0] = v;\n                 let mut i = 1;\n                 while carry {\n-                    let (c, v) = self.base[i].full_add(0, carry);\n+                    let (v, c) = self.base[i].carrying_add(0, carry);\n                     self.base[i] = v;\n                     carry = c;\n                     i += 1;\n@@ -212,12 +183,11 @@ macro_rules! define_bignum {\n             pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n                 use crate::cmp;\n                 use crate::iter;\n-                use crate::num::bignum::FullOps;\n \n                 let sz = cmp::max(self.size, other.size);\n                 let mut noborrow = true;\n                 for (a, b) in iter::zip(&mut self.base[..sz], &other.base[..sz]) {\n-                    let (c, v) = (*a).full_add(!*b, noborrow);\n+                    let (v, c) = (*a).carrying_add(!*b, noborrow);\n                     *a = v;\n                     noborrow = c;\n                 }\n@@ -229,12 +199,10 @@ macro_rules! define_bignum {\n             /// Multiplies itself by a digit-sized `other` and returns its own\n             /// mutable reference.\n             pub fn mul_small(&mut self, other: $ty) -> &mut $name {\n-                use crate::num::bignum::FullOps;\n-\n                 let mut sz = self.size;\n                 let mut carry = 0;\n                 for a in &mut self.base[..sz] {\n-                    let (c, v) = (*a).full_mul(other, carry);\n+                    let (v, c) = (*a).carrying_mul(other, carry);\n                     *a = v;\n                     carry = c;\n                 }"}, {"sha": "cc26c04a5d42a1e1faf113a5495d91f0212288c8", "filename": "library/core/src/num/int_log10.rs", "status": "modified", "additions": 123, "deletions": 124, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_log10.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1,141 +1,140 @@\n-mod unchecked {\n-    // 0 < val <= u8::MAX\n-    #[inline]\n-    pub const fn u8(val: u8) -> u32 {\n-        let val = val as u32;\n-\n-        // For better performance, avoid branches by assembling the solution\n-        // in the bits above the low 8 bits.\n-\n-        // Adding c1 to val gives 10 in the top bits for val < 10, 11 for val >= 10\n-        const C1: u32 = 0b11_00000000 - 10; // 758\n-        // Adding c2 to val gives 01 in the top bits for val < 100, 10 for val >= 100\n-        const C2: u32 = 0b10_00000000 - 100; // 412\n-\n-        // Value of top bits:\n-        //            +c1  +c2  1&2\n-        //     0..=9   10   01   00 = 0\n-        //   10..=99   11   01   01 = 1\n-        // 100..=255   11   10   10 = 2\n-        ((val + C1) & (val + C2)) >> 8\n-    }\n+/// These functions compute the integer logarithm of their type, assuming\n+/// that someone has already checked that the the value is strictly positive.\n+\n+// 0 < val <= u8::MAX\n+#[inline]\n+pub const fn u8(val: u8) -> u32 {\n+    let val = val as u32;\n+\n+    // For better performance, avoid branches by assembling the solution\n+    // in the bits above the low 8 bits.\n+\n+    // Adding c1 to val gives 10 in the top bits for val < 10, 11 for val >= 10\n+    const C1: u32 = 0b11_00000000 - 10; // 758\n+    // Adding c2 to val gives 01 in the top bits for val < 100, 10 for val >= 100\n+    const C2: u32 = 0b10_00000000 - 100; // 412\n+\n+    // Value of top bits:\n+    //            +c1  +c2  1&2\n+    //     0..=9   10   01   00 = 0\n+    //   10..=99   11   01   01 = 1\n+    // 100..=255   11   10   10 = 2\n+    ((val + C1) & (val + C2)) >> 8\n+}\n \n-    // 0 < val < 100_000\n-    #[inline]\n-    const fn less_than_5(val: u32) -> u32 {\n-        // Similar to u8, when adding one of these constants to val,\n-        // we get two possible bit patterns above the low 17 bits,\n-        // depending on whether val is below or above the threshold.\n-        const C1: u32 = 0b011_00000000000000000 - 10; // 393206\n-        const C2: u32 = 0b100_00000000000000000 - 100; // 524188\n-        const C3: u32 = 0b111_00000000000000000 - 1000; // 916504\n-        const C4: u32 = 0b100_00000000000000000 - 10000; // 514288\n-\n-        // Value of top bits:\n-        //                +c1  +c2  1&2  +c3  +c4  3&4   ^\n-        //         0..=9  010  011  010  110  011  010  000 = 0\n-        //       10..=99  011  011  011  110  011  010  001 = 1\n-        //     100..=999  011  100  000  110  011  010  010 = 2\n-        //   1000..=9999  011  100  000  111  011  011  011 = 3\n-        // 10000..=99999  011  100  000  111  100  100  100 = 4\n-        (((val + C1) & (val + C2)) ^ ((val + C3) & (val + C4))) >> 17\n-    }\n+// 0 < val < 100_000\n+#[inline]\n+const fn less_than_5(val: u32) -> u32 {\n+    // Similar to u8, when adding one of these constants to val,\n+    // we get two possible bit patterns above the low 17 bits,\n+    // depending on whether val is below or above the threshold.\n+    const C1: u32 = 0b011_00000000000000000 - 10; // 393206\n+    const C2: u32 = 0b100_00000000000000000 - 100; // 524188\n+    const C3: u32 = 0b111_00000000000000000 - 1000; // 916504\n+    const C4: u32 = 0b100_00000000000000000 - 10000; // 514288\n+\n+    // Value of top bits:\n+    //                +c1  +c2  1&2  +c3  +c4  3&4   ^\n+    //         0..=9  010  011  010  110  011  010  000 = 0\n+    //       10..=99  011  011  011  110  011  010  001 = 1\n+    //     100..=999  011  100  000  110  011  010  010 = 2\n+    //   1000..=9999  011  100  000  111  011  011  011 = 3\n+    // 10000..=99999  011  100  000  111  100  100  100 = 4\n+    (((val + C1) & (val + C2)) ^ ((val + C3) & (val + C4))) >> 17\n+}\n \n-    // 0 < val <= u16::MAX\n-    #[inline]\n-    pub const fn u16(val: u16) -> u32 {\n-        less_than_5(val as u32)\n-    }\n+// 0 < val <= u16::MAX\n+#[inline]\n+pub const fn u16(val: u16) -> u32 {\n+    less_than_5(val as u32)\n+}\n \n-    // 0 < val <= u32::MAX\n-    #[inline]\n-    pub const fn u32(mut val: u32) -> u32 {\n-        let mut log = 0;\n-        if val >= 100_000 {\n-            val /= 100_000;\n-            log += 5;\n-        }\n-        log + less_than_5(val)\n+// 0 < val <= u32::MAX\n+#[inline]\n+pub const fn u32(mut val: u32) -> u32 {\n+    let mut log = 0;\n+    if val >= 100_000 {\n+        val /= 100_000;\n+        log += 5;\n     }\n+    log + less_than_5(val)\n+}\n \n-    // 0 < val <= u64::MAX\n-    #[inline]\n-    pub const fn u64(mut val: u64) -> u32 {\n-        let mut log = 0;\n-        if val >= 10_000_000_000 {\n-            val /= 10_000_000_000;\n-            log += 10;\n-        }\n-        if val >= 100_000 {\n-            val /= 100_000;\n-            log += 5;\n-        }\n-        log + less_than_5(val as u32)\n+// 0 < val <= u64::MAX\n+#[inline]\n+pub const fn u64(mut val: u64) -> u32 {\n+    let mut log = 0;\n+    if val >= 10_000_000_000 {\n+        val /= 10_000_000_000;\n+        log += 10;\n     }\n-\n-    // 0 < val <= u128::MAX\n-    #[inline]\n-    pub const fn u128(mut val: u128) -> u32 {\n-        let mut log = 0;\n-        if val >= 100_000_000_000_000_000_000_000_000_000_000 {\n-            val /= 100_000_000_000_000_000_000_000_000_000_000;\n-            log += 32;\n-            return log + u32(val as u32);\n-        }\n-        if val >= 10_000_000_000_000_000 {\n-            val /= 10_000_000_000_000_000;\n-            log += 16;\n-        }\n-        log + u64(val as u64)\n+    if val >= 100_000 {\n+        val /= 100_000;\n+        log += 5;\n     }\n+    log + less_than_5(val as u32)\n+}\n \n-    // 0 < val <= i8::MAX\n-    #[inline]\n-    pub const fn i8(val: i8) -> u32 {\n-        u8(val as u8)\n+// 0 < val <= u128::MAX\n+#[inline]\n+pub const fn u128(mut val: u128) -> u32 {\n+    let mut log = 0;\n+    if val >= 100_000_000_000_000_000_000_000_000_000_000 {\n+        val /= 100_000_000_000_000_000_000_000_000_000_000;\n+        log += 32;\n+        return log + u32(val as u32);\n     }\n-\n-    // 0 < val <= i16::MAX\n-    #[inline]\n-    pub const fn i16(val: i16) -> u32 {\n-        u16(val as u16)\n+    if val >= 10_000_000_000_000_000 {\n+        val /= 10_000_000_000_000_000;\n+        log += 16;\n     }\n+    log + u64(val as u64)\n+}\n \n-    // 0 < val <= i32::MAX\n-    #[inline]\n-    pub const fn i32(val: i32) -> u32 {\n-        u32(val as u32)\n-    }\n+#[cfg(target_pointer_width = \"16\")]\n+#[inline]\n+pub const fn usize(val: usize) -> u32 {\n+    u16(val as _)\n+}\n \n-    // 0 < val <= i64::MAX\n-    #[inline]\n-    pub const fn i64(val: i64) -> u32 {\n-        u64(val as u64)\n-    }\n+#[cfg(target_pointer_width = \"32\")]\n+#[inline]\n+pub const fn usize(val: usize) -> u32 {\n+    u32(val as _)\n+}\n \n-    // 0 < val <= i128::MAX\n-    #[inline]\n-    pub const fn i128(val: i128) -> u32 {\n-        u128(val as u128)\n-    }\n+#[cfg(target_pointer_width = \"64\")]\n+#[inline]\n+pub const fn usize(val: usize) -> u32 {\n+    u64(val as _)\n+}\n+\n+// 0 < val <= i8::MAX\n+#[inline]\n+pub const fn i8(val: i8) -> u32 {\n+    u8(val as u8)\n }\n \n-macro_rules! impl_checked {\n-    ($T:ident) => {\n-        #[inline]\n-        pub const fn $T(val: $T) -> Option<u32> {\n-            if val > 0 { Some(unchecked::$T(val)) } else { None }\n-        }\n-    };\n+// 0 < val <= i16::MAX\n+#[inline]\n+pub const fn i16(val: i16) -> u32 {\n+    u16(val as u16)\n }\n \n-impl_checked! { u8 }\n-impl_checked! { u16 }\n-impl_checked! { u32 }\n-impl_checked! { u64 }\n-impl_checked! { u128 }\n-impl_checked! { i8 }\n-impl_checked! { i16 }\n-impl_checked! { i32 }\n-impl_checked! { i64 }\n-impl_checked! { i128 }\n+// 0 < val <= i32::MAX\n+#[inline]\n+pub const fn i32(val: i32) -> u32 {\n+    u32(val as u32)\n+}\n+\n+// 0 < val <= i64::MAX\n+#[inline]\n+pub const fn i64(val: i64) -> u32 {\n+    u64(val as u64)\n+}\n+\n+// 0 < val <= i128::MAX\n+#[inline]\n+pub const fn i128(val: i128) -> u32 {\n+    u128(val as u128)\n+}"}, {"sha": "79436c8e8ede485c5fc93fadd00c1cd6a6e8ffb0", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -2362,7 +2362,11 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn checked_log10(self) -> Option<u32> {\n-            int_log10::$ActualT(self as $ActualT)\n+            if self > 0 {\n+                Some(int_log10::$ActualT(self as $ActualT))\n+            } else {\n+                None\n+            }\n         }\n \n         /// Computes the absolute value of `self`."}, {"sha": "721c030b410aec548ecbd15e73630e8bd65ba6f5", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -264,7 +264,7 @@ const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8, u8, i8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n+    uint_impl! { u8, u8, i8, NonZeroU8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n     widening_impl! { u8, u16, 8, unsigned }\n \n@@ -813,21 +813,21 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16, u16, i16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { u16, u16, i16, NonZeroU16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n     widening_impl! { u16, u32, 16, unsigned }\n }\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32, u32, i32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { u32, u32, i32, NonZeroU32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n     widening_impl! { u32, u64, 32, unsigned }\n }\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64, u64, i64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { u64, u64, i64, NonZeroU64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n@@ -837,7 +837,7 @@ impl u64 {\n \n #[lang = \"u128\"]\n impl u128 {\n-    uint_impl! { u128, u128, i128, 128, 340282366920938463463374607431768211455, 16,\n+    uint_impl! { u128, u128, i128, NonZeroU128, 128, 340282366920938463463374607431768211455, 16,\n     \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n     \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n     \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n@@ -850,15 +850,15 @@ impl u128 {\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u16, isize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n+    uint_impl! { usize, u16, isize, NonZeroUsize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n     widening_impl! { usize, u32, 16, unsigned }\n }\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u32, isize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n+    uint_impl! { usize, u32, isize, NonZeroUsize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n     widening_impl! { usize, u64, 32, unsigned }\n@@ -867,7 +867,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize, u64, isize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n+    uint_impl! { usize, u64, isize, NonZeroUsize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n     \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\","}, {"sha": "e21ae48917953530440f1e08086ff558e080b827", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -302,7 +302,7 @@ nonzero_integers_div! {\n \n // A bunch of methods for unsigned nonzero types only.\n macro_rules! nonzero_unsigned_operations {\n-    ( $( $Ty: ident($Int: ty); )+ ) => {\n+    ( $( $Ty: ident($Int: ident); )+ ) => {\n         $(\n             impl $Ty {\n                 /// Add an unsigned integer to a non-zero value.\n@@ -442,6 +442,56 @@ macro_rules! nonzero_unsigned_operations {\n                         None\n                     }\n                 }\n+\n+                /// Returns the base 2 logarithm of the number, rounded down.\n+                ///\n+                /// This is the same operation as\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::log2`],\")]\n+                /// except that it has no failure cases to worry about\n+                /// since this value can never be zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(int_log)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().log2(), 2);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().log2(), 3);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().log2(), 3);\")]\n+                /// ```\n+                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[must_use = \"this returns the result of the operation, \\\n+                              without modifying the original\"]\n+                #[inline]\n+                pub const fn log2(self) -> u32 {\n+                    <$Int>::BITS - 1 - self.leading_zeros()\n+                }\n+\n+                /// Returns the base 10 logarithm of the number, rounded down.\n+                ///\n+                /// This is the same operation as\n+                #[doc = concat!(\"[`\", stringify!($Int), \"::log10`],\")]\n+                /// except that it has no failure cases to worry about\n+                /// since this value can never be zero.\n+                ///\n+                /// # Examples\n+                ///\n+                /// ```\n+                /// #![feature(int_log)]\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                ///\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().log10(), 1);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().log10(), 2);\")]\n+                #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().log10(), 2);\")]\n+                /// ```\n+                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[must_use = \"this returns the result of the operation, \\\n+                              without modifying the original\"]\n+                #[inline]\n+                pub const fn log10(self) -> u32 {\n+                    super::int_log10::$Int(self.0)\n+                }\n             }\n         )+\n     }"}, {"sha": "0bb654977764d48c7df40eefa5730247d8580a8c", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -1,5 +1,6 @@\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $BITS:expr, $MaxV:expr,\n+    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $NonZeroT:ident,\n+        $BITS:expr, $MaxV:expr,\n         $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n         $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n         $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr) => {\n@@ -839,12 +840,10 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn checked_log2(self) -> Option<u32> {\n-            if self <= 0 {\n-                None\n+            if let Some(x) = <$NonZeroT>::new(self) {\n+                Some(x.log2())\n             } else {\n-                // SAFETY: We just checked that this number is positive\n-                let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };\n-                Some(log)\n+                None\n             }\n         }\n \n@@ -863,7 +862,11 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn checked_log10(self) -> Option<u32> {\n-            int_log10::$ActualT(self as $ActualT)\n+            if let Some(x) = <$NonZeroT>::new(self) {\n+                Some(x.log10())\n+            } else {\n+                None\n+            }\n         }\n \n         /// Checked negation. Computes `-self`, returning `None` unless `self =="}, {"sha": "53f7108aca36777e6dfdd5df9c072f7228bc4745", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -13,6 +13,7 @@\n - [JSON Output](json.md)\n - [Tests](tests/index.md)\n - [Platform Support](platform-support.md)\n+    - [Template for target-specific documentation](platform-support/TEMPLATE.md)\n     - [aarch64-apple-ios-sim](platform-support/aarch64-apple-ios-sim.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [x86_64-unknown-none](platform-support/x86_64-unknown-none.md)"}, {"sha": "e64783fcf194abe4d401d78d6eb5529c88d79305", "filename": "src/doc/rustc/src/platform-support/TEMPLATE.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2FTEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2FTEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2FTEMPLATE.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,52 @@\n+# `target-name-here`\n+\n+**Tier: 3**\n+\n+One-sentence description of the target (e.g. CPU, OS)\n+\n+## Target maintainers\n+\n+- Some Person, `email@example.org`, https://github.com/...\n+\n+## Requirements\n+\n+Does the target support host tools, or only cross-compilation? Does the target\n+support std, or alloc (either with a default allocator, or if the user supplies\n+an allocator)?\n+\n+Document the expectations of binaries built for the target. Do they assume\n+specific minimum features beyond the baseline of the CPU/environment/etc? What\n+version of the OS or environment do they expect?\n+\n+Are there notable `#[target_feature(...)]` or `-C target-feature=` values that\n+programs may wish to use?\n+\n+What calling convention does `extern \"C\"` use on the target?\n+\n+What format do binaries use by default? ELF, PE, something else?\n+\n+## Building the target\n+\n+If Rust doesn't build the target by default, how can users build it? Can users\n+just add it to the `target` list in `config.toml`?\n+\n+## Building Rust programs\n+\n+Rust does not yet ship pre-compiled artifacts for this target. To compile for\n+this target, you will either need to build Rust with the target enabled (see\n+\"Building the target\" above), or build your own copy of `core` by using\n+`build-std` or similar.\n+\n+## Testing\n+\n+Does the target support running binaries, or do binaries have varying\n+expectations that prevent having a standard way to run them? If users can run\n+binaries, can they do so in some common emulator, or do they need native\n+hardware? Does the target support running the Rust testsuite?\n+\n+## Cross-compilation toolchains and C code\n+\n+Does the target support C code? If so, what toolchain target should users use\n+to build compatible C code? (This may match the target triple, or it may be a\n+toolchain for a different target triple, potentially with specific options or\n+caveats.)"}, {"sha": "53d0470fa8135c491b119abeaa858c96405e7953", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -62,13 +62,22 @@ not preclude an existing target's maintainers using issues (on the Rust\n repository or otherwise) to track requirements that have not yet been met, as\n appropriate; however, before officially proposing the introduction or promotion\n of a target, it should meet all of the necessary requirements. A target\n-proposal is encouraged to quote the corresponding requirements verbatim as part\n-of explaining how the target meets those requirements.\n+proposal must quote the corresponding requirements verbatim and respond to them\n+as part of explaining how the target meets those requirements. (For the\n+requirements that simply state that the target or the target developers must\n+not do something, it suffices to acknowledge the requirement.)\n \n For a list of all supported targets and their corresponding tiers (\"tier 3\",\n \"tier 2\", \"tier 2 with host tools\", \"tier 1\", or \"tier 1 with host tools\"), see\n [platform support](platform-support.md).\n \n+Several parts of this policy require providing target-specific documentation.\n+Such documentation should typically appear in a subdirectory of the\n+platform-support section of this rustc manual, with a link from the target's\n+entry in [platform support](platform-support.md). Use\n+[TEMPLATE.md](platform-support/TEMPLATE.md) as a base, and see other\n+documentation in that directory for examples.\n+\n Note that a target must have already received approval for the next lower tier,\n and spent a reasonable amount of time at that tier, before making a proposal\n for promotion to the next higher tier; this is true even if a target meets the\n@@ -139,17 +148,19 @@ approved by the appropriate team for that shared code before acceptance.\n     or binary. In other words, the introduction of the target must not cause a\n     user installing or running a version of Rust or the Rust tools to be\n     subject to any new license requirements.\n-  - If the target supports building host tools (such as `rustc` or `cargo`),\n-    those host tools must not depend on proprietary (non-FOSS) libraries, other\n-    than ordinary runtime libraries supplied by the platform and commonly used\n-    by other binaries built for the target. For instance, `rustc` built for the\n-    target may depend on a common proprietary C runtime library or console\n-    output library, but must not depend on a proprietary code generation\n-    library or code optimization library. Rust's license permits such\n-    combinations, but the Rust project has no interest in maintaining such\n-    combinations within the scope of Rust itself, even at tier 3.\n-  - Targets should not require proprietary (non-FOSS) components to link a\n-    functional binary or library.\n+  - Compiling, linking, and emitting functional binaries, libraries, or other\n+    code for the target (whether hosted on the target itself or cross-compiling\n+    from another target) must not depend on proprietary (non-FOSS) libraries.\n+    Host tools built for the target itself may depend on the ordinary runtime\n+    libraries supplied by the platform and commonly used by other applications\n+    built for the target, but those libraries must not be required for code\n+    generation for the target; cross-compilation to the target must not require\n+    such libraries at all. For instance, `rustc` built for the target may\n+    depend on a common proprietary C runtime library or console output library,\n+    but must not depend on a proprietary code generation library or code\n+    optimization library. Rust's license permits such combinations, but the\n+    Rust project has no interest in maintaining such combinations within the\n+    scope of Rust itself, even at tier 3.\n   - \"onerous\" here is an intentionally subjective term. At a minimum, \"onerous\"\n     legal/licensing terms include but are *not* limited to: non-disclosure\n     requirements, non-compete requirements, contributor license agreements\n@@ -184,9 +195,9 @@ approved by the appropriate team for that shared code before acceptance.\n   target not implementing those portions.\n - The target must provide documentation for the Rust community explaining how\n   to build for the target, using cross-compilation if possible. If the target\n-  supports running tests (even if they do not pass), the documentation must\n-  explain how to run tests for the target, using emulation if possible or\n-  dedicated hardware if necessary.\n+  supports running binaries, or running tests (even if they do not pass), the\n+  documentation must explain how to run such binaries or tests for the target,\n+  using emulation if possible or dedicated hardware if necessary.\n - Tier 3 targets must not impose burden on the authors of pull requests, or\n   other developers in the community, to maintain the target. In particular,\n   do not post comments (automated or manual) on a PR that derail or suggest a"}, {"sha": "a9a3a0af276b11205f8bf6767fe8bb8570d9c48c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -923,9 +923,7 @@ impl LangString {\n \n         data.original = string.to_owned();\n \n-        let tokens = Self::tokens(string).collect::<Vec<&str>>();\n-\n-        for token in tokens {\n+        for token in Self::tokens(string) {\n             match token {\n                 \"should_panic\" => {\n                     data.should_panic = true;"}, {"sha": "7cc0e74a79bcb8655551f661fe8f404ae550adf8", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -111,6 +111,12 @@ body {\n \tfont: 1rem/1.4 \"Source Serif 4\", NanumBarunGothic, serif;\n \tmargin: 0;\n \tposition: relative;\n+\t/* We use overflow-wrap: break-word for Safari, which doesn't recognize\n+\t   `anywhere`: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap */\n+\toverflow-wrap: break-word;\n+\t/* Then override it with `anywhere`, which is required to make non-Safari browsers break\n+\t   more aggressively when we want them to. */\n+\toverflow-wrap: anywhere;\n \n \t-webkit-font-feature-settings: \"kern\", \"liga\";\n \t-moz-font-feature-settings: \"kern\", \"liga\";\n@@ -446,6 +452,7 @@ nav.sub {\n \ttext-align: center;\n \tborder-bottom: 1px solid;\n \toverflow-wrap: break-word;\n+\toverflow-wrap: anywhere;\n \tword-wrap: break-word; /* deprecated */\n \tword-break: break-word; /* Chrome, non-standard */\n }\n@@ -576,6 +583,7 @@ nav.sub {\n }\n \n .docblock-short {\n+\toverflow-wrap: break-word;\n \toverflow-wrap: anywhere;\n }\n .docblock-short p {\n@@ -641,6 +649,7 @@ nav.sub {\n \tflex-grow: 1;\n \tmargin: 0px;\n \tpadding: 0px;\n+\toverflow-wrap: break-word;\n \toverflow-wrap: anywhere;\n }\n \n@@ -669,6 +678,7 @@ nav.sub {\n \tmargin: .5em 0;\n \twidth: calc(100% - 2px);\n \toverflow-x: auto;\n+\toverflow-wrap: normal;\n \tdisplay: block;\n }\n \n@@ -1495,6 +1505,7 @@ pre.rust {\n \tpadding: 4px 8px;\n \ttext-align: center;\n \tbackground: rgba(0,0,0,0);\n+\toverflow-wrap: normal;\n }\n \n #theme-choices > button:not(:first-child) {\n@@ -2099,9 +2110,14 @@ details.rustdoc-toggle[open] > summary.hideme::after {\n \t}\n \n \t.docblock code {\n+\t\toverflow-wrap: break-word;\n \t\toverflow-wrap: anywhere;\n \t}\n \n+\t.docblock table code {\n+\t\toverflow-wrap: normal;\n+\t}\n+\n \t.sub-container {\n \t\tflex-direction: column;\n \t}"}, {"sha": "9cf611c3379e8b9ef23579ce6c72b2a0483d7a68", "filename": "src/test/incremental/cache_file_headers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fincremental%2Fcache_file_headers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcache_file_headers.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -7,7 +7,7 @@\n \n // The `l33t haxx0r` Rust compiler is known to produce incr. comp. artifacts\n // that are outrageously incompatible with just about anything, even itself:\n-//[rpass1] rustc-env:RUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER=\"l33t haxx0r rustc 2.1 LTS\"\n+//[rpass1] rustc-env:RUSTC_FORCE_RUSTC_VERSION=\"l33t haxx0r rustc 2.1 LTS\"\n \n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph"}, {"sha": "091508cd805b9b0b6f5534cf9f747ac1732fb83b", "filename": "src/test/run-make-fulldeps/crate-hash-rustc-version/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Frun-make-fulldeps%2Fcrate-hash-rustc-version%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Frun-make-fulldeps%2Fcrate-hash-rustc-version%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcrate-hash-rustc-version%2FMakefile?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -27,7 +27,7 @@ all:\n \t$(RUSTC) b.rs --extern a=$(TMPDIR)/liba$(EXT) --crate-type=bin -Crpath $(FLAGS)\n \t$(call RUN,b)\n \t# Now re-compile a.rs with another rustc version\n-\tRUSTC_FORCE_INCR_COMP_ARTIFACT_HEADER=deadfeed $(RUSTC) a.rs --crate-type=dylib $(FLAGS)\n+\tRUSTC_FORCE_RUSTC_VERSION=deadfeed $(RUSTC) a.rs --crate-type=dylib $(FLAGS)\n \t# After compiling with a different rustc version, write symbols to disk again.\n \t$(NM_CMD) $(call DYLIB,a) > $(TMPDIR)/symbolsafter\n \t# As a sanity check, test if the symbols changed:"}, {"sha": "5ba2f5ce3342668c16e1a3678a91ca21723846bf", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,44 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_must_implement_one_of(eq, neq)]\n+trait Equal {\n+    fn eq(&self, other: &Self) -> bool {\n+        !self.neq(other)\n+    }\n+\n+    fn neq(&self, other: &Self) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+struct T0;\n+struct T1;\n+struct T2;\n+struct T3;\n+\n+impl Equal for T0 {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Equal for T1 {\n+    fn neq(&self, _other: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+impl Equal for T2 {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+\n+    fn neq(&self, _other: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+impl Equal for T3 {}\n+//~^ not all trait items implemented, missing one of: `eq`, `neq`\n+\n+fn main() {}"}, {"sha": "5a4dd1388b2e098b38b0f88512126a053140ba03", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of.stderr?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,15 @@\n+error[E0046]: not all trait items implemented, missing one of: `eq`, `neq`\n+  --> $DIR/rustc_must_implement_one_of.rs:41:1\n+   |\n+LL | impl Equal for T3 {}\n+   | ^^^^^^^^^^^^^^^^^ missing one of `eq`, `neq` in implementation\n+   |\n+note: required because of this annotation\n+  --> $DIR/rustc_must_implement_one_of.rs:3:1\n+   |\n+LL | #[rustc_must_implement_one_of(eq, neq)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "56e8fcff0fce507f3bd96dcc969373f7b95e74f2", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_duplicates.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,19 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_must_implement_one_of(a, a)]\n+//~^ Functions names are duplicated\n+trait Trait {\n+    fn a() {}\n+}\n+\n+#[rustc_must_implement_one_of(b, a, a, c, b, c)]\n+//~^ Functions names are duplicated\n+//~| Functions names are duplicated\n+//~| Functions names are duplicated\n+trait Trait1 {\n+    fn a() {}\n+    fn b() {}\n+    fn c() {}\n+}\n+\n+fn main() {}"}, {"sha": "777beba618277f50d9aa4f1314956f7de4b41838", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_duplicates.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_duplicates.stderr?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,34 @@\n+error: Functions names are duplicated\n+  --> $DIR/rustc_must_implement_one_of_duplicates.rs:3:31\n+   |\n+LL | #[rustc_must_implement_one_of(a, a)]\n+   |                               ^  ^\n+   |\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+error: Functions names are duplicated\n+  --> $DIR/rustc_must_implement_one_of_duplicates.rs:9:34\n+   |\n+LL | #[rustc_must_implement_one_of(b, a, a, c, b, c)]\n+   |                                  ^  ^\n+   |\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+error: Functions names are duplicated\n+  --> $DIR/rustc_must_implement_one_of_duplicates.rs:9:31\n+   |\n+LL | #[rustc_must_implement_one_of(b, a, a, c, b, c)]\n+   |                               ^           ^\n+   |\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+error: Functions names are duplicated\n+  --> $DIR/rustc_must_implement_one_of_duplicates.rs:9:40\n+   |\n+LL | #[rustc_must_implement_one_of(b, a, a, c, b, c)]\n+   |                                        ^     ^\n+   |\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be unique\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "ec2995872de021bea422bef62e3c96a5d4a05c1c", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_gated.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,13 @@\n+#[rustc_must_implement_one_of(eq, neq)]\n+//~^ the `#[rustc_must_implement_one_of]` attribute is used to change minimal complete definition of a trait, it's currently in experimental form and should be changed before being exposed outside of the std\n+trait Equal {\n+    fn eq(&self, other: &Self) -> bool {\n+        !self.neq(other)\n+    }\n+\n+    fn neq(&self, other: &Self) -> bool {\n+        !self.eq(other)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "228bc3e35c21d2ab7bf152da302314889e2fb366", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_gated.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_gated.stderr?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: the `#[rustc_must_implement_one_of]` attribute is used to change minimal complete definition of a trait, it's currently in experimental form and should be changed before being exposed outside of the std\n+  --> $DIR/rustc_must_implement_one_of_gated.rs:1:1\n+   |\n+LL | #[rustc_must_implement_one_of(eq, neq)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add `#![feature(rustc_attrs)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1089e5f9c4ab97d8b3cef3c5878d1635289a28a9", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,38 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_must_implement_one_of(a, b)]\n+//~^ Function not found in this trait\n+//~| Function not found in this trait\n+trait Tr0 {}\n+\n+#[rustc_must_implement_one_of(a, b)]\n+//~^ Function not found in this trait\n+trait Tr1 {\n+    fn a() {}\n+}\n+\n+#[rustc_must_implement_one_of(a)]\n+//~^ the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n+trait Tr2 {\n+    fn a() {}\n+}\n+\n+#[rustc_must_implement_one_of]\n+//~^ malformed `rustc_must_implement_one_of` attribute input\n+trait Tr3 {}\n+\n+#[rustc_must_implement_one_of(A, B)]\n+trait Tr4 {\n+    const A: u8 = 1; //~ Not a function\n+\n+    type B; //~ Not a function\n+}\n+\n+#[rustc_must_implement_one_of(a, b)]\n+trait Tr5 {\n+    fn a(); //~ This function doesn't have a default implementation\n+\n+    fn b(); //~ This function doesn't have a default implementation\n+}\n+\n+fn main() {}"}, {"sha": "74a6dc8fec97ceb2cc3f9bc19152cba6ba7d0e25", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/86b1581ea0e0e47196e1ea70b2d980b3eee72623/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr?ref=86b1581ea0e0e47196e1ea70b2d980b3eee72623", "patch": "@@ -0,0 +1,82 @@\n+error: malformed `rustc_must_implement_one_of` attribute input\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:20:1\n+   |\n+LL | #[rustc_must_implement_one_of]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_must_implement_one_of(function1, function2, ...)]`\n+\n+error: Function not found in this trait\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:3:31\n+   |\n+LL | #[rustc_must_implement_one_of(a, b)]\n+   |                               ^\n+\n+error: Function not found in this trait\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:3:34\n+   |\n+LL | #[rustc_must_implement_one_of(a, b)]\n+   |                                  ^\n+\n+error: Function not found in this trait\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:8:34\n+   |\n+LL | #[rustc_must_implement_one_of(a, b)]\n+   |                                  ^\n+\n+error: the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:14:1\n+   |\n+LL | #[rustc_must_implement_one_of(a)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Not a function\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:26:5\n+   |\n+LL |     const A: u8 = 1;\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: required by this annotation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:24:1\n+   |\n+LL | #[rustc_must_implement_one_of(A, B)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be associated function names\n+\n+error: Not a function\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:28:5\n+   |\n+LL |     type B;\n+   |     ^^^^^^^\n+   |\n+note: required by this annotation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:24:1\n+   |\n+LL | #[rustc_must_implement_one_of(A, B)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: All `#[rustc_must_implement_one_of]` arguments must be associated function names\n+\n+error: This function doesn't have a default implementation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:33:5\n+   |\n+LL |     fn a();\n+   |     ^^^^^^^\n+   |\n+note: required by this annotation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:31:1\n+   |\n+LL | #[rustc_must_implement_one_of(a, b)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: This function doesn't have a default implementation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:35:5\n+   |\n+LL |     fn b();\n+   |     ^^^^^^^\n+   |\n+note: required by this annotation\n+  --> $DIR/rustc_must_implement_one_of_misuse.rs:31:1\n+   |\n+LL | #[rustc_must_implement_one_of(a, b)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+"}]}