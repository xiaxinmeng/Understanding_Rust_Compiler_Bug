{"sha": "e85ee60c42db57368e24ad9ac24840c2494d383c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NWVlNjBjNDJkYjU3MzY4ZTI0YWQ5YWMyNDg0MGMyNDk0ZDM4M2M=", "commit": {"author": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-04-14T22:03:54Z"}, "committer": {"name": "Marco Groppo", "email": "marco.groppo@gmail.com", "date": "2019-04-19T22:10:19Z"}, "message": "Initial support for lang items.", "tree": {"sha": "a94bb45556b404452e2ef282e6d11887f93601ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a94bb45556b404452e2ef282e6d11887f93601ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e85ee60c42db57368e24ad9ac24840c2494d383c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e85ee60c42db57368e24ad9ac24840c2494d383c", "html_url": "https://github.com/rust-lang/rust/commit/e85ee60c42db57368e24ad9ac24840c2494d383c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e85ee60c42db57368e24ad9ac24840c2494d383c/comments", "author": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcogroppo", "id": 2735511, "node_id": "MDQ6VXNlcjI3MzU1MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2735511?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcogroppo", "html_url": "https://github.com/marcogroppo", "followers_url": "https://api.github.com/users/marcogroppo/followers", "following_url": "https://api.github.com/users/marcogroppo/following{/other_user}", "gists_url": "https://api.github.com/users/marcogroppo/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcogroppo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcogroppo/subscriptions", "organizations_url": "https://api.github.com/users/marcogroppo/orgs", "repos_url": "https://api.github.com/users/marcogroppo/repos", "events_url": "https://api.github.com/users/marcogroppo/events{/privacy}", "received_events_url": "https://api.github.com/users/marcogroppo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d55f1136d6444b1f50b9092c36a976d0e1c26202", "url": "https://api.github.com/repos/rust-lang/rust/commits/d55f1136d6444b1f50b9092c36a976d0e1c26202", "html_url": "https://github.com/rust-lang/rust/commit/d55f1136d6444b1f50b9092c36a976d0e1c26202"}], "stats": {"total": 245, "additions": 204, "deletions": 41}, "files": [{"sha": "b27efcbe30a495b4ebc6e298b3565c562fb06e41", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -16,6 +16,7 @@ use crate::{\n     generics::{GenericParams, GenericDef},\n     type_ref::TypeRef,\n     traits::TraitData, Trait, ty::TraitRef,\n+    lang_item::LangItems,\n     ids\n };\n \n@@ -100,6 +101,9 @@ pub trait DefDatabase: SourceDatabase {\n \n     #[salsa::invoke(crate::ConstSignature::static_signature_query)]\n     fn static_signature(&self, konst: Static) -> Arc<ConstSignature>;\n+\n+    #[salsa::invoke(crate::lang_item::LangItems::lang_items_query)]\n+    fn lang_items(&self, krate: Crate) -> Arc<LangItems>;\n }\n \n #[salsa::query_group(HirDatabaseStorage)]"}, {"sha": "adcc682a2143816560ed0871a34431dbce8b4ae7", "filename": "crates/ra_hir/src/lang_item.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flang_item.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -0,0 +1,102 @@\n+use std::sync::Arc;\n+use rustc_hash::FxHashMap;\n+\n+use ra_syntax::{SmolStr, ast::AttrsOwner};\n+\n+use crate::{\n+    Crate, DefDatabase, Enum, Function, HirDatabase, ImplBlock, Module, Static, Struct, Trait\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum LangItemTarget {\n+    Enum(Enum),\n+    Function(Function),\n+    Impl(ImplBlock),\n+    Static(Static),\n+    Struct(Struct),\n+    Trait(Trait),\n+}\n+\n+impl LangItemTarget {\n+    pub(crate) fn krate(&self, db: &impl HirDatabase) -> Option<Crate> {\n+        match self {\n+            LangItemTarget::Enum(e) => e.module(db).krate(db),\n+            LangItemTarget::Function(f) => f.module(db).krate(db),\n+            LangItemTarget::Impl(i) => i.module().krate(db),\n+            LangItemTarget::Static(s) => s.module(db).krate(db),\n+            LangItemTarget::Struct(s) => s.module(db).krate(db),\n+            LangItemTarget::Trait(t) => t.module(db).krate(db),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct LangItems {\n+    items: FxHashMap<SmolStr, LangItemTarget>,\n+}\n+\n+impl LangItems {\n+    pub fn target<'a>(&'a self, item: &str) -> Option<&'a LangItemTarget> {\n+        self.items.get(item)\n+    }\n+\n+    /// Salsa query. This will query a specific crate for lang items.\n+    pub(crate) fn lang_items_query(db: &impl DefDatabase, krate: Crate) -> Arc<LangItems> {\n+        let mut lang_items = LangItems { items: FxHashMap::default() };\n+\n+        if let Some(module) = krate.root_module(db) {\n+            lang_items.collect_lang_items_recursive(db, &module);\n+        }\n+\n+        Arc::new(lang_items)\n+    }\n+\n+    fn collect_lang_items_recursive(&mut self, db: &impl DefDatabase, module: &Module) {\n+        // Look for impl targets\n+        let (impl_blocks, source_map) = db.impls_in_module_with_source_map(module.clone());\n+        let source = module.definition_source(db).1;\n+        for (impl_id, _) in impl_blocks.impls.iter() {\n+            let impl_block = source_map.get(&source, impl_id);\n+            let lang_item_name = impl_block\n+                .attrs()\n+                .filter_map(|a| a.as_key_value())\n+                .filter(|(key, _)| key == \"lang\")\n+                .map(|(_, val)| val)\n+                .nth(0);\n+            if let Some(lang_item_name) = lang_item_name {\n+                let imp = ImplBlock::from_id(*module, impl_id);\n+                self.items.entry(lang_item_name).or_insert(LangItemTarget::Impl(imp));\n+            }\n+        }\n+\n+        // FIXME we should look for the other lang item targets (traits, structs, ...)\n+\n+        // Look for lang items in the children\n+        for child in module.children(db) {\n+            self.collect_lang_items_recursive(db, &child);\n+        }\n+    }\n+}\n+\n+/// Look for a lang item, starting from the specified crate and recursively traversing its\n+/// dependencies.\n+pub(crate) fn lang_item_lookup(\n+    db: &impl DefDatabase,\n+    start_krate: Crate,\n+    item: &str,\n+) -> Option<LangItemTarget> {\n+    let lang_items = db.lang_items(start_krate);\n+    let start_krate_target = lang_items.items.get(item);\n+    if start_krate_target.is_some() {\n+        start_krate_target.map(|t| *t)\n+    } else {\n+        for dep in start_krate.dependencies(db) {\n+            let dep_krate = dep.krate;\n+            let dep_target = lang_item_lookup(db, dep_krate, item);\n+            if dep_target.is_some() {\n+                return dep_target;\n+            }\n+        }\n+        None\n+    }\n+}"}, {"sha": "4411715dea42b7a8abbe177bd9f7813637e75edb", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -36,6 +36,7 @@ mod type_ref;\n mod ty;\n mod impl_block;\n mod expr;\n+mod lang_item;\n mod generics;\n mod docs;\n mod resolve;"}, {"sha": "39152360c44181bf2f7f498ced65c7ca866220f2", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -202,6 +202,10 @@ impl CrateDefMap {\n         Arc::new(def_map)\n     }\n \n+    pub(crate) fn krate(&self) -> Crate {\n+        self.krate\n+    }\n+\n     pub(crate) fn root(&self) -> CrateModuleId {\n         self.root\n     }"}, {"sha": "61925e832dfa8c11b95eaed6be3abb83f3e1dac2", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -190,7 +190,7 @@ impl Resolver {\n             .flatten()\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    pub(crate) fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n "}, {"sha": "2275ac1511db10d6c04e564b4699033e93884077", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -462,6 +462,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let remaining_index = remaining_index.unwrap_or(path.segments.len());\n         let mut actual_def_ty: Option<Ty> = None;\n \n+        let krate = resolver.module().map(|t| t.0.krate());\n         // resolve intermediate segments\n         for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n             let ty = match resolved {\n@@ -500,38 +501,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // Attempt to find an impl_item for the type which has a name matching\n             // the current segment\n             log::debug!(\"looking for path segment: {:?}\", segment);\n+\n             actual_def_ty = Some(ty.clone());\n \n-            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| {\n-                let matching_def: Option<crate::ModuleDef> = match item {\n-                    crate::ImplItem::Method(func) => {\n-                        let sig = func.signature(self.db);\n-                        if segment.name == *sig.name() {\n-                            Some(func.into())\n-                        } else {\n-                            None\n+            let item: crate::ModuleDef = krate.and_then(|k| {\n+                ty.iterate_impl_items(self.db, k, |item| {\n+                    let matching_def: Option<crate::ModuleDef> = match item {\n+                        crate::ImplItem::Method(func) => {\n+                            let sig = func.signature(self.db);\n+                            if segment.name == *sig.name() {\n+                                Some(func.into())\n+                            } else {\n+                                None\n+                            }\n                         }\n-                    }\n \n-                    crate::ImplItem::Const(konst) => {\n-                        let sig = konst.signature(self.db);\n-                        if segment.name == *sig.name() {\n-                            Some(konst.into())\n-                        } else {\n-                            None\n+                        crate::ImplItem::Const(konst) => {\n+                            let sig = konst.signature(self.db);\n+                            if segment.name == *sig.name() {\n+                                Some(konst.into())\n+                            } else {\n+                                None\n+                            }\n                         }\n-                    }\n \n-                    // FIXME: Resolve associated types\n-                    crate::ImplItem::TypeAlias(_) => None,\n-                };\n-                match matching_def {\n-                    Some(_) => {\n-                        self.write_assoc_resolution(id, item);\n-                        return matching_def;\n+                        // FIXME: Resolve associated types\n+                        crate::ImplItem::TypeAlias(_) => None,\n+                    };\n+                    match matching_def {\n+                        Some(_) => {\n+                            self.write_assoc_resolution(id, item);\n+                            return matching_def;\n+                        }\n+                        None => None,\n                     }\n-                    None => None,\n-                }\n+                })\n             })?;\n \n             resolved = Resolution::Def(item.into());"}, {"sha": "ba516313c9f2f6bb041693d72681a2fc759d601a", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -14,6 +14,8 @@ use crate::{\n     resolve::Resolver,\n     traits::TraitItem,\n     generics::HasGenericParams,\n+    lang_item::lang_item_lookup,\n+    ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n use super::{TraitRef, Substs};\n \n@@ -110,10 +112,33 @@ impl CrateImplBlocks {\n     }\n }\n \n-fn def_crate(db: &impl HirDatabase, ty: &Ty) -> Option<Crate> {\n+/// Rudimentary check whether an impl exists for a given type and trait; this\n+/// will actually be done by chalk.\n+pub(crate) fn implements(db: &impl HirDatabase, trait_ref: TraitRef) -> bool {\n+    // FIXME use all trait impls in the whole crate graph\n+    let krate = trait_ref.trait_.module(db).krate(db);\n+    let krate = match krate {\n+        Some(krate) => krate,\n+        None => return false,\n+    };\n+    let crate_impl_blocks = db.impls_in_crate(krate);\n+    let mut impl_blocks = crate_impl_blocks.lookup_impl_blocks_for_trait(&trait_ref.trait_);\n+    impl_blocks.any(|impl_block| &impl_block.target_ty(db) == trait_ref.self_ty())\n+}\n+\n+fn def_crate(db: &impl HirDatabase, cur_krate: Crate, ty: &Ty) -> Option<Crate> {\n     match ty {\n         Ty::Apply(a_ty) => match a_ty.ctor {\n             TypeCtor::Adt(def_id) => def_id.krate(db),\n+            TypeCtor::Bool => lang_item_lookup(db, cur_krate, \"bool\")?.krate(db),\n+            TypeCtor::Char => lang_item_lookup(db, cur_krate, \"char\")?.krate(db),\n+            TypeCtor::Float(UncertainFloatTy::Known(f)) => {\n+                lang_item_lookup(db, cur_krate, f.ty_to_string())?.krate(db)\n+            }\n+            TypeCtor::Int(UncertainIntTy::Known(i)) => {\n+                lang_item_lookup(db, cur_krate, i.ty_to_string())?.krate(db)\n+            }\n+            TypeCtor::Str => lang_item_lookup(db, cur_krate, \"str\")?.krate(db),\n             _ => None,\n         },\n         _ => None,\n@@ -150,8 +175,11 @@ impl Ty {\n         // find in the end takes &self, we still do the autoderef step (just as\n         // rustc does an autoderef and then autoref again).\n \n+        let krate = resolver.module().map(|t| t.0.krate())?;\n         for derefed_ty in self.autoderef(db) {\n-            if let Some(result) = derefed_ty.iterate_inherent_methods(db, name, &mut callback) {\n+            if let Some(result) =\n+                derefed_ty.iterate_inherent_methods(db, name, krate, &mut callback)\n+            {\n                 return Some(result);\n             }\n             if let Some(result) =\n@@ -208,9 +236,10 @@ impl Ty {\n         &self,\n         db: &impl HirDatabase,\n         name: Option<&Name>,\n+        krate: Crate,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n-        let krate = match def_crate(db, self) {\n+        let krate = match def_crate(db, krate, self) {\n             Some(krate) => krate,\n             None => return None,\n         };\n@@ -239,9 +268,10 @@ impl Ty {\n     pub fn iterate_impl_items<T>(\n         self,\n         db: &impl HirDatabase,\n+        krate: Crate,\n         mut callback: impl FnMut(ImplItem) -> Option<T>,\n     ) -> Option<T> {\n-        let krate = def_crate(db, &self)?;\n+        let krate = def_crate(db, krate, &self)?;\n         let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&self) {"}, {"sha": "c49147b9ec559c2b421996365d30fb0fc95c3a91", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -38,18 +38,21 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n         hir::ModuleDef::Struct(s) => {\n             let ty = s.ty(ctx.db);\n-            ty.iterate_impl_items(ctx.db, |item| {\n-                match item {\n-                    hir::ImplItem::Method(func) => {\n-                        let sig = func.signature(ctx.db);\n-                        if !sig.has_self_param() {\n-                            acc.add_function(ctx, func);\n+            let krate = ctx.module.and_then(|m| m.krate(ctx.db));\n+            krate.map_or((), |krate| {\n+                ty.iterate_impl_items(ctx.db, krate, |item| {\n+                    match item {\n+                        hir::ImplItem::Method(func) => {\n+                            let sig = func.signature(ctx.db);\n+                            if !sig.has_self_param() {\n+                                acc.add_function(ctx, func);\n+                            }\n                         }\n+                        hir::ImplItem::Const(ct) => acc.add_const(ctx, ct),\n+                        hir::ImplItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n                     }\n-                    hir::ImplItem::Const(ct) => acc.add_const(ctx, ct),\n-                    hir::ImplItem::TypeAlias(ty) => acc.add_type_alias(ctx, ty),\n-                }\n-                None::<()>\n+                    None::<()>\n+                });\n             });\n         }\n         _ => return,"}, {"sha": "5c4c0ffc16a3aa759ad6ae15cb498db5a00fda28", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -65,6 +65,20 @@ impl ast::Attr {\n             None\n         }\n     }\n+\n+    pub fn as_key_value(&self) -> Option<(SmolStr, SmolStr)> {\n+        let tt = self.value()?;\n+        let tt_node = tt.syntax();\n+        let attr = tt_node.children_with_tokens().nth(1)?;\n+        if attr.kind() == IDENT {\n+            let key = attr.as_token()?.text().clone();\n+            let val_node = tt_node.children_with_tokens().find(|t| t.kind() == STRING)?;\n+            let val = val_node.as_token()?.text().trim_start_matches(\"\\\"\").trim_end_matches(\"\\\"\");\n+            Some((key, SmolStr::new(val)))\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]"}, {"sha": "29a7ce166e709deb4bccc4901409ed5cb034dd35", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -1325,6 +1325,7 @@ impl ToOwned for ImplBlock {\n \n \n impl ast::TypeParamsOwner for ImplBlock {}\n+impl ast::AttrsOwner for ImplBlock {}\n impl ImplBlock {\n     pub fn item_list(&self) -> Option<&ItemList> {\n         super::child_opt(self)"}, {"sha": "41fe35f086cd20e2b8a8155e647ce739733d4f6d", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/e85ee60c42db57368e24ad9ac24840c2494d383c/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=e85ee60c42db57368e24ad9ac24840c2494d383c", "patch": "@@ -341,7 +341,7 @@ Grammar(\n             ],\n             options: [\"TypeRef\"]\n         ),\n-        \"ImplBlock\": (options: [\"ItemList\"], traits: [\"TypeParamsOwner\"]),\n+        \"ImplBlock\": (options: [\"ItemList\"], traits: [\"TypeParamsOwner\", \"AttrsOwner\"]),\n \n         \"ParenType\": (options: [\"TypeRef\"]),\n         \"TupleType\": ( collections: [[\"fields\", \"TypeRef\"]] ),"}]}