{"sha": "6c49c2df763f8cf1817bc651582deba8bb35a29d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDljMmRmNzYzZjhjZjE4MTdiYzY1MTU4MmRlYmE4YmIzNWEyOWQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-13T10:52:39Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-16T20:30:42Z"}, "message": "debuginfo: Properly handle monomorphization of generic functions.", "tree": {"sha": "2408cb65af62a117ab1289798d4a78194e3eb68b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2408cb65af62a117ab1289798d4a78194e3eb68b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c49c2df763f8cf1817bc651582deba8bb35a29d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c49c2df763f8cf1817bc651582deba8bb35a29d", "html_url": "https://github.com/rust-lang/rust/commit/6c49c2df763f8cf1817bc651582deba8bb35a29d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c49c2df763f8cf1817bc651582deba8bb35a29d/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "907633b1bfc757cf9a415e4573098f58881469f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/907633b1bfc757cf9a415e4573098f58881469f2", "html_url": "https://github.com/rust-lang/rust/commit/907633b1bfc757cf9a415e4573098f58881469f2"}], "stats": {"total": 245, "additions": 158, "deletions": 87}, "files": [{"sha": "a8600567c7927764407982d1fa160822a2c8e62c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 142, "deletions": 86, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/6c49c2df763f8cf1817bc651582deba8bb35a29d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49c2df763f8cf1817bc651582deba8bb35a29d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6c49c2df763f8cf1817bc651582deba8bb35a29d", "patch": "@@ -51,7 +51,7 @@ This file consists of three conceptual sections:\n \n use driver::session;\n use lib::llvm::llvm;\n-use lib::llvm::{ModuleRef, ContextRef};\n+use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n@@ -97,7 +97,7 @@ pub struct DebugContext {\n     priv builder: DIBuilderRef,\n     priv curr_loc: (uint, uint),\n     priv created_files: HashMap<~str, DIFile>,\n-    priv created_functions: HashMap<ast::NodeId, DISubprogram>,\n+    priv created_functions: HashMap<FunctionCacheKey, DISubprogram>,\n     priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n     priv created_types: HashMap<uint, DIType>\n }\n@@ -121,6 +121,19 @@ impl DebugContext {\n     }\n }\n \n+#[deriving(Eq,IterBytes)]\n+struct FunctionCacheKey {\n+    // Use the address of the llvm function (FunctionContext::llfn) as key for the cache. This\n+    // nicely takes care of monomorphization, where two specializations will have the same\n+    // ast::NodeId but different llvm functions (each needing its own debug description).\n+    priv llfn: ValueRef\n+}\n+\n+impl FunctionCacheKey {\n+    fn for_function_context(fcx: &FunctionContext) -> FunctionCacheKey {\n+        FunctionCacheKey { llfn: fcx.llfn }\n+    }\n+}\n \n pub struct FunctionDebugContext {\n     priv scope_map: HashMap<ast::NodeId, DIScope>,\n@@ -269,13 +282,22 @@ pub fn update_source_pos(fcx: &FunctionContext,\n /// The return value should be ignored if called from outside of the debuginfo module.\n pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n+    let cache_key = FunctionCacheKey::for_function_context(fcx);\n+\n+    match dbg_cx(cx).created_functions.find_copy(&cache_key) {\n+        Some(fn_metadata) => {\n+            assert!(fcx.debug_context.is_some());\n+            return fn_metadata;\n+        }\n+        None => { /* fallthrough */}\n+    }\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, id, generics) = match fnitem {\n+    let (ident, fn_decl, generics, span) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n                 ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n-                    (item.ident, ty, item.id, Some(generics))\n+                    (item.ident, fn_decl, Some(generics), item.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n@@ -284,23 +306,24 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         ast_map::node_method(\n             @ast::method {\n                 decl: ref fn_decl,\n-                id: id,\n                 ident: ident,\n                 generics: ref generics,\n+                span: span,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, id, Some(generics))\n+            (ident, fn_decl, Some(generics), span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n                 ast::expr_fn_block(ref fn_decl, _) => {\n                     let name = gensym_name(\"fn\");\n-                    (name, fn_decl, expr.id,\n+                    (name, fn_decl,\n                         // This is not quite right. It should actually inherit the generics of the\n                         // enclosing function.\n-                        None)\n+                        None,\n+                        expr.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -310,126 +333,148 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n             @ast::provided(\n                 @ast::method {\n                     decl: ref fn_decl,\n-                    id: id,\n                     ident: ident,\n                     generics: ref generics,\n+                    span: span,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, id, Some(generics))\n+            (ident, fn_decl, Some(generics), span)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n \n-    match dbg_cx(cx).created_functions.find_copy(&id) {\n-        Some(fn_metadata) => return fn_metadata,\n-        None => ()\n-    }\n-\n-    let span = match fcx.span {\n-        Some(value) => value,\n-        None => codemap::dummy_sp()\n-    };\n-\n     debug!(\"create_function_metadata: %s, %s\",\n            cx.sess.str_of(ident),\n            cx.sess.codemap.span_to_str(span));\n \n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n+    let function_type_metadata = unsafe {\n+        let fn_signature = get_function_signature(fcx, fn_decl);\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n+    };\n+\n+    let mut function_name = cx.sess.str_of(ident).to_owned();\n+    let template_parameters = get_template_parameters(fcx,\n+                                                      generics,\n+                                                      file_metadata,\n+                                                      span,\n+                                                      &mut function_name);\n+\n+    let fn_metadata = do function_name.to_c_str().with_ref |function_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_metadata,\n+                function_name,\n+                function_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                function_type_metadata,\n+                false,\n+                true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn,\n+                template_parameters,\n+                ptr::null())\n+        }\n+    };\n+\n+    dbg_cx(cx).created_functions.insert(cache_key, fn_metadata);\n+\n+    // Initialize fn debug context (including scope map)\n+    {\n+        assert!(fcx.debug_context.is_none());\n+\n+        let mut fn_debug_context = ~FunctionDebugContext::new();\n+        let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n+        let entry_block = cx.tcx.items.get(&entry_block_id);\n+\n+        match *entry_block {\n+            ast_map::node_block(ref block) => {\n+                let scope_map = &mut fn_debug_context.scope_map;\n+                let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+\n+                populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n+            }\n+            _ => cx.sess.span_bug(span,\n+                    fmt!(\"debuginfo::create_function_metadata() - \\\n+                         FunctionContext::entry_bcx::node_info points to wrong type of ast_map entry. \\\n+                         Expected: ast_map::node_block, actual: %?\", *entry_block))\n+        }\n+\n+        fcx.debug_context = Some(fn_debug_context);\n+    }\n+\n+    return fn_metadata;\n+\n+    fn get_function_signature(fcx: &FunctionContext, fn_decl: &ast::fn_decl) -> DIArray {\n+        let cx = fcx.ccx;\n+\n+        if !cx.sess.opts.extra_debuginfo {\n+            return create_DIArray(DIB(cx), []);\n+        }\n+\n+        let mut signature = vec::with_capacity(fn_decl.inputs.len() + 1);\n+\n+        // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n-            ast::ty_nil => ptr::null(),\n+            ast::ty_nil => {\n+                signature.push(ptr::null());\n+            }\n             _ => {\n-                let return_type = ty::node_id_to_type(cx.tcx, id);\n+                let return_type = ty::node_id_to_type(cx.tcx, fcx.id);\n                 let return_type = match fcx.param_substs {\n                     None => return_type,\n                     Some(substs) => {\n                         ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n                     }\n                 };\n \n-                type_metadata(cx, return_type, ret_ty.span)\n+                signature.push(type_metadata(cx, return_type, codemap::dummy_sp()));\n             }\n         }\n-    } else {\n-        ptr::null()\n-    };\n \n-    let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(\n-            DIB(cx),\n-            file_metadata,\n-            create_DIArray(DIB(cx), [return_type_metadata]))\n-    };\n-\n-    let template_parameters: DIArray = get_template_parameters(cx, fcx, generics, file_metadata, span);\n-\n-    let fn_metadata =\n-        do cx.sess.str_of(ident).with_c_str |name| {\n-        do cx.sess.str_of(ident).with_c_str |linkage| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFunction(\n-                    DIB(cx),\n-                    file_metadata,\n-                    name,\n-                    linkage,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    fn_ty,\n-                    false,\n-                    true,\n-                    loc.line as c_uint,\n-                    FlagPrototyped as c_uint,\n-                    cx.sess.opts.optimize != session::No,\n-                    fcx.llfn,\n-                    template_parameters,\n-                    ptr::null())\n-            }\n-        }};\n-\n-    assert!(fcx.debug_context.is_none());\n-\n-    let mut fn_debug_context = ~FunctionDebugContext::new();\n-    let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n-    let entry_block = cx.tcx.items.get(&entry_block_id);\n-\n-    match *entry_block {\n-        ast_map::node_block(ref block) => {\n-            let scope_map = &mut fn_debug_context.scope_map;\n-            let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+        // arguments types\n+        for arg in fn_decl.inputs.iter() {\n+            let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n+            let arg_type = match fcx.param_substs {\n+                None => arg_type,\n+                Some(substs) => {\n+                    ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n+                }\n+            };\n \n-            populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n+            signature.push(type_metadata(cx, arg_type, codemap::dummy_sp()));\n         }\n-        _ => cx.sess.span_bug(span,\n-                fmt!(\"debuginfo::create_function_metadata() - \\\n-                     FunctionContext::entry_bcx::node_info points to wrong type of ast_map entry. \\\n-                     Expected: ast_map::node_block, actual: %?\", *entry_block))\n-    }\n-\n-    fcx.debug_context = Some(fn_debug_context);\n \n-    dbg_cx(cx).created_functions.insert(id, fn_metadata);\n-    return fn_metadata;\n+        return create_DIArray(DIB(cx), signature);\n+    }\n \n-    fn get_template_parameters(cx: &mut CrateContext,\n-                               fcx: &FunctionContext,\n+    fn get_template_parameters(fcx: &FunctionContext,\n                                generics: Option<&ast::Generics>,\n                                file_metadata: DIFile,\n-                               span: span) -> DIArray {\n+                               span: span,\n+                               name_to_append_suffix_to: &mut ~str)\n+                            -> DIArray {\n         // Normalize cases\n         let generics = match generics {\n             Some(generics_ref) if generics_ref.is_type_parameterized() => Some(generics_ref),\n             _ => None\n         };\n \n+        let cx = fcx.ccx;\n+\n         match generics {\n             None => {\n                 if (fcx.param_substs.is_some()) {\n                     cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                        Mismatch between ast::Generics and FunctionContext::param_substs 111\");\n+                        Mismatch between ast::Generics and FunctionContext::param_substs\");\n                 }\n \n                 return ptr::null();\n@@ -442,22 +487,31 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                     }\n                     None => {\n                         cx.sess.span_bug(span, \"debuginfo::create_function_metadata() - \\\n-                            Mismatch between ast::Generics and FunctionContext::param_substs 222\");\n+                            Mismatch between ast::Generics and FunctionContext::param_substs\");\n                     }\n                 };\n \n+                name_to_append_suffix_to.push_char('<');\n+\n                 let template_params: ~[DIDescriptor] = do generics\n                     .ty_params\n                     .iter()\n                     .enumerate()\n-                    .transform |(index, &ast::TyParam{ ident: ident, _ })| {\n+                    .map |(index, &ast::TyParam{ ident: ident, _ })| {\n \n                         let actual_type = actual_types[index];\n                         let actual_type_metadata = type_metadata(cx,\n                                                                  actual_type,\n                                                                  codemap::dummy_sp());\n \n-                        do cx.sess.str_of(ident).as_c_str |name| {\n+                        // Add actual type name to <...> clause of function name\n+                        let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+                        name_to_append_suffix_to.push_str(actual_type_name);\n+                        if index != generics.ty_params.len() - 1 {\n+                            name_to_append_suffix_to.push_str(\", \");\n+                        }\n+\n+                        do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n                             unsafe {\n                                 llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                                     DIB(cx),\n@@ -471,6 +525,8 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n                         }\n                     }.collect();\n \n+                name_to_append_suffix_to.push_char('>');\n+\n                 return create_DIArray(DIB(cx), template_params);\n             }\n         }"}, {"sha": "c3b48f27b7381382883a0d51533c3759c4054194", "filename": "src/test/debug-info/generic-function.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c49c2df763f8cf1817bc651582deba8bb35a29d/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c49c2df763f8cf1817bc651582deba8bb35a29d/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs?ref=6c49c2df763f8cf1817bc651582deba8bb35a29d", "patch": "@@ -32,6 +32,21 @@\n // check:$6 = {{3.5, 4}, {4, 3.5}}\n // debugger:continue\n \n+// debugger:finish\n+// debugger:print *t0\n+// check:$7 = 5\n+// debugger:print *t1\n+// check:$8 = {a = 6, b = 7.5}\n+// debugger:print ret\n+// check:$9 = {{5, {a = 6, b = 7.5}}, {{a = 6, b = 7.5}, 5}}\n+// debugger:continue\n+\n+#[deriving(Clone)]\n+struct Struct {\n+    a: int,\n+    b: float\n+}\n+\n fn dup_tup<T0: Clone, T1: Clone>(t0: &T0, t1: &T1) -> ((T0, T1), (T1, T0)) {\n     let ret = ((t0.clone(), t1.clone()), (t1.clone(), t0.clone()));\n     zzz();\n@@ -42,7 +57,7 @@ fn main() {\n \n     let _ = dup_tup(&1, &2.5);\n     let _ = dup_tup(&3.5, &4_u16);\n-\n+    let _ = dup_tup(&5, &Struct { a: 6, b: 7.5 });\n }\n \n fn zzz() {()}"}]}