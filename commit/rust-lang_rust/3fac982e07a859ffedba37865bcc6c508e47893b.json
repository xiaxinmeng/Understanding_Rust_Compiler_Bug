{"sha": "3fac982e07a859ffedba37865bcc6c508e47893b", "node_id": "C_kwDOAAsO6NoAKDNmYWM5ODJlMDdhODU5ZmZlZGJhMzc4NjViY2M2YzUwOGU0Nzg5M2I", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-07T02:04:37Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-07T02:04:37Z"}, "message": "Merge commit 'e8dca3e87d164d2806098c462c6ce41301341f68' into sync_from_cg_gcc", "tree": {"sha": "a12775cef836537f2c2dad6a3f32788285c5cdf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a12775cef836537f2c2dad6a3f32788285c5cdf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fac982e07a859ffedba37865bcc6c508e47893b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fac982e07a859ffedba37865bcc6c508e47893b", "html_url": "https://github.com/rust-lang/rust/commit/3fac982e07a859ffedba37865bcc6c508e47893b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fac982e07a859ffedba37865bcc6c508e47893b/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50b00252aeb77b10db04d65dc9e12ce758def4b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/50b00252aeb77b10db04d65dc9e12ce758def4b5", "html_url": "https://github.com/rust-lang/rust/commit/50b00252aeb77b10db04d65dc9e12ce758def4b5"}, {"sha": "e8dca3e87d164d2806098c462c6ce41301341f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8dca3e87d164d2806098c462c6ce41301341f68", "html_url": "https://github.com/rust-lang/rust/commit/e8dca3e87d164d2806098c462c6ce41301341f68"}], "stats": {"total": 8577, "additions": 7959, "deletions": 618}, "files": [{"sha": "8ebdabe82610ec65cf17e62fdd709281e327b6ae", "filename": "compiler/rustc_codegen_gcc/.github/workflows/ci.yml", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -11,7 +11,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\"]\n+        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\", \"libgccjit12.so\"]\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -78,12 +78,21 @@ jobs:\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n     - name: Build\n+      if: matrix.libgccjit_version != 'libgccjit12.so'\n       run: |\n         ./prepare_build.sh\n         ./build.sh\n         cargo test\n         ./clean_all.sh\n \n+    - name: Build\n+      if: matrix.libgccjit_version == 'libgccjit12.so'\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --no-default-features\n+        cargo test --no-default-features\n+        ./clean_all.sh\n+\n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n@@ -98,6 +107,7 @@ jobs:\n         args: --release\n \n     - name: Test\n+      if: matrix.libgccjit_version != 'libgccjit12.so'\n       run: |\n         # Enable backtraces for easier debugging\n         export RUST_BACKTRACE=1\n@@ -107,3 +117,15 @@ jobs:\n         export RUN_RUNS=2\n \n         ./test.sh --release\n+\n+    - name: Test\n+      if: matrix.libgccjit_version == 'libgccjit12.so'\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        # Reduce amount of benchmark runs as they are slow\n+        export COMPILE_RUNS=2\n+        export RUN_RUNS=2\n+\n+        ./test.sh --release --no-default-features"}, {"sha": "12ed56675639c8525feef60ef9bec1d04ef5b824", "filename": "compiler/rustc_codegen_gcc/.gitignore", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.gitignore?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -13,9 +13,13 @@ perf.data.old\n /rust\n /simple-raytracer\n /regex\n+/rand\n gimple*\n *asm\n res\n test-backend\n gcc_path\n benchmarks\n+tools/llvm-project\n+tools/llvmint\n+tools/llvmint-2"}, {"sha": "c7ad93bafe36c0080f9361212af31837849fbbc5", "filename": "compiler/rustc_codegen_gcc/.rustfmt.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2F.rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.rustfmt.toml?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1 @@\n+disable_all_formatting = true"}, {"sha": "6df2102470fe680daa1495b97cc47badc53d8619", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdecdecfb8a02ec861a39a350f990faa33bd31c3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "211d19a8dc8909546bac8558553d2f8ca5c9959c", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -9,9 +9,17 @@ license = \"MIT OR Apache-2.0\"\n crate-type = [\"dylib\"]\n \n [[test]]\n-name = \"lang_tests\"\n-path = \"tests/lib.rs\"\n+name = \"lang_tests_debug\"\n+path = \"tests/lang_tests_debug.rs\"\n harness = false\n+[[test]]\n+name = \"lang_tests_release\"\n+path = \"tests/lang_tests_release.rs\"\n+harness = false\n+\n+[features]\n+default = [\"master\"]\n+master = [\"gccjit/master\"]\n \n [dependencies]\n gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }"}, {"sha": "ba0d0d04948aa3e5f8e789c6507171b3266f2959", "filename": "compiler/rustc_codegen_gcc/build.sh", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,11 +1,13 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n #set -x\n set -e\n \n codegen_channel=debug\n sysroot_channel=debug\n \n+flags=\n+\n while [[ $# -gt 0 ]]; do\n     case $1 in\n         --release)\n@@ -16,6 +18,15 @@ while [[ $# -gt 0 ]]; do\n             sysroot_channel=release\n             shift\n             ;;\n+        --no-default-features)\n+            flags=\"$flags --no-default-features\"\n+            shift\n+            ;;\n+        --features)\n+            shift\n+            flags=\"$flags --features $1\"\n+            shift\n+            ;;\n         *)\n             echo \"Unknown option $1\"\n             exit 1\n@@ -33,21 +44,13 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n-features=\n-\n-if [[ \"$1\" == \"--features\" ]]; then\n-    shift\n-    features=\"--features $1\"\n-    shift\n-fi\n-\n if [[ \"$codegen_channel\" == \"release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release $features\n+    CARGO_INCREMENTAL=1 cargo rustc --release $flags\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc $features\n+    cargo rustc $flags\n fi\n \n source config.sh"}, {"sha": "f293192a099de8062cebbaae4c55653d5f587ae5", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n # Requires the CHANNEL env var to be set to `debug` or `release.`\n "}, {"sha": "56768bbf1d0150431f913ad65462ff509f101eea", "filename": "compiler/rustc_codegen_gcc/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n set -e\n cd $(dirname \"$0\")\n "}, {"sha": "16e49b20423c6f2a49ab2109d82eab660b1bbf5b", "filename": "compiler/rustc_codegen_gcc/cargo.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fcargo.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n if [ -z $CHANNEL ]; then\n export CHANNEL='debug'\n@@ -20,4 +20,4 @@ fi\n cmd=$1\n shift\n \n-RUSTDOCFLAGS=\"$RUSTFLAGS\" cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@\n+RUSTDOCFLAGS=\"$RUSTFLAGS\" cargo +${TOOLCHAIN} $cmd $@"}, {"sha": "782bd3e5058c430929a49dbf107cfd3768864339", "filename": "compiler/rustc_codegen_gcc/clean_all.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fclean_all.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,5 +1,6 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n+set -v\n \n rm -rf target/ build_sysroot/{sysroot/,sysroot_src/,target/,Cargo.lock} perf.data{,.old}\n rm -rf regex/ simple-raytracer/"}, {"sha": "b25e215fb9ee9053c473e6fdfdeb7d63c57e5822", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -2,7 +2,7 @@ set -e\n \n export CARGO_INCREMENTAL=0\n \n-if [ -f ./gcc_path ]; then \n+if [ -f ./gcc_path ]; then\n     export GCC_PATH=$(cat gcc_path)\n else\n     echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "449ca5f6e29cdc3ee3cc689a0e5989b53a593320", "filename": "compiler/rustc_codegen_gcc/crate_patches/0002-rand-Disable-failing-test.patch", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fcrate_patches%2F0002-rand-Disable-failing-test.patch?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1,32 @@\n+From a8fb97120d71252538b6b026695df40d02696bdb Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 15 Aug 2020 20:04:38 +0200\n+Subject: [PATCH] [rand] Disable failing test\n+\n+---\n+ src/distributions/uniform.rs | 3 ++-\n+ 1 file changed, 2 insertions(+), 1 deletion(-)\n+\n+diff --git a/src/distributions/uniform.rs b/src/distributions/uniform.rs\n+index 480b859..c80bb6f 100644\n+--- a/src/distributions/uniform.rs\n++++ b/src/distributions/uniform.rs\n+@@ -1085,7 +1085,7 @@ mod tests {\n+             _ => panic!(\"`UniformDurationMode` was not serialized/deserialized correctly\")\n+         }\n+     }\n+-    \n++\n+     #[test]\n+     #[cfg(feature = \"serde1\")]\n+     fn test_uniform_serialization() {\n+@@ -1314,6 +1314,7 @@ mod tests {\n+         not(target_arch = \"wasm32\"),\n+         not(target_arch = \"asmjs\")\n+     ))]\n++    #[ignore] // FIXME\n+     fn test_float_assertions() {\n+         use super::SampleUniform;\n+         use std::panic::catch_unwind;\n+-- \n+2.20.1"}, {"sha": "31069058aea3417e668cc2f6c407af00dd68ef58", "filename": "compiler/rustc_codegen_gcc/example/std_example.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -93,9 +93,10 @@ fn main() {\n \n     println!(\"{:?}\", std::intrinsics::caller_location());\n \n-    /*unsafe {\n+    #[cfg(feature=\"master\")]\n+    unsafe {\n         test_simd();\n-    }*/\n+    }\n \n     Box::pin(move |mut _task_context| {\n         yield ();\n@@ -104,15 +105,16 @@ fn main() {\n     println!(\"End\");\n }\n \n-/*#[target_feature(enable = \"sse2\")]\n+#[cfg(feature=\"master\")]\n+#[target_feature(enable = \"sse2\")]\n unsafe fn test_simd() {\n     let x = _mm_setzero_si128();\n     let y = _mm_set1_epi16(7);\n     let or = _mm_or_si128(x, y);\n     let cmp_eq = _mm_cmpeq_epi8(y, y);\n     let cmp_lt = _mm_cmplt_epi8(y, y);\n \n-    /*assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n \n@@ -124,14 +126,15 @@ unsafe fn test_simd() {\n     test_mm_cvtepi8_epi16();\n     test_mm_cvtsi128_si64();\n \n-    // FIXME(#666) implement `#[rustc_arg_required_const(..)]` support\n-    //test_mm_extract_epi8();\n+    test_mm_extract_epi8();\n+    test_mm_insert_epi16();\n \n     let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n-    assert_eq!(mask1, 1);*/\n-}*/\n+    assert_eq!(mask1, 1);\n+}\n \n-/*#[target_feature(enable = \"sse2\")]\n+#[cfg(feature=\"master\")]\n+#[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_slli_si128() {\n     #[rustfmt::skip]\n     let a = _mm_setr_epi8(\n@@ -155,22 +158,10 @@ unsafe fn test_mm_slli_si128() {\n     );\n     let r = _mm_slli_si128(a, 16);\n     assert_eq_m128i(r, _mm_set1_epi8(0));\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -1);\n-    assert_eq_m128i(_mm_set1_epi8(0), r);\n-\n-    #[rustfmt::skip]\n-    let a = _mm_setr_epi8(\n-        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-    );\n-    let r = _mm_slli_si128(a, -0x80000000);\n-    assert_eq_m128i(r, _mm_set1_epi8(0));\n }\n \n+\n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_movemask_epi8() {\n     #[rustfmt::skip]\n@@ -184,6 +175,7 @@ unsafe fn test_mm_movemask_epi8() {\n     assert_eq!(r, 0b10100100_00100101);\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"avx2\")]\n unsafe fn test_mm256_movemask_epi8() {\n     let a = _mm256_set1_epi8(-1);\n@@ -192,6 +184,7 @@ unsafe fn test_mm256_movemask_epi8() {\n     assert_eq!(r, e);\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_add_epi8() {\n     let a = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n@@ -207,6 +200,7 @@ unsafe fn test_mm_add_epi8() {\n     assert_eq_m128i(r, e);\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_add_pd() {\n     let a = _mm_setr_pd(1.0, 2.0);\n@@ -215,25 +209,29 @@ unsafe fn test_mm_add_pd() {\n     assert_eq_m128d(r, _mm_setr_pd(6.0, 12.0));\n }\n \n+#[cfg(feature=\"master\")]\n fn assert_eq_m128i(x: std::arch::x86_64::__m128i, y: std::arch::x86_64::__m128i) {\n     unsafe {\n         assert_eq!(std::mem::transmute::<_, [u8; 16]>(x), std::mem::transmute::<_, [u8; 16]>(y));\n     }\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse2\")]\n pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n     if _mm_movemask_pd(_mm_cmpeq_pd(a, b)) != 0b11 {\n         panic!(\"{:?} != {:?}\", a, b);\n     }\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_mm_cvtsi128_si64() {\n     let r = _mm_cvtsi128_si64(std::mem::transmute::<[i64; 2], _>([5, 0]));\n     assert_eq!(r, 5);\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse4.1\")]\n unsafe fn test_mm_cvtepi8_epi16() {\n     let a = _mm_set1_epi8(10);\n@@ -246,6 +244,7 @@ unsafe fn test_mm_cvtepi8_epi16() {\n     assert_eq_m128i(r, e);\n }\n \n+#[cfg(feature=\"master\")]\n #[target_feature(enable = \"sse4.1\")]\n unsafe fn test_mm_extract_epi8() {\n     #[rustfmt::skip]\n@@ -254,10 +253,19 @@ unsafe fn test_mm_extract_epi8() {\n         8, 9, 10, 11, 12, 13, 14, 15\n     );\n     let r1 = _mm_extract_epi8(a, 0);\n-    let r2 = _mm_extract_epi8(a, 19);\n+    let r2 = _mm_extract_epi8(a, 3);\n     assert_eq!(r1, 0xFF);\n     assert_eq!(r2, 3);\n-}*/\n+}\n+\n+#[cfg(all(feature=\"master\", target_arch = \"x86_64\"))]\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_insert_epi16() {\n+    let a = _mm_setr_epi16(0, 1, 2, 3, 4, 5, 6, 7);\n+    let r = _mm_insert_epi16(a, 9, 0);\n+    let e = _mm_setr_epi16(9, 1, 2, 3, 4, 5, 6, 7);\n+    assert_eq_m128i(r, e);\n+}\n \n #[derive(PartialEq)]\n enum LoopState {"}, {"sha": "d5fa1cec061dd6f9d441246bb8bec4bc61186f6f", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "modified", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -7,167 +7,6 @@ Subject: [PATCH] [core] Disable portable-simd test\n  library/core/tests/lib.rs | 1 -\n  1 file changed, 1 deletion(-)\n \n-diff --git a/library/core/src/lib.rs b/library/core/src/lib.rs\n-index aa1ad93..95fbf55 100644\n---- a/library/core/src/lib.rs\n-+++ b/library/core/src/lib.rs\n-@@ -398,23 +398,4 @@ pub mod arch {\n-     }\n- }\n- \n--// Pull in the `core_simd` crate directly into libcore. The contents of\n--// `core_simd` are in a different repository: rust-lang/portable-simd.\n--//\n--// `core_simd` depends on libcore, but the contents of this module are\n--// set up in such a way that directly pulling it here works such that the\n--// crate uses this crate as its libcore.\n--#[path = \"../../portable-simd/crates/core_simd/src/mod.rs\"]\n--#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n--#[allow(rustdoc::bare_urls)]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--mod core_simd;\n--\n--#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--pub mod simd {\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub use crate::core_simd::simd::*;\n--}\n--\n- include!(\"primitive_docs.rs\");\n-diff --git a/library/core/src/slice/mod.rs b/library/core/src/slice/mod.rs\n-index cd38c3a..ad632dc 100644\n---- a/library/core/src/slice/mod.rs\n-+++ b/library/core/src/slice/mod.rs\n-@@ -17,6 +17,5 @@ use crate::ptr;\n- use crate::result::Result;\n- use crate::result::Result::{Err, Ok};\n--use crate::simd::{self, Simd};\n- use crate::slice;\n- \n- #[unstable(\n-@@ -3475,121 +3474,6 @@ impl<T> [T] {\n-         }\n-     }\n- \n--    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n--    ///\n--    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n--    /// postconditions as that method.  You're only assured that\n--    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n--    ///\n--    /// Notably, all of the following are possible:\n--    /// - `prefix.len() >= LANES`.\n--    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n--    /// - `suffix.len() >= LANES`.\n--    ///\n--    /// That said, this is a safe method, so if you're only writing safe code,\n--    /// then this can at most cause incorrect logic, not unsoundness.\n--    ///\n--    /// # Panics\n--    ///\n--    /// This will panic if the size of the SIMD type is different from\n--    /// `LANES` times that of the scalar.\n--    ///\n--    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n--    /// that from ever happening, as only power-of-two numbers of lanes are\n--    /// supported.  It's possible that, in the future, those restrictions might\n--    /// be lifted in a way that would make it possible to see panics from this\n--    /// method for something like `LANES == 3`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// #![feature(portable_simd)]\n--    ///\n--    /// let short = &[1, 2, 3];\n--    /// let (prefix, middle, suffix) = short.as_simd::<4>();\n--    /// assert_eq!(middle, []); // Not enough elements for anything in the middle\n--    ///\n--    /// // They might be split in any possible way between prefix and suffix\n--    /// let it = prefix.iter().chain(suffix).copied();\n--    /// assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n--    ///\n--    /// fn basic_simd_sum(x: &[f32]) -> f32 {\n--    ///     use std::ops::Add;\n--    ///     use std::simd::f32x4;\n--    ///     let (prefix, middle, suffix) = x.as_simd();\n--    ///     let sums = f32x4::from_array([\n--    ///         prefix.iter().copied().sum(),\n--    ///         0.0,\n--    ///         0.0,\n--    ///         suffix.iter().copied().sum(),\n--    ///     ]);\n--    ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n--    ///     sums.reduce_sum()\n--    /// }\n--    ///\n--    /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n--    /// assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n--    /// ```\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T])\n--    where\n--        Simd<T, LANES>: AsRef<[T; LANES]>,\n--        T: simd::SimdElement,\n--        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n--    {\n--        // These are expected to always match, as vector types are laid out like\n--        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n--        // might as well double-check since it'll optimize away anyhow.\n--        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n--\n--        // SAFETY: The simd types have the same layout as arrays, just with\n--        // potentially-higher alignment, so the de-facto transmutes are sound.\n--        unsafe { self.align_to() }\n--    }\n--\n--    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n--    ///\n--    /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n--    /// postconditions as that method.  You're only assured that\n--    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n--    ///\n--    /// Notably, all of the following are possible:\n--    /// - `prefix.len() >= LANES`.\n--    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n--    /// - `suffix.len() >= LANES`.\n--    ///\n--    /// That said, this is a safe method, so if you're only writing safe code,\n--    /// then this can at most cause incorrect logic, not unsoundness.\n--    ///\n--    /// This is the mutable version of [`slice::as_simd`]; see that for examples.\n--    ///\n--    /// # Panics\n--    ///\n--    /// This will panic if the size of the SIMD type is different from\n--    /// `LANES` times that of the scalar.\n--    ///\n--    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n--    /// that from ever happening, as only power-of-two numbers of lanes are\n--    /// supported.  It's possible that, in the future, those restrictions might\n--    /// be lifted in a way that would make it possible to see panics from this\n--    /// method for something like `LANES == 3`.\n--    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])\n--    where\n--        Simd<T, LANES>: AsMut<[T; LANES]>,\n--        T: simd::SimdElement,\n--        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n--    {\n--        // These are expected to always match, as vector types are laid out like\n--        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n--        // might as well double-check since it'll optimize away anyhow.\n--        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n--\n--        // SAFETY: The simd types have the same layout as arrays, just with\n--        // potentially-higher alignment, so the de-facto transmutes are sound.\n--        unsafe { self.align_to_mut() }\n--    }\n--\n-     /// Checks if the elements of this slice are sorted.\n-     ///\n-     /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n index 06c7be0..359e2e7 100644\n --- a/library/core/tests/lib.rs\n@@ -188,41 +27,3 @@ index 06c7be0..359e2e7 100644\n  mod slice;\n  mod str;\n  mod str_lossy;\n-diff --git a/library/std/src/lib.rs b/library/std/src/lib.rs\n-index 5dc586d..b6fc48f 100644\n---- a/library/std/src/lib.rs\n-+++ b/library/std/src/lib.rs\n-@@ -312,6 +312,5 @@\n- #![feature(panic_can_unwind)]\n- #![feature(panic_unwind)]\n- #![feature(platform_intrinsics)]\n--#![feature(portable_simd)]\n- #![feature(prelude_import)]\n- #![feature(ptr_as_uninit)]\n-@@ -508,23 +508,6 @@ pub mod time;\n- #[unstable(feature = \"once_cell\", issue = \"74465\")]\n- pub mod lazy;\n- \n--// Pull in `std_float` crate  into libstd. The contents of\n--// `std_float` are in a different repository: rust-lang/portable-simd.\n--#[path = \"../../portable-simd/crates/std_float/src/lib.rs\"]\n--#[allow(missing_debug_implementations, dead_code, unsafe_op_in_unsafe_fn, unused_unsafe)]\n--#[allow(rustdoc::bare_urls)]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--mod std_float;\n--\n--#[doc = include_str!(\"../../portable-simd/crates/core_simd/src/core_simd_docs.md\")]\n--#[unstable(feature = \"portable_simd\", issue = \"86656\")]\n--pub mod simd {\n--    #[doc(inline)]\n--    pub use crate::std_float::StdFloat;\n--    #[doc(inline)]\n--    pub use core::simd::*;\n--}\n--\n- #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n- pub mod task {\n-     //! Types and Traits for working with asynchronous tasks.\n---\n-2.26.2.7.g19db9cfb68\n-"}, {"sha": "e98f24c6e128db563f211db128a00e08e623ebbc", "filename": "compiler/rustc_codegen_gcc/prepare.sh", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fprepare.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,10 +1,18 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n+set -v\n \n source prepare_build.sh\n \n cargo install hyperfine || echo \"Skipping hyperfine install\"\n \n+git clone https://github.com/rust-random/rand.git || echo \"rust-random/rand has already been cloned\"\n+pushd rand\n+git checkout -- .\n+git checkout 0f933f9c7176e53b2a3c7952ded484e1783f0bf1\n+git am ../crate_patches/*-rand-*.patch\n+popd\n+\n git clone https://github.com/rust-lang/regex.git || echo \"rust-lang/regex has already been cloned\"\n pushd regex\n git checkout -- ."}, {"sha": "8194360da4bae4c6deffa35025af13075e7801dc", "filename": "compiler/rustc_codegen_gcc/prepare_build.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,5 @@\n-#!/bin/bash --verbose\n+#!/usr/bin/env bash\n set -e\n+set -v\n \n ./build_sysroot/prepare_sysroot_src.sh"}, {"sha": "b20aeb979ad78d5b17e00157b514974b8de5bc3f", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-03-26\"\n+channel = \"nightly-2022-06-06\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "59143eac37b3f03a23ec3d7538b2a34feec9823c", "filename": "compiler/rustc_codegen_gcc/rustc_patches/compile_test.patch", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1,14 @@\n+diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n+index 887d27fd6dca4..2c2239f2b83d1 100644\n+--- a/src/tools/compiletest/src/header.rs\n++++ b/src/tools/compiletest/src/header.rs\n+@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n+     cfg: Option<&str>,\n+ ) -> test::TestDesc {\n+     let mut ignore = false;\n+     #[cfg(not(bootstrap))]\n+-    let ignore_message: Option<String> = None;\n++    let ignore_message: Option<&str> = None;\n+     let mut should_fail = false;\n+\n+     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();"}, {"sha": "041079bc9c6f79a9cd305dd7190fb0f5bd8b8001", "filename": "compiler/rustc_codegen_gcc/rustup.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustup.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n set -e\n "}, {"sha": "52fd66af0659d624384ed5a924521d9d771658b9", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -13,6 +13,7 @@ use std::borrow::Cow;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n+use crate::callee::get_fn;\n \n \n // Rust asm! and GCC Extended Asm semantics differ substantially.\n@@ -116,7 +117,6 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n         let is_x86 = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64);\n         let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n-        let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n         // GCC index of an output operand equals its position in the array\n         let mut outputs = vec![];\n@@ -348,9 +348,24 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // processed in the previous pass\n                 }\n \n-                InlineAsmOperandRef::Const { .. }\n-                | InlineAsmOperandRef::SymFn { .. }\n-                | InlineAsmOperandRef::SymStatic { .. } => {\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    inputs.push(AsmInOperand {\n+                        constraint: \"X\".into(),\n+                        rust_idx,\n+                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n+                            .get_address(None),\n+                    });\n+                }\n+\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    inputs.push(AsmInOperand {\n+                        constraint: \"X\".into(),\n+                        rust_idx,\n+                        val: self.cx.get_static(def_id).get_address(None),\n+                    });\n+                }\n+\n+                InlineAsmOperandRef::Const { .. } => {\n                     // processed in the previous pass\n                 }\n             }\n@@ -359,7 +374,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // 3. Build the template string\n \n         let mut template_str = String::with_capacity(estimate_template_length(template, constants_len, att_dialect));\n-        if !intel_dialect {\n+        if att_dialect {\n             template_str.push_str(ATT_SYNTAX_INS);\n         }\n \n@@ -444,7 +459,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n         }\n \n-        if !intel_dialect {\n+        if att_dialect {\n             template_str.push_str(INTEL_SYNTAX_INS);\n         }\n \n@@ -588,7 +603,7 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n@@ -672,8 +687,8 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n         // Default to Intel syntax on x86\n-        let intel_syntax = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64)\n-            && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n+        let att_dialect = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64)\n+            && options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n         // Build the template string\n         let mut template_str = String::new();\n@@ -723,11 +738,11 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         }\n \n         let template_str =\n-            if intel_syntax {\n-                format!(\"{}\\n\\t.intel_syntax noprefix\", template_str)\n+            if att_dialect {\n+                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n             }\n             else {\n-                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n+                template_str\n             };\n         // NOTE: seems like gcc will put the asm in the wrong section, so set it to .text manually.\n         let template_str = format!(\".pushsection .text\\n{}\\n.popsection\", template_str);"}, {"sha": "e4ecbd46f0c428c2657ac3fcf55681f390eea023", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -78,9 +78,19 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         let context = Context::default();\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n+        // TODO(antoyo): only add the following cli argument if the feature is supported.\n+        context.add_command_line_option(\"-msse2\");\n+        context.add_command_line_option(\"-mavx2\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n+        // Only add if the CPU supports it.\n+        //context.add_command_line_option(\"-mavx512f\");\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n+        // NOTE: This is needed to compile the file src/intrinsic/archs.rs during a bootstrap of rustc.\n+        context.add_command_line_option(\"-fno-var-tracking-assignments\");\n         // NOTE: an optimization (https://github.com/rust-lang/rustc_codegen_gcc/issues/53).\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n         // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292)."}, {"sha": "fa490fe3f222ebdd8801020d150036e714ed2227", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 222, "deletions": 29, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -3,11 +3,11 @@ use std::cell::Cell;\n use std::convert::TryFrom;\n use std::ops::Deref;\n \n-use gccjit::FunctionType;\n use gccjit::{\n     BinaryOp,\n     Block,\n     ComparisonOp,\n+    Context,\n     Function,\n     LValue,\n     RValue,\n@@ -48,6 +48,7 @@ use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::common::{SignType, TypeReflection, type_is_pointer};\n use crate::context::CodegenCx;\n+use crate::intrinsic::llvm;\n use crate::type_of::LayoutGccExt;\n \n // TODO(antoyo)\n@@ -199,17 +200,28 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             return Cow::Borrowed(args);\n         }\n \n+        let func_name = format!(\"{:?}\", func_ptr);\n+\n         let casted_args: Vec<_> = param_types\n             .into_iter()\n             .zip(args.iter())\n             .enumerate()\n             .map(|(index, (expected_ty, &actual_val))| {\n+                if llvm::ignore_arg_cast(&func_name, index, args.len()) {\n+                    return actual_val;\n+                }\n+\n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if on_stack_param_indices.contains(&index) {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                        self.context.new_cast(None, actual_val, expected_ty)\n+                    }\n+                    else if on_stack_param_indices.contains(&index) {\n                         actual_val.dereference(None).to_rvalue()\n                     }\n                     else {\n+                        assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n+                        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -268,29 +280,29 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n         let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n-        let mut return_type = gcc_func.get_return_type();\n+        let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n-        // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n-        if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n-            return_type = self.int_type;\n-        }\n-\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            let func_name = format!(\"{:?}\", func_ptr);\n+            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n             self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n         else {\n+            #[cfg(not(feature=\"master\"))]\n             if gcc_func.get_param_count() == 0 {\n                 // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n                 self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n             }\n             else {\n                 self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             }\n+            #[cfg(feature=\"master\")]\n+            self.block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             // Return dummy value when not having return value.\n             let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n             self.block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n@@ -480,8 +492,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn exactudiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): convert the arguments to unsigned?\n         // TODO(antoyo): poison if not exact.\n+        let a_type = a.get_type().to_unsigned(self);\n+        let a = self.gcc_int_cast(a, a_type);\n+        let b_type = b.get_type().to_unsigned(self);\n+        let b = self.gcc_int_cast(b, b_type);\n         a / b\n     }\n \n@@ -511,12 +526,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        if a.get_type() == self.cx.float_type {\n+        if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n             return self.context.new_call(None, fmodf, &[a, b]);\n         }\n-        assert_eq!(a.get_type(), self.cx.double_type);\n+        assert_eq!(a.get_type().unqualified(), self.cx.double_type);\n \n         let fmod = self.context.get_builtin_function(\"fmod\");\n         return self.context.new_call(None, fmod, &[a, b]);\n@@ -632,18 +647,17 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn load(&mut self, _ty: Type<'gcc>, ptr: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n-        // TODO(antoyo): use ty.\n+    fn load(&mut self, pointee_ty: Type<'gcc>, ptr: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n         let block = self.llbb();\n         let function = block.get_function();\n         // NOTE: instead of returning the dereference here, we have to assign it to a variable in\n         // the current basic block. Otherwise, it could be used in another basic block, causing a\n         // dereference after a drop, for instance.\n-        // TODO(antoyo): handle align.\n+        // TODO(antoyo): handle align of the load instruction.\n+        let ptr = self.context.new_cast(None, ptr, pointee_ty.make_pointer());\n         let deref = ptr.dereference(None).to_rvalue();\n-        let value_type = deref.get_type();\n         unsafe { RETURN_VALUE_COUNT += 1 };\n-        let loaded_value = function.new_local(None, value_type, &format!(\"loadedValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+        let loaded_value = function.new_local(None, pointee_ty, &format!(\"loadedValue{}\", unsafe { RETURN_VALUE_COUNT }));\n         block.add_assignment(None, loaded_value, deref);\n         loaded_value.to_rvalue()\n     }\n@@ -695,7 +709,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 OperandValue::Ref(place.llval, Some(llextra), place.align)\n             }\n             else if place.layout.is_gcc_immediate() {\n-                let load = self.load(place.llval.get_type(), place.llval, place.align);\n+                let load = self.load(\n+                    place.layout.gcc_type(self, false),\n+                    place.llval,\n+                    place.align,\n+                );\n                 if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n                     scalar_load_metadata(self, load, scalar);\n                 }\n@@ -707,7 +725,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n-                    let load = self.load(llptr.get_type(), llptr, align);\n+                    let llty = place.layout.scalar_pair_element_gcc_type(self, i, false);\n+                    let load = self.load(llty, llptr, align);\n                     scalar_load_metadata(self, load, scalar);\n                     if scalar.is_bool() { self.trunc(load, self.type_i1()) } else { load }\n                 };\n@@ -779,9 +798,16 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.store_with_flags(val, ptr, align, MemFlags::empty())\n     }\n \n-    fn store_with_flags(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, _align: Align, _flags: MemFlags) -> RValue<'gcc> {\n+    fn store_with_flags(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, align: Align, _flags: MemFlags) -> RValue<'gcc> {\n         let ptr = self.check_store(val, ptr);\n-        self.llbb().add_assignment(None, ptr.dereference(None), val);\n+        let destination = ptr.dereference(None);\n+        // NOTE: libgccjit does not support specifying the alignment on the assignment, so we cast\n+        // to type so it gets the proper alignment.\n+        let destination_type = destination.to_rvalue().get_type().unqualified();\n+        let aligned_type = destination_type.get_aligned(align.bytes()).make_pointer();\n+        let aligned_destination = self.cx.context.new_bitcast(None, ptr, aligned_type);\n+        let aligned_destination = aligned_destination.dereference(None);\n+        self.llbb().add_assignment(None, aligned_destination, val);\n         // TODO(antoyo): handle align and flags.\n         // NOTE: dummy value here since it's never used. FIXME(antoyo): API should not return a value here?\n         self.cx.context.new_rvalue_zero(self.type_i32())\n@@ -953,7 +979,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn memmove(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n         if flags.contains(MemFlags::NONTEMPORAL) {\n             // HACK(nox): This is inefficient but there is no nontemporal memmove.\n-            let val = self.load(src.get_type(), src, src_align);\n+            let val = self.load(src.get_type().get_pointee().expect(\"get_pointee\"), src, src_align);\n             let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n             self.store_with_flags(val, ptr, dst_align, flags);\n             return;\n@@ -1269,16 +1295,183 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let return_type = v1.get_type();\n-        let params = [\n-            self.context.new_parameter(None, return_type, \"v1\"),\n-            self.context.new_parameter(None, return_type, \"v2\"),\n-            self.context.new_parameter(None, mask.get_type(), \"mask\"),\n-        ];\n-        let shuffle = self.context.new_function(None, FunctionType::Extern, return_type, &params, \"_mm_shuffle_epi8\", false);\n-        self.context.new_call(None, shuffle, &[v1, v2, mask])\n+        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+\n+        // TODO(antoyo): use a recursive unqualified() here.\n+        let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let vec_num_units = vector_type.get_num_units();\n+\n+        let mask_num_units = struct_type.get_field_count();\n+        let mut vector_elements = vec![];\n+        let mask_element_type =\n+            if element_type.is_integral() {\n+                element_type\n+            }\n+            else {\n+                #[cfg(feature=\"master\")]\n+                {\n+                    self.cx.type_ix(element_type.get_size() as u64 * 8)\n+                }\n+                #[cfg(not(feature=\"master\"))]\n+                self.int_type\n+            };\n+        for i in 0..mask_num_units {\n+            let field = struct_type.get_field(i as i32);\n+            vector_elements.push(self.context.new_cast(None, mask.access_field(None, field).to_rvalue(), mask_element_type));\n+        }\n+\n+        // NOTE: the mask needs to be the same length as the input vectors, so add the missing\n+        // elements in the mask if needed.\n+        for _ in mask_num_units..vec_num_units {\n+            vector_elements.push(self.context.new_rvalue_zero(mask_element_type));\n+        }\n+\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n+        let result_type = self.context.new_vector_type(element_type, mask_num_units as u64);\n+        let (v1, v2) =\n+            if vec_num_units < mask_num_units {\n+                // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n+                // vectors and create a dummy second vector.\n+                // TODO(antoyo): switch to using new_vector_access.\n+                let array = self.context.new_bitcast(None, v1, array_type);\n+                let mut elements = vec![];\n+                for i in 0..vec_num_units {\n+                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                }\n+                // TODO(antoyo): switch to using new_vector_access.\n+                let array = self.context.new_bitcast(None, v2, array_type);\n+                for i in 0..(mask_num_units - vec_num_units) {\n+                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                }\n+                let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n+                let zero = self.context.new_rvalue_zero(element_type);\n+                let v2 = self.context.new_rvalue_from_vector(None, result_type, &vec![zero; mask_num_units]);\n+                (v1, v2)\n+            }\n+            else {\n+                (v1, v2)\n+            };\n+\n+        let new_mask_num_units = std::cmp::max(mask_num_units, vec_num_units);\n+        let mask_type = self.context.new_vector_type(mask_element_type, new_mask_num_units as u64);\n+        let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n+        let result = self.context.new_rvalue_vector_perm(None, v1, v2, mask);\n+\n+        if vec_num_units != mask_num_units {\n+            // NOTE: if padding was added, only select the number of elements of the masks to\n+            // remove that padding in the result.\n+            let mut elements = vec![];\n+            // TODO(antoyo): switch to using new_vector_access.\n+            let array = self.context.new_bitcast(None, result, array_type);\n+            for i in 0..mask_num_units {\n+                elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+            }\n+            self.context.new_rvalue_from_vector(None, result_type, &elements)\n+        }\n+        else {\n+            result\n+        }\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn shuffle_vector(&mut self, _v1: RValue<'gcc>, _v2: RValue<'gcc>, _mask: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n     }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n+    {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut vector_elements = vec![];\n+        for i in 0..element_count {\n+            vector_elements.push(i);\n+        }\n+        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mut shift = 1;\n+        let mut res = src;\n+        while shift < element_count {\n+            let vector_elements: Vec<_> =\n+                vector_elements.iter()\n+                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .collect();\n+            let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n+            let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n+            shift *= 2;\n+            res = op(res, shifted, &self.context);\n+        }\n+        self.context.new_vector_access(None, res, self.context.new_rvalue_zero(self.int_type))\n+            .to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n+    {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_reduce_op(&mut self, src: RValue<'gcc>, op: BinaryOp) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| context.new_binary_op(None, op, a.get_type(), a, b))\n+    }\n+\n+    pub fn vector_reduce_fadd_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    // Inspired by Hacker's Delight min implementation.\n+    pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+        })\n+    }\n+\n+    // Inspired by Hacker's Delight max implementation.\n+    pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_reduce(src, |a, b, context| {\n+            let differences_or_zeros = difference_or_zero(a, b, context);\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+        })\n+    }\n+\n+    pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n+        // cond is a vector of integers, not of bools.\n+        let cond_type = cond.get_type();\n+        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let num_units = vector_type.get_num_units();\n+        let element_type = vector_type.get_element_type();\n+        let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n+        let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n+\n+        let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        let then_vals = masks & then_val;\n+\n+        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n+        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n+        let inverted_masks = masks + ones;\n+        // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n+        // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n+        // operation to work.\n+        let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n+        let else_vals = inverted_masks & else_val;\n+\n+        then_vals | else_vals\n+    }\n+}\n+\n+fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n+    let difference = a - b;\n+    let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    difference & masks\n }\n \n impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {"}, {"sha": "ce341406eaf4561a2d6aefa29283e8ecb28837dc", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -121,8 +121,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn const_real(&self, _t: Type<'gcc>, _val: f64) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n+        self.context.new_rvalue_from_double(typ, val)\n     }\n \n     fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {\n@@ -279,6 +279,21 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n         else if self.is_u128(cx) {\n             cx.i128_type\n         }\n+        else if self.is_uchar(cx) {\n+            cx.char_type\n+        }\n+        else if self.is_ushort(cx) {\n+            cx.short_type\n+        }\n+        else if self.is_uint(cx) {\n+            cx.int_type\n+        }\n+        else if self.is_ulong(cx) {\n+            cx.long_type\n+        }\n+        else if self.is_ulonglong(cx) {\n+            cx.longlong_type\n+        }\n         else {\n             self.clone()\n         }\n@@ -300,6 +315,21 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n         else if self.is_i128(cx) {\n             cx.u128_type\n         }\n+        else if self.is_char(cx) {\n+            cx.uchar_type\n+        }\n+        else if self.is_short(cx) {\n+            cx.ushort_type\n+        }\n+        else if self.is_int(cx) {\n+            cx.uint_type\n+        }\n+        else if self.is_long(cx) {\n+            cx.ulong_type\n+        }\n+        else if self.is_longlong(cx) {\n+            cx.ulonglong_type\n+        }\n         else {\n             self.clone()\n         }\n@@ -312,6 +342,11 @@ pub trait TypeReflection<'gcc, 'tcx>  {\n     fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_ulong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_ulonglong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_char(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_short(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_int(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_long(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_longlong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n \n     fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_u8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n@@ -326,15 +361,17 @@ pub trait TypeReflection<'gcc, 'tcx>  {\n \n     fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+\n+    fn is_vector(&self) -> bool;\n }\n \n impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     fn is_uchar(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.u8_type\n+        self.unqualified() == cx.uchar_type\n     }\n \n     fn is_ushort(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n-        self.unqualified() == cx.u16_type\n+        self.unqualified() == cx.ushort_type\n     }\n \n     fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n@@ -349,6 +386,26 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n         self.unqualified() == cx.ulonglong_type\n     }\n \n+    fn is_char(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.char_type\n+    }\n+\n+    fn is_short(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.short_type\n+    }\n+\n+    fn is_int(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.int_type\n+    }\n+\n+    fn is_long(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.long_type\n+    }\n+\n+    fn is_longlong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.longlong_type\n+    }\n+\n     fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n         self.unqualified() == cx.i8_type\n     }\n@@ -396,4 +453,21 @@ impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n     fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n         self.unqualified() == cx.context.new_type::<f64>()\n     }\n+\n+    fn is_vector(&self) -> bool {\n+        let mut typ = self.clone();\n+        loop {\n+            if typ.dyncast_vector().is_some() {\n+                return true;\n+            }\n+\n+            let old_type = typ;\n+            typ = typ.unqualified();\n+            if old_type == typ {\n+                break;\n+            }\n+        }\n+\n+        false\n+    }\n }"}, {"sha": "c0b8d21818f854cbbea2529ed6cf81ec3efe863f", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -25,7 +25,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                 }\n             }\n         }\n-        self.context.new_bitcast(None, value, typ)\n+        // NOTE: since bitcast makes a value non-constant, don't bitcast if not necessary as some\n+        // SIMD builtins require a constant value.\n+        self.bitcast_if_needed(value, typ)\n     }\n }\n \n@@ -45,7 +47,10 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             }\n         }\n         let global_value = self.static_addr_of_mut(cv, align, kind);\n-        // TODO(antoyo): set global constant.\n+        #[cfg(feature = \"master\")]\n+        self.global_lvalues.borrow().get(&global_value)\n+            .expect(\"`static_addr_of_mut` did not add the global to `self.global_lvalues`\")\n+            .global_set_readonly();\n         self.const_globals.borrow_mut().insert(cv, global_value);\n         global_value\n     }\n@@ -79,20 +84,15 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         // TODO(antoyo): set alignment.\n \n-        let value =\n-            if value.get_type() != gcc_type {\n-                self.context.new_bitcast(None, value, gcc_type)\n-            }\n-            else {\n-                value\n-            };\n+        let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if !is_mutable {\n             if self.type_is_freeze(ty) {\n-                // TODO(antoyo): set global constant.\n+                #[cfg(feature = \"master\")]\n+                global.global_set_readonly();\n             }\n         }\n \n@@ -171,8 +171,9 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n                     // TODO(antoyo): check if it's okay that no link_section is set.\n-                    // TODO(antoyo): set alignment here as well.\n-                    let global = self.declare_private_global(&name[..], self.val_ty(cv));\n+\n+                    let typ = self.val_ty(cv).get_aligned(align.bytes());\n+                    let global = self.declare_private_global(&name[..], typ);\n                     global\n                 }\n                 _ => {"}, {"sha": "44f36cfa4cad4388e11f8ec333deea71c4291f19", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -35,6 +35,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n+    pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n \n     pub tls_model: gccjit::TlsModel,\n \n@@ -53,10 +54,15 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub u128_type: Type<'gcc>,\n     pub usize_type: Type<'gcc>,\n \n+    pub char_type: Type<'gcc>,\n+    pub uchar_type: Type<'gcc>,\n+    pub short_type: Type<'gcc>,\n+    pub ushort_type: Type<'gcc>,\n     pub int_type: Type<'gcc>,\n     pub uint_type: Type<'gcc>,\n     pub long_type: Type<'gcc>,\n     pub ulong_type: Type<'gcc>,\n+    pub longlong_type: Type<'gcc>,\n     pub ulonglong_type: Type<'gcc>,\n     pub sizet_type: Type<'gcc>,\n \n@@ -145,10 +151,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let float_type = context.new_type::<f32>();\n         let double_type = context.new_type::<f64>();\n \n+        let char_type = context.new_c_type(CType::Char);\n+        let uchar_type = context.new_c_type(CType::UChar);\n+        let short_type = context.new_c_type(CType::Short);\n+        let ushort_type = context.new_c_type(CType::UShort);\n         let int_type = context.new_c_type(CType::Int);\n         let uint_type = context.new_c_type(CType::UInt);\n         let long_type = context.new_c_type(CType::Long);\n         let ulong_type = context.new_c_type(CType::ULong);\n+        let longlong_type = context.new_c_type(CType::LongLong);\n         let ulonglong_type = context.new_c_type(CType::ULongLong);\n         let sizet_type = context.new_c_type(CType::SizeT);\n \n@@ -184,6 +195,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n+            intrinsics: RefCell::new(FxHashMap::default()),\n \n             tls_model,\n \n@@ -200,10 +212,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             u32_type,\n             u64_type,\n             u128_type,\n+            char_type,\n+            uchar_type,\n+            short_type,\n+            ushort_type,\n             int_type,\n             uint_type,\n             long_type,\n             ulong_type,\n+            longlong_type,\n             ulonglong_type,\n             sizet_type,\n \n@@ -269,16 +286,25 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn is_native_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n-        self.is_native_int_type(typ) || typ == self.bool_type\n+        self.is_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n     pub fn is_int_type_or_bool(&self, typ: Type<'gcc>) -> bool {\n-        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ == self.bool_type\n+        self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n+\n+    pub fn bitcast_if_needed(&self, value: RValue<'gcc>, expected_type: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() != expected_type {\n+            self.context.new_bitcast(None, value, expected_type)\n+        }\n+        else {\n+            value\n+        }\n+    }\n }\n \n impl<'gcc, 'tcx> BackendTypes for CodegenCx<'gcc, 'tcx> {\n@@ -306,8 +332,16 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n-        let func = get_fn(self, instance);\n-        let func = self.rvalue_as_function(func);\n+        let func_name = self.tcx.symbol_name(instance).name;\n+\n+        let func =\n+            if self.intrinsics.borrow().contains_key(func_name) {\n+                self.intrinsics.borrow()[func_name].clone()\n+            }\n+            else {\n+                let func = get_fn(self, instance);\n+                self.rvalue_as_function(func)\n+            };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here."}, {"sha": "a619e2f77125243a062ca7617c098f7a2ca562c7", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -11,7 +11,7 @@ use crate::intrinsic::llvm;\n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         if self.globals.borrow().contains_key(name) {\n-            let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n+            let typ = self.globals.borrow()[name].get_type();\n             let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n             if is_tls {\n                 global.set_tls_model(self.tls_model);\n@@ -103,11 +103,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n /// update the declaration and return existing Value instead.\n fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n     if name.starts_with(\"llvm.\") {\n-        return llvm::intrinsic(name, cx);\n+        let intrinsic = llvm::intrinsic(name, cx);\n+        cx.intrinsics.borrow_mut().insert(name.to_string(), intrinsic);\n+        return intrinsic;\n     }\n     let func =\n         if cx.functions.borrow().contains_key(name) {\n-            *cx.functions.borrow().get(name).expect(\"function\")\n+            cx.functions.borrow()[name]\n         }\n         else {\n             let params: Vec<_> = param_types.into_iter().enumerate()"}, {"sha": "0c5dab0046684bc9e48e504d6ded2ec2b083ba94", "filename": "compiler/rustc_codegen_gcc/src/int.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -153,8 +153,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let a_type = a.get_type();\n         let b_type = b.get_type();\n         if self.is_native_int_type_or_bool(a_type) && self.is_native_int_type_or_bool(b_type) {\n-            if a.get_type() != b.get_type() {\n-                b = self.context.new_cast(None, b, a.get_type());\n+            if a_type != b_type {\n+                if a_type.is_vector() {\n+                    // Vector types need to be bitcast.\n+                    // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+                    b = self.context.new_bitcast(None, b, a.get_type());\n+                }\n+                else {\n+                    b = self.context.new_cast(None, b, a.get_type());\n+                }\n             }\n             self.context.new_binary_op(None, operation, a_type, a, b)\n         }\n@@ -593,7 +600,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let b_type = b.get_type();\n         let a_native = self.is_native_int_type_or_bool(a_type);\n         let b_native = self.is_native_int_type_or_bool(b_type);\n-        if a_native && b_native {\n+        if a_type.is_vector() && b_type.is_vector() {\n+            self.context.new_binary_op(None, operation, a_type, a, b)\n+        }\n+        else if a_native && b_native {\n             if a_type != b_type {\n                 b = self.context.new_cast(None, b, a_type);\n             }\n@@ -639,6 +649,8 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         else {\n             // Since u128 and i128 are the only types that can be unsupported, we know the type of\n             // value and the destination type have the same size, so a bitcast is fine.\n+\n+            // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n             self.context.new_bitcast(None, value, dest_typ)\n         }\n     }"}, {"sha": "fb6c38fa072658c886cdd068f30a842e19398deb", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/archs.rs", "status": "added", "additions": 5722, "deletions": 0, "changes": 5722, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b"}, {"sha": "1b089f08f764a066127b5669de791d39a466e047", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/llvm.rs", "status": "modified", "additions": 246, "deletions": 18, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,22 +1,250 @@\n-use gccjit::Function;\n+use std::borrow::Cow;\n \n-use crate::context::CodegenCx;\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n \n-pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n-    let _gcc_name =\n-        match name {\n-            \"llvm.x86.xgetbv\" => {\n-                let gcc_name = \"__builtin_trap\";\n-                let func = cx.context.get_builtin_function(gcc_name);\n-                cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n-                return func;\n+use crate::{context::CodegenCx, builder::Builder};\n+\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+    // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n+    // arguments here.\n+    if gcc_func.get_param_count() != args.len() {\n+        match &*func_name {\n+            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n+                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+                | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n+                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                => {\n+                    // TODO: refactor by separating those intrinsics outside of this branch.\n+                    let add_before_last_arg =\n+                        match &*func_name {\n+                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n+                            _ => false,\n+                        };\n+                    let new_first_arg_is_zero =\n+                        match &*func_name {\n+                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n+                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n+                            _ => false\n+                        };\n+                    let arg3_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n+                            _ => 2,\n+                        };\n+                    let mut new_args = args.to_vec();\n+                    let arg3_type = gcc_func.get_param_type(arg3_index);\n+                    let first_arg =\n+                        if new_first_arg_is_zero {\n+                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                            let num_units = vector_type.get_num_units();\n+                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n+                        }\n+                        else {\n+                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n+                        };\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, first_arg);\n+                    }\n+                    else {\n+                        new_args.push(first_arg);\n+                    }\n+                    let arg4_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n+                            _ => 3,\n+                        };\n+                    let arg4_type = gcc_func.get_param_type(arg4_index);\n+                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, minus_one);\n+                    }\n+                    else {\n+                        new_args.push(minus_one);\n+                    }\n+                    args = new_args.into();\n+                },\n+                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let arg5_type = gcc_func.get_param_type(4);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                        new_args.push(minus_one);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+\n+                        let mut last_arg = None;\n+                        if args.len() == 4 {\n+                            last_arg = new_args.pop();\n+                        }\n+\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+\n+                        if args.len() == 3 {\n+                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                            // the same GCC intrinsic, but the former has 3 parameters and the\n+                            // latter has 4 so it doesn't require this additional argument.\n+                            let arg5_type = gcc_func.get_param_type(4);\n+                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                        }\n+\n+                        if let Some(last_arg) = last_arg {\n+                            new_args.push(last_arg);\n+                        }\n+\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg3_type = gcc_func.get_param_type(2);\n+                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                        new_args.push(undefined);\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    _ => (),\n+        }\n+    }\n+\n+    args\n+}\n+\n+pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n+    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+    // last argument type check.\n+    // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n+    match func_name {\n+        \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+            | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n+            | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+            | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+            | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+            | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                if index == args_len - 1 {\n+                    return true;\n+                }\n             },\n-            // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n-            \"llvm.x86.sse2.cmp.pd\" => \"__builtin_ia32_cmppd\",\n-            \"llvm.x86.sse2.movmsk.pd\" => \"__builtin_ia32_movmskpd\",\n-            \"llvm.x86.sse2.pmovmskb.128\" => \"__builtin_ia32_pmovmskb128\",\n-            _ => unimplemented!(\"unsupported LLVM intrinsic {}\", name)\n-        };\n-\n-    unimplemented!();\n+        \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+            // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n+            // one of them has a missing parameter before the last one, we check the number of\n+            // arguments to distinguish those cases.\n+            if args_len == 4 && index == args_len - 1 {\n+                return true;\n+            }\n+        },\n+        _ => (),\n+    }\n+\n+    false\n+}\n+\n+#[cfg(not(feature=\"master\"))]\n+pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    match name {\n+        \"llvm.x86.xgetbv\" => {\n+            let gcc_name = \"__builtin_trap\";\n+            let func = cx.context.get_builtin_function(gcc_name);\n+            cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+            return func;\n+        },\n+        _ => unimplemented!(\"unsupported LLVM intrinsic {}\", name),\n+    }\n+}\n+\n+#[cfg(feature=\"master\")]\n+pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    let gcc_name = match name {\n+        \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n+        // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n+        \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n+        \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n+        \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n+        \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n+        \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n+        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n+        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n+        \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n+        \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n+        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n+        \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.pd.512\" => \"__builtin_ia32_vfmaddsubpd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.512\" => \"__builtin_ia32_pternlogd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.256\" => \"__builtin_ia32_pternlogd256_mask\",\n+        \"llvm.x86.avx512.pternlog.d.128\" => \"__builtin_ia32_pternlogd128_mask\",\n+        \"llvm.x86.avx512.pternlog.q.512\" => \"__builtin_ia32_pternlogq512_mask\",\n+        \"llvm.x86.avx512.pternlog.q.256\" => \"__builtin_ia32_pternlogq256_mask\",\n+        \"llvm.x86.avx512.pternlog.q.128\" => \"__builtin_ia32_pternlogq128_mask\",\n+        \"llvm.x86.avx512.add.ps.512\" => \"__builtin_ia32_addps512_mask\",\n+        \"llvm.x86.avx512.add.pd.512\" => \"__builtin_ia32_addpd512_mask\",\n+        \"llvm.x86.avx512.sub.ps.512\" => \"__builtin_ia32_subps512_mask\",\n+        \"llvm.x86.avx512.sub.pd.512\" => \"__builtin_ia32_subpd512_mask\",\n+        \"llvm.x86.avx512.mul.ps.512\" => \"__builtin_ia32_mulps512_mask\",\n+        \"llvm.x86.avx512.mul.pd.512\" => \"__builtin_ia32_mulpd512_mask\",\n+        \"llvm.x86.avx512.div.ps.512\" => \"__builtin_ia32_divps512_mask\",\n+        \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n+        \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n+        \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+\n+        // The above doc points to unknown builtins for the following, so override them:\n+        \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n+        \"llvm.x86.avx2.gather.d.d.256\" => \"__builtin_ia32_gathersiv8si\",\n+        \"llvm.x86.avx2.gather.d.ps\" => \"__builtin_ia32_gathersiv4sf\",\n+        \"llvm.x86.avx2.gather.d.ps.256\" => \"__builtin_ia32_gathersiv8sf\",\n+        \"llvm.x86.avx2.gather.d.q\" => \"__builtin_ia32_gathersiv2di\",\n+        \"llvm.x86.avx2.gather.d.q.256\" => \"__builtin_ia32_gathersiv4di\",\n+        \"llvm.x86.avx2.gather.d.pd\" => \"__builtin_ia32_gathersiv2df\",\n+        \"llvm.x86.avx2.gather.d.pd.256\" => \"__builtin_ia32_gathersiv4df\",\n+        \"llvm.x86.avx2.gather.q.d\" => \"__builtin_ia32_gatherdiv4si\",\n+        \"llvm.x86.avx2.gather.q.d.256\" => \"__builtin_ia32_gatherdiv4si256\",\n+        \"llvm.x86.avx2.gather.q.ps\" => \"__builtin_ia32_gatherdiv4sf\",\n+        \"llvm.x86.avx2.gather.q.ps.256\" => \"__builtin_ia32_gatherdiv4sf256\",\n+        \"llvm.x86.avx2.gather.q.q\" => \"__builtin_ia32_gatherdiv2di\",\n+        \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n+        \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n+        \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n+        \"\" => \"\",\n+        // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n+        _ => include!(\"archs.rs\"),\n+    };\n+\n+    let func = cx.context.get_target_builtin_function(gcc_name);\n+    cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+    func\n }"}, {"sha": "c6681de68e2672b6d2f9f1f01cb15901d0dba305", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -967,34 +967,55 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn saturating_add(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n-        let func = self.current_func.borrow().expect(\"func\");\n-\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let after_block = func.new_block(\"after\");\n-            let func_name =\n-                match width {\n-                    8 => \"__builtin_add_overflow\",\n-                    16 => \"__builtin_add_overflow\",\n-                    32 => \"__builtin_sadd_overflow\",\n-                    64 => \"__builtin_saddll_overflow\",\n-                    128 => \"__builtin_add_overflow\",\n-                    _ => unreachable!(),\n-                };\n-            let overflow_func = self.context.get_builtin_function(func_name);\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n+            let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_sum\");\n-            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+            let supports_native_type = self.is_native_int_type(result_type);\n+            let overflow =\n+                if supports_native_type {\n+                    let func_name =\n+                        match width {\n+                            8 => \"__builtin_add_overflow\",\n+                            16 => \"__builtin_add_overflow\",\n+                            32 => \"__builtin_sadd_overflow\",\n+                            64 => \"__builtin_saddll_overflow\",\n+                            128 => \"__builtin_add_overflow\",\n+                            _ => unreachable!(),\n+                        };\n+                    let overflow_func = self.context.get_builtin_function(func_name);\n+                    self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None)\n+                }\n+                else {\n+                    let func_name =\n+                        match width {\n+                            128 => \"__rust_i128_addo\",\n+                            _ => unreachable!(),\n+                        };\n+                    let param_a = self.context.new_parameter(None, result_type, \"a\");\n+                    let param_b = self.context.new_parameter(None, result_type, \"b\");\n+                    let result_field = self.context.new_field(None, result_type, \"result\");\n+                    let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                    let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                    let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                    let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                    let overflow = result.access_field(None, overflow_field);\n+                    let int_result = result.access_field(None, result_field);\n+                    self.llbb().add_assignment(None, res, int_result);\n+                    overflow\n+                };\n \n             let then_block = func.new_block(\"then\");\n+            let after_block = func.new_block(\"after\");\n \n-            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n-            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n-            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n-                self.context.new_rvalue_from_int(unsigned_type, 0)\n-            );\n-            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n-            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            // Return `result_type`'s maximum or minimum value on overflow\n+            // NOTE: convert the type to unsigned to have an unsigned shift.\n+            let unsigned_type = result_type.to_unsigned(&self.cx);\n+            let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n+            let uint_max = self.gcc_not(self.gcc_int(unsigned_type, 0));\n+            let int_max = self.gcc_lshr(uint_max, self.gcc_int(unsigned_type, 1));\n+            then_block.add_assignment(None, res, self.gcc_int_cast(self.gcc_add(shifted, int_max), result_type));\n             then_block.end_with_jump(None, after_block);\n \n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n@@ -1007,19 +1028,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         }\n         else {\n             // Algorithm from: http://locklessinc.com/articles/sat_arithmetic/\n-            let res = lhs + rhs;\n-            let res_type = res.get_type();\n-            let cond = self.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n-            let value = self.context.new_unary_op(None, UnaryOp::Minus, res_type, self.context.new_cast(None, cond, res_type));\n-            res | value\n+            let res = self.gcc_add(lhs, rhs);\n+            let cond = self.gcc_icmp(IntPredicate::IntULT, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(cond, result_type));\n+            self.gcc_or(res, value)\n         }\n     }\n \n     // Algorithm from: https://locklessinc.com/articles/sat_arithmetic/\n     fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n             let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_diff\");\n             let supports_native_type = self.is_native_int_type(result_type);\n@@ -1059,6 +1079,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let then_block = func.new_block(\"then\");\n             let after_block = func.new_block(\"after\");\n \n+            // Return `result_type`'s maximum or minimum value on overflow\n             // NOTE: convert the type to unsigned to have an unsigned shift.\n             let unsigned_type = result_type.to_unsigned(&self.cx);\n             let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n@@ -1076,11 +1097,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             res.to_rvalue()\n         }\n         else {\n-            let res = lhs - rhs;\n-            let comparison = self.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n-            let comparison = self.context.new_cast(None, comparison, lhs.get_type());\n-            let unary_op = self.context.new_unary_op(None, UnaryOp::Minus, comparison.get_type(), comparison);\n-            self.and(res, unary_op)\n+            let res = self.gcc_sub(lhs, rhs);\n+            let comparison = self.gcc_icmp(IntPredicate::IntULE, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(comparison, result_type));\n+            self.gcc_and(res, value)\n         }\n     }\n }"}, {"sha": "870e9f776a4f08b4b9dbe2f2eec439a356a5ce1d", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 571, "deletions": 6, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,15 +1,20 @@\n-use gccjit::{RValue, Type};\n+use std::cmp::Ordering;\n+\n+use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, Symbol, sym};\n+use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n@@ -53,7 +58,53 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     let sig =\n         tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n-    let name_str = name.as_str();\n+\n+    if name == sym::simd_select_bitmask {\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+\n+        let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n+        let expected_bytes = len / 8 + ((len % 8 > 0) as u64);\n+\n+        let mask_ty = arg_tys[0];\n+        let mut mask = match mask_ty.kind() {\n+            ty::Int(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                let place = PlaceRef::alloca(bx, args[0].layout);\n+                args[0].val.store(bx, place);\n+                let int_ty = bx.type_ix(expected_bytes * 8);\n+                let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n+                bx.load(int_ty, ptr, Align::ONE)\n+            }\n+            _ => return_error!(\n+                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+                mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        };\n+\n+        let arg1 = args[1].immediate();\n+        let arg1_type = arg1.get_type();\n+        let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let arg1_element_type = arg1_vector_type.get_element_type();\n+\n+        let mut elements = vec![];\n+        let one = bx.context.new_rvalue_one(mask.get_type());\n+        for _ in 0..len {\n+            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            elements.push(element);\n+            mask = mask >> one;\n+        }\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+\n+        return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n+    }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n@@ -100,10 +151,28 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         ));\n     }\n \n-    if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n-        let n: u64 = stripped.parse().unwrap_or_else(|_| {\n-            span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n-        });\n+    if let Some(stripped) = name.as_str().strip_prefix(\"simd_shuffle\") {\n+        let n: u64 =\n+            if stripped.is_empty() {\n+                // Make sure this is actually an array, since typeck only checks the length-suffixed\n+                // version of this intrinsic.\n+                match args[2].layout.ty.kind() {\n+                    ty::Array(ty, len) if matches!(ty.kind(), ty::Uint(ty::UintTy::U32)) => {\n+                        len.try_eval_usize(bx.cx.tcx, ty::ParamEnv::reveal_all()).unwrap_or_else(|| {\n+                            span_bug!(span, \"could not evaluate shuffle index array length\")\n+                        })\n+                    }\n+                    _ => return_error!(\n+                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n+                        args[2].layout.ty\n+                    ),\n+                }\n+            }\n+            else {\n+                stripped.parse().unwrap_or_else(|_| {\n+                    span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n+                })\n+            };\n \n         require_simd!(ret_ty, \"return\");\n \n@@ -134,6 +203,225 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         ));\n     }\n \n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_insert {\n+        require!(\n+            in_elem == arg_tys[2],\n+            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n+            in_elem,\n+            in_ty,\n+            arg_tys[2]\n+        );\n+        let vector = args[0].immediate();\n+        let index = args[1].immediate();\n+        let value = args[2].immediate();\n+        // TODO(antoyo): use a recursive unqualified() here.\n+        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        // NOTE: we cannot cast to an array and assign to its element here because the value might\n+        // not be an l-value. So, call a builtin to set the element.\n+        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n+        // TODO(antoyo): don't use target specific builtins here.\n+        let func_name =\n+            match in_len {\n+                2 => {\n+                    if element_type == bx.i64_type {\n+                        \"__builtin_ia32_vec_set_v2di\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                4 => {\n+                    if element_type == bx.i32_type {\n+                        \"__builtin_ia32_vec_set_v4si\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                8 => {\n+                    if element_type == bx.i16_type {\n+                        \"__builtin_ia32_vec_set_v8hi\"\n+                    }\n+                    else {\n+                        unimplemented!();\n+                    }\n+                },\n+                _ => unimplemented!(\"Len: {}\", in_len),\n+            };\n+        let builtin = bx.context.get_target_builtin_function(func_name);\n+        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n+        let result = bx.context.new_call(None, builtin, &[vector, value, bx.context.new_cast(None, index, bx.int_type)]);\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_extract {\n+        require!(\n+            ret_ty == in_elem,\n+            \"expected return type `{}` (element of input `{}`), found `{}`\",\n+            in_elem,\n+            in_ty,\n+            ret_ty\n+        );\n+        let vector = args[0].immediate();\n+        return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n+    }\n+\n+    if name == sym::simd_select {\n+        let m_elem_ty = in_elem;\n+        let m_len = in_len;\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        require!(\n+            m_len == v_len,\n+            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n+            m_len,\n+            v_len\n+        );\n+        match m_elem_ty.kind() {\n+            ty::Int(_) => {}\n+            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+        }\n+        return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n+    }\n+\n+    if name == sym::simd_cast {\n+        require_simd!(ret_ty, \"return\");\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+        // casting cares about nominal type, not just structural type\n+        if in_elem == out_elem {\n+            return Ok(args[0].immediate());\n+        }\n+\n+        enum Style {\n+            Float,\n+            Int(/* is signed? */ bool),\n+            Unsupported,\n+        }\n+\n+        let (in_style, in_width) = match in_elem.kind() {\n+            // vectors of pointer-sized integers should've been\n+            // disallowed before here, so this unwrap is safe.\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0),\n+        };\n+        let (out_style, out_width) = match out_elem.kind() {\n+            ty::Int(i) => (\n+                Style::Int(true),\n+                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Uint(u) => (\n+                Style::Int(false),\n+                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n+            ),\n+            ty::Float(f) => (Style::Float, f.bit_width()),\n+            _ => (Style::Unsupported, 0),\n+        };\n+\n+        let extend = |in_type, out_type| {\n+            let vector_type = bx.context.new_vector_type(out_type, 8);\n+            let vector = args[0].immediate();\n+            let array_type = bx.context.new_array_type(None, in_type, 8);\n+            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n+            let array = bx.context.new_bitcast(None, vector, array_type);\n+\n+            let cast_vec_element = |index| {\n+                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n+                bx.context.new_cast(None, bx.context.new_array_access(None, array, index).to_rvalue(), out_type)\n+            };\n+\n+            bx.context.new_rvalue_from_vector(None, vector_type, &[\n+                cast_vec_element(0),\n+                cast_vec_element(1),\n+                cast_vec_element(2),\n+                cast_vec_element(3),\n+                cast_vec_element(4),\n+                cast_vec_element(5),\n+                cast_vec_element(6),\n+                cast_vec_element(7),\n+            ])\n+        };\n+\n+        match (in_style, out_style) {\n+            (Style::Int(in_is_signed), Style::Int(_)) => {\n+                return Ok(match in_width.cmp(&out_width) {\n+                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n+                    Ordering::Equal => args[0].immediate(),\n+                    Ordering::Less => {\n+                        if in_is_signed {\n+                            match (in_width, out_width) {\n+                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n+                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n+                                // we can generate a call to it.\n+                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n+                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n+                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n+                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n+                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n+                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n+                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n+                            }\n+                        } else {\n+                            match (in_width, out_width) {\n+                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n+                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n+                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n+                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n+                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n+                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n+                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+            (Style::Int(_), Style::Float) => {\n+                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n+                // doing like __builtin_convertvector?\n+                // Or maybe provide convert_vector as an API since it might not easy to get the\n+                // types of internal functions.\n+                unimplemented!();\n+            }\n+            (Style::Float, Style::Int(_)) => {\n+                unimplemented!();\n+            }\n+            (Style::Float, Style::Float) => {\n+                unimplemented!();\n+            }\n+            _ => { /* Unsupported. Fallthrough. */ }\n+        }\n+        require!(\n+            false,\n+            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+            in_ty,\n+            in_elem,\n+            ret_ty,\n+            out_elem\n+        );\n+    }\n+\n     macro_rules! arith_binary {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n             $(if name == sym::$name {\n@@ -151,6 +439,105 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         }\n     }\n \n+    fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n+        name: Symbol,\n+        in_elem: Ty<'_>,\n+        in_ty: Ty<'_>,\n+        in_len: u64,\n+        bx: &mut Builder<'_, 'gcc, 'tcx>,\n+        span: Span,\n+        args: &[OperandRef<'tcx, RValue<'gcc>>],\n+    ) -> Result<RValue<'gcc>, ()> {\n+        macro_rules! emit_error {\n+            ($msg: tt) => {\n+                emit_error!($msg, )\n+            };\n+            ($msg: tt, $($fmt: tt)*) => {\n+                span_invalid_monomorphization_error(\n+                    bx.sess(), span,\n+                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n+                             name, $($fmt)*));\n+            }\n+        }\n+        macro_rules! return_error {\n+            ($($fmt: tt)*) => {\n+                {\n+                    emit_error!($($fmt)*);\n+                    return Err(());\n+                }\n+            }\n+        }\n+\n+        let (elem_ty_str, elem_ty) =\n+            if let ty::Float(f) = in_elem.kind() {\n+                let elem_ty = bx.cx.type_float_from_ty(*f);\n+                match f.bit_width() {\n+                    32 => (\"f32\", elem_ty),\n+                    64 => (\"f64\", elem_ty),\n+                    _ => {\n+                        return_error!(\n+                            \"unsupported element type `{}` of floating-point vector `{}`\",\n+                            f.name_str(),\n+                            in_ty\n+                        );\n+                    }\n+                }\n+            }\n+            else {\n+                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            };\n+\n+        let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n+\n+        let (intr_name, fn_ty) =\n+            match name {\n+                sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)), // TODO(antoyo): pand with 170141183420855150465331762880109871103\n+                sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n+                sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n+                sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n+                sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n+                sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n+                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+            };\n+        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n+        let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n+        let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n+        let c = bx.call(fn_ty, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        Ok(c)\n+    }\n+\n+    if std::matches!(\n+        name,\n+        sym::simd_ceil\n+            | sym::simd_fabs\n+            | sym::simd_fcos\n+            | sym::simd_fexp2\n+            | sym::simd_fexp\n+            | sym::simd_flog10\n+            | sym::simd_flog2\n+            | sym::simd_flog\n+            | sym::simd_floor\n+            | sym::simd_fma\n+            | sym::simd_fpow\n+            | sym::simd_fpowi\n+            | sym::simd_fsin\n+            | sym::simd_fsqrt\n+            | sym::simd_round\n+            | sym::simd_trunc\n+    ) {\n+        return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n@@ -185,5 +572,183 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         simd_neg: Int => neg, Float => fneg;\n     }\n \n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n+        let lhs = args[0].immediate();\n+        let rhs = args[1].immediate();\n+        let is_add = name == sym::simd_saturating_add;\n+        let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n+        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n+            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n+            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n+            _ => {\n+                return_error!(\n+                    \"expected element type `{}` of vector type `{}` \\\n+                     to be a signed or unsigned integer type\",\n+                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    arg_tys[0]\n+                );\n+            }\n+        };\n+        let builtin_name =\n+            match (signed, is_add, in_len, elem_width) {\n+                (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n+                (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n+                (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n+                (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n+                (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n+                (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n+                (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n+                (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n+                _ => unimplemented!(\"signed: {}, is_add: {}, in_len: {}, elem_width: {}\", signed, is_add, in_len, elem_width),\n+            };\n+        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n+\n+        let func = bx.context.get_target_builtin_function(builtin_name);\n+        let param1_type = func.get_param(0).to_rvalue().get_type();\n+        let param2_type = func.get_param(1).to_rvalue().get_type();\n+        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n+        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n+        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n+        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+    }\n+\n+    macro_rules! arith_red {\n+        ($name:ident : $vec_op:expr, $float_reduce:ident, $ordered:expr, $op:ident,\n+         $identity:expr) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.vector_reduce_op(args[0].immediate(), $vec_op);\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            Ok(bx.$op(args[1].immediate(), r))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n+                        }\n+                    }\n+                    ty::Float(_) => {\n+                        if $ordered {\n+                            // ordered arithmetic reductions take an accumulator\n+                            let acc = args[1].immediate();\n+                            Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                        }\n+                        else {\n+                            Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n+                        }\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    arith_red!(\n+        simd_reduce_add_unordered: BinaryOp::Plus,\n+        vector_reduce_fadd_fast,\n+        false,\n+        add,\n+        0.0 // TODO: Use this argument.\n+    );\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n+\n+    macro_rules! minmax_red {\n+        ($name:ident: $reduction:ident) => {\n+            if name == sym::$name {\n+                require!(\n+                    ret_ty == in_elem,\n+                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                    in_elem,\n+                    in_ty,\n+                    ret_ty\n+                );\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    minmax_red!(simd_reduce_min: vector_reduce_min);\n+    minmax_red!(simd_reduce_max: vector_reduce_max);\n+\n+    macro_rules! bitwise_red {\n+        ($name:ident : $op:expr, $boolean:expr) => {\n+            if name == sym::$name {\n+                let input = if !$boolean {\n+                    require!(\n+                        ret_ty == in_elem,\n+                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                        in_elem,\n+                        in_ty,\n+                        ret_ty\n+                    );\n+                    args[0].immediate()\n+                } else {\n+                    match in_elem.kind() {\n+                        ty::Int(_) | ty::Uint(_) => {}\n+                        _ => return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            sym::$name,\n+                            in_ty,\n+                            in_elem,\n+                            ret_ty\n+                        ),\n+                    }\n+\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = bx.type_i1();\n+                    let i1xn = bx.type_vector(i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.kind() {\n+                    ty::Int(_) | ty::Uint(_) => {\n+                        let r = bx.vector_reduce_op(input, $op);\n+                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                    }\n+                    _ => return_error!(\n+                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                        sym::$name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty\n+                    ),\n+                };\n+            }\n+        };\n+    }\n+\n+    bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n+    bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+\n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "5bfdeb8b93a484fc4077f1efad4372155e5c6137", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -203,7 +203,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n     fn run_fat_lto(_cgcx: &CodegenContext<Self>, mut modules: Vec<FatLTOInput<Self>>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<LtoModuleCodegen<Self>, FatalError> {\n         // TODO(antoyo): implement LTO by sending -flto to libgccjit and adding the appropriate gcc linker plugins.\n         // NOTE: implemented elsewhere.\n-        // TODO: what is implemented elsewhere ^ ?\n+        // TODO(antoyo): what is implemented elsewhere ^ ?\n         let module =\n             match modules.remove(0) {\n                 FatLTOInput::InMemory(module) => module,\n@@ -301,7 +301,22 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         )\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n-            false\n+            // Probably using the equivalent of __builtin_cpu_supports.\n+            #[cfg(feature=\"master\")]\n+            {\n+                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+            }\n+            #[cfg(not(feature=\"master\"))]\n+            {\n+                false\n+            }\n+            /*\n+               adx, aes, avx, avx2, avx512bf16, avx512bitalg, avx512bw, avx512cd, avx512dq, avx512er, avx512f, avx512gfni,\n+               avx512ifma, avx512pf, avx512vaes, avx512vbmi, avx512vbmi2, avx512vl, avx512vnni, avx512vp2intersect, avx512vpclmulqdq,\n+               avx512vpopcntdq, bmi1, bmi2, cmpxchg16b, ermsb, f16c, fma, fxsr, lzcnt, movbe, pclmulqdq, popcnt, rdrand, rdseed, rtm,\n+               sha, sse, sse2, sse3, sse4.1, sse4.2, sse4a, ssse3, tbm, xsave, xsavec, xsaveopt, xsaves\n+             */\n+            //false\n         })\n         .map(|feature| Symbol::intern(feature))\n         .collect()"}, {"sha": "002b95db36deef85e6b2a145bfe1e1415d8c1eb5", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -3,10 +3,11 @@ use std::convert::TryInto;\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods};\n use rustc_codegen_ssa::common::TypeKind;\n-use rustc_middle::bug;\n+use rustc_middle::{bug, ty};\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n+use crate::common::TypeReflection;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n@@ -60,6 +61,17 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ity = Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n+\n+    pub fn type_vector(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        self.context.new_vector_type(ty, len)\n+    }\n+\n+    pub fn type_float_from_ty(&self, t: ty::FloatTy) -> Type<'gcc> {\n+        match t {\n+            ty::FloatTy::F32 => self.type_f32(),\n+            ty::FloatTy::F64 => self.type_f64(),\n+        }\n+    }\n }\n \n impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -103,16 +115,19 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.context.new_function_pointer_type(None, return_type, params, false)\n     }\n \n-    fn type_struct(&self, fields: &[Type<'gcc>], _packed: bool) -> Type<'gcc> {\n+    fn type_struct(&self, fields: &[Type<'gcc>], packed: bool) -> Type<'gcc> {\n         let types = fields.to_vec();\n         if let Some(typ) = self.struct_types.borrow().get(fields) {\n             return typ.clone();\n         }\n         let fields: Vec<_> = fields.iter().enumerate()\n             .map(|(index, field)| self.context.new_field(None, *field, &format!(\"field{}_TODO\", index)))\n             .collect();\n-        // TODO(antoyo): use packed.\n         let typ = self.context.new_struct_type(None, \"struct\", &fields).as_type();\n+        if packed {\n+            #[cfg(feature=\"master\")]\n+            typ.set_packed();\n+        }\n         self.struct_types.borrow_mut().insert(types, typ);\n         typ\n     }\n@@ -127,7 +142,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         else if typ.is_compatible_with(self.double_type) {\n             TypeKind::Double\n         }\n-        else if typ.dyncast_vector().is_some() {\n+        else if typ.is_vector() {\n             TypeKind::Vector\n         }\n         else {\n@@ -141,7 +156,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn type_ptr_to_ext(&self, ty: Type<'gcc>, _address_space: AddressSpace) -> Type<'gcc> {\n-        // TODO(antoyo): use address_space\n+        // TODO(antoyo): use address_space, perhaps with TYPE_ADDR_SPACE?\n         ty.make_pointer()\n     }\n \n@@ -167,10 +182,10 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn float_width(&self, typ: Type<'gcc>) -> usize {\n         let f32 = self.context.new_type::<f32>();\n         let f64 = self.context.new_type::<f64>();\n-        if typ == f32 {\n+        if typ.is_compatible_with(f32) {\n             32\n         }\n-        else if typ == f64 {\n+        else if typ.is_compatible_with(f64) {\n             64\n         }\n         else {\n@@ -197,12 +212,15 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.type_array(self.type_from_integer(unit), size / unit_size)\n     }\n \n-    pub fn set_struct_body(&self, typ: Struct<'gcc>, fields: &[Type<'gcc>], _packed: bool) {\n-        // TODO(antoyo): use packed.\n+    pub fn set_struct_body(&self, typ: Struct<'gcc>, fields: &[Type<'gcc>], packed: bool) {\n         let fields: Vec<_> = fields.iter().enumerate()\n             .map(|(index, field)| self.context.new_field(None, *field, &format!(\"field_{}\", index)))\n             .collect();\n         typ.set_fields(None, &fields);\n+        if packed {\n+            #[cfg(feature=\"master\")]\n+            typ.as_type().set_packed();\n+        }\n     }\n \n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n@@ -229,6 +247,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n         self.context.new_array_type(None, ty, len)\n     }\n+\n+    pub fn type_bool(&self) -> Type<'gcc> {\n+        self.context.new_type::<bool>()\n+    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {"}, {"sha": "569ee2925b13c1785c9695ca80f708c912478774", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -24,6 +24,30 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             I128 => self.type_u128(),\n         }\n     }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn type_int_from_ty(&self, t: ty::IntTy) -> Type<'gcc> {\n+        match t {\n+            ty::IntTy::Isize => self.type_isize(),\n+            ty::IntTy::I8 => self.type_i8(),\n+            ty::IntTy::I16 => self.type_i16(),\n+            ty::IntTy::I32 => self.type_i32(),\n+            ty::IntTy::I64 => self.type_i64(),\n+            ty::IntTy::I128 => self.type_i128(),\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn type_uint_from_ty(&self, t: ty::UintTy) -> Type<'gcc> {\n+        match t {\n+            ty::UintTy::Usize => self.type_isize(),\n+            ty::UintTy::U8 => self.type_i8(),\n+            ty::UintTy::U16 => self.type_i16(),\n+            ty::UintTy::U32 => self.type_i32(),\n+            ty::UintTy::U64 => self.type_i64(),\n+            ty::UintTy::U128 => self.type_i128(),\n+        }\n+    }\n }\n \n pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {"}, {"sha": "8b390f95a4b9b54a8cbe7512723b89d82750f266", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 131, "deletions": 94, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,4 +1,4 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n \n # TODO(antoyo): rewrite to cargo-make (or just) or something like that to only rebuild the sysroot when needed?\n \n@@ -14,25 +14,87 @@ fi\n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n \n-features=\n-\n-if [[ \"$1\" == \"--features\" ]]; then\n-    shift\n-    features=\"--features $1\"\n-    shift\n-fi\n-\n-if [[ \"$1\" == \"--release\" ]]; then\n+flags=\n+gcc_master_branch=1\n+channel=\"debug\"\n+func=all\n+build_only=0\n+\n+while [[ $# -gt 0 ]]; do\n+    case $1 in\n+        --release)\n+            codegen_channel=release\n+            shift\n+            ;;\n+        --release-sysroot)\n+            sysroot_channel=release\n+            shift\n+            ;;\n+        --no-default-features)\n+            gcc_master_branch=0\n+            flags=\"$flags --no-default-features\"\n+            shift\n+            ;;\n+        --features)\n+            shift\n+            flags=\"$flags --features $1\"\n+            shift\n+            ;;\n+        --release)\n+            channel=\"release\"\n+            shift\n+            ;;\n+        \"--test-rustc\")\n+            func=test_rustc\n+            shift\n+            ;;\n+\n+        \"--test-libcore\")\n+            func=test_libcore\n+            shift\n+            ;;\n+\n+        \"--clean-ui-tests\")\n+            func=clean_ui_tests\n+            shift\n+            ;;\n+\n+        \"--std-tests\")\n+            func=std_tests\n+            shift\n+            ;;\n+\n+        \"--extended-tests\")\n+            func=extended_sysroot_tests\n+            shift\n+            ;;\n+\n+        \"--build-sysroot\")\n+            func=build_sysroot\n+            shift\n+            ;;\n+        \"--build\")\n+            build_only=1\n+            shift\n+            ;;\n+        *)\n+            echo \"Unknown option $1\"\n+            exit 1\n+            ;;\n+    esac\n+done\n+\n+if [[ $channel == \"release\" ]]; then\n     export CHANNEL='release'\n-    CARGO_INCREMENTAL=1 cargo rustc --release $features\n+    CARGO_INCREMENTAL=1 cargo rustc --release $flags\n     shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n-    cargo rustc $features\n+    cargo rustc $flags\n fi\n \n-if [[ \"$1\" == \"--build\" ]]; then\n+if (( $build_only == 1 )); then\n     exit\n fi\n \n@@ -78,7 +140,11 @@ function std_tests() {\n     $RUN_WRAPPER ./target/out/dst_field_align || (echo $?; false)\n \n     echo \"[AOT] std_example\"\n-    $RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE\n+    std_flags=\"--cfg feature=\\\"master\\\"\"\n+    if (( $gcc_master_branch == 0 )); then\n+        std_flags=\"\"\n+    fi\n+    $RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE $std_flags\n     $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n     echo \"[AOT] subslice-patterns-const-eval\"\n@@ -97,25 +163,6 @@ function std_tests() {\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n \n-# TODO(antoyo): uncomment when it works.\n-#pushd simple-raytracer\n-#if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs ${RUN_RUNS:-10} --warmup 1 --prepare \"rm -r target/*/debug || true\" \\\n-    #\"RUSTFLAGS='' cargo build --target $TARGET_TRIPLE\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/*/debug/main ./raytracer_cg_gccjit\n-    #hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_gccjit\n-#else\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n-    #echo \"[COMPILE] ebobby/simple-raytracer\"\n-    #../cargo.sh build\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n-#fi\n-#popd\n-\n function test_libcore() {\n     pushd build_sysroot/sysroot_src/library/core/tests\n     echo \"[TEST] libcore\"\n@@ -124,19 +171,6 @@ function test_libcore() {\n     popd\n }\n \n-# TODO(antoyo): uncomment when it works.\n-#pushd regex\n-#echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n-#../cargo.sh clean\n-## Make sure `[codegen mono items] start` doesn't poison the diff\n-#../cargo.sh build --example shootout-regex-dna\n-#cat examples/regexdna-input.txt | ../cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n-#diff -u res.txt examples/regexdna-output.txt\n-\n-#echo \"[TEST] rust-lang/regex tests\"\n-#../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options\n-#popd\n-\n #echo\n #echo \"[BENCH COMPILE] mod_bench\"\n \n@@ -153,6 +187,44 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n+function extended_sysroot_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n+\n+    pushd rand\n+    cargo clean\n+    echo \"[TEST] rust-random/rand\"\n+    ../cargo.sh test --workspace\n+    popd\n+\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n+\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n+\n+    pushd regex\n+    echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n+    cargo clean\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n+    # Make sure `[codegen mono items] start` doesn't poison the diff\n+    ../cargo.sh build --example shootout-regex-dna\n+    cat examples/regexdna-input.txt \\\n+        | ../cargo.sh run --example shootout-regex-dna \\\n+        | grep -v \"Spawned thread\" > res.txt\n+    diff -u res.txt examples/regexdna-output.txt\n+\n+    echo \"[TEST] rust-lang/regex tests\"\n+    ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n+    popd\n+}\n+\n function test_rustc() {\n     echo\n     echo \"[TEST] rust-lang/rust\"\n@@ -165,23 +237,7 @@ function test_rustc() {\n     git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n     export RUSTFLAGS=\n \n-    git apply - <<EOF\n-diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n-index 887d27fd6dca4..2c2239f2b83d1 100644\n---- a/src/tools/compiletest/src/header.rs\n-+++ b/src/tools/compiletest/src/header.rs\n-@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n-     cfg: Option<&str>,\n- ) -> test::TestDesc {\n-     let mut ignore = false;\n-     #[cfg(not(bootstrap))]\n--    let ignore_message: Option<String> = None;\n-+    let ignore_message: Option<&str> = None;\n-     let mut should_fail = false;\n-\n-     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n-\n-EOF\n+    git apply ../rustc_patches/compile_test.patch || true\n \n     rm config.toml || true\n \n@@ -205,7 +261,7 @@ EOF\n \n     git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+    rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n     for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n       rm $test\n     done\n@@ -222,33 +278,14 @@ function clean_ui_tests() {\n     find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n }\n \n-case $1 in\n-    \"--test-rustc\")\n-        test_rustc\n-        ;;\n-\n-    \"--test-libcore\")\n-        test_libcore\n-        ;;\n-\n-    \"--clean-ui-tests\")\n-        clean_ui_tests\n-        ;;\n-\n-    \"--std-tests\")\n-        std_tests\n-        ;;\n-\n-    \"--build-sysroot\")\n-        build_sysroot\n-        ;;\n-\n-    *)\n-        clean\n-        mini_tests\n-        build_sysroot\n-        std_tests\n-        test_libcore\n-        test_rustc\n-        ;;\n-esac\n+function all() {\n+    clean\n+    mini_tests\n+    build_sysroot\n+    std_tests\n+    test_libcore\n+    extended_sysroot_tests\n+    test_rustc\n+}\n+\n+$func"}, {"sha": "8e378177e24572b1f5f199dd0550a13d72ecc096", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_common.rs", "status": "renamed", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,3 +1,4 @@\n+//! The common code for `tests/lang_tests_*.rs`\n use std::{\n     env::{self, current_dir},\n     path::PathBuf,\n@@ -7,7 +8,15 @@ use std::{\n use lang_tester::LangTester;\n use tempfile::TempDir;\n \n-fn main() {\n+/// Controls the compile options (e.g., optimization level) used to compile\n+/// test code.\n+#[allow(dead_code)] // Each test crate picks one variant\n+pub enum Profile {\n+    Debug,\n+    Release,\n+}\n+\n+pub fn main_inner(profile: Profile) {\n     let tempdir = TempDir::new().expect(\"temp dir\");\n     let current_dir = current_dir().expect(\"current dir\");\n     let current_dir = current_dir.to_str().expect(\"current dir\").to_string();\n@@ -42,6 +51,15 @@ fn main() {\n                 \"-o\", exe.to_str().expect(\"to_str\"),\n                 path.to_str().expect(\"to_str\"),\n             ]);\n+            match profile {\n+                Profile::Debug => {}\n+                Profile::Release => {\n+                    compiler.args(&[\n+                        \"-C\", \"opt-level=3\",\n+                        \"-C\", \"lto=no\",\n+                    ]);\n+                }\n+            }\n             // Test command 2: run `tempdir/x`.\n             let runtime = Command::new(exe);\n             vec![(\"Compiler\", compiler), (\"Run-time\", runtime)]", "previous_filename": "compiler/rustc_codegen_gcc/tests/lib.rs"}, {"sha": "96bd74883ff0ab50c184b51687f929a40358a947", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_debug.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_debug.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1,5 @@\n+mod lang_tests_common;\n+\n+fn main() {\n+    lang_tests_common::main_inner(lang_tests_common::Profile::Debug);\n+}"}, {"sha": "35d5d60c33ee3b10d4ab3dea57bfa83bd01218c8", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_release.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_release.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_release.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_release.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1,5 @@\n+mod lang_tests_common;\n+\n+fn main() {\n+    lang_tests_common::main_inner(lang_tests_common::Profile::Release);\n+}"}, {"sha": "2b90e4ae8d82b9079b571be7d305d8d6f3f9967c", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 319, "deletions": 132, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -3,151 +3,338 @@\n // Run-time:\n //   status: 0\n \n-#![feature(arbitrary_self_types, auto_traits, core_intrinsics, lang_items, start, intrinsics)]\n+#![feature(bench_black_box, const_black_box, core_intrinsics, start)]\n \n #![no_std]\n \n-mod intrinsics {\n-    extern \"rust-intrinsic\" {\n-        pub fn abort() -> !;\n-    }\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    core::intrinsics::abort();\n }\n \n /*\n- * Core\n+ * Code\n  */\n \n-mod libc {\n-    #[link(name = \"c\")]\n-    extern \"C\" {\n-        pub fn puts(s: *const u8) -> i32;\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    use core::hint::black_box;\n+\n+    macro_rules! check {\n+        ($ty:ty, $expr:expr) => {\n+            {\n+                const EXPECTED: $ty = $expr;\n+                assert_eq!($expr, EXPECTED);\n+            }\n+        };\n     }\n-}\n \n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n+    check!(u32, (2220326408_u32 + black_box(1)) >> (32 - 6));\n+\n+    /// Generate `check!` tests for integer types at least as wide as 128 bits.\n+    macro_rules! check_ops128 {\n+        () => {\n+            check_ops64!();\n+\n+            // Shifts.\n+            check!(T, VAL1 << black_box(64));\n+            check!(T, VAL1 << black_box(81));\n+            check!(T, VAL3 << black_box(63));\n+            check!(T, VAL3 << black_box(64));\n+\n+            check!(T, VAL1 >> black_box(64));\n+            check!(T, VAL2 >> black_box(64));\n+            check!(T, VAL3 >> black_box(64));\n+            check!(T, VAL3 >> black_box(81));\n+        };\n     }\n-}\n \n-/*\n- * Code\n- */\n+    /// Generate `check!` tests for integer types at least as wide as 64 bits.\n+    macro_rules! check_ops64 {\n+        () => {\n+            check_ops32!();\n+\n+            // Shifts.\n+            check!(T, VAL2 << black_box(33));\n+            check!(T, VAL2 << black_box(49));\n+            check!(T, VAL2 << black_box(61));\n+            check!(T, VAL2 << black_box(63));\n+\n+            check!(T, VAL3 << black_box(33));\n+            check!(T, VAL3 << black_box(49));\n+            check!(T, VAL3 << black_box(61));\n+\n+            check!(T, VAL1 >> black_box(33));\n+            check!(T, VAL1 >> black_box(49));\n+            check!(T, VAL1 >> black_box(61));\n+            check!(T, VAL1 >> black_box(63));\n+\n+            check!(T, VAL2 >> black_box(33));\n+            check!(T, VAL2 >> black_box(49));\n+            check!(T, VAL2 >> black_box(61));\n+            check!(T, VAL2 >> black_box(63));\n+\n+            check!(T, VAL3 >> black_box(33));\n+            check!(T, VAL3 >> black_box(49));\n+            check!(T, VAL3 >> black_box(61));\n+            check!(T, VAL3 >> black_box(63));\n+        };\n+    }\n \n-#[start]\n-fn main(argc: isize, _argv: *const *const u8) -> isize {\n-    let var = 134217856_u128;\n-    let var2 = 10475372733397991552_u128;\n-    let var3 = 193236519889708027473620326106273939584_u128;\n-    let var4 = 123236519889708027473620326106273939584_u128;\n-    let var5 = 153236519889708027473620326106273939584_u128;\n-    let var6 = 18446744073709551616_i128;\n-    let var7 = 170141183460469231731687303715884105728_u128;\n-\n-    // Shifts.\n-    assert_eq!(var << (argc as u128 - 1), var);\n-    assert_eq!(var << argc as u128, 268435712);\n-    assert_eq!(var << (argc + 32) as u128, 1152922604118474752);\n-    assert_eq!(var << (argc + 48) as u128, 75557935783508361347072);\n-    assert_eq!(var << (argc + 60) as u128, 309485304969250248077606912);\n-    assert_eq!(var << (argc + 62) as u128, 1237941219877000992310427648);\n-    assert_eq!(var << (argc + 63) as u128, 2475882439754001984620855296);\n-    assert_eq!(var << (argc + 80) as u128, 324518863143436548128224745357312);\n-\n-    assert_eq!(var2 << argc as u128, 20950745466795983104);\n-    assert_eq!(var2 << (argc as u128 - 1), var2);\n-    assert_eq!(var2 << (argc + 32) as u128, 89982766606709001335848566784);\n-    assert_eq!(var2 << (argc + 48) as u128, 5897110592337281111546171672756224);\n-    assert_eq!(var2 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n-    assert_eq!(var2 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n-    assert_eq!(var2 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n-\n-    assert_eq!(var3 << argc as u128, 46190672858477591483866044780779667712);\n-    assert_eq!(var3 << (argc as u128 - 1), var3);\n-    assert_eq!(var3 << (argc + 32) as u128, 21267668304951024224840338247585366016);\n-    assert_eq!(var3 << (argc + 48) as u128, 1335125106377253154015353231953100800);\n-    assert_eq!(var3 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n-    assert_eq!(var3 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n-    assert_eq!(var3 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n-\n-    assert_eq!((2220326408_u32 + argc as u32) >> (32 - 6), 33);\n-\n-    assert_eq!(var >> (argc as u128 - 1), var);\n-    assert_eq!(var >> argc as u128, 67108928);\n-    assert_eq!(var >> (argc + 32) as u128, 0);\n-    assert_eq!(var >> (argc + 48) as u128, 0);\n-    assert_eq!(var >> (argc + 60) as u128, 0);\n-    assert_eq!(var >> (argc + 62) as u128, 0);\n-    assert_eq!(var >> (argc + 63) as u128, 0);\n-\n-    assert_eq!(var2 >> argc as u128, 5237686366698995776);\n-    assert_eq!(var2 >> (argc as u128 - 1), var2);\n-    assert_eq!(var2 >> (argc + 32) as u128, 1219493888);\n-    assert_eq!(var2 >> (argc + 48) as u128, 18608);\n-    assert_eq!(var2 >> (argc + 60) as u128, 4);\n-    assert_eq!(var2 >> (argc + 62) as u128, 1);\n-    assert_eq!(var2 >> (argc + 63) as u128, 0);\n-\n-    assert_eq!(var3 >> (argc as u128 - 1), var3);\n-    assert_eq!(var3 >> argc as u128, 96618259944854013736810163053136969792);\n-    assert_eq!(var3 >> (argc + 32) as u128, 22495691651677250335181635584);\n-    assert_eq!(var3 >> (argc + 48) as u128, 343257013727985387194544);\n-    assert_eq!(var3 >> (argc + 60) as u128, 83802981867183932420);\n-    assert_eq!(var3 >> (argc + 62) as u128, 20950745466795983105);\n-    assert_eq!(var3 >> (argc + 63) as u128, 10475372733397991552);\n-    assert_eq!(var3 >> (argc + 80) as u128, 79920751444992);\n-\n-    assert_eq!(var6 >> argc as u128, 9223372036854775808);\n-    assert_eq!((var6 - 1) >> argc as u128, 9223372036854775807);\n-    assert_eq!(var7 >> argc as u128, 85070591730234615865843651857942052864);\n-\n-    // Casts\n-    assert_eq!((var >> (argc + 32) as u128) as u64, 0);\n-    assert_eq!((var >> argc as u128) as u64, 67108928);\n-\n-    // Addition.\n-    assert_eq!(var + argc as u128, 134217857);\n-\n-    assert_eq!(var2 + argc as u128, 10475372733397991553);\n-    assert_eq!(var2 + (var2 + argc as u128) as u128, 20950745466795983105);\n-\n-    assert_eq!(var3 + argc as u128, 193236519889708027473620326106273939585);\n-\n-    // Subtraction\n-    assert_eq!(var - argc as u128, 134217855);\n-\n-    assert_eq!(var2 - argc as u128, 10475372733397991551);\n-\n-    assert_eq!(var3 - argc as u128, 193236519889708027473620326106273939583);\n-\n-    // Multiplication\n-    assert_eq!(var * (argc + 1) as u128, 268435712);\n-    assert_eq!(var * (argc as u128 + var2), 1405982069077538020949770368);\n-\n-    assert_eq!(var2 * (argc + 1) as u128, 20950745466795983104);\n-    assert_eq!(var2 * (argc as u128 + var2), 109733433903618109003204073240861360256);\n-\n-    assert_eq!(var3 * argc as u128, 193236519889708027473620326106273939584);\n-\n-    assert_eq!(var4 * (argc + 1) as u128, 246473039779416054947240652212547879168);\n-\n-    assert_eq!(var5 * (argc + 1) as u128, 306473039779416054947240652212547879168);\n-\n-    // Division.\n-    assert_eq!(var / (argc + 1) as u128, 67108928);\n-    assert_eq!(var / (argc + 2) as u128, 44739285);\n-\n-    assert_eq!(var2 / (argc + 1) as u128, 5237686366698995776);\n-    assert_eq!(var2 / (argc + 2) as u128, 3491790911132663850);\n-\n-    assert_eq!(var3 / (argc + 1) as u128, 96618259944854013736810163053136969792);\n-    assert_eq!(var3 / (argc + 2) as u128, 64412173296569342491206775368757979861);\n-    assert_eq!(var3 / (argc as u128 + var4), 1);\n-    assert_eq!(var3 / (argc as u128 + var2), 18446744073709551615);\n-\n-    assert_eq!(var4 / (argc + 1) as u128, 61618259944854013736810163053136969792);\n-    assert_eq!(var4 / (argc + 2) as u128, 41078839963236009157873442035424646528);\n+    /// Generate `check!` tests for integer types at least as wide as 32 bits.\n+    macro_rules! check_ops32 {\n+        () => {\n+            // Shifts.\n+            check!(T, VAL2 << black_box(1));\n+            check!(T, VAL2 << black_box(0));\n+\n+            check!(T, VAL3 << black_box(1));\n+            check!(T, VAL3 << black_box(0));\n+\n+            check!(T, VAL1.wrapping_shl(black_box(0)));\n+            check!(T, VAL1.wrapping_shl(black_box(1)));\n+            check!(T, VAL1.wrapping_shl(black_box(33)));\n+            check!(T, VAL1.wrapping_shl(black_box(49)));\n+            check!(T, VAL1.wrapping_shl(black_box(61)));\n+            check!(T, VAL1.wrapping_shl(black_box(63)));\n+            check!(T, VAL1.wrapping_shl(black_box(64)));\n+            check!(T, VAL1.wrapping_shl(black_box(81)));\n+\n+            check!(Option<T>, VAL1.checked_shl(black_box(0)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(1)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(33)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(49)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(61)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(63)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(64)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(81)));\n+\n+            check!(T, VAL1 >> black_box(0));\n+            check!(T, VAL1 >> black_box(1));\n+\n+            check!(T, VAL2 >> black_box(1));\n+            check!(T, VAL2 >> black_box(0));\n+\n+            check!(T, VAL3 >> black_box(0));\n+            check!(T, VAL3 >> black_box(1));\n+\n+            check!(T, VAL1.wrapping_shr(black_box(0)));\n+            check!(T, VAL1.wrapping_shr(black_box(1)));\n+            check!(T, VAL1.wrapping_shr(black_box(33)));\n+            check!(T, VAL1.wrapping_shr(black_box(49)));\n+            check!(T, VAL1.wrapping_shr(black_box(61)));\n+            check!(T, VAL1.wrapping_shr(black_box(63)));\n+            check!(T, VAL1.wrapping_shr(black_box(64)));\n+            check!(T, VAL1.wrapping_shr(black_box(81)));\n+\n+            check!(Option<T>, VAL1.checked_shr(black_box(0)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(1)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(33)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(49)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(61)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(63)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(64)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(81)));\n+\n+            // Casts\n+            check!(u64, (VAL1 >> black_box(1)) as u64);\n+\n+            // Addition.\n+            check!(T, VAL1 + black_box(1));\n+            check!(T, VAL2 + black_box(1));\n+            check!(T, VAL2 + (VAL2 + black_box(1)));\n+            check!(T, VAL3 + black_box(1));\n+\n+            check!(Option<T>, VAL1.checked_add(black_box(1)));\n+            check!(Option<T>, VAL2.checked_add(black_box(1)));\n+            check!(Option<T>, VAL2.checked_add(VAL2 + black_box(1)));\n+            check!(Option<T>, VAL3.checked_add(T::MAX));\n+            check!(Option<T>, VAL3.checked_add(T::MIN));\n+\n+            check!(T, VAL1.wrapping_add(black_box(1)));\n+            check!(T, VAL2.wrapping_add(black_box(1)));\n+            check!(T, VAL2.wrapping_add(VAL2 + black_box(1)));\n+            check!(T, VAL3.wrapping_add(T::MAX));\n+            check!(T, VAL3.wrapping_add(T::MIN));\n+\n+            check!((T, bool), VAL1.overflowing_add(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_add(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_add(VAL2 + black_box(1)));\n+            check!((T, bool), VAL3.overflowing_add(T::MAX));\n+            check!((T, bool), VAL3.overflowing_add(T::MIN));\n+\n+            check!(T, VAL1.saturating_add(black_box(1)));\n+            check!(T, VAL2.saturating_add(black_box(1)));\n+            check!(T, VAL2.saturating_add(VAL2 + black_box(1)));\n+            check!(T, VAL3.saturating_add(T::MAX));\n+            check!(T, VAL3.saturating_add(T::MIN));\n+\n+            // Subtraction\n+            check!(T, VAL1 - black_box(1));\n+            check!(T, VAL2 - black_box(1));\n+            check!(T, VAL3 - black_box(1));\n+\n+            check!(Option<T>, VAL1.checked_sub(black_box(1)));\n+            check!(Option<T>, VAL2.checked_sub(black_box(1)));\n+            check!(Option<T>, VAL2.checked_sub(VAL2 + black_box(1)));\n+            check!(Option<T>, VAL3.checked_sub(T::MAX));\n+            check!(Option<T>, VAL3.checked_sub(T::MIN));\n+\n+            check!(T, VAL1.wrapping_sub(black_box(1)));\n+            check!(T, VAL2.wrapping_sub(black_box(1)));\n+            check!(T, VAL2.wrapping_sub(VAL2 + black_box(1)));\n+            check!(T, VAL3.wrapping_sub(T::MAX));\n+            check!(T, VAL3.wrapping_sub(T::MIN));\n+\n+            check!((T, bool), VAL1.overflowing_sub(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_sub(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_sub(VAL2 + black_box(1)));\n+            check!((T, bool), VAL3.overflowing_sub(T::MAX));\n+            check!((T, bool), VAL3.overflowing_sub(T::MIN));\n+\n+            check!(T, VAL1.saturating_sub(black_box(1)));\n+            check!(T, VAL2.saturating_sub(black_box(1)));\n+            check!(T, VAL2.saturating_sub(VAL2 + black_box(1)));\n+            check!(T, VAL3.saturating_sub(T::MAX));\n+            check!(T, VAL3.saturating_sub(T::MIN));\n+\n+            // Multiplication\n+            check!(T, VAL1 * black_box(2));\n+            check!(T, VAL1 * (black_box(1) + VAL2));\n+            check!(T, VAL2 * black_box(2));\n+            check!(T, VAL2 * (black_box(1) + VAL2));\n+            check!(T, VAL3 * black_box(1));\n+            check!(T, VAL4 * black_box(2));\n+            check!(T, VAL5 * black_box(2));\n+\n+            check!(Option<T>, VAL1.checked_mul(black_box(2)));\n+            check!(Option<T>, VAL1.checked_mul(black_box(1) + VAL2));\n+            check!(Option<T>, VAL3.checked_mul(VAL3));\n+            check!(Option<T>, VAL4.checked_mul(black_box(2)));\n+            check!(Option<T>, VAL5.checked_mul(black_box(2)));\n+\n+            check!(T, VAL1.wrapping_mul(black_box(2)));\n+            check!(T, VAL1.wrapping_mul((black_box(1) + VAL2)));\n+            check!(T, VAL3.wrapping_mul(VAL3));\n+            check!(T, VAL4.wrapping_mul(black_box(2)));\n+            check!(T, VAL5.wrapping_mul(black_box(2)));\n+\n+            check!((T, bool), VAL1.overflowing_mul(black_box(2)));\n+            check!((T, bool), VAL1.overflowing_mul(black_box(1) + VAL2));\n+            check!((T, bool), VAL3.overflowing_mul(VAL3));\n+            check!((T, bool), VAL4.overflowing_mul(black_box(2)));\n+            check!((T, bool), VAL5.overflowing_mul(black_box(2)));\n+\n+            check!(T, VAL1.saturating_mul(black_box(2)));\n+            check!(T, VAL1.saturating_mul(black_box(1) + VAL2));\n+            check!(T, VAL3.saturating_mul(VAL3));\n+            check!(T, VAL4.saturating_mul(black_box(2)));\n+            check!(T, VAL5.saturating_mul(black_box(2)));\n+\n+            // Division.\n+            check!(T, VAL1 / black_box(2));\n+            check!(T, VAL1 / black_box(3));\n+\n+            check!(T, VAL2 / black_box(2));\n+            check!(T, VAL2 / black_box(3));\n+\n+            check!(T, VAL3 / black_box(2));\n+            check!(T, VAL3 / black_box(3));\n+            check!(T, VAL3 / (black_box(1) + VAL4));\n+            check!(T, VAL3 / (black_box(1) + VAL2));\n+\n+            check!(T, VAL4 / black_box(2));\n+            check!(T, VAL4 / black_box(3));\n+\n+            check!(Option<T>, VAL1.checked_div(black_box(2)));\n+            check!(Option<T>, VAL1.checked_div(black_box(1) + VAL2));\n+            check!(Option<T>, VAL3.checked_div(VAL3));\n+            check!(Option<T>, VAL4.checked_div(black_box(2)));\n+            check!(Option<T>, VAL5.checked_div(black_box(2)));\n+            check!(Option<T>, (T::MIN).checked_div(black_box(0 as T).wrapping_sub(1)));\n+            check!(Option<T>, VAL5.checked_div(black_box(0))); // var5 / 0\n+\n+            check!(T, VAL1.wrapping_div(black_box(2)));\n+            check!(T, VAL1.wrapping_div(black_box(1) + VAL2));\n+            check!(T, VAL3.wrapping_div(VAL3));\n+            check!(T, VAL4.wrapping_div(black_box(2)));\n+            check!(T, VAL5.wrapping_div(black_box(2)));\n+            check!(T, (T::MIN).wrapping_div(black_box(0 as T).wrapping_sub(1)));\n+\n+            check!((T, bool), VAL1.overflowing_div(black_box(2)));\n+            check!((T, bool), VAL1.overflowing_div(black_box(1) + VAL2));\n+            check!((T, bool), VAL3.overflowing_div(VAL3));\n+            check!((T, bool), VAL4.overflowing_div(black_box(2)));\n+            check!((T, bool), VAL5.overflowing_div(black_box(2)));\n+            check!((T, bool), (T::MIN).overflowing_div(black_box(0 as T).wrapping_sub(1)));\n+\n+            check!(T, VAL1.saturating_div(black_box(2)));\n+            check!(T, VAL1.saturating_div((black_box(1) + VAL2)));\n+            check!(T, VAL3.saturating_div(VAL3));\n+            check!(T, VAL4.saturating_div(black_box(2)));\n+            check!(T, VAL5.saturating_div(black_box(2)));\n+            check!(T, (T::MIN).saturating_div((0 as T).wrapping_sub(black_box(1))));\n+        };\n+    }\n+\n+    {\n+        type T = u32;\n+        const VAL1: T = 14162_u32;\n+        const VAL2: T = 14556_u32;\n+        const VAL3: T = 323656954_u32;\n+        const VAL4: T = 2023651954_u32;\n+        const VAL5: T = 1323651954_u32;\n+        check_ops32!();\n+    }\n+\n+    {\n+        type T = i32;\n+        const VAL1: T = 13456_i32;\n+        const VAL2: T = 10475_i32;\n+        const VAL3: T = 923653954_i32;\n+        const VAL4: T = 993198738_i32;\n+        const VAL5: T = 1023653954_i32;\n+        check_ops32!();\n+    }\n+\n+    {\n+        type T = u64;\n+        const VAL1: T = 134217856_u64;\n+        const VAL2: T = 104753732_u64;\n+        const VAL3: T = 12323651988970863954_u64;\n+        const VAL4: T = 7323651988970863954_u64;\n+        const VAL5: T = 8323651988970863954_u64;\n+        check_ops64!();\n+    }\n+\n+    {\n+        type T = i64;\n+        const VAL1: T = 134217856_i64;\n+        const VAL2: T = 104753732_i64;\n+        const VAL3: T = 6323651988970863954_i64;\n+        const VAL4: T = 2323651988970863954_i64;\n+        const VAL5: T = 3323651988970863954_i64;\n+        check_ops64!();\n+    }\n+\n+    {\n+        type T = u128;\n+        const VAL1: T = 134217856_u128;\n+        const VAL2: T = 10475372733397991552_u128;\n+        const VAL3: T = 193236519889708027473620326106273939584_u128;\n+        const VAL4: T = 123236519889708027473620326106273939584_u128;\n+        const VAL5: T = 153236519889708027473620326106273939584_u128;\n+        check_ops128!();\n+    }\n+    {\n+        type T = i128;\n+        const VAL1: T = 134217856_i128;\n+        const VAL2: T = 10475372733397991552_i128;\n+        const VAL3: T = 83236519889708027473620326106273939584_i128;\n+        const VAL4: T = 63236519889708027473620326106273939584_i128;\n+        const VAL5: T = 73236519889708027473620326106273939584_i128;\n+        check_ops128!();\n+    }\n \n     0\n }"}, {"sha": "ea2c5add962ae3d871cc0a1a298d9e7b8f54da98", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -1,7 +1,7 @@\n // Compiler:\n //\n // Run-time:\n-//   stdout: Panicking\n+//   stdout: Success\n //   status: signal\n \n #![allow(unused_attributes)]\n@@ -64,7 +64,9 @@ mod intrinsics {\n #[no_mangle]\n pub fn panic(_msg: &str) -> ! {\n     unsafe {\n-        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        // Panicking is expected iff overflow checking is enabled.\n+        #[cfg(debug_assertions)]\n+        libc::puts(\"Success\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);\n         intrinsics::abort();\n     }\n@@ -124,6 +126,15 @@ impl Add for isize {\n #[start]\n fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n     let int = 9223372036854775807isize;\n-    let int = int + argc;\n+    let int = int + argc;  // overflow\n+\n+    // If overflow checking is disabled, we should reach here.\n+    #[cfg(not(debug_assertions))]\n+    unsafe {\n+        libc::puts(\"Success\\0\" as *const str as *const u8);\n+        libc::fflush(libc::stdout);\n+        intrinsics::abort();\n+    }\n+\n     int\n }"}, {"sha": "849c6e9c98164adf72f254c684f2216234ccceb2", "filename": "compiler/rustc_codegen_gcc/tools/generate_intrinsics.py", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fac982e07a859ffedba37865bcc6c508e47893b/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py?ref=3fac982e07a859ffedba37865bcc6c508e47893b", "patch": "@@ -0,0 +1,238 @@\n+import json\n+import os\n+import re\n+import sys\n+import subprocess\n+from os import walk\n+\n+\n+def run_command(command, cwd=None):\n+    p = subprocess.Popen(command, cwd=cwd)\n+    if p.wait() != 0:\n+        print(\"command `{}` failed...\".format(\" \".join(command)))\n+        sys.exit(1)\n+\n+\n+def clone_repository(repo_name, path, repo_url, sub_path=None):\n+    if os.path.exists(path):\n+        while True:\n+            choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(path))\n+            if choice == \"\" or choice.lower() == \"n\":\n+                print(\"Skipping repository update.\")\n+                return\n+            elif choice.lower() == \"y\":\n+                print(\"Updating repository...\")\n+                run_command([\"git\", \"pull\", \"origin\"], cwd=path)\n+                return\n+            else:\n+                print(\"Didn't understand answer...\")\n+    print(\"Cloning {} repository...\".format(repo_name))\n+    if sub_path is None:\n+        run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n+    else:\n+        run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n+        run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"checkout\"], cwd=path)\n+\n+\n+def append_intrinsic(array, intrinsic_name, translation):\n+    array.append((intrinsic_name, translation))\n+\n+\n+def extract_instrinsics(intrinsics, file):\n+    print(\"Extracting intrinsics from `{}`...\".format(file))\n+    with open(file, \"r\", encoding=\"utf8\") as f:\n+        content = f.read()\n+\n+    lines = content.splitlines()\n+    pos = 0\n+    current_arch = None\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        if line.startswith(\"let TargetPrefix =\"):\n+            current_arch = line.split('\"')[1].strip()\n+            if len(current_arch) == 0:\n+                current_arch = None\n+        elif current_arch is None:\n+            pass\n+        elif line == \"}\":\n+            current_arch = None\n+        elif line.startswith(\"def \"):\n+            content = \"\"\n+            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n+                line = lines[pos].split(\" // \")[0].strip()\n+                content += line\n+                pos += 1\n+            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n+            if len(entries) > 0:\n+                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n+                intrinsic = intrinsic.split(\"_\")\n+                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                    continue\n+                intrinsic[0] = \"llvm\"\n+                intrinsic = \".\".join(intrinsic)\n+                if current_arch not in intrinsics:\n+                    intrinsics[current_arch] = []\n+                for entry in entries:\n+                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+            continue\n+        pos += 1\n+        continue\n+    print(\"Done!\")\n+\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    files = []\n+    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n+    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n+        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n+\n+    for file in files:\n+        extract_instrinsics(intrinsics, file)\n+\n+\n+def append_translation(json_data, p, array):\n+    it = json_data[\"index\"][p]\n+    content = it[\"docs\"].split('`')\n+    if len(content) != 5:\n+        return\n+    append_intrinsic(array, content[1], content[3])\n+\n+\n+def extract_instrinsics_from_llvmint(llvmint, intrinsics):\n+    archs = [\n+        \"AMDGPU\",\n+        \"aarch64\",\n+        \"arm\",\n+        \"cuda\",\n+        \"hexagon\",\n+        \"mips\",\n+        \"nvvm\",\n+        \"ppc\",\n+        \"ptx\",\n+        \"x86\",\n+        \"xcore\",\n+    ]\n+\n+    json_file = os.path.join(llvmint, \"target/doc/llvmint.json\")\n+    # We need to regenerate the documentation!\n+    run_command(\n+        [\"cargo\", \"rustdoc\", \"--\", \"-Zunstable-options\", \"--output-format\", \"json\"],\n+        cwd=llvmint,\n+    )\n+    with open(json_file, \"r\", encoding=\"utf8\") as f:\n+        json_data = json.loads(f.read())\n+    for p in json_data[\"paths\"]:\n+        it = json_data[\"paths\"][p]\n+        if it[\"crate_id\"] != 0:\n+            # This is from an external crate.\n+            continue\n+        if it[\"kind\"] != \"function\":\n+            # We're only looking for functions.\n+            continue\n+        # if len(it[\"path\"]) == 2:\n+        #   # This is a \"general\" intrinsic, not bound to a specific arch.\n+        #   append_translation(json_data, p, general)\n+        #   continue\n+        if len(it[\"path\"]) != 3 or it[\"path\"][1] not in archs:\n+            continue\n+        arch = it[\"path\"][1]\n+        if arch not in intrinsics:\n+            intrinsics[arch] = []\n+        append_translation(json_data, p, intrinsics[arch])\n+\n+\n+def fill_intrinsics(intrinsics, from_intrinsics, all_intrinsics):\n+    for arch in from_intrinsics:\n+        if arch not in intrinsics:\n+            intrinsics[arch] = []\n+        for entry in from_intrinsics[arch]:\n+            if entry[0] in all_intrinsics:\n+                if all_intrinsics[entry[0]] == entry[1]:\n+                    # This is a \"full\" duplicate, both the LLVM instruction and the GCC\n+                    # translation are the same.\n+                    continue\n+                intrinsics[arch].append((entry[0], entry[1], True))\n+            else:\n+                intrinsics[arch].append((entry[0], entry[1], False))\n+                all_intrinsics[entry[0]] = entry[1]\n+\n+\n+def update_intrinsics(llvm_path, llvmint, llvmint2):\n+    intrinsics_llvm = {}\n+    intrinsics_llvmint = {}\n+    all_intrinsics = {}\n+\n+    extract_instrinsics_from_llvm(llvm_path, intrinsics_llvm)\n+    extract_instrinsics_from_llvmint(llvmint, intrinsics_llvmint)\n+    extract_instrinsics_from_llvmint(llvmint2, intrinsics_llvmint)\n+\n+    intrinsics = {}\n+    # We give priority to translations from LLVM over the ones from llvmint.\n+    fill_intrinsics(intrinsics, intrinsics_llvm, all_intrinsics)\n+    fill_intrinsics(intrinsics, intrinsics_llvmint, all_intrinsics)\n+\n+    archs = [arch for arch in intrinsics]\n+    archs.sort()\n+\n+    output_file = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"../src/intrinsic/archs.rs\",\n+    )\n+    print(\"Updating content of `{}`...\".format(output_file))\n+    with open(output_file, \"w\", encoding=\"utf8\") as out:\n+        out.write(\"// File generated by `rustc_codegen_gcc/tools/generate_intrinsics.py`\\n\")\n+        out.write(\"// DO NOT EDIT IT!\\n\")\n+        out.write(\"match name {\\n\")\n+        for arch in archs:\n+            if len(intrinsics[arch]) == 0:\n+                continue\n+            intrinsics[arch].sort(key=lambda x: (x[0], x[2]))\n+            out.write('    // {}\\n'.format(arch))\n+            for entry in intrinsics[arch]:\n+                if entry[2] == True: # if it is a duplicate\n+                    out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                else:\n+                    out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+        out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n+        out.write(\"}\\n\")\n+    print(\"Done!\")\n+\n+\n+def main():\n+    llvm_path = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"llvm-project\",\n+    )\n+    llvmint_path = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"llvmint\",\n+    )\n+    llvmint2_path = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"llvmint-2\",\n+    )\n+\n+    # First, we clone the LLVM repository if it's not already here.\n+    clone_repository(\n+        \"llvm-project\",\n+        llvm_path,\n+        \"https://github.com/llvm/llvm-project\",\n+        sub_path=\"llvm/include/llvm/IR\",\n+    )\n+    clone_repository(\n+        \"llvmint\",\n+        llvmint_path,\n+        \"https://github.com/GuillaumeGomez/llvmint\",\n+    )\n+    clone_repository(\n+        \"llvmint2\",\n+        llvmint2_path,\n+        \"https://github.com/antoyo/llvmint\",\n+    )\n+    update_intrinsics(llvm_path, llvmint_path, llvmint2_path)\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())"}]}