{"sha": "a70f9d7324a91058d31c1301c4351932880d57e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3MGY5ZDczMjRhOTEwNThkMzFjMTMwMWM0MzUxOTMyODgwZDU3ZTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-26T17:40:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-29T20:19:16Z"}, "message": "Implement a lock-free work-stealing deque\n\nThis adds an implementation of the Chase-Lev work-stealing deque to libstd\nunder std::rt::deque. I've been unable to break the implementation of the deque\nitself, and it's not super highly optimized just yet (everything uses a SeqCst\nmemory ordering).\n\nThe major snag in implementing the chase-lev deque is that the buffers used to\nstore data internally cannot get deallocated back to the OS. In the meantime, a\nshared buffer pool (synchronized by a normal mutex) is used to\ndeallocate/allocate buffers from. This is done in hope of not overcommitting too\nmuch memory. It is in theory possible to eventually free the buffers, but one\nmust be very careful in doing so.\n\nI was unable to get some good numbers from src/test/bench tests (I don't think\nmany of them are slamming the work queue that much), but I was able to get some\ngood numbers from one of my own tests. In a recent rewrite of select::select(),\nI found that my implementation was incredibly slow due to contention on the\nshared work queue. Upon switching to the parallel deque, I saw the contention\ndrop to 0 and the runtime go from 1.6s to 0.9s with the most amount of time\nspent in libuv awakening the schedulers (plus allocations).\n\nCloses #4877", "tree": {"sha": "b58152ff5a47212c386e6fcfa954175345ec5ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b58152ff5a47212c386e6fcfa954175345ec5ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a70f9d7324a91058d31c1301c4351932880d57e8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a70f9d7324a91058d31c1301c4351932880d57e8", "html_url": "https://github.com/rust-lang/rust/commit/a70f9d7324a91058d31c1301c4351932880d57e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a70f9d7324a91058d31c1301c4351932880d57e8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08f4d1ff9f2cc0092b307e1f438fb911bbf55185", "url": "https://api.github.com/repos/rust-lang/rust/commits/08f4d1ff9f2cc0092b307e1f438fb911bbf55185", "html_url": "https://github.com/rust-lang/rust/commit/08f4d1ff9f2cc0092b307e1f438fb911bbf55185"}], "stats": {"total": 864, "additions": 723, "deletions": 141}, "files": [{"sha": "a7feb6db9236df62edacb7d1c974fe139e81dee5", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -1076,21 +1076,22 @@ mod test {\n         use std::rt::task::Task;\n         use std::rt::task::UnwindResult;\n         use std::rt::thread::Thread;\n-        use std::rt::work_queue::WorkQueue;\n+        use std::rt::deque::BufferPool;\n         use std::unstable::run_in_bare_thread;\n         use uvio::UvEventLoop;\n \n         do run_in_bare_thread {\n             let sleepers = SleeperList::new();\n-            let work_queue1 = WorkQueue::new();\n-            let work_queue2 = WorkQueue::new();\n-            let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+            let mut pool = BufferPool::init();\n+            let (worker1, stealer1) = pool.deque();\n+            let (worker2, stealer2) = pool.deque();\n+            let queues = ~[stealer1, stealer2];\n \n             let loop1 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n+            let mut sched1 = ~Scheduler::new(loop1, worker1, queues.clone(),\n                                              sleepers.clone());\n             let loop2 = ~UvEventLoop::new() as ~EventLoop;\n-            let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n+            let mut sched2 = ~Scheduler::new(loop2, worker2, queues.clone(),\n                                              sleepers.clone());\n \n             let handle1 = Cell::new(sched1.make_handle());"}, {"sha": "94d4523b2e21c42dc1c299bd7eec1e1ff795bb9b", "filename": "src/libstd/rt/deque.rs", "status": "added", "additions": 658, "deletions": 0, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fdeque.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -0,0 +1,658 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A (mostly) lock-free concurrent work-stealing deque\n+//!\n+//! This module contains an implementation of the Chase-Lev work stealing deque\n+//! described in \"Dynamic Circular Work-Stealing Deque\". The implementation is\n+//! heavily based on the pseudocode found in the paper.\n+//!\n+//! This implementation does not want to have the restriction of a garbage\n+//! collector for reclamation of buffers, and instead it uses a shared pool of\n+//! buffers. This shared pool is required for correctness in this\n+//! implementation.\n+//!\n+//! The only lock-synchronized portions of this deque are the buffer allocation\n+//! and deallocation portions. Otherwise all operations are lock-free.\n+//!\n+//! # Example\n+//!\n+//!     use std::rt::deque::BufferPool;\n+//!\n+//!     let mut pool = BufferPool::init();\n+//!     let (mut worker, mut stealer) = pool.deque();\n+//!\n+//!     // Only the worker may push/pop\n+//!     worker.push(1);\n+//!     worker.pop();\n+//!\n+//!     // Stealers take data from the other end of the deque\n+//!     worker.push(1);\n+//!     stealer.steal();\n+//!\n+//!     // Stealers can be cloned to have many stealers stealing in parallel\n+//!     worker.push(1);\n+//!     let mut stealer2 = stealer.clone();\n+//!     stealer2.steal();\n+\n+// NB: the \"buffer pool\" strategy is not done for speed, but rather for\n+//     correctness. For more info, see the comment on `swap_buffer`\n+\n+// XXX: all atomic operations in this module use a SeqCst ordering. That is\n+//      probably overkill\n+\n+use cast;\n+use clone::Clone;\n+use iter::range;\n+use kinds::Send;\n+use libc;\n+use mem;\n+use ops::Drop;\n+use option::{Option, Some, None};\n+use ptr;\n+use unstable::atomics::{AtomicInt, AtomicPtr, SeqCst};\n+use unstable::sync::{UnsafeArc, Exclusive};\n+\n+// Once the queue is less than 1/K full, then it will be downsized. Note that\n+// the deque requires that this number be less than 2.\n+static K: int = 4;\n+\n+// Minimum number of bits that a buffer size should be. No buffer will resize to\n+// under this value, and all deques will initially contain a buffer of this\n+// size.\n+//\n+// The size in question is 1 << MIN_BITS\n+static MIN_BITS: int = 7;\n+\n+struct Deque<T> {\n+    bottom: AtomicInt,\n+    top: AtomicInt,\n+    array: AtomicPtr<Buffer<T>>,\n+    pool: BufferPool<T>,\n+}\n+\n+/// Worker half of the work-stealing deque. This worker has exclusive access to\n+/// one side of the deque, and uses `push` and `pop` method to manipulate it.\n+///\n+/// There may only be one worker per deque.\n+pub struct Worker<T> {\n+    priv deque: UnsafeArc<Deque<T>>,\n+}\n+\n+/// The stealing half of the work-stealing deque. Stealers have access to the\n+/// opposite end of the deque from the worker, and they only have access to the\n+/// `steal` method.\n+pub struct Stealer<T> {\n+    priv deque: UnsafeArc<Deque<T>>,\n+}\n+\n+/// When stealing some data, this is an enumeration of the possible outcomes.\n+#[deriving(Eq)]\n+pub enum Stolen<T> {\n+    /// The deque was empty at the time of stealing\n+    Empty,\n+    /// The stealer lost the race for stealing data, and a retry may return more\n+    /// data.\n+    Abort,\n+    /// The stealer has successfully stolen some data.\n+    Data(T),\n+}\n+\n+/// The allocation pool for buffers used by work-stealing deques. Right now this\n+/// structure is used for reclamation of memory after it is no longer in use by\n+/// deques.\n+///\n+/// This data structure is protected by a mutex, but it is rarely used. Deques\n+/// will only use this structure when allocating a new buffer or deallocating a\n+/// previous one.\n+pub struct BufferPool<T> {\n+    priv pool: Exclusive<~[~Buffer<T>]>,\n+}\n+\n+/// An internal buffer used by the chase-lev deque. This structure is actually\n+/// implemented as a circular buffer, and is used as the intermediate storage of\n+/// the data in the deque.\n+///\n+/// This type is implemented with *T instead of ~[T] for two reasons:\n+///\n+///   1. There is nothing safe about using this buffer. This easily allows the\n+///      same value to be read twice in to rust, and there is nothing to\n+///      prevent this. The usage by the deque must ensure that one of the\n+///      values is forgotten. Furthermore, we only ever want to manually run\n+///      destructors for values in this buffer (on drop) because the bounds\n+///      are defined by the deque it's owned by.\n+///\n+///   2. We can certainly avoid bounds checks using *T instead of ~[T], although\n+///      LLVM is probably pretty good at doing this already.\n+struct Buffer<T> {\n+    storage: *T,\n+    log_size: int,\n+}\n+\n+impl<T: Send> BufferPool<T> {\n+    /// Allocates a new buffer pool which in turn can be used to allocate new\n+    /// deques.\n+    pub fn init() -> BufferPool<T> {\n+        BufferPool { pool: Exclusive::new(~[]) }\n+    }\n+\n+    /// Allocates a new work-stealing deque which will send/receiving memory to\n+    /// and from this buffer pool.\n+    pub fn deque(&mut self) -> (Worker<T>, Stealer<T>) {\n+        let (a, b) = UnsafeArc::new2(Deque::init(self.clone()));\n+        (Worker { deque: a }, Stealer { deque: b })\n+    }\n+\n+    fn alloc(&mut self, bits: int) -> ~Buffer<T> {\n+        unsafe {\n+            self.pool.with(|pool| {\n+                match pool.iter().position(|x| x.size() >= (1 << bits)) {\n+                    Some(i) => pool.remove(i),\n+                    None => ~Buffer::init(bits)\n+                }\n+            })\n+        }\n+    }\n+\n+    fn free(&mut self, buf: ~Buffer<T>) {\n+        unsafe {\n+            use cell::Cell;\n+            let buf = Cell::new(buf);\n+            self.pool.with(|pool| {\n+                let buf = buf.take();\n+                match pool.iter().position(|v| v.size() > buf.size()) {\n+                    Some(i) => pool.insert(i, buf),\n+                    None => pool.push(buf),\n+                }\n+            })\n+        }\n+    }\n+}\n+\n+impl<T: Send> Clone for BufferPool<T> {\n+    fn clone(&self) -> BufferPool<T> { BufferPool { pool: self.pool.clone() } }\n+}\n+\n+impl<T: Send> Worker<T> {\n+    /// Pushes data onto the front of this work queue.\n+    pub fn push(&mut self, t: T) {\n+        unsafe { (*self.deque.get()).push(t) }\n+    }\n+    /// Pops data off the front of the work queue, returning `None` on an empty\n+    /// queue.\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe { (*self.deque.get()).pop() }\n+    }\n+\n+    /// Gets access to the buffer pool that this worker is attached to. This can\n+    /// be used to create more deques which share the same buffer pool as this\n+    /// deque.\n+    pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> {\n+        unsafe { &mut (*self.deque.get()).pool }\n+    }\n+}\n+\n+impl<T: Send> Stealer<T> {\n+    /// Steals work off the end of the queue (opposite of the worker's end)\n+    pub fn steal(&mut self) -> Stolen<T> {\n+        unsafe { (*self.deque.get()).steal() }\n+    }\n+\n+    /// Gets access to the buffer pool that this stealer is attached to. This\n+    /// can be used to create more deques which share the same buffer pool as\n+    /// this deque.\n+    pub fn pool<'a>(&'a mut self) -> &'a mut BufferPool<T> {\n+        unsafe { &mut (*self.deque.get()).pool }\n+    }\n+}\n+\n+impl<T: Send> Clone for Stealer<T> {\n+    fn clone(&self) -> Stealer<T> { Stealer { deque: self.deque.clone() } }\n+}\n+\n+// Almost all of this code can be found directly in the paper so I'm not\n+// personally going to heavily comment what's going on here.\n+\n+impl<T: Send> Deque<T> {\n+    fn init(mut pool: BufferPool<T>) -> Deque<T> {\n+        let buf = pool.alloc(MIN_BITS);\n+        Deque {\n+            bottom: AtomicInt::new(0),\n+            top: AtomicInt::new(0),\n+            array: AtomicPtr::new(unsafe { cast::transmute(buf) }),\n+            pool: pool,\n+        }\n+    }\n+\n+    unsafe fn push(&mut self, data: T) {\n+        let mut b = self.bottom.load(SeqCst);\n+        let t = self.top.load(SeqCst);\n+        let mut a = self.array.load(SeqCst);\n+        let size = b - t;\n+        if size >= (*a).size() - 1 {\n+            // You won't find this code in the chase-lev deque paper. This is\n+            // alluded to in a small footnote, however. We always free a buffer\n+            // when growing in order to prevent leaks.\n+            a = self.swap_buffer(b, a, (*a).resize(b, t, 1));\n+            b = self.bottom.load(SeqCst);\n+        }\n+        (*a).put(b, data);\n+        self.bottom.store(b + 1, SeqCst);\n+    }\n+\n+    unsafe fn pop(&mut self) -> Option<T> {\n+        let b = self.bottom.load(SeqCst);\n+        let a = self.array.load(SeqCst);\n+        let b = b - 1;\n+        self.bottom.store(b, SeqCst);\n+        let t = self.top.load(SeqCst);\n+        let size = b - t;\n+        if size < 0 {\n+            self.bottom.store(t, SeqCst);\n+            return None;\n+        }\n+        let data = (*a).get(b);\n+        if size > 0 {\n+            self.maybe_shrink(b, t);\n+            return Some(data);\n+        }\n+        if self.top.compare_and_swap(t, t + 1, SeqCst) == t {\n+            self.bottom.store(t + 1, SeqCst);\n+            return Some(data);\n+        } else {\n+            self.bottom.store(t + 1, SeqCst);\n+            cast::forget(data); // someone else stole this value\n+            return None;\n+        }\n+    }\n+\n+    unsafe fn steal(&mut self) -> Stolen<T> {\n+        let t = self.top.load(SeqCst);\n+        let old = self.array.load(SeqCst);\n+        let b = self.bottom.load(SeqCst);\n+        let a = self.array.load(SeqCst);\n+        let size = b - t;\n+        if size <= 0 { return Empty }\n+        if size % (*a).size() == 0 {\n+            if a == old && t == self.top.load(SeqCst) {\n+                return Empty\n+            }\n+            return Abort\n+        }\n+        let data = (*a).get(t);\n+        if self.top.compare_and_swap(t, t + 1, SeqCst) == t {\n+            Data(data)\n+        } else {\n+            cast::forget(data); // someone else stole this value\n+            Abort\n+        }\n+    }\n+\n+    unsafe fn maybe_shrink(&mut self, b: int, t: int) {\n+        let a = self.array.load(SeqCst);\n+        if b - t < (*a).size() / K && b - t > (1 << MIN_BITS) {\n+            self.swap_buffer(b, a, (*a).resize(b, t, -1));\n+        }\n+    }\n+\n+    // Helper routine not mentioned in the paper which is used in growing and\n+    // shrinking buffers to swap in a new buffer into place. As a bit of a\n+    // recap, the whole point that we need a buffer pool rather than just\n+    // calling malloc/free directly is that stealers can continue using buffers\n+    // after this method has called 'free' on it. The continued usage is simply\n+    // a read followed by a forget, but we must make sure that the memory can\n+    // continue to be read after we flag this buffer for reclamation.\n+    unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,\n+                          buf: Buffer<T>) -> *mut Buffer<T> {\n+        let newbuf: *mut Buffer<T> = cast::transmute(~buf);\n+        self.array.store(newbuf, SeqCst);\n+        let ss = (*newbuf).size();\n+        self.bottom.store(b + ss, SeqCst);\n+        let t = self.top.load(SeqCst);\n+        if self.top.compare_and_swap(t, t + ss, SeqCst) != t {\n+            self.bottom.store(b, SeqCst);\n+        }\n+        self.pool.free(cast::transmute(old));\n+        return newbuf;\n+    }\n+}\n+\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Deque<T> {\n+    fn drop(&mut self) {\n+        let t = self.top.load(SeqCst);\n+        let b = self.bottom.load(SeqCst);\n+        let a = self.array.load(SeqCst);\n+        // Free whatever is leftover in the dequeue, and then move the buffer\n+        // back into the pool.\n+        for i in range(t, b) {\n+            let _: T = unsafe { (*a).get(i) };\n+        }\n+        self.pool.free(unsafe { cast::transmute(a) });\n+    }\n+}\n+\n+impl<T: Send> Buffer<T> {\n+    unsafe fn init(log_size: int) -> Buffer<T> {\n+        let size = (1 << log_size) * mem::size_of::<T>();\n+        let buffer = libc::malloc(size as libc::size_t);\n+        assert!(!buffer.is_null());\n+        Buffer {\n+            storage: buffer as *T,\n+            log_size: log_size,\n+        }\n+    }\n+\n+    fn size(&self) -> int { 1 << self.log_size }\n+\n+    // Apparently LLVM cannot optimize (foo % (1 << bar)) into this implicitly\n+    fn mask(&self) -> int { (1 << self.log_size) - 1 }\n+\n+    // This does not protect against loading duplicate values of the same cell,\n+    // nor does this clear out the contents contained within. Hence, this is a\n+    // very unsafe method which the caller needs to treat specially in case a\n+    // race is lost.\n+    unsafe fn get(&self, i: int) -> T {\n+        ptr::read_ptr(self.storage.offset(i & self.mask()))\n+    }\n+\n+    // Unsafe because this unsafely overwrites possibly uninitialized or\n+    // initialized data.\n+    unsafe fn put(&mut self, i: int, t: T) {\n+        let ptr = self.storage.offset(i & self.mask());\n+        ptr::copy_nonoverlapping_memory(ptr as *mut T, &t as *T, 1);\n+        cast::forget(t);\n+    }\n+\n+    // Again, unsafe because this has incredibly dubious ownership violations.\n+    // It is assumed that this buffer is immediately dropped.\n+    unsafe fn resize(&self, b: int, t: int, delta: int) -> Buffer<T> {\n+        let mut buf = Buffer::init(self.log_size + delta);\n+        for i in range(t, b) {\n+            buf.put(i, self.get(i));\n+        }\n+        return buf;\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T: Send> Drop for Buffer<T> {\n+    fn drop(&mut self) {\n+        // It is assumed that all buffers are empty on drop.\n+        unsafe { libc::free(self.storage as *libc::c_void) }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::{Data, BufferPool, Abort, Empty, Worker, Stealer};\n+\n+    use cast;\n+    use rt::thread::Thread;\n+    use rand;\n+    use rand::Rng;\n+    use unstable::atomics::{AtomicBool, INIT_ATOMIC_BOOL, SeqCst,\n+                            AtomicUint, INIT_ATOMIC_UINT};\n+    use vec;\n+\n+    #[test]\n+    fn smoke() {\n+        let mut pool = BufferPool::init();\n+        let (mut w, mut s) = pool.deque();\n+        assert_eq!(w.pop(), None);\n+        assert_eq!(s.steal(), Empty);\n+        w.push(1);\n+        assert_eq!(w.pop(), Some(1));\n+        w.push(1);\n+        assert_eq!(s.steal(), Data(1));\n+        w.push(1);\n+        assert_eq!(s.clone().steal(), Data(1));\n+    }\n+\n+    #[test]\n+    fn stealpush() {\n+        static AMT: int = 100000;\n+        let mut pool = BufferPool::<int>::init();\n+        let (mut w, s) = pool.deque();\n+        let t = do Thread::start {\n+            let mut s = s;\n+            let mut left = AMT;\n+            while left > 0 {\n+                match s.steal() {\n+                    Data(i) => {\n+                        assert_eq!(i, 1);\n+                        left -= 1;\n+                    }\n+                    Abort | Empty => {}\n+                }\n+            }\n+        };\n+\n+        for _ in range(0, AMT) {\n+            w.push(1);\n+        }\n+\n+        t.join();\n+    }\n+\n+    #[test]\n+    fn stealpush_large() {\n+        static AMT: int = 100000;\n+        let mut pool = BufferPool::<(int, int)>::init();\n+        let (mut w, s) = pool.deque();\n+        let t = do Thread::start {\n+            let mut s = s;\n+            let mut left = AMT;\n+            while left > 0 {\n+                match s.steal() {\n+                    Data((1, 10)) => { left -= 1; }\n+                    Data(..) => fail!(),\n+                    Abort | Empty => {}\n+                }\n+            }\n+        };\n+\n+        for _ in range(0, AMT) {\n+            w.push((1, 10));\n+        }\n+\n+        t.join();\n+    }\n+\n+    fn stampede(mut w: Worker<~int>, s: Stealer<~int>,\n+                nthreads: int, amt: uint) {\n+        for _ in range(0, amt) {\n+            w.push(~20);\n+        }\n+        let mut remaining = AtomicUint::new(amt);\n+        let unsafe_remaining: *mut AtomicUint = &mut remaining;\n+\n+        let threads = range(0, nthreads).map(|_| {\n+            let s = s.clone();\n+            do Thread::start {\n+                unsafe {\n+                    let mut s = s;\n+                    while (*unsafe_remaining).load(SeqCst) > 0 {\n+                        match s.steal() {\n+                            Data(~20) => {\n+                                (*unsafe_remaining).fetch_sub(1, SeqCst);\n+                            }\n+                            Data(..) => fail!(),\n+                            Abort | Empty => {}\n+                        }\n+                    }\n+                }\n+            }\n+        }).to_owned_vec();\n+\n+        while remaining.load(SeqCst) > 0 {\n+            match w.pop() {\n+                Some(~20) => { remaining.fetch_sub(1, SeqCst); }\n+                Some(..) => fail!(),\n+                None => {}\n+            }\n+        }\n+\n+        for thread in threads.move_iter() {\n+            thread.join();\n+        }\n+    }\n+\n+    #[test]\n+    fn run_stampede() {\n+        let mut pool = BufferPool::<~int>::init();\n+        let (w, s) = pool.deque();\n+        stampede(w, s, 8, 10000);\n+    }\n+\n+    #[test]\n+    fn many_stampede() {\n+        static AMT: uint = 4;\n+        let mut pool = BufferPool::<~int>::init();\n+        let threads = range(0, AMT).map(|_| {\n+            let (w, s) = pool.deque();\n+            do Thread::start {\n+                stampede(w, s, 4, 10000);\n+            }\n+        }).to_owned_vec();\n+\n+        for thread in threads.move_iter() {\n+            thread.join();\n+        }\n+    }\n+\n+    #[test]\n+    fn stress() {\n+        static AMT: int = 100000;\n+        static NTHREADS: int = 8;\n+        static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n+        static mut HITS: AtomicUint = INIT_ATOMIC_UINT;\n+        let mut pool = BufferPool::<int>::init();\n+        let (mut w, s) = pool.deque();\n+\n+        let threads = range(0, NTHREADS).map(|_| {\n+            let s = s.clone();\n+            do Thread::start {\n+                unsafe {\n+                    let mut s = s;\n+                    loop {\n+                        match s.steal() {\n+                            Data(2) => { HITS.fetch_add(1, SeqCst); }\n+                            Data(..) => fail!(),\n+                            _ if DONE.load(SeqCst) => break,\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }\n+        }).to_owned_vec();\n+\n+        let mut rng = rand::task_rng();\n+        let mut expected = 0;\n+        while expected < AMT {\n+            if rng.gen_range(0, 3) == 2 {\n+                match w.pop() {\n+                    None => {}\n+                    Some(2) => unsafe { HITS.fetch_add(1, SeqCst); },\n+                    Some(_) => fail!(),\n+                }\n+            } else {\n+                expected += 1;\n+                w.push(2);\n+            }\n+        }\n+\n+        unsafe {\n+            while HITS.load(SeqCst) < AMT as uint {\n+                match w.pop() {\n+                    None => {}\n+                    Some(2) => { HITS.fetch_add(1, SeqCst); },\n+                    Some(_) => fail!(),\n+                }\n+            }\n+            DONE.store(true, SeqCst);\n+        }\n+\n+        for thread in threads.move_iter() {\n+            thread.join();\n+        }\n+\n+        assert_eq!(unsafe { HITS.load(SeqCst) }, expected as uint);\n+    }\n+\n+    #[test]\n+    fn no_starvation() {\n+        static AMT: int = 10000;\n+        static NTHREADS: int = 4;\n+        static mut DONE: AtomicBool = INIT_ATOMIC_BOOL;\n+        let mut pool = BufferPool::<(int, uint)>::init();\n+        let (mut w, s) = pool.deque();\n+\n+        let (threads, hits) = vec::unzip(range(0, NTHREADS).map(|_| {\n+            let s = s.clone();\n+            let box = ~AtomicUint::new(0);\n+            let thread_box = unsafe {\n+                *cast::transmute::<&~AtomicUint, **mut AtomicUint>(&box)\n+            };\n+            (do Thread::start {\n+                unsafe {\n+                    let mut s = s;\n+                    loop {\n+                        match s.steal() {\n+                            Data((1, 2)) => {\n+                                (*thread_box).fetch_add(1, SeqCst);\n+                            }\n+                            Data(..) => fail!(),\n+                            _ if DONE.load(SeqCst) => break,\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+            }, box)\n+        }));\n+\n+        let mut rng = rand::task_rng();\n+        let mut myhit = false;\n+        let mut iter = 0;\n+        'outer: loop {\n+            for _ in range(0, rng.gen_range(0, AMT)) {\n+                if !myhit && rng.gen_range(0, 3) == 2 {\n+                    match w.pop() {\n+                        None => {}\n+                        Some((1, 2)) => myhit = true,\n+                        Some(_) => fail!(),\n+                    }\n+                } else {\n+                    w.push((1, 2));\n+                }\n+            }\n+            iter += 1;\n+\n+            debug!(\"loop iteration {}\", iter);\n+            for (i, slot) in hits.iter().enumerate() {\n+                let amt = slot.load(SeqCst);\n+                debug!(\"thread {}: {}\", i, amt);\n+                if amt == 0 { continue 'outer; }\n+            }\n+            if myhit {\n+                break\n+            }\n+        }\n+\n+        unsafe { DONE.store(true, SeqCst); }\n+\n+        for thread in threads.move_iter() {\n+            thread.join();\n+        }\n+    }\n+}\n+"}, {"sha": "be1de6c5bdb83a3599009a47cae9c6a8caa64a36", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -75,7 +75,6 @@ use vec::{OwnedVector, MutableVector, ImmutableVector};\n use vec;\n \n use self::thread::Thread;\n-use self::work_queue::WorkQueue;\n \n // the os module needs to reach into this helper, so allow general access\n // through this reexport.\n@@ -130,9 +129,6 @@ pub mod rtio;\n /// or task-local storage.\n pub mod local;\n \n-/// A parallel work-stealing deque.\n-pub mod work_queue;\n-\n /// A parallel queue.\n pub mod message_queue;\n \n@@ -142,6 +138,9 @@ mod mpsc_queue;\n /// A lock-free multi-producer, multi-consumer bounded queue.\n mod mpmc_bounded_queue;\n \n+/// A parallel work-stealing deque\n+pub mod deque;\n+\n /// A parallel data structure for tracking sleeping schedulers.\n pub mod sleeper_list;\n \n@@ -287,22 +286,24 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n     // Create a work queue for each scheduler, ntimes. Create an extra\n     // for the main thread if that flag is set. We won't steal from it.\n-    let work_queues: ~[WorkQueue<~Task>] = vec::from_fn(nscheds, |_| WorkQueue::new());\n+    let mut pool = deque::BufferPool::init();\n+    let arr = vec::from_fn(nscheds, |_| pool.deque());\n+    let (workers, stealers) = vec::unzip(arr.move_iter());\n \n     // The schedulers.\n     let mut scheds = ~[];\n     // Handles to the schedulers. When the main task ends these will be\n     // sent the Shutdown message to terminate the schedulers.\n     let mut handles = ~[];\n \n-    for work_queue in work_queues.iter() {\n+    for worker in workers.move_iter() {\n         rtdebug!(\"inserting a regular scheduler\");\n \n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = new_event_loop();\n         let mut sched = ~Scheduler::new(loop_,\n-                                        work_queue.clone(),\n-                                        work_queues.clone(),\n+                                        worker,\n+                                        stealers.clone(),\n                                         sleepers.clone());\n         let handle = sched.make_handle();\n \n@@ -321,12 +322,12 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n         // This scheduler needs a queue that isn't part of the stealee\n         // set.\n-        let work_queue = WorkQueue::new();\n+        let (worker, _) = pool.deque();\n \n         let main_loop = new_event_loop();\n         let mut main_sched = ~Scheduler::new_special(main_loop,\n-                                                     work_queue,\n-                                                     work_queues.clone(),\n+                                                     worker,\n+                                                     stealers.clone(),\n                                                      sleepers.clone(),\n                                                      false,\n                                                      Some(friend_handle));"}, {"sha": "a231bea5e27e9f7cdacfa38633ffe56502f92cd4", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -13,13 +13,13 @@ use cast::{transmute, transmute_mut_region, transmute_mut_unsafe};\n use clone::Clone;\n use unstable::raw;\n use super::sleeper_list::SleeperList;\n-use super::work_queue::WorkQueue;\n use super::stack::{StackPool};\n use super::rtio::EventLoop;\n use super::context::Context;\n use super::task::{Task, AnySched, Sched};\n use super::message_queue::MessageQueue;\n use rt::kill::BlockedTask;\n+use rt::deque;\n use rt::local_ptr;\n use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback, Callback};\n@@ -39,14 +39,14 @@ use vec::{OwnedVector};\n /// in too much allocation and too many events.\n pub struct Scheduler {\n     /// There are N work queues, one per scheduler.\n-    priv work_queue: WorkQueue<~Task>,\n+    work_queue: deque::Worker<~Task>,\n     /// Work queues for the other schedulers. These are created by\n     /// cloning the core work queues.\n-    work_queues: ~[WorkQueue<~Task>],\n+    work_queues: ~[deque::Stealer<~Task>],\n     /// The queue of incoming messages from other schedulers.\n     /// These are enqueued by SchedHandles after which a remote callback\n     /// is triggered to handle the message.\n-    priv message_queue: MessageQueue<SchedMessage>,\n+    message_queue: MessageQueue<SchedMessage>,\n     /// A shared list of sleeping schedulers. We'll use this to wake\n     /// up schedulers when pushing work onto the work queue.\n     sleeper_list: SleeperList,\n@@ -56,33 +56,33 @@ pub struct Scheduler {\n     /// not active since there are multiple event sources that may\n     /// wake the scheduler. It just prevents the scheduler from pushing\n     /// multiple handles onto the sleeper list.\n-    priv sleepy: bool,\n+    sleepy: bool,\n     /// A flag to indicate we've received the shutdown message and should\n     /// no longer try to go to sleep, but exit instead.\n     no_sleep: bool,\n     stack_pool: StackPool,\n     /// The scheduler runs on a special task. When it is not running\n     /// it is stored here instead of the work queue.\n-    priv sched_task: Option<~Task>,\n+    sched_task: Option<~Task>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n-    priv cleanup_job: Option<CleanupJob>,\n+    cleanup_job: Option<CleanupJob>,\n     /// Should this scheduler run any task, or only pinned tasks?\n     run_anything: bool,\n     /// If the scheduler shouldn't run some tasks, a friend to send\n     /// them to.\n-    priv friend_handle: Option<SchedHandle>,\n+    friend_handle: Option<SchedHandle>,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n     /// A toggleable idle callback\n-    priv idle_callback: Option<~PausibleIdleCallback>,\n+    idle_callback: Option<~PausibleIdleCallback>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n     /// will yield.\n-    priv yield_check_count: uint,\n+    yield_check_count: uint,\n     /// A flag to tell the scheduler loop it needs to do some stealing\n     /// in order to introduce randomness as part of a yield\n-    priv steal_for_yield: bool,\n+    steal_for_yield: bool,\n \n     // n.b. currently destructors of an object are run in top-to-bottom in order\n     //      of field declaration. Due to its nature, the pausible idle callback\n@@ -115,8 +115,8 @@ impl Scheduler {\n     // * Initialization Functions\n \n     pub fn new(event_loop: ~EventLoop,\n-               work_queue: WorkQueue<~Task>,\n-               work_queues: ~[WorkQueue<~Task>],\n+               work_queue: deque::Worker<~Task>,\n+               work_queues: ~[deque::Stealer<~Task>],\n                sleeper_list: SleeperList)\n         -> Scheduler {\n \n@@ -127,8 +127,8 @@ impl Scheduler {\n     }\n \n     pub fn new_special(event_loop: ~EventLoop,\n-                       work_queue: WorkQueue<~Task>,\n-                       work_queues: ~[WorkQueue<~Task>],\n+                       work_queue: deque::Worker<~Task>,\n+                       work_queues: ~[deque::Stealer<~Task>],\n                        sleeper_list: SleeperList,\n                        run_anything: bool,\n                        friend: Option<SchedHandle>)\n@@ -440,11 +440,11 @@ impl Scheduler {\n         let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n             match work_queues[index].steal() {\n-                Some(task) => {\n+                deque::Data(task) => {\n                     rtdebug!(\"found task by stealing\");\n                     return Some(task)\n                 }\n-                None => ()\n+                _ => ()\n             }\n         };\n         rtdebug!(\"giving up on stealing\");\n@@ -889,6 +889,7 @@ mod test {\n     use borrow::to_uint;\n     use rt::sched::{Scheduler};\n     use cell::Cell;\n+    use rt::deque::BufferPool;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n     use rt::basic;\n@@ -994,22 +995,22 @@ mod test {\n     #[test]\n     fn test_schedule_home_states() {\n         use rt::sleeper_list::SleeperList;\n-        use rt::work_queue::WorkQueue;\n         use rt::sched::Shutdown;\n         use borrow;\n         use rt::comm::*;\n \n         do run_in_bare_thread {\n \n             let sleepers = SleeperList::new();\n-            let normal_queue = WorkQueue::new();\n-            let special_queue = WorkQueue::new();\n-            let queues = ~[normal_queue.clone(), special_queue.clone()];\n+            let mut pool = BufferPool::init();\n+            let (normal_worker, normal_stealer) = pool.deque();\n+            let (special_worker, special_stealer) = pool.deque();\n+            let queues = ~[normal_stealer, special_stealer];\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n                 basic::event_loop(),\n-                normal_queue,\n+                normal_worker,\n                 queues.clone(),\n                 sleepers.clone());\n \n@@ -1020,7 +1021,7 @@ mod test {\n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n                 basic::event_loop(),\n-                special_queue.clone(),\n+                special_worker,\n                 queues.clone(),\n                 sleepers.clone(),\n                 false,\n@@ -1169,7 +1170,6 @@ mod test {\n     // Used to deadlock because Shutdown was never recvd.\n     #[test]\n     fn no_missed_messages() {\n-        use rt::work_queue::WorkQueue;\n         use rt::sleeper_list::SleeperList;\n         use rt::stack::StackPool;\n         use rt::sched::{Shutdown, TaskFromFriend};\n@@ -1178,13 +1178,13 @@ mod test {\n         do run_in_bare_thread {\n             stress_factor().times(|| {\n                 let sleepers = SleeperList::new();\n-                let queue = WorkQueue::new();\n-                let queues = ~[queue.clone()];\n+                let mut pool = BufferPool::init();\n+                let (worker, stealer) = pool.deque();\n \n                 let mut sched = ~Scheduler::new(\n                     basic::event_loop(),\n-                    queue,\n-                    queues.clone(),\n+                    worker,\n+                    ~[stealer],\n                     sleepers.clone());\n \n                 let mut handle = sched.make_handle();"}, {"sha": "51ad37a25830e0eda12f33210fcafe1eca8c264e", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -23,24 +23,25 @@ use rand;\n use result::{Result, Ok, Err};\n use rt::basic;\n use rt::comm::oneshot;\n+use rt::deque::BufferPool;\n use rt::new_event_loop;\n use rt::sched::Scheduler;\n use rt::sleeper_list::SleeperList;\n use rt::task::Task;\n use rt::task::UnwindResult;\n use rt::thread::Thread;\n-use rt::work_queue::WorkQueue;\n use unstable::{run_in_bare_thread};\n+use vec;\n use vec::{OwnedVector, MutableVector, ImmutableVector};\n \n pub fn new_test_uv_sched() -> Scheduler {\n \n-    let queue = WorkQueue::new();\n-    let queues = ~[queue.clone()];\n+    let mut pool = BufferPool::init();\n+    let (worker, stealer) = pool.deque();\n \n     let mut sched = Scheduler::new(new_event_loop(),\n-                                   queue,\n-                                   queues,\n+                                   worker,\n+                                   ~[stealer],\n                                    SleeperList::new());\n \n     // Don't wait for the Shutdown message\n@@ -50,13 +51,12 @@ pub fn new_test_uv_sched() -> Scheduler {\n }\n \n pub fn new_test_sched() -> Scheduler {\n-\n-    let queue = WorkQueue::new();\n-    let queues = ~[queue.clone()];\n+    let mut pool = BufferPool::init();\n+    let (worker, stealer) = pool.deque();\n \n     let mut sched = Scheduler::new(basic::event_loop(),\n-                                   queue,\n-                                   queues,\n+                                   worker,\n+                                   ~[stealer],\n                                    SleeperList::new());\n \n     // Don't wait for the Shutdown message\n@@ -227,18 +227,16 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n \n         let mut handles = ~[];\n         let mut scheds = ~[];\n-        let mut work_queues = ~[];\n \n-        for _ in range(0u, nthreads) {\n-            let work_queue = WorkQueue::new();\n-            work_queues.push(work_queue);\n-        }\n+        let mut pool = BufferPool::<~Task>::init();\n+        let workers = range(0, nthreads).map(|_| pool.deque());\n+        let (workers, stealers) = vec::unzip(workers);\n \n-        for i in range(0u, nthreads) {\n+        for worker in workers.move_iter() {\n             let loop_ = new_event_loop();\n             let mut sched = ~Scheduler::new(loop_,\n-                                            work_queues[i].clone(),\n-                                            work_queues.clone(),\n+                                            worker,\n+                                            stealers.clone(),\n                                             sleepers.clone());\n             let handle = sched.make_handle();\n "}, {"sha": "02ea8ab4f5037b65fc442cd770081280eae4e47b", "filename": "src/libstd/rt/work_queue.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/08f4d1ff9f2cc0092b307e1f438fb911bbf55185/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08f4d1ff9f2cc0092b307e1f438fb911bbf55185/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=08f4d1ff9f2cc0092b307e1f438fb911bbf55185", "patch": "@@ -1,75 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use container::Container;\n-use option::*;\n-use vec::OwnedVector;\n-use unstable::sync::Exclusive;\n-use cell::Cell;\n-use kinds::Send;\n-use clone::Clone;\n-\n-pub struct WorkQueue<T> {\n-    // XXX: Another mystery bug fixed by boxing this lock\n-    priv queue: ~Exclusive<~[T]>\n-}\n-\n-impl<T: Send> WorkQueue<T> {\n-    pub fn new() -> WorkQueue<T> {\n-        WorkQueue {\n-            queue: ~Exclusive::new(~[])\n-        }\n-    }\n-\n-    pub fn push(&mut self, value: T) {\n-        unsafe {\n-            let value = Cell::new(value);\n-            self.queue.with(|q| q.unshift(value.take()) );\n-        }\n-    }\n-\n-    pub fn pop(&mut self) -> Option<T> {\n-        unsafe {\n-            self.queue.with(|q| {\n-                if !q.is_empty() {\n-                    Some(q.shift())\n-                } else {\n-                    None\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn steal(&mut self) -> Option<T> {\n-        unsafe {\n-            self.queue.with(|q| {\n-                if !q.is_empty() {\n-                    Some(q.pop())\n-                } else {\n-                    None\n-                }\n-            })\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        unsafe {\n-            self.queue.with_imm(|q| q.is_empty() )\n-        }\n-    }\n-}\n-\n-impl<T> Clone for WorkQueue<T> {\n-    fn clone(&self) -> WorkQueue<T> {\n-        WorkQueue {\n-            queue: self.queue.clone()\n-        }\n-    }\n-}"}, {"sha": "153b3e4ce254baa101a14933c128e8a6236cfb86", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a70f9d7324a91058d31c1301c4351932880d57e8/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=a70f9d7324a91058d31c1301c4351932880d57e8", "patch": "@@ -84,7 +84,6 @@ use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n use rt::task::UnwindResult;\n use rt::thread::Thread;\n-use rt::work_queue::WorkQueue;\n use rt::{in_green_task_context, new_event_loop};\n use task::SingleThreaded;\n use task::TaskOpts;\n@@ -111,11 +110,11 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n             // Since this is a 1:1 scheduler we create a queue not in\n             // the stealee set. The run_anything flag is set false\n             // which will disable stealing.\n-            let work_queue = WorkQueue::new();\n+            let (worker, _stealer) = (*sched).work_queue.pool().deque();\n \n             // Create a new scheduler to hold the new task\n             let mut new_sched = ~Scheduler::new_special(new_event_loop(),\n-                                                        work_queue,\n+                                                        worker,\n                                                         (*sched).work_queues.clone(),\n                                                         (*sched).sleeper_list.clone(),\n                                                         false,"}]}