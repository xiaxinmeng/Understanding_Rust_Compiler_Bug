{"sha": "b81f5c547c41571be3814ad4b2802f3305e12152", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MWY1YzU0N2M0MTU3MWJlMzgxNGFkNGIyODAyZjMzMDVlMTIxNTI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-20T22:39:18Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-20T22:39:18Z"}, "message": "small cleanups in task/spawn.rs", "tree": {"sha": "35c45946c28fc4ee97f4ebba440e50c43398078a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35c45946c28fc4ee97f4ebba440e50c43398078a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b81f5c547c41571be3814ad4b2802f3305e12152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b81f5c547c41571be3814ad4b2802f3305e12152", "html_url": "https://github.com/rust-lang/rust/commit/b81f5c547c41571be3814ad4b2802f3305e12152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b81f5c547c41571be3814ad4b2802f3305e12152/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd406365e1a189c4f229e1eba7ba091605e995ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd406365e1a189c4f229e1eba7ba091605e995ef", "html_url": "https://github.com/rust-lang/rust/commit/dd406365e1a189c4f229e1eba7ba091605e995ef"}], "stats": {"total": 77, "additions": 32, "deletions": 45}, "files": [{"sha": "b789a6ca957926cd7a1d4cedf706a4414eccb426", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b81f5c547c41571be3814ad4b2802f3305e12152/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81f5c547c41571be3814ad4b2802f3305e12152/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=b81f5c547c41571be3814ad4b2802f3305e12152", "patch": "@@ -446,8 +446,7 @@ fn taskgroup_key() -> local_data::Key<@@mut Taskgroup> {\n // Transitionary.\n struct RuntimeGlue;\n impl RuntimeGlue {\n-    fn kill_task(handle: KillHandle) {\n-        let mut handle = handle;\n+    fn kill_task(mut handle: KillHandle) {\n         do handle.kill().map_move |killed_task| {\n             let killed_task = Cell::new(killed_task);\n             do Local::borrow::<Scheduler, ()> |sched| {\n@@ -457,44 +456,38 @@ impl RuntimeGlue {\n     }\n \n     fn with_task_handle_and_failing(blk: &fn(&KillHandle, bool)) {\n-        if in_green_task_context() {\n-            unsafe {\n-                // Can't use safe borrow, because the taskgroup destructor needs to\n-                // access the scheduler again to send kill signals to other tasks.\n-                let me = Local::unsafe_borrow::<Task>();\n-                blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n-            }\n-        } else {\n-            rtabort!(\"task dying in bad context\")\n+        rtassert!(in_green_task_context());\n+        unsafe {\n+            // Can't use safe borrow, because the taskgroup destructor needs to\n+            // access the scheduler again to send kill signals to other tasks.\n+            let me = Local::unsafe_borrow::<Task>();\n+            blk((*me).death.kill_handle.get_ref(), (*me).unwinder.unwinding)\n         }\n     }\n \n     fn with_my_taskgroup<U>(blk: &fn(&Taskgroup) -> U) -> U {\n-        if in_green_task_context() {\n-            unsafe {\n-                // Can't use safe borrow, because creating new hashmaps for the\n-                // tasksets requires an rng, which needs to borrow the sched.\n-                let me = Local::unsafe_borrow::<Task>();\n-                blk(match (*me).taskgroup {\n-                    None => {\n-                        // First task in its (unlinked/unsupervised) taskgroup.\n-                        // Lazily initialize.\n-                        let mut members = TaskSet::new();\n-                        let my_handle = (*me).death.kill_handle.get_ref().clone();\n-                        members.insert(my_handle);\n-                        let tasks = Exclusive::new(Some(TaskGroupData {\n-                            members: members,\n-                            descendants: TaskSet::new(),\n-                        }));\n-                        let group = Taskgroup(tasks, AncestorList(None), None);\n-                        (*me).taskgroup = Some(group);\n-                        (*me).taskgroup.get_ref()\n-                    }\n-                    Some(ref group) => group,\n-                })\n-            }\n-        } else {\n-            rtabort!(\"spawning in bad context\")\n+        rtassert!(in_green_task_context());\n+        unsafe {\n+            // Can't use safe borrow, because creating new hashmaps for the\n+            // tasksets requires an rng, which needs to borrow the sched.\n+            let me = Local::unsafe_borrow::<Task>();\n+            blk(match (*me).taskgroup {\n+                None => {\n+                    // First task in its (unlinked/unsupervised) taskgroup.\n+                    // Lazily initialize.\n+                    let mut members = TaskSet::new();\n+                    let my_handle = (*me).death.kill_handle.get_ref().clone();\n+                    members.insert(my_handle);\n+                    let tasks = Exclusive::new(Some(TaskGroupData {\n+                        members: members,\n+                        descendants: TaskSet::new(),\n+                    }));\n+                    let group = Taskgroup(tasks, AncestorList(None), None);\n+                    (*me).taskgroup = Some(group);\n+                    (*me).taskgroup.get_ref()\n+                }\n+                Some(ref group) => group,\n+            })\n         }\n     }\n }\n@@ -567,17 +560,11 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     result\n }\n \n-pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n-    if in_green_task_context() {\n-        spawn_raw_newsched(opts, f)\n-    } else {\n-        fail!(\"can't spawn from this context\")\n-    }\n-}\n-\n-fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n+pub fn spawn_raw(mut opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n+    rtassert!(in_green_task_context());\n+\n     let child_data = Cell::new(gen_child_taskgroup(opts.linked, opts.supervised));\n     let indestructible = opts.indestructible;\n "}]}