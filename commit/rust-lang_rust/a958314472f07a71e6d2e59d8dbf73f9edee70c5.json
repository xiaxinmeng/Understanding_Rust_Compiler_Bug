{"sha": "a958314472f07a71e6d2e59d8dbf73f9edee70c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTgzMTQ0NzJmMDdhNzFlNmQyZTU5ZDhkYmY3M2Y5ZWRlZTcwYzU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T17:03:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-18T17:03:40Z"}, "message": "Rollup merge of #69839 - RalfJung:miri-error-cleanup, r=oli-obk\n\nMiri error reform\n\nSome time ago we started moving Miri errors into a few distinct categories, but we never classified all the old errors. That's what this PR does.\n\n~~This is on top of https://github.com/rust-lang/rust/pull/69762; [relative diff](https://github.com/RalfJung/rust/compare/validity-errors...RalfJung:miri-error-cleanup).~~\n\nr? @oli-obk\n\nFixes https://github.com/rust-lang/const-eval/issues/4", "tree": {"sha": "69dfa8dd6517feec8f7f1908ff5696b8958d0617", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69dfa8dd6517feec8f7f1908ff5696b8958d0617"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a958314472f07a71e6d2e59d8dbf73f9edee70c5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeclRsCRBK7hj4Ov3rIwAAdHIIABKC5LJVo7r9x5td1mga9OD1\njGjQmKkU7LXdpRyu7roBSjEgQNNWEqcDwF+5bgNwVPtxtmb7UELMMZIBJZPFFXMq\nF3FOIMUN2Tayt6Kql/k9oNiCJRJPoAkB96t80QfZd0NsckvTyyNUeEPjTlM6rnQJ\ny0nSPhdAI8JfhZ64Vw9vZK8m2KSyGqPMHRzZOFHqX2d0vhYEqxPbgSr34nm2/FK1\neA+87vEbCEi/rC7SM7C+lUKI4tA/oPsmgoCmWSUncj8Yg1yqGJJ47aj6wWNPINKQ\nqhSsYs8eJhFHKWi6L+jTrJFM256f9dA64+lCuwAHTiane5lOiUrlKr7IHqfARYc=\n=jKKm\n-----END PGP SIGNATURE-----\n", "payload": "tree 69dfa8dd6517feec8f7f1908ff5696b8958d0617\nparent 23b79d83f2472bb310b4bb53f0bccbbaaab00044\nparent e219dd4a2df1d9d3e082c0a6154dd20be21865e7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584551020 +0100\ncommitter GitHub <noreply@github.com> 1584551020 +0100\n\nRollup merge of #69839 - RalfJung:miri-error-cleanup, r=oli-obk\n\nMiri error reform\n\nSome time ago we started moving Miri errors into a few distinct categories, but we never classified all the old errors. That's what this PR does.\n\n~~This is on top of https://github.com/rust-lang/rust/pull/69762; [relative diff](https://github.com/RalfJung/rust/compare/validity-errors...RalfJung:miri-error-cleanup).~~\n\nr? @oli-obk\n\nFixes https://github.com/rust-lang/const-eval/issues/4\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a958314472f07a71e6d2e59d8dbf73f9edee70c5", "html_url": "https://github.com/rust-lang/rust/commit/a958314472f07a71e6d2e59d8dbf73f9edee70c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a958314472f07a71e6d2e59d8dbf73f9edee70c5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23b79d83f2472bb310b4bb53f0bccbbaaab00044", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b79d83f2472bb310b4bb53f0bccbbaaab00044", "html_url": "https://github.com/rust-lang/rust/commit/23b79d83f2472bb310b4bb53f0bccbbaaab00044"}, {"sha": "e219dd4a2df1d9d3e082c0a6154dd20be21865e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e219dd4a2df1d9d3e082c0a6154dd20be21865e7", "html_url": "https://github.com/rust-lang/rust/commit/e219dd4a2df1d9d3e082c0a6154dd20be21865e7"}], "stats": {"total": 890, "additions": 420, "deletions": 470}, "files": [{"sha": "9474f05b55df7e9bbf1d02c86f9ee7acf5aa1fc4", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -41,6 +41,7 @@ pub struct Allocation<Tag = (), Extra = ()> {\n     /// The size of the allocation. Currently, must always equal `bytes.len()`.\n     pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n+    /// (`Align` guarantees that this is a power of two.)\n     pub align: Align,\n     /// `true` if the allocation is mutable.\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n@@ -314,7 +315,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 &self.get_bytes(cx, ptr, size_with_null)?[..size]\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => throw_unsup!(UnterminatedCString(ptr.erase_tag())),\n+            None => throw_ub!(UnterminatedCString(ptr.erase_tag())),\n         })\n     }\n \n@@ -573,7 +574,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n         self.undef_mask\n             .is_range_defined(ptr.offset, ptr.offset + size)\n-            .or_else(|idx| throw_unsup!(ReadUndefBytes(idx)))\n+            .or_else(|idx| throw_ub!(InvalidUndefBytes(Some(Pointer::new(ptr.alloc_id, idx)))))\n     }\n \n     pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {"}, {"sha": "ff107a5f1e268990a327581b67711ddc079aef5a", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 117, "deletions": 186, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -1,7 +1,6 @@\n-use super::{CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n+use super::{AllocId, CheckInAllocMsg, Pointer, RawConst, ScalarMaybeUndef};\n \n use crate::hir::map::definitions::DefPathData;\n-use crate::mir;\n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::{Align, LayoutError, Size};\n use crate::ty::query::TyCtxtAt;\n@@ -14,8 +13,7 @@ use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n-use rustc_span::{Pos, Span};\n-use rustc_target::spec::abi::Abi;\n+use rustc_span::{def_id::DefId, Pos, Span};\n use std::{any::Any, fmt};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n@@ -296,6 +294,8 @@ pub enum InvalidProgramInfo<'tcx> {\n     TypeckError,\n     /// An error occurred during layout computation.\n     Layout(layout::LayoutError<'tcx>),\n+    /// An invalid transmute happened.\n+    TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n }\n \n impl fmt::Debug for InvalidProgramInfo<'_> {\n@@ -306,6 +306,11 @@ impl fmt::Debug for InvalidProgramInfo<'_> {\n             ReferencedConstant => write!(f, \"referenced constant has errors\"),\n             TypeckError => write!(f, \"encountered constants with type errors, stopping evaluation\"),\n             Layout(ref err) => write!(f, \"{}\", err),\n+            TransmuteSizeDiff(from_ty, to_ty) => write!(\n+                f,\n+                \"tried to transmute from {:?} to {:?}, but their sizes differed\",\n+                from_ty, to_ty\n+            ),\n         }\n     }\n }\n@@ -321,7 +326,10 @@ pub enum UndefinedBehaviorInfo {\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n     InvalidDiscriminant(ScalarMaybeUndef),\n     /// A slice/array index projection went out-of-bounds.\n-    BoundsCheckFailed { len: u64, index: u64 },\n+    BoundsCheckFailed {\n+        len: u64,\n+        index: u64,\n+    },\n     /// Something was divided by 0 (x / 0).\n     DivisionByZero,\n     /// Something was \"remainded\" by 0 (x % 0).\n@@ -330,6 +338,43 @@ pub enum UndefinedBehaviorInfo {\n     PointerArithOverflow,\n     /// Invalid metadata in a wide pointer (using `str` to avoid allocations).\n     InvalidMeta(&'static str),\n+    /// Reading a C string that does not end within its allocation.\n+    UnterminatedCString(Pointer),\n+    /// Dereferencing a dangling pointer after it got freed.\n+    PointerUseAfterFree(AllocId),\n+    /// Used a pointer outside the bounds it is valid for.\n+    PointerOutOfBounds {\n+        ptr: Pointer,\n+        msg: CheckInAllocMsg,\n+        allocation_size: Size,\n+    },\n+    /// Used a pointer with bad alignment.\n+    AlignmentCheckFailed {\n+        required: Align,\n+        has: Align,\n+    },\n+    /// Using an integer as a pointer in the wrong way.\n+    InvalidIntPointerUsage(u64),\n+    /// Writing to read-only memory.\n+    WriteToReadOnly(AllocId),\n+    /// Using a pointer-not-to-a-function as function pointer.\n+    InvalidFunctionPointer(Pointer),\n+    // Trying to access the data behind a function pointer.\n+    DerefFunctionPointer(AllocId),\n+    /// The value validity check found a problem.\n+    /// Should only be thrown by `validity.rs` and always point out which part of the value\n+    /// is the problem.\n+    ValidationFailure(String),\n+    /// Using a non-boolean `u8` as bool.\n+    InvalidBool(u8),\n+    /// Using a non-character `u32` as character.\n+    InvalidChar(u32),\n+    /// Using uninitialized data where it is not allowed.\n+    InvalidUndefBytes(Option<Pointer>),\n+    /// Working with a local that is not currently live.\n+    DeadLocal,\n+    /// Trying to read from the return place of a function.\n+    ReadFromReturnPlace,\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -348,6 +393,50 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n             RemainderByZero => write!(f, \"calculating the remainder with a divisor of zero\"),\n             PointerArithOverflow => write!(f, \"overflowing in-bounds pointer arithmetic\"),\n             InvalidMeta(msg) => write!(f, \"invalid metadata in wide pointer: {}\", msg),\n+            UnterminatedCString(p) => write!(\n+                f,\n+                \"reading a null-terminated string starting at {:?} with no null found before end of allocation\",\n+                p,\n+            ),\n+            PointerUseAfterFree(a) => {\n+                write!(f, \"pointer to {:?} was dereferenced after this allocation got freed\", a)\n+            }\n+            PointerOutOfBounds { ptr, msg, allocation_size } => write!(\n+                f,\n+                \"{} failed: pointer must be in-bounds at offset {}, \\\n+                           but is outside bounds of {} which has size {}\",\n+                msg,\n+                ptr.offset.bytes(),\n+                ptr.alloc_id,\n+                allocation_size.bytes()\n+            ),\n+            InvalidIntPointerUsage(0) => write!(f, \"invalid use of NULL pointer\"),\n+            InvalidIntPointerUsage(i) => write!(f, \"invalid use of {} as a pointer\", i),\n+            AlignmentCheckFailed { required, has } => write!(\n+                f,\n+                \"accessing memory with alignment {}, but alignment {} is required\",\n+                has.bytes(),\n+                required.bytes()\n+            ),\n+            WriteToReadOnly(a) => write!(f, \"writing to {:?} which is read-only\", a),\n+            InvalidFunctionPointer(p) => {\n+                write!(f, \"using {:?} as function pointer but it does not point to a function\", p)\n+            }\n+            DerefFunctionPointer(a) => write!(f, \"accessing {:?} which contains a function\", a),\n+            ValidationFailure(ref err) => write!(f, \"type validation failed: {}\", err),\n+            InvalidBool(b) => write!(f, \"interpreting an invalid 8-bit value as a bool: {}\", b),\n+            InvalidChar(c) => write!(f, \"interpreting an invalid 32-bit value as a char: {}\", c),\n+            InvalidUndefBytes(Some(p)) => write!(\n+                f,\n+                \"reading uninitialized memory at {:?}, but this operation requires initialized memory\",\n+                p\n+            ),\n+            InvalidUndefBytes(None) => write!(\n+                f,\n+                \"using uninitialized data, but this operation requires initialized memory\"\n+            ),\n+            DeadLocal => write!(f, \"accessing a dead local variable\"),\n+            ReadFromReturnPlace => write!(f, \"tried to read from the return place\"),\n         }\n     }\n }\n@@ -359,203 +448,45 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n ///\n /// Currently, we also use this as fall-back error kind for errors that have not been\n /// categorized yet.\n-pub enum UnsupportedOpInfo<'tcx> {\n+pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-\n     /// When const-prop encounters a situation it does not support, it raises this error.\n     /// This must not allocate for performance reasons (hence `str`, not `String`).\n     ConstPropUnsupported(&'static str),\n-\n-    // -- Everything below is not categorized yet --\n-    FunctionAbiMismatch(Abi, Abi),\n-    FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n-    FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n-    FunctionArgCountMismatch,\n-    UnterminatedCString(Pointer),\n-    DanglingPointerDeref,\n-    DoubleFree,\n-    InvalidMemoryAccess,\n-    InvalidFunctionPointer,\n-    InvalidBool,\n-    PointerOutOfBounds {\n-        ptr: Pointer,\n-        msg: CheckInAllocMsg,\n-        allocation_size: Size,\n-    },\n-    InvalidNullPointerUsage,\n+    /// Accessing an unsupported foreign static.\n+    ReadForeignStatic(DefId),\n+    /// Could not find MIR for a function.\n+    NoMirFor(DefId),\n+    /// Modified a static during const-eval.\n+    /// FIXME: move this to `ConstEvalErrKind` through a machine hook.\n+    ModifiedStatic,\n+    /// Encountered a pointer where we needed raw bytes.\n     ReadPointerAsBytes,\n+    /// Encountered raw bytes where we needed a pointer.\n     ReadBytesAsPointer,\n-    ReadForeignStatic,\n-    InvalidPointerMath,\n-    ReadUndefBytes(Size),\n-    DeadLocal,\n-    InvalidBoolOp(mir::BinOp),\n-    UnimplementedTraitSelection,\n-    CalledClosureAsFunction,\n-    NoMirFor(String),\n-    DerefFunctionPointer,\n-    ExecuteMemory,\n-    InvalidChar(u128),\n-    OutOfTls,\n-    TlsOutOfBounds,\n-    AlignmentCheckFailed {\n-        required: Align,\n-        has: Align,\n-    },\n-    ValidationFailure(String),\n-    VtableForArgumentlessMethod,\n-    ModifiedConstantMemory,\n-    ModifiedStatic,\n-    TypeNotPrimitive(Ty<'tcx>),\n-    ReallocatedWrongMemoryKind(String, String),\n-    DeallocatedWrongMemoryKind(String, String),\n-    ReallocateNonBasePtr,\n-    DeallocateNonBasePtr,\n-    IncorrectAllocationInformation(Size, Size, Align, Align),\n-    HeapAllocZeroBytes,\n-    HeapAllocNonPowerOfTwoAlignment(u64),\n-    ReadFromReturnPointer,\n-    PathNotFound(Vec<String>),\n-    TransmuteSizeDiff(Ty<'tcx>, Ty<'tcx>),\n }\n \n-impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n+impl fmt::Debug for UnsupportedOpInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use UnsupportedOpInfo::*;\n         match self {\n-            PointerOutOfBounds { ptr, msg, allocation_size } => write!(\n-                f,\n-                \"{} failed: pointer must be in-bounds at offset {}, \\\n-                           but is outside bounds of allocation {} which has size {}\",\n-                msg,\n-                ptr.offset.bytes(),\n-                ptr.alloc_id,\n-                allocation_size.bytes()\n-            ),\n-            ValidationFailure(ref err) => write!(f, \"type validation failed: {}\", err),\n-            NoMirFor(ref func) => write!(f, \"no MIR for `{}`\", func),\n-            FunctionAbiMismatch(caller_abi, callee_abi) => write!(\n-                f,\n-                \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n-                callee_abi, caller_abi\n-            ),\n-            FunctionArgMismatch(caller_ty, callee_ty) => write!(\n-                f,\n-                \"tried to call a function with argument of type {:?} \\\n-                           passing data of type {:?}\",\n-                callee_ty, caller_ty\n-            ),\n-            TransmuteSizeDiff(from_ty, to_ty) => write!(\n-                f,\n-                \"tried to transmute from {:?} to {:?}, but their sizes differed\",\n-                from_ty, to_ty\n-            ),\n-            FunctionRetMismatch(caller_ty, callee_ty) => write!(\n-                f,\n-                \"tried to call a function with return type {:?} \\\n-                           passing return place of type {:?}\",\n-                callee_ty, caller_ty\n-            ),\n-            FunctionArgCountMismatch => {\n-                write!(f, \"tried to call a function with incorrect number of arguments\")\n-            }\n-            ReallocatedWrongMemoryKind(ref old, ref new) => {\n-                write!(f, \"tried to reallocate memory from `{}` to `{}`\", old, new)\n-            }\n-            DeallocatedWrongMemoryKind(ref old, ref new) => {\n-                write!(f, \"tried to deallocate `{}` memory but gave `{}` as the kind\", old, new)\n-            }\n-            InvalidChar(c) => {\n-                write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c)\n-            }\n-            AlignmentCheckFailed { required, has } => write!(\n-                f,\n-                \"tried to access memory with alignment {}, but alignment {} is required\",\n-                has.bytes(),\n-                required.bytes()\n-            ),\n-            TypeNotPrimitive(ty) => write!(f, \"expected primitive type, got {}\", ty),\n-            PathNotFound(ref path) => write!(f, \"cannot find path {:?}\", path),\n-            IncorrectAllocationInformation(size, size2, align, align2) => write!(\n-                f,\n-                \"incorrect alloc info: expected size {} and align {}, \\\n-                           got size {} and align {}\",\n-                size.bytes(),\n-                align.bytes(),\n-                size2.bytes(),\n-                align2.bytes()\n-            ),\n-            InvalidMemoryAccess => write!(f, \"tried to access memory through an invalid pointer\"),\n-            DanglingPointerDeref => write!(f, \"dangling pointer was dereferenced\"),\n-            DoubleFree => write!(f, \"tried to deallocate dangling pointer\"),\n-            InvalidFunctionPointer => {\n-                write!(f, \"tried to use a function pointer after offsetting it\")\n-            }\n-            InvalidBool => write!(f, \"invalid boolean value read\"),\n-            InvalidNullPointerUsage => write!(f, \"invalid use of NULL pointer\"),\n-            ReadPointerAsBytes => write!(\n-                f,\n-                \"a raw memory access tried to access part of a pointer value as raw \\\n-                    bytes\"\n-            ),\n-            ReadBytesAsPointer => {\n-                write!(f, \"a memory access tried to interpret some bytes as a pointer\")\n-            }\n-            ReadForeignStatic => write!(f, \"tried to read from foreign (extern) static\"),\n-            InvalidPointerMath => write!(\n-                f,\n-                \"attempted to do invalid arithmetic on pointers that would leak base \\\n-                    addresses, e.g., comparing pointers into different allocations\"\n-            ),\n-            DeadLocal => write!(f, \"tried to access a dead local variable\"),\n-            DerefFunctionPointer => write!(f, \"tried to dereference a function pointer\"),\n-            ExecuteMemory => write!(f, \"tried to treat a memory pointer as a function pointer\"),\n-            OutOfTls => write!(f, \"reached the maximum number of representable TLS keys\"),\n-            TlsOutOfBounds => write!(f, \"accessed an invalid (unallocated) TLS key\"),\n-            CalledClosureAsFunction => {\n-                write!(f, \"tried to call a closure through a function pointer\")\n+            Unsupported(ref msg) => write!(f, \"{}\", msg),\n+            ConstPropUnsupported(ref msg) => {\n+                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n             }\n-            VtableForArgumentlessMethod => {\n-                write!(f, \"tried to call a vtable function without arguments\")\n+            ReadForeignStatic(did) => {\n+                write!(f, \"tried to read from foreign (extern) static {:?}\", did)\n             }\n-            ModifiedConstantMemory => write!(f, \"tried to modify constant memory\"),\n+            NoMirFor(did) => write!(f, \"could not load MIR for {:?}\", did),\n             ModifiedStatic => write!(\n                 f,\n                 \"tried to modify a static's initial value from another static's \\\n                     initializer\"\n             ),\n-            ReallocateNonBasePtr => write!(\n-                f,\n-                \"tried to reallocate with a pointer not to the beginning of an \\\n-                    existing object\"\n-            ),\n-            DeallocateNonBasePtr => write!(\n-                f,\n-                \"tried to deallocate with a pointer not to the beginning of an \\\n-                    existing object\"\n-            ),\n-            HeapAllocZeroBytes => write!(f, \"tried to re-, de- or allocate zero bytes on the heap\"),\n-            ReadFromReturnPointer => write!(f, \"tried to read from the return pointer\"),\n-            UnimplementedTraitSelection => {\n-                write!(f, \"there were unresolved type arguments during trait selection\")\n-            }\n-            InvalidBoolOp(_) => write!(f, \"invalid boolean operation\"),\n-            UnterminatedCString(_) => write!(\n-                f,\n-                \"attempted to get length of a null-terminated string, but no null \\\n-                    found before end of allocation\"\n-            ),\n-            ReadUndefBytes(_) => write!(f, \"attempted to read undefined bytes\"),\n-            HeapAllocNonPowerOfTwoAlignment(_) => write!(\n-                f,\n-                \"tried to re-, de-, or allocate heap memory with alignment that is \\\n-                    not a power of two\"\n-            ),\n-            Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ConstPropUnsupported(ref msg) => {\n-                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n-            }\n+\n+            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\",),\n+            ReadBytesAsPointer => write!(f, \"unable to turn bytes into a pointer\"),\n         }\n     }\n }\n@@ -590,7 +521,7 @@ pub enum InterpError<'tcx> {\n     UndefinedBehavior(UndefinedBehaviorInfo),\n     /// The program did something the interpreter does not support (some of these *might* be UB\n     /// but the interpreter is not sure).\n-    Unsupported(UnsupportedOpInfo<'tcx>),\n+    Unsupported(UnsupportedOpInfo),\n     /// The program was invalid (ill-typed, bad MIR, not sufficiently monomorphized, ...).\n     InvalidProgram(InvalidProgramInfo<'tcx>),\n     /// The program exhausted the interpreter's resources (stack/heap too big,\n@@ -606,7 +537,7 @@ pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n impl fmt::Display for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // Forward `Display` to `Debug`.\n-        write!(f, \"{:?}\", self)\n+        fmt::Debug::fmt(self, f)\n     }\n }\n \n@@ -631,7 +562,7 @@ impl InterpError<'_> {\n         match self {\n             InterpError::MachineStop(_)\n             | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n-            | InterpError::Unsupported(UnsupportedOpInfo::ValidationFailure(_))\n+            | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::UbExperimental(_)) => true,\n             _ => false,"}, {"sha": "0b5bb7f3c03faf01bfdb98dac9816587460418c1", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -161,7 +161,13 @@ pub struct AllocId(pub u64);\n \n impl fmt::Debug for AllocId {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"alloc{}\", self.0)\n+        fmt::Display::fmt(self, fmt)\n+    }\n+}\n+\n+impl fmt::Display for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"alloc{}\", self.0)\n     }\n }\n \n@@ -351,12 +357,6 @@ impl<'s> AllocDecodingSession<'s> {\n     }\n }\n \n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n-    }\n-}\n-\n /// An allocation in the global (tcx-managed) memory can be either a function pointer,\n /// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]"}, {"sha": "2cbe25f9674261e899319d537f8480ead7eda068", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -213,20 +213,4 @@ impl<'tcx, Tag> Pointer<Tag> {\n     pub fn erase_tag(self) -> Pointer {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n-\n-    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n-    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n-    /// a \"one-past-the-end\" pointer.\n-    #[inline(always)]\n-    pub fn check_inbounds_alloc(\n-        self,\n-        allocation_size: Size,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx, ()> {\n-        if self.offset > allocation_size {\n-            throw_unsup!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n-        } else {\n-            Ok(())\n-        }\n-    }\n }"}, {"sha": "04fe70b36c1e02bdd93c7f11d6e27ee26572a017", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -455,18 +455,19 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n-        match self {\n-            Scalar::Raw { data: 0, size: 1 } => Ok(false),\n-            Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => throw_unsup!(InvalidBool),\n+        let val = self.to_u8()?;\n+        match val {\n+            0 => Ok(false),\n+            1 => Ok(true),\n+            _ => throw_ub!(InvalidBool(val)),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => throw_unsup!(InvalidChar(val as u128)),\n+            None => throw_ub!(InvalidChar(val)),\n         }\n     }\n \n@@ -609,7 +610,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => throw_unsup!(ReadUndefBytes(Size::ZERO)),\n+            ScalarMaybeUndef::Undef => throw_ub!(InvalidUndefBytes(None)),\n         }\n     }\n "}, {"sha": "28889486c383b55150ced9e80d4c73fc60b31f21", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -240,7 +240,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n             Ok(body) => *body,\n             Err(err) => {\n-                if let err_unsup!(NoMirFor(ref path)) = err.kind {\n+                if let err_unsup!(NoMirFor(did)) = err.kind {\n+                    let path = ecx.tcx.def_path_str(did);\n                     return Err(ConstEvalErrKind::NeedsRfc(format!(\n                         \"calling extern function `{}`\",\n                         path"}, {"sha": "481719bfa8e6338c91f73a48a03f3b3c66d1f5d2", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -138,7 +138,7 @@ pub enum LocalValue<Tag = (), Id = AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => throw_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_ub!(DeadLocal),\n             LocalValue::Uninitialized => {\n                 bug!(\"The type checker should prevent reading from a never-written local\")\n             }\n@@ -152,7 +152,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => throw_unsup!(DeadLocal),\n+            LocalValue::Dead => throw_ub!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_))\n             | ref mut local @ LocalValue::Uninitialized => Ok(Ok(local)),\n@@ -326,7 +326,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if self.tcx.is_mir_available(did) {\n                     Ok(self.tcx.optimized_mir(did).unwrap_read_only())\n                 } else {\n-                    throw_unsup!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                    throw_unsup!(NoMirFor(def_id))\n                 }\n             }\n             _ => Ok(self.tcx.instance_mir(instance)),"}, {"sha": "90b8a4932991e2b44499c2a4105a257c4ecb1dba", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -327,7 +327,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         if let Err(error) = interned {\n             // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n             // to read enum discriminants in order to find references in enum variant fields.\n-            if let err_unsup!(ValidationFailure(_)) = error.kind {\n+            if let err_ub!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(\n                     ecx.tcx,\n@@ -390,7 +390,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n+            throw_ub_format!(\"encountered dangling pointer in final constant\")\n         } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n             // as dangling by local memory."}, {"sha": "03aedad0d988da39935fa9682b6d2aa807ea358b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -135,7 +135,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => throw_unsup!(TypeNotPrimitive(ty)),\n+                    _ => bug!(\"{} called on invalid type {:?}\", intrinsic_name, ty),\n                 };\n                 let (nonzero, intrinsic_name) = match intrinsic_name {\n                     sym::cttz_nonzero => (true, sym::cttz),\n@@ -246,9 +246,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val = self.force_bits(r.to_scalar()?, layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n-                        throw_ub_format!(\"Overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n+                        throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                     } else {\n-                        throw_ub_format!(\"Overflow executing `{}`\", intrinsic_name);\n+                        throw_ub_format!(\"overflow executing `{}`\", intrinsic_name);\n                     }\n                 }\n                 self.write_scalar(val, dest)?;"}, {"sha": "c9d32f6240037ee43691a0a5f568679bc98a1357", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -286,8 +286,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n-            err_unsup!(InvalidNullPointerUsage)\n+            // This is UB, seriously.\n+            err_ub!(InvalidIntPointerUsage(0))\n         } else {\n+            // This is just something we cannot support during const-eval.\n             err_unsup!(ReadBytesAsPointer)\n         })\n         .into())"}, {"sha": "5b2cd89a122845f13cd512465cdb60f8806e4968", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -215,7 +215,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(ReallocateNonBasePtr)\n+            throw_ub_format!(\n+                \"reallocating {:?} which does not point to the beginning of an object\",\n+                ptr\n+            );\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -251,37 +254,43 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(DeallocateNonBasePtr)\n+            throw_ub_format!(\n+                \"deallocating {:?} which does not point to the beginning of an object\",\n+                ptr\n+            );\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return Err(match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err_unsup!(DeallocatedWrongMemoryKind(\n-                        \"function\".to_string(),\n-                        format!(\"{:?}\", kind),\n-                    )),\n-                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => err_unsup!(\n-                        DeallocatedWrongMemoryKind(\"static\".to_string(), format!(\"{:?}\", kind))\n-                    ),\n-                    None => err_unsup!(DoubleFree),\n+                    Some(GlobalAlloc::Function(..)) => err_ub_format!(\"deallocating a function\"),\n+                    Some(GlobalAlloc::Static(..)) | Some(GlobalAlloc::Memory(..)) => {\n+                        err_ub_format!(\"deallocating static memory\")\n+                    }\n+                    None => err_ub!(PointerUseAfterFree(ptr.alloc_id)),\n                 }\n                 .into());\n             }\n         };\n \n         if alloc_kind != kind {\n-            throw_unsup!(DeallocatedWrongMemoryKind(\n-                format!(\"{:?}\", alloc_kind),\n-                format!(\"{:?}\", kind),\n-            ))\n+            throw_ub_format!(\n+                \"deallocating `{:?}` memory using `{:?}` deallocation operation\",\n+                alloc_kind,\n+                kind\n+            );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size || align != alloc.align {\n-                let bytes = alloc.size;\n-                throw_unsup!(IncorrectAllocationInformation(size, bytes, align, alloc.align))\n+                throw_ub_format!(\n+                    \"incorrect layout on deallocation: allocation has size {} and alignment {}, but gave size {} and alignment {}\",\n+                    alloc.size.bytes(),\n+                    alloc.align.bytes(),\n+                    size.bytes(),\n+                    align.bytes(),\n+                )\n             }\n         }\n \n@@ -338,7 +347,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_unsup!(AlignmentCheckFailed {\n+                throw_ub!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -360,7 +369,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL.\n                 if bits == 0 {\n-                    throw_unsup!(InvalidNullPointerUsage)\n+                    throw_ub!(InvalidIntPointerUsage(0))\n                 }\n                 // Must be aligned.\n                 if let Some(align) = align {\n@@ -375,7 +384,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_inbounds_alloc(allocation_size, msg)?;\n+                if end_ptr.offset > allocation_size {\n+                    // equal is okay!\n+                    throw_ub!(PointerOutOfBounds { ptr: end_ptr.erase_tag(), msg, allocation_size })\n+                }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -385,7 +397,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                         // got picked we might be aligned even if this check fails.\n                         // We instead have to fall back to converting to an integer and checking\n                         // the \"real\" alignment.\n-                        throw_unsup!(AlignmentCheckFailed { has: alloc_align, required: align });\n+                        throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n                     }\n                     check_offset_align(ptr.offset.bytes(), align)?;\n                 }\n@@ -402,7 +414,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let (size, _align) = self\n             .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        // If the pointer is out-of-bounds, it may be null.\n+        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+        ptr.offset > size\n     }\n }\n \n@@ -432,13 +446,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n             Some(GlobalAlloc::Memory(mem)) => Cow::Borrowed(mem),\n-            Some(GlobalAlloc::Function(..)) => throw_unsup!(DerefFunctionPointer),\n-            None => throw_unsup!(DanglingPointerDeref),\n+            Some(GlobalAlloc::Function(..)) => throw_ub!(DerefFunctionPointer(id)),\n+            None => throw_ub!(PointerUseAfterFree(id)),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n                     trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n-                    throw_unsup!(ReadForeignStatic)\n+                    throw_unsup!(ReadForeignStatic(def_id))\n                 }\n                 trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n                 let instance = Instance::mono(tcx.tcx, def_id);\n@@ -524,7 +538,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Not {\n-                throw_unsup!(ModifiedConstantMemory)\n+                throw_ub!(WriteToReadOnly(id))\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n@@ -538,7 +552,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Not {\n-                    throw_unsup!(ModifiedConstantMemory)\n+                    throw_ub!(WriteToReadOnly(id))\n                 }\n                 Ok(a)\n             }\n@@ -568,7 +582,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if self.get_fn_alloc(id).is_some() {\n             return if let AllocCheck::Dereferenceable = liveness {\n                 // The caller requested no function pointers.\n-                throw_unsup!(DerefFunctionPointer)\n+                throw_ub!(DerefFunctionPointer(id))\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -596,12 +610,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 if let AllocCheck::MaybeDead = liveness {\n                     // Deallocated pointers are allowed, we should be able to find\n                     // them in the map.\n-                    Ok(*self.dead_alloc_map.get(&id).expect(\n-                        \"deallocated pointers should all be recorded in \\\n-                            `dead_alloc_map`\",\n-                    ))\n+                    Ok(*self\n+                        .dead_alloc_map\n+                        .get(&id)\n+                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n                 } else {\n-                    throw_unsup!(DanglingPointerDeref)\n+                    throw_ub!(PointerUseAfterFree(id))\n                 }\n             }\n         }\n@@ -626,10 +640,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            throw_unsup!(InvalidFunctionPointer)\n+            throw_ub!(InvalidFunctionPointer(ptr.erase_tag()))\n         }\n         let id = M::canonical_alloc_id(self, ptr.alloc_id);\n-        self.get_fn_alloc(id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n+        self.get_fn_alloc(id).ok_or_else(|| err_ub!(InvalidFunctionPointer(ptr.erase_tag())).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "316cf2ee41918fe067a04fec8c4b97300e3b780c", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -343,7 +343,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| err_unsup!(ValidationFailure(err.to_string())))?;\n+            .map_err(|err| err_ub_format!(\"this string is not valid UTF-8: {}\", err))?;\n         Ok(str)\n     }\n \n@@ -457,7 +457,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base_op = match place.local {\n-            mir::RETURN_PLACE => throw_unsup!(ReadFromReturnPointer),\n+            mir::RETURN_PLACE => throw_ub!(ReadFromReturnPlace),\n             local => {\n                 // Do not use the layout passed in as argument if the base we are looking at\n                 // here is not the entire place."}, {"sha": "107cfee5aceb50f6b3ecb21887ee8e82de138a8b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -926,7 +926,7 @@ where\n             // most likey we *are* running `typeck` right now. Investigate whether we can bail out\n             // on `typeck_tables().has_errors` at all const eval entry points.\n             debug!(\"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n-            throw_unsup!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n+            throw_inval!(TransmuteSizeDiff(src.layout.ty, dest.layout.ty));\n         }\n         // Unsized copies rely on interpreting `src.meta` with `dest.layout`, we want\n         // to avoid that here."}, {"sha": "22a081a9c8e0be9af49b682c8dbe25ad83b560c5", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 109, "deletions": 101, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -172,13 +172,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             trace!(\"Skipping callee ZST\");\n             return Ok(());\n         }\n-        let caller_arg = caller_arg.next().ok_or_else(|| err_unsup!(FunctionArgCountMismatch))?;\n+        let caller_arg = caller_arg.next().ok_or_else(|| {\n+            err_ub_format!(\"calling a function with fewer arguments than it requires\")\n+        })?;\n         if rust_abi {\n             assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            throw_unsup!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n+            throw_ub_format!(\n+                \"calling a function with argument of type {:?} passing data of type {:?}\",\n+                callee_arg.layout.ty,\n+                caller_arg.layout.ty\n+            )\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -223,7 +229,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 abi => abi,\n             };\n             if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                throw_unsup!(FunctionAbiMismatch(caller_abi, callee_abi))\n+                throw_ub_format!(\n+                    \"calling a function with ABI {:?} using caller ABI {:?}\",\n+                    callee_abi,\n+                    caller_abi\n+                )\n             }\n         }\n \n@@ -253,110 +263,108 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     StackPopCleanup::Goto { ret: ret.map(|p| p.1), unwind },\n                 )?;\n \n-                // We want to pop this frame again in case there was an error, to put\n-                // the blame in the right location.  Until the 2018 edition is used in\n-                // the compiler, we have to do this with an immediately invoked function.\n-                let res =\n-                    (|| {\n-                        trace!(\n-                            \"caller ABI: {:?}, args: {:#?}\",\n-                            caller_abi,\n-                            args.iter()\n-                                .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n-                                .collect::<Vec<_>>()\n-                        );\n-                        trace!(\n-                            \"spread_arg: {:?}, locals: {:#?}\",\n-                            body.spread_arg,\n-                            body.args_iter()\n-                                .map(|local| (\n-                                    local,\n-                                    self.layout_of_local(self.frame(), local, None).unwrap().ty\n-                                ))\n-                                .collect::<Vec<_>>()\n-                        );\n-\n-                        // Figure out how to pass which arguments.\n-                        // The Rust ABI is special: ZST get skipped.\n-                        let rust_abi = match caller_abi {\n-                            Abi::Rust | Abi::RustCall => true,\n-                            _ => false,\n+                // If an error is raised here, pop the frame again to get an accurate backtrace.\n+                // To this end, we wrap it all in a `try` block.\n+                let res: InterpResult<'tcx> = try {\n+                    trace!(\n+                        \"caller ABI: {:?}, args: {:#?}\",\n+                        caller_abi,\n+                        args.iter()\n+                            .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                            .collect::<Vec<_>>()\n+                    );\n+                    trace!(\n+                        \"spread_arg: {:?}, locals: {:#?}\",\n+                        body.spread_arg,\n+                        body.args_iter()\n+                            .map(|local| (\n+                                local,\n+                                self.layout_of_local(self.frame(), local, None).unwrap().ty\n+                            ))\n+                            .collect::<Vec<_>>()\n+                    );\n+\n+                    // Figure out how to pass which arguments.\n+                    // The Rust ABI is special: ZST get skipped.\n+                    let rust_abi = match caller_abi {\n+                        Abi::Rust | Abi::RustCall => true,\n+                        _ => false,\n+                    };\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n+\n+                    // For where they come from: If the ABI is RustCall, we untuple the\n+                    // last incoming argument.  These two iterators do not have the same type,\n+                    // so to keep the code paths uniform we accept an allocation\n+                    // (for RustCall ABI only).\n+                    let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n+                        if caller_abi == Abi::RustCall && !args.is_empty() {\n+                            // Untuple\n+                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                            Cow::from(\n+                                args.iter()\n+                                    .map(|&a| Ok(a))\n+                                    .chain(\n+                                        (0..untuple_arg.layout.fields.count())\n+                                            .map(|i| self.operand_field(untuple_arg, i as u64)),\n+                                    )\n+                                    .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>(\n+                                    )?,\n+                            )\n+                        } else {\n+                            // Plain arg passing\n+                            Cow::from(args)\n                         };\n-                        // We have two iterators: Where the arguments come from,\n-                        // and where they go to.\n-\n-                        // For where they come from: If the ABI is RustCall, we untuple the\n-                        // last incoming argument.  These two iterators do not have the same type,\n-                        // so to keep the code paths uniform we accept an allocation\n-                        // (for RustCall ABI only).\n-                        let caller_args: Cow<'_, [OpTy<'tcx, M::PointerTag>]> =\n-                            if caller_abi == Abi::RustCall && !args.is_empty() {\n-                                // Untuple\n-                                let (&untuple_arg, args) = args.split_last().unwrap();\n-                                trace!(\"eval_fn_call: Will pass last argument by untupling\");\n-                                Cow::from(args.iter().map(|&a| Ok(a))\n-                                .chain((0..untuple_arg.layout.fields.count())\n-                                    .map(|i| self.operand_field(untuple_arg, i as u64))\n-                                )\n-                                .collect::<InterpResult<'_, Vec<OpTy<'tcx, M::PointerTag>>>>()?)\n-                            } else {\n-                                // Plain arg passing\n-                                Cow::from(args)\n-                            };\n-                        // Skip ZSTs\n-                        let mut caller_iter = caller_args\n-                            .iter()\n-                            .filter(|op| !rust_abi || !op.layout.is_zst())\n-                            .copied();\n-\n-                        // Now we have to spread them out across the callee's locals,\n-                        // taking into account the `spread_arg`.  If we could write\n-                        // this is a single iterator (that handles `spread_arg`), then\n-                        // `pass_argument` would be the loop body. It takes care to\n-                        // not advance `caller_iter` for ZSTs\n-                        for local in body.args_iter() {\n-                            let dest = self.eval_place(&mir::Place::from(local))?;\n-                            if Some(local) == body.spread_arg {\n-                                // Must be a tuple\n-                                for i in 0..dest.layout.fields.count() {\n-                                    let dest = self.place_field(dest, i as u64)?;\n-                                    self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n-                                }\n-                            } else {\n-                                // Normal argument\n+                    // Skip ZSTs\n+                    let mut caller_iter =\n+                        caller_args.iter().filter(|op| !rust_abi || !op.layout.is_zst()).copied();\n+\n+                    // Now we have to spread them out across the callee's locals,\n+                    // taking into account the `spread_arg`.  If we could write\n+                    // this is a single iterator (that handles `spread_arg`), then\n+                    // `pass_argument` would be the loop body. It takes care to\n+                    // not advance `caller_iter` for ZSTs.\n+                    for local in body.args_iter() {\n+                        let dest = self.eval_place(&mir::Place::from(local))?;\n+                        if Some(local) == body.spread_arg {\n+                            // Must be a tuple\n+                            for i in 0..dest.layout.fields.count() {\n+                                let dest = self.place_field(dest, i as u64)?;\n                                 self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                             }\n+                        } else {\n+                            // Normal argument\n+                            self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n                         }\n-                        // Now we should have no more caller args\n-                        if caller_iter.next().is_some() {\n-                            trace!(\"Caller has passed too many args\");\n-                            throw_unsup!(FunctionArgCountMismatch)\n+                    }\n+                    // Now we should have no more caller args\n+                    if caller_iter.next().is_some() {\n+                        throw_ub_format!(\"calling a function with more arguments than it expected\")\n+                    }\n+                    // Don't forget to check the return type!\n+                    if let Some((caller_ret, _)) = ret {\n+                        let callee_ret = self.eval_place(&mir::Place::return_place())?;\n+                        if !Self::check_argument_compat(\n+                            rust_abi,\n+                            caller_ret.layout,\n+                            callee_ret.layout,\n+                        ) {\n+                            throw_ub_format!(\n+                                \"calling a function with return type {:?} passing \\\n+                                     return place of type {:?}\",\n+                                callee_ret.layout.ty,\n+                                caller_ret.layout.ty\n+                            )\n                         }\n-                        // Don't forget to check the return type!\n-                        if let Some((caller_ret, _)) = ret {\n-                            let callee_ret = self.eval_place(&mir::Place::return_place())?;\n-                            if !Self::check_argument_compat(\n-                                rust_abi,\n-                                caller_ret.layout,\n-                                callee_ret.layout,\n-                            ) {\n-                                throw_unsup!(FunctionRetMismatch(\n-                                    caller_ret.layout.ty,\n-                                    callee_ret.layout.ty\n-                                ))\n-                            }\n-                        } else {\n-                            let local = mir::RETURN_PLACE;\n-                            let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n-                            if !callee_layout.abi.is_uninhabited() {\n-                                throw_unsup!(FunctionRetMismatch(\n-                                    self.tcx.types.never,\n-                                    callee_layout.ty\n-                                ))\n-                            }\n+                    } else {\n+                        let local = mir::RETURN_PLACE;\n+                        let callee_layout = self.layout_of_local(self.frame(), local, None)?;\n+                        if !callee_layout.abi.is_uninhabited() {\n+                            throw_ub_format!(\"calling a returning function without a return place\")\n                         }\n-                        Ok(())\n-                    })();\n+                    }\n+                };\n                 match res {\n                     Err(err) => {\n                         self.stack.pop();"}, {"sha": "d93b78a5bd5b618b5c47a644355ddab06e48f787", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -29,7 +29,7 @@ macro_rules! throw_validation_failure {\n             write_path(&mut msg, where_);\n         }\n         write!(&mut msg, \", but expected {}\", $details).unwrap();\n-        throw_unsup!(ValidationFailure(msg))\n+        throw_ub!(ValidationFailure(msg))\n     }};\n     ($what:expr, $where:expr) => {{\n         let mut msg = format!(\"encountered {}\", $what);\n@@ -38,7 +38,7 @@ macro_rules! throw_validation_failure {\n             msg.push_str(\" at \");\n             write_path(&mut msg, where_);\n         }\n-        throw_unsup!(ValidationFailure(msg))\n+        throw_ub!(ValidationFailure(msg))\n     }};\n }\n \n@@ -353,31 +353,39 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     place.ptr, size, align\n                 );\n                 match err.kind {\n-                    err_unsup!(InvalidNullPointerUsage) => {\n+                    err_ub!(InvalidIntPointerUsage(0)) => {\n                         throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n                     }\n-                    err_unsup!(AlignmentCheckFailed { required, has }) => {\n-                        throw_validation_failure!(\n-                            format_args!(\n-                                \"an unaligned {} \\\n-                                    (required {} byte alignment but found {})\",\n-                                kind,\n-                                required.bytes(),\n-                                has.bytes()\n-                            ),\n-                            self.path\n-                        )\n-                    }\n+                    err_ub!(InvalidIntPointerUsage(i)) => throw_validation_failure!(\n+                        format_args!(\"a {} to unallocated address {}\", kind, i),\n+                        self.path\n+                    ),\n+                    err_ub!(AlignmentCheckFailed { required, has }) => throw_validation_failure!(\n+                        format_args!(\n+                            \"an unaligned {} (required {} byte alignment but found {})\",\n+                            kind,\n+                            required.bytes(),\n+                            has.bytes()\n+                        ),\n+                        self.path\n+                    ),\n                     err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n                         format_args!(\"a dangling {} (created from integer)\", kind),\n                         self.path\n                     ),\n-                    err_unsup!(PointerOutOfBounds { .. }) | err_unsup!(DanglingPointerDeref) => {\n-                        throw_validation_failure!(\n-                            format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n-                            self.path\n-                        )\n-                    }\n+                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(\n+                        format_args!(\n+                            \"a dangling {} (going beyond the bounds of its allocation)\",\n+                            kind\n+                        ),\n+                        self.path\n+                    ),\n+                    // This cannot happen during const-eval (because interning already detects\n+                    // dangling pointers), but it can happen in Miri.\n+                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(\n+                        format_args!(\"a dangling {} (use-after-free)\", kind),\n+                        self.path\n+                    ),\n                     _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n                 }\n             }\n@@ -765,11 +773,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            err_unsup!(ReadUndefBytes(offset)) => {\n+                            err_ub!(InvalidUndefBytes(Some(ptr))) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index.\n-                                let i = (offset.bytes() / layout.size.bytes()) as usize;\n+                                let i = (ptr.offset.bytes() / layout.size.bytes()) as usize;\n                                 self.path.push(PathElem::ArrayElem(i));\n \n                                 throw_validation_failure!(\"undefined bytes\", self.path)\n@@ -817,7 +825,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Run it.\n         match visitor.visit_value(op) {\n             Ok(()) => Ok(()),\n-            Err(err) if matches!(err.kind, err_unsup!(ValidationFailure { .. })) => Err(err),\n+            Err(err) if matches!(err.kind, err_ub!(ValidationFailure { .. })) => Err(err),\n             Err(err) if cfg!(debug_assertions) => {\n                 bug!(\"Unexpected error during validation: {}\", err)\n             }"}, {"sha": "305f259eac22dc38832040e15a79ede2a75ca89d", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -12,7 +12,7 @@ error: any use of this value will cause an error\n LL |     const I32_REF_U8_UNION: u8 = unsafe { Nonsense { int_32_ref: &3 }.uint_8 };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n    |\n    = note: `#[deny(const_err)]` on by default\n \n@@ -22,15 +22,15 @@ error: any use of this value will cause an error\n LL |     const I32_REF_U16_UNION: u16 = unsafe { Nonsense { int_32_ref: &3 }.uint_16 };\n    |     ----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                             |\n-   |                                             a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                             unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:34:45\n    |\n LL |     const I32_REF_U32_UNION: u32 = unsafe { Nonsense { int_32_ref: &3 }.uint_32 };\n    |     ----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                             |\n-   |                                             a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                             unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:37:5\n@@ -54,23 +54,23 @@ error: any use of this value will cause an error\n LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:46:45\n    |\n LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int_16 };\n    |     ----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                             |\n-   |                                             a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                             unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:49:45\n    |\n LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int_32 };\n    |     ----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                             |\n-   |                                             a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                             unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:52:5\n@@ -94,7 +94,7 @@ error: any use of this value will cause an error\n LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n    |     ----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                             |\n-   |                                             a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                             unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:61:5\n@@ -110,39 +110,39 @@ error: any use of this value will cause an error\n LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.truthy_falsey };\n    |     ------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                               |\n-   |                                               a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                               unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:67:47\n    |\n LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.character };\n    |     ------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                               |\n-   |                                               a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                               unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:70:39\n    |\n LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    |     ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                       |\n-   |                                       a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                       unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:73:41\n    |\n LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 };\n    |     ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                         |\n-   |                                         a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                         unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:76:41\n    |\n LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 };\n    |     ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                         |\n-   |                                         a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                         unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:79:5\n@@ -158,31 +158,31 @@ error: any use of this value will cause an error\n LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_128 };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:85:39\n    |\n LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    |     ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                       |\n-   |                                       a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                       unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:88:41\n    |\n LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    |     ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                         |\n-   |                                         a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                         unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:91:41\n    |\n LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    |     ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                         |\n-   |                                         a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                         unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:94:5\n@@ -198,15 +198,15 @@ error: any use of this value will cause an error\n LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128 };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:100:41\n    |\n LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32 };\n    |     ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                         |\n-   |                                         a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                         unable to turn pointer into raw bytes\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/const-pointer-values-in-various-types.rs:103:5\n@@ -222,15 +222,15 @@ error: any use of this value will cause an error\n LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_falsey };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n \n error: any use of this value will cause an error\n   --> $DIR/const-pointer-values-in-various-types.rs:109:43\n    |\n LL |     const STR_CHAR_UNION: char = unsafe { Nonsense { stringy: \"3\" }.character };\n    |     --------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                           |\n-   |                                           a raw memory access tried to access part of a pointer value as raw bytes\n+   |                                           unable to turn pointer into raw bytes\n \n error: aborting due to 29 previous errors\n "}, {"sha": "cc40728e6b574afa577f8f59cead2455a48782ee", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -30,15 +30,15 @@ error: any use of this value will cause an error\n LL | const Z2: i32 = unsafe { *(42 as *const i32) };\n    | -------------------------^^^^^^^^^^^^^^^^^^^---\n    |                          |\n-   |                          a memory access tried to interpret some bytes as a pointer\n+   |                          unable to turn bytes into a pointer\n \n error: any use of this value will cause an error\n   --> $DIR/const_raw_ptr_ops.rs:17:26\n    |\n LL | const Z3: i32 = unsafe { *(44 as *const i32) };\n    | -------------------------^^^^^^^^^^^^^^^^^^^---\n    |                          |\n-   |                          a memory access tried to interpret some bytes as a pointer\n+   |                          unable to turn bytes into a pointer\n \n error: aborting due to 5 previous errors\n "}, {"sha": "798f130a4baf6fb1bfa2c39afd888d2da3afcad3", "filename": "src/test/ui/consts/const-eval/issue-49296.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | const X: u64 = *wat(42);\n    | ---------------^^^^^^^^-\n    |                |\n-   |                dangling pointer was dereferenced\n+   |                pointer to alloc2 was dereferenced after this allocation got freed\n    |\n    = note: `#[deny(const_err)]` on by default\n "}, {"sha": "adad1b4f7fafe3006be2b5a38a7c446f0d20983d", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -13,7 +13,7 @@ LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n-   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of allocation 8 which has size 1\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc8 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n    | |____-"}, {"sha": "0200bfe9f08f870f1fbdf43431ec9d25b8f16408", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -6,7 +6,7 @@\n use std::mem;\n \n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n-// normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\"\n \n #[repr(C)]"}, {"sha": "80e60dbb58a5d6adf5f74cc191158f2a3b218c36", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:32:1\n    |\n LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -70,7 +70,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:62:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -86,7 +86,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-wide-ptr.rs:68:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (not entirely in bounds)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (going beyond the bounds of its allocation)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -192,7 +192,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ub-wide-ptr.rs:125:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocN which has size N\n \n error: aborting due to 24 previous errors\n "}, {"sha": "cf70454b6bf9eb28399144cf5fa761b4f4d9c135", "filename": "src/test/ui/consts/const-int-unchecked.stderr", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-unchecked.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | const SHL_U8: u8 = unsafe { intrinsics::unchecked_shl(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in `unchecked_shl`\n+   |                             overflowing shift by 8 in `unchecked_shl`\n    |\n    = note: `#[deny(const_err)]` on by default\n \n@@ -14,335 +14,335 @@ error: any use of this value will cause an error\n LL | const SHL_U16: u16 = unsafe { intrinsics::unchecked_shl(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in `unchecked_shl`\n+   |                               overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:19:31\n    |\n LL | const SHL_U32: u32 = unsafe { intrinsics::unchecked_shl(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in `unchecked_shl`\n+   |                               overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:21:31\n    |\n LL | const SHL_U64: u64 = unsafe { intrinsics::unchecked_shl(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in `unchecked_shl`\n+   |                               overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:23:33\n    |\n LL | const SHL_U128: u128 = unsafe { intrinsics::unchecked_shl(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in `unchecked_shl`\n+   |                                 overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:28:29\n    |\n LL | const SHL_I8: i8 = unsafe { intrinsics::unchecked_shl(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in `unchecked_shl`\n+   |                             overflowing shift by 8 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:30:31\n    |\n LL | const SHL_I16: i16 = unsafe { intrinsics::unchecked_shl(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in `unchecked_shl`\n+   |                               overflowing shift by 16 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:32:31\n    |\n LL | const SHL_I32: i32 = unsafe { intrinsics::unchecked_shl(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in `unchecked_shl`\n+   |                               overflowing shift by 32 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:34:31\n    |\n LL | const SHL_I64: i64 = unsafe { intrinsics::unchecked_shl(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in `unchecked_shl`\n+   |                               overflowing shift by 64 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:36:33\n    |\n LL | const SHL_I128: i128 = unsafe { intrinsics::unchecked_shl(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in `unchecked_shl`\n+   |                                 overflowing shift by 128 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:41:33\n    |\n LL | const SHL_I8_NEG: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 255 in `unchecked_shl`\n+   |                                 overflowing shift by 255 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:43:35\n    |\n LL | const SHL_I16_NEG: i16 = unsafe { intrinsics::unchecked_shl(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 65535 in `unchecked_shl`\n+   |                                   overflowing shift by 65535 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:45:35\n    |\n LL | const SHL_I32_NEG: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 4294967295 in `unchecked_shl`\n+   |                                   overflowing shift by 4294967295 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:47:35\n    |\n LL | const SHL_I64_NEG: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 18446744073709551615 in `unchecked_shl`\n+   |                                   overflowing shift by 18446744073709551615 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:49:37\n    |\n LL | const SHL_I128_NEG: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n-   |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shl`\n+   |                                     overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:55:40\n    |\n LL | const SHL_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shl(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n-   |                                        Overflowing shift by 250 in `unchecked_shl`\n+   |                                        overflowing shift by 250 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:57:42\n    |\n LL | const SHL_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shl(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 65523 in `unchecked_shl`\n+   |                                          overflowing shift by 65523 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:59:42\n    |\n LL | const SHL_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shl(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 4294967271 in `unchecked_shl`\n+   |                                          overflowing shift by 4294967271 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:61:42\n    |\n LL | const SHL_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shl(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 18446744073709551586 in `unchecked_shl`\n+   |                                          overflowing shift by 18446744073709551586 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:63:44\n    |\n LL | const SHL_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shl(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n-   |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shl`\n+   |                                            overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shl`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:70:29\n    |\n LL | const SHR_U8: u8 = unsafe { intrinsics::unchecked_shr(5_u8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in `unchecked_shr`\n+   |                             overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:72:31\n    |\n LL | const SHR_U16: u16 = unsafe { intrinsics::unchecked_shr(5_u16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in `unchecked_shr`\n+   |                               overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:74:31\n    |\n LL | const SHR_U32: u32 = unsafe { intrinsics::unchecked_shr(5_u32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in `unchecked_shr`\n+   |                               overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:76:31\n    |\n LL | const SHR_U64: u64 = unsafe { intrinsics::unchecked_shr(5_u64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in `unchecked_shr`\n+   |                               overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:78:33\n    |\n LL | const SHR_U128: u128 = unsafe { intrinsics::unchecked_shr(5_u128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in `unchecked_shr`\n+   |                                 overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:83:29\n    |\n LL | const SHR_I8: i8 = unsafe { intrinsics::unchecked_shr(5_i8, 8) };\n    | ----------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                             |\n-   |                             Overflowing shift by 8 in `unchecked_shr`\n+   |                             overflowing shift by 8 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:85:31\n    |\n LL | const SHR_I16: i16 = unsafe { intrinsics::unchecked_shr(5_16, 16) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 16 in `unchecked_shr`\n+   |                               overflowing shift by 16 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:87:31\n    |\n LL | const SHR_I32: i32 = unsafe { intrinsics::unchecked_shr(5_i32, 32) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 32 in `unchecked_shr`\n+   |                               overflowing shift by 32 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:89:31\n    |\n LL | const SHR_I64: i64 = unsafe { intrinsics::unchecked_shr(5_i64, 64) };\n    | ------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                               |\n-   |                               Overflowing shift by 64 in `unchecked_shr`\n+   |                               overflowing shift by 64 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:91:33\n    |\n LL | const SHR_I128: i128 = unsafe { intrinsics::unchecked_shr(5_i128, 128) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 128 in `unchecked_shr`\n+   |                                 overflowing shift by 128 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:96:33\n    |\n LL | const SHR_I8_NEG: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -1) };\n    | --------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                 |\n-   |                                 Overflowing shift by 255 in `unchecked_shr`\n+   |                                 overflowing shift by 255 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:98:35\n    |\n LL | const SHR_I16_NEG: i16 = unsafe { intrinsics::unchecked_shr(5_16, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 65535 in `unchecked_shr`\n+   |                                   overflowing shift by 65535 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:100:35\n    |\n LL | const SHR_I32_NEG: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 4294967295 in `unchecked_shr`\n+   |                                   overflowing shift by 4294967295 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:102:35\n    |\n LL | const SHR_I64_NEG: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -1) };\n    | ----------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                   |\n-   |                                   Overflowing shift by 18446744073709551615 in `unchecked_shr`\n+   |                                   overflowing shift by 18446744073709551615 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:104:37\n    |\n LL | const SHR_I128_NEG: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -1) };\n    | ------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                     |\n-   |                                     Overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shr`\n+   |                                     overflowing shift by 340282366920938463463374607431768211455 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:110:40\n    |\n LL | const SHR_I8_NEG_RANDOM: i8 = unsafe { intrinsics::unchecked_shr(5_i8, -6) };\n    | ---------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                        |\n-   |                                        Overflowing shift by 250 in `unchecked_shr`\n+   |                                        overflowing shift by 250 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:112:42\n    |\n LL | const SHR_I16_NEG_RANDOM: i16 = unsafe { intrinsics::unchecked_shr(5_16, -13) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 65523 in `unchecked_shr`\n+   |                                          overflowing shift by 65523 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:114:42\n    |\n LL | const SHR_I32_NEG_RANDOM: i32 = unsafe { intrinsics::unchecked_shr(5_i32, -25) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 4294967271 in `unchecked_shr`\n+   |                                          overflowing shift by 4294967271 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:116:42\n    |\n LL | const SHR_I64_NEG_RANDOM: i64 = unsafe { intrinsics::unchecked_shr(5_i64, -30) };\n    | -----------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                          |\n-   |                                          Overflowing shift by 18446744073709551586 in `unchecked_shr`\n+   |                                          overflowing shift by 18446744073709551586 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:118:44\n    |\n LL | const SHR_I128_NEG_RANDOM: i128 = unsafe { intrinsics::unchecked_shr(5_i128, -93) };\n    | -------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                                            |\n-   |                                            Overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shr`\n+   |                                            overflowing shift by 340282366920938463463374607431768211363 in `unchecked_shr`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:123:25\n    |\n LL | const _: u16 = unsafe { std::intrinsics::unchecked_add(40000u16, 30000) };\n    | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n-   |                         Overflow executing `unchecked_add`\n+   |                         overflow executing `unchecked_add`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:126:25\n    |\n LL | const _: u32 = unsafe { std::intrinsics::unchecked_sub(14u32, 22) };\n    | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n-   |                         Overflow executing `unchecked_sub`\n+   |                         overflow executing `unchecked_sub`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:129:25\n    |\n LL | const _: u16 = unsafe { std::intrinsics::unchecked_mul(300u16, 250u16) };\n    | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n-   |                         Overflow executing `unchecked_mul`\n+   |                         overflow executing `unchecked_mul`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:132:25\n@@ -358,7 +358,7 @@ error: any use of this value will cause an error\n LL | const _: i32 = unsafe { std::intrinsics::unchecked_div(i32::min_value(), -1) };\n    | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n-   |                         Overflow executing `unchecked_div`\n+   |                         overflow executing `unchecked_div`\n \n error: any use of this value will cause an error\n   --> $DIR/const-int-unchecked.rs:137:25\n@@ -374,7 +374,7 @@ error: any use of this value will cause an error\n LL | const _: i32 = unsafe { std::intrinsics::unchecked_rem(i32::min_value(), -1) };\n    | ------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n    |                         |\n-   |                         Overflow executing `unchecked_rem`\n+   |                         overflow executing `unchecked_rem`\n \n error: aborting due to 47 previous errors\n "}, {"sha": "0e213555052c85f683416846a706c2754b3185f3", "filename": "src/test/ui/consts/dangling-alloc-id-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -5,7 +5,7 @@ LL | / const FOO: &() = {\n LL | |     let y = ();\n LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n LL | | };\n-   | |__^ type validation failed: encountered dangling pointer in final constant\n+   | |__^ encountered dangling pointer in final constant\n    |\n    = note: `#[deny(const_err)]` on by default\n "}, {"sha": "4d4c2876c4598afad2d7ddd75fa4853c1ca724c1", "filename": "src/test/ui/consts/dangling_raw_ptr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -5,7 +5,7 @@ LL | / const FOO: *const u32 = {\n LL | |     let x = 42;\n LL | |     &x\n LL | | };\n-   | |__^ type validation failed: encountered dangling pointer in final constant\n+   | |__^ encountered dangling pointer in final constant\n    |\n    = note: `#[deny(const_err)]` on by default\n "}, {"sha": "c7e902132e91ad5a3d29d4c3f7378ab194383b2d", "filename": "src/test/ui/consts/miri_unleashed/abi-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fabi-mismatch.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -16,7 +16,7 @@ error: any use of this value will cause an error\n LL |     my_fn();\n    |     ^^^^^^^\n    |     |\n-   |     tried to call a function with ABI C using caller ABI Rust\n+   |     calling a function with ABI C using caller ABI Rust\n    |     inside call to `call_rust_fn` at $DIR/abi-mismatch.rs:13:17\n ...\n LL | const VAL: () = call_rust_fn(unsafe { std::mem::transmute(c_fn as extern \"C\" fn()) });"}, {"sha": "8456e8ec6870dcd4c0d2204b8e8ac737bfb662d7", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -11,7 +11,7 @@ LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n LL | |     unsafe {\n LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ tried to modify constant memory\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc1 which is read-only\n LL | |     }\n LL | | };\n    | |__-"}, {"sha": "217530740079f2c6af474bab77fe2d0d908056ce", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -26,7 +26,7 @@ error: any use of this value will cause an error\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n-   |           a memory access tried to interpret some bytes as a pointer\n+   |           unable to turn bytes into a pointer\n    |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:28:14\n    | \n   ::: $DIR/offset_from_ub.rs:26:1\n@@ -81,7 +81,7 @@ error: any use of this value will cause an error\n LL |           intrinsics::ptr_offset_from(self, origin)\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |           |\n-   |           a memory access tried to interpret some bytes as a pointer\n+   |           unable to turn bytes into a pointer\n    |           inside call to `std::ptr::const_ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:49:14\n    | \n   ::: $DIR/offset_from_ub.rs:45:1"}, {"sha": "685055525627ee7a8436e0d2301cb988f59fc8ae", "filename": "src/test/ui/error-codes/E0396-fixed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a958314472f07a71e6d2e59d8dbf73f9edee70c5/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0396-fixed.stderr?ref=a958314472f07a71e6d2e59d8dbf73f9edee70c5", "patch": "@@ -4,7 +4,7 @@ error: any use of this value will cause an error\n LL | const VALUE: u8 = unsafe { *REG_ADDR };\n    | ---------------------------^^^^^^^^^---\n    |                            |\n-   |                            a memory access tried to interpret some bytes as a pointer\n+   |                            unable to turn bytes into a pointer\n    |\n    = note: `#[deny(const_err)]` on by default\n "}]}