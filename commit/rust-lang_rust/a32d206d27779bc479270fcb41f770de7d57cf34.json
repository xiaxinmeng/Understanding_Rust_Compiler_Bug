{"sha": "a32d206d27779bc479270fcb41f770de7d57cf34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMmQyMDZkMjc3NzliYzQ3OTI3MGZjYjQxZjc3MGRlN2Q1N2NmMzQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-25T02:03:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-25T02:03:31Z"}, "message": "Implement autoderef in rustc. Un-XFAIL autoderef-full-lval.rs.", "tree": {"sha": "90d0229e6805f3c860876680ebd41d428ab03d0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d0229e6805f3c860876680ebd41d428ab03d0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a32d206d27779bc479270fcb41f770de7d57cf34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a32d206d27779bc479270fcb41f770de7d57cf34", "html_url": "https://github.com/rust-lang/rust/commit/a32d206d27779bc479270fcb41f770de7d57cf34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a32d206d27779bc479270fcb41f770de7d57cf34/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e1e3a9e1e9cb14f35f821e78c8e5626ff9f07b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1e3a9e1e9cb14f35f821e78c8e5626ff9f07b4", "html_url": "https://github.com/rust-lang/rust/commit/0e1e3a9e1e9cb14f35f821e78c8e5626ff9f07b4"}], "stats": {"total": 154, "additions": 130, "deletions": 24}, "files": [{"sha": "675a48237b45352b1905630fe102e66f8317c9f2", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32d206d27779bc479270fcb41f770de7d57cf34/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a32d206d27779bc479270fcb41f770de7d57cf34/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=a32d206d27779bc479270fcb41f770de7d57cf34", "patch": "@@ -422,6 +422,7 @@ TEST_XFAILS_RUSTC := $(filter-out \\\n                         arith-0.rs \\\n                         arith-1.rs \\\n                         arith-2.rs \\\n+                        autoderef-full-lval.rs \\\n                         bind-interior.rs \\\n                         bind-thunk.rs \\\n                         bind-trivial.rs \\"}, {"sha": "6246bbd186710fa197c4cf637ab1371291d0da0e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a32d206d27779bc479270fcb41f770de7d57cf34/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32d206d27779bc479270fcb41f770de7d57cf34/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a32d206d27779bc479270fcb41f770de7d57cf34", "patch": "@@ -1613,13 +1613,16 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n \n     alt (op) {\n         case (ast.bitnot) {\n+            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n             ret res(sub.bcx, cx.build.Not(sub.val));\n         }\n         case (ast.not) {\n+            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n             ret res(sub.bcx, cx.build.Not(sub.val));\n         }\n         case (ast.neg) {\n             // FIXME: switch by signedness.\n+            sub = autoderef(sub.bcx, sub.val, ty.expr_ty(e));\n             ret res(sub.bcx, cx.build.Neg(sub.val));\n         }\n         case (ast.box) {\n@@ -1688,6 +1691,26 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op,\n     fail;\n }\n \n+fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+    let ValueRef v1 = v;\n+    let @ty.t t1 = t;\n+\n+    while (true) {\n+        alt (t1.struct) {\n+            case (ty.ty_box(?inner)) {\n+                auto body = cx.build.GEP(v1,\n+                                         vec(C_int(0),\n+                                             C_int(abi.box_rc_field_body)));\n+                t1 = inner;\n+                v1 = load_scalar_or_boxed(cx, body, inner);\n+            }\n+            case (_) {\n+                ret res(cx, v1);\n+            }\n+        }\n+    }\n+}\n+\n fn trans_binary(@block_ctxt cx, ast.binop op,\n                 @ast.expr a, @ast.expr b) -> result {\n \n@@ -1697,9 +1720,11 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (ast.and) {\n             // Lazy-eval and\n             auto lhs_res = trans_expr(cx, a);\n+            lhs_res = autoderef(lhs_res.bcx, lhs_res.val, ty.expr_ty(a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n+            rhs_res = autoderef(rhs_res.bcx, rhs_res.val, ty.expr_ty(b));\n \n             auto lhs_false_cx = new_scope_block_ctxt(cx, \"lhs false\");\n             auto lhs_false_res = res(lhs_false_cx, C_bool(false));\n@@ -1715,9 +1740,11 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (ast.or) {\n             // Lazy-eval or\n             auto lhs_res = trans_expr(cx, a);\n+            lhs_res = autoderef(lhs_res.bcx, lhs_res.val, ty.expr_ty(a));\n \n             auto rhs_cx = new_scope_block_ctxt(cx, \"rhs\");\n             auto rhs_res = trans_expr(rhs_cx, b);\n+            rhs_res = autoderef(rhs_res.bcx, rhs_res.val, ty.expr_ty(b));\n \n             auto lhs_true_cx = new_scope_block_ctxt(cx, \"lhs true\");\n             auto lhs_true_res = res(lhs_true_cx, C_bool(true));\n@@ -1733,9 +1760,11 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n         case (_) {\n             // Remaining cases are eager:\n             auto lhs = trans_expr(cx, a);\n-            auto sub = trans_expr(lhs.bcx, b);\n-            ret res(sub.bcx, trans_eager_binop(sub.bcx, op,\n-                                               lhs.val, sub.val));\n+            lhs = autoderef(lhs.bcx, lhs.val, ty.expr_ty(a));\n+            auto rhs = trans_expr(lhs.bcx, b);\n+            rhs = autoderef(rhs.bcx, rhs.val, ty.expr_ty(b));\n+            ret res(rhs.bcx, trans_eager_binop(rhs.bcx, op,\n+                                               lhs.val, rhs.val));\n         }\n     }\n     fail;\n@@ -2126,6 +2155,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n     auto lv = trans_lval(cx, base);\n     auto r = lv.res;\n+    r = autoderef(r.bcx, r.val, ty.expr_ty(base));\n     check (lv.is_mem);\n     auto t = ty.expr_ty(base);\n     alt (t.struct) {\n@@ -2160,6 +2190,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n+    lv = autoderef(lv.bcx, lv.val, ty.expr_ty(base));\n     auto ix = trans_expr(lv.bcx, idx);\n     auto v = lv.val;\n "}, {"sha": "98fcc0d423c4d177d880ac533a1645efd1e0612e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 95, "deletions": 21, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a32d206d27779bc479270fcb41f770de7d57cf34/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32d206d27779bc479270fcb41f770de7d57cf34/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a32d206d27779bc479270fcb41f770de7d57cf34", "patch": "@@ -586,11 +586,68 @@ fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n     ret ty.unify(expected, actual, handler);\n }\n \n+tag autoderef_kind {\n+    AUTODEREF_OK;\n+    NO_AUTODEREF;\n+}\n+\n+fn strip_boxes(@ty.t t) -> @ty.t {\n+    auto t1 = t;\n+    while (true) {\n+        alt (t1.struct) {\n+            case (ty.ty_box(?inner)) { t1 = inner; }\n+            case (_) { ret t1; }\n+        }\n+    }\n+    fail;\n+}\n+\n+fn add_boxes(uint n, @ty.t t) -> @ty.t {\n+    auto t1 = t;\n+    while (n != 0u) {\n+        t1 = plain_ty(ty.ty_box(t1));\n+        n -= 1u;\n+    }\n+    ret t1;\n+}\n+\n+\n+fn count_boxes(@ty.t t) -> uint {\n+    auto n = 0u;\n+    auto t1 = t;\n+    while (true) {\n+        alt (t1.struct) {\n+            case (ty.ty_box(?inner)) { n += 1u; t1 = inner; }\n+            case (_) { ret n; }\n+        }\n+    }\n+    fail;\n+}\n+\n+\n+fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n+    be demand_full(fcx, sp, expected, actual, NO_AUTODEREF);\n+}\n+\n+\n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n-fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n-    alt (unify(fcx, expected, actual)) {\n-        case (ty.ures_ok(?t)) { ret t; }\n+\n+fn demand_full(&@fn_ctxt fcx, &span sp,\n+               @ty.t expected, @ty.t actual, autoderef_kind adk) -> @ty.t {\n+\n+    auto expected_1 = expected;\n+    auto actual_1 = actual;\n+    auto implicit_boxes = 0u;\n+\n+    if (adk == AUTODEREF_OK) {\n+        expected_1 = strip_boxes(expected);\n+        actual_1 = strip_boxes(actual);\n+        implicit_boxes = count_boxes(actual);\n+    }\n+\n+    alt (unify(fcx, expected_1, actual_1)) {\n+        case (ty.ures_ok(?t)) { ret add_boxes(implicit_boxes, t); }\n \n         case (ty.ures_err(?err, ?expected, ?actual)) {\n             fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n@@ -680,6 +737,11 @@ fn demand_pat(&@fn_ctxt fcx, @ty.t expected, @ast.pat pat) -> @ast.pat {\n //       but we can mitigate that if expected == actual == unified.\n \n fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n+    be demand_expr_full(fcx, expected, e, NO_AUTODEREF);\n+}\n+\n+fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n+                    autoderef_kind adk) -> @ast.expr {\n     // FIXME: botch to work around typestate bug in rustboot\n     let vec[@ast.expr] v = vec();\n     auto e_1 = ast.expr_vec(v, ast.ann_none);\n@@ -748,15 +810,21 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             e_1 = ast.expr_bind(sube, es, ast.ann_type(t));\n         }\n         case (ast.expr_call(?sube, ?es, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            // NB: we call 'demand_full' and pass in adk only in cases where\n+            // e is an expression that could *possibly* produce a box; things\n+            // like expr_binary or expr_bind can't, so there's no need.\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_call(sube, es, ast.ann_type(t));\n         }\n         case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             e_1 = ast.expr_binary(bop, lhs, rhs, ast.ann_type(t));\n         }\n         case (ast.expr_unary(?uop, ?sube, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            // See note in expr_unary for why we're calling demand_full.\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_unary(uop, sube, ast.ann_type(t));\n         }\n         case (ast.expr_lit(?lit, ?ann)) {\n@@ -768,7 +836,8 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             e_1 = ast.expr_cast(sube, ast_ty, ast.ann_type(t));\n         }\n         case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             auto then_1 = demand_block(fcx, expected, then_0);\n             auto else_1;\n             alt (else_0) {\n@@ -793,36 +862,39 @@ fn demand_expr(&@fn_ctxt fcx, @ty.t expected, @ast.expr e) -> @ast.expr {\n             e_1 = ast.expr_do_while(bloc, cond, ast.ann_type(t));\n         }\n         case (ast.expr_block(?bloc, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_block(bloc, ast.ann_type(t));\n         }\n         case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n             e_1 = ast.expr_assign(lhs_1, rhs_1, ast.ann_type(t));\n         }\n         case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             auto lhs_1 = demand_expr(fcx, expected, lhs_0);\n             auto rhs_1 = demand_expr(fcx, expected, rhs_0);\n             e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, ast.ann_type(t));\n         }\n         case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t));\n         }\n         case (ast.expr_index(?base, ?index, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_index(base, index, ast.ann_type(t));\n         }\n         case (ast.expr_path(?pth, ?d, ?ann)) {\n-            auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n+            auto t = demand_full(fcx, e.span, expected,\n+                                 ann_to_type(ann), adk);\n             e_1 = ast.expr_path(pth, d, ast.ann_type(t));\n         }\n-        case (_) {\n-            fail;\n-        }\n     }\n \n     ret @fold.respan[ast.expr_](e.span, e_1);\n@@ -960,10 +1032,12 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rhs_t0 = expr_ty(rhs_0);\n \n             // FIXME: Binops have a bit more subtlety than this.\n-            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n-            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+            auto lhs_1 = demand_expr_full(fcx, rhs_t0, lhs_0,\n+                                          AUTODEREF_OK);\n+            auto rhs_1 = demand_expr_full(fcx, expr_ty(lhs_1), rhs_0,\n+                                          AUTODEREF_OK);\n \n-            auto t = lhs_t0;\n+            auto t = strip_boxes(lhs_t0);\n             alt (binop) {\n                 case (ast.eq) { t = plain_ty(ty.ty_bool); }\n                 case (ast.lt) { t = plain_ty(ty.ty_bool); }\n@@ -997,7 +1071,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n                 }\n-                case (_) { /* fall through */ }\n+                case (_) { oper_t = strip_boxes(oper_t); }\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_unary(unop, oper_1,\n@@ -1378,7 +1452,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_field(?base, ?field, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = expr_ty(base_1);\n+            auto base_t = strip_boxes(expr_ty(base_1));\n             alt (base_t.struct) {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n@@ -1434,7 +1508,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_index(?base, ?idx, _)) {\n             auto base_1 = check_expr(fcx, base);\n-            auto base_t = expr_ty(base_1);\n+            auto base_t = strip_boxes(expr_ty(base_1));\n \n             auto idx_1 = check_expr(fcx, idx);\n             auto idx_t = expr_ty(idx_1);"}]}