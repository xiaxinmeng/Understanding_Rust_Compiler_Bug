{"sha": "bb1e8d2339cfb360c845b7435e97b4f5eb241991", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMWU4ZDIzMzljZmIzNjBjODQ1Yjc0MzVlOTdiNGY1ZWIyNDE5OTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-13T23:47:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-13T23:52:03Z"}, "message": "rustc: Some more codemap refactoring", "tree": {"sha": "4aa6d929cc0d5335d4817d016b4dddc13224e651", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aa6d929cc0d5335d4817d016b4dddc13224e651"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb1e8d2339cfb360c845b7435e97b4f5eb241991", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1e8d2339cfb360c845b7435e97b4f5eb241991", "html_url": "https://github.com/rust-lang/rust/commit/bb1e8d2339cfb360c845b7435e97b4f5eb241991", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb1e8d2339cfb360c845b7435e97b4f5eb241991/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f26266e03de70641296c26c20add33c1c4132ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f26266e03de70641296c26c20add33c1c4132ea4", "html_url": "https://github.com/rust-lang/rust/commit/f26266e03de70641296c26c20add33c1c4132ea4"}], "stats": {"total": 141, "additions": 67, "deletions": 74}, "files": [{"sha": "fc575d1c14923fd05fd31884431eee236b77b288", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/bb1e8d2339cfb360c845b7435e97b4f5eb241991/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb1e8d2339cfb360c845b7435e97b4f5eb241991/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=bb1e8d2339cfb360c845b7435e97b4f5eb241991", "patch": "@@ -138,92 +138,85 @@ fn print_diagnostic(topic: str, t: diagnostictype, msg: str) {\n \n fn emit_diagnostic(cmsp: option<(codemap, span)>, msg: str,\n                    t: diagnostictype) {\n-    let ss = \"\";\n-    let maybe_lines: option::t<@file_lines> = none;\n     alt cmsp {\n       some((cm, sp)) {\n-        ss = span_to_str(sp, cm);\n-        maybe_lines = some(span_to_lines(sp, cm));\n+        let ss = span_to_str(sp, cm);\n+        let lines = span_to_lines(sp, cm);\n+        print_diagnostic(ss, t, msg);\n+        highlight_lines(cm, sp, lines);\n+      }\n+      none. {\n+        print_diagnostic(\"\", t, msg);\n       }\n-      none. { }\n     }\n-    print_diagnostic(ss, t, msg);\n-    maybe_highlight_lines(cmsp, maybe_lines);\n }\n \n-fn maybe_highlight_lines(cmsp: option<(codemap, span)>,\n-                         maybe_lines: option::t<@file_lines>) {\n+fn highlight_lines(cm: codemap, sp: span,\n+                   lines: @file_lines) {\n \n-    alt maybe_lines {\n-      some(lines) {\n-        let (cm, sp) = option::get(cmsp);\n+    // If we're not looking at a real file then we can't re-open it to\n+    // pull out the lines\n+    if lines.name == \"-\" { ret; }\n \n-        // If we're not looking at a real file then we can't re-open it to\n-        // pull out the lines\n-        if lines.name == \"-\" { ret; }\n+    // FIXME: reading in the entire file is the worst possible way to\n+    //        get access to the necessary lines.\n+    let file = alt io::read_whole_file_str(lines.name) {\n+      result::ok(file) { file }\n+      result::err(e) {\n+        emit_error(none, e);\n+        fail;\n+      }\n+    };\n+    let fm = get_filemap(cm, lines.name);\n+\n+    // arbitrarily only print up to six lines of the error\n+    let max_lines = 6u;\n+    let elided = false;\n+    let display_lines = lines.lines;\n+    if vec::len(display_lines) > max_lines {\n+        display_lines = vec::slice(display_lines, 0u, max_lines);\n+        elided = true;\n+    }\n+    // Print the offending lines\n+    for line: uint in display_lines {\n+        io::stdout().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n+        let s = get_line(fm, line as int, file);\n+        if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n+        io::stdout().write_str(s);\n+    }\n+    if elided {\n+        let last_line = display_lines[vec::len(display_lines) - 1u];\n+        let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n+        let indent = str::char_len(s);\n+        let out = \"\";\n+        while indent > 0u { out += \" \"; indent -= 1u; }\n+        out += \"...\\n\";\n+        io::stdout().write_str(out);\n+    }\n \n-        // FIXME: reading in the entire file is the worst possible way to\n-        //        get access to the necessary lines.\n-        let file = alt io::read_whole_file_str(lines.name) {\n-          result::ok(file) { file }\n-          result::err(e) {\n-            emit_error(none, e);\n-            fail;\n-          }\n-        };\n-        let fm = get_filemap(cm, lines.name);\n-\n-        // arbitrarily only print up to six lines of the error\n-        let max_lines = 6u;\n-        let elided = false;\n-        let display_lines = lines.lines;\n-        if vec::len(display_lines) > max_lines {\n-            display_lines = vec::slice(display_lines, 0u, max_lines);\n-            elided = true;\n-        }\n-        // Print the offending lines\n-        for line: uint in display_lines {\n-            io::stdout().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n-            let s = get_line(fm, line as int, file);\n-            if !str::ends_with(s, \"\\n\") { s += \"\\n\"; }\n-            io::stdout().write_str(s);\n-        }\n-        if elided {\n-            let last_line = display_lines[vec::len(display_lines) - 1u];\n-            let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n-            let indent = str::char_len(s);\n-            let out = \"\";\n-            while indent > 0u { out += \" \"; indent -= 1u; }\n-            out += \"...\\n\";\n-            io::stdout().write_str(out);\n-        }\n \n+    // If there's one line at fault we can easily point to the problem\n+    if vec::len(lines.lines) == 1u {\n+        let lo = lookup_char_pos(cm, sp.lo);\n+        let digits = 0u;\n+        let num = (lines.lines[0] + 1u) / 10u;\n \n-        // If there's one line at fault we can easily point to the problem\n-        if vec::len(lines.lines) == 1u {\n-            let lo = lookup_char_pos(cm, sp.lo);\n-            let digits = 0u;\n-            let num = (lines.lines[0] + 1u) / 10u;\n-\n-            // how many digits must be indent past?\n-            while num > 0u { num /= 10u; digits += 1u; }\n-\n-            // indent past |name:## | and the 0-offset column location\n-            let left = str::char_len(fm.name) + digits + lo.col + 3u;\n-            let s = \"\";\n-            while left > 0u { str::push_char(s, ' '); left -= 1u; }\n-\n-            s += \"^\";\n-            let hi = lookup_char_pos(cm, sp.hi);\n-            if hi.col != lo.col {\n-                // the ^ already takes up one space\n-                let width = hi.col - lo.col - 1u;\n-                while width > 0u { str::push_char(s, '~'); width -= 1u; }\n-            }\n-            io::stdout().write_str(s + \"\\n\");\n+        // how many digits must be indent past?\n+        while num > 0u { num /= 10u; digits += 1u; }\n+\n+        // indent past |name:## | and the 0-offset column location\n+        let left = str::char_len(fm.name) + digits + lo.col + 3u;\n+        let s = \"\";\n+        while left > 0u { str::push_char(s, ' '); left -= 1u; }\n+\n+        s += \"^\";\n+        let hi = lookup_char_pos(cm, sp.hi);\n+        if hi.col != lo.col {\n+            // the ^ already takes up one space\n+            let width = hi.col - lo.col - 1u;\n+            while width > 0u { str::push_char(s, '~'); width -= 1u; }\n         }\n-      }\n-      _ { }\n+        io::stdout().write_str(s + \"\\n\");\n     }\n }\n "}]}