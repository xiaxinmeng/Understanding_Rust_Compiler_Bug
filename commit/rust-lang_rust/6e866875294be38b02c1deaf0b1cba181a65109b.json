{"sha": "6e866875294be38b02c1deaf0b1cba181a65109b", "node_id": "C_kwDOAAsO6NoAKDZlODY2ODc1Mjk0YmUzOGIwMmMxZGVhZjBiMWNiYTE4MWE2NTEwOWI", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-05T19:08:43Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-19T17:55:28Z"}, "message": "Handle replace calls with char slices", "tree": {"sha": "bae37bd3ab652f654119d92e0338f2c4130d23ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bae37bd3ab652f654119d92e0338f2c4130d23ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e866875294be38b02c1deaf0b1cba181a65109b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e866875294be38b02c1deaf0b1cba181a65109b", "html_url": "https://github.com/rust-lang/rust/commit/6e866875294be38b02c1deaf0b1cba181a65109b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e866875294be38b02c1deaf0b1cba181a65109b/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89698b9613179a1c025ce61fc17334a3ff315598", "url": "https://api.github.com/repos/rust-lang/rust/commits/89698b9613179a1c025ce61fc17334a3ff315598", "html_url": "https://github.com/rust-lang/rust/commit/89698b9613179a1c025ce61fc17334a3ff315598"}], "stats": {"total": 183, "additions": 167, "deletions": 16}, "files": [{"sha": "e2477fb06bd67dc6e61907ffdc633267c983c94b", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 151, "deletions": 3, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/6e866875294be38b02c1deaf0b1cba181a65109b/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e866875294be38b02c1deaf0b1cba181a65109b/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=6e866875294be38b02c1deaf0b1cba181a65109b", "patch": "@@ -1,6 +1,154 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+// use clippy_utils::source::snippet_with_context;\n+use clippy_utils::visitors::for_each_expr;\n+use core::ops::ControlFlow;\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::*;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+use std::unreachable;\n+// use rustc_span::Span;\n \n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) {}\n+use super::method_call;\n+use super::COLLAPSIBLE_STR_REPLACE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    name: &str,\n+    recv: &'tcx hir::Expr<'tcx>,\n+    args: &'tcx [hir::Expr<'tcx>],\n+) {\n+    match (name, args) {\n+        (\"replace\", [from, to]) => {\n+            // Check for `str::replace` calls with char slice for linting\n+            let original_recv = find_original_recv(recv);\n+            let original_recv_ty = cx.typeck_results().expr_ty(original_recv).peel_refs();\n+            if_chain! {\n+                // Check the receiver of the method call is `str` type\n+                if matches!(original_recv_ty.kind(), ty::Str);\n+                let from_ty = cx.typeck_results().expr_ty(from).peel_refs();\n+                if let ty::Array(array_ty, _) = from_ty.kind();\n+                if matches!(array_ty.kind(), ty::Char);\n+                then {\n+                    check_replace_call_with_char_slice(cx, from, to);\n+                }\n+            }\n+\n+            match method_call(recv) {\n+                // Check if there's an earlier `str::replace` call\n+                Some((\"replace\", [prev_recv, prev_from, prev_to], prev_span)) => {\n+                    println!(\"Consecutive replace calls\");\n+                    // Check that the original receiver is of `ty::Str` type\n+                    // Check that all the `from` args are char literals\n+                    // Check that all the `to` args are the same variable or has the same &str value\n+                    // If so, then lint\n+                },\n+                _ => {},\n+            }\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn find_original_recv<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> &'tcx hir::Expr<'tcx> {\n+    let mut original_recv = recv;\n+\n+    let _: Option<()> = for_each_expr(recv, |e| {\n+        if let Some((name, [prev_recv, args @ ..], _)) = method_call(e) {\n+            match (name, args) {\n+                (\"replace\", [_, _]) => {\n+                    original_recv = prev_recv;\n+                    ControlFlow::Continue(())\n+                },\n+                _ => ControlFlow::BREAK,\n+            }\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    original_recv\n+}\n+\n+fn check_replace_call_with_char_slice<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    from_arg: &'tcx hir::Expr<'tcx>,\n+    to_arg: &'tcx hir::Expr<'tcx>,\n+) {\n+    let mut has_no_var = true;\n+    let mut char_list: Vec<char> = Vec::new();\n+    // Go through the `from_arg` to collect all char literals\n+    let _: Option<()> = for_each_expr(from_arg, |e| {\n+        if let ExprKind::Lit(Spanned {\n+            node: LitKind::Char(val),\n+            ..\n+        }) = e.kind\n+        {\n+            char_list.push(val);\n+            ControlFlow::Continue(())\n+        } else if let ExprKind::Path(..) = e.kind {\n+            // If a variable is found in the char slice, no lint for first version of this lint\n+            has_no_var = false;\n+            ControlFlow::BREAK\n+        } else {\n+            ControlFlow::Continue(())\n+        }\n+    });\n+\n+    if has_no_var {\n+        let to_arg_repr = match to_arg.kind {\n+            ExprKind::Lit(Spanned {\n+                node: LitKind::Str(to_arg_val, _),\n+                ..\n+            }) => {\n+                let repr = to_arg_val.as_str();\n+                let double_quote = \"\\\"\";\n+                double_quote.to_owned() + repr + double_quote\n+            },\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: path_segments,\n+                    ..\n+                },\n+            )) => {\n+                // join the path_segments values by \"::\"\n+                let path_segment_ident_names: Vec<&str> = path_segments\n+                    .iter()\n+                    .map(|path_seg| path_seg.ident.name.as_str())\n+                    .collect();\n+\n+                path_segment_ident_names.join(\"::\")\n+            },\n+            _ => unreachable!(),\n+        };\n+\n+        let app = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            COLLAPSIBLE_STR_REPLACE,\n+            from_arg.span,\n+            \"used slice of chars in `str::replace` call\",\n+            \"replace with\",\n+            format!(\n+                \"replace(|c| matches!(c, {}), {})\",\n+                format_slice_of_chars_for_sugg(&char_list),\n+                to_arg_repr,\n+            ),\n+            app,\n+        );\n+    }\n+}\n+\n+fn format_slice_of_chars_for_sugg(chars: &Vec<char>) -> String {\n+    let single_quoted_chars: Vec<String> = chars\n+        .iter()\n+        .map(|c| \"'\".to_owned() + &c.to_string() + &\"'\".to_owned())\n+        .collect();\n+    single_quoted_chars.join(\" | \")\n+}"}, {"sha": "ec5d5402b0eaf0a34501d4447c45a989d35a46ad", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e866875294be38b02c1deaf0b1cba181a65109b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e866875294be38b02c1deaf0b1cba181a65109b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6e866875294be38b02c1deaf0b1cba181a65109b", "patch": "@@ -3519,7 +3519,7 @@ impl Methods {\n                 (\"sort_unstable_by\", [arg]) => {\n                     unnecessary_sort_by::check(cx, expr, recv, arg, true);\n                 },\n-                (\"replace\", [_, _]) => collapsible_str_replace::check(cx, expr, recv, args),\n+                (\"replace\", [_, _]) => collapsible_str_replace::check(cx, expr, name, recv, args),\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);"}, {"sha": "943fb4473bbd6f63f1c156e4940b0a026967a5e1", "filename": "tests/ui/collapsible_str_replace.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6e866875294be38b02c1deaf0b1cba181a65109b/tests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e866875294be38b02c1deaf0b1cba181a65109b/tests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.rs?ref=6e866875294be38b02c1deaf0b1cba181a65109b", "patch": "@@ -10,13 +10,28 @@ fn main() {\n     let p = 'p';\n     let s = 's';\n     let u = 'u';\n+    let l = \"l\";\n \n     // LINT CASES\n     // If the first argument to a single `str::replace` call is a slice and none of the chars\n     // are variables, recommend `collapsible_str_replace`\n     let replacement = misspelled.replace(&['s', 'u', 'p'], \"l\");\n     println!(\"{replacement}\");\n \n+    let replacement = misspelled.replace(&['s', 'u', 'p'], l);\n+    println!(\"{replacement}\");\n+\n+    // If multiple `str::replace` calls contain slices and none of the chars are variables,\n+    // recommend `collapsible_str_replace`\n+    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n+    println!(\"{replacement}\");\n+\n+    let replacement = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n+    println!(\"{replacement}\");\n+\n+    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n+    println!(\"replacement\");\n+\n     // If there are consecutive calls to `str::replace` and none of the chars are variables,\n     // recommend `collapsible_str_replace`\n     let replacement = misspelled.replace('s', \"l\").replace('u', \"l\");\n@@ -38,18 +53,6 @@ fn main() {\n     let replacement = misspelled.replace(&get_filter(), \"l\");\n \n     // NO LINT TIL IMPROVEMENT\n-    // If multiple `str::replace` calls contain slices and none of the chars are variables,\n-    // the first iteration does not recommend `collapsible_str_replace`\n-    let replacement = misspelled.replace(&['s', 'u', 'p'], \"l\").replace(&['s', 'p'], \"l\");\n-    println!(\"{replacement}\");\n-\n-    // If a mixture of `str::replace` calls with slice and char arguments are used for `from` arg,\n-    // the first iteration does not recommend `collapsible_str_replace`\n-    let replacement = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n-    println!(\"replacement\");\n-\n-    let replacement = misspelled.replace('p', \"l\").replace(&['s', 'u'], \"l\");\n-\n     // The first iteration of `collapsible_str_replace` will not create lint if the first argument to\n     // a single `str::replace` call is a slice and one or more of its chars are variables\n     let replacement = misspelled.replace(&['s', u, 'p'], \"l\");"}]}