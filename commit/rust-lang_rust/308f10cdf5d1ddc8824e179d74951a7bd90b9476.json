{"sha": "308f10cdf5d1ddc8824e179d74951a7bd90b9476", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOGYxMGNkZjVkMWRkYzg4MjRlMTc5ZDc0OTUxYTdiZDkwYjk0NzY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-02T19:32:43Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-03T02:35:26Z"}, "message": "Rollup merge of #33309 - birkenfeld:pp, r=nrc\n\nMake libsyntax::print::pp more idiomatic\n\nMinor cleanup, and using VecDeque as a ring buffer instead of a vector.", "tree": {"sha": "17e52e1bd80d0dcd6f75799608f8ac48acc39b49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17e52e1bd80d0dcd6f75799608f8ac48acc39b49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/308f10cdf5d1ddc8824e179d74951a7bd90b9476", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXKA5uAAoJEDu/TT4u95+YSMEP/3FxQ/SEJP46Vyo34ZIqBGTn\nVLEevM20PDCUk5qpO4cNrC+TGMeEUr7JYVMkiN+4GESIJlsWg+WEKIrNkt+H8vAX\nx8CxN1kNZOfM2m/JGP57euzS0/wDWKjzXA7dJj/GJDh0XgN0RlRBvd3P8sLegqY5\nUdADFdecm2ARms+Hb7ScBebLzmZwsJ/QtBPQSmh0XVz2krFbDor2BsozpNlKI2i8\nFCqmW1BEmPjbKsPcrA18mn+Pk4G17Ll6MTDCRfQqFT8pzVD6cz6HQOYayriQlfhX\npj4EFlbd1+Se0ndh8/5ONe6Jl/nEiFc08CJHfPkPUQcQhBAtW2ltgM1Ovj2x6juQ\nIeMXdGIonbLvp2vR78+r53A+FycpY9NSQaGQnAds3N3FHMG9LW1Z3bpH1PN4VerG\nBt77BTFcJ8xpzFaIUoU2fOuYnIW5rs/faEc2X1VIIQzbVErTP8ewuUMgV3GmFXn1\nlzbr+6R4lk/T+cmuoBjt+uRdFnP5zj5sH33iK2ZLtBuTZOgxSUoGwlG6yEA+WKl+\n/f1OyOhD3m7h4S3E7qRS/MELqrtK9LydDMt/oZVbRqENUqYjkO3SSZ1zm4AJiu9L\nxE2tbhnKgIZ49LZPseAq1yWE/M2CD3RphxXHYCgBj+UdVwtAnnWSa/32VtMaAVWE\nWrhZLZwrwcHsvMwboVOq\n=c+Vx\n-----END PGP SIGNATURE-----", "payload": "tree 17e52e1bd80d0dcd6f75799608f8ac48acc39b49\nparent 40199f68d909cc15c67de61389328c005062502d\nparent 41861691ebbb736a0f0dfdab142d2302dd7b87ae\nauthor Manish Goregaokar <manishsmail@gmail.com> 1462217563 +0530\ncommitter Manish Goregaokar <manishsmail@gmail.com> 1462242926 +0530\n\nRollup merge of #33309 - birkenfeld:pp, r=nrc\n\nMake libsyntax::print::pp more idiomatic\n\nMinor cleanup, and using VecDeque as a ring buffer instead of a vector.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/308f10cdf5d1ddc8824e179d74951a7bd90b9476", "html_url": "https://github.com/rust-lang/rust/commit/308f10cdf5d1ddc8824e179d74951a7bd90b9476", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/308f10cdf5d1ddc8824e179d74951a7bd90b9476/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40199f68d909cc15c67de61389328c005062502d", "url": "https://api.github.com/repos/rust-lang/rust/commits/40199f68d909cc15c67de61389328c005062502d", "html_url": "https://github.com/rust-lang/rust/commit/40199f68d909cc15c67de61389328c005062502d"}, {"sha": "41861691ebbb736a0f0dfdab142d2302dd7b87ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/41861691ebbb736a0f0dfdab142d2302dd7b87ae", "html_url": "https://github.com/rust-lang/rust/commit/41861691ebbb736a0f0dfdab142d2302dd7b87ae"}], "stats": {"total": 129, "additions": 44, "deletions": 85}, "files": [{"sha": "4a92ad8ddb26d8c20f55fe45dbfa9ae9de17f475", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 44, "deletions": 85, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/308f10cdf5d1ddc8824e179d74951a7bd90b9476/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308f10cdf5d1ddc8824e179d74951a7bd90b9476/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=308f10cdf5d1ddc8824e179d74951a7bd90b9476", "patch": "@@ -61,8 +61,9 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n+use std::collections::VecDeque;\n+use std::fmt;\n use std::io;\n-use std::string;\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -112,35 +113,30 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(token: &Token) -> String {\n-    match *token {\n-        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n-        Token::Break(_) => \"BREAK\".to_string(),\n-        Token::Begin(_) => \"BEGIN\".to_string(),\n-        Token::End => \"END\".to_string(),\n-        Token::Eof => \"EOF\".to_string()\n+impl fmt::Display for Token {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n+            Token::Break(_) => f.write_str(\"BREAK\"),\n+            Token::Begin(_) => f.write_str(\"BEGIN\"),\n+            Token::End => f.write_str(\"END\"),\n+            Token::Eof => f.write_str(\"EOF\"),\n+        }\n     }\n }\n \n-pub fn buf_str(toks: &[Token],\n-               szs: &[isize],\n-               left: usize,\n-               right: usize,\n-               lim: usize)\n-               -> String {\n+fn buf_str(toks: &[Token], szs: &[isize], left: usize, right: usize, lim: usize) -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = string::String::from(\"[\");\n+    let mut s = String::from(\"[\");\n     while i != right && l != 0 {\n         l -= 1;\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(&format!(\"{}={}\",\n-                           szs[i],\n-                           tok_str(&toks[i])));\n+        s.push_str(&format!(\"{}={}\", szs[i], &toks[i]));\n         i += 1;\n         i %= n;\n     }\n@@ -169,7 +165,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     debug!(\"mk_printer {}\", linewidth);\n     let token = vec![Token::Eof; n];\n     let size = vec![0; n];\n-    let scan_stack = vec![0; n];\n+    let scan_stack = VecDeque::with_capacity(n);\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -182,9 +178,6 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n         left_total: 0,\n         right_total: 0,\n         scan_stack: scan_stack,\n-        scan_stack_empty: true,\n-        top: 0,\n-        bottom: 0,\n         print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n@@ -246,9 +239,8 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n /// approximation for purposes of line breaking).\n ///\n /// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n-/// manage calculating 'size'. SCAN is, in other words, the process of\n-/// calculating 'size' entries.\n+/// SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+/// other words, the process of calculating 'size' entries.\n ///\n /// The \"output side\" of the printer is managed by an abstract process called\n /// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n@@ -291,13 +283,7 @@ pub struct Printer<'a> {\n     /// Begin (if there is any) on top of it. Stuff is flushed off the\n     /// bottom as it becomes irrelevant due to the primary ring-buffer\n     /// advancing.\n-    scan_stack: Vec<usize> ,\n-    /// Top==bottom disambiguator\n-    scan_stack_empty: bool,\n-    /// Index of top of scan_stack\n-    top: usize,\n-    /// Index of bottom of scan_stack\n-    bottom: usize,\n+    scan_stack: VecDeque<usize> ,\n     /// Stack of blocks-in-progress being flushed by print\n     print_stack: Vec<PrintStackElem> ,\n     /// Buffered indentation to avoid writing trailing whitespace\n@@ -316,15 +302,15 @@ impl<'a> Printer<'a> {\n         debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n           Token::Eof => {\n-            if !self.scan_stack_empty {\n+            if !self.scan_stack.is_empty() {\n                 self.check_stack(0);\n                 self.advance_left()?;\n             }\n             self.indent(0);\n             Ok(())\n           }\n           Token::Begin(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -339,7 +325,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::End => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n                 self.print(token, 0)\n             } else {\n@@ -353,7 +339,7 @@ impl<'a> Printer<'a> {\n             }\n           }\n           Token::Break(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -370,7 +356,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::String(s, len) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp String('{}')/print Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.print(Token::String(s, len), len)\n@@ -392,12 +378,10 @@ impl<'a> Printer<'a> {\n         if self.right_total - self.left_total > self.space {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n-            if !self.scan_stack_empty {\n-                if self.left == self.scan_stack[self.bottom] {\n-                    debug!(\"setting {} to infinity and popping\", self.left);\n-                    let scanned = self.scan_pop_bottom();\n-                    self.size[scanned] = SIZE_INFINITY;\n-                }\n+            if Some(&self.left) == self.scan_stack.back() {\n+                debug!(\"setting {} to infinity and popping\", self.left);\n+                let scanned = self.scan_pop_bottom();\n+                self.size[scanned] = SIZE_INFINITY;\n             }\n             self.advance_left()?;\n             if self.left != self.right {\n@@ -408,43 +392,21 @@ impl<'a> Printer<'a> {\n     }\n     pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n-        if self.scan_stack_empty {\n-            self.scan_stack_empty = false;\n-        } else {\n-            self.top += 1;\n-            self.top %= self.buf_len;\n-            assert!((self.top != self.bottom));\n-        }\n-        self.scan_stack[self.top] = x;\n+        self.scan_stack.push_front(x);\n     }\n     pub fn scan_pop(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.top];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.top += self.buf_len - 1; self.top %= self.buf_len;\n-        }\n-        return x;\n+        self.scan_stack.pop_front().unwrap()\n     }\n     pub fn scan_top(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        return self.scan_stack[self.top];\n+        *self.scan_stack.front().unwrap()\n     }\n     pub fn scan_pop_bottom(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.bottom];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.bottom += 1; self.bottom %= self.buf_len;\n-        }\n-        return x;\n+        self.scan_stack.pop_back().unwrap()\n     }\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_len;\n-        assert!((self.right != self.left));\n+        assert!(self.right != self.left);\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n@@ -481,7 +443,7 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n     pub fn check_stack(&mut self, k: isize) {\n-        if !self.scan_stack_empty {\n+        if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.token[x] {\n                 Token::Begin(_) => {\n@@ -512,19 +474,16 @@ impl<'a> Printer<'a> {\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        return ret;\n+        ret\n     }\n     pub fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> PrintStackElem {\n-        let print_stack = &mut self.print_stack;\n-        let n = print_stack.len();\n-        if n != 0 {\n-            (*print_stack)[n - 1]\n-        } else {\n-            PrintStackElem {\n+        match self.print_stack.last() {\n+            Some(el) => *el,\n+            None => PrintStackElem {\n                 offset: 0,\n                 pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n@@ -538,7 +497,7 @@ impl<'a> Printer<'a> {\n         write!(self.out, \"{}\", s)\n     }\n     pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n+        debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.token,\n                              &self.size,\n@@ -566,7 +525,7 @@ impl<'a> Printer<'a> {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((!print_stack.is_empty()));\n+            assert!(!print_stack.is_empty());\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n@@ -603,12 +562,12 @@ impl<'a> Printer<'a> {\n               }\n             }\n           }\n-          Token::String(s, len) => {\n+          Token::String(ref s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(&s[..])\n+            self.print_str(s)\n           }\n           Token::Eof => {\n             // Eof should never get here.\n@@ -652,15 +611,15 @@ pub fn eof(p: &mut Printer) -> io::Result<()> {\n }\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n+    p.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {"}]}