{"sha": "ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "node_id": "C_kwDOAAsO6NoAKGVlMDJhNDcyMWI1YmIyMGE2N2ExMDUyOTFjYzNmNTlkOGU1N2RhN2I", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-31T16:05:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-08-31T16:05:52Z"}, "message": "Remove unnecessary allocations", "tree": {"sha": "027d6927053a0929fc61c10c42768ae2e80e34b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/027d6927053a0929fc61c10c42768ae2e80e34b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "html_url": "https://github.com/rust-lang/rust/commit/ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "192a79c23551b5e1d3d5ef8115ebec67437daaff", "url": "https://api.github.com/repos/rust-lang/rust/commits/192a79c23551b5e1d3d5ef8115ebec67437daaff", "html_url": "https://github.com/rust-lang/rust/commit/192a79c23551b5e1d3d5ef8115ebec67437daaff"}], "stats": {"total": 78, "additions": 25, "deletions": 53}, "files": [{"sha": "8ebac5cb1c6c449dd9f7200355f84b43c60f9bab", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 25, "deletions": 48, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "patch": "@@ -628,8 +628,9 @@ impl ExprCollector<'_> {\n \n     fn collect_macro_as_stmt(\n         &mut self,\n+        statements: &mut Vec<Statement>,\n         mac: ast::MacroExpr,\n-    ) -> Option<(Vec<Statement>, Option<ExprId>)> {\n+    ) -> Option<ExprId> {\n         let mac_call = mac.macro_call()?;\n         let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));\n         let macro_ptr = AstPtr::new(&mac_call);\n@@ -639,49 +640,32 @@ impl ExprCollector<'_> {\n             false,\n             |this, expansion: Option<ast::MacroStmts>| match expansion {\n                 Some(expansion) => {\n-                    let mut statements: Vec<_> = expansion\n-                        .statements()\n-                        .filter_map(|stmt| this.collect_stmt(stmt))\n-                        .flatten()\n-                        .collect();\n-                    let tail = expansion.expr().and_then(|expr| match expr {\n-                        ast::Expr::MacroExpr(mac) => {\n-                            let (stmts, tail) = this.collect_macro_as_stmt(mac)?;\n-                            statements.extend(stmts);\n-                            tail\n-                        }\n+                    expansion.statements().for_each(|stmt| this.collect_stmt(statements, stmt));\n+                    expansion.expr().and_then(|expr| match expr {\n+                        ast::Expr::MacroExpr(mac) => this.collect_macro_as_stmt(statements, mac),\n                         expr => Some(this.collect_expr(expr)),\n-                    });\n-                    Some((statements, tail))\n+                    })\n                 }\n                 None => None,\n             },\n         );\n-        let mut stmts = Vec::new();\n-        let expr = match expansion {\n-            Some((statements, tail)) => {\n-                stmts.extend(statements);\n+        match expansion {\n+            Some(tail) => {\n                 // Make the macro-call point to its expanded expression so we can query\n                 // semantics on syntax pointers to the macro\n                 let src = self.expander.to_source(syntax_ptr);\n-                match tail {\n-                    Some(tail) => {\n-                        self.source_map.expr_map.insert(src, tail);\n-                        tail\n-                    }\n-                    None => self.make_expr(Expr::Missing, Ok(src.clone())),\n-                }\n+                self.source_map.expr_map.insert(src, tail);\n+                Some(tail)\n             }\n-            None => self.alloc_expr(Expr::Missing, syntax_ptr),\n-        };\n-        Some((stmts, Some(expr)))\n+            None => None,\n+        }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n+    fn collect_stmt(&mut self, statements: &mut Vec<Statement>, s: ast::Stmt) {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n-                    return None;\n+                    return;\n                 }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref =\n@@ -691,29 +675,26 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                Some(vec![Statement::Let { pat, type_ref, initializer, else_branch }])\n+                statements.push(Statement::Let { pat, type_ref, initializer, else_branch });\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n                 let expr = stmt.expr();\n-                if let Some(expr) = &expr {\n-                    if self.check_cfg(expr).is_none() {\n-                        return None;\n-                    }\n+                match &expr {\n+                    Some(expr) if self.check_cfg(expr).is_none() => return,\n+                    _ => (),\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n                 // Note that macro could be expanded to multiple statements\n                 if let Some(ast::Expr::MacroExpr(mac)) = expr {\n-                    let (mut statements, tail) = self.collect_macro_as_stmt(mac)?;\n-                    if let Some(expr) = tail {\n-                        statements.push(Statement::Expr { expr, has_semi });\n+                    if let Some(expr) = self.collect_macro_as_stmt(statements, mac) {\n+                        statements.push(Statement::Expr { expr, has_semi })\n                     }\n-                    Some(statements)\n                 } else {\n                     let expr = self.collect_expr_opt(expr);\n-                    Some(vec![Statement::Expr { expr, has_semi }])\n+                    statements.push(Statement::Expr { expr, has_semi });\n                 }\n             }\n-            ast::Stmt::Item(_item) => None,\n+            ast::Stmt::Item(_item) => (),\n         }\n     }\n \n@@ -734,14 +715,10 @@ impl ExprCollector<'_> {\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n-        let mut statements: Vec<_> =\n-            block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n+        let mut statements = Vec::new();\n+        block.statements().for_each(|s| self.collect_stmt(&mut statements, s));\n         let tail = block.tail_expr().and_then(|e| match e {\n-            ast::Expr::MacroExpr(mac) => {\n-                let (stmts, tail) = self.collect_macro_as_stmt(mac)?;\n-                statements.extend(stmts);\n-                tail\n-            }\n+            ast::Expr::MacroExpr(mac) => self.collect_macro_as_stmt(&mut statements, mac),\n             expr => self.maybe_collect_expr(expr),\n         });\n         let tail = tail.or_else(|| {"}, {"sha": "b3adafaafd38de8ea411754aa963079da3f3a309", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "patch": "@@ -311,7 +311,6 @@ fn expr_macro_expanded_in_stmts() {\n             !3..4 'a': ()\n             !5..7 '()': ()\n             57..84 '{     ...); } }': ()\n-            63..82 'id! { ... (); }': ()\n         \"#]],\n     );\n }\n@@ -336,7 +335,6 @@ fn recursive_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..13 'ng!{[leta=3]}': {unknown}\n             !3..4 'a': i32\n             !5..6 '3': i32\n             196..237 '{     ...= a; }': ()\n@@ -361,7 +359,6 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..7 'mac!($)': {unknown}\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],"}, {"sha": "23e51a9c16a5600138e3e519e2ae952c4a68c95e", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "patch": "@@ -578,7 +578,6 @@ fn issue_6811() {\n             !11..13 '_b': i32\n             !14..15 '1': i32\n             103..131 '{     ...!(); }': ()\n-            109..128 'profil...ion!()': {unknown}\n         \"#]],\n     );\n }"}, {"sha": "707e9e84506a402728145c7e37a1f6b24dac55db", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee02a4721b5bb20a67a105291cc3f59d8e57da7b/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=ee02a4721b5bb20a67a105291cc3f59d8e57da7b", "patch": "@@ -2549,7 +2549,6 @@ impl B for Astruct {}\n         expect![[r#\"\n             569..573 'self': Box<[T], A>\n             602..634 '{     ...     }': Vec<T, A>\n-            612..628 'unimpl...ted!()': Vec<T, A>\n             648..761 '{     ...t]); }': ()\n             658..661 'vec': Vec<i32, Global>\n             664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>"}]}