{"sha": "491fccfbe3561b0674a7dd13ac9f00820662aa59", "node_id": "C_kwDOAAsO6NoAKDQ5MWZjY2ZiZTM1NjFiMDY3NGE3ZGQxM2FjOWYwMDgyMDY2MmFhNTk", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-01T01:05:46Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-18T16:59:14Z"}, "message": "proc_macro: stop using a remote object handle for Ident\n\nDoing this for all unicode identifiers would require a dependency on\n`unicode-normalization` and `rustc_lexer`, which is currently not\npossible for `proc_macro` due to it being built concurrently with `std`\nand `core`. Instead, ASCII identifiers are validated locally, and an RPC\nmessage is used to validate unicode identifiers when needed.\n\nString values are interned on the both the server and client when\ndeserializing, to avoid unnecessary copies and keep Ident cheap to copy and\nmove. This appears to be important for performance.\n\nThe client-side interner is based roughly on the one from rustc_span, and uses\nan arena inspired by rustc_arena.\n\nRPC messages passing symbols always include the full value. This could\npotentially be optimized in the future if it is revealed to be a\nperformance bottleneck.\n\nDespite now having a relevant implementaion of Display for Ident, ToString is\nstill specialized, as it is a hot-path for this object.\n\nThe symbol infrastructure will also be used for literals in the next\npart.", "tree": {"sha": "004f1977288b1841cbd150e4e9e376d0350da11a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/004f1977288b1841cbd150e4e9e376d0350da11a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/491fccfbe3561b0674a7dd13ac9f00820662aa59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/491fccfbe3561b0674a7dd13ac9f00820662aa59", "html_url": "https://github.com/rust-lang/rust/commit/491fccfbe3561b0674a7dd13ac9f00820662aa59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/491fccfbe3561b0674a7dd13ac9f00820662aa59/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0dce6ec8df23adbe7c45c07ed080caf3d81a14b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0dce6ec8df23adbe7c45c07ed080caf3d81a14b", "html_url": "https://github.com/rust-lang/rust/commit/e0dce6ec8df23adbe7c45c07ed080caf3d81a14b"}], "stats": {"total": 555, "additions": 441, "deletions": 114}, "files": [{"sha": "ffd5e8763e36bc124f9b6c152913d683d5732266", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 34, "deletions": 57, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -11,13 +11,13 @@ use rustc_parse::lexer::nfc_normalize;\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::def_id::CrateNum;\n-use rustc_span::symbol::{self, kw, sym, Symbol};\n+use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Punct, TokenTree};\n+use pm::bridge::{server, DelimSpan, ExpnGlobals, Group, Ident, Punct, TokenTree};\n use pm::{Delimiter, Level, LineColumn};\n+use std::ascii;\n use std::ops::Bound;\n-use std::{ascii, panic};\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -50,7 +50,7 @@ impl ToInternal<token::Delimiter> for Delimiter {\n }\n \n impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n-    for Vec<TokenTree<TokenStream, Span, Ident, Literal>>\n+    for Vec<TokenTree<TokenStream, Span, Symbol, Literal>>\n {\n     fn from_internal((stream, rustc): (TokenStream, &mut Rustc<'_, '_>)) -> Self {\n         use rustc_ast::token::*;\n@@ -135,13 +135,12 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                 Question => op(\"?\"),\n                 SingleQuote => op(\"'\"),\n \n-                Ident(name, false) if name == kw::DollarCrate => trees.push(TokenTree::Ident(Ident::dollar_crate(span))),\n-                Ident(name, is_raw) => trees.push(TokenTree::Ident(Ident::new(rustc.sess(), name, is_raw, span))),\n+                Ident(sym, is_raw) => trees.push(TokenTree::Ident(Ident { sym, is_raw, span })),\n                 Lifetime(name) => {\n                     let ident = symbol::Ident::new(name, span).without_first_quote();\n                     trees.extend([\n                         TokenTree::Punct(Punct { ch: b'\\'', joint: true, span }),\n-                        TokenTree::Ident(Ident::new(rustc.sess(), ident.name, false, span)),\n+                        TokenTree::Ident(Ident { sym: ident.name, is_raw: false, span }),\n                     ]);\n                 }\n                 Literal(lit) => trees.push(TokenTree::Literal(self::Literal { lit, span })),\n@@ -170,7 +169,7 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n                 }\n \n                 Interpolated(nt) if let NtIdent(ident, is_raw) = *nt => {\n-                    trees.push(TokenTree::Ident(Ident::new(rustc.sess(), ident.name, is_raw, ident.span)))\n+                    trees.push(TokenTree::Ident(Ident { sym: ident.name, is_raw, span: ident.span }))\n                 }\n \n                 Interpolated(nt) => {\n@@ -200,11 +199,14 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)>\n     }\n }\n \n-impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n+impl ToInternal<TokenStream>\n+    for (TokenTree<TokenStream, Span, Symbol, Literal>, &mut Rustc<'_, '_>)\n+{\n     fn to_internal(self) -> TokenStream {\n         use rustc_ast::token::*;\n \n-        let (ch, joint, span) = match self {\n+        let (tree, rustc) = self;\n+        let (ch, joint, span) = match tree {\n             TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n             TokenTree::Group(Group { delimiter, stream, span: DelimSpan { open, close, .. } }) => {\n                 return tokenstream::TokenTree::Delimited(\n@@ -215,6 +217,7 @@ impl ToInternal<TokenStream> for TokenTree<TokenStream, Span, Ident, Literal> {\n                 .into();\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n+                rustc.sess().symbol_gallery.insert(sym, span);\n                 return tokenstream::TokenTree::token(Ident(sym, is_raw), span).into();\n             }\n             TokenTree::Literal(self::Literal {\n@@ -289,33 +292,6 @@ impl ToInternal<rustc_errors::Level> for Level {\n \n pub struct FreeFunctions;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Ident {\n-    sym: Symbol,\n-    is_raw: bool,\n-    span: Span,\n-}\n-\n-impl Ident {\n-    fn new(sess: &ParseSess, sym: Symbol, is_raw: bool, span: Span) -> Ident {\n-        let sym = nfc_normalize(sym.as_str());\n-        let string = sym.as_str();\n-        if !rustc_lexer::is_ident(string) {\n-            panic!(\"`{:?}` is not a valid identifier\", string)\n-        }\n-        if is_raw && !sym.can_be_raw() {\n-            panic!(\"`{}` cannot be a raw identifier\", string);\n-        }\n-        sess.symbol_gallery.insert(sym, span);\n-        Ident { sym, is_raw, span }\n-    }\n-\n-    fn dollar_crate(span: Span) -> Ident {\n-        // `$crate` is accepted as an ident only if it comes from the compiler.\n-        Ident { sym: kw::DollarCrate, is_raw: false, span }\n-    }\n-}\n-\n // FIXME(eddyb) `Literal` should not expose internal `Debug` impls.\n #[derive(Clone, Debug)]\n pub struct Literal {\n@@ -357,12 +333,12 @@ impl<'a, 'b> Rustc<'a, 'b> {\n impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n-    type Ident = Ident;\n     type Literal = Literal;\n     type SourceFile = Lrc<SourceFile>;\n     type MultiSpan = Vec<Span>;\n     type Diagnostic = Diagnostic;\n     type Span = Span;\n+    type Symbol = Symbol;\n }\n \n impl server::FreeFunctions for Rustc<'_, '_> {\n@@ -453,22 +429,22 @@ impl server::TokenStream for Rustc<'_, '_> {\n \n     fn from_token_tree(\n         &mut self,\n-        tree: TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>,\n+        tree: TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>,\n     ) -> Self::TokenStream {\n-        tree.to_internal()\n+        (tree, &mut *self).to_internal()\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n-        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>>,\n+        trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>>,\n     ) -> Self::TokenStream {\n         let mut builder = tokenstream::TokenStreamBuilder::new();\n         if let Some(base) = base {\n             builder.push(base);\n         }\n         for tree in trees {\n-            builder.push(tree.to_internal());\n+            builder.push((tree, &mut *self).to_internal());\n         }\n         builder.build()\n     }\n@@ -491,25 +467,11 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n-    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Ident, Self::Literal>> {\n+    ) -> Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol, Self::Literal>> {\n         FromInternal::from_internal((stream, self))\n     }\n }\n \n-impl server::Ident for Rustc<'_, '_> {\n-    fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        Ident::new(self.sess(), Symbol::intern(string), is_raw, span)\n-    }\n-\n-    fn span(&mut self, ident: Self::Ident) -> Self::Span {\n-        ident.span\n-    }\n-\n-    fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n-        Ident { span, ..ident }\n-    }\n-}\n-\n impl server::Literal for Rustc<'_, '_> {\n     fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n         let name = FileName::proc_macro_source_code(s);\n@@ -812,6 +774,13 @@ impl server::Span for Rustc<'_, '_> {\n     }\n }\n \n+impl server::Symbol for Rustc<'_, '_> {\n+    fn normalize_and_validate_ident(&mut self, string: &str) -> Result<Self::Symbol, ()> {\n+        let sym = nfc_normalize(string);\n+        if rustc_lexer::is_ident(sym.as_str()) { Ok(sym) } else { Err(()) }\n+    }\n+}\n+\n impl server::Server for Rustc<'_, '_> {\n     fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n         ExpnGlobals {\n@@ -820,4 +789,12 @@ impl server::Server for Rustc<'_, '_> {\n             mixed_site: self.mixed_site,\n         }\n     }\n+\n+    fn intern_symbol(string: &str) -> Self::Symbol {\n+        Symbol::intern(string)\n+    }\n+\n+    fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n+        f(&symbol.as_str())\n+    }\n }"}, {"sha": "fa72d2816ebfe7f7b2f906640e7fd1e1c2031628", "filename": "library/proc_macro/src/bridge/arena.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Farena.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -0,0 +1,113 @@\n+//! A minimal arena allocator inspired by `rustc_arena::DroplessArena`.\n+//!\n+//! This is unfortunately a minimal re-implementation rather than a dependency\n+//! as it is difficult to depend on crates from within `proc_macro`, due to it\n+//! being built at the same time as `std`.\n+\n+use std::cell::{Cell, RefCell};\n+use std::cmp;\n+use std::mem::MaybeUninit;\n+use std::ops::Range;\n+use std::ptr;\n+use std::slice;\n+use std::str;\n+\n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n+const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n+\n+/// A minimal arena allocator inspired by `rustc_arena::DroplessArena`.\n+///\n+/// This is unfortunately a complete re-implementation rather than a dependency\n+/// as it is difficult to depend on crates from within `proc_macro`, due to it\n+/// being built at the same time as `std`.\n+///\n+/// This arena doesn't have support for allocating anything other than byte\n+/// slices, as that is all that is necessary.\n+pub(crate) struct Arena {\n+    start: Cell<*mut MaybeUninit<u8>>,\n+    end: Cell<*mut MaybeUninit<u8>>,\n+    chunks: RefCell<Vec<Box<[MaybeUninit<u8>]>>>,\n+}\n+\n+impl Arena {\n+    pub(crate) fn new() -> Self {\n+        Arena {\n+            start: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n+            chunks: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n+    /// Add a new chunk with at least `additional` free bytes.\n+    #[inline(never)]\n+    #[cold]\n+    fn grow(&self, additional: usize) {\n+        let mut chunks = self.chunks.borrow_mut();\n+        let mut new_cap;\n+        if let Some(last_chunk) = chunks.last_mut() {\n+            // If the previous chunk's len is less than HUGE_PAGE\n+            // bytes, then this chunk will be least double the previous\n+            // chunk's size.\n+            new_cap = last_chunk.len().min(HUGE_PAGE / 2);\n+            new_cap *= 2;\n+        } else {\n+            new_cap = PAGE;\n+        }\n+        // Also ensure that this chunk can fit `additional`.\n+        new_cap = cmp::max(additional, new_cap);\n+\n+        let mut chunk = Box::new_uninit_slice(new_cap);\n+        let Range { start, end } = chunk.as_mut_ptr_range();\n+        self.start.set(start);\n+        self.end.set(end);\n+        chunks.push(chunk);\n+    }\n+\n+    /// Allocates a byte slice with specified size from the current memory\n+    /// chunk. Returns `None` if there is no free space left to satisfy the\n+    /// request.\n+    fn alloc_raw_without_grow(&self, bytes: usize) -> Option<&mut [MaybeUninit<u8>]> {\n+        let start = self.start.get().addr();\n+        let old_end = self.end.get();\n+        let end = old_end.addr();\n+\n+        let new_end = end.checked_sub(bytes)?;\n+        if start <= new_end {\n+            let new_end = old_end.with_addr(new_end);\n+            self.end.set(new_end);\n+            // SAFETY: `bytes` bytes starting at `new_end` were just reserved.\n+            Some(unsafe { slice::from_raw_parts_mut(new_end, bytes) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn alloc_raw(&self, bytes: usize) -> &mut [MaybeUninit<u8>] {\n+        if bytes == 0 {\n+            return &mut [];\n+        }\n+\n+        loop {\n+            if let Some(a) = self.alloc_raw_without_grow(bytes) {\n+                break a;\n+            }\n+            // No free space left. Allocate a new chunk to satisfy the request.\n+            // On failure the grow will panic or abort.\n+            self.grow(bytes);\n+        }\n+    }\n+\n+    pub(crate) fn alloc_str<'a>(&'a self, string: &str) -> &'a mut str {\n+        let alloc = self.alloc_raw(string.len());\n+        let bytes = MaybeUninit::write_slice(alloc, string.as_bytes());\n+\n+        // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n+        // and immediately convert the clone back to `&str`.\n+        unsafe { str::from_utf8_unchecked_mut(bytes) }\n+    }\n+}"}, {"sha": "6d48faf5413e8368aa12226dafb8dd7a7c75f1f2", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -181,7 +181,6 @@ define_handles! {\n     Diagnostic,\n \n     'interned:\n-    Ident,\n     Span,\n }\n \n@@ -242,6 +241,8 @@ impl fmt::Debug for Span {\n     }\n }\n \n+pub(crate) use super::symbol::Symbol;\n+\n macro_rules! define_client_side {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n@@ -405,6 +406,9 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n         maybe_install_panic_hook(force_show_panics);\n \n+        // Make sure the symbol store is empty before decoding inputs.\n+        Symbol::invalidate_all();\n+\n         let reader = &mut &buf[..];\n         let (globals, input) = <(ExpnGlobals<Span>, A)>::decode(reader, &mut ());\n \n@@ -438,6 +442,10 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n         buf.clear();\n         Err::<(), _>(e).encode(&mut buf, &mut ());\n     });\n+\n+    // Now that a response has been serialized, invalidate all symbols\n+    // registered with the interner.\n+    Symbol::invalidate_all();\n     buf\n }\n "}, {"sha": "1015c0d7259800ff914260ec0237ef083c0b78f0", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -65,24 +65,19 @@ macro_rules! with_api {\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree(\n-                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>,\n+                    tree: TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>,\n                 ) -> $S::TokenStream;\n                 fn concat_trees(\n                     base: Option<$S::TokenStream>,\n-                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>,\n+                    trees: Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>>,\n                 ) -> $S::TokenStream;\n                 fn concat_streams(\n                     base: Option<$S::TokenStream>,\n                     streams: Vec<$S::TokenStream>,\n                 ) -> $S::TokenStream;\n                 fn into_trees(\n                     $self: $S::TokenStream\n-                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Ident, $S::Literal>>;\n-            },\n-            Ident {\n-                fn new(string: &str, span: $S::Span, is_raw: bool) -> $S::Ident;\n-                fn span($self: $S::Ident) -> $S::Span;\n-                fn with_span($self: $S::Ident, span: $S::Span) -> $S::Ident;\n+                ) -> Vec<TokenTree<$S::TokenStream, $S::Span, $S::Symbol, $S::Literal>>;\n             },\n             Literal {\n                 fn drop($self: $S::Literal);\n@@ -146,6 +141,9 @@ macro_rules! with_api {\n                 fn save_span($self: $S::Span) -> usize;\n                 fn recover_proc_macro_span(id: usize) -> $S::Span;\n             },\n+            Symbol {\n+                fn normalize_and_validate_ident(string: &str) -> Result<$S::Symbol, ()>;\n+            },\n         }\n     };\n }\n@@ -170,6 +168,8 @@ macro_rules! reverse_decode {\n     }\n }\n \n+#[allow(unsafe_code)]\n+mod arena;\n #[allow(unsafe_code)]\n mod buffer;\n #[forbid(unsafe_code)]\n@@ -189,6 +189,8 @@ mod scoped_cell;\n mod selfless_reify;\n #[forbid(unsafe_code)]\n pub mod server;\n+#[allow(unsafe_code)]\n+mod symbol;\n \n use buffer::Buffer;\n pub use rpc::PanicMessage;\n@@ -466,16 +468,25 @@ pub struct Punct<Span> {\n \n compound_traits!(struct Punct<Span> { ch, joint, span });\n \n+#[derive(Copy, Clone, Eq, PartialEq)]\n+pub struct Ident<Span, Symbol> {\n+    pub sym: Symbol,\n+    pub is_raw: bool,\n+    pub span: Span,\n+}\n+\n+compound_traits!(struct Ident<Span, Symbol> { sym, is_raw, span });\n+\n #[derive(Clone)]\n-pub enum TokenTree<TokenStream, Span, Ident, Literal> {\n+pub enum TokenTree<TokenStream, Span, Symbol, Literal> {\n     Group(Group<TokenStream, Span>),\n     Punct(Punct<Span>),\n-    Ident(Ident),\n+    Ident(Ident<Span, Symbol>),\n     Literal(Literal),\n }\n \n compound_traits!(\n-    enum TokenTree<TokenStream, Span, Ident, Literal> {\n+    enum TokenTree<TokenStream, Span, Symbol, Literal> {\n         Group(tt),\n         Punct(tt),\n         Ident(tt),"}, {"sha": "53668ecfead78a13e197a130b3f641b441052b14", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -8,12 +8,12 @@ use super::client::HandleStore;\n pub trait Types {\n     type FreeFunctions: 'static;\n     type TokenStream: 'static + Clone;\n-    type Ident: 'static + Copy + Eq + Hash;\n     type Literal: 'static + Clone;\n     type SourceFile: 'static + Clone;\n     type MultiSpan: 'static;\n     type Diagnostic: 'static;\n     type Span: 'static + Copy + Eq + Hash;\n+    type Symbol: 'static;\n }\n \n /// Declare an associated fn of one of the traits below, adding necessary\n@@ -38,6 +38,12 @@ macro_rules! declare_server_traits {\n \n         pub trait Server: Types $(+ $name)* {\n             fn globals(&mut self) -> ExpnGlobals<Self::Span>;\n+\n+            /// Intern a symbol received from RPC\n+            fn intern_symbol(ident: &str) -> Self::Symbol;\n+\n+            /// Recover the string value of a symbol, and invoke a callback with it.\n+            fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str));\n         }\n     }\n }\n@@ -49,6 +55,12 @@ impl<S: Server> Server for MarkedTypes<S> {\n     fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n         <_>::mark(Server::globals(&mut self.0))\n     }\n+    fn intern_symbol(ident: &str) -> Self::Symbol {\n+        <_>::mark(S::intern_symbol(ident))\n+    }\n+    fn with_symbol_string(symbol: &Self::Symbol, f: impl FnOnce(&str)) {\n+        S::with_symbol_string(symbol.unmark(), f)\n+    }\n }\n \n macro_rules! define_mark_types_impls {\n@@ -81,11 +93,13 @@ macro_rules! define_dispatcher_impl {\n         pub trait DispatcherTrait {\n             // HACK(eddyb) these are here to allow `Self::$name` to work below.\n             $(type $name;)*\n+\n             fn dispatch(&mut self, buf: Buffer) -> Buffer;\n         }\n \n         impl<S: Server> DispatcherTrait for Dispatcher<MarkedTypes<S>> {\n             $(type $name = <MarkedTypes<S> as Types>::$name;)*\n+\n             fn dispatch(&mut self, mut buf: Buffer) -> Buffer {\n                 let Dispatcher { handle_store, server } = self;\n "}, {"sha": "930c111455df0977005a5b82702b8601df62a289", "filename": "library/proc_macro/src/bridge/symbol.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fsymbol.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -0,0 +1,205 @@\n+//! Client-side interner used for symbols.\n+//!\n+//! This is roughly based on the symbol interner from `rustc_span` and the\n+//! DroplessArena from `rustc_arena`. It is unfortunately a complete\n+//! copy/re-implementation rather than a dependency as it is difficult to depend\n+//! on crates from within `proc_macro`, due to it being built at the same time\n+//! as `std`.\n+//!\n+//! If at some point in the future it becomes easier to add dependencies to\n+//! proc_macro, this module should probably be removed or simplified.\n+\n+use std::cell::RefCell;\n+use std::num::NonZeroU32;\n+use std::str;\n+\n+use super::*;\n+\n+/// Handle for a symbol string stored within the Interner.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Symbol(NonZeroU32);\n+\n+impl !Send for Symbol {}\n+impl !Sync for Symbol {}\n+\n+impl Symbol {\n+    /// Intern a new `Symbol`\n+    pub(crate) fn new(string: &str) -> Self {\n+        INTERNER.with_borrow_mut(|i| i.intern(string))\n+    }\n+\n+    /// Create a new `Symbol` for an identifier.\n+    ///\n+    /// Validates and normalizes before converting it to a symbol.\n+    pub(crate) fn new_ident(string: &str, is_raw: bool) -> Self {\n+        // Fast-path: check if this is a valid ASCII identifier\n+        if Self::is_valid_ascii_ident(string.as_bytes()) {\n+            if is_raw && !Self::can_be_raw(string) {\n+                panic!(\"`{}` cannot be a raw identifier\", string);\n+            }\n+            return Self::new(string);\n+        }\n+\n+        // Slow-path: If the string is already ASCII we're done, otherwise ask\n+        // our server to do this for us over RPC.\n+        // We don't need to check for identifiers which can't be raw here,\n+        // because all of them are ASCII.\n+        if string.is_ascii() {\n+            Err(())\n+        } else {\n+            client::Symbol::normalize_and_validate_ident(string)\n+        }\n+        .unwrap_or_else(|_| panic!(\"`{:?}` is not a valid identifier\", string))\n+    }\n+\n+    /// Run a callback with the symbol's string value.\n+    pub(crate) fn with<R>(self, f: impl FnOnce(&str) -> R) -> R {\n+        INTERNER.with_borrow(|i| f(i.get(self)))\n+    }\n+\n+    /// Clear out the thread-local symbol interner, making all previously\n+    /// created symbols invalid such that `with` will panic when called on them.\n+    pub(crate) fn invalidate_all() {\n+        INTERNER.with_borrow_mut(|i| i.clear());\n+    }\n+\n+    /// Check if the ident is a valid ASCII identifier.\n+    ///\n+    /// This is a short-circuit which is cheap to implement within the\n+    /// proc-macro client to avoid RPC when creating simple idents, but may\n+    /// return `false` for a valid identifier if it contains non-ASCII\n+    /// characters.\n+    fn is_valid_ascii_ident(bytes: &[u8]) -> bool {\n+        matches!(bytes.first(), Some(b'_' | b'a'..=b'z' | b'A'..=b'Z'))\n+            && bytes[1..]\n+                .iter()\n+                .all(|b| matches!(b, b'_' | b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9'))\n+    }\n+\n+    // Mimics the behaviour of `Symbol::can_be_raw` from `rustc_span`\n+    fn can_be_raw(string: &str) -> bool {\n+        match string {\n+            \"_\" | \"super\" | \"self\" | \"Self\" | \"crate\" => false,\n+            _ => true,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.with(|s| fmt::Debug::fmt(s, f))\n+    }\n+}\n+\n+impl ToString for Symbol {\n+    fn to_string(&self) -> String {\n+        self.with(|s| s.to_owned())\n+    }\n+}\n+\n+impl fmt::Display for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.with(|s| fmt::Display::fmt(s, f))\n+    }\n+}\n+\n+impl<S> Encode<S> for Symbol {\n+    fn encode(self, w: &mut Writer, s: &mut S) {\n+        self.with(|sym| sym.encode(w, s))\n+    }\n+}\n+\n+impl<S: server::Server> DecodeMut<'_, '_, client::HandleStore<server::MarkedTypes<S>>>\n+    for Marked<S::Symbol, Symbol>\n+{\n+    fn decode(r: &mut Reader<'_>, s: &mut client::HandleStore<server::MarkedTypes<S>>) -> Self {\n+        Mark::mark(S::intern_symbol(<&str>::decode(r, s)))\n+    }\n+}\n+\n+impl<S: server::Server> Encode<client::HandleStore<server::MarkedTypes<S>>>\n+    for Marked<S::Symbol, Symbol>\n+{\n+    fn encode(self, w: &mut Writer, s: &mut client::HandleStore<server::MarkedTypes<S>>) {\n+        S::with_symbol_string(&self.unmark(), |sym| sym.encode(w, s))\n+    }\n+}\n+\n+impl<S> DecodeMut<'_, '_, S> for Symbol {\n+    fn decode(r: &mut Reader<'_>, s: &mut S) -> Self {\n+        Symbol::new(<&str>::decode(r, s))\n+    }\n+}\n+\n+thread_local! {\n+    static INTERNER: RefCell<Interner> = RefCell::new(Interner {\n+        arena: arena::Arena::new(),\n+        names: fxhash::FxHashMap::default(),\n+        strings: Vec::new(),\n+        // Start with a base of 1 to make sure that `NonZeroU32` works.\n+        sym_base: NonZeroU32::new(1).unwrap(),\n+    });\n+}\n+\n+/// Basic interner for a `Symbol`, inspired by the one in `rustc_span`.\n+struct Interner {\n+    arena: arena::Arena,\n+    // SAFETY: These `'static` lifetimes are actually references to data owned\n+    // by the Arena. This is safe, as we never return them as static references\n+    // from `Interner`.\n+    names: fxhash::FxHashMap<&'static str, Symbol>,\n+    strings: Vec<&'static str>,\n+    // The offset to apply to symbol names stored in the interner. This is used\n+    // to ensure that symbol names are not re-used after the interner is\n+    // cleared.\n+    sym_base: NonZeroU32,\n+}\n+\n+impl Interner {\n+    fn intern(&mut self, string: &str) -> Symbol {\n+        if let Some(&name) = self.names.get(string) {\n+            return name;\n+        }\n+\n+        let name = Symbol(\n+            self.sym_base\n+                .checked_add(self.strings.len() as u32)\n+                .expect(\"`proc_macro` symbol name overflow\"),\n+        );\n+\n+        let string: &str = self.arena.alloc_str(string);\n+\n+        // SAFETY: we can extend the arena allocation to `'static` because we\n+        // only access these while the arena is still alive.\n+        let string: &'static str = unsafe { &*(string as *const str) };\n+        self.strings.push(string);\n+        self.names.insert(string, name);\n+        name\n+    }\n+\n+    /// Read a symbol's value from the store while it is held.\n+    fn get(&self, symbol: Symbol) -> &str {\n+        // NOTE: Subtract out the offset which was added to make the symbol\n+        // nonzero and prevent symbol name re-use.\n+        let name = symbol\n+            .0\n+            .get()\n+            .checked_sub(self.sym_base.get())\n+            .expect(\"use-after-free of `proc_macro` symbol\");\n+        self.strings[name as usize]\n+    }\n+\n+    /// Clear all symbols from the store, invalidating them such that `get` will\n+    /// panic if they are accessed in the future.\n+    fn clear(&mut self) {\n+        // NOTE: Be careful not to panic here, as we may be called on the client\n+        // when a `catch_unwind` isn't installed.\n+        self.sym_base = self.sym_base.saturating_add(self.strings.len() as u32);\n+        self.names.clear();\n+        self.strings.clear();\n+\n+        // SAFETY: This is cleared after the names and strings tables are\n+        // cleared out, so no references into the arena should remain.\n+        self.arena = arena::Arena::new();\n+    }\n+}"}, {"sha": "911deaef8c97835e388503c328658eb16de0f212", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -24,10 +24,14 @@\n #![feature(staged_api)]\n #![feature(allow_internal_unstable)]\n #![feature(decl_macro)]\n+#![feature(local_key_cell_methods)]\n+#![feature(maybe_uninit_write_slice)]\n #![feature(negative_impls)]\n+#![feature(new_uninit)]\n #![feature(restricted_std)]\n #![feature(rustc_attrs)]\n #![feature(min_specialization)]\n+#![feature(strict_provenance)]\n #![recursion_limit = \"256\"]\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n@@ -214,7 +218,7 @@ fn tree_to_bridge_tree(\n ) -> bridge::TokenTree<\n     bridge::client::TokenStream,\n     bridge::client::Span,\n-    bridge::client::Ident,\n+    bridge::client::Symbol,\n     bridge::client::Literal,\n > {\n     match tree {\n@@ -240,7 +244,7 @@ struct ConcatTreesHelper {\n         bridge::TokenTree<\n             bridge::client::TokenStream,\n             bridge::client::Span,\n-            bridge::client::Ident,\n+            bridge::client::Symbol,\n             bridge::client::Literal,\n         >,\n     >,\n@@ -367,7 +371,7 @@ pub mod token_stream {\n             bridge::TokenTree<\n                 bridge::client::TokenStream,\n                 bridge::client::Span,\n-                bridge::client::Ident,\n+                bridge::client::Symbol,\n                 bridge::client::Literal,\n             >,\n         >,\n@@ -1048,7 +1052,7 @@ impl PartialEq<Punct> for char {\n /// An identifier (`ident`).\n #[derive(Clone)]\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n-pub struct Ident(bridge::client::Ident);\n+pub struct Ident(bridge::Ident<bridge::client::Span, bridge::client::Symbol>);\n \n impl Ident {\n     /// Creates a new `Ident` with the given `string` as well as the specified\n@@ -1072,7 +1076,11 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, false))\n+        Ident(bridge::Ident {\n+            sym: bridge::client::Symbol::new_ident(string, false),\n+            is_raw: false,\n+            span: span.0,\n+        })\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n@@ -1081,38 +1089,45 @@ impl Ident {\n     /// (e.g. `self`, `super`) are not supported, and will cause a panic.\n     #[stable(feature = \"proc_macro_raw_ident\", since = \"1.47.0\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        Ident(bridge::client::Ident::new(string, span.0, true))\n+        Ident(bridge::Ident {\n+            sym: bridge::client::Symbol::new_ident(string, true),\n+            is_raw: true,\n+            span: span.0,\n+        })\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n-    /// by [`to_string`](Self::to_string).\n+    /// by [`to_string`](ToString::to_string).\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn span(&self) -> Span {\n-        Span(self.0.span())\n+        Span(self.0.span)\n     }\n \n     /// Configures the span of this `Ident`, possibly changing its hygiene context.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn set_span(&mut self, span: Span) {\n-        self.0 = self.0.with_span(span.0);\n+        self.0.span = span.0;\n     }\n }\n \n-// N.B., the bridge only provides `to_string`, implement `fmt::Display`\n-// based on it (the reverse of the usual relationship between the two).\n-#[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n+/// Converts the identifier to a string that should be losslessly convertible\n+/// back into the same identifier.\n+#[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl ToString for Ident {\n     fn to_string(&self) -> String {\n-        TokenStream::from(TokenTree::from(self.clone())).to_string()\n+        self.0.sym.with(|sym| if self.0.is_raw { [\"r#\", sym].concat() } else { sym.to_owned() })\n     }\n }\n \n-/// Prints the identifier as a string that should be losslessly convertible\n-/// back into the same identifier.\n+/// Prints the identifier as a string that should be losslessly convertible back\n+/// into the same identifier.\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.to_string())\n+        if self.0.is_raw {\n+            f.write_str(\"r#\")?;\n+        }\n+        fmt::Display::fmt(&self.0.sym, f)\n     }\n }\n "}, {"sha": "151f6203439f793136bf2f6124d07b60962160e0", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -1,17 +1,9 @@\n // aux-build:invalid-punct-ident.rs\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME https://github.com/rust-lang/rust/issues/59998\n-// normalize-stderr-test \"thread.*panicked.*proc_macro_server.rs.*\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n-// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n-// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n-// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n+// ignore-stage1\n+// only-linux\n+//\n+// FIXME: This should be a normal (stage1, all platforms) test in\n+// src/test/ui/proc-macro once issue #59998 is fixed.\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "0bd07bd649e47605e416e4ffb95782a78fa55140", "filename": "src/test/ui/proc-macro/invalid-punct-ident-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-2.stderr?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-2.rs:19:1\n+  --> $DIR/invalid-punct-ident-2.rs:11:1\n    |\n LL | invalid_ident!();\n    | ^^^^^^^^^^^^^^^^"}, {"sha": "7c22a56b6fbe9fbedfb43da3a69d33d78b19c10d", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.rs?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -1,17 +1,9 @@\n // aux-build:invalid-punct-ident.rs\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME https://github.com/rust-lang/rust/issues/59998\n-// normalize-stderr-test \"thread.*panicked.*proc_macro_server.rs.*\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*RUST_BACKTRACE=1.*\\n\" -> \"\"\n-// normalize-stderr-test \"\\nerror: internal compiler error.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note:.*unexpectedly panicked.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: we would appreciate a bug report.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"note: rustc.*running on.*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"query stack during panic:\\n\" -> \"\"\n-// normalize-stderr-test \"we're just showing a limited slice of the query stack\\n\" -> \"\"\n-// normalize-stderr-test \"end of query stack\\n\" -> \"\"\n+// ignore-stage1\n+// only-linux\n+//\n+// FIXME: This should be a normal (stage1, all platforms) test in\n+// src/test/ui/proc-macro once issue #59998 is fixed.\n \n #[macro_use]\n extern crate invalid_punct_ident;"}, {"sha": "a0cc5ef6e2d621552f8175007c37ab33383b6098", "filename": "src/test/ui/proc-macro/invalid-punct-ident-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/491fccfbe3561b0674a7dd13ac9f00820662aa59/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finvalid-punct-ident-3.stderr?ref=491fccfbe3561b0674a7dd13ac9f00820662aa59", "patch": "@@ -1,5 +1,5 @@\n error: proc macro panicked\n-  --> $DIR/invalid-punct-ident-3.rs:19:1\n+  --> $DIR/invalid-punct-ident-3.rs:11:1\n    |\n LL | invalid_raw_ident!();\n    | ^^^^^^^^^^^^^^^^^^^^"}]}