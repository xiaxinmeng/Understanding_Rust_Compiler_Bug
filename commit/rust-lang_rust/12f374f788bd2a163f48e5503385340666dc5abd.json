{"sha": "12f374f788bd2a163f48e5503385340666dc5abd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZjM3NGY3ODhiZDJhMTYzZjQ4ZTU1MDMzODUzNDA2NjZkYzVhYmQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T23:01:02Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-03-26T23:01:02Z"}, "message": "Merge pull request #803 from Manishearth/fixes\n\nICE fixes and other things", "tree": {"sha": "ab418824a306c50045b39a200f60e06ff8b77039", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab418824a306c50045b39a200f60e06ff8b77039"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12f374f788bd2a163f48e5503385340666dc5abd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12f374f788bd2a163f48e5503385340666dc5abd", "html_url": "https://github.com/rust-lang/rust/commit/12f374f788bd2a163f48e5503385340666dc5abd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12f374f788bd2a163f48e5503385340666dc5abd/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deb0f3120d61ca948d3ef8982cc565b2547cebca", "url": "https://api.github.com/repos/rust-lang/rust/commits/deb0f3120d61ca948d3ef8982cc565b2547cebca", "html_url": "https://github.com/rust-lang/rust/commit/deb0f3120d61ca948d3ef8982cc565b2547cebca"}, {"sha": "fcfda681e51ec538fd117d906b95606fd3c3198d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcfda681e51ec538fd117d906b95606fd3c3198d", "html_url": "https://github.com/rust-lang/rust/commit/fcfda681e51ec538fd117d906b95606fd3c3198d"}], "stats": {"total": 110, "additions": 76, "deletions": 34}, "files": [{"sha": "7924623c189eb31d63963da2aa648ffe7152b883", "filename": "src/enum_glob_use.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -43,20 +43,21 @@ impl EnumGlobUse {\n         }\n         if let ItemUse(ref item_use) = item.node {\n             if let ViewPath_::ViewPathGlob(_) = item_use.node {\n-                let def = cx.tcx.def_map.borrow()[&item.id];\n-                if let Some(node_id) = cx.tcx.map.as_local_node_id(def.def_id()) {\n-                    if let Some(NodeItem(it)) = cx.tcx.map.find(node_id) {\n-                        if let ItemEnum(..) = it.node {\n-                            span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                        }\n-                    }\n-                } else {\n-                    if let Some(dp) = cx.sess().cstore.def_path(def.def_id()).last() {\n-                        if let DefPathData::Type(_) = dp.data {\n-                            if let TyEnum(..) = cx.sess().cstore.item_type(&cx.tcx, def.def_id()).ty.sty {\n+                if let Some(def) = cx.tcx.def_map.borrow().get(&item.id) {\n+                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def.def_id()) {\n+                        if let Some(NodeItem(it)) = cx.tcx.map.find(node_id) {\n+                            if let ItemEnum(..) = it.node {\n                                 span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n                             }\n                         }\n+                    } else {\n+                        if let Some(dp) = cx.sess().cstore.def_path(def.def_id()).last() {\n+                            if let DefPathData::Type(_) = dp.data {\n+                                if let TyEnum(..) = cx.sess().cstore.item_type(&cx.tcx, def.def_id()).ty.sty {\n+                                    span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "81761695eb8aa7ad6a2b287843ecb506f7892eef", "filename": "src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -402,8 +402,8 @@ impl LateLintPass for MethodsPass {\n                         }\n                     }\n \n-                    let ret_ty = return_ty(cx.tcx.node_id_to_type(implitem.id));\n-                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty))) {\n+                    let ret_ty = return_ty(cx, implitem.id);\n+                    if &name.as_str() == &\"new\" && !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n                         span_lint(cx,\n                                   NEW_RET_NO_SELF,\n                                   sig.explicit_self.span,"}, {"sha": "395d69138e13756ff26c5480024b63c4eba7b20e", "filename": "src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/src%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnew_without_default.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -52,8 +52,8 @@ impl LateLintPass for NewWithoutDefault {\n \n                 if_let_chain!{[\n                     self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n-                    let Some(ret_ty) = return_ty(cx.tcx.node_id_to_type(id)),\n-                    same_tys(cx, self_ty, ret_ty),\n+                    let Some(ret_ty) = return_ty(cx, id),\n+                    same_tys(cx, self_ty, ret_ty, id),\n                     let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH),\n                     !implements_trait(cx, self_ty, default_trait_id, Vec::new())\n                 ], {"}, {"sha": "742298622fc3535173b922bac2011882fd044ea4", "filename": "src/types.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -1,7 +1,6 @@\n use reexport::*;\n use rustc::lint::*;\n-use rustc::middle::const_eval;\n-use rustc::middle::ty;\n+use rustc::middle::{const_eval, def, ty};\n use rustc_front::hir::*;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc_front::util::{is_comparison_binop, binop_to_string};\n@@ -53,21 +52,34 @@ impl LateLintPass for TypePass {\n         if in_macro(cx, ast_ty.span) {\n             return;\n         }\n-        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n-            if let ty::TyBox(ref inner) = ty.sty {\n-                if match_type(cx, inner, &VEC_PATH) {\n+        if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n+            if let def::Def::Struct(..) = did.full_def() {\n+                if Some(did.def_id()) == cx.tcx.lang_items.owned_box() {\n+                    if_let_chain! {\n+                        [\n+                            let TyPath(_, ref path) = ast_ty.node,\n+                            let Some(ref last) = path.segments.last(),\n+                            let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n+                            let Some(ref vec) = ag.types.get(0),\n+                            let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n+                            let def::Def::Struct(..) = did.full_def(),\n+                            match_def_path(cx, did.def_id(), &VEC_PATH),\n+                        ],\n+                        {\n+                            span_help_and_lint(cx,\n+                                               BOX_VEC,\n+                                               ast_ty.span,\n+                                               \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                               \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                        }\n+                    }\n+                } else if match_def_path(cx, did.def_id(), &LL_PATH) {\n                     span_help_and_lint(cx,\n-                                       BOX_VEC,\n+                                       LINKEDLIST,\n                                        ast_ty.span,\n-                                       \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                       \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                                       \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                                       \"a VecDeque might work\");\n                 }\n-            } else if match_type(cx, ty, &LL_PATH) {\n-                span_help_and_lint(cx,\n-                                   LINKEDLIST,\n-                                   ast_ty.span,\n-                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"a VecDeque might work\");\n             }\n         }\n     }"}, {"sha": "0389c3d56c009b92ec6f5ec99a4450e98b82bc46", "filename": "src/utils/mod.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -4,6 +4,7 @@ use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::middle::def_id::DefId;\n use rustc::middle::traits::ProjectionMode;\n use rustc::middle::{cstore, def, infer, ty, traits};\n+use rustc::middle::subst::Subst;\n use rustc::session::Session;\n use rustc_front::hir::*;\n use std::borrow::Cow;\n@@ -54,6 +55,7 @@ pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE_PATH: [&'static str; 3] = [\"core\", \"intrinsics\", \"transmute\"];\n pub const VEC_FROM_ELEM_PATH: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n pub const VEC_PATH: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const BOX_PATH: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n@@ -89,6 +91,11 @@ macro_rules! if_let_chain {\n            $block\n         }\n     };\n+    ([let $pat:pat = $expr:expr,], $block:block) => {\n+        if let $pat = $expr {\n+           $block\n+        }\n+    };\n     ([$expr:expr, $($tt:tt)+], $block:block) => {\n         if $expr {\n            if_let_chain!{ [$($tt)+], $block }\n@@ -99,6 +106,11 @@ macro_rules! if_let_chain {\n            $block\n         }\n     };\n+    ([$expr:expr,], $block:block) => {\n+        if $expr {\n+           $block\n+        }\n+    };\n }\n \n /// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n@@ -764,8 +776,13 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n }\n \n /// Convenience function to get the return type of a function or `None` if the function diverges.\n-pub fn return_ty(fun: ty::Ty) -> Option<ty::Ty> {\n-    if let ty::FnConverging(ret_ty) = fun.fn_sig().skip_binder().output {\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Option<ty::Ty<'tcx>> {\n+    let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n+    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(parameter_env), ProjectionMode::Any);\n+\n+    let fn_sig = cx.tcx.node_id_to_type(fn_item).fn_sig().subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n+    let fn_sig = infcx.tcx.liberate_late_bound_regions(infcx.parameter_environment.free_id_outlive, &fn_sig);\n+    if let ty::FnConverging(ret_ty) = fn_sig.output {\n         Some(ret_ty)\n     } else {\n         None\n@@ -775,7 +792,10 @@ pub fn return_ty(fun: ty::Ty) -> Option<ty::Ty> {\n /// Check if two types are the same.\n // FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` == `for <'b> Foo<'b>` but\n // not for type parameters.\n-pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>) -> bool {\n-    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None, ProjectionMode::Any);\n-    infcx.can_equate(&cx.tcx.erase_regions(&a), &cx.tcx.erase_regions(&b)).is_ok()\n+pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>, parameter_item: NodeId) -> bool {\n+    let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, parameter_item);\n+    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(parameter_env), ProjectionMode::Any);\n+    let new_a = a.subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n+    let new_b = b.subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n+    infcx.can_equate(&new_a, &new_b).is_ok()\n }"}, {"sha": "74f262b05a78e163ea608ae53dc679a317e1d181", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12f374f788bd2a163f48e5503385340666dc5abd/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f374f788bd2a163f48e5503385340666dc5abd/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=12f374f788bd2a163f48e5503385340666dc5abd", "patch": "@@ -47,6 +47,15 @@ impl<'a> Lt2<'a> {\n     pub fn new(s: &str) -> Lt2 { unimplemented!() }\n }\n \n+struct Lt3<'a> {\n+    foo: &'a u32,\n+}\n+\n+impl<'a> Lt3<'a> {\n+    // The lifetime is different, but that\u2019s irrelevant, see #734\n+    pub fn new() -> Lt3<'static> { unimplemented!() }\n+}\n+\n #[derive(Clone,Copy)]\n struct U;\n "}]}