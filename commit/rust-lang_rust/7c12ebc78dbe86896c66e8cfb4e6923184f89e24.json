{"sha": "7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMTJlYmM3OGRiZTg2ODk2YzY2ZThjZmI0ZTY5MjMxODRmODllMjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T15:16:23Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T15:16:23Z"}, "message": "Roll our own MIR for dropping arrays.", "tree": {"sha": "a30e10160815ae5b8e35c3447a03039e56f5e9c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a30e10160815ae5b8e35c3447a03039e56f5e9c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "html_url": "https://github.com/rust-lang/rust/commit/7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c12ebc78dbe86896c66e8cfb4e6923184f89e24/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030f00a8a1929a0f140f0f4ec14937efb720d6dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/030f00a8a1929a0f140f0f4ec14937efb720d6dd", "html_url": "https://github.com/rust-lang/rust/commit/030f00a8a1929a0f140f0f4ec14937efb720d6dd"}], "stats": {"total": 229, "additions": 206, "deletions": 23}, "files": [{"sha": "5fe66ee50c74c98a563df8c2677009388f7ef9f1", "filename": "src/eval_context.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7c12ebc78dbe86896c66e8cfb4e6923184f89e24/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c12ebc78dbe86896c66e8cfb4e6923184f89e24/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "patch": "@@ -5,6 +5,7 @@ use std::fmt::Write;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::ConstVal;\n+use rustc_const_math::{ConstInt, ConstUsize};\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n@@ -44,6 +45,9 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: u64,\n+\n+    /// Drop glue for arrays and slices\n+    pub(crate) seq_drop_glue: MirRef<'tcx>,\n }\n \n /// A stack frame.\n@@ -124,13 +128,184 @@ impl Default for ResourceLimits {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n+        let source_info = mir::SourceInfo {\n+            span: DUMMY_SP,\n+            scope: mir::ARGUMENT_VISIBILITY_SCOPE\n+        };\n+        // i = 0; len = Len(*a0); goto head;\n+        let start_block = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(2)),\n+                        mir::Rvalue::Use(mir::Operand::Constant(mir::Constant {\n+                            span: DUMMY_SP,\n+                            ty: tcx.types.usize,\n+                            literal: mir::Literal::Value {\n+                                value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(0, tcx.sess.target.uint_type).unwrap())),\n+                            },\n+                        }))\n+                    )\n+                },\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(3)),\n+                        mir::Rvalue::Len(mir::Lvalue::Projection(Box::new(mir::LvalueProjection {\n+                            base: mir::Lvalue::Local(mir::Local::new(1)),\n+                            elem: mir::ProjectionElem::Deref,\n+                        }))),\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n+            }),\n+            is_cleanup: false\n+        };\n+        // head: done = i == len; switch done { 1 => ret, 0 => loop }\n+        let head = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(4)),\n+                        mir::Rvalue::BinaryOp(\n+                            mir::BinOp::Eq,\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(3))),\n+                        )\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::SwitchInt {\n+                    targets: vec![\n+                        mir::BasicBlock::new(2),\n+                        mir::BasicBlock::new(4),\n+                    ],\n+                    discr: mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(4))),\n+                    switch_ty: tcx.types.bool,\n+                    values: vec![ConstInt::U8(0)].into(),\n+                },\n+            }),\n+            is_cleanup: false\n+        };\n+        // loop: drop (*a0)[i]; goto inc;\n+        let loop_ = mir::BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Drop {\n+                    target: mir::BasicBlock::new(3),\n+                    unwind: None,\n+                    location: mir::Lvalue::Projection(Box::new(\n+                        mir::LvalueProjection {\n+                            base: mir::Lvalue::Projection(Box::new(\n+                                mir::LvalueProjection {\n+                                    base: mir::Lvalue::Local(mir::Local::new(1)),\n+                                    elem: mir::ProjectionElem::Deref,\n+                                }\n+                            )),\n+                            elem: mir::ProjectionElem::Index(mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2)))),\n+                        }\n+                    )),\n+                },\n+            }),\n+            is_cleanup: false\n+        };\n+        // inc: i++; goto head;\n+        let inc = mir::BasicBlockData {\n+            statements: vec![\n+                mir::Statement {\n+                    source_info,\n+                    kind: mir::StatementKind::Assign(\n+                        mir::Lvalue::Local(mir::Local::new(2)),\n+                        mir::Rvalue::BinaryOp(\n+                            mir::BinOp::Add,\n+                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n+                            mir::Operand::Constant(mir::Constant {\n+                                span: DUMMY_SP,\n+                                ty: tcx.types.usize,\n+                                literal: mir::Literal::Value {\n+                                    value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(0, tcx.sess.target.uint_type).unwrap())),\n+                                },\n+                            }),\n+                        )\n+                    )\n+                },\n+            ],\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n+            }),\n+            is_cleanup: false\n+        };\n+        // ret: return;\n+        let ret = mir::BasicBlockData {\n+            statements: Vec::new(),\n+            terminator: Some(mir::Terminator {\n+                source_info: source_info,\n+                kind: mir::TerminatorKind::Return,\n+            }),\n+            is_cleanup: false\n+        };\n+        let locals = vec![\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.mk_nil(),\n+                name: None,\n+                source_info: None,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.mk_mut_ptr(tcx.mk_self_type()),\n+                name: None,\n+                source_info: None,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.usize,\n+                name: None,\n+                source_info: None,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.usize,\n+                name: None,\n+                source_info: None,\n+            },\n+            mir::LocalDecl {\n+                mutability: mir::Mutability::Mut,\n+                ty: tcx.types.bool,\n+                name: None,\n+                source_info: None,\n+            },\n+        ];\n+        let seq_drop_glue = mir::Mir::new(\n+            vec![start_block, head, loop_, inc, ret].into_iter().collect(),\n+            Vec::new().into_iter().collect(), // vis scopes\n+            Vec::new().into_iter().collect(), // promoted\n+            tcx.mk_nil(), // return type\n+            locals.into_iter().collect(),\n+            1, // arg_count\n+            Vec::new(), // upvars\n+            DUMMY_SP,\n+        );\n+        let seq_drop_glue = tcx.alloc_mir(seq_drop_glue);\n+        // Perma-borrow MIR from shims to prevent mutation.\n+        ::std::mem::forget(seq_drop_glue.borrow());\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n+            seq_drop_glue: seq_drop_glue.borrow(),\n         }\n     }\n \n@@ -1958,3 +2133,13 @@ fn fulfill_obligation<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         vtable\n     })\n }\n+\n+pub fn resolve_drop_in_place<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+) -> ty::Instance<'tcx>\n+{\n+    let def_id = tcx.require_lang_item(::rustc::middle::lang_items::DropInPlaceFnLangItem);\n+    let substs = tcx.intern_substs(&[Kind::from(ty)]);\n+    resolve(tcx, def_id, substs)\n+}"}, {"sha": "8258395c402de3cb898abab45a2b6b71eb1f001d", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7c12ebc78dbe86896c66e8cfb4e6923184f89e24/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c12ebc78dbe86896c66e8cfb4e6923184f89e24/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=7c12ebc78dbe86896c66e8cfb4e6923184f89e24", "patch": "@@ -80,18 +80,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let src_ptr = self.force_allocation(lval)?.to_ptr();\n \n                 let ty = self.lvalue_ty(location);\n+                let ty = ::eval_context::apply_param_substs(self.tcx, self.substs(), &ty);\n \n                 self.goto_block(target);\n-                let drop_in_place = self.tcx.lang_items.drop_in_place_fn().expect(\"drop_in_place lang item not available\");\n-                let env = self.tcx.empty_parameter_environment();\n-                let def = if self.tcx.type_needs_drop_given_env(ty, &env) {\n-                    ty::InstanceDef::DropGlue(drop_in_place, Some(ty))\n-                } else {\n-                    ty::InstanceDef::DropGlue(drop_in_place, None)\n+                let instance = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n+\n+                if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n+                    // we don't actually need to drop anything\n+                    return Ok(());\n+                }\n+\n+                let mir = match ty.sty {\n+                    ty::TyDynamic(..) => unimplemented!(),\n+                    ty::TyArray(..) | ty::TySlice(..) => ::eval_context::MirRef::clone(&self.seq_drop_glue),\n+                    _ => self.load_mir(instance.def)?,\n                 };\n-                let substs = self.substs();\n-                let instance = ty::Instance { substs, def };\n-                let mir = self.load_mir(instance.def)?;\n+\n                 self.push_stack_frame(\n                     instance,\n                     terminator.source_info.span,\n@@ -162,19 +166,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.dump_local(ret);\n                 Ok(())\n             },\n-            /*Abi::C => {\n-                let sig = self.erase_lifetimes(&sig);\n-                let ty = sig.output();\n-                let (ret, target) = destination.unwrap();\n-                match instance.def {\n-                    ty::InstanceDef::Item(_) => {},\n-                    _ => bug!(\"C abi function must be InstanceDef::Item\"),\n-                }\n-                self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n-                self.dump_local(ret);\n-                self.goto_block(target);\n-                Ok(())\n-            },*/\n             ty::InstanceDef::ClosureOnceShim{..} => {\n                 let mut args = Vec::new();\n                 for arg in arg_operands {\n@@ -198,7 +189,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     args.push((arg_val, arg_ty));\n                 }\n                 match sig.abi {\n-                    Abi::C => unimplemented!(),\n+                    Abi::C => {\n+                        let ty = sig.output();\n+                        let (ret, target) = destination.unwrap();\n+                        self.call_c_abi(instance.def_id(), arg_operands, ret, ty)?;\n+                        self.dump_local(ret);\n+                        self.goto_block(target);\n+                        return Ok(());\n+                    },\n                     Abi::Rust => {},\n                     Abi::RustCall => self.unpack_fn_args(&mut args)?,\n                     _ => unimplemented!(),"}]}