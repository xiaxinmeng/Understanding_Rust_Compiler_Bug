{"sha": "b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMGU2YTdiNTY5NDJmMzFjYmQ3YjlmZGI3ODkyNWJmNWI2NWIyNDc=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-07T16:22:08Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-12T12:25:58Z"}, "message": "Handle extend selection in recursive macro", "tree": {"sha": "f7b7cca49841cd219a8b7060a091367cff68ec60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7b7cca49841cd219a8b7060a091367cff68ec60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "html_url": "https://github.com/rust-lang/rust/commit/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07f4171b1803f562118671255d73b97f20d24e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f4171b1803f562118671255d73b97f20d24e07", "html_url": "https://github.com/rust-lang/rust/commit/07f4171b1803f562118671255d73b97f20d24e07"}], "stats": {"total": 76, "additions": 49, "deletions": 27}, "files": [{"sha": "a9ad4b476e74e87f8ada56d4e4f66cf69c9a5e10", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "patch": "@@ -9,21 +9,22 @@ use ra_syntax::{\n     SyntaxNode, SyntaxToken, TextRange, TextUnit, TokenAtOffset, T,\n };\n \n-use crate::{db::RootDatabase, FileRange};\n-use hir::{db::AstDatabase, InFile};\n+use crate::{db::RootDatabase, expand::descend_into_macros, FileId, FileRange};\n+use hir::db::AstDatabase;\n use itertools::Itertools;\n \n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let src = db.parse(frange.file_id).tree();\n-    let root = InFile::new(frange.file_id.into(), src.syntax());\n-    try_extend_selection(db, root, frange.range).unwrap_or(frange.range)\n+    try_extend_selection(db, src.syntax(), frange).unwrap_or(frange.range)\n }\n \n fn try_extend_selection(\n     db: &RootDatabase,\n-    root: InFile<&SyntaxNode>,\n-    range: TextRange,\n+    root: &SyntaxNode,\n+    frange: FileRange,\n ) -> Option<TextRange> {\n+    let range = frange.range;\n+\n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     let list_kinds = [\n         RECORD_FIELD_PAT_LIST,\n@@ -46,9 +47,9 @@ fn try_extend_selection(\n \n     if range.is_empty() {\n         let offset = range.start();\n-        let mut leaves = root.value.token_at_offset(offset);\n+        let mut leaves = root.token_at_offset(offset);\n         if leaves.clone().all(|it| it.kind() == WHITESPACE) {\n-            return Some(extend_ws(root.value, leaves.next()?, offset));\n+            return Some(extend_ws(root, leaves.next()?, offset));\n         }\n         let leaf_range = match leaves {\n             TokenAtOffset::None => return None,\n@@ -64,7 +65,7 @@ fn try_extend_selection(\n         };\n         return Some(leaf_range);\n     };\n-    let node = match find_covering_element(root.value, range) {\n+    let node = match find_covering_element(root, range) {\n         NodeOrToken::Token(token) => {\n             if token.text_range() != range {\n                 return Some(token.text_range());\n@@ -82,7 +83,7 @@ fn try_extend_selection(\n     // if we are in single token_tree, we maybe live in macro or attr\n     if node.kind() == TOKEN_TREE {\n         if let Some(macro_call) = node.ancestors().find_map(ast::MacroCall::cast) {\n-            if let Some(range) = extend_tokens_from_range(db, &root, macro_call, range) {\n+            if let Some(range) = extend_tokens_from_range(db, frange.file_id, macro_call, range) {\n                 return Some(range);\n             }\n         }\n@@ -105,48 +106,52 @@ fn try_extend_selection(\n \n fn extend_tokens_from_range(\n     db: &RootDatabase,\n-    root: &InFile<&SyntaxNode>,\n+    file_id: FileId,\n     macro_call: ast::MacroCall,\n     original_range: TextRange,\n ) -> Option<TextRange> {\n-    let analyzer = hir::SourceAnalyzer::new(db, root.clone(), None);\n-    let expansion = analyzer.expand(db, root.with_value(&macro_call))?;\n-\n     // compute original mapped token range\n+    let mut expanded = None;\n     let range = macro_call\n         .syntax()\n         .descendants_with_tokens()\n         .filter_map(|n| match n {\n             NodeOrToken::Token(token) if token.text_range().is_subrange(&original_range) => {\n-                expansion\n-                    .map_token_down(db, root.with_value(&token))\n-                    .map(|node| node.value.text_range())\n+                let node = descend_into_macros(db, file_id, token);\n+                match node.file_id {\n+                    it if it == file_id.into() => None,\n+                    it if expanded.is_none() || expanded == Some(it) => {\n+                        expanded = Some(it.into());\n+                        Some(node.value.text_range())\n+                    }\n+                    _ => None,\n+                }\n             }\n             _ => None,\n         })\n         .fold1(|x, y| union_range(x, y))?;\n \n-    let src = db.parse_or_expand(expansion.file_id())?;\n+    let expanded = expanded?;\n+    let src = db.parse_or_expand(expanded)?;\n     let parent = shallowest_node(&find_covering_element(&src, range))?.parent()?;\n-\n     // compute parent mapped token range\n     let range = macro_call\n         .syntax()\n         .descendants_with_tokens()\n         .filter_map(|n| match n {\n             NodeOrToken::Token(token) => {\n-                expansion.map_token_down(db, root.with_value(&token)).and_then(|node| {\n-                    if node.value.text_range().is_subrange(&parent.text_range()) {\n-                        Some(token.text_range())\n-                    } else {\n-                        None\n-                    }\n-                })\n+                let node = descend_into_macros(db, file_id, token.clone());\n+                if node.file_id == expanded\n+                    && node.value.text_range().is_subrange(&parent.text_range())\n+                {\n+                    Some(token.text_range())\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         })\n         .fold1(|x, y| union_range(x, y))?;\n-\n     if original_range.is_subrange(&range) && original_range != range {\n         Some(range)\n     } else {\n@@ -597,4 +602,21 @@ fn main() { let var = (\n             ],\n         );\n     }\n+\n+    #[test]\n+    fn extend_selection_inside_recur_macros() {\n+        do_check(\n+            r#\" macro_rules! foo2 { ($item:item) => {$item} }\n+                macro_rules! foo { ($item:item) => {foo2!($item);} }\n+                foo!{fn hello(na<|>me:usize){}}\"#,\n+            &[\n+                \"name\",\n+                \"name:usize\",\n+                \"(name:usize)\",\n+                \"fn hello(name:usize){}\",\n+                \"{fn hello(name:usize){}}\",\n+                \"foo!{fn hello(name:usize){}}\",\n+            ],\n+        );\n+    }\n }"}]}