{"sha": "a2081deb2d16c58f2b367ad8a8d4a047d80f51a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDgxZGViMmQxNmM1OGYyYjM2N2FkOGE4ZDRhMDQ3ZDgwZjUxYTY=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-01-27T21:51:41Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-01-27T21:51:41Z"}, "message": "Simplify and fix the resolution of expr_path. With this we now get to codegen\nin\n-------------------\ntype foo = rec(int a);\nmod m1 {\n  mod m2 {\n    const foo bar = rec(a = 4);\n  }\n}\nfn main(vec[str] args) {\n  log m1.m2.bar.a;\n}\n-------------------", "tree": {"sha": "b4cb550e0e8c059a81730282d8e2b83cf93966e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4cb550e0e8c059a81730282d8e2b83cf93966e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6", "html_url": "https://github.com/rust-lang/rust/commit/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6/comments", "author": null, "committer": null, "parents": [{"sha": "c170e7edfdfe156f11374d5e3c265b613351dc99", "url": "https://api.github.com/repos/rust-lang/rust/commits/c170e7edfdfe156f11374d5e3c265b613351dc99", "html_url": "https://github.com/rust-lang/rust/commit/c170e7edfdfe156f11374d5e3c265b613351dc99"}], "stats": {"total": 29, "additions": 10, "deletions": 19}, "files": [{"sha": "380ec150cf6124965ddb907e4a083bd99d0c8a17", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2081deb2d16c58f2b367ad8a8d4a047d80f51a6/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a2081deb2d16c58f2b367ad8a8d4a047d80f51a6", "patch": "@@ -35,7 +35,7 @@ tag def_wrap {\n     def_wrap_import(@ast.view_item);\n     def_wrap_mod(@ast.item);\n     def_wrap_other(def);\n-    def_wrap_expr_field(uint);\n+    def_wrap_expr_field(uint, def);\n     def_wrap_resolving;\n }\n \n@@ -72,6 +72,9 @@ fn unwrap_def(def_wrap d) -> def {\n         case (def_wrap_other(?d)) {\n             ret d;\n         }\n+        case (def_wrap_expr_field(_, ?d)) {\n+            ret d;\n+        }\n     }\n }\n \n@@ -140,9 +143,9 @@ fn find_final_def(&env e, import_map index,\n             case (def_wrap_use(?c)) {\n                 e.sess.span_err(sp, \"Crate access is not implemented\");\n             }\n-            case (_) {\n+            case (def_wrap_other(?d)) {\n                 let uint l = _vec.len[ident](idents);\n-                ret def_wrap_expr_field(l);\n+                ret def_wrap_expr_field(l, d);\n             }\n         }\n         fail;\n@@ -419,26 +422,13 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n                   ann a) -> @ast.expr {\n     auto n_idents = _vec.len[ast.ident](p.node.idents);\n-\n     check (n_idents != 0u);\n-    auto id0 = p.node.idents.(0);\n-\n-    auto d_ = lookup_name(e, id0);\n-\n-    alt (d_) {\n-        case (some[def](_)) {\n-            // log \"resolved name \" + n.node.ident;\n-        }\n-        case (none[def]) {\n-            e.sess.span_err(sp, \"unresolved name: \" + id0);\n-        }\n-    }\n \n     auto index = new_def_hash[def_wrap]();\n     auto d = find_final_def(e, index, sp, p.node.idents, none[ast.def_id]);\n     let uint path_len = 0u;\n     alt (d) {\n-        case (def_wrap_expr_field(?remaining)) {\n+        case (def_wrap_expr_field(?remaining, _)) {\n             path_len = n_idents - remaining + 1u;\n         }\n         case (def_wrap_other(_)) {\n@@ -453,7 +443,8 @@ fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n     }\n     auto path_elems =\n         _vec.slice[ident](p.node.idents, 0u, path_len);\n-    auto p_ = rec(node=rec(idents = vec(id0) with p.node) with p);\n+    auto p_ = rec(node=rec(idents = path_elems with p.node) with p);\n+    auto d_ = some(unwrap_def(d));\n     auto ex = @fold.respan[ast.expr_](sp, ast.expr_path(p_, d_, a));\n     auto i = path_len;\n     while (i < n_idents) {\n@@ -473,7 +464,7 @@ fn fold_view_item_import(&env e, &span sp,\n     auto last_id = is.(len - 1u);\n     auto d = find_final_def(e, index, sp, is, some(id));\n     alt (d) {\n-        case (def_wrap_expr_field(?remain)) {\n+        case (def_wrap_expr_field(?remain, _)) {\n             auto ident = is.(len - remain);\n             e.sess.span_err(sp, ident + \" is not a module or crate\");\n         }"}]}