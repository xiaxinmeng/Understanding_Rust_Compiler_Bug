{"sha": "47256b8b7c78f188defaed8f5491ce01812622b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MjU2YjhiN2M3OGYxODhkZWZhZWQ4ZjU0OTFjZTAxODEyNjIyYjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T14:31:56Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T16:37:01Z"}, "message": "Remove private methods from TyCtxt impl block: rustc::infer::error_reporting.", "tree": {"sha": "9d1d710ac14c012e41b25acb1c055a7e514508ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d1d710ac14c012e41b25acb1c055a7e514508ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47256b8b7c78f188defaed8f5491ce01812622b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47256b8b7c78f188defaed8f5491ce01812622b1", "html_url": "https://github.com/rust-lang/rust/commit/47256b8b7c78f188defaed8f5491ce01812622b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47256b8b7c78f188defaed8f5491ce01812622b1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "637793a1999f46d10c9567f302ca211385702224", "url": "https://api.github.com/repos/rust-lang/rust/commits/637793a1999f46d10c9567f302ca211385702224", "html_url": "https://github.com/rust-lang/rust/commit/637793a1999f46d10c9567f302ca211385702224"}], "stats": {"total": 217, "additions": 109, "deletions": 108}, "files": [{"sha": "e653f645881f87bc87341723114fafd584aa8222", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/47256b8b7c78f188defaed8f5491ce01812622b1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47256b8b7c78f188defaed8f5491ce01812622b1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=47256b8b7c78f188defaed8f5491ce01812622b1", "patch": "@@ -107,9 +107,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                         _ => \"expression\",\n                     },\n                     Some(Node::Stmt(_)) => \"statement\",\n-                    Some(Node::Item(it)) => Self::item_scope_tag(&it),\n-                    Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n+                    Some(Node::Item(it)) => item_scope_tag(&it),\n+                    Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n+                    Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -131,11 +131,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                         &new_string[..]\n                     }\n                 };\n-                self.explain_span(scope_decorated_tag, span)\n+                explain_span(self, scope_decorated_tag, span)\n             }\n \n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n-                self.msg_span_from_free_region(region)\n+                msg_span_from_free_region(self, region)\n             }\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n@@ -157,7 +157,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         };\n \n-        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+        emit_msg_span(err, prefix, description, span, suffix);\n     }\n \n     pub fn note_and_explain_free_region(\n@@ -167,124 +167,124 @@ impl<'tcx> TyCtxt<'tcx> {\n         region: ty::Region<'tcx>,\n         suffix: &str,\n     ) {\n-        let (description, span) = self.msg_span_from_free_region(region);\n+        let (description, span) = msg_span_from_free_region(self, region);\n \n-        TyCtxt::emit_msg_span(err, prefix, description, span, suffix);\n+        emit_msg_span(err, prefix, description, span, suffix);\n     }\n+}\n \n-    fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n-        match *region {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                self.msg_span_from_early_bound_and_free_regions(region)\n-            }\n-            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-            ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n-            _ => bug!(\"{:?}\", region),\n+fn msg_span_from_free_region(\n+    tcx: TyCtxt<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> (String, Option<Span>) {\n+    match *region {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+            msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n+        ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        _ => bug!(\"{:?}\", region),\n     }\n+}\n \n-    fn msg_span_from_early_bound_and_free_regions(\n-        self,\n-        region: ty::Region<'tcx>,\n-    ) -> (String, Option<Span>) {\n-        let cm = self.sess.source_map();\n-\n-        let scope = region.free_region_binding_scope(self);\n-        let node = self.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n-        let tag = match self.hir().find(node) {\n-            Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n-            Some(Node::Item(it)) => Self::item_scope_tag(&it),\n-            Some(Node::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(Node::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n-            _ => unreachable!(),\n-        };\n-        let (prefix, span) = match *region {\n-            ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n-                if let Some(param) =\n-                    self.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n-                {\n-                    sp = param.span;\n-                }\n-                (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n-            }\n-            ty::ReFree(ty::FreeRegion {\n-                bound_region: ty::BoundRegion::BrNamed(_, name), ..\n-            }) => {\n-                let mut sp = cm.def_span(self.hir().span(node));\n-                if let Some(param) =\n-                    self.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n-                {\n-                    sp = param.span;\n-                }\n-                (format!(\"the lifetime `{}` as defined on\", name), sp)\n-            }\n-            ty::ReFree(ref fr) => match fr.bound_region {\n-                ty::BrAnon(idx) => (\n-                    format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span(node),\n-                ),\n-                _ => (\n-                    format!(\"the lifetime `{}` as defined on\", region),\n-                    cm.def_span(self.hir().span(node)),\n-                ),\n-            },\n-            _ => bug!(),\n-        };\n-        let (msg, opt_span) = self.explain_span(tag, span);\n-        (format!(\"{} {}\", prefix, msg), opt_span)\n-    }\n-\n-    fn emit_msg_span(\n-        err: &mut DiagnosticBuilder<'_>,\n-        prefix: &str,\n-        description: String,\n-        span: Option<Span>,\n-        suffix: &str,\n-    ) {\n-        let message = format!(\"{}{}{}\", prefix, description, suffix);\n-\n-        if let Some(span) = span {\n-            err.span_note(span, &message);\n-        } else {\n-            err.note(&message);\n+fn msg_span_from_early_bound_and_free_regions(\n+    tcx: TyCtxt<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> (String, Option<Span>) {\n+    let cm = tcx.sess.source_map();\n+\n+    let scope = region.free_region_binding_scope(tcx);\n+    let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n+    let tag = match tcx.hir().find(node) {\n+        Some(Node::Block(_)) | Some(Node::Expr(_)) => \"body\",\n+        Some(Node::Item(it)) => item_scope_tag(&it),\n+        Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n+        Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n+        _ => unreachable!(),\n+    };\n+    let (prefix, span) = match *region {\n+        ty::ReEarlyBound(ref br) => {\n+            let mut sp = cm.def_span(tcx.hir().span(node));\n+            if let Some(param) =\n+                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+            {\n+                sp = param.span;\n+            }\n+            (format!(\"the lifetime `{}` as defined on\", br.name), sp)\n         }\n-    }\n-\n-    fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n-        match item.kind {\n-            hir::ItemKind::Impl(..) => \"impl\",\n-            hir::ItemKind::Struct(..) => \"struct\",\n-            hir::ItemKind::Union(..) => \"union\",\n-            hir::ItemKind::Enum(..) => \"enum\",\n-            hir::ItemKind::Trait(..) => \"trait\",\n-            hir::ItemKind::Fn(..) => \"function body\",\n-            _ => \"item\",\n+        ty::ReFree(ty::FreeRegion { bound_region: ty::BoundRegion::BrNamed(_, name), .. }) => {\n+            let mut sp = cm.def_span(tcx.hir().span(node));\n+            if let Some(param) =\n+                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+            {\n+                sp = param.span;\n+            }\n+            (format!(\"the lifetime `{}` as defined on\", name), sp)\n         }\n+        ty::ReFree(ref fr) => match fr.bound_region {\n+            ty::BrAnon(idx) => {\n+                (format!(\"the anonymous lifetime #{} defined on\", idx + 1), tcx.hir().span(node))\n+            }\n+            _ => (\n+                format!(\"the lifetime `{}` as defined on\", region),\n+                cm.def_span(tcx.hir().span(node)),\n+            ),\n+        },\n+        _ => bug!(),\n+    };\n+    let (msg, opt_span) = explain_span(tcx, tag, span);\n+    (format!(\"{} {}\", prefix, msg), opt_span)\n+}\n+\n+fn emit_msg_span(\n+    err: &mut DiagnosticBuilder<'_>,\n+    prefix: &str,\n+    description: String,\n+    span: Option<Span>,\n+    suffix: &str,\n+) {\n+    let message = format!(\"{}{}{}\", prefix, description, suffix);\n+\n+    if let Some(span) = span {\n+        err.span_note(span, &message);\n+    } else {\n+        err.note(&message);\n     }\n+}\n \n-    fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n-        match item.kind {\n-            hir::TraitItemKind::Method(..) => \"method body\",\n-            hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n-        }\n+fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ItemKind::Impl(..) => \"impl\",\n+        hir::ItemKind::Struct(..) => \"struct\",\n+        hir::ItemKind::Union(..) => \"union\",\n+        hir::ItemKind::Enum(..) => \"enum\",\n+        hir::ItemKind::Trait(..) => \"trait\",\n+        hir::ItemKind::Fn(..) => \"function body\",\n+        _ => \"item\",\n     }\n+}\n \n-    fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n-        match item.kind {\n-            hir::ImplItemKind::Method(..) => \"method body\",\n-            hir::ImplItemKind::Const(..)\n-            | hir::ImplItemKind::OpaqueTy(..)\n-            | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n-        }\n+fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::TraitItemKind::Method(..) => \"method body\",\n+        hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => \"associated item\",\n     }\n+}\n \n-    fn explain_span(self, heading: &str, span: Span) -> (String, Option<Span>) {\n-        let lo = self.sess.source_map().lookup_char_pos(span.lo());\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n+fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n+    match item.kind {\n+        hir::ImplItemKind::Method(..) => \"method body\",\n+        hir::ImplItemKind::Const(..)\n+        | hir::ImplItemKind::OpaqueTy(..)\n+        | hir::ImplItemKind::TyAlias(..) => \"associated item\",\n     }\n }\n \n+fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option<Span>) {\n+    let lo = tcx.sess.source_map().lookup_char_pos(span.lo());\n+    (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,"}, {"sha": "6c78e70a4444d785cb6da19cf65305568291f2e6", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47256b8b7c78f188defaed8f5491ce01812622b1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47256b8b7c78f188defaed8f5491ce01812622b1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=47256b8b7c78f188defaed8f5491ce01812622b1", "patch": "@@ -1,5 +1,6 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n@@ -32,7 +33,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     );\n                     err.span_label(sup_origin.span(), \"...but this borrow...\");\n \n-                    let (lifetime, lt_sp_opt) = self.tcx().msg_span_from_free_region(sup_r);\n+                    let (lifetime, lt_sp_opt) = msg_span_from_free_region(self.tcx(), sup_r);\n                     if let Some(lifetime_sp) = lt_sp_opt {\n                         err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n                     }"}]}