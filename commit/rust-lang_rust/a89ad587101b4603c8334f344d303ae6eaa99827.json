{"sha": "a89ad587101b4603c8334f344d303ae6eaa99827", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OWFkNTg3MTAxYjQ2MDNjODMzNGYzNDRkMzAzYWU2ZWFhOTk4Mjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-07T04:32:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-09T16:44:01Z"}, "message": "rustc: Reformat check_const with modern style\n\nRemove a bunch of two-space tabs", "tree": {"sha": "59eaff82f74d36d83b822d11ed17c7e758cd7eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59eaff82f74d36d83b822d11ed17c7e758cd7eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a89ad587101b4603c8334f344d303ae6eaa99827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a89ad587101b4603c8334f344d303ae6eaa99827", "html_url": "https://github.com/rust-lang/rust/commit/a89ad587101b4603c8334f344d303ae6eaa99827", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a89ad587101b4603c8334f344d303ae6eaa99827/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfd52817ee81676e0cdba4ab2c5badf195fcfda7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd52817ee81676e0cdba4ab2c5badf195fcfda7", "html_url": "https://github.com/rust-lang/rust/commit/dfd52817ee81676e0cdba4ab2c5badf195fcfda7"}], "stats": {"total": 144, "additions": 78, "deletions": 66}, "files": [{"sha": "bb62a96f0adc62342e2b6c1b93f25fbf9872ee9d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a89ad587101b4603c8334f344d303ae6eaa99827/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a89ad587101b4603c8334f344d303ae6eaa99827/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a89ad587101b4603c8334f344d303ae6eaa99827", "patch": "@@ -47,7 +47,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         check_pat(self, p);\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n-        check_expr(self, ex);\n+        if check_expr(self, ex) {\n+            visit::walk_expr(v, e);\n+        }\n     }\n }\n \n@@ -96,73 +98,80 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     }\n }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n-    if v.in_const {\n-        match e.node {\n-          ExprUnary(UnDeref, _) => { }\n-          ExprUnary(UnUniq, _) => {\n-            span_err!(v.tcx.sess, e.span, E0010, \"cannot do allocations in constant expressions\");\n-            return;\n-          }\n-          ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n-          ExprBinary(..) | ExprUnary(..) => {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n+    if !v.in_const { return true }\n+\n+    match e.node {\n+        ExprUnary(UnDeref, _) => {}\n+        ExprUnary(UnUniq, _) => {\n+            span_err!(v.tcx.sess, e.span, E0010,\n+                      \"cannot do allocations in constant expressions\");\n+            return false;\n+        }\n+        ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n+        ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n                 span_err!(v.tcx.sess, e.span, E0011,\n-                    \"user-defined operators are not allowed in constant expressions\");\n+                          \"user-defined operators are not allowed in constant \\\n+                           expressions\");\n             }\n-          }\n-          ExprLit(_) => (),\n-          ExprCast(_, _) => {\n+        }\n+        ExprLit(_) => (),\n+        ExprCast(_, _) => {\n             let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n                 span_err!(v.tcx.sess, e.span, E0012,\n-                    \"can not cast to `{}` in a constant expression\",\n-                    ppaux::ty_to_string(v.tcx, ety)\n-                );\n+                          \"can not cast to `{}` in a constant expression\",\n+                          ppaux::ty_to_string(v.tcx, ety));\n             }\n-          }\n-          ExprPath(ref pth) => {\n+        }\n+        ExprPath(ref pth) => {\n             // NB: In the future you might wish to relax this slightly\n             // to handle on-demand instantiation of functions via\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n             if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n                 span_err!(v.tcx.sess, e.span, E0013,\n-                    \"paths in constants may only refer to items without type parameters\");\n+                          \"paths in constants may only refer to items without \\\n+                           type parameters\");\n             }\n             match v.tcx.def_map.borrow().find(&e.id) {\n-              Some(&DefStatic(..)) |\n-              Some(&DefFn(..)) |\n-              Some(&DefVariant(_, _, _)) |\n-              Some(&DefStruct(_)) => { }\n-\n-              Some(&def) => {\n-                debug!(\"(checking const) found bad def: {:?}\", def);\n-                span_err!(v.tcx.sess, e.span, E0014,\n-                    \"paths in constants may only refer to constants or functions\");\n-              }\n-              None => {\n-                v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n-              }\n+                Some(&DefStatic(..)) |\n+                Some(&DefFn(..)) |\n+                Some(&DefVariant(_, _, _)) |\n+                Some(&DefStruct(_)) => { }\n+\n+                Some(&def) => {\n+                    debug!(\"(checking const) found bad def: {:?}\", def);\n+                    span_err!(v.tcx.sess, e.span, E0014,\n+                              \"paths in constants may only refer to constants \\\n+                               or functions\");\n+                }\n+                None => {\n+                    v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n+                }\n             }\n-          }\n-          ExprCall(ref callee, _) => {\n+        }\n+        ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n+\n                 _ => {\n                     span_err!(v.tcx.sess, e.span, E0015,\n-                      \"function calls in constants are limited to struct and enum constructors\");\n+                              \"function calls in constants are limited to \\\n+                               struct and enum constructors\");\n                 }\n             }\n-          }\n-          ExprBlock(ref block) => {\n+        }\n+        ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n                 let block_span_err = |span|\n                     span_err!(v.tcx.sess, span, E0016,\n-                        \"blocks in constants are limited to items and tail expressions\");\n+                              \"blocks in constants are limited to items and \\\n+                               tail expressions\");\n                 match stmt.node {\n                     StmtDecl(ref span, _) => {\n                         match span.node {\n@@ -174,40 +183,43 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n                     }\n                     StmtExpr(ref expr, _) => block_span_err(expr.span),\n                     StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    StmtMac(..) => v.tcx.sess.span_bug(e.span,\n-                        \"unexpanded statement macro in const?!\")\n+                    StmtMac(..) => {\n+                        v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n+                                                     macro in const?!\")\n+                    }\n                 }\n             }\n             match block.expr {\n                 Some(ref expr) => check_expr(v, &**expr),\n                 None => {}\n             }\n-          }\n-          ExprVec(_) |\n-          ExprAddrOf(MutImmutable, _) |\n-          ExprParen(..) |\n-          ExprField(..) |\n-          ExprTupField(..) |\n-          ExprIndex(..) |\n-          ExprTup(..) |\n-          ExprRepeat(..) |\n-          ExprStruct(..) => { }\n-          ExprAddrOf(_, ref inner) => {\n-                match inner.node {\n-                    // Mutable slices are allowed.\n-                    ExprVec(_) => {}\n-                    _ => span_err!(v.tcx.sess, e.span, E0017,\n-                                   \"references in constants may only refer to immutable values\")\n+        }\n+        ExprVec(_) |\n+        ExprAddrOf(MutImmutable, _) |\n+        ExprParen(..) |\n+        ExprField(..) |\n+        ExprTupField(..) |\n+        ExprIndex(..) |\n+        ExprTup(..) |\n+        ExprRepeat(..) |\n+        ExprStruct(..) => {}\n \n-                }\n-          },\n+        ExprAddrOf(_, ref inner) => {\n+            match inner.node {\n+                // Mutable slices are allowed.\n+                ExprVec(_) => {}\n+                _ => span_err!(v.tcx.sess, e.span, E0017,\n+                               \"references in constants may only refer \\\n+                                to immutable values\")\n+\n+            }\n+        }\n \n-          _ => {\n-              span_err!(v.tcx.sess, e.span, E0019,\n-                  \"constant contains unimplemented expression type\");\n-              return;\n-          }\n+        _ => {\n+            span_err!(v.tcx.sess, e.span, E0019,\n+                      \"constant contains unimplemented expression type\");\n+            return false;\n         }\n     }\n-    visit::walk_expr(v, e);\n+    true\n }"}]}