{"sha": "c395c3311dc2ac59251e86eaa6b86b597358d31f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTVjMzMxMWRjMmFjNTkyNTFlODZlYWE2Yjg2YjU5NzM1OGQzMWY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-21T22:51:13Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:58:33Z"}, "message": "Filter out path items by the qualifier", "tree": {"sha": "d35715eecb794064bea787333cada1804aacfeac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d35715eecb794064bea787333cada1804aacfeac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c395c3311dc2ac59251e86eaa6b86b597358d31f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c395c3311dc2ac59251e86eaa6b86b597358d31f", "html_url": "https://github.com/rust-lang/rust/commit/c395c3311dc2ac59251e86eaa6b86b597358d31f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c395c3311dc2ac59251e86eaa6b86b597358d31f/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a", "html_url": "https://github.com/rust-lang/rust/commit/f08c0cdd2a99d2851d472d2c6b3f54d37aa13e8a"}], "stats": {"total": 39, "additions": 15, "deletions": 24}, "files": [{"sha": "976dc92fbcab1f5c9c581cf490a90c80102bfeb9", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c395c3311dc2ac59251e86eaa6b86b597358d31f/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c395c3311dc2ac59251e86eaa6b86b597358d31f/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=c395c3311dc2ac59251e86eaa6b86b597358d31f", "patch": "@@ -1,8 +1,8 @@\n //! Look up accessible paths for items.\n use either::Either;\n use hir::{\n-    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, PathResolution,\n-    PrefixKind, Semantics,\n+    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, PrefixKind,\n+    Semantics,\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n@@ -192,7 +192,7 @@ impl ImportAssets {\n         let db = sema.db;\n \n         match &self.import_candidate {\n-            ImportCandidate::Path(path_candidate) => Box::new(path_applicable_defs(\n+            ImportCandidate::Path(path_candidate) => Box::new(path_applicable_items(\n                 sema,\n                 path_candidate,\n                 unfiltered_defs\n@@ -223,37 +223,28 @@ impl ImportAssets {\n     }\n }\n \n-fn path_applicable_defs<'a>(\n+fn path_applicable_items<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     path_candidate: &PathImportCandidate,\n     unfiltered_defs: impl Iterator<Item = (ModPath, ItemInNs)> + 'a,\n-) -> impl Iterator<Item = (ModPath, ItemInNs)> + 'a {\n+) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n     let unresolved_qualifier = match &path_candidate.unresolved_qualifier {\n         Some(qualifier) => qualifier,\n         None => {\n-            return unfiltered_defs;\n+            return Box::new(unfiltered_defs);\n         }\n     };\n \n-    // TODO kb filter out items: found path should end with `qualifier::Name` or `qualifier::Something` for fuzzy search case.\n+    let qualifier_string = unresolved_qualifier.to_string();\n+    Box::new(unfiltered_defs.filter(move |(candidate_path, _)| {\n+        let mut candidate_qualifier = candidate_path.clone();\n+        candidate_qualifier.pop_segment();\n \n-    // TODO kb find a way to turn a qualifier into the corresponding ModuleDef. Maybe through the unfiltered data?\n-    if let Some(qualifier_start_resolution) = resolve_qualifier_start(sema, unresolved_qualifier) {\n-        // TODO kb ascend until an unresolved segment part appears\n-    } else {\n-        // first segment is already unresolved, need to turn it into ModuleDef somehow\n-    }\n-\n-    return unfiltered_defs;\n-}\n-\n-fn resolve_qualifier_start(\n-    sema: &Semantics<RootDatabase>,\n-    qualifier: &ast::Path,\n-) -> Option<PathResolution> {\n-    let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-    let qualifier_start_path = qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-    sema.resolve_path(&qualifier_start_path)\n+        // TODO kb\n+        // * take 1st segment of `unresolved_qualifier` and return it instead of the original `ItemInNs`\n+        // * Update `ModPath`: pop until 1st segment of `unresolved_qualifier` reached (do not rely on name comparison, nested mod names can repeat)\n+        candidate_qualifier.to_string().ends_with(&qualifier_string)\n+    }))\n }\n \n fn trait_applicable_defs<'a>("}]}