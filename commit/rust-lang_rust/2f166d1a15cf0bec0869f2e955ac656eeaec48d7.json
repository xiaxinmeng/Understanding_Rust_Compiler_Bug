{"sha": "2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "node_id": "C_kwDOAAsO6NoAKDJmMTY2ZDFhMTVjZjBiZWMwODY5ZjJlOTU1YWM2NTZlZWFlYzQ4ZDc", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-03-05T15:12:00Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-03-10T20:21:45Z"}, "message": "Render doc sidebar using Askama", "tree": {"sha": "9faef7307ea38ff764685d0a9aed533684aad5bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9faef7307ea38ff764685d0a9aed533684aad5bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "html_url": "https://github.com/rust-lang/rust/commit/2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39f2657d1101b50f9b71ae460b762d330cc8426b", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f2657d1101b50f9b71ae460b762d330cc8426b", "html_url": "https://github.com/rust-lang/rust/commit/39f2657d1101b50f9b71ae460b762d330cc8426b"}], "stats": {"total": 1260, "additions": 616, "deletions": 644}, "files": [{"sha": "595ddddc7dd646e5529edfcdd4348bc332801a31", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "patch": "@@ -17,10 +17,11 @@ use super::print_item::{full_path, item_path, print_item};\n use super::search_index::build_index;\n use super::write_shared::write_shared;\n use super::{\n-    collect_spans_and_sources, print_sidebar, scrape_examples_help, sidebar_module_like, AllTypes,\n-    LinkFromSrc, StylePath,\n+    collect_spans_and_sources, scrape_examples_help,\n+    sidebar::print_sidebar,\n+    sidebar::{sidebar_module_like, Sidebar},\n+    AllTypes, LinkFromSrc, StylePath,\n };\n-\n use crate::clean::{self, types::ExternalLocation, ExternalCrate};\n use crate::config::{ModuleSorting, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n@@ -35,6 +36,7 @@ use crate::html::url_parts_builder::UrlPartsBuilder;\n use crate::html::{layout, sources, static_files};\n use crate::scrape_examples::AllCallLocations;\n use crate::try_err;\n+use askama::Template;\n \n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n@@ -600,15 +602,18 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         };\n         let all = shared.all.replace(AllTypes::new());\n         let mut sidebar = Buffer::html();\n-        write!(sidebar, \"<h2 class=\\\"location\\\"><a href=\\\"#\\\">Crate {}</a></h2>\", crate_name);\n-\n-        let mut items = Buffer::html();\n-        sidebar_module_like(&mut items, all.item_sections());\n-        if !items.is_empty() {\n-            sidebar.push_str(\"<div class=\\\"sidebar-elems\\\">\");\n-            sidebar.push_buffer(items);\n-            sidebar.push_str(\"</div>\");\n-        }\n+\n+        let blocks = sidebar_module_like(all.item_sections());\n+        let bar = Sidebar {\n+            title_prefix: \"Crate \",\n+            title: crate_name.as_str(),\n+            is_crate: false,\n+            version: \"\",\n+            blocks: vec![blocks],\n+            path: String::new(),\n+        };\n+\n+        bar.render_into(&mut sidebar).unwrap();\n \n         let v = layout::render(\n             &shared.layout,"}, {"sha": "c389dbf379e4546ff6a111179097c11416bcd72c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 632, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "patch": "@@ -30,6 +30,7 @@ mod tests;\n \n mod context;\n mod print_item;\n+mod sidebar;\n mod span_map;\n mod write_shared;\n \n@@ -49,11 +50,9 @@ use std::string::ToString;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{ConstStability, Deprecation, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n     symbol::{sym, Symbol},\n@@ -1869,154 +1868,6 @@ pub(crate) fn render_impl_summary(\n     w.write_str(\"</section>\");\n }\n \n-fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n-    if it.is_struct()\n-        || it.is_trait()\n-        || it.is_primitive()\n-        || it.is_union()\n-        || it.is_enum()\n-        || it.is_mod()\n-        || it.is_typedef()\n-    {\n-        write!(\n-            buffer,\n-            \"<h2 class=\\\"location\\\"><a href=\\\"#\\\">{}{}</a></h2>\",\n-            match *it.kind {\n-                clean::ModuleItem(..) =>\n-                    if it.is_crate() {\n-                        \"Crate \"\n-                    } else {\n-                        \"Module \"\n-                    },\n-                _ => \"\",\n-            },\n-            it.name.as_ref().unwrap()\n-        );\n-    }\n-\n-    buffer.write_str(\"<div class=\\\"sidebar-elems\\\">\");\n-    if it.is_crate() {\n-        write!(buffer, \"<ul class=\\\"block\\\">\");\n-        if let Some(ref version) = cx.cache().crate_version {\n-            write!(buffer, \"<li class=\\\"version\\\">Version {}</li>\", Escape(version));\n-        }\n-        write!(buffer, \"<li><a id=\\\"all-types\\\" href=\\\"all.html\\\">All Items</a></li>\");\n-        buffer.write_str(\"</ul>\");\n-    }\n-\n-    match *it.kind {\n-        clean::StructItem(ref s) => sidebar_struct(cx, buffer, it, s),\n-        clean::TraitItem(ref t) => sidebar_trait(cx, buffer, it, t),\n-        clean::PrimitiveItem(_) => sidebar_primitive(cx, buffer, it),\n-        clean::UnionItem(ref u) => sidebar_union(cx, buffer, it, u),\n-        clean::EnumItem(ref e) => sidebar_enum(cx, buffer, it, e),\n-        clean::TypedefItem(_) => sidebar_typedef(cx, buffer, it),\n-        clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n-        clean::ForeignTypeItem => sidebar_foreign_type(cx, buffer, it),\n-        _ => {}\n-    }\n-\n-    // The sidebar is designed to display sibling functions, modules and\n-    // other miscellaneous information. since there are lots of sibling\n-    // items (and that causes quadratic growth in large modules),\n-    // we refactor common parts into a shared JavaScript file per module.\n-    // still, we don't move everything into JS because we want to preserve\n-    // as much HTML as possible in order to allow non-JS-enabled browsers\n-    // to navigate the documentation (though slightly inefficiently).\n-\n-    if !it.is_mod() {\n-        let path: String = cx.current.iter().map(|s| s.as_str()).intersperse(\"::\").collect();\n-\n-        write!(buffer, \"<h2><a href=\\\"index.html\\\">In {}</a></h2>\", path);\n-    }\n-\n-    // Closes sidebar-elems div.\n-    buffer.write_str(\"</div>\");\n-}\n-\n-fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n-    if used_links.insert(url.clone()) {\n-        return url;\n-    }\n-    let mut add = 1;\n-    while !used_links.insert(format!(\"{}-{}\", url, add)) {\n-        add += 1;\n-    }\n-    format!(\"{}-{}\", url, add)\n-}\n-\n-struct SidebarLink {\n-    name: Symbol,\n-    url: String,\n-}\n-\n-impl fmt::Display for SidebarLink {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<a href=\\\"#{}\\\">{}</a>\", self.url, self.name)\n-    }\n-}\n-\n-impl PartialEq for SidebarLink {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.url == other.url\n-    }\n-}\n-\n-impl Eq for SidebarLink {}\n-\n-impl PartialOrd for SidebarLink {\n-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for SidebarLink {\n-    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n-        self.url.cmp(&other.url)\n-    }\n-}\n-\n-fn get_methods(\n-    i: &clean::Impl,\n-    for_deref: bool,\n-    used_links: &mut FxHashSet<String>,\n-    deref_mut: bool,\n-    tcx: TyCtxt<'_>,\n-) -> Vec<SidebarLink> {\n-    i.items\n-        .iter()\n-        .filter_map(|item| match item.name {\n-            Some(name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut, tcx) {\n-                    Some(SidebarLink {\n-                        name,\n-                        url: get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n-                    })\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>()\n-}\n-\n-fn get_associated_constants(\n-    i: &clean::Impl,\n-    used_links: &mut FxHashSet<String>,\n-) -> Vec<SidebarLink> {\n-    i.items\n-        .iter()\n-        .filter_map(|item| match item.name {\n-            Some(name) if !name.is_empty() && item.is_associated_const() => Some(SidebarLink {\n-                name,\n-                url: get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n-            }),\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>()\n-}\n-\n pub(crate) fn small_url_encode(s: String) -> String {\n     // These characters don't need to be escaped in a URI.\n     // See https://url.spec.whatwg.org/#query-percent-encode-set\n@@ -2082,232 +1933,6 @@ pub(crate) fn small_url_encode(s: String) -> String {\n     }\n }\n \n-pub(crate) fn sidebar_render_assoc_items(\n-    cx: &Context<'_>,\n-    out: &mut Buffer,\n-    id_map: &mut IdMap,\n-    concrete: Vec<&Impl>,\n-    synthetic: Vec<&Impl>,\n-    blanket_impl: Vec<&Impl>,\n-) {\n-    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n-        let mut links = FxHashSet::default();\n-\n-        let mut ret = impls\n-            .iter()\n-            .filter_map(|it| {\n-                let trait_ = it.inner_impl().trait_.as_ref()?;\n-                let encoded =\n-                    id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n-\n-                let i_display = format!(\"{:#}\", trait_.print(cx));\n-                let out = Escape(&i_display);\n-                let prefix = match it.inner_impl().polarity {\n-                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n-                    ty::ImplPolarity::Negative => \"!\",\n-                };\n-                let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n-                if links.insert(generated.clone()) { Some(generated) } else { None }\n-            })\n-            .collect::<Vec<String>>();\n-        ret.sort();\n-        ret\n-    };\n-\n-    let concrete_format = format_impls(concrete, id_map);\n-    let synthetic_format = format_impls(synthetic, id_map);\n-    let blanket_format = format_impls(blanket_impl, id_map);\n-\n-    if !concrete_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"trait-implementations\",\n-            \"Trait Implementations\",\n-            concrete_format.iter(),\n-        );\n-    }\n-\n-    if !synthetic_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"synthetic-implementations\",\n-            \"Auto Trait Implementations\",\n-            synthetic_format.iter(),\n-        );\n-    }\n-\n-    if !blanket_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"blanket-implementations\",\n-            \"Blanket Implementations\",\n-            blanket_format.iter(),\n-        );\n-    }\n-}\n-\n-fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.item_id.expect_def_id();\n-    let cache = cx.cache();\n-\n-    if let Some(v) = cache.impls.get(&did) {\n-        let mut used_links = FxHashSet::default();\n-        let mut id_map = IdMap::new();\n-\n-        {\n-            let used_links_bor = &mut used_links;\n-            let mut assoc_consts = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_associated_constants(i.inner_impl(), used_links_bor))\n-                .collect::<Vec<_>>();\n-            if !assoc_consts.is_empty() {\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                assoc_consts.sort();\n-\n-                print_sidebar_block(\n-                    out,\n-                    \"implementations\",\n-                    \"Associated Constants\",\n-                    assoc_consts.iter(),\n-                );\n-            }\n-            let mut methods = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx()))\n-                .collect::<Vec<_>>();\n-            if !methods.is_empty() {\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                methods.sort();\n-\n-                print_sidebar_block(out, \"implementations\", \"Methods\", methods.iter());\n-            }\n-        }\n-\n-        if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) =\n-                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n-            {\n-                let mut derefs = DefIdSet::default();\n-                derefs.insert(did);\n-                sidebar_deref_methods(cx, out, impl_, v, &mut derefs, &mut used_links);\n-            }\n-\n-            let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n-            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-                concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n-\n-            sidebar_render_assoc_items(cx, out, &mut id_map, concrete, synthetic, blanket_impl);\n-        }\n-    }\n-}\n-\n-fn sidebar_deref_methods(\n-    cx: &Context<'_>,\n-    out: &mut Buffer,\n-    impl_: &Impl,\n-    v: &[Impl],\n-    derefs: &mut DefIdSet,\n-    used_links: &mut FxHashSet<String>,\n-) {\n-    let c = cx.cache();\n-\n-    debug!(\"found Deref: {:?}\", impl_);\n-    if let Some((target, real_target)) =\n-        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n-                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n-                _ => (&t.type_, &t.type_),\n-            }),\n-            _ => None,\n-        })\n-    {\n-        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id(c) &&\n-            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n-            // `impl Deref<Target = S> for S`\n-            (did == type_did || !derefs.insert(did))\n-        {\n-            // Avoid infinite cycles\n-            return;\n-        }\n-        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-        let inner_impl = target\n-            .def_id(c)\n-            .or_else(|| {\n-                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n-            })\n-            .and_then(|did| c.impls.get(&did));\n-        if let Some(impls) = inner_impl {\n-            debug!(\"found inner_impl: {:?}\", impls);\n-            let mut ret = impls\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, used_links, deref_mut, cx.tcx()))\n-                .collect::<Vec<_>>();\n-            if !ret.is_empty() {\n-                let id = if let Some(target_def_id) = real_target.def_id(c) {\n-                    cx.deref_id_map.get(&target_def_id).expect(\"Deref section without derived id\")\n-                } else {\n-                    \"deref-methods\"\n-                };\n-                let title = format!(\n-                    \"Methods from {}&lt;Target={}&gt;\",\n-                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n-                    Escape(&format!(\"{:#}\", real_target.print(cx))),\n-                );\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                ret.sort();\n-                print_sidebar_block(out, id, &title, ret.iter());\n-            }\n-        }\n-\n-        // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(c) &&\n-            let Some(target_impls) = c.impls.get(&target_did) &&\n-            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n-                i.inner_impl()\n-                    .trait_\n-                    .as_ref()\n-                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n-                    .unwrap_or(false)\n-            })\n-        {\n-            sidebar_deref_methods(\n-                cx,\n-                out,\n-                target_deref_impl,\n-                target_impls,\n-                derefs,\n-                used_links,\n-            );\n-        }\n-    }\n-}\n-\n-fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n-    let mut sidebar = Buffer::new();\n-    let fields = get_struct_fields_name(&s.fields);\n-\n-    if !fields.is_empty() {\n-        match s.ctor_kind {\n-            None => {\n-                print_sidebar_block(&mut sidebar, \"fields\", \"Fields\", fields.iter());\n-            }\n-            Some(CtorKind::Fn) => print_sidebar_title(&mut sidebar, \"fields\", \"Tuple Fields\"),\n-            Some(CtorKind::Const) => {}\n-        }\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n fn get_id_for_impl(for_: &clean::Type, trait_: Option<&clean::Path>, cx: &Context<'_>) -> String {\n     match trait_ {\n         Some(t) => small_url_encode(format!(\"impl-{:#}-for-{:#}\", t.print(cx), for_.print(cx))),\n@@ -2328,131 +1953,6 @@ fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String\n     }\n }\n \n-fn print_sidebar_title(buf: &mut Buffer, id: &str, title: &str) {\n-    write!(buf, \"<h3><a href=\\\"#{}\\\">{}</a></h3>\", id, title);\n-}\n-\n-fn print_sidebar_block(\n-    buf: &mut Buffer,\n-    id: &str,\n-    title: &str,\n-    items: impl Iterator<Item = impl fmt::Display>,\n-) {\n-    print_sidebar_title(buf, id, title);\n-    buf.push_str(\"<ul class=\\\"block\\\">\");\n-    for item in items {\n-        write!(buf, \"<li>{}</li>\", item);\n-    }\n-    buf.push_str(\"</ul>\");\n-}\n-\n-fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n-    buf.write_str(\"<section>\");\n-\n-    fn print_sidebar_section(\n-        out: &mut Buffer,\n-        items: &[clean::Item],\n-        id: &str,\n-        title: &str,\n-        filter: impl Fn(&clean::Item) -> bool,\n-        mapper: impl Fn(&str) -> String,\n-    ) {\n-        let mut items: Vec<&str> = items\n-            .iter()\n-            .filter_map(|m| match m.name {\n-                Some(ref name) if filter(m) => Some(name.as_str()),\n-                _ => None,\n-            })\n-            .collect::<Vec<_>>();\n-\n-        if !items.is_empty() {\n-            items.sort_unstable();\n-            print_sidebar_block(out, id, title, items.into_iter().map(mapper));\n-        }\n-    }\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-associated-types\",\n-        \"Required Associated Types\",\n-        |m| m.is_ty_associated_type(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-associated-types\",\n-        \"Provided Associated Types\",\n-        |m| m.is_associated_type(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-associated-consts\",\n-        \"Required Associated Constants\",\n-        |m| m.is_ty_associated_const(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-associated-consts\",\n-        \"Provided Associated Constants\",\n-        |m| m.is_associated_const(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-methods\",\n-        \"Required Methods\",\n-        |m| m.is_ty_method(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::TyMethod),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-methods\",\n-        \"Provided Methods\",\n-        |m| m.is_method(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n-    );\n-\n-    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n-        let mut res = implementors\n-            .iter()\n-            .filter(|i| !i.is_on_local_type(cx))\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n-            .collect::<Vec<_>>();\n-\n-        if !res.is_empty() {\n-            res.sort();\n-            print_sidebar_block(\n-                buf,\n-                \"foreign-impls\",\n-                \"Implementations on Foreign Types\",\n-                res.iter().map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(name))),\n-            );\n-        }\n-    }\n-\n-    sidebar_assoc_items(cx, buf, it);\n-\n-    print_sidebar_title(buf, \"implementors\", \"Implementors\");\n-    if t.is_auto(cx.tcx()) {\n-        print_sidebar_title(buf, \"synthetic-implementors\", \"Auto Implementors\");\n-    }\n-\n-    buf.push_str(\"</section>\")\n-}\n-\n /// Returns the list of implementations for the primitive reference type, filtering out any\n /// implementations that are on concrete or partially generic types, only keeping implementations\n /// of the form `impl<T> Trait for &T`.\n@@ -2483,89 +1983,6 @@ pub(crate) fn get_filtered_impls_for_reference<'a>(\n     (concrete, synthetic, blanket_impl)\n }\n \n-fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-\n-    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        sidebar_assoc_items(cx, &mut sidebar, it);\n-    } else {\n-        let shared = Rc::clone(&cx.shared);\n-        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n-\n-        sidebar_render_assoc_items(\n-            cx,\n-            &mut sidebar,\n-            &mut IdMap::new(),\n-            concrete,\n-            synthetic,\n-            blanket_impl,\n-        );\n-    }\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn sidebar_typedef(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn get_struct_fields_name(fields: &[clean::Item]) -> Vec<String> {\n-    let mut fields = fields\n-        .iter()\n-        .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n-        .filter_map(|f| {\n-            f.name.map(|name| format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))\n-        })\n-        .collect::<Vec<_>>();\n-    fields.sort();\n-    fields\n-}\n-\n-fn sidebar_union(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n-    let mut sidebar = Buffer::new();\n-    let fields = get_struct_fields_name(&u.fields);\n-\n-    if !fields.is_empty() {\n-        print_sidebar_block(&mut sidebar, \"fields\", \"Fields\", fields.iter());\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n-    let mut sidebar = Buffer::new();\n-\n-    let mut variants = e\n-        .variants()\n-        .filter_map(|v| {\n-            v.name\n-                .as_ref()\n-                .map(|name| format!(\"<a href=\\\"#variant.{name}\\\">{name}</a>\", name = name))\n-        })\n-        .collect::<Vec<_>>();\n-    if !variants.is_empty() {\n-        variants.sort_unstable();\n-        print_sidebar_block(&mut sidebar, \"variants\", \"Variants\", variants.iter());\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub(crate) enum ItemSection {\n     Reexports,\n@@ -2719,54 +2136,6 @@ fn item_ty_to_section(ty: ItemType) -> ItemSection {\n     }\n }\n \n-pub(crate) fn sidebar_module_like(buf: &mut Buffer, item_sections_in_use: FxHashSet<ItemSection>) {\n-    use std::fmt::Write as _;\n-\n-    let mut sidebar = String::new();\n-\n-    for &sec in ItemSection::ALL.iter().filter(|sec| item_sections_in_use.contains(sec)) {\n-        let _ = write!(sidebar, \"<li><a href=\\\"#{}\\\">{}</a></li>\", sec.id(), sec.name());\n-    }\n-\n-    if !sidebar.is_empty() {\n-        write!(\n-            buf,\n-            \"<section>\\\n-                 <ul class=\\\"block\\\">{}</ul>\\\n-             </section>\",\n-            sidebar\n-        );\n-    }\n-}\n-\n-fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n-    let item_sections_in_use: FxHashSet<_> = items\n-        .iter()\n-        .filter(|it| {\n-            !it.is_stripped()\n-                && it\n-                    .name\n-                    .or_else(|| {\n-                        if let clean::ImportItem(ref i) = *it.kind &&\n-                            let clean::ImportKind::Simple(s) = i.kind { Some(s) } else { None }\n-                    })\n-                    .is_some()\n-        })\n-        .map(|it| item_ty_to_section(it.type_()))\n-        .collect();\n-\n-    sidebar_module_like(buf, item_sections_in_use);\n-}\n-\n-fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained"}, {"sha": "94ad4753d7cb6bac65728ef904e0444ee0c9001f", "filename": "src/librustdoc/html/render/sidebar.rs", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs?ref=2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "patch": "@@ -0,0 +1,561 @@\n+use std::{borrow::Cow, rc::Rc};\n+\n+use askama::Template;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{def::CtorKind, def_id::DefIdSet};\n+use rustc_middle::ty::{self, TyCtxt};\n+\n+use crate::{\n+    clean,\n+    formats::{item_type::ItemType, Impl},\n+    html::{format::Buffer, markdown::IdMap},\n+};\n+\n+use super::{item_ty_to_section, Context, ItemSection};\n+\n+#[derive(Template)]\n+#[template(path = \"sidebar.html\")]\n+pub(super) struct Sidebar<'a> {\n+    pub(super) title_prefix: &'static str,\n+    pub(super) title: &'a str,\n+    pub(super) is_crate: bool,\n+    pub(super) version: &'a str,\n+    pub(super) blocks: Vec<LinkBlock<'a>>,\n+    pub(super) path: String,\n+}\n+\n+impl<'a> Sidebar<'a> {\n+    /// Only create a `<section>` if there are any blocks\n+    /// which should actually be rendered.\n+    pub fn should_render_blocks(&self) -> bool {\n+        self.blocks.iter().any(LinkBlock::should_render)\n+    }\n+}\n+\n+/// A sidebar section such as 'Methods'.\n+pub(crate) struct LinkBlock<'a> {\n+    /// The name of this section, e.g. 'Methods'\n+    /// as well as the link to it, e.g. `#implementations`.\n+    /// Will be rendered inside an `<h3>` tag\n+    heading: Link<'a>,\n+    links: Vec<Link<'a>>,\n+    /// Render the heading even if there are no links\n+    force_render: bool,\n+}\n+\n+impl<'a> LinkBlock<'a> {\n+    pub fn new(heading: Link<'a>, links: Vec<Link<'a>>) -> Self {\n+        Self { heading, links, force_render: false }\n+    }\n+\n+    pub fn forced(heading: Link<'a>) -> Self {\n+        Self { heading, links: vec![], force_render: true }\n+    }\n+\n+    pub fn should_render(&self) -> bool {\n+        self.force_render || !self.links.is_empty()\n+    }\n+}\n+\n+/// A link to an item. Content should not be escaped.\n+#[derive(PartialOrd, Ord, PartialEq, Eq, Hash, Clone)]\n+pub(crate) struct Link<'a> {\n+    /// The content for the anchor tag\n+    name: Cow<'a, str>,\n+    /// The id of an anchor within the page (without a `#` prefix)\n+    href: Cow<'a, str>,\n+}\n+\n+impl<'a> Link<'a> {\n+    pub fn new(href: impl Into<Cow<'a, str>>, name: impl Into<Cow<'a, str>>) -> Self {\n+        Self { href: href.into(), name: name.into() }\n+    }\n+    pub fn empty() -> Link<'static> {\n+        Link::new(\"\", \"\")\n+    }\n+}\n+\n+pub(super) fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n+    let blocks: Vec<LinkBlock<'_>> = match *it.kind {\n+        clean::StructItem(ref s) => sidebar_struct(cx, it, s),\n+        clean::TraitItem(ref t) => sidebar_trait(cx, it, t),\n+        clean::PrimitiveItem(_) => sidebar_primitive(cx, it),\n+        clean::UnionItem(ref u) => sidebar_union(cx, it, u),\n+        clean::EnumItem(ref e) => sidebar_enum(cx, it, e),\n+        clean::TypedefItem(_) => sidebar_typedef(cx, it),\n+        clean::ModuleItem(ref m) => vec![sidebar_module(&m.items)],\n+        clean::ForeignTypeItem => sidebar_foreign_type(cx, it),\n+        _ => vec![],\n+    };\n+    // The sidebar is designed to display sibling functions, modules and\n+    // other miscellaneous information. since there are lots of sibling\n+    // items (and that causes quadratic growth in large modules),\n+    // we refactor common parts into a shared JavaScript file per module.\n+    // still, we don't move everything into JS because we want to preserve\n+    // as much HTML as possible in order to allow non-JS-enabled browsers\n+    // to navigate the documentation (though slightly inefficiently).\n+    let (title_prefix, title) = if it.is_struct()\n+        || it.is_trait()\n+        || it.is_primitive()\n+        || it.is_union()\n+        || it.is_enum()\n+        || it.is_mod()\n+        || it.is_typedef()\n+    {\n+        (\n+            match *it.kind {\n+                clean::ModuleItem(..) if it.is_crate() => \"Crate \",\n+                clean::ModuleItem(..) => \"Module \",\n+                _ => \"\",\n+            },\n+            it.name.as_ref().unwrap().as_str(),\n+        )\n+    } else {\n+        (\"\", \"\")\n+    };\n+    let version = if it.is_crate() {\n+        cx.cache().crate_version.as_ref().map(String::as_str).unwrap_or_default()\n+    } else {\n+        \"\"\n+    };\n+    let path: String = if !it.is_mod() {\n+        cx.current.iter().map(|s| s.as_str()).intersperse(\"::\").collect()\n+    } else {\n+        \"\".into()\n+    };\n+    let sidebar = Sidebar { title_prefix, title, is_crate: it.is_crate(), version, blocks, path };\n+    sidebar.render_into(buffer).unwrap();\n+}\n+\n+fn get_struct_fields_name<'a>(fields: &'a [clean::Item]) -> Vec<Link<'a>> {\n+    let mut fields = fields\n+        .iter()\n+        .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n+        .filter_map(|f| {\n+            f.name.as_ref().map(|name| Link::new(format!(\"structfield.{name}\"), name.as_str()))\n+        })\n+        .collect::<Vec<Link<'a>>>();\n+    fields.sort();\n+    fields\n+}\n+\n+fn sidebar_struct<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    s: &'a clean::Struct,\n+) -> Vec<LinkBlock<'a>> {\n+    let fields = get_struct_fields_name(&s.fields);\n+    let field_name = match s.ctor_kind {\n+        Some(CtorKind::Fn) => Some(\"Tuple Fields\"),\n+        None => Some(\"Fields\"),\n+        _ => None,\n+    };\n+    let mut items = vec![];\n+    if let Some(name) = field_name {\n+        items.push(LinkBlock::new(Link::new(\"fields\", name), fields));\n+    }\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+fn sidebar_trait<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    t: &'a clean::Trait,\n+) -> Vec<LinkBlock<'a>> {\n+    fn filter_items<'a>(\n+        items: &'a [clean::Item],\n+        filt: impl Fn(&clean::Item) -> bool,\n+        ty: &str,\n+    ) -> Vec<Link<'a>> {\n+        let mut res = items\n+            .iter()\n+            .filter_map(|m: &clean::Item| match m.name {\n+                Some(ref name) if filt(m) => Some(Link::new(format!(\"{ty}.{name}\"), name.as_str())),\n+                _ => None,\n+            })\n+            .collect::<Vec<Link<'a>>>();\n+        res.sort();\n+        res\n+    }\n+\n+    let req_assoc = filter_items(&t.items, |m| m.is_ty_associated_type(), \"associatedtype\");\n+    let prov_assoc = filter_items(&t.items, |m| m.is_associated_type(), \"associatedtype\");\n+    let req_assoc_const =\n+        filter_items(&t.items, |m| m.is_ty_associated_const(), \"associatedconstant\");\n+    let prov_assoc_const =\n+        filter_items(&t.items, |m| m.is_associated_const(), \"associatedconstant\");\n+    let req_method = filter_items(&t.items, |m| m.is_ty_method(), \"tymethod\");\n+    let prov_method = filter_items(&t.items, |m| m.is_method(), \"method\");\n+    let mut foreign_impls = vec![];\n+    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n+        foreign_impls.extend(\n+            implementors\n+                .iter()\n+                .filter(|i| !i.is_on_local_type(cx))\n+                .filter_map(|i| super::extract_for_impl_name(&i.impl_item, cx))\n+                .map(|(name, id)| Link::new(id, name)),\n+        );\n+        foreign_impls.sort();\n+    }\n+\n+    let mut blocks: Vec<LinkBlock<'_>> = [\n+        (\"required-associated-types\", \"Required Associated Types\", req_assoc),\n+        (\"provided-associated-types\", \"Provided Associated Types\", prov_assoc),\n+        (\"required-associated-consts\", \"Required Associated Constants\", req_assoc_const),\n+        (\"provided-associated-consts\", \"Provided Associated Constants\", prov_assoc_const),\n+        (\"required-methods\", \"Required Methods\", req_method),\n+        (\"provided-methods\", \"Provided Methods\", prov_method),\n+        (\"foreign-impls\", \"Implementations on Foreign Types\", foreign_impls),\n+    ]\n+    .into_iter()\n+    .map(|(id, title, items)| LinkBlock::new(Link::new(id, title), items))\n+    .collect();\n+    sidebar_assoc_items(cx, it, &mut blocks);\n+    blocks.push(LinkBlock::forced(Link::new(\"implementors\", \"Implementors\")));\n+    if t.is_auto(cx.tcx()) {\n+        blocks.push(LinkBlock::forced(Link::new(\"synthetic-implementors\", \"Auto Implementors\")));\n+    }\n+    blocks\n+}\n+\n+fn sidebar_primitive<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        let mut items = vec![];\n+        sidebar_assoc_items(cx, it, &mut items);\n+        items\n+    } else {\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) =\n+            super::get_filtered_impls_for_reference(&shared, it);\n+\n+        sidebar_render_assoc_items(cx, &mut IdMap::new(), concrete, synthetic, blanket_impl).into()\n+    }\n+}\n+\n+fn sidebar_typedef<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    let mut items = vec![];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+fn sidebar_union<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    u: &'a clean::Union,\n+) -> Vec<LinkBlock<'a>> {\n+    let fields = get_struct_fields_name(&u.fields);\n+    let mut items = vec![LinkBlock::new(Link::new(\"fields\", \"Fields\"), fields)];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+/// Adds trait implementations into the blocks of links\n+fn sidebar_assoc_items<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    links: &mut Vec<LinkBlock<'a>>,\n+) {\n+    let did = it.item_id.expect_def_id();\n+    let cache = cx.cache();\n+\n+    let mut assoc_consts = Vec::new();\n+    let mut methods = Vec::new();\n+    if let Some(v) = cache.impls.get(&did) {\n+        let mut used_links = FxHashSet::default();\n+        let mut id_map = IdMap::new();\n+\n+        {\n+            let used_links_bor = &mut used_links;\n+            assoc_consts.extend(\n+                v.iter()\n+                    .filter(|i| i.inner_impl().trait_.is_none())\n+                    .flat_map(|i| get_associated_constants(i.inner_impl(), used_links_bor)),\n+            );\n+            // We want links' order to be reproducible so we don't use unstable sort.\n+            assoc_consts.sort();\n+\n+            #[rustfmt::skip] // rustfmt makes the pipeline less readable\n+            methods.extend(\n+                v.iter()\n+                    .filter(|i| i.inner_impl().trait_.is_none())\n+                    .flat_map(|i| get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx())),\n+            );\n+\n+            // We want links' order to be reproducible so we don't use unstable sort.\n+            methods.sort();\n+        }\n+\n+        let mut deref_methods = Vec::new();\n+        let [concrete, synthetic, blanket] = if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n+            if let Some(impl_) =\n+                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n+            {\n+                let mut derefs = DefIdSet::default();\n+                derefs.insert(did);\n+                sidebar_deref_methods(\n+                    cx,\n+                    &mut deref_methods,\n+                    impl_,\n+                    v,\n+                    &mut derefs,\n+                    &mut used_links,\n+                );\n+            }\n+\n+            let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n+            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+                concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n+\n+            sidebar_render_assoc_items(cx, &mut id_map, concrete, synthetic, blanket_impl)\n+        } else {\n+            std::array::from_fn(|_| LinkBlock::new(Link::empty(), vec![]))\n+        };\n+\n+        let mut blocks = vec![\n+            LinkBlock::new(Link::new(\"implementations\", \"Associated Constants\"), assoc_consts),\n+            LinkBlock::new(Link::new(\"implementations\", \"Methods\"), methods),\n+        ];\n+        blocks.append(&mut deref_methods);\n+        blocks.extend([concrete, synthetic, blanket]);\n+        links.append(&mut blocks);\n+    }\n+}\n+\n+fn sidebar_deref_methods<'a>(\n+    cx: &'a Context<'_>,\n+    out: &mut Vec<LinkBlock<'a>>,\n+    impl_: &Impl,\n+    v: &[Impl],\n+    derefs: &mut DefIdSet,\n+    used_links: &mut FxHashSet<String>,\n+) {\n+    let c = cx.cache();\n+\n+    debug!(\"found Deref: {:?}\", impl_);\n+    if let Some((target, real_target)) =\n+        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n+            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n+            _ => None,\n+        })\n+    {\n+        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n+        if let Some(did) = target.def_id(c) &&\n+            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n+            // `impl Deref<Target = S> for S`\n+            (did == type_did || !derefs.insert(did))\n+        {\n+            // Avoid infinite cycles\n+            return;\n+        }\n+        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n+        let inner_impl = target\n+            .def_id(c)\n+            .or_else(|| {\n+                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n+            })\n+            .and_then(|did| c.impls.get(&did));\n+        if let Some(impls) = inner_impl {\n+            debug!(\"found inner_impl: {:?}\", impls);\n+            let mut ret = impls\n+                .iter()\n+                .filter(|i| i.inner_impl().trait_.is_none())\n+                .flat_map(|i| get_methods(i.inner_impl(), true, used_links, deref_mut, cx.tcx()))\n+                .collect::<Vec<_>>();\n+            if !ret.is_empty() {\n+                let id = if let Some(target_def_id) = real_target.def_id(c) {\n+                    Cow::Borrowed(\n+                        cx.deref_id_map\n+                            .get(&target_def_id)\n+                            .expect(\"Deref section without derived id\")\n+                            .as_str(),\n+                    )\n+                } else {\n+                    Cow::Borrowed(\"deref-methods\")\n+                };\n+                let title = format!(\n+                    \"Methods from {:#}<Target={:#}>\",\n+                    impl_.inner_impl().trait_.as_ref().unwrap().print(cx),\n+                    real_target.print(cx),\n+                );\n+                // We want links' order to be reproducible so we don't use unstable sort.\n+                ret.sort();\n+                out.push(LinkBlock::new(Link::new(id, title), ret));\n+            }\n+        }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id(c) &&\n+            let Some(target_impls) = c.impls.get(&target_did) &&\n+            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                i.inner_impl()\n+                    .trait_\n+                    .as_ref()\n+                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                    .unwrap_or(false)\n+            })\n+        {\n+            sidebar_deref_methods(\n+                cx,\n+                out,\n+                target_deref_impl,\n+                target_impls,\n+                derefs,\n+                used_links,\n+            );\n+        }\n+    }\n+}\n+\n+fn sidebar_enum<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    e: &'a clean::Enum,\n+) -> Vec<LinkBlock<'a>> {\n+    let mut variants = e\n+        .variants()\n+        .filter_map(|v| v.name)\n+        .map(|name| Link::new(format!(\"variant.{name}\"), name.to_string()))\n+        .collect::<Vec<_>>();\n+    variants.sort_unstable();\n+\n+    let mut items = vec![LinkBlock::new(Link::new(\"variants\", \"Variants\"), variants)];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+pub(crate) fn sidebar_module_like(\n+    item_sections_in_use: FxHashSet<ItemSection>,\n+) -> LinkBlock<'static> {\n+    let item_sections = ItemSection::ALL\n+        .iter()\n+        .copied()\n+        .filter(|sec| item_sections_in_use.contains(sec))\n+        .map(|sec| Link::new(sec.id(), sec.name()))\n+        .collect();\n+    LinkBlock::new(Link::empty(), item_sections)\n+}\n+\n+fn sidebar_module(items: &[clean::Item]) -> LinkBlock<'static> {\n+    let item_sections_in_use: FxHashSet<_> = items\n+        .iter()\n+        .filter(|it| {\n+            !it.is_stripped()\n+                && it\n+                    .name\n+                    .or_else(|| {\n+                        if let clean::ImportItem(ref i) = *it.kind &&\n+                            let clean::ImportKind::Simple(s) = i.kind { Some(s) } else { None }\n+                    })\n+                    .is_some()\n+        })\n+        .map(|it| item_ty_to_section(it.type_()))\n+        .collect();\n+\n+    sidebar_module_like(item_sections_in_use)\n+}\n+\n+fn sidebar_foreign_type<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    let mut items = vec![];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+/// Renders the trait implementations for this type\n+fn sidebar_render_assoc_items(\n+    cx: &Context<'_>,\n+    id_map: &mut IdMap,\n+    concrete: Vec<&Impl>,\n+    synthetic: Vec<&Impl>,\n+    blanket_impl: Vec<&Impl>,\n+) -> [LinkBlock<'static>; 3] {\n+    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n+        let mut links = FxHashSet::default();\n+\n+        let mut ret = impls\n+            .iter()\n+            .filter_map(|it| {\n+                let trait_ = it.inner_impl().trait_.as_ref()?;\n+                let encoded =\n+                    id_map.derive(super::get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n+\n+                let prefix = match it.inner_impl().polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                    ty::ImplPolarity::Negative => \"!\",\n+                };\n+                let generated = Link::new(encoded, format!(\"{prefix}{:#}\", trait_.print(cx)));\n+                if links.insert(generated.clone()) { Some(generated) } else { None }\n+            })\n+            .collect::<Vec<Link<'static>>>();\n+        ret.sort();\n+        ret\n+    };\n+\n+    let concrete = format_impls(concrete, id_map);\n+    let synthetic = format_impls(synthetic, id_map);\n+    let blanket = format_impls(blanket_impl, id_map);\n+    [\n+        LinkBlock::new(Link::new(\"trait-implementations\", \"Trait Implementations\"), concrete),\n+        LinkBlock::new(\n+            Link::new(\"synthetic-implementations\", \"Auto Trait Implementations\"),\n+            synthetic,\n+        ),\n+        LinkBlock::new(Link::new(\"blanket-implementations\", \"Blanket Implementations\"), blanket),\n+    ]\n+}\n+\n+fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n+    if used_links.insert(url.clone()) {\n+        return url;\n+    }\n+    let mut add = 1;\n+    while !used_links.insert(format!(\"{}-{}\", url, add)) {\n+        add += 1;\n+    }\n+    format!(\"{}-{}\", url, add)\n+}\n+\n+fn get_methods<'a>(\n+    i: &'a clean::Impl,\n+    for_deref: bool,\n+    used_links: &mut FxHashSet<String>,\n+    deref_mut: bool,\n+    tcx: TyCtxt<'_>,\n+) -> Vec<Link<'a>> {\n+    i.items\n+        .iter()\n+        .filter_map(|item| match item.name {\n+            Some(ref name) if !name.is_empty() && item.is_method() => {\n+                if !for_deref || super::should_render_item(item, deref_mut, tcx) {\n+                    Some(Link::new(\n+                        get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n+                        name.as_str(),\n+                    ))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        })\n+        .collect::<Vec<_>>()\n+}\n+\n+fn get_associated_constants<'a>(\n+    i: &'a clean::Impl,\n+    used_links: &mut FxHashSet<String>,\n+) -> Vec<Link<'a>> {\n+    i.items\n+        .iter()\n+        .filter_map(|item| match item.name {\n+            Some(ref name) if !name.is_empty() && item.is_associated_const() => Some(Link::new(\n+                get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n+                name.as_str(),\n+            )),\n+            _ => None,\n+        })\n+        .collect::<Vec<_>>()\n+}"}, {"sha": "01d476ad29f2f8529df915297502dca7645c5ca4", "filename": "src/librustdoc/html/templates/sidebar.html", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html", "raw_url": "https://github.com/rust-lang/rust/raw/2f166d1a15cf0bec0869f2e955ac656eeaec48d7/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html?ref=2f166d1a15cf0bec0869f2e955ac656eeaec48d7", "patch": "@@ -0,0 +1,37 @@\n+{% if !title.is_empty() %}\n+    <h2 class=\"location\"> {# #}\n+        <a href=\"#\">{{title_prefix}}{{title}}</a> {# #}\n+    </h2>\n+{% endif %}\n+<div class=\"sidebar-elems\">\n+    {% if is_crate %}\n+        <ul class=\"block\">\n+            {% if !version.is_empty() %}\n+                <li class=\"version\">Version {{+ version}}</li>\n+            {% endif %}\n+            <li><a id=\"all-types\" href=\"all.html\">All Items</a></li> {# #}\n+        </ul>\n+    {% endif %}\n+\n+    {% if self.should_render_blocks() %}\n+        <section>\n+            {% for block in blocks %}\n+                {% if block.should_render() %}\n+                    {% if !block.heading.name.is_empty() %}\n+                        <h3><a href=\"#{{block.heading.href|safe}}\">{{block.heading.name}}</a></h3>\n+                    {% endif %}\n+                    {% if !block.links.is_empty() %}\n+                        <ul class=\"block\">\n+                            {% for link in block.links %}\n+                                <li><a href=\"#{{link.href|safe}}\">{{link.name}}</a></li>\n+                            {% endfor %}\n+                        </ul>\n+                    {% endif %}\n+                {% endif %}\n+            {% endfor %}\n+        </section>\n+    {% endif %}\n+    {% if !path.is_empty() %}\n+        <h2><a href=\"index.html\">In {{+ path}}</a></h2>\n+    {% endif %}\n+</div>"}]}