{"sha": "cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmODM0N2JhNmJjODJjNDFkZTJhZDliZjU2MWFmNTkzYTg5Y2JlNDU=", "commit": {"author": {"name": "Harald Hoyer", "email": "harald@redhat.com", "date": "2019-02-28T09:25:54Z"}, "committer": {"name": "Harald Hoyer", "email": "harald@hoyer.xyz", "date": "2019-03-23T06:36:27Z"}, "message": "fs::copy() set file mode early\n\nA convenience method like fs::copy() should try to prevent pitfalls a\nnormal user doesn't think about.\n\nIn case of an empty umask, setting the file mode early prevents\ntemporarily world readable or even writeable files,\nbecause the default mode is 0o666.\n\nIn case the target is a named pipe or special device node, setting the\nfile mode can lead to unwanted side effects, like setting permissons on\n`/dev/stdout` or for root setting permissions on `/dev/null`.\n\ncopy_file_range() returns EINVAL, if the destination is a FIFO/pipe or\na device like \"/dev/null\", so fallback to io::copy, too.\n\nUse `fcopyfile` on MacOS instead of `copyfile`.\n\nFixes: https://github.com/rust-lang/rust/issues/26933\nFixed: https://github.com/rust-lang/rust/issues/37885", "tree": {"sha": "6dc37ee09025e41a85801b85f4764a8d11edcbaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dc37ee09025e41a85801b85f4764a8d11edcbaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEExdxr/R5NxsU+Wm67+ko5wcKGHUcFAlyV0+8ACgkQ+ko5wcKG\nHUdIBQgAyNDxddIaMOblXN8KHYkTKk7ggPkMhxjvTzuottqopLy+CmddT+5EjFLF\nrjfW03pwDPZOK8BlpbZLaW/iAIPNNPS+xC6r5zFbA2fHqvVSEXc4RsQadSn9L7e0\nnSidTKjHBBJKdj6N3j9+9k33GP7iwMBJMiTJBpr8ISS3Iav1QgBnmxbm+baNdUxv\nnVlGCwSUpOdt2S4XPUbQWdsoXJ5UV1rjrNRUIkBPaso8p/Q/bJe3wTGmjtCci1yb\n8hjoJ2b+3YD2dq9lOSdo1pGW7R1f1soqkALXk4imYXSpHx7szgz9q6O+YTaEUvTw\nwYOzFI6Tz8UcsZoSiQ6TuDEobvZjqQ==\n=YiEh\n-----END PGP SIGNATURE-----", "payload": "tree 6dc37ee09025e41a85801b85f4764a8d11edcbaf\nparent 7cf074a1e655ac07d04d045667278fa1a9970b93\nauthor Harald Hoyer <harald@redhat.com> 1551345954 +0100\ncommitter Harald Hoyer <harald@hoyer.xyz> 1553322987 +0100\n\nfs::copy() set file mode early\n\nA convenience method like fs::copy() should try to prevent pitfalls a\nnormal user doesn't think about.\n\nIn case of an empty umask, setting the file mode early prevents\ntemporarily world readable or even writeable files,\nbecause the default mode is 0o666.\n\nIn case the target is a named pipe or special device node, setting the\nfile mode can lead to unwanted side effects, like setting permissons on\n`/dev/stdout` or for root setting permissions on `/dev/null`.\n\ncopy_file_range() returns EINVAL, if the destination is a FIFO/pipe or\na device like \"/dev/null\", so fallback to io::copy, too.\n\nUse `fcopyfile` on MacOS instead of `copyfile`.\n\nFixes: https://github.com/rust-lang/rust/issues/26933\nFixed: https://github.com/rust-lang/rust/issues/37885\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "html_url": "https://github.com/rust-lang/rust/commit/cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf8347ba6bc82c41de2ad9bf561af593a89cbe45/comments", "author": {"login": "haraldh", "id": 427825, "node_id": "MDQ6VXNlcjQyNzgyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/427825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/haraldh", "html_url": "https://github.com/haraldh", "followers_url": "https://api.github.com/users/haraldh/followers", "following_url": "https://api.github.com/users/haraldh/following{/other_user}", "gists_url": "https://api.github.com/users/haraldh/gists{/gist_id}", "starred_url": "https://api.github.com/users/haraldh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/haraldh/subscriptions", "organizations_url": "https://api.github.com/users/haraldh/orgs", "repos_url": "https://api.github.com/users/haraldh/repos", "events_url": "https://api.github.com/users/haraldh/events{/privacy}", "received_events_url": "https://api.github.com/users/haraldh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "haraldh", "id": 427825, "node_id": "MDQ6VXNlcjQyNzgyNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/427825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/haraldh", "html_url": "https://github.com/haraldh", "followers_url": "https://api.github.com/users/haraldh/followers", "following_url": "https://api.github.com/users/haraldh/following{/other_user}", "gists_url": "https://api.github.com/users/haraldh/gists{/gist_id}", "starred_url": "https://api.github.com/users/haraldh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/haraldh/subscriptions", "organizations_url": "https://api.github.com/users/haraldh/orgs", "repos_url": "https://api.github.com/users/haraldh/repos", "events_url": "https://api.github.com/users/haraldh/events{/privacy}", "received_events_url": "https://api.github.com/users/haraldh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cf074a1e655ac07d04d045667278fa1a9970b93", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf074a1e655ac07d04d045667278fa1a9970b93", "html_url": "https://github.com/rust-lang/rust/commit/7cf074a1e655ac07d04d045667278fa1a9970b93"}], "stats": {"total": 142, "additions": 83, "deletions": 59}, "files": [{"sha": "c73f7983146d411b4980bce29e1f54cab4328636", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/cf8347ba6bc82c41de2ad9bf561af593a89cbe45/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8347ba6bc82c41de2ad9bf561af593a89cbe45/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "patch": "@@ -827,30 +827,54 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n+fn open_and_set_permissions(\n+    from: &Path,\n+    to: &Path,\n+) -> io::Result<(crate::fs::File, crate::fs::File, u64, crate::fs::Metadata)> {\n+    use crate::fs::{File, OpenOptions};\n+    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n+\n+    let reader = File::open(from)?;\n+    let (perm, len) = {\n+        let metadata = reader.metadata()?;\n+        if !metadata.is_file() {\n+            return Err(Error::new(\n+                ErrorKind::InvalidInput,\n+                \"the source path is not an existing regular file\",\n+            ));\n+        }\n+        (metadata.permissions(), metadata.len())\n+    };\n+    let writer = OpenOptions::new()\n+        // create the file with the correct mode right away\n+        .mode(perm.mode())\n+        .write(true)\n+        .create(true)\n+        .truncate(true)\n+        .open(to)?;\n+    let writer_metadata = writer.metadata()?;\n+    if writer_metadata.is_file() {\n+        // Set the correct file permissions, in case the file already existed.\n+        // Don't set the permissions on already existing non-files like\n+        // pipes/FIFOs or device nodes.\n+        writer.set_permissions(perm)?;\n+    }\n+    Ok((reader, writer, len, writer_metadata))\n+}\n+\n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"macos\",\n               target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::File;\n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (mut reader, mut writer, _, _) = open_and_set_permissions(from, to)?;\n \n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    writer.set_permissions(perm)?;\n-    Ok(ret)\n+    io::copy(&mut reader, &mut writer)\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::cmp;\n-    use crate::fs::File;\n     use crate::sync::atomic::{AtomicBool, Ordering};\n \n     // Kernel prior to 4.5 don't have copy_file_range\n@@ -876,17 +900,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         )\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let (perm, len) = {\n-        let metadata = reader.metadata()?;\n-        (metadata.permissions(), metadata.size())\n-    };\n+    let (mut reader, mut writer, len, _) = open_and_set_permissions(from, to)?;\n \n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n     let mut written = 0u64;\n@@ -896,13 +910,14 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             let copy_result = unsafe {\n                 // We actually don't have to adjust the offsets,\n                 // because copy_file_range adjusts the file offset automatically\n-                cvt(copy_file_range(reader.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    writer.as_raw_fd(),\n-                                    ptr::null_mut(),\n-                                    bytes_to_copy,\n-                                    0)\n-                    )\n+                cvt(copy_file_range(\n+                    reader.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    writer.as_raw_fd(),\n+                    ptr::null_mut(),\n+                    bytes_to_copy,\n+                    0,\n+                ))\n             };\n             if let Err(ref copy_err) = copy_result {\n                 match copy_err.raw_os_error() {\n@@ -920,24 +935,25 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 match err.raw_os_error() {\n-                    Some(os_err) if os_err == libc::ENOSYS\n-                                 || os_err == libc::EXDEV\n-                                 || os_err == libc::EPERM => {\n-                        // Try fallback io::copy if either:\n-                        // - Kernel version is < 4.5 (ENOSYS)\n-                        // - Files are mounted on different fs (EXDEV)\n-                        // - copy_file_range is disallowed, for example by seccomp (EPERM)\n-                        assert_eq!(written, 0);\n-                        let ret = io::copy(&mut reader, &mut writer)?;\n-                        writer.set_permissions(perm)?;\n-                        return Ok(ret)\n-                    },\n+                    Some(os_err)\n+                    if os_err == libc::ENOSYS\n+                        || os_err == libc::EXDEV\n+                        || os_err == libc::EINVAL\n+                        || os_err == libc::EPERM =>\n+                        {\n+                            // Try fallback io::copy if either:\n+                            // - Kernel version is < 4.5 (ENOSYS)\n+                            // - Files are mounted on different fs (EXDEV)\n+                            // - copy_file_range is disallowed, for example by seccomp (EPERM)\n+                            // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n+                            assert_eq!(written, 0);\n+                            return io::copy(&mut reader, &mut writer);\n+                        }\n                     _ => return Err(err),\n                 }\n             }\n         }\n     }\n-    writer.set_permissions(perm)?;\n     Ok(written)\n }\n \n@@ -960,9 +976,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     type copyfile_flags_t = u32;\n \n     extern \"C\" {\n-        fn copyfile(\n-            from: *const libc::c_char,\n-            to: *const libc::c_char,\n+        fn fcopyfile(\n+            from: libc::c_int,\n+            to: libc::c_int,\n             state: copyfile_state_t,\n             flags: copyfile_flags_t,\n         ) -> libc::c_int;\n@@ -988,10 +1004,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n     }\n \n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n+    let (reader, writer, _, writer_metadata) = open_and_set_permissions(from, to)?;\n \n     // We ensure that `FreeOnDrop` never contains a null pointer so it is\n     // always safe to call `copyfile_state_free`\n@@ -1003,12 +1016,18 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         FreeOnDrop(state)\n     };\n \n+    let flags = if writer_metadata.is_file() {\n+        COPYFILE_ALL\n+    } else {\n+        COPYFILE_DATA\n+    };\n+\n     cvt(unsafe {\n-        copyfile(\n-            cstr(from)?.as_ptr(),\n-            cstr(to)?.as_ptr(),\n+        fcopyfile(\n+            reader.as_raw_fd(),\n+            writer.as_raw_fd(),\n             state.0,\n-            COPYFILE_ALL,\n+            flags,\n         )\n     })?;\n "}, {"sha": "dfcef59aa57825851f827159fb833cf12dfdfbb3", "filename": "src/test/run-pass/paths-containing-nul.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf8347ba6bc82c41de2ad9bf561af593a89cbe45/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf8347ba6bc82c41de2ad9bf561af593a89cbe45/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpaths-containing-nul.rs?ref=cf8347ba6bc82c41de2ad9bf561af593a89cbe45", "patch": "@@ -1,6 +1,7 @@\n #![allow(deprecated)]\n // ignore-cloudabi no files or I/O\n // ignore-wasm32-bare no files or I/O\n+// ignore-emscripten no files\n \n use std::fs;\n use std::io;\n@@ -22,14 +23,18 @@ fn main() {\n     assert_invalid_input(\"remove_file\", fs::remove_file(\"\\0\"));\n     assert_invalid_input(\"metadata\", fs::metadata(\"\\0\"));\n     assert_invalid_input(\"symlink_metadata\", fs::symlink_metadata(\"\\0\"));\n+\n+    // If `dummy_file` does not exist, then we might get another unrelated error\n+    let dummy_file = std::env::current_exe().unwrap();\n+\n     assert_invalid_input(\"rename1\", fs::rename(\"\\0\", \"a\"));\n-    assert_invalid_input(\"rename2\", fs::rename(\"a\", \"\\0\"));\n+    assert_invalid_input(\"rename2\", fs::rename(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"copy1\", fs::copy(\"\\0\", \"a\"));\n-    assert_invalid_input(\"copy2\", fs::copy(\"a\", \"\\0\"));\n+    assert_invalid_input(\"copy2\", fs::copy(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"hard_link1\", fs::hard_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"hard_link2\", fs::hard_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"hard_link2\", fs::hard_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"soft_link1\", fs::soft_link(\"\\0\", \"a\"));\n-    assert_invalid_input(\"soft_link2\", fs::soft_link(\"a\", \"\\0\"));\n+    assert_invalid_input(\"soft_link2\", fs::soft_link(&dummy_file, \"\\0\"));\n     assert_invalid_input(\"read_link\", fs::read_link(\"\\0\"));\n     assert_invalid_input(\"canonicalize\", fs::canonicalize(\"\\0\"));\n     assert_invalid_input(\"create_dir\", fs::create_dir(\"\\0\"));"}]}