{"sha": "864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "node_id": "C_kwDOAAsO6NoAKDg2NDI5MDQ3MmZjYjFkZWVlMmE0ZmIwOWE5ZGYyODY0Y2UzYmQxYTQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-09-28T18:00:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-28T18:00:12Z"}, "message": "Rollup merge of #87260 - antoyo:libgccjit-codegen, r=Mark-Simulacrum\n\nLibgccjit codegen\n\nThis PR introduces a subtree for a gcc-based codegen backend to the repository, per decision in https://github.com/rust-lang/compiler-team/issues/442. We do not yet expect to ship this backend on nightly or run tests in CI, but we do verify that the backend checks (i.e., `cargo check`) successfully.\n\nWork is expected to progress primarily in https://github.com/rust-lang/rustc_codegen_gcc, with semi-regular upstreaming, like with other subtrees.", "tree": {"sha": "78514f270b1fe75739df1cc245e1dc70dc27c05b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78514f270b1fe75739df1cc245e1dc70dc27c05b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhU1gtCRBK7hj4Ov3rIwAAqV4IAHKH0JD/a2LAy8bz0skmAZXQ\nJQda133qk2+XVbUNyDxSYp5LljFRBXX5BHO4ewX3+T2BxFOdE/LMfymB7vFpmUZO\nQ0J+6gGy5Tm7K8QCkSRkw9Xg8qq1ogfu2yQ3aiMh/QDzArRGK/9p2KNZOKmxRNd5\nc70nzRD6/XCb4tWDOWmIdDgk1tKVn493TXIzeKFsYWuHxE6k+vep5qG5Gv0whK6h\ndrp3CLOGNk54+YPmMXUN7ffZJB+O+5A+MtQqVEVV/cymD82kWRgQh9HVFabZgxeR\nJC04DqcI2ihNzTVhr4gd0bLRw/4kQ89UgKHIh9u4yiVyRGJWLDd9hkVTTrMbU4U=\n=rMAB\n-----END PGP SIGNATURE-----\n", "payload": "tree 78514f270b1fe75739df1cc245e1dc70dc27c05b\nparent 1d71ba862309d59df710078a845c8772ffb22aba\nparent 90be409db0ef219bad25e38ec7b1902683389b07\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1632852012 +0200\ncommitter GitHub <noreply@github.com> 1632852012 +0200\n\nRollup merge of #87260 - antoyo:libgccjit-codegen, r=Mark-Simulacrum\n\nLibgccjit codegen\n\nThis PR introduces a subtree for a gcc-based codegen backend to the repository, per decision in https://github.com/rust-lang/compiler-team/issues/442. We do not yet expect to ship this backend on nightly or run tests in CI, but we do verify that the backend checks (i.e., `cargo check`) successfully.\n\nWork is expected to progress primarily in https://github.com/rust-lang/rustc_codegen_gcc, with semi-regular upstreaming, like with other subtrees.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "html_url": "https://github.com/rust-lang/rust/commit/864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d71ba862309d59df710078a845c8772ffb22aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d71ba862309d59df710078a845c8772ffb22aba", "html_url": "https://github.com/rust-lang/rust/commit/1d71ba862309d59df710078a845c8772ffb22aba"}, {"sha": "90be409db0ef219bad25e38ec7b1902683389b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/90be409db0ef219bad25e38ec7b1902683389b07", "html_url": "https://github.com/rust-lang/rust/commit/90be409db0ef219bad25e38ec7b1902683389b07"}], "stats": {"total": 13241, "additions": 13239, "deletions": 2}, "files": [{"sha": "ce7073886c20e95658065773511c7a05174d5274", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -41,6 +41,7 @@ members = [\n exclude = [\n   \"build\",\n   \"compiler/rustc_codegen_cranelift\",\n+  \"compiler/rustc_codegen_gcc\",\n   \"src/test/rustdoc-gui\",\n   # HACK(eddyb) This hardcodes the fact that our CI uses `/checkout/obj`.\n   \"obj\","}, {"sha": "98bed8ef387ff4fee2f2c513f89f4db1655eeec3", "filename": "compiler/rustc_codegen_gcc/.github/workflows/main.yml", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fmain.yml?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,96 @@\n+name: CI\n+\n+on:\n+  - push\n+  - pull_request\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+\n+    steps:\n+    - uses: actions/checkout@v2\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: libgccjit.so\n+          path: gcc-build\n+          repo: antoyo/gcc\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set LIBRARY_PATH\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+\n+    # https://github.com/actions/cache/issues/133\n+    - name: Fixup owner of ~/.cargo/\n+      # Don't remove the trailing /. It is necessary to follow the symlink.\n+      run: sudo chown -R $(whoami):$(id -ng) ~/.cargo/\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v1.1.2\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v1\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v1.1.2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Test\n+      run: |\n+        # Enable backtraces for easier debugging\n+        export RUST_BACKTRACE=1\n+\n+        # Reduce amount of benchmark runs as they are slow\n+        export COMPILE_RUNS=2\n+        export RUN_RUNS=2\n+\n+        ./test.sh --release"}, {"sha": "1e2f9e3aebb2cd83b6ae296b833efc75c3e10f92", "filename": "compiler/rustc_codegen_gcc/.gitignore", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.gitignore?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,20 @@\n+target\n+**/*.rs.bk\n+*.rlib\n+*.o\n+perf.data\n+perf.data.old\n+*.events\n+*.string*\n+/build_sysroot/sysroot\n+/build_sysroot/sysroot_src\n+/build_sysroot/Cargo.lock\n+/build_sysroot/test_target/Cargo.lock\n+/rust\n+/simple-raytracer\n+/regex\n+gimple*\n+*asm\n+res\n+test-backend\n+gcc_path"}, {"sha": "60a2101c689cc2d1d6102a682956e61190f370cd", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,373 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.7.18\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e37cfd5e7657ada45f742d6e99ca5788580b5c529dc78faf11ece6dc702656f\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"ar\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n+[[package]]\n+name = \"crc32fast\"\n+version = \"1.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"fm\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"68fda3cff2cce84c19e5dfa5179a4b35d2c0f18b893f108002b8a6a54984acca\"\n+dependencies = [\n+ \"regex\",\n+]\n+\n+[[package]]\n+name = \"gccjit\"\n+version = \"1.0.0\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+dependencies = [\n+ \"gccjit_sys\",\n+]\n+\n+[[package]]\n+name = \"gccjit_sys\"\n+version = \"0.0.1\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+dependencies = [\n+ \"libc 0.1.12\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n+dependencies = [\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc 0.2.102\",\n+ \"wasi\",\n+]\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n+dependencies = [\n+ \"libc 0.2.102\",\n+]\n+\n+[[package]]\n+name = \"indexmap\"\n+version = \"1.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc633605454125dec4b66843673f01c7df2b89479b32e0ed634e43a91cff62a5\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n+\n+[[package]]\n+name = \"lang_tester\"\n+version = \"0.3.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n+dependencies = [\n+ \"fm\",\n+ \"getopts\",\n+ \"libc 0.2.102\",\n+ \"num_cpus\",\n+ \"termcolor\",\n+ \"threadpool\",\n+ \"wait-timeout\",\n+ \"walkdir\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.1.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.102\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"2.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+\n+[[package]]\n+name = \"num_cpus\"\n+version = \"1.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc 0.2.102\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.25.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a38f2be3697a57b4060074ff41b44c16870d916ad7877c17696e063257482bc7\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"indexmap\",\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"ppv-lite86\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.8.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n+dependencies = [\n+ \"libc 0.2.102\",\n+ \"rand_chacha\",\n+ \"rand_core\",\n+ \"rand_hc\",\n+]\n+\n+[[package]]\n+name = \"rand_chacha\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88\"\n+dependencies = [\n+ \"ppv-lite86\",\n+ \"rand_core\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d34f1408f55294453790c48b2f1ebbb1c5b4b7563eb1f418bcfcfdbb06ebb4e7\"\n+dependencies = [\n+ \"getrandom\",\n+]\n+\n+[[package]]\n+name = \"rand_hc\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d51e9f596de227fda2ea6c84607f5558e196eeaf43c986b724ba4fb8fdf497e7\"\n+dependencies = [\n+ \"rand_core\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n+[[package]]\n+name = \"regex\"\n+version = \"1.5.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d07a8629359eb56f1e2fb1652bb04212c072a87ba68546a04065d525673ac461\"\n+dependencies = [\n+ \"aho-corasick\",\n+ \"memchr\",\n+ \"regex-syntax\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.6.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b\"\n+\n+[[package]]\n+name = \"remove_dir_all\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3acd125665422973a33ac9d3dd2df85edad0f4ae9b00dafb1a05e43a9f5ef8e7\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"rustc_codegen_gcc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ar\",\n+ \"gccjit\",\n+ \"lang_tester\",\n+ \"object\",\n+ \"target-lexicon\",\n+ \"tempfile\",\n+]\n+\n+[[package]]\n+name = \"same-file\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"target-lexicon\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab0e7238dcc7b40a7be719a25365910f6807bd864f4cce6b2e6b873658e2b19d\"\n+\n+[[package]]\n+name = \"tempfile\"\n+version = \"3.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc 0.2.102\",\n+ \"rand\",\n+ \"redox_syscall\",\n+ \"remove_dir_all\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"termcolor\"\n+version = \"1.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2dfed899f0eb03f32ee8c6a0aabdb8a7949659e3466561fc0adf54e26d88c5f4\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"threadpool\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n+dependencies = [\n+ \"num_cpus\",\n+]\n+\n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n+\n+[[package]]\n+name = \"wait-timeout\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n+dependencies = [\n+ \"libc 0.2.102\",\n+]\n+\n+[[package]]\n+name = \"walkdir\"\n+version = \"2.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56\"\n+dependencies = [\n+ \"same-file\",\n+ \"winapi\",\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.10.2+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-util\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "9e8c195c15f6054084ba875ebb26f8c349b9906c", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,51 @@\n+[package]\n+name = \"rustc_codegen_gcc\"\n+version = \"0.1.0\"\n+authors = [\"Antoni Boucher <bouanto@zoho.com>\"]\n+edition = \"2018\"\n+license = \"MIT OR Apache-2.0\"\n+\n+[lib]\n+crate-type = [\"dylib\"]\n+\n+[[test]]\n+name = \"lang_tests\"\n+path = \"tests/lib.rs\"\n+harness = false\n+\n+[dependencies]\n+gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n+\n+# Local copy.\n+#gccjit = { path = \"../gccjit.rs\" }\n+\n+target-lexicon = \"0.10.0\"\n+\n+ar = \"0.8.0\"\n+\n+[dependencies.object]\n+version = \"0.25.0\"\n+default-features = false\n+features = [\"read\", \"std\", \"write\"] # We don't need WASM support.\n+\n+[dev-dependencies]\n+lang_tester = \"0.3.9\"\n+tempfile = \"3.1.0\"\n+\n+[profile.dev]\n+# By compiling dependencies with optimizations, performing tests gets much faster.\n+opt-level = 3\n+\n+[profile.dev.package.rustc_codegen_gcc]\n+# Disabling optimizations for cg_gccjit itself makes compilation after a change faster.\n+opt-level = 0\n+\n+# Disable optimizations and debuginfo of build scripts and some of the heavy build deps, as the\n+# execution time of build scripts is so fast that optimizing them slows down the total build time.\n+[profile.dev.build-override]\n+opt-level = 0\n+debug = false\n+\n+[profile.release.build-override]\n+opt-level = 0\n+debug = false"}, {"sha": "1b5ec8b78e237b5c3b3d812a7c0a6589d0f7161d", "filename": "compiler/rustc_codegen_gcc/LICENSE-APACHE", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FLICENSE-APACHE?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,176 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS"}, {"sha": "31aa79387f27e730e33d871925e152e35e428031", "filename": "compiler/rustc_codegen_gcc/LICENSE-MIT", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FLICENSE-MIT?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,23 @@\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "709d93c6edb054f384fd2c9a4823597e827753e9", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,135 @@\n+# WIP libgccjit codegen backend for rust\n+\n+This is a GCC codegen for rustc, which means it can be loaded by the existing rustc frontend, but benefits from GCC: more architectures are supported and GCC's optimizations are used.\n+\n+**Despite its name, libgccjit can be used for ahead-of-time compilation, as is used here.**\n+\n+## Motivation\n+\n+The primary goal of this project is to be able to compile Rust code on platforms unsupported by LLVM.\n+A secondary goal is to check if using the gcc backend will provide any run-time speed improvement for the programs compiled using rustc.\n+\n+## Building\n+\n+**This requires a patched libgccjit in order to work.\n+The patches in [this repostory](https://github.com/antoyo/libgccjit-patches) need to be applied.\n+(Those patches should work when applied on master, but in case it doesn't work, they are known to work when applied on 079c23cfe079f203d5df83fea8e92a60c7d7e878.)\n+You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already includes these patches.**\n+\n+**Put the path to your custom build of libgccjit in the file `gcc_path`.**\n+\n+```bash\n+$ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n+$ cd rustc_codegen_gcc\n+$ ./prepare_build.sh # download and patch sysroot src\n+$ ./build.sh --release\n+```\n+\n+To run the tests:\n+\n+```bash\n+$ ./prepare.sh # download and patch sysroot src and install hyperfine for benchmarking\n+$ ./test.sh --release\n+```\n+\n+## Usage\n+\n+`$cg_gccjit_dir` is the directory you cloned this repo into in the following instructions.\n+\n+### Cargo\n+\n+```bash\n+$ CHANNEL=\"release\" $cg_gccjit_dir/cargo.sh run\n+```\n+\n+If you compiled cg_gccjit in debug mode (aka you didn't pass `--release` to `./test.sh`) you should use `CHANNEL=\"debug\"` instead or omit `CHANNEL=\"release\"` completely.\n+\n+### Rustc\n+\n+> You should prefer using the Cargo method.\n+\n+```bash\n+$ rustc +$(cat $cg_gccjit_dir/rust-toolchain) -Cpanic=abort -Zcodegen-backend=$cg_gccjit_dir/target/release/librustc_codegen_gcc.so --sysroot $cg_gccjit_dir/build_sysroot/sysroot my_crate.rs\n+```\n+\n+## Env vars\n+\n+<dl>\n+    <dt>CG_GCCJIT_INCR_CACHE_DISABLED</dt>\n+    <dd>Don't cache object files in the incremental cache. Useful during development of cg_gccjit\n+    to make it possible to use incremental mode for all analyses performed by rustc without caching\n+    object files when their content should have been changed by a change to cg_gccjit.</dd>\n+    <dt>CG_GCCJIT_DISPLAY_CG_TIME</dt>\n+    <dd>Display the time it took to perform codegen for a crate</dd>\n+</dl>\n+\n+## Debugging\n+\n+Sometimes, libgccjit will crash and output an error like this:\n+\n+```\n+during RTL pass: expand\n+libgccjit.so: error: in expmed_mode_index, at expmed.h:249\n+0x7f0da2e61a35 expmed_mode_index\n+\t../../../gcc/gcc/expmed.h:249\n+0x7f0da2e61aa4 expmed_op_cost_ptr\n+\t../../../gcc/gcc/expmed.h:271\n+0x7f0da2e620dc sdiv_cost_ptr\n+\t../../../gcc/gcc/expmed.h:540\n+0x7f0da2e62129 sdiv_cost\n+\t../../../gcc/gcc/expmed.h:558\n+0x7f0da2e73c12 expand_divmod(int, tree_code, machine_mode, rtx_def*, rtx_def*, rtx_def*, int)\n+\t../../../gcc/gcc/expmed.c:4335\n+0x7f0da2ea1423 expand_expr_real_2(separate_ops*, rtx_def*, machine_mode, expand_modifier)\n+\t../../../gcc/gcc/expr.c:9240\n+0x7f0da2cd1a1e expand_gimple_stmt_1\n+\t../../../gcc/gcc/cfgexpand.c:3796\n+0x7f0da2cd1c30 expand_gimple_stmt\n+\t../../../gcc/gcc/cfgexpand.c:3857\n+0x7f0da2cd90a9 expand_gimple_basic_block\n+\t../../../gcc/gcc/cfgexpand.c:5898\n+0x7f0da2cdade8 execute\n+\t../../../gcc/gcc/cfgexpand.c:6582\n+```\n+\n+To see the code which causes this error, call the following function:\n+\n+```c\n+gcc_jit_context_dump_to_file(ctxt, \"/tmp/output.c\", 1 /* update_locations */)\n+```\n+\n+This will create a C-like file and add the locations into the IR pointing to this C file.\n+Then, rerun the program and it will output the location in the second line:\n+\n+```\n+libgccjit.so: /tmp/something.c:61322:0: error: in expmed_mode_index, at expmed.h:249\n+```\n+\n+Or add a breakpoint to `add_error` in gdb and print the line number using:\n+\n+```\n+p loc->m_line\n+```\n+\n+### How to use a custom-build rustc\n+\n+ * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n+ * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n+\n+### How to build a cross-compiling libgccjit\n+\n+#### Building libgccjit\n+\n+ * Follow these instructions: https://preshing.com/20141119/how-to-build-a-gcc-cross-compiler/ with the following changes:\n+ * Configure gcc with `../gcc/configure --enable-host-shared --disable-multilib --enable-languages=c,jit,c++ --disable-bootstrap --enable-checking=release --prefix=/opt/m68k-gcc/ --target=m68k-linux --without-headers`.\n+ * Some shells, like fish, don't define the environment variable `$MACHTYPE`.\n+ * Add `CFLAGS=\"-Wno-error=attributes -g -O2\"` at the end of the configure command for building glibc (`CFLAGS=\"-Wno-error=attributes -Wno-error=array-parameter -Wno-error=stringop-overflow -Wno-error=array-bounds -g -O2\"` for glibc 2.31, which is useful for Debian).\n+\n+#### Configuring rustc_codegen_gcc\n+\n+ * Set `TARGET_TRIPLE=\"m68k-unknown-linux-gnu\"` in config.sh.\n+ * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n+ * Set `linker='-Clinker=m68k-linux-gcc'`.\n+ * Set the path to the cross-compiling libgccjit in `gcc_path`.\n+ * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n+ * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "17a0d2ab3f0601f92b56bccff8b7ba0adde227d5", "filename": "compiler/rustc_codegen_gcc/build.sh", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,31 @@\n+#!/bin/bash\n+\n+#set -x\n+set -e\n+\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n+\n+export LD_LIBRARY_PATH=\"$GCC_PATH\"\n+export LIBRARY_PATH=\"$GCC_PATH\"\n+\n+if [[ \"$1\" == \"--release\" ]]; then\n+    export CHANNEL='release'\n+    CARGO_INCREMENTAL=1 cargo rustc --release\n+else\n+    echo $LD_LIBRARY_PATH\n+    export CHANNEL='debug'\n+    cargo rustc\n+fi\n+\n+source config.sh\n+\n+rm -r target/out || true\n+mkdir -p target/out/gccjit\n+\n+echo \"[BUILD] sysroot\"\n+time ./build_sysroot/build_sysroot.sh $CHANNEL"}, {"sha": "cfadf47cc3f8608ad5e26832d7c53a6571efb8cc", "filename": "compiler/rustc_codegen_gcc/build_sysroot/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2FCargo.toml?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+authors = [\"bjorn3 <bjorn3@users.noreply.github.com>\"]\n+name = \"sysroot\"\n+version = \"0.0.0\"\n+\n+[dependencies]\n+core = { path = \"./sysroot_src/library/core\" }\n+compiler_builtins = \"0.1\"\n+alloc = { path = \"./sysroot_src/library/alloc\" }\n+std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n+test = { path = \"./sysroot_src/library/test\" }\n+\n+[patch.crates-io]\n+rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n+rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }\n+rustc-std-workspace-std = { path = \"./sysroot_src/library/rustc-std-workspace-std\" }\n+\n+[profile.release]\n+debug = true"}, {"sha": "d1dcf495db8a3770df197c7f80b22a2573475c0b", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,30 @@\n+#!/bin/bash\n+\n+# Requires the CHANNEL env var to be set to `debug` or `release.`\n+\n+set -e\n+cd $(dirname \"$0\")\n+\n+pushd ../ >/dev/null\n+source ./config.sh\n+popd >/dev/null\n+\n+# Cleanup for previous run\n+#     v Clean target dir except for build scripts and incremental cache\n+rm -r target/*/{debug,release}/{build,deps,examples,libsysroot*,native} 2>/dev/null || true\n+rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n+rm -r sysroot/ 2>/dev/null || true\n+\n+# Build libs\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+if [[ \"$1\" == \"--release\" ]]; then\n+    sysroot_channel='release'\n+    RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release\n+else\n+    sysroot_channel='debug'\n+    cargo build --target $TARGET_TRIPLE\n+fi\n+\n+# Copy files to sysroot\n+mkdir -p sysroot/lib/rustlib/$TARGET_TRIPLE/lib/\n+cp -r target/$TARGET_TRIPLE/$sysroot_channel/deps/* sysroot/lib/rustlib/$TARGET_TRIPLE/lib/"}, {"sha": "071e7ed1f85df465dabe68bf1ee3e0216d2f424d", "filename": "compiler/rustc_codegen_gcc/build_sysroot/prepare_sysroot_src.sh", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,39 @@\n+#!/bin/bash\n+set -e\n+cd $(dirname \"$0\")\n+\n+SRC_DIR=$(dirname $(rustup which rustc))\"/../lib/rustlib/src/rust/\"\n+DST_DIR=\"sysroot_src\"\n+\n+if [ ! -e $SRC_DIR ]; then\n+    echo \"Please install rust-src component\"\n+    exit 1\n+fi\n+\n+rm -rf $DST_DIR\n+mkdir -p $DST_DIR/library\n+cp -r $SRC_DIR/library $DST_DIR/\n+\n+pushd $DST_DIR\n+echo \"[GIT] init\"\n+git init\n+echo \"[GIT] add\"\n+git add .\n+echo \"[GIT] commit\"\n+\n+# This is needed on systems where nothing is configured.\n+# git really needs something here, or it will fail.\n+# Even using --author is not enough.\n+git config user.email || git config user.email \"none@example.com\"\n+git config user.name || git config user.name \"None\"\n+\n+git commit -m \"Initial commit\" -q\n+for file in $(ls ../../patches/ | grep -v patcha); do\n+echo \"[GIT] apply\" $file\n+git apply ../../patches/$file\n+git add -A\n+git commit --no-gpg-sign -m \"Patch $file\"\n+done\n+popd\n+\n+echo \"Successfully prepared libcore for building\""}, {"sha": "0c9ac1ac8e4bd702086402213af792ae0636d192", "filename": "compiler/rustc_codegen_gcc/build_sysroot/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fsrc%2Flib.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1 @@\n+#![no_std]"}, {"sha": "1001c522052c800b15d170971d187b6987092288", "filename": "compiler/rustc_codegen_gcc/cargo.sh", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fcargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fcargo.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,23 @@\n+#!/bin/bash\n+\n+if [ -z $CHANNEL ]; then\n+export CHANNEL='debug'\n+fi\n+\n+pushd $(dirname \"$0\") >/dev/null\n+source config.sh\n+\n+# read nightly compiler from rust-toolchain file\n+TOOLCHAIN=$(cat rust-toolchain)\n+\n+popd >/dev/null\n+\n+if [[ $(rustc -V) != $(rustc +${TOOLCHAIN} -V) ]]; then\n+    echo \"rustc_codegen_gcc is build for $(rustc +${TOOLCHAIN} -V) but the default rustc version is $(rustc -V).\"\n+    echo \"Using $(rustc +${TOOLCHAIN} -V).\"\n+fi\n+\n+cmd=$1\n+shift\n+\n+RUSTDOCFLAGS=\"$RUSTFLAGS\" cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@"}, {"sha": "a77d1486fe283f8a22819fc58b5e7edb3863fb7d", "filename": "compiler/rustc_codegen_gcc/clean_all.sh", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fclean_all.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,5 @@\n+#!/bin/bash --verbose\n+set -e\n+\n+rm -rf target/ build_sysroot/{sysroot/,sysroot_src/,target/,Cargo.lock} perf.data{,.old}\n+rm -rf regex/ simple-raytracer/"}, {"sha": "87df2f2102bcd42dd3ede437a72a30552ff147e3", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,52 @@\n+set -e\n+\n+export CARGO_INCREMENTAL=0\n+\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n+\n+unamestr=`uname`\n+if [[ \"$unamestr\" == 'Linux' ]]; then\n+   dylib_ext='so'\n+elif [[ \"$unamestr\" == 'Darwin' ]]; then\n+   dylib_ext='dylib'\n+else\n+   echo \"Unsupported os\"\n+   exit 1\n+fi\n+\n+HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+TARGET_TRIPLE=$HOST_TRIPLE\n+#TARGET_TRIPLE=\"m68k-unknown-linux-gnu\"\n+\n+linker=''\n+RUN_WRAPPER=''\n+if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+   if [[ \"$TARGET_TRIPLE\" == \"m68k-unknown-linux-gnu\" ]]; then\n+       TARGET_TRIPLE=\"mips-unknown-linux-gnu\"\n+       linker='-Clinker=m68k-linux-gcc'\n+   elif [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n+      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+      linker='-Clinker=aarch64-linux-gnu-gcc'\n+      RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n+   else\n+      echo \"Unknown non-native platform\"\n+   fi\n+fi\n+\n+export RUSTFLAGS=\"$linker -Cpanic=abort -Zsymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+\n+# FIXME(antoyo): remove once the atomic shim is gone\n+if [[ `uname` == 'Darwin' ]]; then\n+   export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n+fi\n+\n+RUSTC=\"rustc $RUSTFLAGS -L crate=target/out --out-dir target/out\"\n+export RUSTC_LOG=warn # display metadata load errors\n+\n+export LD_LIBRARY_PATH=\"$(pwd)/target/out:$(pwd)/build_sysroot/sysroot/lib/rustlib/$TARGET_TRIPLE/lib:$GCC_PATH\"\n+export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH"}, {"sha": "bc6dd007ba010b8cc511bedcbf045d46f981699d", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,41 @@\n+#![feature(start, box_syntax, core_intrinsics, alloc_prelude, alloc_error_handler)]\n+#![no_std]\n+\n+extern crate alloc;\n+extern crate alloc_system;\n+\n+use alloc::prelude::v1::*;\n+\n+use alloc_system::System;\n+\n+#[global_allocator]\n+static ALLOC: System = System;\n+\n+#[link(name = \"c\")]\n+extern \"C\" {\n+    fn puts(s: *const u8) -> i32;\n+}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    unsafe {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+#[alloc_error_handler]\n+fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n+    unsafe {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    let world: Box<&str> = box \"Hello World!\\0\";\n+    unsafe {\n+        puts(*world as *const str as *const u8);\n+    }\n+\n+    0\n+}"}, {"sha": "5f66ca67f2d409e9699c49a9fcda047c1e8c6ca9", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![no_std]\n+#![feature(allocator_api, rustc_private)]\n+#![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]\n+\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\")))]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+const MIN_ALIGN: usize = 16;\n+\n+pub struct System;\n+#[cfg(any(windows, unix, target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n+    }\n+}\n+#[cfg(any(unix, target_os = \"redox\"))]\n+mod platform {\n+    extern crate libc;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut u8\n+            } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return ptr::null_mut()\n+                    }\n+                }\n+                aligned_malloc(&layout)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::calloc(layout.size(), 1) as *mut u8\n+            } else {\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr, 0, layout.size());\n+                }\n+                ptr\n+            }\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+            libc::free(ptr as *mut libc::c_void)\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\"))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n+    }\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\",\n+                  target_os = \"solaris\")))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n+        }\n+    }\n+}\n+#[cfg(windows)]\n+#[allow(nonstandard_style)]\n+mod platform {\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n+    }\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+    #[inline]\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n+        let ptr = if layout.align() <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, layout.size())\n+        } else {\n+            let size = layout.size() + layout.align();\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n+            if ptr.is_null() {\n+                ptr\n+            } else {\n+                align_ptr(ptr, layout.align())\n+            }\n+        };\n+        ptr as *mut u8\n+    }\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, 0)\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            if layout.align() <= MIN_ALIGN {\n+                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            } else {\n+                let header = get_header(ptr);\n+                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            }\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+}"}, {"sha": "ddeb752f93ed71257d6dd2e39d33b372416eca1a", "filename": "compiler/rustc_codegen_gcc/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,69 @@\n+// Adapted from rustc run-pass test suite\n+\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n+#![feature(rustc_attrs)]\n+\n+use std::{\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n+    marker::Unsize,\n+};\n+\n+struct Ptr<T: ?Sized>(Box<T>);\n+\n+impl<T: ?Sized> Deref for Ptr<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n+\n+struct Wrapper<T: ?Sized>(T);\n+\n+impl<T: ?Sized> Deref for Wrapper<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n+\n+\n+trait Trait {\n+    // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n+    // without unsized_locals), but wrappers arond `Self` currently are not.\n+    // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n+    // fn wrapper(self: Wrapper<Self>) -> i32;\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32;\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32;\n+}\n+\n+impl Trait for i32 {\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32 {\n+        ***self\n+    }\n+}\n+\n+fn main() {\n+    let pw = Ptr(Box::new(Wrapper(5))) as Ptr<Wrapper<dyn Trait>>;\n+    assert_eq!(pw.ptr_wrapper(), 5);\n+\n+    let wp = Wrapper(Ptr(Box::new(6))) as Wrapper<Ptr<dyn Trait>>;\n+    assert_eq!(wp.wrapper_ptr(), 6);\n+\n+    let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n+}"}, {"sha": "6c338e99912ec2eec32edaa156f6d9fc7b9d8523", "filename": "compiler/rustc_codegen_gcc/example/dst-field-align.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fdst-field-align.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,67 @@\n+// run-pass\n+#![allow(dead_code)]\n+struct Foo<T: ?Sized> {\n+    a: u16,\n+    b: T\n+}\n+\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for usize {\n+    fn get(&self) -> usize { *self }\n+}\n+\n+struct Baz<T: ?Sized> {\n+    a: T\n+}\n+\n+struct HasDrop<T: ?Sized> {\n+    ptr: Box<usize>,\n+    data: T\n+}\n+\n+fn main() {\n+    // Test that zero-offset works properly\n+    let b : Baz<usize> = Baz { a: 7 };\n+    assert_eq!(b.a.get(), 7);\n+    let b : &Baz<dyn Bar> = &b;\n+    assert_eq!(b.a.get(), 7);\n+\n+    // Test that the field is aligned properly\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    assert_eq!(f.b.get(), 11);\n+    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+\n+    let f : &Foo<dyn Bar> = &f;\n+    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n+    assert_eq!(f.b.get(), 11);\n+\n+    // The pointers should be the same\n+    assert_eq!(ptr1, ptr2);\n+\n+    // Test that nested DSTs work properly\n+    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    assert_eq!(f.b.b.get(), 17);\n+    let f : &Foo<Foo<dyn Bar>> = &f;\n+    assert_eq!(f.b.b.get(), 17);\n+\n+    // Test that get the pointer via destructuring works\n+\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f : &Foo<dyn Bar> = &f;\n+    let &Foo { a: _, b: ref bar } = f;\n+    assert_eq!(bar.get(), 11);\n+\n+    // Make sure that drop flags don't screw things up\n+\n+    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n+        ptr: Box::new(0),\n+        data: Baz { a: [1,2,3,4] }\n+    };\n+    assert_eq!([1,2,3,4], d.data.a);\n+\n+    let d : &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1,2,3,4], &d.data.a);\n+}"}, {"sha": "5878e8548d9269d1180cbba739de6b1d5d05324e", "filename": "compiler/rustc_codegen_gcc/example/example.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fexample.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,208 @@\n+#![feature(no_core, unboxed_closures)]\n+#![no_core]\n+#![allow(dead_code)]\n+\n+extern crate mini_core;\n+\n+use mini_core::*;\n+\n+fn abc(a: u8) -> u8 {\n+    a * 2\n+}\n+\n+fn bcd(b: bool, a: u8) -> u8 {\n+    if b {\n+        a * 2\n+    } else {\n+        a * 3\n+    }\n+}\n+\n+fn call() {\n+    abc(42);\n+}\n+\n+fn indirect_call() {\n+    let f: fn() = call;\n+    f();\n+}\n+\n+enum BoolOption {\n+    Some(bool),\n+    None,\n+}\n+\n+fn option_unwrap_or(o: BoolOption, d: bool) -> bool {\n+    match o {\n+        BoolOption::Some(b) => b,\n+        BoolOption::None => d,\n+    }\n+}\n+\n+fn ret_42() -> u8 {\n+    42\n+}\n+\n+fn return_str() -> &'static str {\n+    \"hello world\"\n+}\n+\n+fn promoted_val() -> &'static u8 {\n+    &(1 * 2)\n+}\n+\n+fn cast_ref_to_raw_ptr(abc: &u8) -> *const u8 {\n+    abc as *const u8\n+}\n+\n+fn cmp_raw_ptr(a: *const u8, b: *const u8) -> bool {\n+    a == b\n+}\n+\n+fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n+    (\n+        a as u8, a as u16, a as u32, a as usize, a as i8, a as i16, a as i32, a as isize, b as u8,\n+        b as u32,\n+    )\n+}\n+\n+fn char_cast(c: char) -> u8 {\n+    c as u8\n+}\n+\n+pub struct DebugTuple(());\n+\n+fn debug_tuple() -> DebugTuple {\n+    DebugTuple(())\n+}\n+\n+fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+fn use_size_of() -> usize {\n+    size_of::<u64>()\n+}\n+\n+unsafe fn use_copy_intrinsic(src: *const u8, dst: *mut u8) {\n+    intrinsics::copy::<u8>(src, dst, 1);\n+}\n+\n+unsafe fn use_copy_intrinsic_ref(src: *const u8, dst: *mut u8) {\n+    let copy2 = &intrinsics::copy::<u8>;\n+    copy2(src, dst, 1);\n+}\n+\n+const ABC: u8 = 6 * 7;\n+\n+fn use_const() -> u8 {\n+    ABC\n+}\n+\n+pub fn call_closure_3arg() {\n+    (|_, _, _| {})(0u8, 42u16, 0u8)\n+}\n+\n+pub fn call_closure_2arg() {\n+    (|_, _| {})(0u8, 42u16)\n+}\n+\n+struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b [u16],)> for IsNotEmpty {\n+    type Output = (u8, u8);\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&'a &'b [u16],)) -> (u8, u8) {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b [u16],)> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, _arg: (&'a &'b [u16],)) -> (u8, u8) {\n+        (0, 42)\n+    }\n+}\n+\n+pub fn call_is_not_empty() {\n+    IsNotEmpty.call_once((&(&[0u16] as &[_]),));\n+}\n+\n+fn eq_char(a: char, b: char) -> bool {\n+    a == b\n+}\n+\n+unsafe fn transmute(c: char) -> u32 {\n+    intrinsics::transmute(c)\n+}\n+\n+unsafe fn deref_str_ptr(s: *const str) -> &'static str {\n+    &*s\n+}\n+\n+fn use_array(arr: [u8; 3]) -> u8 {\n+    arr[1]\n+}\n+\n+fn repeat_array() -> [u8; 3] {\n+    [0; 3]\n+}\n+\n+fn array_as_slice(arr: &[u8; 3]) -> &[u8] {\n+    arr\n+}\n+\n+unsafe fn use_ctlz_nonzero(a: u16) -> u16 {\n+    intrinsics::ctlz_nonzero(a)\n+}\n+\n+fn ptr_as_usize(ptr: *const u8) -> usize {\n+    ptr as usize\n+}\n+\n+fn float_cast(a: f32, b: f64) -> (f64, f32) {\n+    (a as f64, b as f32)\n+}\n+\n+fn int_to_float(a: u8, b: i32) -> (f64, f32) {\n+    (a as f64, b as f32)\n+}\n+\n+fn make_array() -> [u8; 3] {\n+    [42, 0, 5]\n+}\n+\n+fn some_promoted_tuple() -> &'static (&'static str, &'static str) {\n+    &(\"abc\", \"some\")\n+}\n+\n+fn index_slice(s: &[u8]) -> u8 {\n+    s[2]\n+}\n+\n+pub struct StrWrapper {\n+    s: str,\n+}\n+\n+fn str_wrapper_get(w: &StrWrapper) -> &str {\n+    &w.s\n+}\n+\n+fn i16_as_i8(a: i16) -> i8 {\n+    a as i8\n+}\n+\n+struct Unsized(u8, str);\n+\n+fn get_sized_field_ref_from_unsized_type(u: &Unsized) -> &u8 {\n+    &u.0\n+}\n+\n+fn get_unsized_field_ref_from_unsized_type(u: &Unsized) -> &str {\n+    &u.1\n+}\n+\n+pub fn reuse_byref_argument_storage(a: (u8, u16, u32)) -> u8 {\n+    a.0\n+}"}, {"sha": "1067cee88148756f597738b0e65ae1c332d45975", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "added", "additions": 585, "deletions": 0, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,585 @@\n+#![feature(\n+    no_core, lang_items, intrinsics, unboxed_closures, type_ascription, extern_types,\n+    untagged_unions, decl_macro, rustc_attrs, transparent_unions, auto_traits,\n+    thread_local\n+)]\n+#![no_core]\n+#![allow(dead_code)]\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    intrinsics::unreachable();\n+}\n+\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"unsize\"]\n+pub trait Unsize<T: ?Sized> {}\n+\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+\n+#[lang = \"dispatch_from_dyn\"]\n+pub trait DispatchFromDyn<T> {}\n+\n+// &T -> &U\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+// &mut T -> &mut U\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+// *const T -> *const U\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+// *mut T -> *mut U\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+\n+#[lang = \"receiver\"]\n+pub trait Receiver {}\n+\n+impl<T: ?Sized> Receiver for &T {}\n+impl<T: ?Sized> Receiver for &mut T {}\n+impl<T: ?Sized> Receiver for Box<T> {}\n+\n+#[lang = \"copy\"]\n+pub unsafe trait Copy {}\n+\n+unsafe impl Copy for bool {}\n+unsafe impl Copy for u8 {}\n+unsafe impl Copy for u16 {}\n+unsafe impl Copy for u32 {}\n+unsafe impl Copy for u64 {}\n+unsafe impl Copy for usize {}\n+unsafe impl Copy for i8 {}\n+unsafe impl Copy for i16 {}\n+unsafe impl Copy for i32 {}\n+unsafe impl Copy for isize {}\n+unsafe impl Copy for f32 {}\n+unsafe impl Copy for char {}\n+unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n+unsafe impl<T: ?Sized> Copy for *const T {}\n+unsafe impl<T: ?Sized> Copy for *mut T {}\n+\n+#[lang = \"sync\"]\n+pub unsafe trait Sync {}\n+\n+unsafe impl Sync for bool {}\n+unsafe impl Sync for u8 {}\n+unsafe impl Sync for u16 {}\n+unsafe impl Sync for u32 {}\n+unsafe impl Sync for u64 {}\n+unsafe impl Sync for usize {}\n+unsafe impl Sync for i8 {}\n+unsafe impl Sync for i16 {}\n+unsafe impl Sync for i32 {}\n+unsafe impl Sync for isize {}\n+unsafe impl Sync for char {}\n+unsafe impl<'a, T: ?Sized> Sync for &'a T {}\n+unsafe impl Sync for [u8; 16] {}\n+\n+#[lang = \"freeze\"]\n+unsafe auto trait Freeze {}\n+\n+unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}\n+unsafe impl<T: ?Sized> Freeze for *const T {}\n+unsafe impl<T: ?Sized> Freeze for *mut T {}\n+unsafe impl<T: ?Sized> Freeze for &T {}\n+unsafe impl<T: ?Sized> Freeze for &mut T {}\n+\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {}\n+\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {}\n+\n+#[lang = \"not\"]\n+pub trait Not {\n+    type Output;\n+\n+    fn not(self) -> Self::Output;\n+}\n+\n+impl Not for bool {\n+    type Output = bool;\n+\n+    fn not(self) -> bool {\n+        !self\n+    }\n+}\n+\n+#[lang = \"mul\"]\n+pub trait Mul<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Mul for u8 {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+impl Mul for usize {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+#[lang = \"rem\"]\n+pub trait Rem<RHS = Self> {\n+    type Output;\n+\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Rem for usize {\n+    type Output = Self;\n+\n+    fn rem(self, rhs: Self) -> Self {\n+        self % rhs\n+    }\n+}\n+\n+#[lang = \"bitor\"]\n+pub trait BitOr<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl BitOr for bool {\n+    type Output = bool;\n+\n+    fn bitor(self, rhs: bool) -> bool {\n+        self | rhs\n+    }\n+}\n+\n+impl<'a> BitOr<bool> for &'a bool {\n+    type Output = bool;\n+\n+    fn bitor(self, rhs: bool) -> bool {\n+        *self | rhs\n+    }\n+}\n+\n+#[lang = \"eq\"]\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n+    fn eq(&self, other: &Rhs) -> bool;\n+    fn ne(&self, other: &Rhs) -> bool;\n+}\n+\n+impl PartialEq for u8 {\n+    fn eq(&self, other: &u8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u16 {\n+    fn eq(&self, other: &u16) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u16) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u32 {\n+    fn eq(&self, other: &u32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+\n+impl PartialEq for u64 {\n+    fn eq(&self, other: &u64) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u64) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for usize {\n+    fn eq(&self, other: &usize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &usize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i8 {\n+    fn eq(&self, other: &i8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i32 {\n+    fn eq(&self, other: &i32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for isize {\n+    fn eq(&self, other: &isize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &isize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for char {\n+    fn eq(&self, other: &char) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &char) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl<T: ?Sized> PartialEq for *const T {\n+    fn eq(&self, other: &*const T) -> bool {\n+        *self == *other\n+    }\n+    fn ne(&self, other: &*const T) -> bool {\n+        *self != *other\n+    }\n+}\n+\n+#[lang = \"neg\"]\n+pub trait Neg {\n+    type Output;\n+\n+    fn neg(self) -> Self::Output;\n+}\n+\n+impl Neg for i8 {\n+    type Output = i8;\n+\n+    fn neg(self) -> i8 {\n+        -self\n+    }\n+}\n+\n+impl Neg for i16 {\n+    type Output = i16;\n+\n+    fn neg(self) -> i16 {\n+        self\n+    }\n+}\n+\n+impl Neg for isize {\n+    type Output = isize;\n+\n+    fn neg(self) -> isize {\n+        -self\n+    }\n+}\n+\n+impl Neg for f32 {\n+    type Output = f32;\n+\n+    fn neg(self) -> f32 {\n+        -self\n+    }\n+}\n+\n+pub enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+pub use Option::*;\n+\n+#[lang = \"phantom_data\"]\n+pub struct PhantomData<T: ?Sized>;\n+\n+#[lang = \"fn_once\"]\n+#[rustc_paren_sugar]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+#[rustc_paren_sugar]\n+pub trait FnMut<Args>: FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target: ?Sized;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized>(*mut T);\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+\n+impl<T: ?Sized> Drop for Box<T> {\n+    fn drop(&mut self) {\n+        // drop is currently performed by compiler.\n+    }\n+}\n+\n+impl<T> Deref for Box<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &**self\n+    }\n+}\n+\n+#[lang = \"exchange_malloc\"]\n+unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n+    libc::malloc(size)\n+}\n+\n+#[lang = \"box_free\"]\n+unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    libc::free(ptr as *mut u8);\n+}\n+\n+#[lang = \"drop\"]\n+pub trait Drop {\n+    fn drop(&mut self);\n+}\n+\n+#[lang = \"manually_drop\"]\n+#[repr(transparent)]\n+pub struct ManuallyDrop<T: ?Sized> {\n+    pub value: T,\n+}\n+\n+#[lang = \"maybe_uninit\"]\n+#[repr(transparent)]\n+pub union MaybeUninit<T> {\n+    pub uninit: (),\n+    pub value: ManuallyDrop<T>,\n+}\n+\n+pub mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+        pub fn size_of<T>() -> usize;\n+        pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn min_align_of<T>() -> usize;\n+        pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+        pub fn transmute<T, U>(e: T) -> U;\n+        pub fn ctlz_nonzero<T>(x: T) -> T;\n+        pub fn needs_drop<T>() -> bool;\n+        pub fn bitreverse<T>(x: T) -> T;\n+        pub fn bswap<T>(x: T) -> T;\n+        pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n+        pub fn unreachable() -> !;\n+    }\n+}\n+\n+pub mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn malloc(size: usize) -> *mut u8;\n+        pub fn free(ptr: *mut u8);\n+        pub fn memcpy(dst: *mut u8, src: *const u8, size: usize);\n+        pub fn memmove(dst: *mut u8, src: *const u8, size: usize);\n+        pub fn strncpy(dst: *mut u8, src: *const u8, size: usize);\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+extern {\n+    type VaListImpl;\n+}\n+\n+#[lang = \"va_list\"]\n+#[repr(transparent)]\n+pub struct VaList<'a>(&'a mut VaListImpl);\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro file() { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro line() { /* compiler built-in */ }\n+\n+#[rustc_builtin_macro]\n+#[rustc_macro_transparency = \"semitransparent\"]\n+pub macro cfg() { /* compiler built-in */ }\n+\n+pub static A_STATIC: u8 = 42;\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[no_mangle]\n+pub fn get_tls() -> u8 {\n+    #[thread_local]\n+    static A: u8 = 42;\n+\n+    A\n+}"}, {"sha": "69d591565acfa563820ee8c822098e4742603385", "filename": "compiler/rustc_codegen_gcc/example/mini_core_hello_world.rs", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,424 @@\n+// Adapted from https://github.com/sunfishcode/mir2cranelift/blob/master/rust-examples/nocore-hello-world.rs\n+\n+#![feature(\n+    no_core, unboxed_closures, start, lang_items, box_syntax, never_type, linkage,\n+    extern_types, thread_local\n+)]\n+#![no_core]\n+#![allow(dead_code, non_camel_case_types)]\n+\n+extern crate mini_core;\n+\n+use mini_core::*;\n+use mini_core::libc::*;\n+\n+unsafe extern \"C\" fn my_puts(s: *const u8) {\n+    puts(s);\n+}\n+\n+#[lang = \"termination\"]\n+trait Termination {\n+    fn report(self) -> i32;\n+}\n+\n+impl Termination for () {\n+    fn report(self) -> i32 {\n+        unsafe {\n+            NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n+            *NUM_REF as i32\n+        }\n+    }\n+}\n+\n+trait SomeTrait {\n+    fn object_safe(&self);\n+}\n+\n+impl SomeTrait for &'static str {\n+    fn object_safe(&self) {\n+        unsafe {\n+            puts(*self as *const str as *const u8);\n+        }\n+    }\n+}\n+\n+struct NoisyDrop {\n+    text: &'static str,\n+    inner: NoisyDropInner,\n+}\n+\n+struct NoisyDropInner;\n+\n+impl Drop for NoisyDrop {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(self.text as *const str as *const u8);\n+        }\n+    }\n+}\n+\n+impl Drop for NoisyDropInner {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(\"Inner got dropped!\\0\" as *const str as *const u8);\n+        }\n+    }\n+}\n+\n+impl SomeTrait for NoisyDrop {\n+    fn object_safe(&self) {}\n+}\n+\n+enum Ordering {\n+    Less = -1,\n+    Equal = 0,\n+    Greater = 1,\n+}\n+\n+#[lang = \"start\"]\n+fn start<T: Termination + 'static>(\n+    main: fn() -> T,\n+    argc: isize,\n+    argv: *const *const u8,\n+) -> isize {\n+    if argc == 3 {\n+        unsafe { puts(*argv); }\n+        unsafe { puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const u8)); }\n+        unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const u8)); }\n+    }\n+\n+    main().report();\n+    0\n+}\n+\n+static mut NUM: u8 = 6 * 7;\n+static NUM_REF: &'static u8 = unsafe { &NUM };\n+\n+macro_rules! assert {\n+    ($e:expr) => {\n+        if !$e {\n+            panic(stringify!(! $e));\n+        }\n+    };\n+}\n+\n+macro_rules! assert_eq {\n+    ($l:expr, $r: expr) => {\n+        if $l != $r {\n+            panic(stringify!($l != $r));\n+        }\n+    }\n+}\n+\n+struct Unique<T: ?Sized> {\n+    pointer: *const T,\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+\n+unsafe fn zeroed<T>() -> T {\n+    let mut uninit = MaybeUninit { uninit: () };\n+    intrinsics::write_bytes(&mut uninit.value.value as *mut T, 0, 1);\n+    uninit.value.value\n+}\n+\n+fn take_f32(_f: f32) {}\n+fn take_unique(_u: Unique<()>) {}\n+\n+fn return_u128_pair() -> (u128, u128) {\n+    (0, 0)\n+}\n+\n+fn call_return_u128_pair() {\n+    return_u128_pair();\n+}\n+\n+fn main() {\n+    take_unique(Unique {\n+        pointer: 0 as *const (),\n+        _marker: PhantomData,\n+    });\n+    take_f32(0.1);\n+\n+    //call_return_u128_pair();\n+\n+    let slice = &[0, 1] as &[i32];\n+    let slice_ptr = slice as *const [i32] as *const i32;\n+\n+    assert_eq!(slice_ptr as usize % 4, 0);\n+\n+    //return;\n+\n+    unsafe {\n+        printf(\"Hello %s\\n\\0\" as *const str as *const i8, \"printf\\0\" as *const str as *const i8);\n+\n+        let hello: &[u8] = b\"Hello\\0\" as &[u8; 6];\n+        let ptr: *const u8 = hello as *const [u8] as *const u8;\n+        puts(ptr);\n+\n+        let world: Box<&str> = box \"World!\\0\";\n+        puts(*world as *const str as *const u8);\n+        world as Box<dyn SomeTrait>;\n+\n+        assert_eq!(intrinsics::bitreverse(0b10101000u8), 0b00010101u8);\n+\n+        assert_eq!(intrinsics::bswap(0xabu8), 0xabu8);\n+        assert_eq!(intrinsics::bswap(0xddccu16), 0xccddu16);\n+        assert_eq!(intrinsics::bswap(0xffee_ddccu32), 0xccdd_eeffu32);\n+        assert_eq!(intrinsics::bswap(0x1234_5678_ffee_ddccu64), 0xccdd_eeff_7856_3412u64);\n+\n+        assert_eq!(intrinsics::size_of_val(hello) as u8, 6);\n+\n+        let chars = &['C', 'h', 'a', 'r', 's'];\n+        let chars = chars as &[char];\n+        assert_eq!(intrinsics::size_of_val(chars) as u8, 4 * 5);\n+\n+        let a: &dyn SomeTrait = &\"abc\\0\";\n+        a.object_safe();\n+\n+        assert_eq!(intrinsics::size_of_val(a) as u8, 16);\n+        assert_eq!(intrinsics::size_of_val(&0u32) as u8, 4);\n+\n+        assert_eq!(intrinsics::min_align_of::<u16>() as u8, 2);\n+        assert_eq!(intrinsics::min_align_of_val(&a) as u8, intrinsics::min_align_of::<&str>() as u8);\n+\n+        assert!(!intrinsics::needs_drop::<u8>());\n+        assert!(intrinsics::needs_drop::<NoisyDrop>());\n+\n+        Unique {\n+            pointer: 0 as *const &str,\n+            _marker: PhantomData,\n+        } as Unique<dyn SomeTrait>;\n+\n+        struct MyDst<T: ?Sized>(T);\n+\n+        intrinsics::size_of_val(&MyDst([0u8; 4]) as &MyDst<[u8]>);\n+\n+        struct Foo {\n+            x: u8,\n+            y: !,\n+        }\n+\n+        unsafe fn uninitialized<T>() -> T {\n+            MaybeUninit { uninit: () }.value.value\n+        }\n+\n+        zeroed::<(u8, u8)>();\n+        #[allow(unreachable_code)]\n+        {\n+            if false {\n+                zeroed::<!>();\n+                zeroed::<Foo>();\n+                uninitialized::<Foo>();\n+            }\n+        }\n+    }\n+\n+    let _ = box NoisyDrop {\n+        text: \"Boxed outer got dropped!\\0\",\n+        inner: NoisyDropInner,\n+    } as Box<dyn SomeTrait>;\n+\n+    const FUNC_REF: Option<fn()> = Some(main);\n+    match FUNC_REF {\n+        Some(_) => {},\n+        None => assert!(false),\n+    }\n+\n+    match Ordering::Less {\n+        Ordering::Less => {},\n+        _ => assert!(false),\n+    }\n+\n+    [NoisyDropInner, NoisyDropInner];\n+\n+    let x = &[0u32, 42u32] as &[u32];\n+    match x {\n+        [] => assert_eq!(0u32, 1),\n+        [_, ref y @ ..] => assert_eq!(&x[1] as *const u32 as usize, &y[0] as *const u32 as usize),\n+    }\n+\n+    assert_eq!(((|()| 42u8) as fn(()) -> u8)(()), 42);\n+\n+    extern {\n+        #[linkage = \"weak\"]\n+        static ABC: *const u8;\n+    }\n+\n+    {\n+        extern {\n+            #[linkage = \"weak\"]\n+            static ABC: *const u8;\n+        }\n+    }\n+\n+    // TODO(antoyo): to make this work, support weak linkage.\n+    //unsafe { assert_eq!(ABC as usize, 0); }\n+\n+    &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n+\n+    let f = 1000.0;\n+    assert_eq!(f as u8, 255);\n+    let f2 = -1000.0;\n+    assert_eq!(f2 as i8, -128);\n+    assert_eq!(f2 as u8, 0);\n+\n+    static ANOTHER_STATIC: &u8 = &A_STATIC;\n+    assert_eq!(*ANOTHER_STATIC, 42);\n+\n+    check_niche_behavior();\n+\n+    extern \"C\" {\n+        type ExternType;\n+    }\n+\n+    struct ExternTypeWrapper {\n+        _a: ExternType,\n+    }\n+\n+    let nullptr = 0 as *const ();\n+    let extern_nullptr = nullptr as *const ExternTypeWrapper;\n+    extern_nullptr as *const ();\n+    let slice_ptr = &[] as *const [u8];\n+    slice_ptr as *const u8;\n+\n+    #[cfg(not(jit))]\n+    test_tls();\n+}\n+\n+#[repr(C)]\n+enum c_void {\n+    _1,\n+    _2,\n+}\n+\n+type c_int = i32;\n+type c_ulong = u64;\n+\n+type pthread_t = c_ulong;\n+\n+#[repr(C)]\n+struct pthread_attr_t {\n+    __size: [u64; 7],\n+}\n+\n+#[link(name = \"pthread\")]\n+extern \"C\" {\n+    fn pthread_attr_init(attr: *mut pthread_attr_t) -> c_int;\n+\n+    fn pthread_create(\n+        native: *mut pthread_t,\n+        attr: *const pthread_attr_t,\n+        f: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n+        value: *mut c_void\n+    ) -> c_int;\n+\n+    fn pthread_join(\n+        native: pthread_t,\n+        value: *mut *mut c_void\n+    ) -> c_int;\n+}\n+\n+#[thread_local]\n+#[cfg(not(jit))]\n+static mut TLS: u8 = 42;\n+\n+#[cfg(not(jit))]\n+extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n+    unsafe { TLS = 0; }\n+    0 as *mut c_void\n+}\n+\n+#[cfg(not(jit))]\n+fn test_tls() {\n+    unsafe {\n+        let mut attr: pthread_attr_t = zeroed();\n+        let mut thread: pthread_t = 0;\n+\n+        assert_eq!(TLS, 42);\n+\n+        if pthread_attr_init(&mut attr) != 0 {\n+            assert!(false);\n+        }\n+\n+        if pthread_create(&mut thread, &attr, mutate_tls, 0 as *mut c_void) != 0 {\n+            assert!(false);\n+        }\n+\n+        let mut res = 0 as *mut c_void;\n+        pthread_join(thread, &mut res);\n+\n+        // TLS of main thread must not have been changed by the other thread.\n+        assert_eq!(TLS, 42);\n+\n+        puts(\"TLS works!\\n\\0\" as *const str as *const u8);\n+    }\n+}\n+\n+// Copied ui/issues/issue-61696.rs\n+\n+pub enum Infallible {}\n+\n+// The check that the `bool` field of `V1` is encoding a \"niche variant\"\n+// (i.e. not `V1`, so `V3` or `V4`) used to be mathematically incorrect,\n+// causing valid `V1` values to be interpreted as other variants.\n+pub enum E1 {\n+    V1 { f: bool },\n+    V2 { f: Infallible },\n+    V3,\n+    V4,\n+}\n+\n+// Computing the discriminant used to be done using the niche type (here `u8`,\n+// from the `bool` field of `V1`), overflowing for variants with large enough\n+// indices (`V3` and `V4`), causing them to be interpreted as other variants.\n+pub enum E2<X> {\n+    V1 { f: bool },\n+\n+    /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n+    _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n+    _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n+    _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n+    _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n+    _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n+    _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n+    _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n+    _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n+    _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n+    _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n+    _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n+    _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n+    _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n+    _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n+    _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n+    _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n+    _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n+    _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n+    _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n+    _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n+    _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n+    _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n+    _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n+    _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n+    _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n+    _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n+    _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n+    _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n+    _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n+    _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n+    _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+\n+    V3,\n+    V4,\n+}\n+\n+fn check_niche_behavior () {\n+    if let E1::V2 { .. } = (E1::V1 { f: true }) {\n+        intrinsics::abort();\n+    }\n+\n+    if let E2::V1 { .. } = E2::V3::<Infallible> {\n+        intrinsics::abort();\n+    }\n+}"}, {"sha": "2e2b0052dee8b7ff84a9c1381f7d5e566671d39f", "filename": "compiler/rustc_codegen_gcc/example/mod_bench.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,37 @@\n+#![feature(start, box_syntax, core_intrinsics, lang_items)]\n+#![no_std]\n+\n+#[link(name = \"c\")]\n+extern {}\n+\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    unsafe {\n+        core::intrinsics::abort();\n+    }\n+}\n+\n+#[lang=\"eh_personality\"]\n+fn eh_personality(){}\n+\n+// Required for rustc_codegen_llvm\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    for i in 2..100_000_000 {\n+        black_box((i + 1) % i);\n+    }\n+\n+    0\n+}\n+\n+#[inline(never)]\n+fn black_box(i: u32) {\n+    if i != 1 {\n+        unsafe { core::intrinsics::abort(); }\n+    }\n+}"}, {"sha": "eba0eb82896004c7168823ec909530aa7967aee4", "filename": "compiler/rustc_codegen_gcc/example/std_example.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,278 @@\n+#![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n+\n+use std::arch::x86_64::*;\n+use std::io::Write;\n+use std::ops::Generator;\n+\n+extern {\n+    pub fn printf(format: *const i8, ...) -> i32;\n+}\n+\n+fn main() {\n+    let mutex = std::sync::Mutex::new(());\n+    let _guard = mutex.lock().unwrap();\n+\n+    let _ = ::std::iter::repeat('a' as u8).take(10).collect::<Vec<_>>();\n+    let stderr = ::std::io::stderr();\n+    let mut stderr = stderr.lock();\n+\n+    std::thread::spawn(move || {\n+        println!(\"Hello from another thread!\");\n+    });\n+\n+    writeln!(stderr, \"some {} text\", \"<unknown>\").unwrap();\n+\n+    let _ = std::process::Command::new(\"true\").env(\"c\", \"d\").spawn();\n+\n+    println!(\"cargo:rustc-link-lib=z\");\n+\n+    static ONCE: std::sync::Once = std::sync::Once::new();\n+    ONCE.call_once(|| {});\n+\n+    let _eq = LoopState::Continue(()) == LoopState::Break(());\n+\n+    // Make sure ByValPair values with differently sized components are correctly passed\n+    map(None::<(u8, Box<Instruction>)>);\n+\n+    println!(\"{}\", 2.3f32.exp());\n+    println!(\"{}\", 2.3f32.exp2());\n+    println!(\"{}\", 2.3f32.abs());\n+    println!(\"{}\", 2.3f32.sqrt());\n+    println!(\"{}\", 2.3f32.floor());\n+    println!(\"{}\", 2.3f32.ceil());\n+    println!(\"{}\", 2.3f32.min(1.0));\n+    println!(\"{}\", 2.3f32.max(1.0));\n+    println!(\"{}\", 2.3f32.powi(2));\n+    println!(\"{}\", 2.3f32.log2());\n+    assert_eq!(2.3f32.copysign(-1.0), -2.3f32);\n+    println!(\"{}\", 2.3f32.powf(2.0));\n+\n+    assert_eq!(-128i8, (-128i8).saturating_sub(1));\n+    assert_eq!(127i8, 127i8.saturating_sub(-128));\n+    assert_eq!(-128i8, (-128i8).saturating_add(-128));\n+    assert_eq!(127i8, 127i8.saturating_add(1));\n+\n+    assert_eq!(-32768i16, (-32768i16).saturating_add(-32768));\n+    assert_eq!(32767i16, 32767i16.saturating_add(1));\n+\n+    assert_eq!(0b0000000000000000000000000010000010000000000000000000000000000000_0000000000100000000000000000000000001000000000000100000000000000u128.leading_zeros(), 26);\n+    assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n+\n+    let _d = 0i128.checked_div(2i128);\n+    let _d = 0u128.checked_div(2u128);\n+    assert_eq!(1u128 + 2, 3);\n+\n+    assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 >> 64, 0xFEDCBA98765432u128);\n+    assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64, 0xFEDCBA98765432i128);\n+\n+    let tmp = 353985398u128;\n+    assert_eq!(tmp * 932490u128, 330087843781020u128);\n+\n+    let tmp = -0x1234_5678_9ABC_DEF0i64;\n+    assert_eq!(tmp as i128, -0x1234_5678_9ABC_DEF0i128);\n+\n+    // Check that all u/i128 <-> float casts work correctly.\n+    let houndred_u128 = 100u128;\n+    let houndred_i128 = 100i128;\n+    let houndred_f32 = 100.0f32;\n+    let houndred_f64 = 100.0f64;\n+    assert_eq!(houndred_u128 as f32, 100.0);\n+    assert_eq!(houndred_u128 as f64, 100.0);\n+    assert_eq!(houndred_f32 as u128, 100);\n+    assert_eq!(houndred_f64 as u128, 100);\n+    assert_eq!(houndred_i128 as f32, 100.0);\n+    assert_eq!(houndred_i128 as f64, 100.0);\n+    assert_eq!(houndred_f32 as i128, 100);\n+    assert_eq!(houndred_f64 as i128, 100);\n+\n+    let _a = 1u32 << 2u8;\n+\n+    let empty: [i32; 0] = [];\n+    assert!(empty.is_sorted());\n+\n+    println!(\"{:?}\", std::intrinsics::caller_location());\n+\n+    /*unsafe {\n+        test_simd();\n+    }*/\n+\n+    Box::pin(move |mut _task_context| {\n+        yield ();\n+    }).as_mut().resume(0);\n+\n+    println!(\"End\");\n+}\n+\n+/*#[target_feature(enable = \"sse2\")]\n+unsafe fn test_simd() {\n+    let x = _mm_setzero_si128();\n+    let y = _mm_set1_epi16(7);\n+    let or = _mm_or_si128(x, y);\n+    let cmp_eq = _mm_cmpeq_epi8(y, y);\n+    let cmp_lt = _mm_cmplt_epi8(y, y);\n+\n+    /*assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n+\n+    test_mm_slli_si128();\n+    test_mm_movemask_epi8();\n+    test_mm256_movemask_epi8();\n+    test_mm_add_epi8();\n+    test_mm_add_pd();\n+    test_mm_cvtepi8_epi16();\n+    test_mm_cvtsi128_si64();\n+\n+    // FIXME(#666) implement `#[rustc_arg_required_const(..)]` support\n+    //test_mm_extract_epi8();\n+\n+    let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n+    assert_eq!(mask1, 1);*/\n+}*/\n+\n+/*#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_slli_si128() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 1);\n+    let e = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 15);\n+    let e = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 16);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -1);\n+    assert_eq_m128i(_mm_set1_epi8(0), r);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -0x80000000);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_movemask_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8, 0b01,\n+        0b0101, 0b1111_0000u8 as i8, 0, 0,\n+        0, 0, 0b1111_0000u8 as i8, 0b0101,\n+        0b01, 0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8,\n+    );\n+    let r = _mm_movemask_epi8(a);\n+    assert_eq!(r, 0b10100100_00100101);\n+}\n+\n+#[target_feature(enable = \"avx2\")]\n+unsafe fn test_mm256_movemask_epi8() {\n+    let a = _mm256_set1_epi8(-1);\n+    let r = _mm256_movemask_epi8(a);\n+    let e = -1;\n+    assert_eq!(r, e);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_epi8() {\n+    let a = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    #[rustfmt::skip]\n+    let b = _mm_setr_epi8(\n+        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+    );\n+    let r = _mm_add_epi8(a, b);\n+    #[rustfmt::skip]\n+    let e = _mm_setr_epi8(\n+        16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,\n+    );\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_pd() {\n+    let a = _mm_setr_pd(1.0, 2.0);\n+    let b = _mm_setr_pd(5.0, 10.0);\n+    let r = _mm_add_pd(a, b);\n+    assert_eq_m128d(r, _mm_setr_pd(6.0, 12.0));\n+}\n+\n+fn assert_eq_m128i(x: std::arch::x86_64::__m128i, y: std::arch::x86_64::__m128i) {\n+    unsafe {\n+        assert_eq!(std::mem::transmute::<_, [u8; 16]>(x), std::mem::transmute::<_, [u8; 16]>(y));\n+    }\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n+    if _mm_movemask_pd(_mm_cmpeq_pd(a, b)) != 0b11 {\n+        panic!(\"{:?} != {:?}\", a, b);\n+    }\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_cvtsi128_si64() {\n+    let r = _mm_cvtsi128_si64(std::mem::transmute::<[i64; 2], _>([5, 0]));\n+    assert_eq!(r, 5);\n+}\n+\n+#[target_feature(enable = \"sse4.1\")]\n+unsafe fn test_mm_cvtepi8_epi16() {\n+    let a = _mm_set1_epi8(10);\n+    let r = _mm_cvtepi8_epi16(a);\n+    let e = _mm_set1_epi16(10);\n+    assert_eq_m128i(r, e);\n+    let a = _mm_set1_epi8(-10);\n+    let r = _mm_cvtepi8_epi16(a);\n+    let e = _mm_set1_epi16(-10);\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[target_feature(enable = \"sse4.1\")]\n+unsafe fn test_mm_extract_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        -1, 1, 2, 3, 4, 5, 6, 7,\n+        8, 9, 10, 11, 12, 13, 14, 15\n+    );\n+    let r1 = _mm_extract_epi8(a, 0);\n+    let r2 = _mm_extract_epi8(a, 19);\n+    assert_eq!(r1, 0xFF);\n+    assert_eq!(r2, 3);\n+}*/\n+\n+#[derive(PartialEq)]\n+enum LoopState {\n+    Continue(()),\n+    Break(())\n+}\n+\n+pub enum Instruction {\n+    Increment,\n+    Loop,\n+}\n+\n+fn map(a: Option<(u8, Box<Instruction>)>) -> Option<Box<Instruction>> {\n+    match a {\n+        None => None,\n+        Some((_, instr)) => Some(instr),\n+    }\n+}"}, {"sha": "2cb84786f56d02e55dc36d9c5515e5bf499c2309", "filename": "compiler/rustc_codegen_gcc/example/subslice-patterns-const-eval.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fsubslice-patterns-const-eval.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,97 @@\n+// Based on https://github.com/rust-lang/rust/blob/c5840f9d252c2f5cc16698dbf385a29c5de3ca07/src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs\n+\n+// Test that array subslice patterns are correctly handled in const evaluation.\n+\n+// run-pass\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct N(u8);\n+\n+#[derive(PartialEq, Debug, Clone)]\n+struct Z;\n+\n+macro_rules! n {\n+    ($($e:expr),* $(,)?) => {\n+        [$(N($e)),*]\n+    }\n+}\n+\n+// This macro has an unused variable so that it can be repeated base on the\n+// number of times a repeated variable (`$e` in `z`) occurs.\n+macro_rules! zed {\n+    ($e:expr) => { Z }\n+}\n+\n+macro_rules! z {\n+    ($($e:expr),* $(,)?) => {\n+        [$(zed!($e)),*]\n+    }\n+}\n+\n+// Compare constant evaluation and runtime evaluation of a given expression.\n+macro_rules! compare_evaluation {\n+    ($e:expr, $t:ty $(,)?) => {{\n+        const CONST_EVAL: $t = $e;\n+        const fn const_eval() -> $t { $e }\n+        static CONST_EVAL2: $t = const_eval();\n+        let runtime_eval = $e;\n+        assert_eq!(CONST_EVAL, runtime_eval);\n+        assert_eq!(CONST_EVAL2, runtime_eval);\n+    }}\n+}\n+\n+// Repeat `$test`, substituting the given macro variables with the given\n+// identifiers.\n+//\n+// For example:\n+//\n+// repeat! {\n+//     ($name); X; Y:\n+//     struct $name;\n+// }\n+//\n+// Expands to:\n+//\n+// struct X; struct Y;\n+//\n+// This is used to repeat the tests using both the `N` and `Z`\n+// types.\n+macro_rules! repeat {\n+    (($($dollar:tt $placeholder:ident)*); $($($values:ident),+);*: $($test:tt)*) => {\n+        macro_rules! single {\n+            ($($dollar $placeholder:ident),*) => { $($test)* }\n+        }\n+        $(single!($($values),+);)*\n+    }\n+}\n+\n+fn main() {\n+    repeat! {\n+        ($arr $Ty); n, N; z, Z:\n+        compare_evaluation!({ let [_, x @ .., _] = $arr!(1, 2, 3, 4); x }, [$Ty; 2]);\n+        compare_evaluation!({ let [_, ref x @ .., _] = $arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+        compare_evaluation!({ let [_, x @ .., _] = &$arr!(1, 2, 3, 4); x }, &'static [$Ty; 2]);\n+\n+        compare_evaluation!({ let [_, _, x @ .., _, _] = $arr!(1, 2, 3, 4); x }, [$Ty; 0]);\n+        compare_evaluation!(\n+            { let [_, _, ref x @ .., _, _] = $arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+        compare_evaluation!(\n+            { let [_, _, x @ .., _, _] = &$arr!(1, 2, 3, 4); x },\n+            &'static [$Ty; 0],\n+        );\n+\n+        compare_evaluation!({ let [_, .., x] = $arr!(1, 2, 3, 4); x }, $Ty);\n+        compare_evaluation!({ let [_, .., ref x] = $arr!(1, 2, 3, 4); x }, &'static $Ty);\n+        compare_evaluation!({ let [_, _y @ .., x] = &$arr!(1, 2, 3, 4); x }, &'static $Ty);\n+    }\n+\n+    compare_evaluation!({ let [_, .., N(x)] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [_, .., N(ref x)] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [_, .., N(x)] = &n!(1, 2, 3, 4); x }, &'static u8);\n+\n+    compare_evaluation!({ let [N(x), .., _] = n!(1, 2, 3, 4); x }, u8);\n+    compare_evaluation!({ let [N(ref x), .., _] = n!(1, 2, 3, 4); x }, &'static u8);\n+    compare_evaluation!({ let [N(x), .., _] = &n!(1, 2, 3, 4); x }, &'static u8);\n+}"}, {"sha": "93bab17e46b27c4dec994bd9346507db8f708dde", "filename": "compiler/rustc_codegen_gcc/example/track-caller-attribute.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fexample%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Ftrack-caller-attribute.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,40 @@\n+// Based on https://github.com/anp/rust/blob/175631311716d7dfeceec40d2587cde7142ffa8c/src/test/ui/rfc-2091-track-caller/track-caller-attribute.rs\n+\n+// run-pass\n+\n+use std::panic::Location;\n+\n+#[track_caller]\n+fn tracked() -> &'static Location<'static> {\n+    Location::caller()\n+}\n+\n+fn nested_intrinsic() -> &'static Location<'static> {\n+    Location::caller()\n+}\n+\n+fn nested_tracked() -> &'static Location<'static> {\n+    tracked()\n+}\n+\n+fn main() {\n+    let location = Location::caller();\n+    assert_eq!(location.file(), file!());\n+    assert_eq!(location.line(), 21);\n+    assert_eq!(location.column(), 20);\n+\n+    let tracked = tracked();\n+    assert_eq!(tracked.file(), file!());\n+    assert_eq!(tracked.line(), 26);\n+    assert_eq!(tracked.column(), 19);\n+\n+    let nested = nested_intrinsic();\n+    assert_eq!(nested.file(), file!());\n+    assert_eq!(nested.line(), 13);\n+    assert_eq!(nested.column(), 5);\n+\n+    let contained = nested_tracked();\n+    assert_eq!(contained.file(), file!());\n+    assert_eq!(contained.line(), 17);\n+    assert_eq!(contained.column(), 5);\n+}"}, {"sha": "aae62a938b4577e8ad70ee825d9331c3f687ecd7", "filename": "compiler/rustc_codegen_gcc/patches/0022-core-Disable-not-compiling-tests.patch", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,63 @@\n+From f6befc4bb51d84f5f1cf35938a168c953d421350 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 24 Nov 2019 15:10:23 +0100\n+Subject: [PATCH] [core] Disable not compiling tests\n+\n+---\n+ library/core/tests/Cargo.toml         | 8 ++++++++\n+ library/core/tests/num/flt2dec/mod.rs | 1 -\n+ library/core/tests/num/int_macros.rs  | 2 ++\n+ library/core/tests/num/uint_macros.rs | 2 ++\n+ library/core/tests/ptr.rs             | 2 ++\n+ library/core/tests/slice.rs           | 2 ++\n+ 6 files changed, 16 insertions(+), 1 deletion(-)\n+ create mode 100644 library/core/tests/Cargo.toml\n+\n+diff --git a/library/core/tests/Cargo.toml b/library/core/tests/Cargo.toml\n+new file mode 100644\n+index 0000000..46fd999\n+--- /dev/null\n++++ b/library/core/tests/Cargo.toml\n+@@ -0,0 +1,8 @@\n++[package]\n++name = \"core\"\n++version = \"0.0.0\"\n++edition = \"2018\"\n++\n++[lib]\n++name = \"coretests\"\n++path = \"lib.rs\"\n+diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n+index a35897e..f0bf645 100644\n+--- a/library/core/tests/num/flt2dec/mod.rs\n++++ b/library/core/tests/num/flt2dec/mod.rs\n+@@ -13,7 +13,6 @@ mod strategy {\n+     mod dragon;\n+     mod grisu;\n+ }\n+-mod random;\n+ \n+ pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+     match decode(v).1 {\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 6609bc3..241b497 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n+     }\n+ }\n+ \n++/*\n+ #[test]\n+ #[cfg(not(target_arch = \"wasm32\"))]\n+ fn sort_unstable() {\n+@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n+     v.select_nth_unstable(0);\n+     assert!(v == [0xDEADBEEF]);\n+ }\n++*/\n+ \n+ #[test]\n+ #[should_panic(expected = \"index 0 greater than length of slice\")]\n+--\n+2.21.0 (Apple Git-122)"}, {"sha": "ee5ba449fb8e6bb0ee310eea54ac65a01ec8842a", "filename": "compiler/rustc_codegen_gcc/patches/0023-core-Ignore-failing-tests.patch", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,49 @@\n+From dd82e95c9de212524e14fc60155de1ae40156dfc Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sun, 24 Nov 2019 15:34:06 +0100\n+Subject: [PATCH] [core] Ignore failing tests\n+\n+---\n+ library/core/tests/iter.rs       |  4 ++++\n+ library/core/tests/num/bignum.rs | 10 ++++++++++\n+ library/core/tests/num/mod.rs    |  5 +++--\n+ library/core/tests/time.rs       |  1 +\n+ 4 files changed, 18 insertions(+), 2 deletions(-)\n+\n+diff --git a/library/core/tests/array.rs b/library/core/tests/array.rs\n+index 4bc44e9..8e3c7a4 100644\n+--- a/library/core/tests/array.rs\n++++ b/library/core/tests/array.rs\n+@@ -242,6 +242,7 @@ fn iterator_drops() {\n+     assert_eq!(i.get(), 5);\n+ }\n+ \n++/*\n+ // This test does not work on targets without panic=unwind support.\n+ // To work around this problem, test is marked is should_panic, so it will\n+ // be automagically skipped on unsuitable targets, such as\n+@@ -283,6 +284,7 @@ fn array_default_impl_avoids_leaks_on_panic() {\n+     assert_eq!(COUNTER.load(Relaxed), 0);\n+     panic!(\"test succeeded\")\n+ }\n++*/\n+ \n+ #[test]\n+ fn empty_array_is_always_default() {\n+@@ -304,6 +304,7 @@ fn array_map() {\n+     assert_eq!(b, [1, 2, 3]);\n+ }\n+ \n++/*\n+ // See note on above test for why `should_panic` is used.\n+ #[test]\n+ #[should_panic(expected = \"test succeeded\")]\n+@@ -332,6 +333,7 @@ fn array_map_drop_safety() {\n+     assert_eq!(DROPPED.load(Ordering::SeqCst), num_to_create);\n+     panic!(\"test succeeded\")\n+ }\n++*/\n+ \n+ #[test]\n+ fn cell_allows_array_cycle() {\n+-- 2.21.0 (Apple Git-122)"}, {"sha": "503fa29b36269e451959d79f73faa2512c8040d6", "filename": "compiler/rustc_codegen_gcc/prepare.sh", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fprepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fprepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fprepare.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,22 @@\n+#!/bin/bash --verbose\n+set -e\n+\n+source prepare_build.sh\n+\n+cargo install hyperfine || echo \"Skipping hyperfine install\"\n+\n+git clone https://github.com/rust-lang/regex.git || echo \"rust-lang/regex has already been cloned\"\n+pushd regex\n+git checkout -- .\n+git checkout 341f207c1071f7290e3f228c710817c280c8dca1\n+popd\n+\n+git clone https://github.com/ebobby/simple-raytracer || echo \"ebobby/simple-raytracer has already been cloned\"\n+pushd simple-raytracer\n+git checkout -- .\n+git checkout 804a7a21b9e673a482797aa289a18ed480e4d813\n+\n+# build with cg_llvm for perf comparison\n+cargo build\n+mv target/debug/main raytracer_cg_llvm\n+popd"}, {"sha": "ccf535098301511a2dbaea33bf6dede139aea814", "filename": "compiler/rustc_codegen_gcc/prepare_build.sh", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fprepare_build.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,5 @@\n+#!/bin/bash --verbose\n+set -e\n+\n+rustup component add rust-src rustc-dev llvm-tools-preview\n+./build_sysroot/prepare_sysroot_src.sh"}, {"sha": "d311a33f807b7e238422d21f43fdc22e2998c7df", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1 @@\n+nightly-2021-09-28"}, {"sha": "01ce5bb78be0f4ebc32253a55ae17a8527e75fbf", "filename": "compiler/rustc_codegen_gcc/rustup.sh", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustup.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,29 @@\n+#!/bin/bash\n+\n+set -e\n+\n+case $1 in\n+    \"prepare\")\n+        TOOLCHAIN=$(date +%Y-%m-%d)\n+\n+        echo \"=> Installing new nightly\"\n+        rustup toolchain install --profile minimal nightly-${TOOLCHAIN} # Sanity check to see if the nightly exists\n+        echo nightly-${TOOLCHAIN} > rust-toolchain\n+\n+        echo \"=> Uninstalling all old nighlies\"\n+        for nightly in $(rustup toolchain list | grep nightly | grep -v $TOOLCHAIN | grep -v nightly-x86_64); do\n+            rustup toolchain uninstall $nightly\n+        done\n+\n+        ./clean_all.sh\n+        ./prepare.sh\n+        ;;\n+    \"commit\")\n+        git add rust-toolchain\n+        git commit -m \"Rustup to $(rustc -V)\"\n+        ;;\n+    *)\n+        echo \"Unknown command '$1'\"\n+        echo \"Usage: ./rustup.sh prepare|commit\"\n+        ;;\n+esac"}, {"sha": "ce428c589a478f1f6059d3a4845c21b5e407db82", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,160 @@\n+use gccjit::{ToRValue, Type};\n+use rustc_codegen_ssa::traits::{AbiBuilderMethods, BaseTypeMethods};\n+use rustc_middle::bug;\n+use rustc_middle::ty::Ty;\n+use rustc_target::abi::call::{CastTarget, FnAbi, PassMode, Reg, RegKind};\n+\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+use crate::intrinsic::ArgAbiExt;\n+use crate::type_of::LayoutGccExt;\n+\n+impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn get_param(&self, index: usize) -> Self::Value {\n+        self.cx.current_func.borrow().expect(\"current func\")\n+            .get_param(index as i32)\n+            .to_rvalue()\n+    }\n+}\n+\n+impl GccType for CastTarget {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, '_>) -> Type<'gcc> {\n+        let rest_gcc_unit = self.rest.unit.gcc_type(cx);\n+        let (rest_count, rem_bytes) =\n+            if self.rest.unit.size.bytes() == 0 {\n+                (0, 0)\n+            }\n+            else {\n+                (self.rest.total.bytes() / self.rest.unit.size.bytes(), self.rest.total.bytes() % self.rest.unit.size.bytes())\n+            };\n+\n+        if self.prefix.iter().all(|x| x.is_none()) {\n+            // Simplify to a single unit when there is no prefix and size <= unit size\n+            if self.rest.total <= self.rest.unit.size {\n+                return rest_gcc_unit;\n+            }\n+\n+            // Simplify to array when all chunks are the same size and type\n+            if rem_bytes == 0 {\n+                return cx.type_array(rest_gcc_unit, rest_count);\n+            }\n+        }\n+\n+        // Create list of fields in the main structure\n+        let mut args: Vec<_> = self\n+            .prefix\n+            .iter()\n+            .flat_map(|option_kind| {\n+                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk_size }.gcc_type(cx))\n+            })\n+            .chain((0..rest_count).map(|_| rest_gcc_unit))\n+            .collect();\n+\n+        // Append final integer\n+        if rem_bytes != 0 {\n+            // Only integers can be really split further.\n+            assert_eq!(self.rest.unit.kind, RegKind::Integer);\n+            args.push(cx.type_ix(rem_bytes * 8));\n+        }\n+\n+        cx.type_struct(&args, false)\n+    }\n+}\n+\n+pub trait GccType {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, '_>) -> Type<'gcc>;\n+}\n+\n+impl GccType for Reg {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, '_>) -> Type<'gcc> {\n+        match self.kind {\n+            RegKind::Integer => cx.type_ix(self.size.bits()),\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => cx.type_f32(),\n+                    64 => cx.type_f64(),\n+                    _ => bug!(\"unsupported float: {:?}\", self),\n+                }\n+            },\n+            RegKind::Vector => unimplemented!(), //cx.type_vector(cx.type_i8(), self.size.bytes()),\n+        }\n+    }\n+}\n+\n+pub trait FnAbiGccExt<'gcc, 'tcx> {\n+    // TODO(antoyo): return a function pointer type instead?\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool);\n+    fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+}\n+\n+impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n+    fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool) {\n+        let args_capacity: usize = self.args.iter().map(|arg|\n+            if arg.pad.is_some() {\n+                1\n+            }\n+            else {\n+                0\n+            } +\n+            if let PassMode::Pair(_, _) = arg.mode {\n+                2\n+            } else {\n+                1\n+            }\n+        ).sum();\n+        let mut argument_tys = Vec::with_capacity(\n+            if let PassMode::Indirect { .. } = self.ret.mode {\n+                1\n+            }\n+            else {\n+                0\n+            } + args_capacity,\n+        );\n+\n+        let return_ty =\n+            match self.ret.mode {\n+                PassMode::Ignore => cx.type_void(),\n+                PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n+                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Indirect { .. } => {\n+                    argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n+                    cx.type_void()\n+                }\n+            };\n+\n+        for arg in &self.args {\n+            // add padding\n+            if let Some(ty) = arg.pad {\n+                argument_tys.push(ty.gcc_type(cx));\n+            }\n+\n+            let arg_ty = match arg.mode {\n+                PassMode::Ignore => continue,\n+                PassMode::Direct(_) => arg.layout.immediate_gcc_type(cx),\n+                PassMode::Pair(..) => {\n+                    argument_tys.push(arg.layout.scalar_pair_element_gcc_type(cx, 0, true));\n+                    argument_tys.push(arg.layout.scalar_pair_element_gcc_type(cx, 1, true));\n+                    continue;\n+                }\n+                PassMode::Indirect { extra_attrs: Some(_), .. } => {\n+                    unimplemented!();\n+                }\n+                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Indirect { extra_attrs: None, .. } => cx.type_ptr_to(arg.memory_ty(cx)),\n+            };\n+            argument_tys.push(arg_ty);\n+        }\n+\n+        (return_ty, argument_tys, self.c_variadic)\n+    }\n+\n+    fn ptr_to_gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        let (return_type, params, variadic) = self.gcc_type(cx);\n+        let pointer_type = cx.context.new_function_pointer_type(None, return_type, &params, variadic);\n+        pointer_type\n+    }\n+}"}, {"sha": "6378a31202c1b88b1e2d213b5518e28c422b52a8", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,116 @@\n+use gccjit::{FunctionType, ToRValue};\n+use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_middle::bug;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::symbol::sym;\n+\n+use crate::GccContext;\n+\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+    let context = &mods.context;\n+    let usize =\n+        match tcx.sess.target.pointer_width {\n+            16 => context.new_type::<u16>(),\n+            32 => context.new_type::<u32>(),\n+            64 => context.new_type::<u64>(),\n+            tws => bug!(\"Unsupported target word size for int: {}\", tws),\n+        };\n+    let i8 = context.new_type::<i8>();\n+    let i8p = i8.make_pointer();\n+    let void = context.new_type::<()>();\n+\n+    for method in ALLOCATOR_METHODS {\n+        let mut types = Vec::with_capacity(method.inputs.len());\n+        for ty in method.inputs.iter() {\n+            match *ty {\n+                AllocatorTy::Layout => {\n+                    types.push(usize);\n+                    types.push(usize);\n+                }\n+                AllocatorTy::Ptr => types.push(i8p),\n+                AllocatorTy::Usize => types.push(usize),\n+\n+                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+            }\n+        }\n+        let output = match method.output {\n+            AllocatorTy::ResultPtr => Some(i8p),\n+            AllocatorTy::Unit => None,\n+\n+            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                panic!(\"invalid allocator output\")\n+            }\n+        };\n+        let name = format!(\"__rust_{}\", method.name);\n+\n+        let args: Vec<_> = types.iter().enumerate()\n+            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+            .collect();\n+        let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n+\n+        if tcx.sess.target.options.default_hidden_visibility {\n+            // TODO(antoyo): set visibility.\n+        }\n+        if tcx.sess.must_emit_unwind_tables() {\n+            // TODO(antoyo): emit unwind tables.\n+        }\n+\n+        let callee = kind.fn_name(method.name);\n+        let args: Vec<_> = types.iter().enumerate()\n+            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+            .collect();\n+        let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n+        // TODO(antoyo): set visibility.\n+\n+        let block = func.new_block(\"entry\");\n+\n+        let args = args\n+            .iter()\n+            .enumerate()\n+            .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n+            .collect::<Vec<_>>();\n+        let ret = context.new_call(None, callee, &args);\n+        //llvm::LLVMSetTailCall(ret, True);\n+        if output.is_some() {\n+            block.end_with_return(None, ret);\n+        }\n+        else {\n+            block.end_with_void_return(None);\n+        }\n+\n+        // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n+        // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n+    }\n+\n+    let types = [usize, usize];\n+    let name = \"__rust_alloc_error_handler\".to_string();\n+    let args: Vec<_> = types.iter().enumerate()\n+        .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+        .collect();\n+    let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n+\n+    let kind =\n+        if has_alloc_error_handler {\n+            AllocatorKind::Global\n+        }\n+        else {\n+            AllocatorKind::Default\n+        };\n+    let callee = kind.fn_name(sym::oom);\n+    let args: Vec<_> = types.iter().enumerate()\n+        .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+        .collect();\n+    let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n+    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+\n+    let block = func.new_block(\"entry\");\n+\n+    let args = args\n+        .iter()\n+        .enumerate()\n+        .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n+        .collect::<Vec<_>>();\n+    let _ret = context.new_call(None, callee, &args);\n+    //llvm::LLVMSetTailCall(ret, True);\n+    block.end_with_void_return(None);\n+}"}, {"sha": "d749d763402b810ebd35508cbb5ec1b33ea2dfba", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,218 @@\n+use std::fs::File;\n+use std::path::{Path, PathBuf};\n+\n+use rustc_session::Session;\n+use rustc_codegen_ssa::back::archive::ArchiveBuilder;\n+\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n+use rustc_middle::middle::cstore::DllImport;\n+\n+\n+struct ArchiveConfig<'a> {\n+    sess: &'a Session,\n+    dst: PathBuf,\n+    use_native_ar: bool,\n+    use_gnu_style_archive: bool,\n+}\n+\n+#[derive(Debug)]\n+enum ArchiveEntry {\n+    FromArchive {\n+        archive_index: usize,\n+        entry_index: usize,\n+    },\n+    File(PathBuf),\n+}\n+\n+pub struct ArArchiveBuilder<'a> {\n+    config: ArchiveConfig<'a>,\n+    src_archives: Vec<(PathBuf, ar::Archive<File>)>,\n+    // Don't use `HashMap` here, as the order is important. `rust.metadata.bin` must always be at\n+    // the end of an archive for linkers to not get confused.\n+    entries: Vec<(String, ArchiveEntry)>,\n+}\n+\n+impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n+    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n+        let config = ArchiveConfig {\n+            sess,\n+            dst: output.to_path_buf(),\n+            use_native_ar: false,\n+            // FIXME test for linux and System V derivatives instead\n+            use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n+        };\n+\n+        let (src_archives, entries) = if let Some(input) = input {\n+            let mut archive = ar::Archive::new(File::open(input).unwrap());\n+            let mut entries = Vec::new();\n+\n+            let mut i = 0;\n+            while let Some(entry) = archive.next_entry() {\n+                let entry = entry.unwrap();\n+                entries.push((\n+                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n+                    ArchiveEntry::FromArchive {\n+                        archive_index: 0,\n+                        entry_index: i,\n+                    },\n+                ));\n+                i += 1;\n+            }\n+\n+            (vec![(input.to_owned(), archive)], entries)\n+        } else {\n+            (vec![], Vec::new())\n+        };\n+\n+        ArArchiveBuilder {\n+            config,\n+            src_archives,\n+            entries,\n+        }\n+    }\n+\n+    fn src_files(&mut self) -> Vec<String> {\n+        self.entries.iter().map(|(name, _)| name.clone()).collect()\n+    }\n+\n+    fn remove_file(&mut self, name: &str) {\n+        let index = self\n+            .entries\n+            .iter()\n+            .position(|(entry_name, _)| entry_name == name)\n+            .expect(\"Tried to remove file not existing in src archive\");\n+        self.entries.remove(index);\n+    }\n+\n+    fn add_file(&mut self, file: &Path) {\n+        self.entries.push((\n+            file.file_name().unwrap().to_str().unwrap().to_string(),\n+            ArchiveEntry::File(file.to_owned()),\n+        ));\n+    }\n+\n+    fn add_archive<F>(&mut self, archive_path: &Path, mut skip: F) -> std::io::Result<()>\n+    where\n+        F: FnMut(&str) -> bool + 'static,\n+    {\n+        let mut archive = ar::Archive::new(std::fs::File::open(&archive_path)?);\n+        let archive_index = self.src_archives.len();\n+\n+        let mut i = 0;\n+        while let Some(entry) = archive.next_entry() {\n+            let entry = entry?;\n+            let file_name = String::from_utf8(entry.header().identifier().to_vec())\n+                .map_err(|err| std::io::Error::new(std::io::ErrorKind::InvalidData, err))?;\n+            if !skip(&file_name) {\n+                self.entries\n+                    .push((file_name, ArchiveEntry::FromArchive { archive_index, entry_index: i }));\n+            }\n+            i += 1;\n+        }\n+\n+        self.src_archives.push((archive_path.to_owned(), archive));\n+        Ok(())\n+    }\n+\n+    fn update_symbols(&mut self) {\n+    }\n+\n+    fn build(mut self) {\n+        use std::process::Command;\n+\n+        fn add_file_using_ar(archive: &Path, file: &Path) {\n+            Command::new(\"ar\")\n+                .arg(\"r\") // add or replace file\n+                .arg(\"-c\") // silence created file message\n+                .arg(archive)\n+                .arg(&file)\n+                .status()\n+                .unwrap();\n+        }\n+\n+        enum BuilderKind<'a> {\n+            Bsd(ar::Builder<File>),\n+            Gnu(ar::GnuBuilder<File>),\n+            NativeAr(&'a Path),\n+        }\n+\n+        let mut builder = if self.config.use_native_ar {\n+            BuilderKind::NativeAr(&self.config.dst)\n+        } else if self.config.use_gnu_style_archive {\n+            BuilderKind::Gnu(ar::GnuBuilder::new(\n+                File::create(&self.config.dst).unwrap(),\n+                self.entries\n+                    .iter()\n+                    .map(|(name, _)| name.as_bytes().to_vec())\n+                    .collect(),\n+            ))\n+        } else {\n+            BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n+        };\n+\n+        // Add all files\n+        for (entry_name, entry) in self.entries.into_iter() {\n+            match entry {\n+                ArchiveEntry::FromArchive {\n+                    archive_index,\n+                    entry_index,\n+                } => {\n+                    let (ref src_archive_path, ref mut src_archive) =\n+                        self.src_archives[archive_index];\n+                    let entry = src_archive.jump_to_entry(entry_index).unwrap();\n+                    let header = entry.header().clone();\n+\n+                    match builder {\n+                        BuilderKind::Bsd(ref mut builder) => {\n+                            builder.append(&header, entry).unwrap()\n+                        }\n+                        BuilderKind::Gnu(ref mut builder) => {\n+                            builder.append(&header, entry).unwrap()\n+                        }\n+                        BuilderKind::NativeAr(archive_file) => {\n+                            Command::new(\"ar\")\n+                                .arg(\"x\")\n+                                .arg(src_archive_path)\n+                                .arg(&entry_name)\n+                                .status()\n+                                .unwrap();\n+                            add_file_using_ar(archive_file, Path::new(&entry_name));\n+                            std::fs::remove_file(entry_name).unwrap();\n+                        }\n+                    }\n+                }\n+                ArchiveEntry::File(file) =>\n+                    match builder {\n+                        BuilderKind::Bsd(ref mut builder) => {\n+                            builder\n+                                .append_file(entry_name.as_bytes(), &mut File::open(file).expect(\"file for bsd builder\"))\n+                                .unwrap()\n+                        },\n+                        BuilderKind::Gnu(ref mut builder) => {\n+                            builder\n+                                .append_file(entry_name.as_bytes(), &mut File::open(&file).expect(&format!(\"file {:?} for gnu builder\", file)))\n+                                .unwrap()\n+                        },\n+                        BuilderKind::NativeAr(archive_file) => add_file_using_ar(archive_file, &file),\n+                    },\n+            }\n+        }\n+\n+        // Finalize archive\n+        std::mem::drop(builder);\n+\n+        // Run ranlib to be able to link the archive\n+        let status = std::process::Command::new(\"ranlib\")\n+            .arg(self.config.dst)\n+            .status()\n+            .expect(\"Couldn't run ranlib\");\n+\n+        if !status.success() {\n+            self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+        }\n+    }\n+\n+    fn inject_dll_import_lib(&mut self, _lib_name: &str, _dll_imports: &[DllImport], _tmpdir: &MaybeTempDir) {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "3b77097e9ad00230b058ab0ef63762cb9eabbc96", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "added", "additions": 785, "deletions": 0, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,785 @@\n+use gccjit::{LValue, RValue, ToRValue, Type};\n+use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_codegen_ssa::mir::operand::OperandValue;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n+\n+use rustc_hir::LlvmInlineAsmInner;\n+use rustc_middle::{bug, ty::Instance};\n+use rustc_span::{Span, Symbol};\n+use rustc_target::asm::*;\n+\n+use std::borrow::Cow;\n+\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+\n+// Rust asm! and GCC Extended Asm semantics differ substantially.\n+//\n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+//    both \"in\" and \"out\" (`inout(reg)`).\n+//\n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    cannot interleave.\n+//\n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+//    because the asm template refers to operands by index.\n+//\n+//    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n+//\n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+//    a variable (`_`),  and such \"clobbers\" do have index.\n+//\n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n+//    as a workaround. These variables need to be declared and initialized *before* \n+//    the Extended Asm block but *after* normal local variables \n+//    (see comment in `codegen_inline_asm` for explanation).\n+//\n+// With that in mind, let's see how we translate Rust syntax to GCC \n+// (from now on, `CC` stands for \"constraint code\"):\n+//\n+// * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n+// * `inout(reg_class) var` -> translated to output operand: `\"+CC\"(var)`\n+// * `in(reg_class) var`    -> translated to input operand: `\"CC\"(var)`\n+//\n+// * `out(reg_class) _` -> translated to one `=r(tmp)`, where \"tmp\" is a temporary unused variable\n+//\n+// * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n+//\n+// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+//                              output: `\"=CC\"(in_var)`\n+//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                                       of the corresponding output operand\n+//\n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+//                                      where \"tmp\" is a temporary unused variable\n+//\n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n+//                                              with `\"r\"(var)` constraint, \n+//                                              and one register variable assigned to the desired register.\n+// \n+\n+const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n+const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n+\n+\n+struct AsmOutOperand<'a, 'tcx, 'gcc> {\n+    rust_idx: usize,\n+    constraint: &'a str,\n+    late: bool,\n+    readwrite: bool,\n+\n+    tmp_var: LValue<'gcc>,\n+    out_place: Option<PlaceRef<'tcx, RValue<'gcc>>>\n+}\n+\n+struct AsmInOperand<'a, 'tcx> {\n+    rust_idx: usize,\n+    constraint: Cow<'a, str>,\n+    val: RValue<'tcx>\n+}\n+\n+impl AsmOutOperand<'_, '_, '_> {\n+    fn to_constraint(&self) -> String {\n+        let mut res = String::with_capacity(self.constraint.len() + self.late as usize + 1);\n+\n+        let sign = if self.readwrite { '+' } else { '=' };\n+        res.push(sign);\n+        if !self.late {\n+            res.push('&');\n+        }\n+\n+        res.push_str(&self.constraint);\n+        res\n+    }\n+}\n+\n+enum ConstraintOrRegister {\n+    Constraint(&'static str),\n+    Register(&'static str)\n+}\n+\n+\n+impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, _inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n+        self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n+            .help(\"consider using the `asm!` macro instead\")\n+            .emit();\n+\n+        // We return `true` even if we've failed to generate the asm\n+        // because we want to suppress the \"malformed inline assembly\" error\n+        // generated by the frontend.\n+        true\n+    }\n+\n+    fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, _span: &[Span]) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+        let is_x86 = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64);\n+        let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n+        let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n+\n+        // GCC index of an output operand equals its position in the array \n+        let mut outputs = vec![];\n+\n+        // GCC index of an input operand equals its position in the array\n+        // added to `outputs.len()`\n+        let mut inputs = vec![];\n+\n+        // Clobbers collected from `out(\"explicit register\") _` and `inout(\"expl_reg\") var => _`\n+        let mut clobbers = vec![];\n+\n+        // We're trying to preallocate space for the template\n+        let mut constants_len = 0;\n+\n+        // There are rules we must adhere to if we want GCC to do the right thing:\n+        // \n+        // * Every local variable that the asm block uses as an output must be declared *before*\n+        //   the asm block. \n+        // * There must be no instructions whatsoever between the register variables and the asm.\n+        //\n+        // Therefore, the backend must generate the instructions strictly in this order:\n+        //\n+        // 1. Output variables.\n+        // 2. Register variables.\n+        // 3. The asm block.\n+        //\n+        // We also must make sure that no input operands are emitted before output operands.\n+        //\n+        // This is why we work in passes, first emitting local vars, then local register vars.\n+        // Also, we don't emit any asm operands immediately; we save them to \n+        // the one of the buffers to be emitted later.\n+\n+        // 1. Normal variables (and saving operands to buffers).\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    use ConstraintOrRegister::*;\n+\n+                    let (constraint, ty) = match (reg_to_gcc(reg), place) {\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        // When `reg` is a class and not an explicit register but the out place is not specified,\n+                        // we need to create an unused output variable to assign the output to. This var\n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // doesn't matter.\n+                        (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n+                        (Register(_), Some(_)) => {\n+                            // left for the next pass\n+                            continue\n+                        },\n+                        (Register(reg_name), None) => {\n+                            // `clobber_abi` can add lots of clobbers that are not supported by the target,\n+                            // such as AVX-512 registers, so we just ignore unsupported registers\n+                            let is_target_supported = reg.reg_class().supported_types(asm_arch).iter()\n+                                .any(|&(_, feature)| {\n+                                    if let Some(feature) = feature {\n+                                        self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                    } else {\n+                                        true // Register class is unconditionally supported\n+                                    }\n+                                });\n+\n+                            if is_target_supported && !clobbers.contains(&reg_name) {\n+                                clobbers.push(reg_name);\n+                            }\n+                            continue\n+                        }\n+                    };\n+\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite: false,\n+                        tmp_var,\n+                        out_place: place\n+                    });\n+                }\n+\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        inputs.push(AsmInOperand { \n+                            constraint: Cow::Borrowed(constraint), \n+                            rust_idx, \n+                            val: value.immediate()\n+                        });\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        constraint\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    };\n+\n+                    // Rustc frontend guarantees that input and output types are \"compatible\",\n+                    // so we can just use input var's type for the output variable.\n+                    //\n+                    // This decision is also backed by the fact that LLVM needs in and out \n+                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // I'm not sure if GCC is so picky too, but better safe than sorry.\n+                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+\n+                    // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // \"out and tied in\" vars as described above.\n+                    let readwrite = out_place.is_none();\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite,\n+                        tmp_var, \n+                        out_place,\n+                    });\n+\n+                    if !readwrite {\n+                        let out_gcc_idx = outputs.len() - 1;\n+                        let constraint = Cow::Owned(out_gcc_idx.to_string());\n+\n+                        inputs.push(AsmInOperand {\n+                            constraint, \n+                            rust_idx, \n+                            val: in_value.immediate()\n+                        });\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::Const { ref string } => {\n+                    constants_len += string.len() + att_dialect as usize;\n+                }\n+\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    constants_len += self.tcx.symbol_name(instance).name.len();\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    constants_len += self.tcx.symbol_name(Instance::mono(self.tcx, def_id)).name.len();\n+                }\n+            }\n+        }\n+\n+        // 2. Register variables.\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n+            match *op {\n+                // `out(\"explicit register\") var`\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `in(\"explicit register\") var`\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n+                        reg_var.set_register_name(reg_name);\n+                        self.llbb().add_assignment(None, reg_var, value.immediate());\n+\n+                        inputs.push(AsmInOperand { \n+                            constraint: \"r\".into(), \n+                            rust_idx, \n+                            val: reg_var.to_rvalue()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `inout(\"explicit register\") in_var => out_var`\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = out_place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        // See explanation in the first pass.\n+                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+\n+                        let constraint = Cow::Owned((outputs.len() - 1).to_string());\n+                        inputs.push(AsmInOperand { \n+                            constraint, \n+                            rust_idx,\n+                            val: in_value.immediate()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                InlineAsmOperandRef::Const { .. } \n+                | InlineAsmOperandRef::SymFn { .. } \n+                | InlineAsmOperandRef::SymStatic { .. } => {\n+                    // processed in the previous pass\n+                }\n+            }\n+        }\n+\n+        // 3. Build the template string\n+\n+        let mut template_str = String::with_capacity(estimate_template_length(template, constants_len, att_dialect));\n+        if !intel_dialect {\n+            template_str.push_str(ATT_SYNTAX_INS);\n+        }\n+\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref string) => {\n+                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n+                    let mut iter = string.split('%');\n+                    if let Some(s) = iter.next() {\n+                        template_str.push_str(s);\n+                    }\n+\n+                    for s in iter {\n+                        template_str.push_str(\"%%\");\n+                        template_str.push_str(s);\n+                    }\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    let mut push_to_template = |modifier, gcc_idx| {\n+                        use std::fmt::Write;\n+\n+                        template_str.push('%');\n+                        if let Some(modifier) = modifier {\n+                            template_str.push(modifier);\n+                        }\n+                        write!(template_str, \"{}\", gcc_idx).expect(\"pushing to string failed\");\n+                    };\n+\n+                    match rust_operands[operand_idx] {\n+                        InlineAsmOperandRef::Out { reg, ..  } => {\n+                            let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::In { reg, .. } => {\n+                            let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n+                            let in_gcc_index = inputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            let gcc_index = in_gcc_index + outputs.len();\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n+\n+                            // The input register is tied to the output, so we can just use the index of the output register\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::SymFn { instance } => {\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        InlineAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(@Commeownist): This may not be sufficient for all kinds of statics.\n+                            // Some statics may need the `@plt` suffix, like thread-local vars.\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        InlineAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the template\n+                            if att_dialect {\n+                                template_str.push('$');\n+                            }\n+                            template_str.push_str(string);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if !intel_dialect {\n+            template_str.push_str(INTEL_SYNTAX_INS);\n+        }\n+        \n+        // 4. Generate Extended Asm block\n+\n+        let block = self.llbb();\n+        let extended_asm = block.add_extended_asm(None, &template_str);\n+\n+        for op in &outputs {\n+            extended_asm.add_output_operand(None, &op.to_constraint(), op.tmp_var);\n+        }\n+\n+        for op in &inputs {\n+            extended_asm.add_input_operand(None, &op.constraint, op.val);\n+        }\n+\n+        for clobber in clobbers.iter() {\n+            extended_asm.add_clobber(clobber);\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // on all architectures. For instance, what about FP stack?\n+            extended_asm.add_clobber(\"cc\");\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            extended_asm.add_clobber(\"memory\");\n+        }\n+        if !options.contains(InlineAsmOptions::PURE) {\n+            extended_asm.set_volatile_flag(true);\n+        }\n+        if !options.contains(InlineAsmOptions::NOSTACK) {\n+            // TODO(@Commeownist): figure out how to align stack\n+        }\n+        if options.contains(InlineAsmOptions::NORETURN) {\n+            let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n+            let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n+            self.call(self.type_void(), builtin_unreachable, &[], None);\n+        }\n+\n+        // Write results to outputs. \n+        //\n+        // We need to do this because:\n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //     (especially with current `rustc_backend_ssa` API).\n+        //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n+        //\n+        // Instead, we generate a temporary output variable for each output operand, and then this loop,\n+        // generates `out_place = tmp_var;` assignments if out_place exists.\n+        for op in &outputs {\n+            if let Some(place) = op.out_place {\n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n+            }\n+        }\n+\n+    }\n+}\n+\n+fn estimate_template_length(template: &[InlineAsmTemplatePiece], constants_len: usize, att_dialect: bool) -> usize {\n+    let len: usize = template.iter().map(|piece| {\n+        match *piece {\n+            InlineAsmTemplatePiece::String(ref string) => {\n+                string.len()\n+            }\n+            InlineAsmTemplatePiece::Placeholder { .. } => {\n+                // '%' + 1 char modifier + 1 char index\n+                3\n+            }\n+        }\n+    })\n+    .sum();\n+\n+    // increase it by 5% to account for possible '%' signs that'll be duplicated\n+    // I pulled the number out of blue, but should be fair enough\n+    // as the upper bound\n+    let mut res = (len as f32 * 1.05) as usize + constants_len;\n+\n+    if att_dialect {\n+        res += INTEL_SYNTAX_INS.len() + ATT_SYNTAX_INS.len();\n+    }\n+    res\n+}\n+\n+/// Converts a register class to a GCC constraint code.\n+fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n+    let constraint = match reg {\n+        // For vector registers LLVM wants the register name to match the type size.\n+        InlineAsmRegOrRegClass::Reg(reg) => {\n+            match reg {\n+                InlineAsmReg::X86(_) => {\n+                    // TODO(antoyo): add support for vector register.\n+                    //\n+                    // // For explicit registers, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n+                    return ConstraintOrRegister::Register(match reg.name() {\n+                        // Some of registers' names does not map 1-1 from rust to gcc\n+                        \"st(0)\" => \"st\",\n+\n+                        name => name,\n+                    });\n+                }\n+\n+                _ => unimplemented!(),\n+            }\n+        },\n+        InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => unimplemented!(),\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => unimplemented!(),\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => unimplemented!(),\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => unimplemented!(),\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => unimplemented!(),\n+            InlineAsmRegClass::Bpf(_) => unimplemented!(),\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+            | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+                unreachable!(\"clobber-only\")\n+            },\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+            InlineAsmRegClass::X86(\n+                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n+            ) => unreachable!(\"clobber-only\"),\n+            InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+                bug!(\"GCC backend does not support SPIR-V\")\n+            }\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Err => unreachable!(),\n+        }\n+    };\n+\n+    ConstraintOrRegister::Constraint(constraint)\n+}\n+\n+/// Type to use for outputs that are discarded. It doesn't really matter what\n+/// the type is, as long as it is valid for the constraint code.\n+fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegClass) -> Type<'gcc> {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            unimplemented!()\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => cx.type_i32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => cx.type_f32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => cx.type_f64(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            unimplemented!()\n+        }\n+        InlineAsmRegClass::Bpf(_) => unimplemented!(),\n+        InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => cx.type_i32(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n+        | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n+            unreachable!(\"clobber-only\")\n+        },\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => cx.type_i32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => cx.type_i8(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::mmx_reg) => unimplemented!(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => cx.type_i32(),\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => cx.type_f64(),\n+        InlineAsmRegClass::Err => unreachable!(),\n+    }\n+}\n+\n+impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n+    fn codegen_global_asm(&self, template: &[InlineAsmTemplatePiece], operands: &[GlobalAsmOperandRef], options: InlineAsmOptions, _line_spans: &[Span]) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+\n+        // Default to Intel syntax on x86\n+        let intel_syntax = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64)\n+            && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n+\n+        // Build the template string\n+        let mut template_str = String::new();\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref string) => {\n+                    for line in string.lines() {\n+                        // NOTE: gcc does not allow inline comment, so remove them.\n+                        let line =\n+                            if let Some(index) = line.rfind(\"//\") {\n+                                &line[..index]\n+                            }\n+                            else {\n+                                line\n+                            };\n+                        template_str.push_str(line);\n+                        template_str.push('\\n');\n+                    }\n+                },\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n+                    match operands[operand_idx] {\n+                        GlobalAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the\n+                            // template. Note that we don't need to escape %\n+                            // here unlike normal inline assembly.\n+                            template_str.push_str(string);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let template_str =\n+            if intel_syntax {\n+                format!(\"{}\\n\\t.intel_syntax noprefix\", template_str)\n+            }\n+            else {\n+                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n+            };\n+        // NOTE: seems like gcc will put the asm in the wrong section, so set it to .text manually.\n+        let template_str = format!(\".pushsection .text\\n{}\\n.popsection\", template_str);\n+        self.context.add_top_level_asm(None, &template_str);\n+    }\n+}\n+\n+fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option<char>) -> Option<char> {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => modifier,\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            unimplemented!()\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            unimplemented!()\n+        }\n+        InlineAsmRegClass::Bpf(_) => unimplemented!(),\n+        InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n+        InlineAsmRegClass::Mips(_) => unimplemented!(),\n+        InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n+        InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n+            None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n+            Some('l') => Some('b'),\n+            Some('h') => Some('h'),\n+            Some('x') => Some('w'),\n+            Some('e') => Some('k'),\n+            Some('r') => Some('q'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n+        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        },\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n+        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+        InlineAsmRegClass::Err => unreachable!(),\n+    }\n+}"}, {"sha": "d692799d7642fe1192bf21dda7827abee4d3de74", "filename": "compiler/rustc_codegen_gcc/src/back/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fmod.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1 @@\n+pub mod write;"}, {"sha": "c3e3847823d918a59ddaced2a4da539c5210959b", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,78 @@\n+use std::fs;\n+\n+use gccjit::OutputKind;\n+use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n+use rustc_codegen_ssa::back::write::{CodegenContext, EmitObj, ModuleConfig};\n+use rustc_errors::Handler;\n+use rustc_session::config::OutputType;\n+use rustc_span::fatal_error::FatalError;\n+use rustc_target::spec::SplitDebuginfo;\n+\n+use crate::{GccCodegenBackend, GccContext};\n+\n+pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_handler: &Handler, module: ModuleCodegen<GccContext>, config: &ModuleConfig) -> Result<CompiledModule, FatalError> {\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n+    {\n+        let context = &module.module_llvm.context;\n+\n+        let module_name = module.name.clone();\n+        let module_name = Some(&module_name[..]);\n+\n+        let _bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n+        let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n+\n+        if config.bitcode_needed() {\n+            // TODO(antoyo)\n+        }\n+\n+        if config.emit_ir {\n+            unimplemented!();\n+        }\n+\n+        if config.emit_asm {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n+            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+            context.compile_to_file(OutputKind::Assembler, path.to_str().expect(\"path to str\"));\n+        }\n+\n+        match config.emit_obj {\n+            EmitObj::ObjectCode(_) => {\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+                match &*module.name {\n+                    \"std_example.7rcbfp3g-cgu.15\" => {\n+                        println!(\"Dumping reproducer {}\", module.name);\n+                        let _ = fs::create_dir(\"/tmp/reproducers\");\n+                        // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n+                        // transmuting an rvalue to an lvalue.\n+                        // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n+                        context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n+                        println!(\"Dumped reproducer {}\", module.name);\n+                    },\n+                    _ => (),\n+                }\n+                context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n+            }\n+\n+            EmitObj::Bitcode => {\n+                // TODO(antoyo)\n+            }\n+\n+            EmitObj::None => {}\n+        }\n+    }\n+\n+    Ok(module.into_compiled_module(\n+        config.emit_obj != EmitObj::None,\n+        cgcx.target_can_use_split_dwarf && cgcx.split_debuginfo == SplitDebuginfo::Unpacked,\n+        config.emit_bc,\n+        &cgcx.output_filenames,\n+    ))\n+}\n+\n+pub(crate) fn link(_cgcx: &CodegenContext<GccCodegenBackend>, _diag_handler: &Handler, mut _modules: Vec<ModuleCodegen<GccContext>>) -> Result<ModuleCodegen<GccContext>, FatalError> {\n+    unimplemented!();\n+}"}, {"sha": "9fd043607fc7e25bb9a81c11823b106af686c7db", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,165 @@\n+use std::env;\n+use std::time::Instant;\n+\n+use gccjit::{\n+    Context,\n+    FunctionType,\n+    GlobalKind,\n+};\n+use rustc_middle::dep_graph;\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::middle::exported_symbols;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_middle::mir::mono::Linkage;\n+use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n+use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n+use rustc_codegen_ssa::mono_item::MonoItemExt;\n+use rustc_codegen_ssa::traits::DebugInfoMethods;\n+use rustc_session::config::DebugInfo;\n+use rustc_span::Symbol;\n+\n+use crate::GccContext;\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+\n+pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n+    match linkage {\n+        Linkage::External => GlobalKind::Imported,\n+        Linkage::AvailableExternally => GlobalKind::Imported,\n+        Linkage::LinkOnceAny => unimplemented!(),\n+        Linkage::LinkOnceODR => unimplemented!(),\n+        Linkage::WeakAny => unimplemented!(),\n+        Linkage::WeakODR => unimplemented!(),\n+        Linkage::Appending => unimplemented!(),\n+        Linkage::Internal => GlobalKind::Internal,\n+        Linkage::Private => GlobalKind::Internal,\n+        Linkage::ExternalWeak => GlobalKind::Imported, // TODO(antoyo): should be weak linkage.\n+        Linkage::Common => unimplemented!(),\n+    }\n+}\n+\n+pub fn linkage_to_gcc(linkage: Linkage) -> FunctionType {\n+    match linkage {\n+        Linkage::External => FunctionType::Exported,\n+        Linkage::AvailableExternally => FunctionType::Extern,\n+        Linkage::LinkOnceAny => unimplemented!(),\n+        Linkage::LinkOnceODR => unimplemented!(),\n+        Linkage::WeakAny => FunctionType::Exported, // FIXME(antoyo): should be similar to linkonce.\n+        Linkage::WeakODR => unimplemented!(),\n+        Linkage::Appending => unimplemented!(),\n+        Linkage::Internal => FunctionType::Internal,\n+        Linkage::Private => FunctionType::Internal,\n+        Linkage::ExternalWeak => unimplemented!(),\n+        Linkage::Common => unimplemented!(),\n+    }\n+}\n+\n+pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<GccContext>, u64) {\n+    let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n+    let start_time = Instant::now();\n+\n+    let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n+    let (module, _) = tcx.dep_graph.with_task(dep_node, tcx, cgu_name, module_codegen, dep_graph::hash_result);\n+    let time_to_codegen = start_time.elapsed();\n+    drop(prof_timer);\n+\n+    // We assume that the cost to run GCC on a CGU is proportional to\n+    // the time we needed for codegenning it.\n+    let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n+\n+    fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<GccContext> {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        // Instantiate monomorphizations without filling out definitions yet...\n+        //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n+        let context = Context::default();\n+        // TODO(antoyo): only set on x86 platforms.\n+        context.add_command_line_option(\"-masm=intel\");\n+        for arg in &tcx.sess.opts.cg.llvm_args {\n+            context.add_command_line_option(arg);\n+        }\n+        context.add_command_line_option(\"-fno-semantic-interposition\");\n+        if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n+            context.set_dump_code_on_compile(true);\n+        }\n+        if env::var(\"CG_GCCJIT_DUMP_GIMPLE\").as_deref() == Ok(\"1\") {\n+            context.set_dump_initial_gimple(true);\n+        }\n+        context.set_debug_info(true);\n+        if env::var(\"CG_GCCJIT_DUMP_EVERYTHING\").as_deref() == Ok(\"1\") {\n+            context.set_dump_everything(true);\n+        }\n+        if env::var(\"CG_GCCJIT_KEEP_INTERMEDIATES\").as_deref() == Ok(\"1\") {\n+            context.set_keep_intermediates(true);\n+        }\n+\n+        {\n+            let cx = CodegenCx::new(&context, cgu, tcx);\n+\n+            let mono_items = cgu.items_in_deterministic_order(tcx);\n+            for &(mono_item, (linkage, visibility)) in &mono_items {\n+                mono_item.predefine::<Builder<'_, '_, '_>>(&cx, linkage, visibility);\n+            }\n+\n+            // ... and now that we have everything pre-defined, fill out those definitions.\n+            for &(mono_item, _) in &mono_items {\n+                mono_item.define::<Builder<'_, '_, '_>>(&cx);\n+            }\n+\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx);\n+\n+            // Finalize debuginfo\n+            if cx.sess().opts.debuginfo != DebugInfo::None {\n+                cx.debuginfo_finalize();\n+            }\n+        }\n+\n+        ModuleCodegen {\n+            name: cgu_name.to_string(),\n+            module_llvm: GccContext {\n+                context\n+            },\n+            kind: ModuleKind::Regular,\n+        }\n+    }\n+\n+    (module, cost)\n+}\n+\n+pub fn write_compressed_metadata<'tcx>(tcx: TyCtxt<'tcx>, metadata: &EncodedMetadata, gcc_module: &mut GccContext) {\n+    use snap::write::FrameEncoder;\n+    use std::io::Write;\n+\n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8 characters\n+    //\n+    // https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, see\n+    // https://github.com/llvm/llvm-project/blob/llvmorg-12.0.0/lld/COFF/Writer.cpp#L1190-L1197\n+    let section_name = if tcx.sess.target.is_like_osx { \"__DATA,.rustc\" } else { \".rustc\" };\n+\n+    let context = &gcc_module.context;\n+    let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n+\n+    let name = exported_symbols::metadata_symbol_name(tcx);\n+    let typ = context.new_array_type(None, context.new_type::<u8>(), compressed.len() as i32);\n+    let global = context.new_global(None, GlobalKind::Exported, typ, name);\n+    global.global_set_initializer(&compressed);\n+    global.set_link_section(section_name);\n+\n+    // Also generate a .section directive to force no\n+    // flags, at least for ELF outputs, so that the\n+    // metadata doesn't get loaded into memory.\n+    let directive = format!(\".section {}\", section_name);\n+    context.add_top_level_asm(None, &directive);\n+}"}, {"sha": "ac908418ee4bf6fcf160a070090705e157c5793c", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "added", "additions": 1540, "deletions": 0, "changes": 1540, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,1540 @@\n+use std::borrow::Cow;\n+use std::cell::Cell;\n+use std::convert::TryFrom;\n+use std::ops::Deref;\n+\n+use gccjit::FunctionType;\n+use gccjit::{\n+    BinaryOp,\n+    Block,\n+    ComparisonOp,\n+    Function,\n+    LValue,\n+    RValue,\n+    ToRValue,\n+    Type,\n+    UnaryOp,\n+};\n+use rustc_codegen_ssa::MemFlags;\n+use rustc_codegen_ssa::common::{AtomicOrdering, AtomicRmwBinOp, IntPredicate, RealPredicate, SynchronizationScope};\n+use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::{\n+    BackendTypes,\n+    BaseTypeMethods,\n+    BuilderMethods,\n+    ConstMethods,\n+    DerivedTypeMethods,\n+    LayoutTypeMethods,\n+    HasCodegen,\n+    OverflowOp,\n+    StaticBuilderMethods,\n+};\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n+use rustc_span::Span;\n+use rustc_span::def_id::DefId;\n+use rustc_target::abi::{\n+    self,\n+    call::FnAbi,\n+    Align,\n+    HasDataLayout,\n+    Size,\n+    TargetDataLayout,\n+    WrappingRange,\n+};\n+use rustc_target::spec::{HasTargetSpec, Target};\n+\n+use crate::common::{SignType, TypeReflection, type_is_pointer};\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+// TODO(antoyo)\n+type Funclet = ();\n+\n+// TODO(antoyo): remove this variable.\n+static mut RETURN_VALUE_COUNT: usize = 0;\n+\n+enum ExtremumOperation {\n+    Max,\n+    Min,\n+}\n+\n+trait EnumClone {\n+    fn clone(&self) -> Self;\n+}\n+\n+impl EnumClone for AtomicOrdering {\n+    fn clone(&self) -> Self {\n+        match *self {\n+            AtomicOrdering::NotAtomic => AtomicOrdering::NotAtomic,\n+            AtomicOrdering::Unordered => AtomicOrdering::Unordered,\n+            AtomicOrdering::Monotonic => AtomicOrdering::Monotonic,\n+            AtomicOrdering::Acquire => AtomicOrdering::Acquire,\n+            AtomicOrdering::Release => AtomicOrdering::Release,\n+            AtomicOrdering::AcquireRelease => AtomicOrdering::AcquireRelease,\n+            AtomicOrdering::SequentiallyConsistent => AtomicOrdering::SequentiallyConsistent,\n+        }\n+    }\n+}\n+\n+pub struct Builder<'a: 'gcc, 'gcc, 'tcx> {\n+    pub cx: &'a CodegenCx<'gcc, 'tcx>,\n+    pub block: Option<Block<'gcc>>,\n+    stack_var_count: Cell<usize>,\n+}\n+\n+impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn with_cx(cx: &'a CodegenCx<'gcc, 'tcx>) -> Self {\n+        Builder {\n+            cx,\n+            block: None,\n+            stack_var_count: Cell::new(0),\n+        }\n+    }\n+\n+    fn atomic_extremum(&mut self, operation: ExtremumOperation, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n+        let size = self.cx.int_width(src.get_type()) / 8;\n+\n+        let func = self.current_func();\n+\n+        let load_ordering =\n+            match order {\n+                // TODO(antoyo): does this make sense?\n+                AtomicOrdering::AcquireRelease | AtomicOrdering::Release => AtomicOrdering::Acquire,\n+                _ => order.clone(),\n+            };\n+        let previous_value = self.atomic_load(dst.get_type(), dst, load_ordering.clone(), Size::from_bytes(size));\n+        let previous_var = func.new_local(None, previous_value.get_type(), \"previous_value\");\n+        let return_value = func.new_local(None, previous_value.get_type(), \"return_value\");\n+        self.llbb().add_assignment(None, previous_var, previous_value);\n+        self.llbb().add_assignment(None, return_value, previous_var.to_rvalue());\n+\n+        let while_block = func.new_block(\"while\");\n+        let after_block = func.new_block(\"after_while\");\n+        self.llbb().end_with_jump(None, while_block);\n+\n+        // NOTE: since jumps were added and compare_exchange doesn't expect this, the current blocks in the\n+        // state need to be updated.\n+        self.block = Some(while_block);\n+        *self.cx.current_block.borrow_mut() = Some(while_block);\n+\n+        let comparison_operator =\n+            match operation {\n+                ExtremumOperation::Max => ComparisonOp::LessThan,\n+                ExtremumOperation::Min => ComparisonOp::GreaterThan,\n+            };\n+\n+        let cond1 = self.context.new_comparison(None, comparison_operator, previous_var.to_rvalue(), self.context.new_cast(None, src, previous_value.get_type()));\n+        let compare_exchange = self.compare_exchange(dst, previous_var, src, order, load_ordering, false);\n+        let cond2 = self.cx.context.new_unary_op(None, UnaryOp::LogicalNegate, compare_exchange.get_type(), compare_exchange);\n+        let cond = self.cx.context.new_binary_op(None, BinaryOp::LogicalAnd, self.cx.bool_type, cond1, cond2);\n+\n+        while_block.end_with_conditional(None, cond, while_block, after_block);\n+\n+        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // state need to be updated.\n+        self.block = Some(after_block);\n+        *self.cx.current_block.borrow_mut() = Some(after_block);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    fn compare_exchange(&self, dst: RValue<'gcc>, cmp: LValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n+        let size = self.cx.int_width(src.get_type());\n+        let compare_exchange = self.context.get_builtin_function(&format!(\"__atomic_compare_exchange_{}\", size / 8));\n+        let order = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n+        let failure_order = self.context.new_rvalue_from_int(self.i32_type, failure_order.to_gcc());\n+        let weak = self.context.new_rvalue_from_int(self.bool_type, weak as i32);\n+\n+        let void_ptr_type = self.context.new_type::<*mut ()>();\n+        let volatile_void_ptr_type = void_ptr_type.make_volatile();\n+        let dst = self.context.new_cast(None, dst, volatile_void_ptr_type);\n+        let expected = self.context.new_cast(None, cmp.get_address(None), void_ptr_type);\n+\n+        // NOTE: not sure why, but we have the wrong type here.\n+        let int_type = compare_exchange.get_param(2).to_rvalue().get_type();\n+        let src = self.context.new_cast(None, src, int_type);\n+        self.context.new_call(None, compare_exchange, &[dst, expected, src, weak, order, failure_order])\n+    }\n+\n+    pub fn assign(&self, lvalue: LValue<'gcc>, value: RValue<'gcc>) {\n+        self.llbb().add_assignment(None, lvalue, value);\n+    }\n+\n+    fn check_call<'b>(&mut self, _typ: &str, func: Function<'gcc>, args: &'b [RValue<'gcc>]) -> Cow<'b, [RValue<'gcc>]> {\n+        let mut all_args_match = true;\n+        let mut param_types = vec![];\n+        let param_count = func.get_param_count();\n+        for (index, arg) in args.iter().enumerate().take(param_count) {\n+            let param = func.get_param(index as i32);\n+            let param = param.to_rvalue().get_type();\n+            if param != arg.get_type() {\n+                all_args_match = false;\n+            }\n+            param_types.push(param);\n+        }\n+\n+        if all_args_match {\n+            return Cow::Borrowed(args);\n+        }\n+\n+        let casted_args: Vec<_> = param_types\n+            .into_iter()\n+            .zip(args.iter())\n+            .enumerate()\n+            .map(|(_i, (expected_ty, &actual_val))| {\n+                let actual_ty = actual_val.get_type();\n+                if expected_ty != actual_ty {\n+                    self.bitcast(actual_val, expected_ty)\n+                }\n+                else {\n+                    actual_val\n+                }\n+            })\n+            .collect();\n+\n+        Cow::Owned(casted_args)\n+    }\n+\n+    fn check_ptr_call<'b>(&mut self, _typ: &str, func_ptr: RValue<'gcc>, args: &'b [RValue<'gcc>]) -> Cow<'b, [RValue<'gcc>]> {\n+        let mut all_args_match = true;\n+        let mut param_types = vec![];\n+        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        for (index, arg) in args.iter().enumerate().take(gcc_func.get_param_count()) {\n+            let param = gcc_func.get_param_type(index);\n+            if param != arg.get_type() {\n+                all_args_match = false;\n+            }\n+            param_types.push(param);\n+        }\n+\n+        if all_args_match {\n+            return Cow::Borrowed(args);\n+        }\n+\n+        let casted_args: Vec<_> = param_types\n+            .into_iter()\n+            .zip(args.iter())\n+            .enumerate()\n+            .map(|(_i, (expected_ty, &actual_val))| {\n+                let actual_ty = actual_val.get_type();\n+                if expected_ty != actual_ty {\n+                    self.bitcast(actual_val, expected_ty)\n+                }\n+                else {\n+                    actual_val\n+                }\n+            })\n+            .collect();\n+\n+        Cow::Owned(casted_args)\n+    }\n+\n+    fn check_store(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>) -> RValue<'gcc> {\n+        let dest_ptr_ty = self.cx.val_ty(ptr).make_pointer(); // TODO(antoyo): make sure make_pointer() is okay here.\n+        let stored_ty = self.cx.val_ty(val);\n+        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n+\n+        if dest_ptr_ty == stored_ptr_ty {\n+            ptr\n+        }\n+        else {\n+            self.bitcast(ptr, stored_ptr_ty)\n+        }\n+    }\n+\n+    pub fn current_func(&self) -> Function<'gcc> {\n+        self.block.expect(\"block\").get_function()\n+    }\n+\n+    fn function_call(&mut self, func: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        // TODO(antoyo): remove when the API supports a different type for functions.\n+        let func: Function<'gcc> = self.cx.rvalue_as_function(func);\n+        let args = self.check_call(\"call\", func, args);\n+\n+        // gccjit requires to use the result of functions, even when it's not used.\n+        // That's why we assign the result to a local or call add_eval().\n+        let return_type = func.get_return_type();\n+        let current_block = self.current_block.borrow().expect(\"block\");\n+        let void_type = self.context.new_type::<()>();\n+        let current_func = current_block.get_function();\n+        if return_type != void_type {\n+            unsafe { RETURN_VALUE_COUNT += 1 };\n+            let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+            result.to_rvalue()\n+        }\n+        else {\n+            current_block.add_eval(None, self.cx.context.new_call(None, func, &args));\n+            // Return dummy value when not having return value.\n+            self.context.new_rvalue_from_long(self.isize_type, 0)\n+        }\n+    }\n+\n+    fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+\n+        // gccjit requires to use the result of functions, even when it's not used.\n+        // That's why we assign the result to a local or call add_eval().\n+        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let mut return_type = gcc_func.get_return_type();\n+        let current_block = self.current_block.borrow().expect(\"block\");\n+        let void_type = self.context.new_type::<()>();\n+        let current_func = current_block.get_function();\n+\n+        // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n+        if gcc_func.get_param_count() == 0 && format!(\"{:?}\", func_ptr) == \"__builtin_ia32_pmovmskb128\" {\n+            return_type = self.int_type;\n+        }\n+\n+        if return_type != void_type {\n+            unsafe { RETURN_VALUE_COUNT += 1 };\n+            let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            current_block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            result.to_rvalue()\n+        }\n+        else {\n+            if gcc_func.get_param_count() == 0 {\n+                // FIXME(antoyo): As a temporary workaround for unsupported LLVM intrinsics.\n+                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &[]));\n+            }\n+            else {\n+                current_block.add_eval(None, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            }\n+            // Return dummy value when not having return value.\n+            let result = current_func.new_local(None, self.isize_type, \"dummyValueThatShouldNeverBeUsed\");\n+            current_block.add_assignment(None, result, self.context.new_rvalue_from_long(self.isize_type, 0));\n+            result.to_rvalue()\n+        }\n+    }\n+\n+    pub fn overflow_call(&mut self, func: Function<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        // gccjit requires to use the result of functions, even when it's not used.\n+        // That's why we assign the result to a local.\n+        let return_type = self.context.new_type::<bool>();\n+        let current_block = self.current_block.borrow().expect(\"block\");\n+        let current_func = current_block.get_function();\n+        // TODO(antoyo): return the new_call() directly? Since the overflow function has no side-effects.\n+        unsafe { RETURN_VALUE_COUNT += 1 };\n+        let result = current_func.new_local(None, return_type, &format!(\"returnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+        current_block.add_assignment(None, result, self.cx.context.new_call(None, func, &args));\n+        result.to_rvalue()\n+    }\n+}\n+\n+impl<'gcc, 'tcx> HasCodegen<'tcx> for Builder<'_, 'gcc, 'tcx> {\n+    type CodegenCx = CodegenCx<'gcc, 'tcx>;\n+}\n+\n+impl<'tcx> HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.cx.tcx()\n+    }\n+}\n+\n+impl HasDataLayout for Builder<'_, '_, '_> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self.cx.data_layout()\n+    }\n+}\n+\n+impl<'tcx> LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n+\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        self.cx.handle_layout_err(err, span, ty)\n+    }\n+}\n+\n+impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        self.cx.handle_fn_abi_err(err, span, fn_abi_request)\n+    }\n+}\n+\n+impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+    type Target = CodegenCx<'gcc, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.cx\n+    }\n+}\n+\n+impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n+    type Value = <CodegenCx<'gcc, 'tcx> as BackendTypes>::Value;\n+    type Function = <CodegenCx<'gcc, 'tcx> as BackendTypes>::Function;\n+    type BasicBlock = <CodegenCx<'gcc, 'tcx> as BackendTypes>::BasicBlock;\n+    type Type = <CodegenCx<'gcc, 'tcx> as BackendTypes>::Type;\n+    type Funclet = <CodegenCx<'gcc, 'tcx> as BackendTypes>::Funclet;\n+\n+    type DIScope = <CodegenCx<'gcc, 'tcx> as BackendTypes>::DIScope;\n+    type DILocation = <CodegenCx<'gcc, 'tcx> as BackendTypes>::DILocation;\n+    type DIVariable = <CodegenCx<'gcc, 'tcx> as BackendTypes>::DIVariable;\n+}\n+\n+impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+        let mut bx = Builder::with_cx(cx);\n+        *cx.current_block.borrow_mut() = Some(block);\n+        bx.block = Some(block);\n+        bx\n+    }\n+\n+    fn build_sibling_block(&mut self, name: &str) -> Self {\n+        let block = self.append_sibling_block(name);\n+        Self::build(self.cx, block)\n+    }\n+\n+    fn llbb(&self) -> Block<'gcc> {\n+        self.block.expect(\"block\")\n+    }\n+\n+    fn append_block(cx: &'a CodegenCx<'gcc, 'tcx>, func: RValue<'gcc>, name: &str) -> Block<'gcc> {\n+        let func = cx.rvalue_as_function(func);\n+        func.new_block(name)\n+    }\n+\n+    fn append_sibling_block(&mut self, name: &str) -> Block<'gcc> {\n+        let func = self.current_func();\n+        func.new_block(name)\n+    }\n+\n+    fn ret_void(&mut self) {\n+        self.llbb().end_with_void_return(None)\n+    }\n+\n+    fn ret(&mut self, value: RValue<'gcc>) {\n+        let value =\n+            if self.structs_as_pointer.borrow().contains(&value) {\n+                // NOTE: hack to workaround a limitation of the rustc API: see comment on\n+                // CodegenCx.structs_as_pointer\n+                value.dereference(None).to_rvalue()\n+            }\n+            else {\n+                value\n+            };\n+        self.llbb().end_with_return(None, value);\n+    }\n+\n+    fn br(&mut self, dest: Block<'gcc>) {\n+        self.llbb().end_with_jump(None, dest)\n+    }\n+\n+    fn cond_br(&mut self, cond: RValue<'gcc>, then_block: Block<'gcc>, else_block: Block<'gcc>) {\n+        self.llbb().end_with_conditional(None, cond, then_block, else_block)\n+    }\n+\n+    fn switch(&mut self, value: RValue<'gcc>, default_block: Block<'gcc>, cases: impl ExactSizeIterator<Item = (u128, Block<'gcc>)>) {\n+        let mut gcc_cases = vec![];\n+        let typ = self.val_ty(value);\n+        for (on_val, dest) in cases {\n+            let on_val = self.const_uint_big(typ, on_val);\n+            gcc_cases.push(self.context.new_case(on_val, on_val, dest));\n+        }\n+        self.block.expect(\"block\").end_with_switch(None, value, default_block, &gcc_cases);\n+    }\n+\n+    fn invoke(&mut self, _typ: Type<'gcc>, _func: RValue<'gcc>, _args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let condition = self.context.new_rvalue_from_int(self.bool_type, 0);\n+        self.llbb().end_with_conditional(None, condition, then, catch);\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+\n+        // TODO(antoyo)\n+    }\n+\n+    fn unreachable(&mut self) {\n+        let func = self.context.get_builtin_function(\"__builtin_unreachable\");\n+        let block = self.block.expect(\"block\");\n+        block.add_eval(None, self.context.new_call(None, func, &[]));\n+        let return_type = block.get_function().get_return_type();\n+        let void_type = self.context.new_type::<()>();\n+        if return_type == void_type {\n+            block.end_with_void_return(None)\n+        }\n+        else {\n+            let return_value = self.current_func()\n+                .new_local(None, return_type, \"unreachableReturn\");\n+            block.end_with_return(None, return_value)\n+        }\n+    }\n+\n+    fn add(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): this should not be required.\n+        if format!(\"{:?}\", a.get_type()) != format!(\"{:?}\", b.get_type()) {\n+            b = self.context.new_cast(None, b, a.get_type());\n+        }\n+        a + b\n+    }\n+\n+    fn fadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a + b\n+    }\n+\n+    fn sub(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        if a.get_type() != b.get_type() {\n+            b = self.context.new_cast(None, b, a.get_type());\n+        }\n+        a - b\n+    }\n+\n+    fn fsub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a - b\n+    }\n+\n+    fn mul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a * b\n+    }\n+\n+    fn fmul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a * b\n+    }\n+\n+    fn udiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): convert the arguments to unsigned?\n+        a / b\n+    }\n+\n+    fn exactudiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): convert the arguments to unsigned?\n+        // TODO(antoyo): poison if not exact.\n+        a / b\n+    }\n+\n+    fn sdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): convert the arguments to signed?\n+        a / b\n+    }\n+\n+    fn exactsdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): posion if not exact.\n+        // FIXME(antoyo): rustc_codegen_ssa::mir::intrinsic uses different types for a and b but they\n+        // should be the same.\n+        let typ = a.get_type().to_signed(self);\n+        let b = self.context.new_cast(None, b, typ);\n+        a / b\n+    }\n+\n+    fn fdiv(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a / b\n+    }\n+\n+    fn urem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a % b\n+    }\n+\n+    fn srem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a % b\n+    }\n+\n+    fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        if a.get_type() == self.cx.float_type {\n+            let fmodf = self.context.get_builtin_function(\"fmodf\");\n+            // FIXME(antoyo): this seems to produce the wrong result.\n+            return self.context.new_call(None, fmodf, &[a, b]);\n+        }\n+        assert_eq!(a.get_type(), self.cx.double_type);\n+\n+        let fmod = self.context.get_builtin_function(\"fmod\");\n+        return self.context.new_call(None, fmod, &[a, b]);\n+    }\n+\n+    fn shl(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+            let a = self.context.new_cast(None, a, b_type);\n+            let result = a << b;\n+            self.context.new_cast(None, result, a_type)\n+        }\n+        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+            let b = self.context.new_cast(None, b, a_type);\n+            a << b\n+        }\n+        else {\n+            a << b\n+        }\n+    }\n+\n+    fn lshr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+        // TODO(antoyo): cast to unsigned to do a logical shift if that does not work.\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+            let a = self.context.new_cast(None, a, b_type);\n+            let result = a >> b;\n+            self.context.new_cast(None, result, a_type)\n+        }\n+        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+            let b = self.context.new_cast(None, b, a_type);\n+            a >> b\n+        }\n+        else {\n+            a >> b\n+        }\n+    }\n+\n+    fn ashr(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): check whether behavior is an arithmetic shift for >> .\n+        // FIXME(antoyo): remove the casts when libgccjit can shift an unsigned number by an unsigned number.\n+        let a_type = a.get_type();\n+        let b_type = b.get_type();\n+        if a_type.is_unsigned(self) && b_type.is_signed(self) {\n+            let a = self.context.new_cast(None, a, b_type);\n+            let result = a >> b;\n+            self.context.new_cast(None, result, a_type)\n+        }\n+        else if a_type.is_signed(self) && b_type.is_unsigned(self) {\n+            let b = self.context.new_cast(None, b, a_type);\n+            a >> b\n+        }\n+        else {\n+            a >> b\n+        }\n+    }\n+\n+    fn and(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n+        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n+        if a.get_type() != b.get_type() {\n+            b = self.context.new_cast(None, b, a.get_type());\n+        }\n+        let res = self.current_func().new_local(None, b.get_type(), \"andResult\");\n+        self.llbb().add_assignment(None, res, a & b);\n+        res.to_rvalue()\n+    }\n+\n+    fn or(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n+        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n+        let res = self.current_func().new_local(None, b.get_type(), \"orResult\");\n+        self.llbb().add_assignment(None, res, a | b);\n+        res.to_rvalue()\n+    }\n+\n+    fn xor(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a ^ b\n+    }\n+\n+    fn neg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): use new_unary_op()?\n+        self.cx.context.new_rvalue_from_long(a.get_type(), 0) - a\n+    }\n+\n+    fn fneg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n+    }\n+\n+    fn not(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n+        let operation =\n+            if a.get_type().is_bool() {\n+                UnaryOp::LogicalNegate\n+            }\n+            else {\n+                UnaryOp::BitwiseNegate\n+            };\n+        self.cx.context.new_unary_op(None, operation, a.get_type(), a)\n+    }\n+\n+    fn unchecked_sadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a + b\n+    }\n+\n+    fn unchecked_uadd(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a + b\n+    }\n+\n+    fn unchecked_ssub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a - b\n+    }\n+\n+    fn unchecked_usub(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): should generate poison value?\n+        a - b\n+    }\n+\n+    fn unchecked_smul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a * b\n+    }\n+\n+    fn unchecked_umul(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        a * b\n+    }\n+\n+    fn fadd_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn fsub_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn fmul_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn fdiv_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn frem_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n+        use rustc_middle::ty::{Int, IntTy::*, Uint, UintTy::*};\n+\n+        let new_kind =\n+            match typ.kind() {\n+                Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.pointer_width)),\n+                Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.pointer_width)),\n+                t @ (Uint(_) | Int(_)) => t.clone(),\n+                _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n+            };\n+\n+        // TODO(antoyo): remove duplication with intrinsic?\n+        let name =\n+            match oop {\n+                OverflowOp::Add =>\n+                    match new_kind {\n+                        Int(I8) => \"__builtin_add_overflow\",\n+                        Int(I16) => \"__builtin_add_overflow\",\n+                        Int(I32) => \"__builtin_sadd_overflow\",\n+                        Int(I64) => \"__builtin_saddll_overflow\",\n+                        Int(I128) => \"__builtin_add_overflow\",\n+\n+                        Uint(U8) => \"__builtin_add_overflow\",\n+                        Uint(U16) => \"__builtin_add_overflow\",\n+                        Uint(U32) => \"__builtin_uadd_overflow\",\n+                        Uint(U64) => \"__builtin_uaddll_overflow\",\n+                        Uint(U128) => \"__builtin_add_overflow\",\n+\n+                        _ => unreachable!(),\n+                    },\n+                OverflowOp::Sub =>\n+                    match new_kind {\n+                        Int(I8) => \"__builtin_sub_overflow\",\n+                        Int(I16) => \"__builtin_sub_overflow\",\n+                        Int(I32) => \"__builtin_ssub_overflow\",\n+                        Int(I64) => \"__builtin_ssubll_overflow\",\n+                        Int(I128) => \"__builtin_sub_overflow\",\n+\n+                        Uint(U8) => \"__builtin_sub_overflow\",\n+                        Uint(U16) => \"__builtin_sub_overflow\",\n+                        Uint(U32) => \"__builtin_usub_overflow\",\n+                        Uint(U64) => \"__builtin_usubll_overflow\",\n+                        Uint(U128) => \"__builtin_sub_overflow\",\n+\n+                        _ => unreachable!(),\n+                    },\n+                OverflowOp::Mul =>\n+                    match new_kind {\n+                        Int(I8) => \"__builtin_mul_overflow\",\n+                        Int(I16) => \"__builtin_mul_overflow\",\n+                        Int(I32) => \"__builtin_smul_overflow\",\n+                        Int(I64) => \"__builtin_smulll_overflow\",\n+                        Int(I128) => \"__builtin_mul_overflow\",\n+\n+                        Uint(U8) => \"__builtin_mul_overflow\",\n+                        Uint(U16) => \"__builtin_mul_overflow\",\n+                        Uint(U32) => \"__builtin_umul_overflow\",\n+                        Uint(U64) => \"__builtin_umulll_overflow\",\n+                        Uint(U128) => \"__builtin_mul_overflow\",\n+\n+                        _ => unreachable!(),\n+                    },\n+            };\n+\n+        let intrinsic = self.context.get_builtin_function(&name);\n+        let res = self.current_func()\n+            // TODO(antoyo): is it correct to use rhs type instead of the parameter typ?\n+            .new_local(None, rhs.get_type(), \"binopResult\")\n+            .get_address(None);\n+        let overflow = self.overflow_call(intrinsic, &[lhs, rhs, res], None);\n+        (res.dereference(None).to_rvalue(), overflow)\n+    }\n+\n+    fn alloca(&mut self, ty: Type<'gcc>, align: Align) -> RValue<'gcc> {\n+        // FIXME(antoyo): this check that we don't call get_aligned() a second time on a type.\n+        // Ideally, we shouldn't need to do this check.\n+        let aligned_type =\n+            if ty == self.cx.u128_type || ty == self.cx.i128_type {\n+                ty\n+            }\n+            else {\n+                ty.get_aligned(align.bytes())\n+            };\n+        // TODO(antoyo): It might be better to return a LValue, but fixing the rustc API is non-trivial.\n+        self.stack_var_count.set(self.stack_var_count.get() + 1);\n+        self.current_func().new_local(None, aligned_type, &format!(\"stack_var_{}\", self.stack_var_count.get())).get_address(None)\n+    }\n+\n+    fn dynamic_alloca(&mut self, _ty: Type<'gcc>, _align: Align) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn array_alloca(&mut self, _ty: Type<'gcc>, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn load(&mut self, _ty: Type<'gcc>, ptr: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n+        // TODO(antoyo): use ty.\n+        let block = self.llbb();\n+        let function = block.get_function();\n+        // NOTE: instead of returning the dereference here, we have to assign it to a variable in\n+        // the current basic block. Otherwise, it could be used in another basic block, causing a\n+        // dereference after a drop, for instance.\n+        // TODO(antoyo): handle align.\n+        let deref = ptr.dereference(None).to_rvalue();\n+        let value_type = deref.get_type();\n+        unsafe { RETURN_VALUE_COUNT += 1 };\n+        let loaded_value = function.new_local(None, value_type, &format!(\"loadedValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+        block.add_assignment(None, loaded_value, deref);\n+        loaded_value.to_rvalue()\n+    }\n+\n+    fn volatile_load(&mut self, _ty: Type<'gcc>, ptr: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): use ty.\n+        let ptr = self.context.new_cast(None, ptr, ptr.get_type().make_volatile());\n+        ptr.dereference(None).to_rvalue()\n+    }\n+\n+    fn atomic_load(&mut self, _ty: Type<'gcc>, ptr: RValue<'gcc>, order: AtomicOrdering, size: Size) -> RValue<'gcc> {\n+        // TODO(antoyo): use ty.\n+        // TODO(antoyo): handle alignment.\n+        let atomic_load = self.context.get_builtin_function(&format!(\"__atomic_load_{}\", size.bytes()));\n+        let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n+\n+        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n+        self.context.new_call(None, atomic_load, &[ptr, ordering])\n+    }\n+\n+    fn load_operand(&mut self, place: PlaceRef<'tcx, RValue<'gcc>>) -> OperandRef<'tcx, RValue<'gcc>> {\n+        assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n+\n+        if place.layout.is_zst() {\n+            return OperandRef::new_zst(self, place.layout);\n+        }\n+\n+        fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {\n+            let vr = scalar.valid_range.clone();\n+            match scalar.value {\n+                abi::Int(..) => {\n+                    if !scalar.is_always_valid(bx) {\n+                        bx.range_metadata(load, scalar.valid_range);\n+                    }\n+                }\n+                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n+                    bx.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let val =\n+            if let Some(llextra) = place.llextra {\n+                OperandValue::Ref(place.llval, Some(llextra), place.align)\n+            }\n+            else if place.layout.is_gcc_immediate() {\n+                let load = self.load(place.llval.get_type(), place.llval, place.align);\n+                if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n+                    scalar_load_metadata(self, load, scalar);\n+                }\n+                OperandValue::Immediate(self.to_immediate(load, place.layout))\n+            }\n+            else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+                let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+                let pair_type = place.layout.gcc_type(self, false);\n+\n+                let mut load = |i, scalar: &abi::Scalar, align| {\n+                    let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n+                    let load = self.load(llptr.get_type(), llptr, align);\n+                    scalar_load_metadata(self, load, scalar);\n+                    if scalar.is_bool() { self.trunc(load, self.type_i1()) } else { load }\n+                };\n+\n+                OperandValue::Pair(\n+                    load(0, a, place.align),\n+                    load(1, b, place.align.restrict_for_offset(b_offset)),\n+                )\n+            }\n+            else {\n+                OperandValue::Ref(place.llval, None, place.align)\n+            };\n+\n+        OperandRef { val, layout: place.layout }\n+    }\n+\n+    fn write_operand_repeatedly(mut self, cg_elem: OperandRef<'tcx, RValue<'gcc>>, count: u64, dest: PlaceRef<'tcx, RValue<'gcc>>) -> Self {\n+        let zero = self.const_usize(0);\n+        let count = self.const_usize(count);\n+        let start = dest.project_index(&mut self, zero).llval;\n+        let end = dest.project_index(&mut self, count).llval;\n+\n+        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n+        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n+        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+\n+        let ptr_type = start.get_type();\n+        let current = self.llbb().get_function().new_local(None, ptr_type, \"loop_var\");\n+        let current_val = current.to_rvalue();\n+        self.assign(current, start);\n+\n+        self.br(header_bx.llbb());\n+\n+        let keep_going = header_bx.icmp(IntPredicate::IntNE, current_val, end);\n+        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+\n+        let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n+        cg_elem.val.store(&mut body_bx, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n+\n+        let next = body_bx.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n+        body_bx.llbb().add_assignment(None, current, next);\n+        body_bx.br(header_bx.llbb());\n+\n+        next_bx\n+    }\n+\n+    fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn nonnull_metadata(&mut self, _load: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn store(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, align: Align) -> RValue<'gcc> {\n+        self.store_with_flags(val, ptr, align, MemFlags::empty())\n+    }\n+\n+    fn store_with_flags(&mut self, val: RValue<'gcc>, ptr: RValue<'gcc>, _align: Align, _flags: MemFlags) -> RValue<'gcc> {\n+        let ptr = self.check_store(val, ptr);\n+        self.llbb().add_assignment(None, ptr.dereference(None), val);\n+        // TODO(antoyo): handle align and flags.\n+        // NOTE: dummy value here since it's never used. FIXME(antoyo): API should not return a value here?\n+        self.cx.context.new_rvalue_zero(self.type_i32())\n+    }\n+\n+    fn atomic_store(&mut self, value: RValue<'gcc>, ptr: RValue<'gcc>, order: AtomicOrdering, size: Size) {\n+        // TODO(antoyo): handle alignment.\n+        let atomic_store = self.context.get_builtin_function(&format!(\"__atomic_store_{}\", size.bytes()));\n+        let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n+        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n+\n+        // FIXME(antoyo): fix libgccjit to allow comparing an integer type with an aligned integer type because\n+        // the following cast is required to avoid this error:\n+        // gcc_jit_context_new_call: mismatching types for argument 2 of function \"__atomic_store_4\": assignment to param arg1 (type: int) from loadedValue3577 (type: unsigned int  __attribute__((aligned(4))))\n+        let int_type = atomic_store.get_param(1).to_rvalue().get_type();\n+        let value = self.context.new_cast(None, value, int_type);\n+        self.llbb()\n+            .add_eval(None, self.context.new_call(None, atomic_store, &[ptr, value, ordering]));\n+    }\n+\n+    fn gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n+        let mut result = ptr;\n+        for index in indices {\n+            result = self.context.new_array_access(None, result, *index).get_address(None).to_rvalue();\n+        }\n+        result\n+    }\n+\n+    fn inbounds_gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n+        // FIXME(antoyo): would be safer if doing the same thing (loop) as gep.\n+        // TODO(antoyo): specify inbounds somehow.\n+        match indices.len() {\n+            1 => {\n+                self.context.new_array_access(None, ptr, indices[0]).get_address(None)\n+            },\n+            2 => {\n+                let array = ptr.dereference(None); // TODO(antoyo): assert that first index is 0?\n+                self.context.new_array_access(None, array, indices[1]).get_address(None)\n+            },\n+            _ => unimplemented!(),\n+        }\n+    }\n+\n+    fn struct_gep(&mut self, value_type: Type<'gcc>, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n+        // FIXME(antoyo): it would be better if the API only called this on struct, not on arrays.\n+        assert_eq!(idx as usize as u64, idx);\n+        let value = ptr.dereference(None).to_rvalue();\n+\n+        if value_type.is_array().is_some() {\n+            let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n+            let element = self.context.new_array_access(None, value, index);\n+            element.get_address(None)\n+        }\n+        else if let Some(vector_type) = value_type.is_vector() {\n+            let array_type = vector_type.get_element_type().make_pointer();\n+            let array = self.bitcast(ptr, array_type);\n+            let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n+            let element = self.context.new_array_access(None, array, index);\n+            element.get_address(None)\n+        }\n+        else if let Some(struct_type) = value_type.is_struct() {\n+            ptr.dereference_field(None, struct_type.get_field(idx as i32)).get_address(None)\n+        }\n+        else {\n+            panic!(\"Unexpected type {:?}\", value_type);\n+        }\n+    }\n+\n+    /* Casts */\n+    fn trunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): check that it indeed truncate the value.\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): check that it indeed sign extend the value.\n+        if dest_ty.is_vector().is_some() {\n+            // TODO(antoyo): nothing to do as it is only for LLVM?\n+            return value;\n+        }\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn fptoui(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn fptosi(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn uitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn sitofp(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn fptrunc(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): make sure it truncates.\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn fpext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, value, dest_ty)\n+    }\n+\n+    fn ptrtoint(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.cx.ptrtoint(self.block.expect(\"block\"), value, dest_ty)\n+    }\n+\n+    fn inttoptr(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.cx.inttoptr(self.block.expect(\"block\"), value, dest_ty)\n+    }\n+\n+    fn bitcast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.cx.const_bitcast(value, dest_ty)\n+    }\n+\n+    fn intcast(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>, _is_signed: bool) -> RValue<'gcc> {\n+        // NOTE: is_signed is for value, not dest_typ.\n+        self.cx.context.new_cast(None, value, dest_typ)\n+    }\n+\n+    fn pointercast(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let val_type = value.get_type();\n+        match (type_is_pointer(val_type), type_is_pointer(dest_ty)) {\n+            (false, true) => {\n+                // NOTE: Projecting a field of a pointer type will attemp a cast from a signed char to\n+                // a pointer, which is not supported by gccjit.\n+                return self.cx.context.new_cast(None, self.inttoptr(value, val_type.make_pointer()), dest_ty);\n+            },\n+            (false, false) => {\n+                // When they are not pointers, we want a transmute (or reinterpret_cast).\n+                self.bitcast(value, dest_ty)\n+            },\n+            (true, true) => self.cx.context.new_cast(None, value, dest_ty),\n+            (true, false) => unimplemented!(),\n+        }\n+    }\n+\n+    /* Comparisons */\n+    fn icmp(&mut self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        let left_type = lhs.get_type();\n+        let right_type = rhs.get_type();\n+        if left_type != right_type {\n+            // NOTE: because libgccjit cannot compare function pointers.\n+            if left_type.is_function_ptr_type().is_some() && right_type.is_function_ptr_type().is_some() {\n+                lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n+                rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n+            }\n+            // NOTE: hack because we try to cast a vector type to the same vector type.\n+            else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n+                rhs = self.context.new_cast(None, rhs, left_type);\n+            }\n+        }\n+        self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+    }\n+\n+    fn fcmp(&mut self, op: RealPredicate, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+    }\n+\n+    /* Miscellaneous instructions */\n+    fn memcpy(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+            let val = self.load(src.get_type(), src, src_align);\n+            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.type_size_t(), false);\n+        let _is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.type_i8p());\n+        let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n+        let memcpy = self.context.get_builtin_function(\"memcpy\");\n+        let block = self.block.expect(\"block\");\n+        // TODO(antoyo): handle aligns and is_volatile.\n+        block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n+    }\n+\n+    fn memmove(&mut self, dst: RValue<'gcc>, dst_align: Align, src: RValue<'gcc>, src_align: Align, size: RValue<'gcc>, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n+            let val = self.load(src.get_type(), src, src_align);\n+            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.type_size_t(), false);\n+        let _is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.type_i8p());\n+        let src = self.pointercast(src, self.type_ptr_to(self.type_void()));\n+\n+        let memmove = self.context.get_builtin_function(\"memmove\");\n+        let block = self.block.expect(\"block\");\n+        // TODO(antoyo): handle is_volatile.\n+        block.add_eval(None, self.context.new_call(None, memmove, &[dst, src, size]));\n+    }\n+\n+    fn memset(&mut self, ptr: RValue<'gcc>, fill_byte: RValue<'gcc>, size: RValue<'gcc>, _align: Align, flags: MemFlags) {\n+        let _is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let ptr = self.pointercast(ptr, self.type_i8p());\n+        let memset = self.context.get_builtin_function(\"memset\");\n+        let block = self.block.expect(\"block\");\n+        // TODO(antoyo): handle align and is_volatile.\n+        let fill_byte = self.context.new_cast(None, fill_byte, self.i32_type);\n+        let size = self.intcast(size, self.type_size_t(), false);\n+        block.add_eval(None, self.context.new_call(None, memset, &[ptr, fill_byte, size]));\n+    }\n+\n+    fn select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, mut else_val: RValue<'gcc>) -> RValue<'gcc> {\n+        let func = self.current_func();\n+        let variable = func.new_local(None, then_val.get_type(), \"selectVar\");\n+        let then_block = func.new_block(\"then\");\n+        let else_block = func.new_block(\"else\");\n+        let after_block = func.new_block(\"after\");\n+        self.llbb().end_with_conditional(None, cond, then_block, else_block);\n+\n+        then_block.add_assignment(None, variable, then_val);\n+        then_block.end_with_jump(None, after_block);\n+\n+        if then_val.get_type() != else_val.get_type() {\n+            else_val = self.context.new_cast(None, else_val, then_val.get_type());\n+        }\n+        else_block.add_assignment(None, variable, else_val);\n+        else_block.end_with_jump(None, after_block);\n+\n+        // NOTE: since jumps were added in a place rustc does not expect, the current blocks in the\n+        // state need to be updated.\n+        self.block = Some(after_block);\n+        *self.cx.current_block.borrow_mut() = Some(after_block);\n+\n+        variable.to_rvalue()\n+    }\n+\n+    #[allow(dead_code)]\n+    fn va_arg(&mut self, _list: RValue<'gcc>, _ty: Type<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn extract_element(&mut self, _vec: RValue<'gcc>, _idx: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn vector_splat(&mut self, _num_elts: usize, _elt: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn extract_value(&mut self, aggregate_value: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n+        // FIXME(antoyo): it would be better if the API only called this on struct, not on arrays.\n+        assert_eq!(idx as usize as u64, idx);\n+        let value_type = aggregate_value.get_type();\n+\n+        if value_type.is_array().is_some() {\n+            let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n+            let element = self.context.new_array_access(None, aggregate_value, index);\n+            element.get_address(None)\n+        }\n+        else if value_type.is_vector().is_some() {\n+            panic!();\n+        }\n+        else if let Some(pointer_type) = value_type.get_pointee() {\n+            if let Some(struct_type) = pointer_type.is_struct() {\n+                // NOTE: hack to workaround a limitation of the rustc API: see comment on\n+                // CodegenCx.structs_as_pointer\n+                aggregate_value.dereference_field(None, struct_type.get_field(idx as i32)).to_rvalue()\n+            }\n+            else {\n+                panic!(\"Unexpected type {:?}\", value_type);\n+            }\n+        }\n+        else if let Some(struct_type) = value_type.is_struct() {\n+            aggregate_value.access_field(None, struct_type.get_field(idx as i32)).to_rvalue()\n+        }\n+        else {\n+            panic!(\"Unexpected type {:?}\", value_type);\n+        }\n+    }\n+\n+    fn insert_value(&mut self, aggregate_value: RValue<'gcc>, value: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n+        // FIXME(antoyo): it would be better if the API only called this on struct, not on arrays.\n+        assert_eq!(idx as usize as u64, idx);\n+        let value_type = aggregate_value.get_type();\n+\n+        let lvalue =\n+            if value_type.is_array().is_some() {\n+                let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n+                self.context.new_array_access(None, aggregate_value, index)\n+            }\n+            else if value_type.is_vector().is_some() {\n+                panic!();\n+            }\n+            else if let Some(pointer_type) = value_type.get_pointee() {\n+                if let Some(struct_type) = pointer_type.is_struct() {\n+                    // NOTE: hack to workaround a limitation of the rustc API: see comment on\n+                    // CodegenCx.structs_as_pointer\n+                    aggregate_value.dereference_field(None, struct_type.get_field(idx as i32))\n+                }\n+                else {\n+                    panic!(\"Unexpected type {:?}\", value_type);\n+                }\n+            }\n+            else {\n+                panic!(\"Unexpected type {:?}\", value_type);\n+            };\n+\n+        let lvalue_type = lvalue.to_rvalue().get_type();\n+        let value =\n+            // NOTE: sometimes, rustc will create a value with the wrong type.\n+            if lvalue_type != value.get_type() {\n+                self.context.new_cast(None, value, lvalue_type)\n+            }\n+            else {\n+                value\n+            };\n+\n+        self.llbb().add_assignment(None, lvalue, value);\n+\n+        aggregate_value\n+    }\n+\n+    fn landing_pad(&mut self, _ty: Type<'gcc>, _pers_fn: RValue<'gcc>, _num_clauses: usize) -> RValue<'gcc> {\n+        let field1 = self.context.new_field(None, self.u8_type, \"landing_pad_field_1\");\n+        let field2 = self.context.new_field(None, self.i32_type, \"landing_pad_field_1\");\n+        let struct_type = self.context.new_struct_type(None, \"landing_pad\", &[field1, field2]);\n+        self.current_func().new_local(None, struct_type.as_type(), \"landing_pad\")\n+            .to_rvalue()\n+        // TODO(antoyo): Properly implement unwinding.\n+        // the above is just to make the compilation work as it seems\n+        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n+    }\n+\n+    fn set_cleanup(&mut self, _landing_pad: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn resume(&mut self, _exn: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn cleanup_pad(&mut self, _parent: Option<RValue<'gcc>>, _args: &[RValue<'gcc>]) -> Funclet {\n+        unimplemented!();\n+    }\n+\n+    fn cleanup_ret(&mut self, _funclet: &Funclet, _unwind: Option<Block<'gcc>>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn catch_pad(&mut self, _parent: RValue<'gcc>, _args: &[RValue<'gcc>]) -> Funclet {\n+        unimplemented!();\n+    }\n+\n+    fn catch_switch(&mut self, _parent: Option<RValue<'gcc>>, _unwind: Option<Block<'gcc>>, _num_handlers: usize) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn add_handler(&mut self, _catch_switch: RValue<'gcc>, _handler: Block<'gcc>) {\n+        unimplemented!();\n+    }\n+\n+    fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    // Atomic Operations\n+    fn atomic_cmpxchg(&mut self, dst: RValue<'gcc>, cmp: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n+        let expected = self.current_func().new_local(None, cmp.get_type(), \"expected\");\n+        self.llbb().add_assignment(None, expected, cmp);\n+        let success = self.compare_exchange(dst, expected, src, order, failure_order, weak);\n+\n+        let pair_type = self.cx.type_struct(&[src.get_type(), self.bool_type], false);\n+        let result = self.current_func().new_local(None, pair_type, \"atomic_cmpxchg_result\");\n+        let align = Align::from_bits(64).expect(\"align\"); // TODO(antoyo): use good align.\n+\n+        let value_type = result.to_rvalue().get_type();\n+        if let Some(struct_type) = value_type.is_struct() {\n+            self.store(success, result.access_field(None, struct_type.get_field(1)).get_address(None), align);\n+            // NOTE: since success contains the call to the intrinsic, it must be stored before\n+            // expected so that we store expected after the call.\n+            self.store(expected.to_rvalue(), result.access_field(None, struct_type.get_field(0)).get_address(None), align);\n+        }\n+        // TODO(antoyo): handle when value is not a struct.\n+\n+        result.to_rvalue()\n+    }\n+\n+    fn atomic_rmw(&mut self, op: AtomicRmwBinOp, dst: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering) -> RValue<'gcc> {\n+        let size = self.cx.int_width(src.get_type()) / 8;\n+        let name =\n+            match op {\n+                AtomicRmwBinOp::AtomicXchg => format!(\"__atomic_exchange_{}\", size),\n+                AtomicRmwBinOp::AtomicAdd => format!(\"__atomic_fetch_add_{}\", size),\n+                AtomicRmwBinOp::AtomicSub => format!(\"__atomic_fetch_sub_{}\", size),\n+                AtomicRmwBinOp::AtomicAnd => format!(\"__atomic_fetch_and_{}\", size),\n+                AtomicRmwBinOp::AtomicNand => format!(\"__atomic_fetch_nand_{}\", size),\n+                AtomicRmwBinOp::AtomicOr => format!(\"__atomic_fetch_or_{}\", size),\n+                AtomicRmwBinOp::AtomicXor => format!(\"__atomic_fetch_xor_{}\", size),\n+                AtomicRmwBinOp::AtomicMax => return self.atomic_extremum(ExtremumOperation::Max, dst, src, order),\n+                AtomicRmwBinOp::AtomicMin => return self.atomic_extremum(ExtremumOperation::Min, dst, src, order),\n+                AtomicRmwBinOp::AtomicUMax => return self.atomic_extremum(ExtremumOperation::Max, dst, src, order),\n+                AtomicRmwBinOp::AtomicUMin => return self.atomic_extremum(ExtremumOperation::Min, dst, src, order),\n+            };\n+\n+\n+        let atomic_function = self.context.get_builtin_function(name);\n+        let order = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n+\n+        let void_ptr_type = self.context.new_type::<*mut ()>();\n+        let volatile_void_ptr_type = void_ptr_type.make_volatile();\n+        let dst = self.context.new_cast(None, dst, volatile_void_ptr_type);\n+        // FIXME(antoyo): not sure why, but we have the wrong type here.\n+        let new_src_type = atomic_function.get_param(1).to_rvalue().get_type();\n+        let src = self.context.new_cast(None, src, new_src_type);\n+        let res = self.context.new_call(None, atomic_function, &[dst, src, order]);\n+        self.context.new_cast(None, res, src.get_type())\n+    }\n+\n+    fn atomic_fence(&mut self, order: AtomicOrdering, scope: SynchronizationScope) {\n+        let name =\n+            match scope {\n+                SynchronizationScope::SingleThread => \"__atomic_signal_fence\",\n+                SynchronizationScope::CrossThread => \"__atomic_thread_fence\",\n+            };\n+        let thread_fence = self.context.get_builtin_function(name);\n+        let order = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n+        self.llbb().add_eval(None, self.context.new_call(None, thread_fence, &[order]));\n+    }\n+\n+    fn set_invariant_load(&mut self, load: RValue<'gcc>) {\n+        // NOTE: Hack to consider vtable function pointer as non-global-variable function pointer.\n+        self.normal_function_addresses.borrow_mut().insert(load);\n+        // TODO(antoyo)\n+    }\n+\n+    fn lifetime_start(&mut self, _ptr: RValue<'gcc>, _size: Size) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn lifetime_end(&mut self, _ptr: RValue<'gcc>, _size: Size) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        // FIXME(antoyo): remove when having a proper API.\n+        let gcc_func = unsafe { std::mem::transmute(func) };\n+        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+            self.function_call(func, args, funclet)\n+        }\n+        else {\n+            // If it's a not function that was defined, it's a function pointer.\n+            self.function_ptr_call(func, args, funclet)\n+        }\n+    }\n+\n+    fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {\n+        // FIXME(antoyo): this does not zero-extend.\n+        if value.get_type().is_bool() && dest_typ.is_i8(&self.cx) {\n+            // FIXME(antoyo): hack because base::from_immediate converts i1 to i8.\n+            // Fix the code in codegen_ssa::base::from_immediate.\n+            return value;\n+        }\n+        self.context.new_cast(None, value, dest_typ)\n+    }\n+\n+    fn cx(&self) -> &CodegenCx<'gcc, 'tcx> {\n+        self.cx\n+    }\n+\n+    fn do_not_inline(&mut self, _llret: RValue<'gcc>) {\n+        unimplemented!();\n+    }\n+\n+    fn set_span(&mut self, _span: Span) {}\n+\n+    fn from_immediate(&mut self, val: Self::Value) -> Self::Value {\n+        if self.cx().val_ty(val) == self.cx().type_i1() {\n+            self.zext(val, self.cx().type_i8())\n+        }\n+        else {\n+            val\n+        }\n+    }\n+\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: abi::Scalar) -> Self::Value {\n+        if scalar.is_bool() {\n+            return self.trunc(val, self.cx().type_i1());\n+        }\n+        val\n+    }\n+\n+    fn fptoui_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n+        None\n+    }\n+\n+    fn fptosi_sat(&mut self, _val: RValue<'gcc>, _dest_ty: Type<'gcc>) -> Option<RValue<'gcc>> {\n+        None\n+    }\n+\n+    fn instrprof_increment(&mut self, _fn_name: RValue<'gcc>, _hash: RValue<'gcc>, _num_counters: RValue<'gcc>, _index: RValue<'gcc>) {\n+        unimplemented!();\n+    }\n+}\n+\n+impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n+        let return_type = v1.get_type();\n+        let params = [\n+            self.context.new_parameter(None, return_type, \"v1\"),\n+            self.context.new_parameter(None, return_type, \"v2\"),\n+            self.context.new_parameter(None, mask.get_type(), \"mask\"),\n+        ];\n+        let shuffle = self.context.new_function(None, FunctionType::Extern, return_type, &params, \"_mm_shuffle_epi8\", false);\n+        self.context.new_call(None, shuffle, &[v1, v2, mask])\n+    }\n+}\n+\n+impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n+    fn get_static(&mut self, def_id: DefId) -> RValue<'gcc> {\n+        // Forward to the `get_static` method of `CodegenCx`\n+        self.cx().get_static(def_id).get_address(None)\n+    }\n+}\n+\n+impl<'tcx> HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        self.cx.param_env()\n+    }\n+}\n+\n+impl<'tcx> HasTargetSpec for Builder<'_, '_, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.cx.target_spec()\n+    }\n+}\n+\n+trait ToGccComp {\n+    fn to_gcc_comparison(&self) -> ComparisonOp;\n+}\n+\n+impl ToGccComp for IntPredicate {\n+    fn to_gcc_comparison(&self) -> ComparisonOp {\n+        match *self {\n+            IntPredicate::IntEQ => ComparisonOp::Equals,\n+            IntPredicate::IntNE => ComparisonOp::NotEquals,\n+            IntPredicate::IntUGT => ComparisonOp::GreaterThan,\n+            IntPredicate::IntUGE => ComparisonOp::GreaterThanEquals,\n+            IntPredicate::IntULT => ComparisonOp::LessThan,\n+            IntPredicate::IntULE => ComparisonOp::LessThanEquals,\n+            IntPredicate::IntSGT => ComparisonOp::GreaterThan,\n+            IntPredicate::IntSGE => ComparisonOp::GreaterThanEquals,\n+            IntPredicate::IntSLT => ComparisonOp::LessThan,\n+            IntPredicate::IntSLE => ComparisonOp::LessThanEquals,\n+        }\n+    }\n+}\n+\n+impl ToGccComp for RealPredicate {\n+    fn to_gcc_comparison(&self) -> ComparisonOp {\n+        // TODO(antoyo): check that ordered vs non-ordered is respected.\n+        match *self {\n+            RealPredicate::RealPredicateFalse => unreachable!(),\n+            RealPredicate::RealOEQ => ComparisonOp::Equals,\n+            RealPredicate::RealOGT => ComparisonOp::GreaterThan,\n+            RealPredicate::RealOGE => ComparisonOp::GreaterThanEquals,\n+            RealPredicate::RealOLT => ComparisonOp::LessThan,\n+            RealPredicate::RealOLE => ComparisonOp::LessThanEquals,\n+            RealPredicate::RealONE => ComparisonOp::NotEquals,\n+            RealPredicate::RealORD => unreachable!(),\n+            RealPredicate::RealUNO => unreachable!(),\n+            RealPredicate::RealUEQ => ComparisonOp::Equals,\n+            RealPredicate::RealUGT => ComparisonOp::GreaterThan,\n+            RealPredicate::RealUGE => ComparisonOp::GreaterThan,\n+            RealPredicate::RealULT => ComparisonOp::LessThan,\n+            RealPredicate::RealULE => ComparisonOp::LessThan,\n+            RealPredicate::RealUNE => ComparisonOp::NotEquals,\n+            RealPredicate::RealPredicateTrue => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[repr(C)]\n+#[allow(non_camel_case_types)]\n+enum MemOrdering {\n+    __ATOMIC_RELAXED,\n+    __ATOMIC_CONSUME,\n+    __ATOMIC_ACQUIRE,\n+    __ATOMIC_RELEASE,\n+    __ATOMIC_ACQ_REL,\n+    __ATOMIC_SEQ_CST,\n+}\n+\n+trait ToGccOrdering {\n+    fn to_gcc(self) -> i32;\n+}\n+\n+impl ToGccOrdering for AtomicOrdering {\n+    fn to_gcc(self) -> i32 {\n+        use MemOrdering::*;\n+\n+        let ordering =\n+            match self {\n+                AtomicOrdering::NotAtomic => __ATOMIC_RELAXED, // TODO(antoyo): check if that's the same.\n+                AtomicOrdering::Unordered => __ATOMIC_RELAXED,\n+                AtomicOrdering::Monotonic => __ATOMIC_RELAXED, // TODO(antoyo): check if that's the same.\n+                AtomicOrdering::Acquire => __ATOMIC_ACQUIRE,\n+                AtomicOrdering::Release => __ATOMIC_RELEASE,\n+                AtomicOrdering::AcquireRelease => __ATOMIC_ACQ_REL,\n+                AtomicOrdering::SequentiallyConsistent => __ATOMIC_SEQ_CST,\n+            };\n+        ordering as i32\n+    }\n+}"}, {"sha": "76419b103d049e3c2b50c0831b3c1e4c3ff28959", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,77 @@\n+use gccjit::{FunctionType, RValue};\n+use rustc_codegen_ssa::traits::BaseTypeMethods;\n+use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n+\n+use crate::abi::FnAbiGccExt;\n+use crate::context::CodegenCx;\n+\n+/// Codegens a reference to a fn/method item, monomorphizing and\n+/// inlining as it goes.\n+///\n+/// # Parameters\n+///\n+/// - `cx`: the crate context\n+/// - `instance`: the instance to be instantiated\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+    let tcx = cx.tcx();\n+\n+    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_escaping_bound_vars());\n+\n+    if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n+        return func;\n+    }\n+\n+    let sym = tcx.symbol_name(instance).name;\n+\n+    let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n+\n+    let func =\n+        if let Some(func) = cx.get_declared_value(&sym) {\n+            // Create a fn pointer with the new signature.\n+            let ptrty = fn_abi.ptr_to_gcc_type(cx);\n+\n+            // This is subtle and surprising, but sometimes we have to bitcast\n+            // the resulting fn pointer.  The reason has to do with external\n+            // functions.  If you have two crates that both bind the same C\n+            // library, they may not use precisely the same types: for\n+            // example, they will probably each declare their own structs,\n+            // which are distinct types from LLVM's point of view (nominal\n+            // types).\n+            //\n+            // Now, if those two crates are linked into an application, and\n+            // they contain inlined code, you can wind up with a situation\n+            // where both of those functions wind up being loaded into this\n+            // application simultaneously. In that case, the same function\n+            // (from LLVM's point of view) requires two types. But of course\n+            // LLVM won't allow one function to have two types.\n+            //\n+            // What we currently do, therefore, is declare the function with\n+            // one of the two types (whichever happens to come first) and then\n+            // bitcast as needed when the function is referenced to make sure\n+            // it has the type we expect.\n+            //\n+            // This can occur on either a crate-local or crate-external\n+            // reference. It also occurs when testing libcore and in some\n+            // other weird situations. Annoying.\n+            if cx.val_ty(func) != ptrty {\n+                // TODO(antoyo): cast the pointer.\n+                func\n+            }\n+            else {\n+                func\n+            }\n+        }\n+        else {\n+            cx.linkage.set(FunctionType::Extern);\n+            let func = cx.declare_fn(&sym, &fn_abi);\n+\n+            // TODO(antoyo): set linkage and attributes.\n+            func\n+        };\n+\n+    cx.function_instances.borrow_mut().insert(instance, func);\n+\n+    func\n+}"}, {"sha": "bda08b653f05929fc35a58d273a80fdc20c728ae", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "added", "additions": 450, "deletions": 0, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,450 @@\n+use std::convert::TryFrom;\n+use std::convert::TryInto;\n+\n+use gccjit::LValue;\n+use gccjit::{Block, CType, RValue, Type, ToRValue};\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::{\n+    BaseTypeMethods,\n+    ConstMethods,\n+    DerivedTypeMethods,\n+    MiscMethods,\n+    StaticMethods,\n+};\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::ScalarInt;\n+use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n+use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_span::Symbol;\n+use rustc_target::abi::{self, HasDataLayout, Pointer, Size};\n+\n+use crate::consts::const_alloc_to_gcc;\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn const_bytes(&self, bytes: &[u8]) -> RValue<'gcc> {\n+        bytes_in_context(self, bytes)\n+    }\n+\n+    fn const_cstr(&self, symbol: Symbol, _null_terminated: bool) -> LValue<'gcc> {\n+        // TODO(antoyo): handle null_terminated.\n+        if let Some(&value) = self.const_cstr_cache.borrow().get(&symbol) {\n+            return value;\n+        }\n+\n+        let global = self.global_string(&*symbol.as_str());\n+\n+        self.const_cstr_cache.borrow_mut().insert(symbol, global);\n+        global\n+    }\n+\n+    fn global_string(&self, string: &str) -> LValue<'gcc> {\n+        // TODO(antoyo): handle non-null-terminated strings.\n+        let string = self.context.new_string_literal(&*string);\n+        let sym = self.generate_local_symbol_name(\"str\");\n+        let global = self.declare_private_global(&sym, self.val_ty(string));\n+        global.global_set_initializer_value(string);\n+        global\n+        // TODO(antoyo): set linkage.\n+    }\n+\n+    pub fn inttoptr(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        let func = block.get_function();\n+        let local = func.new_local(None, value.get_type(), \"intLocal\");\n+        block.add_assignment(None, local, value);\n+        let value_address = local.get_address(None);\n+\n+        let ptr = self.context.new_cast(None, value_address, dest_ty.make_pointer());\n+        ptr.dereference(None).to_rvalue()\n+    }\n+\n+    pub fn ptrtoint(&self, block: Block<'gcc>, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): when libgccjit allow casting from pointer to int, remove this.\n+        let func = block.get_function();\n+        let local = func.new_local(None, value.get_type(), \"ptrLocal\");\n+        block.add_assignment(None, local, value);\n+        let ptr_address = local.get_address(None);\n+\n+        let ptr = self.context.new_cast(None, ptr_address, dest_ty.make_pointer());\n+        ptr.dereference(None).to_rvalue()\n+    }\n+}\n+\n+pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n+    let context = &cx.context;\n+    let byte_type = context.new_type::<u8>();\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let elements: Vec<_> =\n+        bytes.iter()\n+        .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n+        .collect();\n+    context.new_rvalue_from_array(None, typ, &elements)\n+}\n+\n+pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n+    typ.get_pointee().is_some()\n+}\n+\n+impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn const_null(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if type_is_pointer(typ) {\n+            self.context.new_null(typ)\n+        }\n+        else {\n+            self.const_int(typ, 0)\n+        }\n+    }\n+\n+    fn const_undef(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        let local = self.current_func.borrow().expect(\"func\")\n+            .new_local(None, typ, \"undefined\");\n+        if typ.is_struct().is_some() {\n+            // NOTE: hack to workaround a limitation of the rustc API: see comment on\n+            // CodegenCx.structs_as_pointer\n+            let pointer = local.get_address(None);\n+            self.structs_as_pointer.borrow_mut().insert(pointer);\n+            pointer\n+        }\n+        else {\n+            local.to_rvalue()\n+        }\n+    }\n+\n+    fn const_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n+        self.context.new_rvalue_from_long(typ, i64::try_from(int).expect(\"i64::try_from\"))\n+    }\n+\n+    fn const_uint(&self, typ: Type<'gcc>, int: u64) -> RValue<'gcc> {\n+        self.context.new_rvalue_from_long(typ, u64::try_from(int).expect(\"u64::try_from\") as i64)\n+    }\n+\n+    fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n+        let num64: Result<i64, _> = num.try_into();\n+        if let Ok(num) = num64 {\n+            // FIXME(antoyo): workaround for a bug where libgccjit is expecting a constant.\n+            // The operations >> 64 and | low are making the normal case a non-constant.\n+            return self.context.new_rvalue_from_long(typ, num as i64);\n+        }\n+\n+        if num >> 64 != 0 {\n+            // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n+            let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n+            let high = self.context.new_rvalue_from_long(typ, (num >> 64) as u64 as i64);\n+\n+            let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+            (high << sixty_four) | self.context.new_cast(None, low, typ)\n+        }\n+        else if typ.is_i128(self) {\n+            let num = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n+            self.context.new_cast(None, num, typ)\n+        }\n+        else {\n+            self.context.new_rvalue_from_long(typ, num as u64 as i64)\n+        }\n+    }\n+\n+    fn const_bool(&self, val: bool) -> RValue<'gcc> {\n+        self.const_uint(self.type_i1(), val as u64)\n+    }\n+\n+    fn const_i32(&self, i: i32) -> RValue<'gcc> {\n+        self.const_int(self.type_i32(), i as i64)\n+    }\n+\n+    fn const_u32(&self, i: u32) -> RValue<'gcc> {\n+        self.const_uint(self.type_u32(), i as u64)\n+    }\n+\n+    fn const_u64(&self, i: u64) -> RValue<'gcc> {\n+        self.const_uint(self.type_u64(), i)\n+    }\n+\n+    fn const_usize(&self, i: u64) -> RValue<'gcc> {\n+        let bit_size = self.data_layout().pointer_size.bits();\n+        if bit_size < 64 {\n+            // make sure it doesn't overflow\n+            assert!(i < (1 << bit_size));\n+        }\n+\n+        self.const_uint(self.usize_type, i)\n+    }\n+\n+    fn const_u8(&self, _i: u8) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn const_real(&self, _t: Type<'gcc>, _val: f64) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {\n+        let len = s.as_str().len();\n+        let cs = self.const_ptrcast(self.const_cstr(s, false).get_address(None),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+        );\n+        (cs, self.const_usize(len as u64))\n+    }\n+\n+    fn const_struct(&self, values: &[RValue<'gcc>], packed: bool) -> RValue<'gcc> {\n+        let fields: Vec<_> = values.iter()\n+            .map(|value| value.get_type())\n+            .collect();\n+        // TODO(antoyo): cache the type? It's anonymous, so probably not.\n+        let typ = self.type_struct(&fields, packed);\n+        let struct_type = typ.is_struct().expect(\"struct type\");\n+        self.context.new_rvalue_from_struct(None, struct_type, values)\n+    }\n+\n+    fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {\n+        // TODO(antoyo)\n+        None\n+    }\n+\n+    fn const_to_opt_u128(&self, _v: RValue<'gcc>, _sign_ext: bool) -> Option<u128> {\n+        // TODO(antoyo)\n+        None\n+    }\n+\n+    fn scalar_to_backend(&self, cv: Scalar, layout: abi::Scalar, ty: Type<'gcc>) -> RValue<'gcc> {\n+        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        match cv {\n+            Scalar::Int(ScalarInt::ZST) => {\n+                assert_eq!(0, layout.value.size(self).bytes());\n+                self.const_undef(self.type_ix(0))\n+            }\n+            Scalar::Int(int) => {\n+                let data = int.assert_bits(layout.value.size(self));\n+\n+                // FIXME(antoyo): there's some issues with using the u128 code that follows, so hard-code\n+                // the paths for floating-point values.\n+                if ty == self.float_type {\n+                    return self.context.new_rvalue_from_double(ty, f32::from_bits(data as u32) as f64);\n+                }\n+                else if ty == self.double_type {\n+                    return self.context.new_rvalue_from_double(ty, f64::from_bits(data as u64));\n+                }\n+\n+                let value = self.const_uint_big(self.type_ix(bitsize), data);\n+                if layout.value == Pointer {\n+                    self.inttoptr(self.current_block.borrow().expect(\"block\"), value, ty)\n+                } else {\n+                    self.const_bitcast(value, ty)\n+                }\n+            }\n+            Scalar::Ptr(ptr, _size) => {\n+                let (alloc_id, offset) = ptr.into_parts();\n+                let base_addr =\n+                    match self.tcx.global_alloc(alloc_id) {\n+                        GlobalAlloc::Memory(alloc) => {\n+                            let init = const_alloc_to_gcc(self, alloc);\n+                            let value =\n+                                match alloc.mutability {\n+                                    Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n+                                    _ => self.static_addr_of(init, alloc.align, None),\n+                                };\n+                            if !self.sess().fewer_names() {\n+                                // TODO(antoyo): set value name.\n+                            }\n+                            value\n+                        },\n+                        GlobalAlloc::Function(fn_instance) => {\n+                            self.get_fn_addr(fn_instance)\n+                        },\n+                        GlobalAlloc::Static(def_id) => {\n+                            assert!(self.tcx.is_static(def_id));\n+                            self.get_static(def_id).get_address(None)\n+                        },\n+                    };\n+                let ptr_type = base_addr.get_type();\n+                let base_addr = self.const_bitcast(base_addr, self.usize_type);\n+                let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n+                let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n+                if layout.value != Pointer {\n+                    self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n+                }\n+                else {\n+                    self.const_bitcast(ptr, ty)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value {\n+        const_alloc_to_gcc(self, alloc)\n+    }\n+\n+    fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: &Allocation, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n+        assert_eq!(alloc.align, layout.align.abi);\n+        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let value =\n+            if layout.size == Size::ZERO {\n+                let value = self.const_usize(alloc.align.bytes());\n+                self.context.new_cast(None, value, ty)\n+            }\n+            else {\n+                let init = const_alloc_to_gcc(self, alloc);\n+                let base_addr = self.static_addr_of(init, alloc.align, None);\n+\n+                let array = self.const_bitcast(base_addr, self.type_i8p());\n+                let value = self.context.new_array_access(None, array, self.const_usize(offset.bytes())).get_address(None);\n+                self.const_bitcast(value, ty)\n+            };\n+        PlaceRef::new_sized(value, layout)\n+    }\n+\n+    fn const_ptrcast(&self, val: RValue<'gcc>, ty: Type<'gcc>) -> RValue<'gcc> {\n+        self.context.new_cast(None, val, ty)\n+    }\n+}\n+\n+pub trait SignType<'gcc, 'tcx> {\n+    fn is_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn to_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+}\n+\n+impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n+    fn is_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.is_i8(cx) || self.is_i16(cx) || self.is_i32(cx) || self.is_i64(cx) || self.is_i128(cx)\n+    }\n+\n+    fn is_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.is_u8(cx) || self.is_u16(cx) || self.is_u32(cx) || self.is_u64(cx) || self.is_u128(cx)\n+    }\n+\n+    fn to_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        if self.is_u8(cx) {\n+            cx.i8_type\n+        }\n+        else if self.is_u16(cx) {\n+            cx.i16_type\n+        }\n+        else if self.is_u32(cx) {\n+            cx.i32_type\n+        }\n+        else if self.is_u64(cx) {\n+            cx.i64_type\n+        }\n+        else if self.is_u128(cx) {\n+            cx.i128_type\n+        }\n+        else {\n+            self.clone()\n+        }\n+    }\n+\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        if self.is_i8(cx) {\n+            cx.u8_type\n+        }\n+        else if self.is_i16(cx) {\n+            cx.u16_type\n+        }\n+        else if self.is_i32(cx) {\n+            cx.u32_type\n+        }\n+        else if self.is_i64(cx) {\n+            cx.u64_type\n+        }\n+        else if self.is_i128(cx) {\n+            cx.u128_type\n+        }\n+        else {\n+            self.clone()\n+        }\n+    }\n+}\n+\n+pub trait TypeReflection<'gcc, 'tcx>  {\n+    fn is_uchar(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_ushort(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_ulong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_ulonglong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+\n+    fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_u8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_i16(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_u16(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_i32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_u32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_i64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_u64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_i128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_u128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+\n+    fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+    fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n+}\n+\n+impl<'gcc, 'tcx> TypeReflection<'gcc, 'tcx> for Type<'gcc> {\n+    fn is_uchar(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u8_type\n+    }\n+\n+    fn is_ushort(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u16_type\n+    }\n+\n+    fn is_uint(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.uint_type\n+    }\n+\n+    fn is_ulong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.ulong_type\n+    }\n+\n+    fn is_ulonglong(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.ulonglong_type\n+    }\n+\n+    fn is_i8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.i8_type\n+    }\n+\n+    fn is_u8(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u8_type\n+    }\n+\n+    fn is_i16(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.i16_type\n+    }\n+\n+    fn is_u16(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u16_type\n+    }\n+\n+    fn is_i32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.i32_type\n+    }\n+\n+    fn is_u32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u32_type\n+    }\n+\n+    fn is_i64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.i64_type\n+    }\n+\n+    fn is_u64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.u64_type\n+    }\n+\n+    fn is_i128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.context.new_c_type(CType::Int128t)\n+    }\n+\n+    fn is_u128(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.context.new_c_type(CType::UInt128t)\n+    }\n+\n+    fn is_f32(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.context.new_type::<f32>()\n+    }\n+\n+    fn is_f64(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool {\n+        self.unqualified() == cx.context.new_type::<f64>()\n+    }\n+}"}, {"sha": "205498acc3187beb9260e194db2e3de1c06d5426", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,390 @@\n+use gccjit::{LValue, RValue, ToRValue, Type};\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n+use rustc_hir as hir;\n+use rustc_hir::Node;\n+use rustc_middle::{bug, span_bug};\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::mono::MonoItem;\n+use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_middle::mir::interpret::{self, Allocation, ErrorHandled, Scalar as InterpScalar, read_target_uint};\n+use rustc_span::Span;\n+use rustc_span::def_id::DefId;\n+use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRange};\n+\n+use crate::base;\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n+        if value.get_type() == self.bool_type.make_pointer() {\n+            if let Some(pointee) = typ.get_pointee() {\n+                if pointee.is_vector().is_some() {\n+                    panic!()\n+                }\n+            }\n+        }\n+        self.context.new_bitcast(None, value, typ)\n+    }\n+}\n+\n+impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n+    fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n+        if let Some(global_value) = self.const_globals.borrow().get(&cv) {\n+            // TODO(antoyo): upgrade alignment.\n+            return *global_value;\n+        }\n+        let global_value = self.static_addr_of_mut(cv, align, kind);\n+        // TODO(antoyo): set global constant.\n+        self.const_globals.borrow_mut().insert(cv, global_value);\n+        global_value\n+    }\n+\n+    fn codegen_static(&self, def_id: DefId, is_mutable: bool) {\n+        let attrs = self.tcx.codegen_fn_attrs(def_id);\n+\n+        let value =\n+            match codegen_static_initializer(&self, def_id) {\n+                Ok((value, _)) => value,\n+                // Error has already been reported\n+                Err(_) => return,\n+            };\n+\n+        let global = self.get_static(def_id);\n+\n+        // boolean SSA values are i1, but they have to be stored in i8 slots,\n+        // otherwise some LLVM optimization passes don't work as expected\n+        let val_llty = self.val_ty(value);\n+        let value =\n+            if val_llty == self.type_i1() {\n+                unimplemented!();\n+            }\n+            else {\n+                value\n+            };\n+\n+        let instance = Instance::mono(self.tcx, def_id);\n+        let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n+        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+\n+        // TODO(antoyo): set alignment.\n+\n+        let value =\n+            if value.get_type() != gcc_type {\n+                self.context.new_bitcast(None, value, gcc_type)\n+            }\n+            else {\n+                value\n+            };\n+        global.global_set_initializer_value(value);\n+\n+        // As an optimization, all shared statics which do not have interior\n+        // mutability are placed into read-only memory.\n+        if !is_mutable {\n+            if self.type_is_freeze(ty) {\n+                // TODO(antoyo): set global constant.\n+            }\n+        }\n+\n+        if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+            // Do not allow LLVM to change the alignment of a TLS on macOS.\n+            //\n+            // By default a global's alignment can be freely increased.\n+            // This allows LLVM to generate more performant instructions\n+            // e.g., using load-aligned into a SIMD register.\n+            //\n+            // However, on macOS 10.10 or below, the dynamic linker does not\n+            // respect any alignment given on the TLS (radar 24221680).\n+            // This will violate the alignment assumption, and causing segfault at runtime.\n+            //\n+            // This bug is very easy to trigger. In `println!` and `panic!`,\n+            // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n+            // which the values would be `mem::replace`d on initialization.\n+            // The implementation of `mem::replace` will use SIMD\n+            // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n+            // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n+            // which macOS's dyld disregarded and causing crashes\n+            // (see issues #51794, #51758, #50867, #48866 and #44056).\n+            //\n+            // To workaround the bug, we trick LLVM into not increasing\n+            // the global's alignment by explicitly assigning a section to it\n+            // (equivalent to automatically generating a `#[link_section]` attribute).\n+            // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n+            // of `lib/IR/Globals.cpp` for why this works.\n+            //\n+            // When the alignment is not increased, the optimized `mem::replace`\n+            // will use load-unaligned instructions instead, and thus avoiding the crash.\n+            //\n+            // We could remove this hack whenever we decide to drop macOS 10.10 support.\n+            if self.tcx.sess.target.options.is_like_osx {\n+                // The `inspect` method is okay here because we checked relocations, and\n+                // because we are doing this access to inspect the final interpreter state\n+                // (not as part of the interpreter execution).\n+                //\n+                // FIXME: This check requires that the (arbitrary) value of undefined bytes\n+                // happens to be zero. Instead, we should only check the value of defined bytes\n+                // and set all undefined bytes to zero if this allocation is headed for the\n+                // BSS.\n+                unimplemented!();\n+            }\n+        }\n+\n+        // Wasm statics with custom link sections get special treatment as they\n+        // go into custom sections of the wasm executable.\n+        if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+            if let Some(_section) = attrs.link_section {\n+                unimplemented!();\n+            }\n+        } else {\n+            // TODO(antoyo): set link section.\n+        }\n+\n+        if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n+            self.add_used_global(global.to_rvalue());\n+        }\n+    }\n+\n+    /// Add a global value to a list to be stored in the `llvm.used` variable, an array of i8*.\n+    fn add_used_global(&self, _global: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+}\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n+        let global =\n+            match kind {\n+                Some(kind) if !self.tcx.sess.fewer_names() => {\n+                    let name = self.generate_local_symbol_name(kind);\n+                    // TODO(antoyo): check if it's okay that TLS is off here.\n+                    // TODO(antoyo): check if it's okay that link_section is None here.\n+                    // TODO(antoyo): set alignment here as well.\n+                    let global = self.define_global(&name[..], self.val_ty(cv), false, None);\n+                    // TODO(antoyo): set linkage.\n+                    global\n+                }\n+                _ => {\n+                    let typ = self.val_ty(cv).get_aligned(align.bytes());\n+                    let global = self.declare_unnamed_global(typ);\n+                    global\n+                },\n+            };\n+        // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n+        // globally.\n+        global.global_set_initializer_value(cv);\n+        // TODO(antoyo): set unnamed address.\n+        global.get_address(None)\n+    }\n+\n+    pub fn get_static(&self, def_id: DefId) -> LValue<'gcc> {\n+        let instance = Instance::mono(self.tcx, def_id);\n+        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n+        if let Some(&global) = self.instances.borrow().get(&instance) {\n+            return global;\n+        }\n+\n+        let defined_in_current_codegen_unit =\n+            self.codegen_unit.items().contains_key(&MonoItem::Static(def_id));\n+        assert!(\n+            !defined_in_current_codegen_unit,\n+            \"consts::get_static() should always hit the cache for \\\n+                 statics defined in the same CGU, but did not for `{:?}`\",\n+            def_id\n+        );\n+\n+        let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n+        let sym = self.tcx.symbol_name(instance).name;\n+\n+        let global =\n+            if let Some(def_id) = def_id.as_local() {\n+                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                let llty = self.layout_of(ty).gcc_type(self, true);\n+                // FIXME: refactor this to work without accessing the HIR\n+                let global = match self.tcx.hir().get(id) {\n+                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n+                        if let Some(global) = self.get_declared_value(&sym) {\n+                            if self.val_ty(global) != self.type_ptr_to(llty) {\n+                                span_bug!(span, \"Conflicting types for static\");\n+                            }\n+                        }\n+\n+                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+                        let global = self.declare_global(&sym, llty, is_tls, fn_attrs.link_section);\n+\n+                        if !self.tcx.is_reachable_non_generic(def_id) {\n+                            // TODO(antoyo): set visibility.\n+                        }\n+\n+                        global\n+                    }\n+\n+                    Node::ForeignItem(&hir::ForeignItem {\n+                        span,\n+                        kind: hir::ForeignItemKind::Static(..),\n+                        ..\n+                    }) => {\n+                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n+                        check_and_apply_linkage(&self, &fn_attrs, ty, sym, span)\n+                    }\n+\n+                    item => bug!(\"get_static: expected static, found {:?}\", item),\n+                };\n+\n+                global\n+            }\n+            else {\n+                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n+\n+                let attrs = self.tcx.codegen_fn_attrs(def_id);\n+                let span = self.tcx.def_span(def_id);\n+                let global = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n+\n+                let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+                // If this assertion triggers, there's something wrong with commandline\n+                // argument validation.\n+                debug_assert!(\n+                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                        && self.tcx.sess.target.options.is_like_msvc\n+                        && self.tcx.sess.opts.cg.prefer_dynamic)\n+                );\n+\n+                if needs_dll_storage_attr {\n+                    // This item is external but not foreign, i.e., it originates from an external Rust\n+                    // crate. Since we don't know whether this crate will be linked dynamically or\n+                    // statically in the final application, we always mark such symbols as 'dllimport'.\n+                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                    // to make things work.\n+                    //\n+                    // However, in some scenarios we defer emission of statics to downstream\n+                    // crates, so there are cases where a static with an upstream DefId\n+                    // is actually present in the current crate. We can find out via the\n+                    // is_codegened_item query.\n+                    if !self.tcx.is_codegened_item(def_id) {\n+                        unimplemented!();\n+                    }\n+                }\n+                global\n+            };\n+\n+        // TODO(antoyo): set dll storage class.\n+\n+        self.instances.borrow_mut().insert(instance, global);\n+        global\n+    }\n+}\n+\n+pub fn const_alloc_to_gcc<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, alloc: &Allocation) -> RValue<'gcc> {\n+    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let dl = cx.data_layout();\n+    let pointer_size = dl.pointer_size.bytes() as usize;\n+\n+    let mut next_offset = 0;\n+    for &(offset, alloc_id) in alloc.relocations().iter() {\n+        let offset = offset.bytes();\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // is within the bounds of the allocation, and it doesn't affect interpreter execution\n+            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n+            // some arbitrary byte value.\n+            //\n+            // FIXME: relay undef bytes to codegen as undef const bytes\n+            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n+            llvals.push(cx.const_bytes(bytes));\n+        }\n+        let ptr_offset =\n+            read_target_uint( dl.endian,\n+                // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n+                // affect interpreter execution (we inspect the result after interpreter execution),\n+                // and we properly interpret the relocation as a relocation pointer offset.\n+                alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n+            )\n+            .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n+            as u64;\n+        llvals.push(cx.scalar_to_backend(\n+            InterpScalar::from_pointer(\n+                interpret::Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n+                &cx.tcx,\n+            ),\n+            abi::Scalar { value: Primitive::Pointer, valid_range: WrappingRange { start: 0, end: !0 } },\n+            cx.type_i8p(),\n+        ));\n+        next_offset = offset + pointer_size;\n+    }\n+    if alloc.len() >= next_offset {\n+        let range = next_offset..alloc.len();\n+        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n+        // inspect the result after interpreter execution). Any undef byte is replaced with some\n+        // arbitrary byte value.\n+        //\n+        // FIXME: relay undef bytes to codegen as undef const bytes\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n+        llvals.push(cx.const_bytes(bytes));\n+    }\n+\n+    cx.const_struct(&llvals, true)\n+}\n+\n+pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id: DefId) -> Result<(RValue<'gcc>, &'tcx Allocation), ErrorHandled> {\n+    let alloc = cx.tcx.eval_static_initializer(def_id)?;\n+    Ok((const_alloc_to_gcc(cx, alloc), alloc))\n+}\n+\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n+    let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    if let Some(linkage) = attrs.linkage {\n+        // If this is a static with a linkage specified, then we need to handle\n+        // it a little specially. The typesystem prevents things like &T and\n+        // extern \"C\" fn() from being non-null, so we can't just declare a\n+        // static and call it a day. Some linkages (like weak) will make it such\n+        // that the static actually has a null value.\n+        let llty2 =\n+            if let ty::RawPtr(ref mt) = ty.kind() {\n+                cx.layout_of(mt.ty).gcc_type(cx, true)\n+            }\n+            else {\n+                cx.sess().span_fatal(\n+                    span,\n+                    \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n+                )\n+            };\n+        // Declare a symbol `foo` with the desired linkage.\n+        let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));\n+\n+        // Declare an internal global `extern_with_linkage_foo` which\n+        // is initialized with the address of `foo`.  If `foo` is\n+        // discarded during linking (for example, if `foo` has weak\n+        // linkage and there are no definitions), then\n+        // `extern_with_linkage_foo` will instead be initialized to\n+        // zero.\n+        let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+        real_name.push_str(&sym);\n+        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n+        // TODO(antoyo): set linkage.\n+        global2.global_set_initializer_value(global1.get_address(None));\n+        // TODO(antoyo): use global_set_initializer() when it will work.\n+        global2\n+    }\n+    else {\n+        // Generate an external declaration.\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        cx.declare_global(&sym, llty, is_tls, attrs.link_section)\n+    }\n+}"}, {"sha": "7677ade7314e52d1ce8af86ad1fbc54d3b45c39b", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,475 @@\n+use std::cell::{Cell, RefCell};\n+\n+use gccjit::{\n+    Block,\n+    Context,\n+    CType,\n+    Function,\n+    FunctionType,\n+    LValue,\n+    RValue,\n+    Struct,\n+    Type,\n+};\n+use rustc_codegen_ssa::base::wants_msvc_seh;\n+use rustc_codegen_ssa::traits::{\n+    BackendTypes,\n+    MiscMethods,\n+};\n+use rustc_data_structures::base_n;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_middle::span_bug;\n+use rustc_middle::mir::mono::CodegenUnit;\n+use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_session::Session;\n+use rustc_span::{Span, Symbol};\n+use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n+use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n+\n+use crate::callee::get_fn;\n+use crate::declare::mangle_name;\n+\n+#[derive(Clone)]\n+pub struct FuncSig<'gcc> {\n+    pub params: Vec<Type<'gcc>>,\n+    pub return_type: Type<'gcc>,\n+}\n+\n+pub struct CodegenCx<'gcc, 'tcx> {\n+    pub check_overflow: bool,\n+    pub codegen_unit: &'tcx CodegenUnit<'tcx>,\n+    pub context: &'gcc Context<'gcc>,\n+\n+    // TODO(antoyo): First set it to a dummy block to avoid using Option?\n+    pub current_block: RefCell<Option<Block<'gcc>>>,\n+    pub current_func: RefCell<Option<Function<'gcc>>>,\n+    pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n+\n+    pub tls_model: gccjit::TlsModel,\n+\n+    pub bool_type: Type<'gcc>,\n+    pub i8_type: Type<'gcc>,\n+    pub i16_type: Type<'gcc>,\n+    pub i32_type: Type<'gcc>,\n+    pub i64_type: Type<'gcc>,\n+    pub i128_type: Type<'gcc>,\n+    pub isize_type: Type<'gcc>,\n+\n+    pub u8_type: Type<'gcc>,\n+    pub u16_type: Type<'gcc>,\n+    pub u32_type: Type<'gcc>,\n+    pub u64_type: Type<'gcc>,\n+    pub u128_type: Type<'gcc>,\n+    pub usize_type: Type<'gcc>,\n+\n+    pub int_type: Type<'gcc>,\n+    pub uint_type: Type<'gcc>,\n+    pub long_type: Type<'gcc>,\n+    pub ulong_type: Type<'gcc>,\n+    pub ulonglong_type: Type<'gcc>,\n+    pub sizet_type: Type<'gcc>,\n+\n+    pub float_type: Type<'gcc>,\n+    pub double_type: Type<'gcc>,\n+\n+    pub linkage: Cell<FunctionType>,\n+    pub scalar_types: RefCell<FxHashMap<Ty<'tcx>, Type<'gcc>>>,\n+    pub types: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), Type<'gcc>>>,\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n+\n+    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n+\n+    /// Cache instances of monomorphic and polymorphic items\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n+    /// Cache function instances of monomorphic and polymorphic items\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    /// Cache generated vtables\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n+\n+    /// Cache of emitted const globals (value -> global)\n+    pub const_globals: RefCell<FxHashMap<RValue<'gcc>, RValue<'gcc>>>,\n+\n+    /// Cache of constant strings,\n+    pub const_cstr_cache: RefCell<FxHashMap<Symbol, LValue<'gcc>>>,\n+\n+    /// Cache of globals.\n+    pub globals: RefCell<FxHashMap<String, RValue<'gcc>>>,\n+\n+    /// A counter that is used for generating local symbol names\n+    local_gen_sym_counter: Cell<usize>,\n+    pub global_gen_sym_counter: Cell<usize>,\n+\n+    eh_personality: Cell<Option<RValue<'gcc>>>,\n+\n+    pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n+\n+    /// NOTE: a hack is used because the rustc API is not suitable to libgccjit and as such,\n+    /// `const_undef()` returns struct as pointer so that they can later be assigned a value.\n+    /// As such, this set remembers which of these pointers were returned by this function so that\n+    /// they can be deferenced later.\n+    /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n+    pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+}\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn new(context: &'gcc Context<'gcc>, codegen_unit: &'tcx CodegenUnit<'tcx>, tcx: TyCtxt<'tcx>) -> Self {\n+        let check_overflow = tcx.sess.overflow_checks();\n+        // TODO(antoyo): fix this mess. libgccjit seems to return random type when using new_int_type().\n+        let isize_type = context.new_c_type(CType::LongLong);\n+        let usize_type = context.new_c_type(CType::ULongLong);\n+        let bool_type = context.new_type::<bool>();\n+        let i8_type = context.new_type::<i8>();\n+        let i16_type = context.new_type::<i16>();\n+        let i32_type = context.new_type::<i32>();\n+        let i64_type = context.new_c_type(CType::LongLong);\n+        let i128_type = context.new_c_type(CType::Int128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n+        let u8_type = context.new_type::<u8>();\n+        let u16_type = context.new_type::<u16>();\n+        let u32_type = context.new_type::<u32>();\n+        let u64_type = context.new_c_type(CType::ULongLong);\n+        let u128_type = context.new_c_type(CType::UInt128t).get_aligned(8); // TODO(antoyo): should the alignment be hard-coded?\n+\n+        let tls_model = to_gcc_tls_mode(tcx.sess.tls_model());\n+\n+        let float_type = context.new_type::<f32>();\n+        let double_type = context.new_type::<f64>();\n+\n+        let int_type = context.new_c_type(CType::Int);\n+        let uint_type = context.new_c_type(CType::UInt);\n+        let long_type = context.new_c_type(CType::Long);\n+        let ulong_type = context.new_c_type(CType::ULong);\n+        let ulonglong_type = context.new_c_type(CType::ULongLong);\n+        let sizet_type = context.new_c_type(CType::SizeT);\n+\n+        assert_eq!(isize_type, i64_type);\n+        assert_eq!(usize_type, u64_type);\n+\n+        let mut functions = FxHashMap::default();\n+        let builtins = [\n+            \"__builtin_unreachable\", \"abort\", \"__builtin_expect\", \"__builtin_add_overflow\", \"__builtin_mul_overflow\",\n+            \"__builtin_saddll_overflow\", /*\"__builtin_sadd_overflow\",*/ \"__builtin_smulll_overflow\", /*\"__builtin_smul_overflow\",*/\n+            \"__builtin_ssubll_overflow\", /*\"__builtin_ssub_overflow\",*/ \"__builtin_sub_overflow\", \"__builtin_uaddll_overflow\",\n+            \"__builtin_uadd_overflow\", \"__builtin_umulll_overflow\", \"__builtin_umul_overflow\", \"__builtin_usubll_overflow\",\n+            \"__builtin_usub_overflow\", \"sqrtf\", \"sqrt\", \"__builtin_powif\", \"__builtin_powi\", \"sinf\", \"sin\", \"cosf\", \"cos\",\n+            \"powf\", \"pow\", \"expf\", \"exp\", \"exp2f\", \"exp2\", \"logf\", \"log\", \"log10f\", \"log10\", \"log2f\", \"log2\", \"fmaf\",\n+            \"fma\", \"fabsf\", \"fabs\", \"fminf\", \"fmin\", \"fmaxf\", \"fmax\", \"copysignf\", \"copysign\", \"floorf\", \"floor\", \"ceilf\",\n+            \"ceil\", \"truncf\", \"trunc\", \"rintf\", \"rint\", \"nearbyintf\", \"nearbyint\", \"roundf\", \"round\",\n+            \"__builtin_expect_with_probability\",\n+        ];\n+\n+        for builtin in builtins.iter() {\n+            functions.insert(builtin.to_string(), context.get_builtin_function(builtin));\n+        }\n+\n+        Self {\n+            check_overflow,\n+            codegen_unit,\n+            context,\n+            current_block: RefCell::new(None),\n+            current_func: RefCell::new(None),\n+            normal_function_addresses: Default::default(),\n+            functions: RefCell::new(functions),\n+\n+            tls_model,\n+\n+            bool_type,\n+            i8_type,\n+            i16_type,\n+            i32_type,\n+            i64_type,\n+            i128_type,\n+            isize_type,\n+            usize_type,\n+            u8_type,\n+            u16_type,\n+            u32_type,\n+            u64_type,\n+            u128_type,\n+            int_type,\n+            uint_type,\n+            long_type,\n+            ulong_type,\n+            ulonglong_type,\n+            sizet_type,\n+\n+            float_type,\n+            double_type,\n+\n+            linkage: Cell::new(FunctionType::Internal),\n+            instances: Default::default(),\n+            function_instances: Default::default(),\n+            vtables: Default::default(),\n+            const_globals: Default::default(),\n+            const_cstr_cache: Default::default(),\n+            globals: Default::default(),\n+            scalar_types: Default::default(),\n+            types: Default::default(),\n+            tcx,\n+            struct_types: Default::default(),\n+            types_with_fields_to_set: Default::default(),\n+            local_gen_sym_counter: Cell::new(0),\n+            global_gen_sym_counter: Cell::new(0),\n+            eh_personality: Cell::new(None),\n+            pointee_infos: Default::default(),\n+            structs_as_pointer: Default::default(),\n+        }\n+    }\n+\n+    pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n+        let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n+        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+            \"{:?} ({:?}) is not a function\", value, value.get_type());\n+        function\n+    }\n+\n+    pub fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+}\n+\n+impl<'gcc, 'tcx> BackendTypes for CodegenCx<'gcc, 'tcx> {\n+    type Value = RValue<'gcc>;\n+    type Function = RValue<'gcc>;\n+\n+    type BasicBlock = Block<'gcc>;\n+    type Type = Type<'gcc>;\n+    type Funclet = (); // TODO(antoyo)\n+\n+    type DIScope = (); // TODO(antoyo)\n+    type DILocation = (); // TODO(antoyo)\n+    type DIVariable = (); // TODO(antoyo)\n+}\n+\n+impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn vtables(&self) -> &RefCell<FxHashMap<(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>> {\n+        &self.vtables\n+    }\n+\n+    fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n+        let func = get_fn(self, instance);\n+        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n+        func\n+    }\n+\n+    fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n+        let func = get_fn(self, instance);\n+        let func = self.rvalue_as_function(func);\n+        let ptr = func.get_address(None);\n+\n+        // TODO(antoyo): don't do this twice: i.e. in declare_fn and here.\n+        // FIXME(antoyo): the rustc API seems to call get_fn_addr() when not needed (e.g. for FFI).\n+\n+        self.normal_function_addresses.borrow_mut().insert(ptr);\n+\n+        ptr\n+    }\n+\n+    fn eh_personality(&self) -> RValue<'gcc> {\n+        // The exception handling personality function.\n+        //\n+        // If our compilation unit has the `eh_personality` lang item somewhere\n+        // within it, then we just need to codegen that. Otherwise, we're\n+        // building an rlib which will depend on some upstream implementation of\n+        // this function, so we just codegen a generic reference to it. We don't\n+        // specify any of the types for the function, we just make it a symbol\n+        // that LLVM can later use.\n+        //\n+        // Note that MSVC is a little special here in that we don't use the\n+        // `eh_personality` lang item at all. Currently LLVM has support for\n+        // both Dwarf and SEH unwind mechanisms for MSVC targets and uses the\n+        // *name of the personality function* to decide what kind of unwind side\n+        // tables/landing pads to emit. It looks like Dwarf is used by default,\n+        // injecting a dependency on the `_Unwind_Resume` symbol for resuming\n+        // an \"exception\", but for MSVC we want to force SEH. This means that we\n+        // can't actually have the personality function be our standard\n+        // `rust_eh_personality` function, but rather we wired it up to the\n+        // CRT's custom personality function, which forces LLVM to consider\n+        // landing pads as \"landing pads for SEH\".\n+        if let Some(llpersonality) = self.eh_personality.get() {\n+            return llpersonality;\n+        }\n+        let tcx = self.tcx;\n+        let llfn = match tcx.lang_items().eh_personality() {\n+            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n+                ty::Instance::resolve(\n+                    tcx,\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    tcx.intern_substs(&[]),\n+                )\n+                .unwrap().unwrap(),\n+            ),\n+            _ => {\n+                let _name = if wants_msvc_seh(self.sess()) {\n+                    \"__CxxFrameHandler3\"\n+                } else {\n+                    \"rust_eh_personality\"\n+                };\n+                //let func = self.declare_func(name, self.type_i32(), &[], true);\n+                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n+                // unwinding support is added.\n+                self.context.new_rvalue_from_int(self.int_type, 0)\n+            }\n+        };\n+        // TODO(antoyo): apply target cpu attributes.\n+        self.eh_personality.set(Some(llfn));\n+        llfn\n+    }\n+\n+    fn sess(&self) -> &Session {\n+        &self.tcx.sess\n+    }\n+\n+    fn check_overflow(&self) -> bool {\n+        self.check_overflow\n+    }\n+\n+    fn codegen_unit(&self) -> &'tcx CodegenUnit<'tcx> {\n+        self.codegen_unit\n+    }\n+\n+    fn used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n+        unimplemented!();\n+    }\n+\n+    fn set_frame_pointer_type(&self, _llfn: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn apply_target_cpu_attr(&self, _llfn: RValue<'gcc>) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn create_used_variable(&self) {\n+        unimplemented!();\n+    }\n+\n+    fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n+        if self.get_declared_value(\"main\").is_none() {\n+            Some(self.declare_cfn(\"main\", fn_type))\n+        }\n+        else {\n+            // If the symbol already exists, it is an error: for example, the user wrote\n+            // #[no_mangle] extern \"C\" fn main(..) {..}\n+            // instead of #[start]\n+            None\n+        }\n+    }\n+\n+    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n+        unimplemented!()\n+    }\n+\n+    fn create_compiler_used_variable(&self) {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'gcc, 'tcx> HasDataLayout for CodegenCx<'gcc, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'gcc, 'tcx> HasTargetSpec for CodegenCx<'gcc, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.tcx.sess.target\n+    }\n+}\n+\n+impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    type LayoutOfResult = TyAndLayout<'tcx>;\n+\n+    #[inline]\n+    fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n+        if let LayoutError::SizeOverflow(_) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n+        }\n+    }\n+}\n+\n+impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            match fn_abi_request {\n+                FnAbiRequest::OfFnPtr { sig, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n+                        sig,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+                FnAbiRequest::OfInstance { instance, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n+                        instance,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'gcc> HasParamEnv<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n+    /// Generates a new symbol name with the given prefix. This symbol name must\n+    /// only be used for definitions with `internal` or `private` linkage.\n+    pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n+        let idx = self.local_gen_sym_counter.get();\n+        self.local_gen_sym_counter.set(idx + 1);\n+        // Include a '.' character, so there can be no accidental conflicts with\n+        // user defined names\n+        let mut name = String::with_capacity(prefix.len() + 6);\n+        name.push_str(prefix);\n+        name.push_str(\".\");\n+        base_n::push_str(idx as u128, base_n::ALPHANUMERIC_ONLY, &mut name);\n+        name\n+    }\n+}\n+\n+pub fn unit_name<'tcx>(codegen_unit: &CodegenUnit<'tcx>) -> String {\n+    let name = &codegen_unit.name().to_string();\n+    mangle_name(&name.replace('-', \"_\"))\n+}\n+\n+fn to_gcc_tls_mode(tls_model: TlsModel) -> gccjit::TlsModel {\n+    match tls_model {\n+        TlsModel::GeneralDynamic => gccjit::TlsModel::GlobalDynamic,\n+        TlsModel::LocalDynamic => gccjit::TlsModel::LocalDynamic,\n+        TlsModel::InitialExec => gccjit::TlsModel::InitialExec,\n+        TlsModel::LocalExec => gccjit::TlsModel::LocalExec,\n+    }\n+}"}, {"sha": "872fc2472e223d68f6deccd853e37e653cd60dc4", "filename": "compiler/rustc_codegen_gcc/src/coverageinfo.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcoverageinfo.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,69 @@\n+use gccjit::RValue;\n+use rustc_codegen_ssa::traits::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::coverage::{\n+    CodeRegion,\n+    CounterValueReference,\n+    ExpressionOperandId,\n+    InjectedExpressionId,\n+    Op,\n+};\n+use rustc_middle::ty::Instance;\n+\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+\n+impl<'a, 'gcc, 'tcx> CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn set_function_source_hash(\n+        &mut self,\n+        _instance: Instance<'tcx>,\n+        _function_source_hash: u64,\n+    ) -> bool {\n+        unimplemented!();\n+    }\n+\n+    fn add_coverage_counter(&mut self, _instance: Instance<'tcx>, _id: CounterValueReference, _region: CodeRegion) -> bool {\n+        // TODO(antoyo)\n+        false\n+    }\n+\n+    fn add_coverage_counter_expression(&mut self, _instance: Instance<'tcx>, _id: InjectedExpressionId, _lhs: ExpressionOperandId, _op: Op, _rhs: ExpressionOperandId, _region: Option<CodeRegion>) -> bool {\n+        // TODO(antoyo)\n+        false\n+    }\n+\n+    fn add_coverage_unreachable(&mut self, _instance: Instance<'tcx>, _region: CodeRegion) -> bool {\n+        // TODO(antoyo)\n+        false\n+    }\n+}\n+\n+impl<'gcc, 'tcx> CoverageInfoMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn coverageinfo_finalize(&self) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn get_pgo_func_name_var(&self, _instance: Instance<'tcx>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    /// Functions with MIR-based coverage are normally codegenned _only_ if\n+    /// called. LLVM coverage tools typically expect every function to be\n+    /// defined (even if unused), with at least one call to LLVM intrinsic\n+    /// `instrprof.increment`.\n+    ///\n+    /// Codegen a small function that will never be called, with one counter\n+    /// that will never be incremented.\n+    ///\n+    /// For used/called functions, the coverageinfo was already added to the\n+    /// `function_coverage_map` (keyed by function `Instance`) during codegen.\n+    /// But in this case, since the unused function was _not_ previously\n+    /// codegenned, collect the coverage `CodeRegion`s from the MIR and add\n+    /// them. The first `CodeRegion` is used to add a single counter, with the\n+    /// same counter ID used in the injected `instrprof.increment` intrinsic\n+    /// call. Since the function is never called, all other `CodeRegion`s can be\n+    /// added as `unreachable_region`s.\n+    fn define_unused_fn(&self, _def_id: DefId) {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "4d3b4f04badec86dd9149a9421036a3c81e52518", "filename": "compiler/rustc_codegen_gcc/src/debuginfo.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,62 @@\n+use gccjit::RValue;\n+use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, VariableKind};\n+use rustc_codegen_ssa::traits::{DebugInfoBuilderMethods, DebugInfoMethods};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{Instance, Ty};\n+use rustc_span::{SourceFile, Span, Symbol};\n+use rustc_target::abi::Size;\n+use rustc_target::abi::call::FnAbi;\n+\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+\n+impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn dbg_var_addr(&mut self, _dbg_var: Self::DIVariable, _scope_metadata: Self::DIScope, _variable_alloca: Self::Value, _direct_offset: Size, _indirect_offsets: &[Size]) {\n+        unimplemented!();\n+    }\n+\n+    fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n+        // TODO(antoyo): insert reference to gdb debug scripts section global.\n+    }\n+\n+    fn set_var_name(&mut self, _value: RValue<'gcc>, _name: &str) {\n+        unimplemented!();\n+    }\n+\n+    fn set_dbg_loc(&mut self, _dbg_loc: Self::DILocation) {\n+        unimplemented!();\n+    }\n+}\n+\n+impl<'gcc, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn create_vtable_metadata(&self, _ty: Ty<'tcx>, _vtable: Self::Value) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn create_function_debug_context(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _llfn: RValue<'gcc>, _mir: &mir::Body<'tcx>) -> Option<FunctionDebugContext<Self::DIScope, Self::DILocation>> {\n+        // TODO(antoyo)\n+        None\n+    }\n+\n+    fn extend_scope_to_file(&self, _scope_metadata: Self::DIScope, _file: &SourceFile) -> Self::DIScope {\n+        unimplemented!();\n+    }\n+\n+    fn debuginfo_finalize(&self) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn create_dbg_var(&self, _variable_name: Symbol, _variable_type: Ty<'tcx>, _scope_metadata: Self::DIScope, _variable_kind: VariableKind, _span: Span) -> Self::DIVariable {\n+        unimplemented!();\n+    }\n+\n+    fn dbg_scope_fn(&self, _instance: Instance<'tcx>, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _maybe_definition_llfn: Option<RValue<'gcc>>) -> Self::DIScope {\n+        unimplemented!();\n+    }\n+\n+    fn dbg_loc(&self, _scope: Self::DIScope, _inlined_at: Option<Self::DILocation>, _span: Span) -> Self::DILocation {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "b79a50d1eee2eebf1beaa11503bd032b9b200142", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,144 @@\n+use gccjit::{Function, FunctionType, GlobalKind, LValue, RValue, Type};\n+use rustc_codegen_ssa::traits::BaseTypeMethods;\n+use rustc_middle::ty::Ty;\n+use rustc_span::Symbol;\n+use rustc_target::abi::call::FnAbi;\n+\n+use crate::abi::FnAbiGccExt;\n+use crate::context::{CodegenCx, unit_name};\n+use crate::intrinsic::llvm;\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        if self.globals.borrow().contains_key(name) {\n+            let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n+            let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n+            if is_tls {\n+                global.set_tls_model(self.tls_model);\n+            }\n+            if let Some(link_section) = link_section {\n+                global.set_link_section(&link_section.as_str());\n+            }\n+            global\n+        }\n+        else {\n+            self.declare_global(name, ty, is_tls, link_section)\n+        }\n+    }\n+\n+    pub fn declare_unnamed_global(&self, ty: Type<'gcc>) -> LValue<'gcc> {\n+        let index = self.global_gen_sym_counter.get();\n+        self.global_gen_sym_counter.set(index + 1);\n+        let name = format!(\"global_{}_{}\", index, unit_name(&self.codegen_unit));\n+        self.context.new_global(None, GlobalKind::Exported, ty, &name)\n+    }\n+\n+    pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, linkage, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n+        global\n+    }\n+\n+    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n+        self.linkage.set(FunctionType::Exported);\n+        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n+    }*/\n+\n+    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, GlobalKind::Exported, ty, name);\n+        if is_tls {\n+            global.set_tls_model(self.tls_model);\n+        }\n+        if let Some(link_section) = link_section {\n+            global.set_link_section(&link_section.as_str());\n+        }\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n+        global\n+    }\n+\n+    pub fn declare_private_global(&self, name: &str, ty: Type<'gcc>) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, GlobalKind::Internal, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n+        global\n+    }\n+\n+    pub fn declare_cfn(&self, name: &str, _fn_type: Type<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): use the fn_type parameter.\n+        let const_string = self.context.new_type::<u8>().make_pointer().make_pointer();\n+        let return_type = self.type_i32();\n+        let variadic = false;\n+        self.linkage.set(FunctionType::Exported);\n+        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, &[self.type_i32(), const_string], variadic);\n+        // NOTE: it is needed to set the current_func here as well, because get_fn() is not called\n+        // for the main function.\n+        *self.current_func.borrow_mut() = Some(func);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n+    }\n+\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+        let (return_type, params, variadic) = fn_abi.gcc_type(self);\n+        let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n+    }\n+\n+    pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        self.get_or_insert_global(name, ty, is_tls, link_section)\n+    }\n+\n+    pub fn get_declared_value(&self, name: &str) -> Option<RValue<'gcc>> {\n+        // TODO(antoyo): use a different field than globals, because this seems to return a function?\n+        self.globals.borrow().get(name).cloned()\n+    }\n+}\n+\n+/// Declare a function.\n+///\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing Value instead.\n+fn declare_raw_fn<'gcc>(cx: &CodegenCx<'gcc, '_>, name: &str, _callconv: () /*llvm::CallConv*/, return_type: Type<'gcc>, param_types: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+    if name.starts_with(\"llvm.\") {\n+        return llvm::intrinsic(name, cx);\n+    }\n+    let func =\n+        if cx.functions.borrow().contains_key(name) {\n+            *cx.functions.borrow().get(name).expect(\"function\")\n+        }\n+        else {\n+            let params: Vec<_> = param_types.into_iter().enumerate()\n+                .map(|(index, param)| cx.context.new_parameter(None, *param, &format!(\"param{}\", index))) // TODO(antoyo): set name.\n+                .collect();\n+            let func = cx.context.new_function(None, cx.linkage.get(), return_type, &params, mangle_name(name), variadic);\n+            cx.functions.borrow_mut().insert(name.to_string(), func);\n+            func\n+        };\n+\n+    // TODO(antoyo): set function calling convention.\n+    // TODO(antoyo): set unnamed address.\n+    // TODO(antoyo): set no red zone function attribute.\n+    // TODO(antoyo): set attributes for optimisation.\n+    // TODO(antoyo): set attributes for non lazy bind.\n+\n+    // FIXME(antoyo): invalid cast.\n+    func\n+}\n+\n+// FIXME(antoyo): this is a hack because libgccjit currently only supports alpha, num and _.\n+// Unsupported characters: `$` and `.`.\n+pub fn mangle_name(name: &str) -> String {\n+    name.replace(|char: char| {\n+        if !char.is_alphanumeric() && char != '_' {\n+            debug_assert!(\"$.\".contains(char), \"Unsupported char in function name: {}\", char);\n+            true\n+        }\n+        else {\n+            false\n+        }\n+    }, \"_\")\n+}"}, {"sha": "b074febc521ebe03263fadb044fed62c48759900", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/llvm.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,22 @@\n+use gccjit::Function;\n+\n+use crate::context::CodegenCx;\n+\n+pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    let _gcc_name =\n+        match name {\n+            \"llvm.x86.xgetbv\" => {\n+                let gcc_name = \"__builtin_trap\";\n+                let func = cx.context.get_builtin_function(gcc_name);\n+                cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+                return func;\n+            },\n+            // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n+            \"llvm.x86.sse2.cmp.pd\" => \"__builtin_ia32_cmppd\",\n+            \"llvm.x86.sse2.movmsk.pd\" => \"__builtin_ia32_movmskpd\",\n+            \"llvm.x86.sse2.pmovmskb.128\" => \"__builtin_ia32_pmovmskb128\",\n+            _ => unimplemented!(\"unsupported LLVM intrinsic {}\", name)\n+        };\n+\n+    unimplemented!();\n+}"}, {"sha": "375d422cb25c40608565b752f0b555caf54425a4", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "added", "additions": 1067, "deletions": 0, "changes": 1067, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,1067 @@\n+pub mod llvm;\n+mod simd;\n+\n+use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp};\n+use rustc_codegen_ssa::MemFlags;\n+use rustc_codegen_ssa::base::wants_msvc_seh;\n+use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+use rustc_middle::bug;\n+use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_span::{Span, Symbol, symbol::kw, sym};\n+use rustc_target::abi::HasDataLayout;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use rustc_target::spec::PanicStrategy;\n+\n+use crate::abi::GccType;\n+use crate::builder::Builder;\n+use crate::common::{SignType, TypeReflection};\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+use crate::intrinsic::simd::generic_simd_intrinsic;\n+\n+fn get_simple_intrinsic<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, name: Symbol) -> Option<Function<'gcc>> {\n+    let gcc_name = match name {\n+        sym::sqrtf32 => \"sqrtf\",\n+        sym::sqrtf64 => \"sqrt\",\n+        sym::powif32 => \"__builtin_powif\",\n+        sym::powif64 => \"__builtin_powi\",\n+        sym::sinf32 => \"sinf\",\n+        sym::sinf64 => \"sin\",\n+        sym::cosf32 => \"cosf\",\n+        sym::cosf64 => \"cos\",\n+        sym::powf32 => \"powf\",\n+        sym::powf64 => \"pow\",\n+        sym::expf32 => \"expf\",\n+        sym::expf64 => \"exp\",\n+        sym::exp2f32 => \"exp2f\",\n+        sym::exp2f64 => \"exp2\",\n+        sym::logf32 => \"logf\",\n+        sym::logf64 => \"log\",\n+        sym::log10f32 => \"log10f\",\n+        sym::log10f64 => \"log10\",\n+        sym::log2f32 => \"log2f\",\n+        sym::log2f64 => \"log2\",\n+        sym::fmaf32 => \"fmaf\",\n+        sym::fmaf64 => \"fma\",\n+        sym::fabsf32 => \"fabsf\",\n+        sym::fabsf64 => \"fabs\",\n+        sym::minnumf32 => \"fminf\",\n+        sym::minnumf64 => \"fmin\",\n+        sym::maxnumf32 => \"fmaxf\",\n+        sym::maxnumf64 => \"fmax\",\n+        sym::copysignf32 => \"copysignf\",\n+        sym::copysignf64 => \"copysign\",\n+        sym::floorf32 => \"floorf\",\n+        sym::floorf64 => \"floor\",\n+        sym::ceilf32 => \"ceilf\",\n+        sym::ceilf64 => \"ceil\",\n+        sym::truncf32 => \"truncf\",\n+        sym::truncf64 => \"trunc\",\n+        sym::rintf32 => \"rintf\",\n+        sym::rintf64 => \"rint\",\n+        sym::nearbyintf32 => \"nearbyintf\",\n+        sym::nearbyintf64 => \"nearbyint\",\n+        sym::roundf32 => \"roundf\",\n+        sym::roundf64 => \"round\",\n+        sym::abort => \"abort\",\n+        _ => return None,\n+    };\n+    Some(cx.context.get_builtin_function(&gcc_name))\n+}\n+\n+impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn codegen_intrinsic_call(&mut self, instance: Instance<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, args: &[OperandRef<'tcx, RValue<'gcc>>], llresult: RValue<'gcc>, span: Span) {\n+        let tcx = self.tcx;\n+        let callee_ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n+\n+        let (def_id, substs) = match *callee_ty.kind() {\n+            ty::FnDef(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"expected fn item type, found {}\", callee_ty),\n+        };\n+\n+        let sig = callee_ty.fn_sig(tcx);\n+        let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n+        let arg_tys = sig.inputs();\n+        let ret_ty = sig.output();\n+        let name = tcx.item_name(def_id);\n+        let name_str = &*name.as_str();\n+\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n+\n+        let simple = get_simple_intrinsic(self, name);\n+        let llval =\n+            match name {\n+                _ if simple.is_some() => {\n+                    // FIXME(antoyo): remove this cast when the API supports function.\n+                    let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n+                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                },\n+                sym::likely => {\n+                    self.expect(args[0].immediate(), true)\n+                }\n+                sym::unlikely => {\n+                    self.expect(args[0].immediate(), false)\n+                }\n+                kw::Try => {\n+                    try_intrinsic(\n+                        self,\n+                        args[0].immediate(),\n+                        args[1].immediate(),\n+                        args[2].immediate(),\n+                        llresult,\n+                    );\n+                    return;\n+                }\n+                sym::breakpoint => {\n+                    unimplemented!();\n+                }\n+                sym::va_copy => {\n+                    unimplemented!();\n+                }\n+                sym::va_arg => {\n+                    unimplemented!();\n+                }\n+\n+                sym::volatile_load | sym::unaligned_volatile_load => {\n+                    let tp_ty = substs.type_at(0);\n+                    let mut ptr = args[0].immediate();\n+                    if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                        ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n+                    }\n+                    let load = self.volatile_load(ptr.get_type(), ptr);\n+                    // TODO(antoyo): set alignment.\n+                    self.to_immediate(load, self.layout_of(tp_ty))\n+                }\n+                sym::volatile_store => {\n+                    let dst = args[0].deref(self.cx());\n+                    args[1].val.volatile_store(self, dst);\n+                    return;\n+                }\n+                sym::unaligned_volatile_store => {\n+                    let dst = args[0].deref(self.cx());\n+                    args[1].val.unaligned_volatile_store(self, dst);\n+                    return;\n+                }\n+                sym::prefetch_read_data\n+                    | sym::prefetch_write_data\n+                    | sym::prefetch_read_instruction\n+                    | sym::prefetch_write_instruction => {\n+                        unimplemented!();\n+                    }\n+                sym::ctlz\n+                    | sym::ctlz_nonzero\n+                    | sym::cttz\n+                    | sym::cttz_nonzero\n+                    | sym::ctpop\n+                    | sym::bswap\n+                    | sym::bitreverse\n+                    | sym::rotate_left\n+                    | sym::rotate_right\n+                    | sym::saturating_add\n+                    | sym::saturating_sub => {\n+                        let ty = arg_tys[0];\n+                        match int_type_width_signed(ty, self) {\n+                            Some((width, signed)) => match name {\n+                                sym::ctlz | sym::cttz => {\n+                                    let func = self.current_func.borrow().expect(\"func\");\n+                                    let then_block = func.new_block(\"then\");\n+                                    let else_block = func.new_block(\"else\");\n+                                    let after_block = func.new_block(\"after\");\n+\n+                                    let arg = args[0].immediate();\n+                                    let result = func.new_local(None, arg.get_type(), \"zeros\");\n+                                    let zero = self.cx.context.new_rvalue_zero(arg.get_type());\n+                                    let cond = self.cx.context.new_comparison(None, ComparisonOp::Equals, arg, zero);\n+                                    self.llbb().end_with_conditional(None, cond, then_block, else_block);\n+\n+                                    let zero_result = self.cx.context.new_rvalue_from_long(arg.get_type(), width as i64);\n+                                    then_block.add_assignment(None, result, zero_result);\n+                                    then_block.end_with_jump(None, after_block);\n+\n+                                    // NOTE: since jumps were added in a place\n+                                    // count_leading_zeroes() does not expect, the current blocks\n+                                    // in the state need to be updated.\n+                                    *self.current_block.borrow_mut() = Some(else_block);\n+                                    self.block = Some(else_block);\n+\n+                                    let zeros =\n+                                        match name {\n+                                            sym::ctlz => self.count_leading_zeroes(width, arg),\n+                                            sym::cttz => self.count_trailing_zeroes(width, arg),\n+                                            _ => unreachable!(),\n+                                        };\n+                                    else_block.add_assignment(None, result, zeros);\n+                                    else_block.end_with_jump(None, after_block);\n+\n+                                    // NOTE: since jumps were added in a place rustc does not\n+                                    // expect, the current blocks in the state need to be updated.\n+                                    *self.current_block.borrow_mut() = Some(after_block);\n+                                    self.block = Some(after_block);\n+\n+                                    result.to_rvalue()\n+                                }\n+                                sym::ctlz_nonzero => {\n+                                    self.count_leading_zeroes(width, args[0].immediate())\n+                                },\n+                                sym::cttz_nonzero => {\n+                                    self.count_trailing_zeroes(width, args[0].immediate())\n+                                }\n+                                sym::ctpop => self.pop_count(args[0].immediate()),\n+                                sym::bswap => {\n+                                    if width == 8 {\n+                                        args[0].immediate() // byte swap a u8/i8 is just a no-op\n+                                    }\n+                                    else {\n+                                        // TODO(antoyo): check if it's faster to use string literals and a\n+                                        // match instead of format!.\n+                                        let bswap = self.cx.context.get_builtin_function(&format!(\"__builtin_bswap{}\", width));\n+                                        let mut arg = args[0].immediate();\n+                                        // FIXME(antoyo): this cast should not be necessary. Remove\n+                                        // when having proper sized integer types.\n+                                        let param_type = bswap.get_param(0).to_rvalue().get_type();\n+                                        if param_type != arg.get_type() {\n+                                            arg = self.bitcast(arg, param_type);\n+                                        }\n+                                        self.cx.context.new_call(None, bswap, &[arg])\n+                                    }\n+                                },\n+                                sym::bitreverse => self.bit_reverse(width, args[0].immediate()),\n+                                sym::rotate_left | sym::rotate_right => {\n+                                    // TODO(antoyo): implement using algorithm from:\n+                                    // https://blog.regehr.org/archives/1063\n+                                    // for other platforms.\n+                                    let is_left = name == sym::rotate_left;\n+                                    let val = args[0].immediate();\n+                                    let raw_shift = args[1].immediate();\n+                                    if is_left {\n+                                        self.rotate_left(val, raw_shift, width)\n+                                    }\n+                                    else {\n+                                        self.rotate_right(val, raw_shift, width)\n+                                    }\n+                                },\n+                                sym::saturating_add => {\n+                                    self.saturating_add(args[0].immediate(), args[1].immediate(), signed, width)\n+                                },\n+                                sym::saturating_sub => {\n+                                    self.saturating_sub(args[0].immediate(), args[1].immediate(), signed, width)\n+                                },\n+                                _ => bug!(),\n+                            },\n+                            None => {\n+                                span_invalid_monomorphization_error(\n+                                    tcx.sess,\n+                                    span,\n+                                    &format!(\n+                                        \"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\",\n+                                      name, ty\n+                                    ),\n+                                );\n+                                return;\n+                            }\n+                        }\n+                    }\n+\n+                sym::raw_eq => {\n+                    use rustc_target::abi::Abi::*;\n+                    let tp_ty = substs.type_at(0);\n+                    let layout = self.layout_of(tp_ty).layout;\n+                    let _use_integer_compare = match layout.abi {\n+                        Scalar(_) | ScalarPair(_, _) => true,\n+                        Uninhabited | Vector { .. } => false,\n+                        Aggregate { .. } => {\n+                            // For rusty ABIs, small aggregates are actually passed\n+                            // as `RegKind::Integer` (see `FnAbi::adjust_for_abi`),\n+                            // so we re-use that same threshold here.\n+                            layout.size <= self.data_layout().pointer_size * 2\n+                        }\n+                    };\n+\n+                    let a = args[0].immediate();\n+                    let b = args[1].immediate();\n+                    if layout.size.bytes() == 0 {\n+                        self.const_bool(true)\n+                    }\n+                    /*else if use_integer_compare {\n+                        let integer_ty = self.type_ix(layout.size.bits()); // FIXME(antoyo): LLVM creates an integer of 96 bits for [i32; 3], but gcc doesn't support this, so it creates an integer of 128 bits.\n+                        let ptr_ty = self.type_ptr_to(integer_ty);\n+                        let a_ptr = self.bitcast(a, ptr_ty);\n+                        let a_val = self.load(integer_ty, a_ptr, layout.align.abi);\n+                        let b_ptr = self.bitcast(b, ptr_ty);\n+                        let b_val = self.load(integer_ty, b_ptr, layout.align.abi);\n+                        self.icmp(IntPredicate::IntEQ, a_val, b_val)\n+                    }*/\n+                    else {\n+                        let void_ptr_type = self.context.new_type::<*const ()>();\n+                        let a_ptr = self.bitcast(a, void_ptr_type);\n+                        let b_ptr = self.bitcast(b, void_ptr_type);\n+                        let n = self.context.new_cast(None, self.const_usize(layout.size.bytes()), self.sizet_type);\n+                        let builtin = self.context.get_builtin_function(\"memcmp\");\n+                        let cmp = self.context.new_call(None, builtin, &[a_ptr, b_ptr, n]);\n+                        self.icmp(IntPredicate::IntEQ, cmp, self.const_i32(0))\n+                    }\n+                }\n+\n+                sym::black_box => {\n+                    args[0].val.store(self, result);\n+\n+                    let block = self.llbb();\n+                    let extended_asm = block.add_extended_asm(None, \"\");\n+                    extended_asm.add_input_operand(None, \"r\", result.llval);\n+                    extended_asm.add_clobber(\"memory\");\n+                    extended_asm.set_volatile_flag(true);\n+                    \n+                    // We have copied the value to `result` already.\n+                    return;\n+                }\n+\n+                _ if name_str.starts_with(\"simd_\") => {\n+                    match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n+                        Ok(llval) => llval,\n+                        Err(()) => return,\n+                    }\n+                }\n+\n+                _ => bug!(\"unknown intrinsic '{}'\", name),\n+            };\n+\n+        if !fn_abi.ret.is_ignore() {\n+            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n+                let ptr = self.pointercast(result.llval, ptr_llty);\n+                self.store(llval, ptr, result.align);\n+            }\n+            else {\n+                OperandRef::from_immediate_or_packed_pair(self, llval, result.layout)\n+                    .val\n+                    .store(self, result);\n+            }\n+        }\n+    }\n+\n+    fn abort(&mut self) {\n+        let func = self.context.get_builtin_function(\"abort\");\n+        let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+        self.call(self.type_void(), func, &[], None);\n+    }\n+\n+    fn assume(&mut self, value: Self::Value) {\n+        // TODO(antoyo): switch to asumme when it exists.\n+        // Or use something like this:\n+        // #define __assume(cond) do { if (!(cond)) __builtin_unreachable(); } while (0)\n+        self.expect(value, true);\n+    }\n+\n+    fn expect(&mut self, cond: Self::Value, _expected: bool) -> Self::Value {\n+        // TODO(antoyo)\n+        cond\n+    }\n+\n+    fn sideeffect(&mut self) {\n+        // TODO(antoyo)\n+    }\n+\n+    fn va_start(&mut self, _va_list: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn va_end(&mut self, _va_list: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+}\n+\n+impl<'a, 'gcc, 'tcx> ArgAbiMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n+    fn store_fn_arg(&mut self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>, idx: &mut usize, dst: PlaceRef<'tcx, Self::Value>) {\n+        arg_abi.store_fn_arg(self, idx, dst)\n+    }\n+\n+    fn store_arg(&mut self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>, val: RValue<'gcc>, dst: PlaceRef<'tcx, RValue<'gcc>>) {\n+        arg_abi.store(self, val, dst)\n+    }\n+\n+    fn arg_memory_ty(&self, arg_abi: &ArgAbi<'tcx, Ty<'tcx>>) -> Type<'gcc> {\n+        arg_abi.memory_ty(self)\n+    }\n+}\n+\n+pub trait ArgAbiExt<'gcc, 'tcx> {\n+    fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+    fn store(&self, bx: &mut Builder<'_, 'gcc, 'tcx>, val: RValue<'gcc>, dst: PlaceRef<'tcx, RValue<'gcc>>);\n+    fn store_fn_arg(&self, bx: &mut Builder<'_, 'gcc, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx, RValue<'gcc>>);\n+}\n+\n+impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+    /// Gets the LLVM type for a place of the original Rust type of\n+    /// this argument/return, i.e., the result of `type_of::type_of`.\n+    fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        self.layout.gcc_type(cx, true)\n+    }\n+\n+    /// Stores a direct/indirect value described by this ArgAbi into a\n+    /// place for the original Rust type of this argument/return.\n+    /// Can be used for both storing formal arguments into Rust variables\n+    /// or results of call/invoke instructions into their destinations.\n+    fn store(&self, bx: &mut Builder<'_, 'gcc, 'tcx>, val: RValue<'gcc>, dst: PlaceRef<'tcx, RValue<'gcc>>) {\n+        if self.is_ignore() {\n+            return;\n+        }\n+        if self.is_sized_indirect() {\n+            OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n+        }\n+        else if self.is_unsized_indirect() {\n+            bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n+        }\n+        else if let PassMode::Cast(cast) = self.mode {\n+            // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n+            // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n+            let can_store_through_cast_ptr = false;\n+            if can_store_through_cast_ptr {\n+                let cast_ptr_llty = bx.type_ptr_to(cast.gcc_type(bx));\n+                let cast_dst = bx.pointercast(dst.llval, cast_ptr_llty);\n+                bx.store(val, cast_dst, self.layout.align.abi);\n+            }\n+            else {\n+                // The actual return type is a struct, but the ABI\n+                // adaptation code has cast it into some scalar type.  The\n+                // code that follows is the only reliable way I have\n+                // found to do a transform like i64 -> {i32,i32}.\n+                // Basically we dump the data onto the stack then memcpy it.\n+                //\n+                // Other approaches I tried:\n+                // - Casting rust ret pointer to the foreign type and using Store\n+                //   is (a) unsafe if size of foreign type > size of rust type and\n+                //   (b) runs afoul of strict aliasing rules, yielding invalid\n+                //   assembly under -O (specifically, the store gets removed).\n+                // - Truncating foreign type to correct integral type and then\n+                //   bitcasting to the struct type yields invalid cast errors.\n+\n+                // We instead thus allocate some scratch space...\n+                let scratch_size = cast.size(bx);\n+                let scratch_align = cast.align(bx);\n+                let llscratch = bx.alloca(cast.gcc_type(bx), scratch_align);\n+                bx.lifetime_start(llscratch, scratch_size);\n+\n+                // ... where we first store the value...\n+                bx.store(val, llscratch, scratch_align);\n+\n+                // ... and then memcpy it to the intended destination.\n+                bx.memcpy(\n+                    dst.llval,\n+                    self.layout.align.abi,\n+                    llscratch,\n+                    scratch_align,\n+                    bx.const_usize(self.layout.size.bytes()),\n+                    MemFlags::empty(),\n+                );\n+\n+                bx.lifetime_end(llscratch, scratch_size);\n+            }\n+        }\n+        else {\n+            OperandValue::Immediate(val).store(bx, dst);\n+        }\n+    }\n+\n+    fn store_fn_arg<'a>(&self, bx: &mut Builder<'a, 'gcc, 'tcx>, idx: &mut usize, dst: PlaceRef<'tcx, RValue<'gcc>>) {\n+        let mut next = || {\n+            let val = bx.current_func().get_param(*idx as i32);\n+            *idx += 1;\n+            val.to_rvalue()\n+        };\n+        match self.mode {\n+            PassMode::Ignore => {}\n+            PassMode::Pair(..) => {\n+                OperandValue::Pair(next(), next()).store(bx, dst);\n+            }\n+            PassMode::Indirect { extra_attrs: Some(_), .. } => {\n+                OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n+            }\n+            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n+                let next_arg = next();\n+                self.store(bx, next_arg.to_rvalue(), dst);\n+            }\n+        }\n+    }\n+}\n+\n+fn int_type_width_signed<'gcc, 'tcx>(ty: Ty<'tcx>, cx: &CodegenCx<'gcc, 'tcx>) -> Option<(u64, bool)> {\n+    match ty.kind() {\n+        ty::Int(t) => Some((\n+            match t {\n+                rustc_middle::ty::IntTy::Isize => u64::from(cx.tcx.sess.target.pointer_width),\n+                rustc_middle::ty::IntTy::I8 => 8,\n+                rustc_middle::ty::IntTy::I16 => 16,\n+                rustc_middle::ty::IntTy::I32 => 32,\n+                rustc_middle::ty::IntTy::I64 => 64,\n+                rustc_middle::ty::IntTy::I128 => 128,\n+            },\n+            true,\n+        )),\n+        ty::Uint(t) => Some((\n+            match t {\n+                rustc_middle::ty::UintTy::Usize => u64::from(cx.tcx.sess.target.pointer_width),\n+                rustc_middle::ty::UintTy::U8 => 8,\n+                rustc_middle::ty::UintTy::U16 => 16,\n+                rustc_middle::ty::UintTy::U32 => 32,\n+                rustc_middle::ty::UintTy::U64 => 64,\n+                rustc_middle::ty::UintTy::U128 => 128,\n+            },\n+            false,\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n+    fn bit_reverse(&mut self, width: u64, value: RValue<'gcc>) -> RValue<'gcc> {\n+        let result_type = value.get_type();\n+        let typ = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, typ)\n+            }\n+            else {\n+                value\n+            };\n+\n+        let context = &self.cx.context;\n+        let result =\n+            match width {\n+                8 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0xF0));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0x0F));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 4));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0xCC));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0x33));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0xAA));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0x55));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 1));\n+                    let step3 = self.or(left, right);\n+\n+                    step3\n+                },\n+                16 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0x5555));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0xAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0x3333));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0xCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0x0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0xF0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_int(typ, 0x00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_int(typ, 0xFF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    step4\n+                },\n+                32 => {\n+                    // TODO(antoyo): Refactor with other implementations.\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_long(typ, 0x55555555));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_long(typ, 0xAAAAAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x33333333));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xCCCCCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_long(typ, 0x0F0F0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_long(typ, 0xF0F0F0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_long(typ, 0x00FF00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_long(typ, 0xFF00FF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    // Fifth step.\n+                    let left = self.and(step4, context.new_rvalue_from_long(typ, 0x0000FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 16));\n+                    let right = self.and(step4, context.new_rvalue_from_long(typ, 0xFFFF0000));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 16));\n+                    let step5 = self.or(left, right);\n+\n+                    step5\n+                },\n+                64 => {\n+                    // First step.\n+                    let left = self.shl(value, context.new_rvalue_from_long(typ, 32));\n+                    let right = self.lshr(value, context.new_rvalue_from_long(typ, 32));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x0001FFFF0001FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 15));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xFFFE0000FFFE0000u64 as i64)); // TODO(antoyo): transmute the number instead?\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 17));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.lshr(step2, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.xor(step2, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x003F801F003F801F));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.or(temp, left);\n+                    let step3 = self.xor(left, step2);\n+\n+                    // Fourth step.\n+                    let left = self.lshr(step3, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.xor(step3, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x0E0384210E038421));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.or(temp, left);\n+                    let step4 = self.xor(left, step3);\n+\n+                    // Fifth step.\n+                    let left = self.lshr(step4, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.xor(step4, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x2248884222488842));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.or(temp, left);\n+                    let step5 = self.xor(left, step4);\n+\n+                    step5\n+                },\n+                128 => {\n+                    // TODO(antoyo): find a more efficient implementation?\n+                    let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+                    let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n+                    let low = self.context.new_cast(None, value, self.u64_type);\n+\n+                    let reversed_high = self.bit_reverse(64, high);\n+                    let reversed_low = self.bit_reverse(64, low);\n+\n+                    let new_low = self.context.new_cast(None, reversed_high, typ);\n+                    let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n+\n+                    new_low | new_high\n+                },\n+                _ => {\n+                    panic!(\"cannot bit reverse with width = {}\", width);\n+                },\n+            };\n+\n+        self.context.new_bitcast(None, result, result_type)\n+    }\n+\n+    fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): use width?\n+        let arg_type = arg.get_type();\n+        let count_leading_zeroes =\n+            if arg_type.is_uint(&self.cx) {\n+                \"__builtin_clz\"\n+            }\n+            else if arg_type.is_ulong(&self.cx) {\n+                \"__builtin_clzl\"\n+            }\n+            else if arg_type.is_ulonglong(&self.cx) {\n+                \"__builtin_clzll\"\n+            }\n+            else if width == 128 {\n+                // Algorithm from: https://stackoverflow.com/a/28433850/389119\n+                let array_type = self.context.new_array_type(None, arg_type, 3);\n+                let result = self.current_func()\n+                    .new_local(None, array_type, \"count_loading_zeroes_results\");\n+\n+                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n+                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n+                let low = self.context.new_cast(None, arg, self.u64_type);\n+\n+                let zero = self.context.new_rvalue_zero(self.usize_type);\n+                let one = self.context.new_rvalue_one(self.usize_type);\n+                let two = self.context.new_rvalue_from_long(self.usize_type, 2);\n+\n+                let clzll = self.context.get_builtin_function(\"__builtin_clzll\");\n+\n+                let first_elem = self.context.new_array_access(None, result, zero);\n+                let first_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[high]), arg_type);\n+                self.llbb()\n+                    .add_assignment(None, first_elem, first_value);\n+\n+                let second_elem = self.context.new_array_access(None, result, one);\n+                let second_value = self.context.new_cast(None, self.context.new_call(None, clzll, &[low]), arg_type) + sixty_four;\n+                self.llbb()\n+                    .add_assignment(None, second_elem, second_value);\n+\n+                let third_elem = self.context.new_array_access(None, result, two);\n+                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                self.llbb()\n+                    .add_assignment(None, third_elem, third_value);\n+\n+                let not_high = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, high);\n+                let not_low = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, low);\n+                let not_low_and_not_high = not_low & not_high;\n+                let index = not_high + not_low_and_not_high;\n+\n+                let res = self.context.new_array_access(None, result, index);\n+\n+                return self.context.new_cast(None, res, arg_type);\n+            }\n+            else {\n+                let count_leading_zeroes = self.context.get_builtin_function(\"__builtin_clz\");\n+                let arg = self.context.new_cast(None, arg, self.uint_type);\n+                let diff = self.int_width(self.uint_type) - self.int_width(arg_type);\n+                let diff = self.context.new_rvalue_from_long(self.int_type, diff);\n+                let res = self.context.new_call(None, count_leading_zeroes, &[arg]) - diff;\n+                return self.context.new_cast(None, res, arg_type);\n+            };\n+        let count_leading_zeroes = self.context.get_builtin_function(count_leading_zeroes);\n+        let res = self.context.new_call(None, count_leading_zeroes, &[arg]);\n+        self.context.new_cast(None, res, arg_type)\n+    }\n+\n+    fn count_trailing_zeroes(&self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+        let result_type = arg.get_type();\n+        let arg =\n+            if result_type.is_signed(self.cx) {\n+                let new_type = result_type.to_unsigned(self.cx);\n+                self.context.new_bitcast(None, arg, new_type)\n+            }\n+            else {\n+                arg\n+            };\n+        let arg_type = arg.get_type();\n+        let (count_trailing_zeroes, expected_type) =\n+            if arg_type.is_uchar(&self.cx) || arg_type.is_ushort(&self.cx) || arg_type.is_uint(&self.cx) {\n+                // NOTE: we don't need to & 0xFF for uchar because the result is undefined on zero.\n+                (\"__builtin_ctz\", self.cx.uint_type)\n+            }\n+            else if arg_type.is_ulong(&self.cx) {\n+                (\"__builtin_ctzl\", self.cx.ulong_type)\n+            }\n+            else if arg_type.is_ulonglong(&self.cx) {\n+                (\"__builtin_ctzll\", self.cx.ulonglong_type)\n+            }\n+            else if arg_type.is_u128(&self.cx) {\n+                // Adapted from the algorithm to count leading zeroes from: https://stackoverflow.com/a/28433850/389119\n+                let array_type = self.context.new_array_type(None, arg_type, 3);\n+                let result = self.current_func()\n+                    .new_local(None, array_type, \"count_loading_zeroes_results\");\n+\n+                let sixty_four = self.context.new_rvalue_from_long(arg_type, 64);\n+                let high = self.context.new_cast(None, arg >> sixty_four, self.u64_type);\n+                let low = self.context.new_cast(None, arg, self.u64_type);\n+\n+                let zero = self.context.new_rvalue_zero(self.usize_type);\n+                let one = self.context.new_rvalue_one(self.usize_type);\n+                let two = self.context.new_rvalue_from_long(self.usize_type, 2);\n+\n+                let ctzll = self.context.get_builtin_function(\"__builtin_ctzll\");\n+\n+                let first_elem = self.context.new_array_access(None, result, zero);\n+                let first_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[low]), arg_type);\n+                self.llbb()\n+                    .add_assignment(None, first_elem, first_value);\n+\n+                let second_elem = self.context.new_array_access(None, result, one);\n+                let second_value = self.context.new_cast(None, self.context.new_call(None, ctzll, &[high]), arg_type) + sixty_four;\n+                self.llbb()\n+                    .add_assignment(None, second_elem, second_value);\n+\n+                let third_elem = self.context.new_array_access(None, result, two);\n+                let third_value = self.context.new_rvalue_from_long(arg_type, 128);\n+                self.llbb()\n+                    .add_assignment(None, third_elem, third_value);\n+\n+                let not_low = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, low);\n+                let not_high = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, high);\n+                let not_low_and_not_high = not_low & not_high;\n+                let index = not_low + not_low_and_not_high;\n+\n+                let res = self.context.new_array_access(None, result, index);\n+\n+                return self.context.new_bitcast(None, res, result_type);\n+            }\n+            else {\n+                unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n+            };\n+        let count_trailing_zeroes = self.context.get_builtin_function(count_trailing_zeroes);\n+        let arg =\n+            if arg_type != expected_type {\n+                self.context.new_cast(None, arg, expected_type)\n+            }\n+            else {\n+                arg\n+            };\n+        let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n+        self.context.new_bitcast(None, res, result_type)\n+    }\n+\n+    fn int_width(&self, typ: Type<'gcc>) -> i64 {\n+        self.cx.int_width(typ) as i64\n+    }\n+\n+    fn pop_count(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): use the optimized version with fewer operations.\n+        let result_type = value.get_type();\n+        let value_type = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, value_type)\n+            }\n+            else {\n+                value\n+            };\n+\n+        if value_type.is_u128(&self.cx) {\n+            // TODO(antoyo): implement in the normal algorithm below to have a more efficient\n+            // implementation (that does not require a call to __popcountdi2).\n+            let popcount = self.context.get_builtin_function(\"__builtin_popcountll\");\n+            let sixty_four = self.context.new_rvalue_from_long(value_type, 64);\n+            let high = self.context.new_cast(None, value >> sixty_four, self.cx.ulonglong_type);\n+            let high = self.context.new_call(None, popcount, &[high]);\n+            let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n+            let low = self.context.new_call(None, popcount, &[low]);\n+            let res = high + low;\n+            return self.context.new_bitcast(None, res, result_type);\n+        }\n+\n+        // First step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x5555555555555555);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 1);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        // Second step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x3333333333333333);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 2);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        // Third step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x0F0F0F0F0F0F0F0F);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 4);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        if value_type.is_u8(&self.cx) {\n+            return self.context.new_bitcast(None, value, result_type);\n+        }\n+\n+        // Fourth step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x00FF00FF00FF00FF);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 8);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        if value_type.is_u16(&self.cx) {\n+            return self.context.new_bitcast(None, value, result_type);\n+        }\n+\n+        // Fifth step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x0000FFFF0000FFFF);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 16);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        if value_type.is_u32(&self.cx) {\n+            return self.context.new_bitcast(None, value, result_type);\n+        }\n+\n+        // Sixth step.\n+        let mask = self.context.new_rvalue_from_long(value_type, 0x00000000FFFFFFFF);\n+        let left = value & mask;\n+        let shifted = value >> self.context.new_rvalue_from_int(value_type, 32);\n+        let right = shifted & mask;\n+        let value = left + right;\n+\n+        self.context.new_bitcast(None, value, result_type)\n+    }\n+\n+    // Algorithm from: https://blog.regehr.org/archives/1063\n+    fn rotate_left(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n+        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n+        let shift = shift % max;\n+        let lhs = self.shl(value, shift);\n+        let result_and =\n+            self.and(\n+                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n+                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+            );\n+        let rhs = self.lshr(value, result_and);\n+        self.or(lhs, rhs)\n+    }\n+\n+    // Algorithm from: https://blog.regehr.org/archives/1063\n+    fn rotate_right(&mut self, value: RValue<'gcc>, shift: RValue<'gcc>, width: u64) -> RValue<'gcc> {\n+        let max = self.context.new_rvalue_from_long(shift.get_type(), width as i64);\n+        let shift = shift % max;\n+        let lhs = self.lshr(value, shift);\n+        let result_and =\n+            self.and(\n+                self.context.new_unary_op(None, UnaryOp::Minus, shift.get_type(), shift),\n+                self.context.new_rvalue_from_long(shift.get_type(), width as i64 - 1),\n+            );\n+        let rhs = self.shl(value, result_and);\n+        self.or(lhs, rhs)\n+    }\n+\n+    fn saturating_add(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n+        let func = self.current_func.borrow().expect(\"func\");\n+\n+        if signed {\n+            // Algorithm from: https://stackoverflow.com/a/56531252/389119\n+            let after_block = func.new_block(\"after\");\n+            let func_name =\n+                match width {\n+                    8 => \"__builtin_add_overflow\",\n+                    16 => \"__builtin_add_overflow\",\n+                    32 => \"__builtin_sadd_overflow\",\n+                    64 => \"__builtin_saddll_overflow\",\n+                    128 => \"__builtin_add_overflow\",\n+                    _ => unreachable!(),\n+                };\n+            let overflow_func = self.context.get_builtin_function(func_name);\n+            let result_type = lhs.get_type();\n+            let res = func.new_local(None, result_type, \"saturating_sum\");\n+            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+\n+            let then_block = func.new_block(\"then\");\n+\n+            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n+            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n+            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n+                self.context.new_rvalue_from_int(unsigned_type, 0)\n+            );\n+            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n+            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            then_block.end_with_jump(None, after_block);\n+\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not\n+            // expect, the current blocks in the state need to be updated.\n+            *self.current_block.borrow_mut() = Some(after_block);\n+            self.block = Some(after_block);\n+\n+            res.to_rvalue()\n+        }\n+        else {\n+            // Algorithm from: http://locklessinc.com/articles/sat_arithmetic/\n+            let res = lhs + rhs;\n+            let res_type = res.get_type();\n+            let cond = self.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+            let value = self.context.new_unary_op(None, UnaryOp::Minus, res_type, self.context.new_cast(None, cond, res_type));\n+            res | value\n+        }\n+    }\n+\n+    // Algorithm from: https://locklessinc.com/articles/sat_arithmetic/\n+    fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n+        if signed {\n+            // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n+            let func_name =\n+                match width {\n+                    8 => \"__builtin_sub_overflow\",\n+                    16 => \"__builtin_sub_overflow\",\n+                    32 => \"__builtin_ssub_overflow\",\n+                    64 => \"__builtin_ssubll_overflow\",\n+                    128 => \"__builtin_sub_overflow\",\n+                    _ => unreachable!(),\n+                };\n+            let overflow_func = self.context.get_builtin_function(func_name);\n+            let result_type = lhs.get_type();\n+            let func = self.current_func.borrow().expect(\"func\");\n+            let res = func.new_local(None, result_type, \"saturating_diff\");\n+            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+\n+            let then_block = func.new_block(\"then\");\n+            let after_block = func.new_block(\"after\");\n+\n+            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n+            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n+            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n+                self.context.new_rvalue_from_int(unsigned_type, 0)\n+            );\n+            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n+            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            then_block.end_with_jump(None, after_block);\n+\n+            self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n+\n+            // NOTE: since jumps were added in a place rustc does not\n+            // expect, the current blocks in the state need to be updated.\n+            *self.current_block.borrow_mut() = Some(after_block);\n+            self.block = Some(after_block);\n+\n+            res.to_rvalue()\n+        }\n+        else {\n+            let res = lhs - rhs;\n+            let comparison = self.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+            let comparison = self.context.new_cast(None, comparison, lhs.get_type());\n+            let unary_op = self.context.new_unary_op(None, UnaryOp::Minus, comparison.get_type(), comparison);\n+            self.and(res, unary_op)\n+        }\n+    }\n+}\n+\n+fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n+        bx.call(bx.type_void(), try_func, &[data], None);\n+        // Return 0 unconditionally from the intrinsic call;\n+        // we can never unwind.\n+        let ret_align = bx.tcx.data_layout.i32_align.abi;\n+        bx.store(bx.const_i32(0), dest, ret_align);\n+    }\n+    else if wants_msvc_seh(bx.sess()) {\n+        unimplemented!();\n+    }\n+    else {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "26a42217e4c56b192abe335b8e53d0ad286e4870", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,167 @@\n+use gccjit::{RValue, Type};\n+use rustc_codegen_ssa::base::compare_simd_types;\n+use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n+use rustc_hir as hir;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{Span, Symbol, sym};\n+\n+use crate::builder::Builder;\n+\n+pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n+    // macros for error handling:\n+    macro_rules! emit_error {\n+        ($msg: tt) => {\n+            emit_error!($msg, )\n+        };\n+        ($msg: tt, $($fmt: tt)*) => {\n+            span_invalid_monomorphization_error(\n+                bx.sess(), span,\n+                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n+                         name, $($fmt)*));\n+        }\n+    }\n+\n+    macro_rules! return_error {\n+        ($($fmt: tt)*) => {\n+            {\n+                emit_error!($($fmt)*);\n+                return Err(());\n+            }\n+        }\n+    }\n+\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                return_error!($($fmt)*);\n+            }\n+        };\n+    }\n+\n+    macro_rules! require_simd {\n+        ($ty: expr, $position: expr) => {\n+            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        };\n+    }\n+\n+    let tcx = bx.tcx();\n+    let sig =\n+        tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), callee_ty.fn_sig(tcx));\n+    let arg_tys = sig.inputs();\n+    let name_str = &*name.as_str();\n+\n+    // every intrinsic below takes a SIMD vector as its first argument\n+    require_simd!(arg_tys[0], \"input\");\n+    let in_ty = arg_tys[0];\n+\n+    let comparison = match name {\n+        sym::simd_eq => Some(hir::BinOpKind::Eq),\n+        sym::simd_ne => Some(hir::BinOpKind::Ne),\n+        sym::simd_lt => Some(hir::BinOpKind::Lt),\n+        sym::simd_le => Some(hir::BinOpKind::Le),\n+        sym::simd_gt => Some(hir::BinOpKind::Gt),\n+        sym::simd_ge => Some(hir::BinOpKind::Ge),\n+        _ => None,\n+    };\n+\n+    let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n+    if let Some(cmp_op) = comparison {\n+        require_simd!(ret_ty, \"return\");\n+\n+        let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            \"expected return type with length {} (same as input type `{}`), \\\n+             found `{}` with length {}\",\n+            in_len,\n+            in_ty,\n+            ret_ty,\n+            out_len\n+        );\n+        require!(\n+            bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n+            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n+            ret_ty,\n+            out_ty\n+        );\n+\n+        return Ok(compare_simd_types(\n+            bx,\n+            args[0].immediate(),\n+            args[1].immediate(),\n+            in_elem,\n+            llret_ty,\n+            cmp_op,\n+        ));\n+    }\n+\n+    if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n+        let n: u64 = stripped.parse().unwrap_or_else(|_| {\n+            span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n+        });\n+\n+        require_simd!(ret_ty, \"return\");\n+\n+        let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+        require!(\n+            out_len == n,\n+            \"expected return type of length {}, found `{}` with length {}\",\n+            n,\n+            ret_ty,\n+            out_len\n+        );\n+        require!(\n+            in_elem == out_ty,\n+            \"expected return element type `{}` (element of input `{}`), \\\n+             found `{}` with element type `{}`\",\n+            in_elem,\n+            in_ty,\n+            ret_ty,\n+            out_ty\n+        );\n+\n+        let vector = args[2].immediate();\n+\n+        return Ok(bx.shuffle_vector(\n+            args[0].immediate(),\n+            args[1].immediate(),\n+            vector,\n+        ));\n+    }\n+\n+    macro_rules! arith_binary {\n+        ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n+            $(if name == sym::$name {\n+                match in_elem.kind() {\n+                    $($(ty::$p(_))|* => {\n+                        return Ok(bx.$call(args[0].immediate(), args[1].immediate()))\n+                    })*\n+                    _ => {},\n+                }\n+                require!(false,\n+                         \"unsupported operation on `{}` with element `{}`\",\n+                         in_ty,\n+                         in_elem)\n+            })*\n+        }\n+    }\n+\n+    arith_binary! {\n+        simd_add: Uint, Int => add, Float => fadd;\n+        simd_sub: Uint, Int => sub, Float => fsub;\n+        simd_mul: Uint, Int => mul, Float => fmul;\n+        simd_div: Uint => udiv, Int => sdiv, Float => fdiv;\n+        simd_rem: Uint => urem, Int => srem, Float => frem;\n+        simd_shl: Uint, Int => shl;\n+        simd_shr: Uint => lshr, Int => ashr;\n+        simd_and: Uint, Int => and;\n+        simd_or: Uint, Int => or; // FIXME(antoyo): calling `or` might not work on vectors.\n+        simd_xor: Uint, Int => xor;\n+    }\n+\n+    unimplemented!(\"simd {}\", name);\n+}"}, {"sha": "f3c02e2634ff61cca5f02d6df67d79df7eec3b35", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,293 @@\n+/*\n+ * TODO(antoyo): support #[inline] attributes.\n+ * TODO(antoyo): support LTO.\n+ *\n+ * TODO(antoyo): remove the patches.\n+ */\n+\n+#![feature(rustc_private, decl_macro, associated_type_bounds, never_type, trusted_len)]\n+#![allow(broken_intra_doc_links)]\n+#![recursion_limit=\"256\"]\n+#![warn(rust_2018_idioms)]\n+#![warn(unused_lifetimes)]\n+\n+extern crate rustc_ast;\n+extern crate rustc_codegen_ssa;\n+extern crate rustc_data_structures;\n+extern crate rustc_errors;\n+extern crate rustc_hir;\n+extern crate rustc_metadata;\n+extern crate rustc_middle;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_symbol_mangling;\n+extern crate rustc_target;\n+extern crate snap;\n+\n+// This prevents duplicating functions and statics that are already part of the host rustc process.\n+#[allow(unused_extern_crates)]\n+extern crate rustc_driver;\n+\n+mod abi;\n+mod allocator;\n+mod archive;\n+mod asm;\n+mod back;\n+mod base;\n+mod builder;\n+mod callee;\n+mod common;\n+mod consts;\n+mod context;\n+mod coverageinfo;\n+mod debuginfo;\n+mod declare;\n+mod intrinsic;\n+mod mono_item;\n+mod type_;\n+mod type_of;\n+\n+use std::any::Any;\n+use std::sync::Arc;\n+\n+use gccjit::{Context, OptimizationLevel};\n+use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n+use rustc_codegen_ssa::base::codegen_crate;\n+use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig, TargetMachineFactoryFn};\n+use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n+use rustc_codegen_ssa::target_features::supported_target_features;\n+use rustc_codegen_ssa::traits::{CodegenBackend, ExtraBackendMethods, ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{ErrorReported, Handler};\n+use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::{Lto, OptLevel, OutputFilenames};\n+use rustc_session::Session;\n+use rustc_span::Symbol;\n+use rustc_span::fatal_error::FatalError;\n+\n+pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n+\n+impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n+    fn drop(&mut self) {\n+        if ::std::thread::panicking() {\n+            println!(\"{}\", (self.0)());\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct GccCodegenBackend;\n+\n+impl CodegenBackend for GccCodegenBackend {\n+    fn init(&self, sess: &Session) {\n+        if sess.lto() != Lto::No {\n+            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+        }\n+    }\n+\n+    fn codegen_crate<'tcx>(&self, tcx: TyCtxt<'tcx>, metadata: EncodedMetadata, need_metadata_module: bool) -> Box<dyn Any> {\n+        let target_cpu = target_cpu(tcx.sess);\n+        let res = codegen_crate(self.clone(), tcx, target_cpu.to_string(), metadata, need_metadata_module);\n+\n+        rustc_symbol_mangling::test::report_symbol_names(tcx);\n+\n+        Box::new(res)\n+    }\n+\n+    fn join_codegen(&self, ongoing_codegen: Box<dyn Any>, sess: &Session) -> Result<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>), ErrorReported> {\n+        let (codegen_results, work_products) = ongoing_codegen\n+            .downcast::<rustc_codegen_ssa::back::write::OngoingCodegen<GccCodegenBackend>>()\n+            .expect(\"Expected GccCodegenBackend's OngoingCodegen, found Box<Any>\")\n+            .join(sess);\n+\n+        Ok((codegen_results, work_products))\n+    }\n+\n+    fn link(&self, sess: &Session, codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorReported> {\n+        use rustc_codegen_ssa::back::link::link_binary;\n+\n+        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+        )\n+    }\n+\n+    fn target_features(&self, sess: &Session) -> Vec<Symbol> {\n+        target_features(sess)\n+    }\n+}\n+\n+impl ExtraBackendMethods for GccCodegenBackend {\n+    fn new_metadata<'tcx>(&self, _tcx: TyCtxt<'tcx>, _mod_name: &str) -> Self::Module {\n+        GccContext {\n+            context: Context::default(),\n+        }\n+    }\n+\n+    fn write_compressed_metadata<'tcx>(&self, tcx: TyCtxt<'tcx>, metadata: &EncodedMetadata, gcc_module: &mut Self::Module) {\n+        base::write_compressed_metadata(tcx, metadata, gcc_module)\n+    }\n+\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, mods: &mut Self::Module, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+        unsafe { allocator::codegen(tcx, mods, module_name, kind, has_alloc_error_handler) }\n+    }\n+\n+    fn compile_codegen_unit<'tcx>(&self, tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (ModuleCodegen<Self::Module>, u64) {\n+        base::compile_codegen_unit(tcx, cgu_name)\n+    }\n+\n+    fn target_machine_factory(&self, _sess: &Session, _opt_level: OptLevel) -> TargetMachineFactoryFn<Self> {\n+        // TODO(antoyo): set opt level.\n+        Arc::new(|_| {\n+            Ok(())\n+        })\n+    }\n+\n+    fn target_cpu<'b>(&self, _sess: &'b Session) -> &'b str {\n+        unimplemented!();\n+    }\n+\n+    fn tune_cpu<'b>(&self, _sess: &'b Session) -> Option<&'b str> {\n+        None\n+        // TODO(antoyo)\n+    }\n+}\n+\n+pub struct ModuleBuffer;\n+\n+impl ModuleBufferMethods for ModuleBuffer {\n+    fn data(&self) -> &[u8] {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct ThinBuffer;\n+\n+impl ThinBufferMethods for ThinBuffer {\n+    fn data(&self) -> &[u8] {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct GccContext {\n+    context: Context<'static>,\n+}\n+\n+unsafe impl Send for GccContext {}\n+// FIXME(antoyo): that shouldn't be Sync. Parallel compilation is currently disabled with \"-Zno-parallel-llvm\". Try to disable it here.\n+unsafe impl Sync for GccContext {}\n+\n+impl WriteBackendMethods for GccCodegenBackend {\n+    type Module = GccContext;\n+    type TargetMachine = ();\n+    type ModuleBuffer = ModuleBuffer;\n+    type Context = ();\n+    type ThinData = ();\n+    type ThinBuffer = ThinBuffer;\n+\n+    fn run_fat_lto(_cgcx: &CodegenContext<Self>, mut modules: Vec<FatLTOInput<Self>>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<LtoModuleCodegen<Self>, FatalError> {\n+        // TODO(antoyo): implement LTO by sending -flto to libgccjit and adding the appropriate gcc linker plugins.\n+        // NOTE: implemented elsewhere.\n+        // TODO: what is implemented elsewhere ^ ?\n+        let module =\n+            match modules.remove(0) {\n+                FatLTOInput::InMemory(module) => module,\n+                FatLTOInput::Serialized { .. } => {\n+                    unimplemented!();\n+                }\n+            };\n+        Ok(LtoModuleCodegen::Fat { module: Some(module), _serialized_bitcode: vec![] })\n+    }\n+\n+    fn run_thin_lto(_cgcx: &CodegenContext<Self>, _modules: Vec<(String, Self::ThinBuffer)>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<(Vec<LtoModuleCodegen<Self>>, Vec<WorkProduct>), FatalError> {\n+        unimplemented!();\n+    }\n+\n+    fn print_pass_timings(&self) {\n+        unimplemented!();\n+    }\n+\n+    unsafe fn optimize(_cgcx: &CodegenContext<Self>, _diag_handler: &Handler, module: &ModuleCodegen<Self::Module>, config: &ModuleConfig) -> Result<(), FatalError> {\n+        module.module_llvm.context.set_optimization_level(to_gcc_opt_level(config.opt_level));\n+        Ok(())\n+    }\n+\n+    unsafe fn optimize_thin(_cgcx: &CodegenContext<Self>, _thin: &mut ThinModule<Self>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+        unimplemented!();\n+    }\n+\n+    unsafe fn codegen(cgcx: &CodegenContext<Self>, diag_handler: &Handler, module: ModuleCodegen<Self::Module>, config: &ModuleConfig) -> Result<CompiledModule, FatalError> {\n+        back::write::codegen(cgcx, diag_handler, module, config)\n+    }\n+\n+    fn prepare_thin(_module: ModuleCodegen<Self::Module>) -> (String, Self::ThinBuffer) {\n+        unimplemented!();\n+    }\n+\n+    fn serialize_module(_module: ModuleCodegen<Self::Module>) -> (String, Self::ModuleBuffer) {\n+        unimplemented!();\n+    }\n+\n+    fn run_lto_pass_manager(_cgcx: &CodegenContext<Self>, _module: &ModuleCodegen<Self::Module>, _config: &ModuleConfig, _thin: bool) -> Result<(), FatalError> {\n+        // TODO(antoyo)\n+        Ok(())\n+    }\n+\n+    fn run_link(cgcx: &CodegenContext<Self>, diag_handler: &Handler, modules: Vec<ModuleCodegen<Self::Module>>) -> Result<ModuleCodegen<Self::Module>, FatalError> {\n+        back::write::link(cgcx, diag_handler, modules)\n+    }\n+}\n+\n+/// This is the entrypoint for a hot plugged rustc_codegen_gccjit\n+#[no_mangle]\n+pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n+    Box::new(GccCodegenBackend)\n+}\n+\n+fn to_gcc_opt_level(optlevel: Option<OptLevel>) -> OptimizationLevel {\n+    match optlevel {\n+        None => OptimizationLevel::None,\n+        Some(level) => {\n+            match level {\n+                OptLevel::No => OptimizationLevel::None,\n+                OptLevel::Less => OptimizationLevel::Limited,\n+                OptLevel::Default => OptimizationLevel::Standard,\n+                OptLevel::Aggressive => OptimizationLevel::Aggressive,\n+                OptLevel::Size | OptLevel::SizeMin => OptimizationLevel::Limited,\n+            }\n+        },\n+    }\n+}\n+\n+fn handle_native(name: &str) -> &str {\n+    if name != \"native\" {\n+        return name;\n+    }\n+\n+    unimplemented!();\n+}\n+\n+pub fn target_cpu(sess: &Session) -> &str {\n+    let name = sess.opts.cg.target_cpu.as_ref().unwrap_or(&sess.target.cpu);\n+    handle_native(name)\n+}\n+\n+pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+    supported_target_features(sess)\n+        .iter()\n+        .filter_map(\n+            |&(feature, gate)| {\n+                if sess.is_nightly_build() || gate.is_none() { Some(feature) } else { None }\n+            },\n+        )\n+        .filter(|_feature| {\n+            // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n+            false\n+        })\n+        .map(|feature| Symbol::intern(feature))\n+        .collect()\n+}"}, {"sha": "e21d40b6c37e37f67bf4644b78aefcd7c13fe2cd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,38 @@\n+use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n+use rustc_span::def_id::DefId;\n+\n+use crate::base;\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+        let attrs = self.tcx.codegen_fn_attrs(def_id);\n+        let instance = Instance::mono(self.tcx, def_id);\n+        let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n+        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+\n+        let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+        let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+\n+        // TODO(antoyo): set linkage and visibility.\n+        self.instances.borrow_mut().insert(instance, global);\n+    }\n+\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+        assert!(!instance.substs.needs_infer());\n+\n+        let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+        self.linkage.set(base::linkage_to_gcc(linkage));\n+        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n+\n+        // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n+        // TODO(antoyo): set unique comdat.\n+        // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+    }\n+}"}, {"sha": "3545e1b628105870b333bd2030dbf30ad79c4ed5", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,282 @@\n+use std::convert::TryInto;\n+\n+use gccjit::{RValue, Struct, Type};\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods};\n+use rustc_codegen_ssa::common::TypeKind;\n+use rustc_middle::bug;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n+\n+use crate::common::TypeReflection;\n+use crate::context::CodegenCx;\n+use crate::type_of::LayoutGccExt;\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn type_ix(&self, num_bits: u64) -> Type<'gcc> {\n+        // gcc only supports 1, 2, 4 or 8-byte integers.\n+        // FIXME(antoyo): this is misleading to use the next power of two as rustc_codegen_ssa\n+        // sometimes use 96-bit numbers and the following code will give an integer of a different\n+        // size.\n+        let bytes = (num_bits / 8).next_power_of_two() as i32;\n+        match bytes {\n+            1 => self.i8_type,\n+            2 => self.i16_type,\n+            4 => self.i32_type,\n+            8 => self.i64_type,\n+            16 => self.i128_type,\n+            _ => panic!(\"unexpected num_bits: {}\", num_bits),\n+        }\n+    }\n+\n+    pub fn type_void(&self) -> Type<'gcc> {\n+        self.context.new_type::<()>()\n+    }\n+\n+    pub fn type_size_t(&self) -> Type<'gcc> {\n+        self.context.new_type::<usize>()\n+    }\n+\n+    pub fn type_u8(&self) -> Type<'gcc> {\n+        self.u8_type\n+    }\n+\n+    pub fn type_u16(&self) -> Type<'gcc> {\n+        self.u16_type\n+    }\n+\n+    pub fn type_u32(&self) -> Type<'gcc> {\n+        self.u32_type\n+    }\n+\n+    pub fn type_u64(&self) -> Type<'gcc> {\n+        self.u64_type\n+    }\n+\n+    pub fn type_u128(&self) -> Type<'gcc> {\n+        self.u128_type\n+    }\n+\n+    pub fn type_pointee_for_align(&self, align: Align) -> Type<'gcc> {\n+        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n+        let ity = Integer::approximate_align(self, align);\n+        self.type_from_integer(ity)\n+    }\n+}\n+\n+impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn type_i1(&self) -> Type<'gcc> {\n+        self.bool_type\n+    }\n+\n+    fn type_i8(&self) -> Type<'gcc> {\n+        self.i8_type\n+    }\n+\n+    fn type_i16(&self) -> Type<'gcc> {\n+        self.i16_type\n+    }\n+\n+    fn type_i32(&self) -> Type<'gcc> {\n+        self.i32_type\n+    }\n+\n+    fn type_i64(&self) -> Type<'gcc> {\n+        self.i64_type\n+    }\n+\n+    fn type_i128(&self) -> Type<'gcc> {\n+        self.i128_type\n+    }\n+\n+    fn type_isize(&self) -> Type<'gcc> {\n+        self.isize_type\n+    }\n+\n+    fn type_f32(&self) -> Type<'gcc> {\n+        self.context.new_type::<f32>()\n+    }\n+\n+    fn type_f64(&self) -> Type<'gcc> {\n+        self.context.new_type::<f64>()\n+    }\n+\n+    fn type_func(&self, params: &[Type<'gcc>], return_type: Type<'gcc>) -> Type<'gcc> {\n+        self.context.new_function_pointer_type(None, return_type, params, false)\n+    }\n+\n+    fn type_struct(&self, fields: &[Type<'gcc>], _packed: bool) -> Type<'gcc> {\n+        let types = fields.to_vec();\n+        if let Some(typ) = self.struct_types.borrow().get(fields) {\n+            return typ.clone();\n+        }\n+        let fields: Vec<_> = fields.iter().enumerate()\n+            .map(|(index, field)| self.context.new_field(None, *field, &format!(\"field{}_TODO\", index)))\n+            .collect();\n+        // TODO(antoyo): use packed.\n+        let typ = self.context.new_struct_type(None, \"struct\", &fields).as_type();\n+        self.struct_types.borrow_mut().insert(types, typ);\n+        typ\n+    }\n+\n+    fn type_kind(&self, typ: Type<'gcc>) -> TypeKind {\n+        if typ.is_integral() {\n+            TypeKind::Integer\n+        }\n+        else if typ.is_vector().is_some() {\n+            TypeKind::Vector\n+        }\n+        else {\n+            // TODO(antoyo): support other types.\n+            TypeKind::Void\n+        }\n+    }\n+\n+    fn type_ptr_to(&self, ty: Type<'gcc>) -> Type<'gcc> {\n+        ty.make_pointer()\n+    }\n+\n+    fn type_ptr_to_ext(&self, ty: Type<'gcc>, _address_space: AddressSpace) -> Type<'gcc> {\n+        // TODO(antoyo): use address_space\n+        ty.make_pointer()\n+    }\n+\n+    fn element_type(&self, ty: Type<'gcc>) -> Type<'gcc> {\n+        if let Some(typ) = ty.is_array() {\n+            typ\n+        }\n+        else if let Some(vector_type) = ty.is_vector() {\n+            vector_type.get_element_type()\n+        }\n+        else if let Some(typ) = ty.get_pointee() {\n+            typ\n+        }\n+        else {\n+            unreachable!()\n+        }\n+    }\n+\n+    fn vector_length(&self, _ty: Type<'gcc>) -> usize {\n+        unimplemented!();\n+    }\n+\n+    fn float_width(&self, typ: Type<'gcc>) -> usize {\n+        let f32 = self.context.new_type::<f32>();\n+        let f64 = self.context.new_type::<f64>();\n+        if typ == f32 {\n+            32\n+        }\n+        else if typ == f64 {\n+            64\n+        }\n+        else {\n+            panic!(\"Cannot get width of float type {:?}\", typ);\n+        }\n+        // TODO(antoyo): support other sizes.\n+    }\n+\n+    fn int_width(&self, typ: Type<'gcc>) -> u64 {\n+        if typ.is_i8(self) || typ.is_u8(self) {\n+            8\n+        }\n+        else if typ.is_i16(self) || typ.is_u16(self) {\n+            16\n+        }\n+        else if typ.is_i32(self) || typ.is_u32(self) {\n+            32\n+        }\n+        else if typ.is_i64(self) || typ.is_u64(self) {\n+            64\n+        }\n+        else if typ.is_i128(self) || typ.is_u128(self) {\n+            128\n+        }\n+        else {\n+            panic!(\"Cannot get width of int type {:?}\", typ);\n+        }\n+    }\n+\n+    fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {\n+        value.get_type()\n+    }\n+}\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    pub fn type_padding_filler(&self, size: Size, align: Align) -> Type<'gcc> {\n+        let unit = Integer::approximate_align(self, align);\n+        let size = size.bytes();\n+        let unit_size = unit.size().bytes();\n+        assert_eq!(size % unit_size, 0);\n+        self.type_array(self.type_from_integer(unit), size / unit_size)\n+    }\n+\n+    pub fn set_struct_body(&self, typ: Struct<'gcc>, fields: &[Type<'gcc>], _packed: bool) {\n+        // TODO(antoyo): use packed.\n+        let fields: Vec<_> = fields.iter().enumerate()\n+            .map(|(index, field)| self.context.new_field(None, *field, &format!(\"field_{}\", index)))\n+            .collect();\n+        typ.set_fields(None, &fields);\n+    }\n+\n+    pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n+        self.context.new_opaque_struct_type(None, name)\n+    }\n+\n+    pub fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n+        if let Some(struct_type) = ty.is_struct() {\n+            if struct_type.get_field_count() == 0 {\n+                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n+                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n+                // zero for ZSTs.\n+                // FIXME(antoyo): fix gccjit API.\n+                len = 0;\n+            }\n+        }\n+\n+        // NOTE: see note above. Some other test uses usize::MAX.\n+        if len == u64::MAX {\n+            len = 0;\n+        }\n+\n+        let len: i32 = len.try_into().expect(\"array len\");\n+\n+        self.context.new_array_type(None, ty, len)\n+    }\n+}\n+\n+pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {\n+    let field_count = layout.fields.count();\n+\n+    let mut packed = false;\n+    let mut offset = Size::ZERO;\n+    let mut prev_effective_align = layout.align.abi;\n+    let mut result: Vec<_> = Vec::with_capacity(1 + field_count * 2);\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let target_offset = layout.fields.offset(i as usize);\n+        let field = layout.field(cx, i);\n+        let effective_field_align =\n+            layout.align.abi.min(field.align.abi).restrict_for_offset(target_offset);\n+        packed |= effective_field_align < field.align.abi;\n+\n+        assert!(target_offset >= offset);\n+        let padding = target_offset - offset;\n+        let padding_align = prev_effective_align.min(effective_field_align);\n+        assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n+        result.push(cx.type_padding_filler(padding, padding_align));\n+\n+        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        offset = target_offset + field.size;\n+        prev_effective_align = effective_field_align;\n+    }\n+    if !layout.is_unsized() && field_count > 0 {\n+        if offset > layout.size {\n+            bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n+        }\n+        let padding = layout.size - offset;\n+        let padding_align = prev_effective_align;\n+        assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n+        result.push(cx.type_padding_filler(padding, padding_align));\n+        assert_eq!(result.len(), 1 + field_count * 2);\n+    }\n+\n+    (result, packed)\n+}"}, {"sha": "9c39c8f91a1ff54ece1fdccfd27b92adef4602eb", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,359 @@\n+use std::fmt::Write;\n+\n+use gccjit::{Struct, Type};\n+use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n+use rustc_middle::bug;\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n+use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n+\n+use crate::abi::{FnAbiGccExt, GccType};\n+use crate::context::CodegenCx;\n+use crate::type_::struct_fields;\n+\n+impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    fn type_from_unsigned_integer(&self, i: Integer) -> Type<'gcc> {\n+        use Integer::*;\n+        match i {\n+            I8 => self.type_u8(),\n+            I16 => self.type_u16(),\n+            I32 => self.type_u32(),\n+            I64 => self.type_u64(),\n+            I128 => self.type_u128(),\n+        }\n+    }\n+}\n+\n+pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+    match layout.abi {\n+        Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n+        Abi::Vector { ref element, count } => {\n+            let element = layout.scalar_gcc_type_at(cx, element, Size::ZERO);\n+            return cx.context.new_vector_type(element, count);\n+        },\n+        Abi::ScalarPair(..) => {\n+            return cx.type_struct(\n+                &[\n+                    layout.scalar_pair_element_gcc_type(cx, 0, false),\n+                    layout.scalar_pair_element_gcc_type(cx, 1, false),\n+                ],\n+                false,\n+            );\n+        }\n+        Abi::Uninhabited | Abi::Aggregate { .. } => {}\n+    }\n+\n+    let name = match layout.ty.kind() {\n+        // FIXME(eddyb) producing readable type names for trait objects can result\n+        // in problematically distinct types due to HRTB and subtyping (see #47638).\n+        // ty::Dynamic(..) |\n+        ty::Adt(..) | ty::Closure(..) | ty::Foreign(..) | ty::Generator(..) | ty::Str\n+            if !cx.sess().fewer_names() =>\n+        {\n+            let mut name = with_no_trimmed_paths(|| layout.ty.to_string());\n+            if let (&ty::Adt(def, _), &Variants::Single { index }) =\n+                (layout.ty.kind(), &layout.variants)\n+            {\n+                if def.is_enum() && !def.variants.is_empty() {\n+                    write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n+                }\n+            }\n+            if let (&ty::Generator(_, _, _), &Variants::Single { index }) =\n+                (layout.ty.kind(), &layout.variants)\n+            {\n+                write!(&mut name, \"::{}\", ty::GeneratorSubsts::variant_name(index)).unwrap();\n+            }\n+            Some(name)\n+        }\n+        ty::Adt(..) => {\n+            // If `Some` is returned then a named struct is created in LLVM. Name collisions are\n+            // avoided by LLVM (with increasing suffixes). If rustc doesn't generate names then that\n+            // can improve perf.\n+            // FIXME(antoyo): I don't think that's true for libgccjit.\n+            Some(String::new())\n+        }\n+        _ => None,\n+    };\n+\n+    match layout.fields {\n+        FieldsShape::Primitive | FieldsShape::Union(_) => {\n+            let fill = cx.type_padding_filler(layout.size, layout.align.abi);\n+            let packed = false;\n+            match name {\n+                None => cx.type_struct(&[fill], packed),\n+                Some(ref name) => {\n+                    let gcc_type = cx.type_named_struct(name);\n+                    cx.set_struct_body(gcc_type, &[fill], packed);\n+                    gcc_type.as_type()\n+                },\n+            }\n+        }\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Arbitrary { .. } =>\n+            match name {\n+                None => {\n+                    let (gcc_fields, packed) = struct_fields(cx, layout);\n+                    cx.type_struct(&gcc_fields, packed)\n+                },\n+                Some(ref name) => {\n+                    let gcc_type = cx.type_named_struct(name);\n+                    *defer = Some((gcc_type, layout));\n+                    gcc_type.as_type()\n+                },\n+            },\n+    }\n+}\n+\n+pub trait LayoutGccExt<'tcx> {\n+    fn is_gcc_immediate(&self) -> bool;\n+    fn is_gcc_scalar_pair(&self) -> bool;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+    fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n+    fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n+    fn gcc_field_index(&self, index: usize) -> u64;\n+    fn pointee_info_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n+}\n+\n+impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n+    fn is_gcc_immediate(&self) -> bool {\n+        match self.abi {\n+            Abi::Scalar(_) | Abi::Vector { .. } => true,\n+            Abi::ScalarPair(..) => false,\n+            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+        }\n+    }\n+\n+    fn is_gcc_scalar_pair(&self) -> bool {\n+        match self.abi {\n+            Abi::ScalarPair(..) => true,\n+            Abi::Uninhabited | Abi::Scalar(_) | Abi::Vector { .. } | Abi::Aggregate { .. } => false,\n+        }\n+    }\n+\n+    /// Gets the GCC type corresponding to a Rust type, i.e., `rustc_middle::ty::Ty`.\n+    /// The pointee type of the pointer in `PlaceRef` is always this type.\n+    /// For sized types, it is also the right LLVM type for an `alloca`\n+    /// containing a value of that type, and most immediates (except `bool`).\n+    /// Unsized types, however, are represented by a \"minimal unit\", e.g.\n+    /// `[T]` becomes `T`, while `str` and `Trait` turn into `i8` - this\n+    /// is useful for indexing slices, as `&[T]`'s data pointer is `T*`.\n+    /// If the type is an unsized struct, the regular layout is generated,\n+    /// with the inner-most trailing unsized field using the \"minimal unit\"\n+    /// of that field's type - this is useful for taking the address of\n+    /// that field and ensuring the struct has the right alignment.\n+    //TODO(antoyo): do we still need the set_fields parameter?\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+        if let Abi::Scalar(ref scalar) = self.abi {\n+            // Use a different cache for scalars because pointers to DSTs\n+            // can be either fat or thin (data pointers of fat pointers).\n+            if let Some(&ty) = cx.scalar_types.borrow().get(&self.ty) {\n+                return ty;\n+            }\n+            let ty =\n+                match *self.ty.kind() {\n+                    ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                    }\n+                    ty::Adt(def, _) if def.is_box() => {\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                    }\n+                    ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n+                    _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n+                };\n+            cx.scalar_types.borrow_mut().insert(self.ty, ty);\n+            return ty;\n+        }\n+\n+        // Check the cache.\n+        let variant_index =\n+            match self.variants {\n+                Variants::Single { index } => Some(index),\n+                _ => None,\n+            };\n+        let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n+        if let Some(ty) = cached_type {\n+            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n+            if let Some((struct_type, layout)) = type_to_set_fields {\n+                // Since we might be trying to generate a type containing another type which is not\n+                // completely generated yet, we deferred setting the fields until now.\n+                let (fields, packed) = struct_fields(cx, layout);\n+                cx.set_struct_body(struct_type, &fields, packed);\n+            }\n+            return ty;\n+        }\n+\n+        assert!(!self.ty.has_escaping_bound_vars(), \"{:?} has escaping bound vars\", self.ty);\n+\n+        // Make sure lifetimes are erased, to avoid generating distinct LLVM\n+        // types for Rust types that only differ in the choice of lifetimes.\n+        let normal_ty = cx.tcx.erase_regions(self.ty);\n+\n+        let mut defer = None;\n+        let ty =\n+            if self.ty != normal_ty {\n+                let mut layout = cx.layout_of(normal_ty);\n+                if let Some(v) = variant_index {\n+                    layout = layout.for_variant(cx, v);\n+                }\n+                layout.gcc_type(cx, true)\n+            }\n+            else {\n+                uncached_gcc_type(cx, *self, &mut defer)\n+            };\n+\n+        cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n+\n+        if let Some((ty, layout)) = defer {\n+            let (fields, packed) = struct_fields(cx, layout);\n+            cx.set_struct_body(ty, &fields, packed);\n+        }\n+\n+        ty\n+    }\n+\n+    fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        if let Abi::Scalar(ref scalar) = self.abi {\n+            if scalar.is_bool() {\n+                return cx.type_i1();\n+            }\n+        }\n+        self.gcc_type(cx, true)\n+    }\n+\n+    fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n+        match scalar.value {\n+            Int(i, true) => cx.type_from_integer(i),\n+            Int(i, false) => cx.type_from_unsigned_integer(i),\n+            F32 => cx.type_f32(),\n+            F64 => cx.type_f64(),\n+            Pointer => {\n+                // If we know the alignment, pick something better than i8.\n+                let pointee =\n+                    if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                        cx.type_pointee_for_align(pointee.align)\n+                    }\n+                    else {\n+                        cx.type_i8()\n+                    };\n+                cx.type_ptr_to(pointee)\n+            }\n+        }\n+    }\n+\n+    fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc> {\n+        // TODO(antoyo): remove llvm hack:\n+        // HACK(eddyb) special-case fat pointers until LLVM removes\n+        // pointee types, to avoid bitcasting every `OperandRef::deref`.\n+        match self.ty.kind() {\n+            ty::Ref(..) | ty::RawPtr(_) => {\n+                return self.field(cx, index).gcc_type(cx, true);\n+            }\n+            ty::Adt(def, _) if def.is_box() => {\n+                let ptr_ty = cx.tcx.mk_mut_ptr(self.ty.boxed_ty());\n+                return cx.layout_of(ptr_ty).scalar_pair_element_gcc_type(cx, index, immediate);\n+            }\n+            _ => {}\n+        }\n+\n+        let (a, b) = match self.abi {\n+            Abi::ScalarPair(ref a, ref b) => (a, b),\n+            _ => bug!(\"TyAndLayout::scalar_pair_element_llty({:?}): not applicable\", self),\n+        };\n+        let scalar = [a, b][index];\n+\n+        // Make sure to return the same type `immediate_gcc_type` would when\n+        // dealing with an immediate pair.  This means that `(bool, bool)` is\n+        // effectively represented as `{i8, i8}` in memory and two `i1`s as an\n+        // immediate, just like `bool` is typically `i8` in memory and only `i1`\n+        // when immediate.  We need to load/store `bool` as `i8` to avoid\n+        // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n+        // TODO(antoyo): this bugs certainly don't happen in this case since the bool type is used instead of i1.\n+        if scalar.is_bool() {\n+            return cx.type_i1();\n+        }\n+\n+        let offset =\n+            if index == 0 {\n+                Size::ZERO\n+            }\n+            else {\n+                a.value.size(cx).align_to(b.value.align(cx).abi)\n+            };\n+        self.scalar_gcc_type_at(cx, scalar, offset)\n+    }\n+\n+    fn gcc_field_index(&self, index: usize) -> u64 {\n+        match self.abi {\n+            Abi::Scalar(_) | Abi::ScalarPair(..) => {\n+                bug!(\"TyAndLayout::gcc_field_index({:?}): not applicable\", self)\n+            }\n+            _ => {}\n+        }\n+        match self.fields {\n+            FieldsShape::Primitive | FieldsShape::Union(_) => {\n+                bug!(\"TyAndLayout::gcc_field_index({:?}): not applicable\", self)\n+            }\n+\n+            FieldsShape::Array { .. } => index as u64,\n+\n+            FieldsShape::Arbitrary { .. } => 1 + (self.fields.memory_index(index) as u64) * 2,\n+        }\n+    }\n+\n+    fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo> {\n+        if let Some(&pointee) = cx.pointee_infos.borrow().get(&(self.ty, offset)) {\n+            return pointee;\n+        }\n+\n+        let result = Ty::ty_and_layout_pointee_info_at(*self, cx, offset);\n+\n+        cx.pointee_infos.borrow_mut().insert((self.ty, offset), result);\n+        result\n+    }\n+}\n+\n+impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n+        layout.gcc_type(self, true)\n+    }\n+\n+    fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n+        layout.immediate_gcc_type(self)\n+    }\n+\n+    fn is_backend_immediate(&self, layout: TyAndLayout<'tcx>) -> bool {\n+        layout.is_gcc_immediate()\n+    }\n+\n+    fn is_backend_scalar_pair(&self, layout: TyAndLayout<'tcx>) -> bool {\n+        layout.is_gcc_scalar_pair()\n+    }\n+\n+    fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64 {\n+        layout.gcc_field_index(index)\n+    }\n+\n+    fn scalar_pair_element_backend_type(&self, layout: TyAndLayout<'tcx>, index: usize, immediate: bool) -> Type<'gcc> {\n+        layout.scalar_pair_element_gcc_type(self, index, immediate)\n+    }\n+\n+    fn cast_backend_type(&self, ty: &CastTarget) -> Type<'gcc> {\n+        ty.gcc_type(self)\n+    }\n+\n+    fn fn_ptr_backend_type(&self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Type<'gcc> {\n+        fn_abi.ptr_to_gcc_type(self)\n+    }\n+\n+    fn reg_backend_type(&self, _ty: &Reg) -> Type<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    fn fn_decl_backend_type(&self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Type<'gcc> {\n+        // FIXME(antoyo): return correct type.\n+        self.type_void()\n+    }\n+}"}, {"sha": "944d0ce516e0f553b4e2f1a10471a85212eae9f3", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,217 @@\n+#!/bin/bash\n+\n+# TODO(antoyo): rewrite to cargo-make (or just) or something like that to only rebuild the sysroot when needed?\n+\n+set -e\n+\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n+\n+export LD_LIBRARY_PATH=\"$GCC_PATH\"\n+export LIBRARY_PATH=\"$GCC_PATH\"\n+\n+if [[ \"$1\" == \"--release\" ]]; then\n+    export CHANNEL='release'\n+    CARGO_INCREMENTAL=1 cargo rustc --release\n+    shift\n+else\n+    echo $LD_LIBRARY_PATH\n+    export CHANNEL='debug'\n+    cargo rustc\n+fi\n+\n+source config.sh\n+\n+function clean() {\n+    rm -r target/out || true\n+    mkdir -p target/out/gccjit\n+}\n+\n+function mini_tests() {\n+    echo \"[BUILD] mini_core\"\n+    $RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target $TARGET_TRIPLE\n+\n+    echo \"[BUILD] example\"\n+    $RUSTC example/example.rs --crate-type lib --target $TARGET_TRIPLE\n+\n+    echo \"[AOT] mini_core_hello_world\"\n+    $RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n+}\n+\n+function build_sysroot() {\n+    echo \"[BUILD] sysroot\"\n+    time ./build_sysroot/build_sysroot.sh\n+}\n+\n+function std_tests() {\n+    echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n+    $RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n+\n+    echo \"[AOT] alloc_system\"\n+    $RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n+\n+    echo \"[AOT] alloc_example\"\n+    $RUSTC example/alloc_example.rs --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/alloc_example\n+\n+    echo \"[AOT] dst_field_align\"\n+    # FIXME(antoyo): Re-add -Zmir-opt-level=2 once rust-lang/rust#67529 is fixed.\n+    $RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/dst_field_align || (echo $?; false)\n+\n+    echo \"[AOT] std_example\"\n+    $RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n+\n+    echo \"[AOT] subslice-patterns-const-eval\"\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n+\n+    echo \"[AOT] track-caller-attribute\"\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/track-caller-attribute\n+\n+    echo \"[BUILD] mod_bench\"\n+    $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n+}\n+\n+# FIXME(antoyo): linker gives multiple definitions error on Linux\n+#echo \"[BUILD] sysroot in release mode\"\n+#./build_sysroot/build_sysroot.sh --release\n+\n+# TODO(antoyo): uncomment when it works.\n+#pushd simple-raytracer\n+#if [[ \"$HOST_TRIPLE\" = \"$TARGET_TRIPLE\" ]]; then\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs ${RUN_RUNS:-10} --warmup 1 --prepare \"rm -r target/*/debug || true\" \\\n+    #\"RUSTFLAGS='' cargo build --target $TARGET_TRIPLE\" \\\n+    #\"../cargo.sh build\"\n+\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/*/debug/main ./raytracer_cg_gccjit\n+    #hyperfine --runs ${RUN_RUNS:-10} ./raytracer_cg_llvm ./raytracer_cg_gccjit\n+#else\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\"\n+    #echo \"[COMPILE] ebobby/simple-raytracer\"\n+    #../cargo.sh build\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer (skipped)\"\n+#fi\n+#popd\n+\n+function test_libcore() {\n+    pushd build_sysroot/sysroot_src/library/core/tests\n+    echo \"[TEST] libcore\"\n+    rm -r ./target || true\n+    ../../../../../cargo.sh test\n+    popd\n+}\n+\n+# TODO(antoyo): uncomment when it works.\n+#pushd regex\n+#echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n+#../cargo.sh clean\n+## Make sure `[codegen mono items] start` doesn't poison the diff\n+#../cargo.sh build --example shootout-regex-dna\n+#cat examples/regexdna-input.txt | ../cargo.sh run --example shootout-regex-dna | grep -v \"Spawned thread\" > res.txt\n+#diff -u res.txt examples/regexdna-output.txt\n+\n+#echo \"[TEST] rust-lang/regex tests\"\n+#../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options\n+#popd\n+\n+#echo\n+#echo \"[BENCH COMPILE] mod_bench\"\n+\n+#COMPILE_MOD_BENCH_INLINE=\"$RUSTC example/mod_bench.rs --crate-type bin -Zmir-opt-level=3 -O --crate-name mod_bench_inline\"\n+#COMPILE_MOD_BENCH_LLVM_0=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=0 -o target/out/mod_bench_llvm_0 -Cpanic=abort\"\n+#COMPILE_MOD_BENCH_LLVM_1=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=1 -o target/out/mod_bench_llvm_1 -Cpanic=abort\"\n+#COMPILE_MOD_BENCH_LLVM_2=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=2 -o target/out/mod_bench_llvm_2 -Cpanic=abort\"\n+#COMPILE_MOD_BENCH_LLVM_3=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=3 -o target/out/mod_bench_llvm_3 -Cpanic=abort\"\n+\n+## Use 100 runs, because a single compilations doesn't take more than ~150ms, so it isn't very slow\n+#hyperfine --runs ${COMPILE_RUNS:-100} \"$COMPILE_MOD_BENCH_INLINE\" \"$COMPILE_MOD_BENCH_LLVM_0\" \"$COMPILE_MOD_BENCH_LLVM_1\" \"$COMPILE_MOD_BENCH_LLVM_2\" \"$COMPILE_MOD_BENCH_LLVM_3\"\n+\n+#echo\n+#echo \"[BENCH RUN] mod_bench\"\n+#hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n+\n+function test_rustc() {\n+    echo\n+    echo \"[TEST] rust-lang/rust\"\n+\n+    rust_toolchain=$(cat rust-toolchain)\n+\n+    git clone https://github.com/rust-lang/rust.git || true\n+    cd rust\n+    git fetch\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n+    export RUSTFLAGS=\n+\n+    rm config.toml || true\n+\n+    cat > config.toml <<EOF\n+[rust]\n+codegen-backends = []\n+deny-warnings = false\n+\n+[build]\n+cargo = \"$(which cargo)\"\n+local-rebuild = true\n+rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n+EOF\n+\n+    rustc -V | cut -d' ' -f3 | tr -d '('\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') src/test\n+\n+    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+      rm $test\n+    done\n+\n+    git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+\n+    rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n+      rm $test\n+    done\n+    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n+    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    rm src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs || true # TODO(antoyo): Enable back this test if I ever implement the llvm_asm! macro.\n+\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Zsymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+\n+    echo \"[TEST] rustc test suite\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n+}\n+\n+function clean_ui_tests() {\n+    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n+}\n+\n+case $1 in\n+    \"--test-rustc\")\n+        test_rustc\n+        ;;\n+\n+    \"--test-libcore\")\n+        test_libcore\n+        ;;\n+\n+    \"--clean-ui-tests\")\n+        clean_ui_tests\n+        ;;\n+\n+    *)\n+        clean\n+        mini_tests\n+        build_sysroot\n+        std_tests\n+        test_libcore\n+        test_rustc\n+        ;;\n+esac"}, {"sha": "8ee35b30bc8e581fa0e4b3d8195aec6dc6d8facf", "filename": "compiler/rustc_codegen_gcc/tests/lib.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flib.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,50 @@\n+use std::{\n+    env::{self, current_dir},\n+    path::PathBuf,\n+    process::Command,\n+};\n+\n+use lang_tester::LangTester;\n+use tempfile::TempDir;\n+\n+fn main() {\n+    let tempdir = TempDir::new().expect(\"temp dir\");\n+    let current_dir = current_dir().expect(\"current dir\");\n+    let current_dir = current_dir.to_str().expect(\"current dir\").to_string();\n+    let gcc_path = include_str!(\"../gcc_path\");\n+    let gcc_path = gcc_path.trim();\n+    env::set_var(\"LD_LIBRARY_PATH\", gcc_path);\n+    LangTester::new()\n+        .test_dir(\"tests/run\")\n+        .test_file_filter(|path| path.extension().expect(\"extension\").to_str().expect(\"to_str\") == \"rs\")\n+        .test_extract(|source| {\n+            let lines =\n+                source.lines()\n+                    .skip_while(|l| !l.starts_with(\"//\"))\n+                    .take_while(|l| l.starts_with(\"//\"))\n+                    .map(|l| &l[2..])\n+                    .collect::<Vec<_>>()\n+                    .join(\"\\n\");\n+            Some(lines)\n+        })\n+        .test_cmds(move |path| {\n+            // Test command 1: Compile `x.rs` into `tempdir/x`.\n+            let mut exe = PathBuf::new();\n+            exe.push(&tempdir);\n+            exe.push(path.file_stem().expect(\"file_stem\"));\n+            let mut compiler = Command::new(\"rustc\");\n+            compiler.args(&[\n+                &format!(\"-Zcodegen-backend={}/target/debug/librustc_codegen_gcc.so\", current_dir),\n+                \"--sysroot\", &format!(\"{}/build_sysroot/sysroot/\", current_dir),\n+                \"-Zno-parallel-llvm\",\n+                \"-C\", \"panic=abort\",\n+                \"-C\", \"link-arg=-lc\",\n+                \"-o\", exe.to_str().expect(\"to_str\"),\n+                path.to_str().expect(\"to_str\"),\n+            ]);\n+            // Test command 2: run `tempdir/x`.\n+            let runtime = Command::new(exe);\n+            vec![(\"Compiler\", compiler), (\"Run-time\", runtime)]\n+        })\n+        .run();\n+}"}, {"sha": "291af5993aa25cb7d46b91672809ce9cb7a76c96", "filename": "compiler/rustc_codegen_gcc/tests/run/abort1.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,51 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: signal\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod intrinsics {\n+    use super::Sized;\n+\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+fn test_fail() -> ! {\n+    unsafe { intrinsics::abort() };\n+}\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    test_fail();\n+}"}, {"sha": "3c87c567892b570672694e8ec619e521b66d7b3d", "filename": "compiler/rustc_codegen_gcc/tests/run/abort2.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,53 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: signal\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod intrinsics {\n+    use super::Sized;\n+\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+fn fail() -> i32 {\n+    unsafe { intrinsics::abort() };\n+    0\n+}\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    fail();\n+    0\n+}"}, {"sha": "8b621d8a3530fb864eba0eee7520e66c3e2d95f0", "filename": "compiler/rustc_codegen_gcc/tests/run/array.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,229 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 42\n+//     7\n+//     5\n+//     10\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for isize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+\n+/*\n+ * Code\n+ */\n+\n+static mut ONE: usize = 1;\n+\n+fn make_array() -> [u8; 3] {\n+    [42, 10, 5]\n+}\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    let array = [42, 7, 5];\n+    let array2 = make_array();\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, array[ONE - 1]);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, array[ONE]);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, array[ONE + 1]);\n+\n+        libc::printf(b\"%d\\n\\0\" as *const u8 as *const i8, array2[argc as usize] as u32);\n+    }\n+    0\n+}"}, {"sha": "9c0055b0b6b5ec36fdbbcfc2d7eda5645a3a7b63", "filename": "compiler/rustc_codegen_gcc/tests/run/asm.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,153 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+\n+#![feature(asm, global_asm)]\n+\n+global_asm!(\"\n+    .global add_asm\n+add_asm:\n+     mov rax, rdi\n+     add rax, rsi\n+     ret\"\n+);\n+\n+extern \"C\" {\n+    fn add_asm(a: i64, b: i64) -> i64;\n+}\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"nop\");\n+    }\n+\n+    let x: u64;\n+    unsafe {\n+        asm!(\"mov $5, {}\",\n+            out(reg) x,\n+            options(att_syntax)\n+        );\n+    }\n+    assert_eq!(x, 5);\n+\n+    let x: u64;\n+    let input: u64 = 42;\n+    unsafe {\n+        asm!(\"mov {input}, {output}\",\n+             \"add $1, {output}\",\n+            input = in(reg) input,\n+            output = out(reg) x,\n+            options(att_syntax)\n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    let x: u64;\n+    unsafe {\n+        asm!(\"mov {}, 6\",\n+            out(reg) x,\n+        );\n+    }\n+    assert_eq!(x, 6);\n+\n+    let x: u64;\n+    let input: u64 = 42;\n+    unsafe {\n+        asm!(\"mov {output}, {input}\",\n+             \"add {output}, 1\",\n+            input = in(reg) input,\n+            output = out(reg) x,\n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check inout(reg_class) x \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {0}, {0}\",\n+            inout(reg) x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check inout(\"reg\") x\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add r11, r11\",\n+            inout(\"r11\") x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check a mix of\n+    // in(\"reg\")\n+    // inout(class) x => y\n+    // inout (class) x\n+    let x: u64 = 702;\n+    let y: u64 = 100;\n+    let res: u64;\n+    let mut rem: u64 = 0;\n+    unsafe {\n+        asm!(\"div r11\",\n+            in(\"r11\") y,\n+            inout(\"eax\") x => res,\n+            inout(\"edx\") rem,\n+        );\n+    }\n+    assert_eq!(res, 7);\n+    assert_eq!(rem, 2);\n+\n+    // check const \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            inout(reg) x,\n+            const 1 \n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check const (ATT syntax)\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            const 1,\n+            inout(reg) x,\n+            options(att_syntax)\n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check sym fn\n+    extern \"C\" fn foo() -> u64 { 42 }\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym fn (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static\n+    static FOO: u64 = 42;\n+    let x: u64;\n+    unsafe {\n+        asm!(\"mov {1}, qword ptr [rip + {0}]\", sym FOO, lateout(reg) x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"movq {0}(%rip), {1}\", sym FOO, lateout(reg) x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n+    assert_eq!(unsafe { add_asm(40, 2) }, 42);\n+}"}, {"sha": "cc8647006ca639e846ad70347239aff21f98df7a", "filename": "compiler/rustc_codegen_gcc/tests/run/assign.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,153 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   stdout: 2\n+//     7 8\n+//     10\n+\n+#![allow(unused_attributes)]\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics, track_caller)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for *mut i32 {}\n+impl Copy for usize {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i32 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn fflush(stream: *mut i32) -> i32;\n+        pub fn printf(format: *const i8, ...) -> i32;\n+\n+        pub static STDOUT: *mut i32;\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        libc::fflush(libc::STDOUT);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+fn inc_ref(num: &mut isize) -> isize {\n+    *num = *num + 5;\n+    *num + 1\n+}\n+\n+fn inc(num: isize) -> isize {\n+    num + 1\n+}\n+\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    argc = inc(argc);\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, argc);\n+    }\n+\n+    let b = inc_ref(&mut argc);\n+    unsafe {\n+        libc::printf(b\"%ld %ld\\n\\0\" as *const u8 as *const i8, argc, b);\n+    }\n+\n+    argc = 10;\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, argc);\n+    }\n+    0\n+}"}, {"sha": "7121a5f0d5221b572bbf9fb968c82bd352acc863", "filename": "compiler/rustc_codegen_gcc/tests/run/closure.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,230 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: Arg: 1\n+//     Argument: 1\n+//     String arg: 1\n+//     Int argument: 2\n+//     Both args: 11\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics,\n+    unboxed_closures)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u32 {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"unsize\"]\n+pub trait Unsize<T: ?Sized> {}\n+\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+\n+#[lang = \"fn_once\"]\n+#[rustc_paren_sugar]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+#[rustc_paren_sugar]\n+pub trait FnMut<Args>: FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let string = \"Arg: %d\\n\\0\";\n+    let mut closure = || {\n+        unsafe {\n+            libc::printf(string as *const str as *const i8, argc);\n+        }\n+    };\n+    closure();\n+\n+    let mut closure = || {\n+        unsafe {\n+            libc::printf(\"Argument: %d\\n\\0\" as *const str as *const i8, argc);\n+        }\n+    };\n+    closure();\n+\n+    let mut closure = |string| {\n+        unsafe {\n+            libc::printf(string as *const str as *const i8, argc);\n+        }\n+    };\n+    closure(\"String arg: %d\\n\\0\");\n+\n+    let mut closure = |arg: isize| {\n+        unsafe {\n+            libc::printf(\"Int argument: %d\\n\\0\" as *const str as *const i8, arg);\n+        }\n+    };\n+    closure(argc + 1);\n+\n+    let mut closure = |string, arg: isize| {\n+        unsafe {\n+            libc::printf(string as *const str as *const i8, arg);\n+        }\n+    };\n+    closure(\"Both args: %d\\n\\0\", argc + 10);\n+\n+    0\n+}"}, {"sha": "6a2e2d5bb11a98de1e72495d32832227d2325631", "filename": "compiler/rustc_codegen_gcc/tests/run/condition.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,320 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: true\n+//     1\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for u64 {}\n+impl Copy for i32 {}\n+impl Copy for u32 {}\n+impl Copy for bool {}\n+impl Copy for u16 {}\n+impl Copy for i16 {}\n+impl Copy for char {}\n+impl Copy for i8 {}\n+impl Copy for u8 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for isize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+#[lang = \"eq\"]\n+pub trait PartialEq<Rhs: ?Sized = Self> {\n+    fn eq(&self, other: &Rhs) -> bool;\n+    fn ne(&self, other: &Rhs) -> bool;\n+}\n+\n+impl PartialEq for u8 {\n+    fn eq(&self, other: &u8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u16 {\n+    fn eq(&self, other: &u16) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u16) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for u32 {\n+    fn eq(&self, other: &u32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+\n+impl PartialEq for u64 {\n+    fn eq(&self, other: &u64) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &u64) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for usize {\n+    fn eq(&self, other: &usize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &usize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i8 {\n+    fn eq(&self, other: &i8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for i32 {\n+    fn eq(&self, other: &i32) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i32) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for isize {\n+    fn eq(&self, other: &isize) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &isize) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+impl PartialEq for char {\n+    fn eq(&self, other: &char) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &char) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        if argc == 1 {\n+            libc::printf(b\"true\\n\\0\" as *const u8 as *const i8);\n+        }\n+\n+        let string =\n+            match argc {\n+                1 => b\"1\\n\\0\",\n+                2 => b\"2\\n\\0\",\n+                3 => b\"3\\n\\0\",\n+                4 => b\"4\\n\\0\",\n+                5 => b\"5\\n\\0\",\n+                _ => b\"_\\n\\0\",\n+            };\n+        libc::printf(string as *const u8 as *const i8);\n+    }\n+    0\n+}"}, {"sha": "c02cfd2a85f033959f49a414eeb6082f7133cd23", "filename": "compiler/rustc_codegen_gcc/tests/run/empty_main.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fempty_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fempty_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fempty_main.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,39 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+\n+#![feature(auto_traits, lang_items, no_core, start)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    0\n+}"}, {"sha": "956e53dd4aa650acb36a617b38a1a00b8f62713a", "filename": "compiler/rustc_codegen_gcc/tests/run/exit.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,49 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 2\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn exit(status: i32);\n+    }\n+}\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        libc::exit(2);\n+    }\n+    0\n+}"}, {"sha": "eeab352095123aa873498afceb3a028b749fec14", "filename": "compiler/rustc_codegen_gcc/tests/run/exit_code.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fexit_code.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,39 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 1\n+\n+#![feature(auto_traits, lang_items, no_core, start)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    1\n+}"}, {"sha": "a226fff79e51b9c81a5ff6210a93e7ef07d7dc91", "filename": "compiler/rustc_codegen_gcc/tests/run/fun_ptr.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,223 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 1\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for isize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+\n+/*\n+ * Code\n+ */\n+\n+fn i16_as_i8(a: i16) -> i8 {\n+    a as i8\n+}\n+\n+fn call_func(func: fn(i16) -> i8, param: i16) -> i8 {\n+    func(param)\n+}\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        let result = call_func(i16_as_i8, argc as i16) as isize;\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, result);\n+    }\n+    0\n+}"}, {"sha": "7111703ca2532096c497313bdff6e3122cfda055", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,129 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   stdout: Panicking\n+//   status: signal\n+\n+#![allow(unused_attributes)]\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for *mut i32 {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn fflush(stream: *mut i32) -> i32;\n+\n+        pub static STDOUT: *mut i32;\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        libc::fflush(libc::STDOUT);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let int = 9223372036854775807isize;\n+    let int = int + argc;\n+    int\n+}"}, {"sha": "e8876009cc61043eea0ac5d1624eeb3e76d2fa1e", "filename": "compiler/rustc_codegen_gcc/tests/run/mut_ref.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,165 @@\n+\n+// Compiler:\n+//\n+// Run-time:\n+//   stdout: 2\n+//     7\n+//     6\n+//     11\n+\n+#![allow(unused_attributes)]\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics, track_caller)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for *mut i32 {}\n+impl Copy for usize {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i32 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn fflush(stream: *mut i32) -> i32;\n+        pub fn printf(format: *const i8, ...) -> i32;\n+\n+        pub static STDOUT: *mut i32;\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        libc::fflush(libc::STDOUT);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+struct Test {\n+    field: isize,\n+}\n+\n+fn test(num: isize) -> Test {\n+    Test {\n+        field: num + 1,\n+    }\n+}\n+\n+fn update_num(num: &mut isize) {\n+    *num = *num + 5;\n+}\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let mut test = test(argc);\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, test.field);\n+    }\n+    update_num(&mut test.field);\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, test.field);\n+    }\n+\n+    update_num(&mut argc);\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, argc);\n+    }\n+\n+    let refe = &mut argc;\n+    *refe = *refe + 5;\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, argc);\n+    }\n+\n+    0\n+}"}, {"sha": "4dc375309e42695933ade915d98720048a4e0340", "filename": "compiler/rustc_codegen_gcc/tests/run/operations.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,221 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   stdout: 41\n+//     39\n+//     10\n+\n+#![allow(unused_attributes)]\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics, arbitrary_self_types)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for *mut i32 {}\n+impl Copy for usize {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+\n+#[lang = \"deref\"]\n+pub trait Deref {\n+    type Target: ?Sized;\n+\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn puts(s: *const u8) -> i32;\n+        pub fn fflush(stream: *mut i32) -> i32;\n+\n+        pub static STDOUT: *mut i32;\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        libc::fflush(libc::STDOUT);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for isize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+#[lang = \"mul\"]\n+pub trait Mul<RHS = Self> {\n+    type Output;\n+\n+    #[must_use]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Mul for u8 {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+impl Mul for usize {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+impl Mul for isize {\n+    type Output = Self;\n+\n+    fn mul(self, rhs: Self) -> Self::Output {\n+        self * rhs\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, 40 + argc);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, 40 - argc);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, 10 * argc);\n+    }\n+    0\n+}"}, {"sha": "6ac099ea145c23ae0fade4afdce75d919ffd0e00", "filename": "compiler/rustc_codegen_gcc/tests/run/ptr_cast.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,222 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 1\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u8 {}\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+        pub fn puts(s: *const u8) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic\"]\n+#[track_caller]\n+#[no_mangle]\n+pub fn panic(_msg: &str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+#[lang = \"add\"]\n+trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i8 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for i32 {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for usize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+impl Add for isize {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self {\n+        self + rhs\n+    }\n+}\n+\n+#[lang = \"sub\"]\n+pub trait Sub<RHS = Self> {\n+    type Output;\n+\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Sub for usize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for isize {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for u8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i8 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+impl Sub for i16 {\n+    type Output = Self;\n+\n+    fn sub(self, rhs: Self) -> Self {\n+        self - rhs\n+    }\n+}\n+\n+\n+/*\n+ * Code\n+ */\n+\n+static mut ONE: usize = 1;\n+\n+fn make_array() -> [u8; 3] {\n+    [42, 10, 5]\n+}\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        let ptr = ONE as *mut usize;\n+        let value = ptr as usize;\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, value);\n+    }\n+    0\n+}"}, {"sha": "6fa10dca06f67244f804a46ab212d448fb04a11e", "filename": "compiler/rustc_codegen_gcc/tests/run/return-tuple.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Freturn-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Freturn-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Freturn-tuple.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,72 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 10\n+//     10\n+//     42\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+#[lang = \"copy\"]\n+pub unsafe trait Copy {}\n+\n+unsafe impl Copy for bool {}\n+unsafe impl Copy for u8 {}\n+unsafe impl Copy for u16 {}\n+unsafe impl Copy for u32 {}\n+unsafe impl Copy for u64 {}\n+unsafe impl Copy for usize {}\n+unsafe impl Copy for i8 {}\n+unsafe impl Copy for i16 {}\n+unsafe impl Copy for i32 {}\n+unsafe impl Copy for isize {}\n+unsafe impl Copy for f32 {}\n+unsafe impl Copy for char {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+/*\n+ * Code\n+ */\n+\n+fn int_cast(a: u16, b: i16) -> (u8, u16, u32, usize, i8, i16, i32, isize, u8, u32) {\n+    (\n+        a as u8, a as u16, a as u32, a as usize, a as i8, a as i16, a as i32, a as isize, b as u8,\n+        b as u32,\n+    )\n+}\n+\n+#[start]\n+fn main(argc: isize, _argv: *const *const u8) -> isize {\n+    let (a, b, c, d, e, f, g, h, i, j) = int_cast(10, 42);\n+    unsafe {\n+        libc::printf(b\"%d\\n\\0\" as *const u8 as *const i8, c);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, d);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, j);\n+    }\n+    0\n+}"}, {"sha": "ad9258ed0bdebdc0b53f806ce4b831b8855f0012", "filename": "compiler/rustc_codegen_gcc/tests/run/slice.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,128 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 5\n+\n+#![feature(arbitrary_self_types, auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+impl Copy for usize {}\n+impl Copy for i32 {}\n+impl Copy for u32 {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+#[lang = \"index\"]\n+pub trait Index<Idx: ?Sized> {\n+    type Output: ?Sized;\n+    fn index(&self, index: Idx) -> &Self::Output;\n+}\n+\n+impl<T> Index<usize> for [T; 3] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+impl<T> Index<usize> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self[index]\n+    }\n+}\n+\n+#[lang = \"unsize\"]\n+pub trait Unsize<T: ?Sized> {}\n+\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+#[lang = \"panic_location\"]\n+struct PanicLocation {\n+    file: &'static str,\n+    line: u32,\n+    column: u32,\n+}\n+\n+#[lang = \"panic_bounds_check\"]\n+#[track_caller]\n+#[no_mangle]\n+fn panic_bounds_check(index: usize, len: usize) -> ! {\n+    unsafe {\n+        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        intrinsics::abort();\n+    }\n+}\n+\n+mod intrinsics {\n+    use super::Sized;\n+\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+static mut TWO: usize = 2;\n+\n+fn index_slice(s: &[u32]) -> u32 {\n+    unsafe {\n+        s[TWO]\n+    }\n+}\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let array = [42, 7, 5];\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, index_slice(&array));\n+    }\n+    0\n+}"}, {"sha": "ab89f6aff4b50798aadf5191f823e4200110472b", "filename": "compiler/rustc_codegen_gcc/tests/run/static.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,106 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 10\n+//      14\n+//      1\n+//      12\n+//      12\n+//      1\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod intrinsics {\n+    use super::Sized;\n+\n+    extern \"rust-intrinsic\" {\n+        pub fn abort() -> !;\n+    }\n+}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {}\n+\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {}\n+\n+#[lang = \"drop_in_place\"]\n+#[allow(unconditional_recursion)]\n+pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+    // Code here does not matter - this is replaced by the\n+    // real drop glue by the compiler.\n+    drop_in_place(to_drop);\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+struct Test {\n+    field: isize,\n+}\n+\n+struct WithRef {\n+    refe: &'static Test,\n+}\n+\n+static mut CONSTANT: isize = 10;\n+\n+static mut TEST: Test = Test {\n+    field: 12,\n+};\n+\n+static mut TEST2: Test = Test {\n+    field: 14,\n+};\n+\n+static mut WITH_REF: WithRef = WithRef {\n+    refe: unsafe { &TEST },\n+};\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, CONSTANT);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, TEST2.field);\n+        TEST2.field = argc;\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, TEST2.field);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, WITH_REF.refe.field);\n+        WITH_REF.refe = &TEST2;\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, TEST.field);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, WITH_REF.refe.field);\n+    }\n+    0\n+}"}, {"sha": "6c8884855ac35891d70391e7dc14799162fdfe60", "filename": "compiler/rustc_codegen_gcc/tests/run/structs.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstructs.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,70 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 1\n+//     2\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+struct Test {\n+    field: isize,\n+}\n+\n+struct Two {\n+    two: isize,\n+}\n+\n+fn one() -> isize {\n+    1\n+}\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let test = Test {\n+        field: one(),\n+    };\n+    let two = Two {\n+        two: 2,\n+    };\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, test.field);\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, two.two);\n+    }\n+    0\n+}"}, {"sha": "0b670bf2674248843f74c447adaa6bebd4e3b673", "filename": "compiler/rustc_codegen_gcc/tests/run/tuple.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ftuple.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -0,0 +1,51 @@\n+// Compiler:\n+//\n+// Run-time:\n+//   status: 0\n+//   stdout: 3\n+\n+#![feature(auto_traits, lang_items, no_core, start, intrinsics)]\n+\n+#![no_std]\n+#![no_core]\n+\n+/*\n+ * Core\n+ */\n+\n+// Because we don't have core yet.\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"copy\"]\n+trait Copy {\n+}\n+\n+impl Copy for isize {}\n+\n+#[lang = \"receiver\"]\n+trait Receiver {\n+}\n+\n+#[lang = \"freeze\"]\n+pub(crate) unsafe auto trait Freeze {}\n+\n+mod libc {\n+    #[link(name = \"c\")]\n+    extern \"C\" {\n+        pub fn printf(format: *const i8, ...) -> i32;\n+    }\n+}\n+\n+/*\n+ * Code\n+ */\n+\n+#[start]\n+fn main(mut argc: isize, _argv: *const *const u8) -> isize {\n+    let test: (isize, isize, isize) = (3, 1, 4);\n+    unsafe {\n+        libc::printf(b\"%ld\\n\\0\" as *const u8 as *const i8, test.0);\n+    }\n+    0\n+}"}, {"sha": "053f3e3ee583b9afbe4783715ad4892f80d88569", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -19,6 +19,7 @@ ignore = [\n     \"library/backtrace\",\n     \"library/stdarch\",\n     \"compiler/rustc_codegen_cranelift\",\n+    \"compiler/rustc_codegen_gcc\",\n     \"src/doc/book\",\n     \"src/doc/edition-guide\",\n     \"src/doc/embedded-book\","}, {"sha": "28e7f1fdca7a19519e957f93690c8402abf6697e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -243,11 +243,16 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.paths(&[\"compiler/rustc_codegen_cranelift\", \"rustc_codegen_cranelift\"])\n+        run.paths(&[\n+            \"compiler/rustc_codegen_cranelift\",\n+            \"rustc_codegen_cranelift\",\n+            \"compiler/rustc_codegen_gcc\",\n+            \"rustc_codegen_gcc\",\n+        ])\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        for &backend in &[INTERNER.intern_str(\"cranelift\")] {\n+        for &backend in &[INTERNER.intern_str(\"cranelift\"), INTERNER.intern_str(\"gcc\")] {\n             run.builder.ensure(CodegenBackend { target: run.target, backend });\n         }\n     }"}, {"sha": "a20ea3235ed46348fc07ac468a1c94c9c84b689f", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/864290472fcb1deee2a4fb09a9df2864ce3bd1a4/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=864290472fcb1deee2a4fb09a9df2864ce3bd1a4", "patch": "@@ -57,6 +57,7 @@ fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n         \"tidy-test-file\",\n         \"compiler/rustc_codegen_cranelift\",\n+        \"compiler/rustc_codegen_gcc\",\n         \"src/llvm-project\",\n         \"library/backtrace\",\n         \"library/stdarch\","}]}