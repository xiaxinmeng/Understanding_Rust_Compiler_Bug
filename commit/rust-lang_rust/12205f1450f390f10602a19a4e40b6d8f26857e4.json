{"sha": "12205f1450f390f10602a19a4e40b6d8f26857e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMjA1ZjE0NTBmMzkwZjEwNjAyYTE5YTRlNDBiNmQ4ZjI2ODU3ZTQ=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-06-24T14:51:16Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-06-24T15:14:42Z"}, "message": "Improve sort tests and benchmarks", "tree": {"sha": "956f415c5fea826d333545eb01e7e20770517e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/956f415c5fea826d333545eb01e7e20770517e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12205f1450f390f10602a19a4e40b6d8f26857e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12205f1450f390f10602a19a4e40b6d8f26857e4", "html_url": "https://github.com/rust-lang/rust/commit/12205f1450f390f10602a19a4e40b6d8f26857e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12205f1450f390f10602a19a4e40b6d8f26857e4/comments", "author": null, "committer": null, "parents": [{"sha": "7e76505e0105e3102ed14d827dd727afc1c9fd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e76505e0105e3102ed14d827dd727afc1c9fd92", "html_url": "https://github.com/rust-lang/rust/commit/7e76505e0105e3102ed14d827dd727afc1c9fd92"}], "stats": {"total": 276, "additions": 180, "deletions": 96}, "files": [{"sha": "5f274eec87d4717ab0a62b252158ab020316d404", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=12205f1450f390f10602a19a4e40b6d8f26857e4", "patch": "@@ -17,6 +17,7 @@\n #![feature(sort_unstable)]\n #![feature(test)]\n \n+extern crate rand;\n extern crate test;\n \n mod btree;"}, {"sha": "d99270e7f311e20c0e54c32622a48f42301a3b5d", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=12205f1450f390f10602a19a4e40b6d8f26857e4", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{mem, ptr};\n-use std::__rand::{Rng, thread_rng};\n+use std::__rand::{thread_rng};\n+use std::mem;\n+use std::ptr;\n \n+use rand::{Rng, SeedableRng, XorShiftRng};\n use test::{Bencher, black_box};\n \n #[bench]\n@@ -191,17 +193,17 @@ fn gen_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_random(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u64>().take(len).collect()\n }\n \n fn gen_random_bytes(len: usize) -> Vec<u8> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter::<u8>().take(len).collect()\n }\n \n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_ascending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -212,7 +214,7 @@ fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n }\n \n fn gen_mostly_descending(len: usize) -> Vec<u64> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = gen_descending(len);\n     for _ in (0usize..).take_while(|x| x * x <= len) {\n         let x = rng.gen::<usize>() % len;\n@@ -223,7 +225,7 @@ fn gen_mostly_descending(len: usize) -> Vec<u64> {\n }\n \n fn gen_strings(len: usize) -> Vec<String> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n@@ -233,26 +235,40 @@ fn gen_strings(len: usize) -> Vec<String> {\n }\n \n fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n-    let mut rng = thread_rng();\n+    let mut rng = XorShiftRng::from_seed([0, 1, 2, 3]);\n     rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n }\n \n macro_rules! sort {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n-            b.iter(|| $gen($len).$f());\n+            let v = $gen($len);\n+            b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n+macro_rules! sort_strings {\n+    ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n+        #[bench]\n+        fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n+            let v = v.iter().map(|s| &**s).collect::<Vec<&str>>();\n+            b.iter(|| v.clone().$f());\n+            b.bytes = $len * mem::size_of::<&str>() as u64;\n+        }\n+    }\n+}\n+\n macro_rules! sort_expensive {\n     ($f:ident, $name:ident, $gen:expr, $len:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n+            let v = $gen($len);\n             b.iter(|| {\n-                let mut v = $gen($len);\n+                let mut v = v.clone();\n                 let mut count = 0;\n                 v.$f(|a: &u64, b: &u64| {\n                     count += 1;\n@@ -263,38 +279,38 @@ macro_rules! sort_expensive {\n                 });\n                 black_box(count);\n             });\n-            b.bytes = $len as u64 * mem::size_of::<u64>() as u64;\n+            b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n     }\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n sort!(sort, sort_small_descending, gen_descending, 10);\n sort!(sort, sort_small_random, gen_random, 10);\n-sort!(sort, sort_small_big_random, gen_big_random, 10);\n+sort!(sort, sort_small_big, gen_big_random, 10);\n sort!(sort, sort_medium_random, gen_random, 100);\n sort!(sort, sort_large_ascending, gen_ascending, 10000);\n sort!(sort, sort_large_descending, gen_descending, 10000);\n sort!(sort, sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort, sort_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort, sort_large_random, gen_random, 10000);\n-sort!(sort, sort_large_big_random, gen_big_random, 10000);\n-sort!(sort, sort_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_by, sort_large_random_expensive, gen_random, 10000);\n+sort!(sort, sort_large_big, gen_big_random, 10000);\n+sort_strings!(sort, sort_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_by, sort_large_expensive, gen_random, 10000);\n \n sort!(sort_unstable, sort_unstable_small_ascending, gen_ascending, 10);\n sort!(sort_unstable, sort_unstable_small_descending, gen_descending, 10);\n sort!(sort_unstable, sort_unstable_small_random, gen_random, 10);\n-sort!(sort_unstable, sort_unstable_small_big_random, gen_big_random, 10);\n+sort!(sort_unstable, sort_unstable_small_big, gen_big_random, 10);\n sort!(sort_unstable, sort_unstable_medium_random, gen_random, 100);\n sort!(sort_unstable, sort_unstable_large_ascending, gen_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_descending, gen_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_ascending, gen_mostly_ascending, 10000);\n sort!(sort_unstable, sort_unstable_large_mostly_descending, gen_mostly_descending, 10000);\n sort!(sort_unstable, sort_unstable_large_random, gen_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_big_random, gen_big_random, 10000);\n-sort!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n-sort_expensive!(sort_unstable_by, sort_unstable_large_random_expensive, gen_random, 10000);\n+sort!(sort_unstable, sort_unstable_large_big, gen_big_random, 10000);\n+sort_strings!(sort_unstable, sort_unstable_large_strings, gen_strings, 10000);\n+sort_expensive!(sort_unstable_by, sort_unstable_large_expensive, gen_random, 10000);\n \n macro_rules! reverse {\n     ($name:ident, $ty:ty, $f:expr) => {"}, {"sha": "fe8893904eba1bf3ee8ae9e562471fec3eb4acd8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=12205f1450f390f10602a19a4e40b6d8f26857e4", "patch": "@@ -1794,7 +1794,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n \n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n-            // `T` is not a zero-sized type, so it's okay to divide by it's size.\n+            // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n             unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n         }\n@@ -1908,7 +1908,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n     // algorithm should continue building a new run instead, `None` is returned.\n     //\n-    // TimSort is infamous for it's buggy implementations, as described here:\n+    // TimSort is infamous for its buggy implementations, as described here:\n     // http://envisage-project.eu/timsort-specification-and-verification/\n     //\n     // The gist of the story is: we must enforce the invariants on the top four runs on the stack."}, {"sha": "c53bf15f1bfb6263fe861c643defab423ffa3dd7", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=12205f1450f390f10602a19a4e40b6d8f26857e4", "patch": "@@ -396,18 +396,44 @@ fn test_sort() {\n     let mut rng = thread_rng();\n \n     for len in (2..25).chain(500..510) {\n-        for _ in 0..100 {\n-            let mut v: Vec<_> = rng.gen_iter::<i32>().take(len).collect();\n-            let mut v1 = v.clone();\n-\n-            v.sort();\n-            assert!(v.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| a.cmp(b));\n-            assert!(v1.windows(2).all(|w| w[0] <= w[1]));\n-\n-            v1.sort_by(|a, b| b.cmp(a));\n-            assert!(v1.windows(2).all(|w| w[0] >= w[1]));\n+        for &modulus in &[5, 10, 100, 1000] {\n+            for _ in 0..10 {\n+                let orig: Vec<_> = rng.gen_iter::<i32>()\n+                    .map(|x| x % modulus)\n+                    .take(len)\n+                    .collect();\n+\n+                // Sort in default order.\n+                let mut v = orig.clone();\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in ascending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| a.cmp(b));\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+\n+                // Sort in descending order.\n+                let mut v = orig.clone();\n+                v.sort_by(|a, b| b.cmp(a));\n+                assert!(v.windows(2).all(|w| w[0] >= w[1]));\n+\n+                // Sort with many pre-sorted runs.\n+                let mut v = orig.clone();\n+                v.sort();\n+                v.reverse();\n+                for _ in 0..5 {\n+                    let a = rng.gen::<usize>() % len;\n+                    let b = rng.gen::<usize>() % len;\n+                    if a < b {\n+                        v[a..b].reverse();\n+                    } else {\n+                        v.swap(a, b);\n+                    }\n+                }\n+                v.sort();\n+                assert!(v.windows(2).all(|w| w[0] <= w[1]));\n+            }\n         }\n     }\n "}, {"sha": "3458199bdaf776802a42903cc9fb7c96e8fde1ec", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 104, "deletions": 63, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12205f1450f390f10602a19a4e40b6d8f26857e4/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=12205f1450f390f10602a19a4e40b6d8f26857e4", "patch": "@@ -10,14 +10,17 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(rand)]\n #![feature(const_fn)]\n+#![feature(rand)]\n+#![feature(sort_unstable)]\n \n use std::__rand::{thread_rng, Rng};\n+use std::cell::Cell;\n+use std::cmp::Ordering;\n use std::panic;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::sync::atomic::{ATOMIC_USIZE_INIT, AtomicUsize};\n+use std::sync::atomic::Ordering::Relaxed;\n use std::thread;\n-use std::cell::Cell;\n \n const MAX_LEN: usize = 80;\n \n@@ -45,54 +48,85 @@ static DROP_COUNTS: [AtomicUsize; MAX_LEN] = [\n     AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0), AtomicUsize::new(0),\n ];\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+static VERSIONS: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+#[derive(Clone, Eq)]\n struct DropCounter {\n     x: u32,\n     id: usize,\n+    version: Cell<usize>,\n+}\n+\n+impl PartialEq for DropCounter {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl PartialOrd for DropCounter {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.version.set(self.version.get() + 1);\n+        other.version.set(other.version.get() + 1);\n+        VERSIONS.fetch_add(2, Relaxed);\n+        self.x.partial_cmp(&other.x)\n+    }\n+}\n+\n+impl Ord for DropCounter {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other).unwrap()\n+    }\n }\n \n impl Drop for DropCounter {\n     fn drop(&mut self) {\n-        DROP_COUNTS[self.id].fetch_add(1, Ordering::Relaxed);\n+        DROP_COUNTS[self.id].fetch_add(1, Relaxed);\n+        VERSIONS.fetch_sub(self.version.get(), Relaxed);\n     }\n }\n \n-fn test(input: &[DropCounter]) {\n-    let len = input.len();\n+macro_rules! test {\n+    ($input:ident, $func:ident) => {\n+        let len = $input.len();\n+\n+        // Work out the total number of comparisons required to sort\n+        // this array...\n+        let mut count = 0usize;\n+        $input.to_owned().$func(|a, b| { count += 1; a.cmp(b) });\n+\n+        // ... and then panic on each and every single one.\n+        for panic_countdown in 0..count {\n+            // Refresh the counters.\n+            VERSIONS.store(0, Relaxed);\n+            for i in 0..len {\n+                DROP_COUNTS[i].store(0, Relaxed);\n+            }\n \n-    // Work out the total number of comparisons required to sort\n-    // this array...\n-    let mut count = 0usize;\n-    input.to_owned().sort_by(|a, b| { count += 1; a.cmp(b) });\n+            let v = $input.to_owned();\n+            let _ = thread::spawn(move || {\n+                let mut v = v;\n+                let mut panic_countdown = panic_countdown;\n+                v.$func(|a, b| {\n+                    if panic_countdown == 0 {\n+                        SILENCE_PANIC.with(|s| s.set(true));\n+                        panic!();\n+                    }\n+                    panic_countdown -= 1;\n+                    a.cmp(b)\n+                })\n+            }).join();\n+\n+            // Check that the number of things dropped is exactly\n+            // what we expect (i.e. the contents of `v`).\n+            for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n+                let count = c.load(Relaxed);\n+                assert!(count == 1,\n+                        \"found drop count == {} for i == {}, len == {}\",\n+                        count, i, len);\n+            }\n \n-    // ... and then panic on each and every single one.\n-    for panic_countdown in 0..count {\n-        // Refresh the counters.\n-        for i in 0..len {\n-            DROP_COUNTS[i].store(0, Ordering::Relaxed);\n-        }\n-\n-        let v = input.to_owned();\n-        let _ = thread::spawn(move || {\n-            let mut v = v;\n-            let mut panic_countdown = panic_countdown;\n-            v.sort_by(|a, b| {\n-                if panic_countdown == 0 {\n-                    SILENCE_PANIC.with(|s| s.set(true));\n-                    panic!();\n-                }\n-                panic_countdown -= 1;\n-                a.cmp(b)\n-            })\n-        }).join();\n-\n-        // Check that the number of things dropped is exactly\n-        // what we expect (i.e. the contents of `v`).\n-        for (i, c) in DROP_COUNTS.iter().enumerate().take(len) {\n-            let count = c.load(Ordering::Relaxed);\n-            assert!(count == 1,\n-                    \"found drop count == {} for i == {}, len == {}\",\n-                    count, i, len);\n+            // Check that the most recent versions of values were dropped.\n+            assert_eq!(VERSIONS.load(Relaxed), 0);\n         }\n     }\n }\n@@ -106,33 +140,40 @@ fn main() {\n             prev(info);\n         }\n     }));\n+\n     for len in (1..20).chain(70..MAX_LEN) {\n-        // Test on a random array.\n-        let mut rng = thread_rng();\n-        let input = (0..len).map(|id| {\n-            DropCounter {\n-                x: rng.next_u32(),\n-                id: id,\n-            }\n-        }).collect::<Vec<_>>();\n-        test(&input);\n-\n-        // Test on a sorted array with two elements randomly swapped, creating several natural\n-        // runs of random lengths. Such arrays have very high chances of hitting all code paths in\n-        // the merge procedure.\n-        for _ in 0..5 {\n-            let mut input = (0..len).map(|i|\n-                DropCounter {\n-                    x: i as u32,\n-                    id: i,\n+        for &modulus in &[5, 20, 50] {\n+            for &has_runs in &[false, true] {\n+                let mut rng = thread_rng();\n+                let mut input = (0..len)\n+                    .map(|id| {\n+                        DropCounter {\n+                            x: rng.next_u32() % modulus,\n+                            id: id,\n+                            version: Cell::new(0),\n+                        }\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                if has_runs {\n+                    for c in &mut input {\n+                        c.x = c.id as u32;\n+                    }\n+\n+                    for _ in 0..5 {\n+                        let a = rng.gen::<usize>() % len;\n+                        let b = rng.gen::<usize>() % len;\n+                        if a < b {\n+                            input[a..b].reverse();\n+                        } else {\n+                            input.swap(a, b);\n+                        }\n+                    }\n                 }\n-            ).collect::<Vec<_>>();\n \n-            let a = rng.gen::<usize>() % len;\n-            let b = rng.gen::<usize>() % len;\n-            input.swap(a, b);\n-\n-            test(&input);\n+                test!(input, sort_by);\n+                test!(input, sort_unstable_by);\n+            }\n         }\n     }\n }"}]}