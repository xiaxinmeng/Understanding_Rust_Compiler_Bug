{"sha": "5c4d621a9622bbc444479c34e46d2e0f86606c44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNGQ2MjFhOTYyMmJiYzQ0NDQ3OWMzNGU0NmQyZTBmODY2MDZjNDQ=", "commit": {"author": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-07-16T05:21:00Z"}, "committer": {"name": "Cameron Hart", "email": "cameron.hart@gmail.com", "date": "2016-07-16T05:21:00Z"}, "message": "Merge branch 'master' into issue-30961", "tree": {"sha": "69b4c1de461511b2ae280d330b041a10f95792b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69b4c1de461511b2ae280d330b041a10f95792b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c4d621a9622bbc444479c34e46d2e0f86606c44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c4d621a9622bbc444479c34e46d2e0f86606c44", "html_url": "https://github.com/rust-lang/rust/commit/5c4d621a9622bbc444479c34e46d2e0f86606c44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c4d621a9622bbc444479c34e46d2e0f86606c44/comments", "author": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitshifter", "id": 135700, "node_id": "MDQ6VXNlcjEzNTcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/135700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitshifter", "html_url": "https://github.com/bitshifter", "followers_url": "https://api.github.com/users/bitshifter/followers", "following_url": "https://api.github.com/users/bitshifter/following{/other_user}", "gists_url": "https://api.github.com/users/bitshifter/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitshifter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitshifter/subscriptions", "organizations_url": "https://api.github.com/users/bitshifter/orgs", "repos_url": "https://api.github.com/users/bitshifter/repos", "events_url": "https://api.github.com/users/bitshifter/events{/privacy}", "received_events_url": "https://api.github.com/users/bitshifter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1efa324eca5badeb481ea8a4a54eaa180e8c3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1efa324eca5badeb481ea8a4a54eaa180e8c3fe", "html_url": "https://github.com/rust-lang/rust/commit/e1efa324eca5badeb481ea8a4a54eaa180e8c3fe"}, {"sha": "4db1874f4c26a2c88acb5e46b413e9c4adce3477", "url": "https://api.github.com/repos/rust-lang/rust/commits/4db1874f4c26a2c88acb5e46b413e9c4adce3477", "html_url": "https://github.com/rust-lang/rust/commit/4db1874f4c26a2c88acb5e46b413e9c4adce3477"}], "stats": {"total": 9514, "additions": 4610, "deletions": 4904}, "files": [{"sha": "283efdd2411564f962cdaf210c43eec37384a55a", "filename": "README.md", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -105,7 +105,7 @@ build.\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2013\n (or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n-option. In addition, `cmake` needs to be installed to build LLVM.\n+option.\n \n With these dependencies installed, the build takes two steps:\n \n@@ -116,13 +116,25 @@ $ make && make install\n \n #### MSVC with rustbuild\n \n-For those who don't want the hassle of MSYS or MinGW, you can invoke rustbuild\n-directly. All you need are Python 2, CMake, and Git in your PATH (make sure you\n-do __not__ use the ones from MSYS!). You'll also need Visual Studio 2013 or\n-newer with the C++ tools. Then all you need to do is invoke the appropriate\n-vcvars bat file and kick off rustbuild.\n+The old build system, based on makefiles, is currently being rewritten into a\n+Rust-based build system called rustbuild. This can be used to bootstrap the\n+compiler on MSVC without needing to install MSYS or MinGW. All you need are\n+[Python 2](https://www.python.org/downloads/),\n+[CMake](https://cmake.org/download/), and\n+[Git](https://git-scm.com/downloads) in your PATH (make sure you do not use the\n+ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n+newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n \n-```bat\n+```\n+python .\\src\\bootstrap\\bootstrap.py\n+```\n+\n+Currently rustbuild only works with some known versions of Visual Studio. If you\n+have a more recent version installed that a part of rustbuild doesn't understand\n+then you may need to force rustbuild to use an older version. This can be done\n+by manually calling the appropriate vcvars file before running the bootstrap.\n+\n+```\n CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n python .\\src\\bootstrap\\bootstrap.py\n ```"}, {"sha": "16496eb89d4ca8ef1ec581fb60fbebc0d43af1f3", "filename": "configure", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -637,10 +637,20 @@ valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone path\"\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n-valopt release-channel \"dev\" \"the name of the release channel to build\"\n valopt musl-root \"/usr/local\" \"MUSL root installation directory\"\n valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n \n+if [ -e ${CFG_SRC_DIR}.git ]\n+then\n+    valopt release-channel \"dev\" \"the name of the release channel to build\"\n+else\n+    # If we have no git directory then we are probably a tarball distribution\n+    # and should default to stable channel - Issue 28322\n+    probe CFG_GIT          git\n+    msg \"git: no git directory. Changing default release channel to stable\"\n+    valopt release-channel \"stable\" \"the name of the release channel to build\"\n+fi\n+\n # Used on systems where \"cc\" and \"ar\" are unavailable\n valopt default-linker \"cc\" \"the default linker\"\n valopt default-ar     \"ar\" \"the default ar\""}, {"sha": "fa61afd3be582215f26ea7262452c8c177e56f5b", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -44,7 +44,7 @@ The optional \\fIKIND\\fR can be one of \\fIstatic\\fR, \\fIdylib\\fR, or\n \\fIframework\\fR.\n If omitted, \\fIdylib\\fR is assumed.\n .TP\n-\\fB\\-\\-crate\\-type\\fR [bin|lib|rlib|dylib|staticlib]\n+\\fB\\-\\-crate\\-type\\fR [bin|lib|rlib|dylib|cdylib|staticlib]\n Comma separated list of types of crates for the compiler to emit.\n .TP\n \\fB\\-\\-crate\\-name\\fR \\fINAME\\fR"}, {"sha": "c2636384dbb2b447967ad6917e452cf9976d177a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -155,6 +155,7 @@ pub fn std(build: &Build, stage: u32, target: &str, out: &Path) {\n /// is largely just a wrapper around `cargo doc`.\n pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} test ({})\", stage, target);\n+    t!(fs::create_dir_all(out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n@@ -175,11 +176,12 @@ pub fn test(build: &Build, stage: u32, target: &str, out: &Path) {\n /// dependencies. This is largely just a wrapper around `cargo doc`.\n pub fn rustc(build: &Build, stage: u32, target: &str, out: &Path) {\n     println!(\"Documenting stage{} compiler ({})\", stage, target);\n+    t!(fs::create_dir_all(out));\n     let compiler = Compiler::new(stage, &build.config.build);\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n-    if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) {\n+    if !up_to_date(&rustdoc, &out_dir.join(\"rustc/index.html\")) && out_dir.exists() {\n         t!(fs::remove_dir_all(&out_dir));\n     }\n     let mut cargo = build.cargo(&compiler, Mode::Librustc, target, \"doc\");"}, {"sha": "82ae70d22ca060336d9088f20cba8834552ea3a9", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -380,10 +380,18 @@ impl<'a> Step<'a> {\n                 vec![self.doc_test(stage)]\n             }\n             Source::Doc { stage } => {\n-                vec![self.doc_book(stage), self.doc_nomicon(stage),\n-                     self.doc_style(stage), self.doc_standalone(stage),\n-                     self.doc_std(stage),\n-                     self.doc_error_index(stage)]\n+                let mut deps = vec![\n+                    self.doc_book(stage), self.doc_nomicon(stage),\n+                    self.doc_style(stage), self.doc_standalone(stage),\n+                    self.doc_std(stage),\n+                    self.doc_error_index(stage),\n+                ];\n+\n+                if build.config.compiler_docs {\n+                    deps.push(self.doc_rustc(stage));\n+                }\n+\n+                deps\n             }\n             Source::Check { stage, compiler } => {\n                 // Check is just a pseudo step which means check all targets,"}, {"sha": "666d0946ecc80a3eac3e25a9764bb34b097bd85b", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -336,7 +336,7 @@ could annotate it on the function declaration:\n \n ```rust,ignore\n fn call_with_ref<'a, F>(some_closure:F) -> i32\n-    where F: Fn(&'a 32) -> i32 {\n+    where F: Fn(&'a i32) -> i32 {\n ```\n \n However this presents a problem with in our case. When you specify the explicit\n@@ -350,7 +350,7 @@ of the closure we can use Higher-Ranked Trait Bounds with the `for<...>` syntax:\n \n ```ignore\n fn call_with_ref<F>(some_closure:F) -> i32\n-    where F: for<'a> Fn(&'a 32) -> i32 {\n+    where F: for<'a> Fn(&'a i32) -> i32 {\n ```\n \n This lets the Rust compiler find the minimum lifetime to invoke our closure and"}, {"sha": "3cbe5d6026774abca897db24797882d4065a95f6", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -183,8 +183,62 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n }\n ```\n \n-For reference, the examples used here are also available as a [library on\n-GitHub](https://github.com/thestinger/rust-snappy).\n+Then, we can add some tests to show how to use them.\n+\n+```rust\n+# #![feature(libc)]\n+# extern crate libc;\n+# use libc::{c_int, size_t};\n+# unsafe fn snappy_compress(input: *const u8,\n+#                           input_length: size_t,\n+#                           compressed: *mut u8,\n+#                           compressed_length: *mut size_t)\n+#                           -> c_int { 0 }\n+# unsafe fn snappy_uncompress(compressed: *const u8,\n+#                             compressed_length: size_t,\n+#                             uncompressed: *mut u8,\n+#                             uncompressed_length: *mut size_t)\n+#                             -> c_int { 0 }\n+# unsafe fn snappy_max_compressed_length(source_length: size_t) -> size_t { 0 }\n+# unsafe fn snappy_uncompressed_length(compressed: *const u8,\n+#                                      compressed_length: size_t,\n+#                                      result: *mut size_t)\n+#                                      -> c_int { 0 }\n+# unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,\n+#                                             compressed_length: size_t)\n+#                                             -> c_int { 0 }\n+# fn main() { }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn valid() {\n+        let d = vec![0xde, 0xad, 0xd0, 0x0d];\n+        let c: &[u8] = &compress(&d);\n+        assert!(validate_compressed_buffer(c));\n+        assert!(uncompress(c) == Some(d));\n+    }\n+\n+    #[test]\n+    fn invalid() {\n+        let d = vec![0, 0, 0, 0];\n+        assert!(!validate_compressed_buffer(&d));\n+        assert!(uncompress(&d).is_none());\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        let d = vec![];\n+        assert!(!validate_compressed_buffer(&d));\n+        assert!(uncompress(&d).is_none());\n+        let c = compress(&d);\n+        assert!(validate_compressed_buffer(&c));\n+        assert!(uncompress(&c) == Some(d));\n+    }\n+}\n+```\n \n # Destructors\n "}, {"sha": "9f40829f4233f1e4d76f37f5f39fcc4850eaeb28", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -328,7 +328,7 @@ invocation site. Code such as the following will not work:\n \n ```rust,ignore\n macro_rules! foo {\n-    () => (let x = 3);\n+    () => (let x = 3;);\n }\n \n fn main() {\n@@ -342,7 +342,7 @@ tagged with the right syntax context.\n \n ```rust\n macro_rules! foo {\n-    ($v:ident) => (let $v = 3);\n+    ($v:ident) => (let $v = 3;);\n }\n \n fn main() {"}, {"sha": "b3073f5e526033271c855588b8fb343d40d63bb5", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -2633,7 +2633,7 @@ comma:\n \n There are several forms of struct expressions. A _struct expression_\n consists of the [path](#paths) of a [struct item](#structs), followed by\n-a brace-enclosed list of one or more comma-separated name-value pairs,\n+a brace-enclosed list of zero or more comma-separated name-value pairs,\n providing the field values of a new instance of the struct. A field name\n can be any identifier, and is separated from its value expression by a colon.\n The location denoted by a struct field is mutable if and only if the\n@@ -2652,10 +2652,12 @@ The following are examples of struct expressions:\n \n ```\n # struct Point { x: f64, y: f64 }\n+# struct NothingInMe { }\n # struct TuplePoint(f64, f64);\n # mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n+NothingInMe {};\n TuplePoint(10.0, 20.0);\n let u = game::User {name: \"Joe\", age: 35, score: 100_000};\n some_fn::<Cookie>(Cookie);"}, {"sha": "822a3894fccb7145e3d7523f51bee5eef9836de2", "filename": "src/etc/unicode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -28,7 +28,7 @@\n bytes_old = 0\n bytes_new = 0\n \n-preamble = '''// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+preamble = '''// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}, {"sha": "e058ca661692a8d01f8cf9d35939dfe3105ce968", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1 +1 @@\n-Subproject commit aab1c0a0e0b39825b16673128729ef46310a5da8\n+Subproject commit e058ca661692a8d01f8cf9d35939dfe3105ce968"}, {"sha": "e762e4d8ce9a26a2d3690a40839d6e47ae280bd5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,23 +12,11 @@\n \n //! Threadsafe reference-counted boxes (the `Arc<T>` type).\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as `Send` because it uses atomic reference counting.\n-//!\n-//! If you do not need thread-safety, and just need shared ownership, consider\n-//! the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-//! does not use atomics, making it both thread-unsafe as well as significantly\n-//! faster when updating the reference count.\n-//!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n-//!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! The `Arc<T>` type provides shared ownership of an immutable value through\n+//! atomic reference counting.\n //!\n+//! `Weak<T>` is a weak reference to the `Arc<T>` box, and it is created by\n+//! the `downgrade` method.\n //! # Examples\n //!\n //! Sharing some immutable data between threads:\n@@ -47,27 +35,6 @@\n //!     });\n //! }\n //! ```\n-//!\n-//! Sharing mutable data safely between threads with a `Mutex`:\n-//!\n-//! ```no_run\n-//! use std::sync::{Arc, Mutex};\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(Mutex::new(5));\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         let mut number = five.lock().unwrap();\n-//!\n-//!         *number += 1;\n-//!\n-//!         println!(\"{}\", *number); // prints 6\n-//!     });\n-//! }\n-//! ```\n \n use boxed::Box;\n \n@@ -92,15 +59,19 @@ use heap::deallocate;\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n /// An atomically reference counted wrapper for shared state.\n+/// Destruction is deterministic, and will occur as soon as the last owner is\n+/// gone. It is marked as `Send` because it uses atomic reference counting.\n ///\n-/// # Examples\n+/// If you do not need thread-safety, and just need shared ownership, consider\n+/// the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n+/// does not use atomics, making it both thread-unsafe as well as significantly\n+/// faster when updating the reference count.\n ///\n-/// In this example, a large vector is shared between several threads.\n-/// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// thread.\n+/// # Examples\n ///\n-/// When you clone an `Arc<T>`, it will create another pointer to the data and\n-/// increase the reference counter.\n+/// In this example, a large vector of data will be shared by several threads. First we\n+/// wrap it with a `Arc::new` and then clone the `Arc<T>` reference for every thread (which will\n+/// increase the reference count atomically).\n ///\n /// ```\n /// use std::sync::Arc;\n@@ -111,6 +82,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in 0..10 {\n+///         // prepare a copy of reference here and it will be moved to the thread\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         thread::spawn(move || {\n@@ -121,6 +93,29 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///     }\n /// }\n /// ```\n+/// You can also share mutable data between threads safely\n+/// by putting it inside `Mutex` and then share `Mutex` immutably\n+/// with `Arc<T>` as shown below.\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// let five = Arc::new(Mutex::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let five = five.clone();\n+///\n+///     thread::spawn(move || {\n+///         let mut number = five.lock().unwrap();\n+///\n+///         *number += 1;\n+///\n+///         println!(\"{}\", *number); // prints 6\n+///     });\n+/// }\n+/// ```\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n@@ -139,6 +134,14 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n ///\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n /// used to break cycles between `Arc` pointers.\n+///\n+/// A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n+/// will return `None` if the value has already been dropped.\n+///\n+/// For example, a tree with parent pointers can be represented by putting the\n+/// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n+/// as `Weak<T>` pointers.\n+\n #[unsafe_no_drop_flag]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {"}, {"sha": "7ba5ca30941f476f01f7957325b1cd361ab43e27", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -249,6 +249,14 @@ impl<T: ?Sized> Box<T> {\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw(x);\n+    /// let x = unsafe { Box::from_raw(ptr) };\n+    /// ```\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -266,9 +274,8 @@ impl<T: ?Sized> Box<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let seventeen = Box::new(17);\n-    /// let raw = Box::into_raw(seventeen);\n-    /// let boxed_again = unsafe { Box::from_raw(raw) };\n+    /// let x = Box::new(5);\n+    /// let ptr = Box::into_raw(x);\n     /// ```\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n@@ -399,6 +406,24 @@ impl Box<Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(value: Box<Any>) {\n+    ///     if let Ok(string) = value.downcast::<String>() {\n+    ///         println!(\"String ({}): {}\", string.len(), string);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let my_string = \"Hello World\".to_string();\n+    ///     print_if_string(Box::new(my_string));\n+    ///     print_if_string(Box::new(0i8));\n+    /// }\n+    /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -419,6 +444,24 @@ impl Box<Any + Send> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(value: Box<Any + Send>) {\n+    ///     if let Ok(string) = value.downcast::<String>() {\n+    ///         println!(\"String ({}): {}\", string.len(), string);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let my_string = \"Hello World\".to_string();\n+    ///     print_if_string(Box::new(my_string));\n+    ///     print_if_string(Box::new(0i8));\n+    /// }\n+    /// ```\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n         <Box<Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker"}, {"sha": "dbede94f0bf1b668a8fa37173858c44cb2fc757a", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 283, "deletions": 352, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -13,19 +13,14 @@\n //! The `LinkedList` allows pushing and popping elements at either end and is thus\n //! efficiently usable as a double-ended queue.\n \n-// LinkedList is constructed like a singly-linked list over the field `next`.\n-// including the last link being None; each Node owns its `next` field.\n-//\n-// Backlinks over LinkedList::prev are raw pointers that form a full chain in\n-// the reverse direction.\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::{Box, IntermediateBox};\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hasher, Hash};\n use core::iter::FromIterator;\n+use core::marker::PhantomData;\n use core::mem;\n use core::ops::{BoxPlace, InPlace, Place, Placer};\n use core::ptr::{self, Shared};\n@@ -35,222 +30,156 @@ use super::SpecExtend;\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n-    length: usize,\n-    list_head: Link<T>,\n-    list_tail: Rawlink<Node<T>>,\n-}\n-\n-type Link<T> = Option<Box<Node<T>>>;\n-\n-struct Rawlink<T> {\n-    p: Option<Shared<T>>,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n+    marker: PhantomData<Box<Node<T>>>,\n }\n \n-impl<T> Copy for Rawlink<T> {}\n-unsafe impl<T: Send> Send for Rawlink<T> {}\n-unsafe impl<T: Sync> Sync for Rawlink<T> {}\n-\n struct Node<T> {\n-    next: Link<T>,\n-    prev: Rawlink<Node<T>>,\n-    value: T,\n+    next: Option<Shared<Node<T>>>,\n+    prev: Option<Shared<Node<T>>>,\n+    element: T,\n }\n \n-/// An iterator over references to the items of a `LinkedList`.\n+/// An iterator over references to the elements of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    head: &'a Link<T>,\n-    tail: Rawlink<Node<T>>,\n-    nelem: usize,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n+    marker: PhantomData<&'a Node<T>>,\n }\n \n // FIXME #19839: deriving is too aggressive on the bounds (T doesn't need to be Clone).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n-    fn clone(&self) -> Iter<'a, T> {\n-        Iter {\n-            head: self.head.clone(),\n-            tail: self.tail,\n-            nelem: self.nelem,\n-        }\n+    fn clone(&self) -> Self {\n+        Iter { ..*self }\n     }\n }\n \n-/// An iterator over mutable references to the items of a `LinkedList`.\n+/// An iterator over mutable references to the elements of a `LinkedList`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n     list: &'a mut LinkedList<T>,\n-    head: Rawlink<Node<T>>,\n-    tail: Rawlink<Node<T>>,\n-    nelem: usize,\n+    head: Option<Shared<Node<T>>>,\n+    tail: Option<Shared<Node<T>>>,\n+    len: usize,\n }\n \n-/// An iterator over the items of a `LinkedList`.\n+/// An iterator over the elements of a `LinkedList`.\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     list: LinkedList<T>,\n }\n \n-/// Rawlink is a type like Option<T> but for holding a raw pointer\n-impl<T> Rawlink<T> {\n-    /// Like Option::None for Rawlink\n-    fn none() -> Rawlink<T> {\n-        Rawlink { p: None }\n-    }\n-\n-    /// Like Option::Some for Rawlink\n-    fn some(n: &mut T) -> Rawlink<T> {\n-        unsafe { Rawlink { p: Some(Shared::new(n)) } }\n-    }\n-\n-    /// Convert the `Rawlink` into an Option value\n-    ///\n-    /// **unsafe** because:\n-    ///\n-    /// - Dereference of raw pointer.\n-    /// - Returns reference of arbitrary lifetime.\n-    unsafe fn resolve<'a>(&self) -> Option<&'a T> {\n-        self.p.map(|p| &**p)\n-    }\n-\n-    /// Convert the `Rawlink` into an Option value\n-    ///\n-    /// **unsafe** because:\n-    ///\n-    /// - Dereference of raw pointer.\n-    /// - Returns reference of arbitrary lifetime.\n-    unsafe fn resolve_mut<'a>(&mut self) -> Option<&'a mut T> {\n-        self.p.map(|p| &mut **p)\n-    }\n-\n-    /// Return the `Rawlink` and replace with `Rawlink::none()`\n-    fn take(&mut self) -> Rawlink<T> {\n-        mem::replace(self, Rawlink::none())\n-    }\n-}\n-\n-impl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n-    fn from(node: &'a mut Link<T>) -> Self {\n-        match node.as_mut() {\n-            None => Rawlink::none(),\n-            Some(ptr) => Rawlink::some(ptr),\n-        }\n-    }\n-}\n-\n-impl<T> Clone for Rawlink<T> {\n-    #[inline]\n-    fn clone(&self) -> Rawlink<T> {\n-        Rawlink { p: self.p }\n-    }\n-}\n-\n impl<T> Node<T> {\n-    fn new(v: T) -> Node<T> {\n+    fn new(element: T) -> Self {\n         Node {\n-            value: v,\n             next: None,\n-            prev: Rawlink::none(),\n+            prev: None,\n+            element: element,\n         }\n     }\n \n-    /// Update the `prev` link on `next`, then set self's next pointer.\n-    ///\n-    /// `self.next` should be `None` when you call this\n-    /// (otherwise a Node is probably being dropped by mistake).\n-    fn set_next(&mut self, mut next: Box<Node<T>>) {\n-        debug_assert!(self.next.is_none());\n-        next.prev = Rawlink::some(self);\n-        self.next = Some(next);\n+    fn into_element(self: Box<Self>) -> T {\n+        self.element\n     }\n }\n \n-/// Clear the .prev field on `next`, then return `Some(next)`\n-fn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {\n-    next.prev = Rawlink::none();\n-    Some(next)\n-}\n-\n // private methods\n impl<T> LinkedList<T> {\n-    /// Add a Node first in the list\n+    /// Adds the given node to the front of the list.\n     #[inline]\n-    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n-        match self.list_head {\n-            None => {\n-                self.list_head = link_no_prev(new_head);\n-                self.list_tail = Rawlink::from(&mut self.list_head);\n-            }\n-            Some(ref mut head) => {\n-                new_head.prev = Rawlink::none();\n-                head.prev = Rawlink::some(&mut *new_head);\n-                mem::swap(head, &mut new_head);\n-                head.next = Some(new_head);\n+    fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n+        unsafe {\n+            node.next = self.head;\n+            node.prev = None;\n+            let node = Some(Shared::new(Box::into_raw(node)));\n+\n+            match self.head {\n+                None => self.tail = node,\n+                Some(head) => (**head).prev = node,\n             }\n+\n+            self.head = node;\n+            self.len += 1;\n         }\n-        self.length += 1;\n     }\n \n-    /// Remove the first Node and return it, or None if the list is empty\n+    /// Removes and returns the node at the front of the list.\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n-        self.list_head.take().map(|mut front_node| {\n-            self.length -= 1;\n-            match front_node.next.take() {\n-                Some(node) => self.list_head = link_no_prev(node),\n-                None => self.list_tail = Rawlink::none(),\n+        self.head.map(|node| unsafe {\n+            let node = Box::from_raw(*node);\n+            self.head = node.next;\n+\n+            match self.head {\n+                None => self.tail = None,\n+                Some(head) => (**head).prev = None,\n             }\n-            front_node\n+\n+            self.len -= 1;\n+            node\n         })\n     }\n \n-    /// Add a Node last in the list\n+    /// Adds the given node to the back of the list.\n     #[inline]\n-    fn push_back_node(&mut self, new_tail: Box<Node<T>>) {\n-        match unsafe { self.list_tail.resolve_mut() } {\n-            None => return self.push_front_node(new_tail),\n-            Some(tail) => {\n-                tail.set_next(new_tail);\n-                self.list_tail = Rawlink::from(&mut tail.next);\n+    fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n+        unsafe {\n+            node.next = None;\n+            node.prev = self.tail;\n+            let node = Some(Shared::new(Box::into_raw(node)));\n+\n+            match self.tail {\n+                None => self.head = node,\n+                Some(tail) => (**tail).next = node,\n             }\n+\n+            self.tail = node;\n+            self.len += 1;\n         }\n-        self.length += 1;\n     }\n \n-    /// Remove the last Node and return it, or None if the list is empty\n+    /// Removes and returns the node at the back of the list.\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n-        unsafe {\n-            self.list_tail.resolve_mut().and_then(|tail| {\n-                self.length -= 1;\n-                self.list_tail = tail.prev;\n-                match tail.prev.resolve_mut() {\n-                    None => self.list_head.take(),\n-                    Some(tail_prev) => tail_prev.next.take(),\n-                }\n-            })\n-        }\n+        self.tail.map(|node| unsafe {\n+            let node = Box::from_raw(*node);\n+            self.tail = node.prev;\n+\n+            match self.tail {\n+                None => self.head = None,\n+                Some(tail) => (**tail).next = None,\n+            }\n+\n+            self.len -= 1;\n+            node\n+        })\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for LinkedList<T> {\n     #[inline]\n-    fn default() -> LinkedList<T> {\n-        LinkedList::new()\n+    fn default() -> Self {\n+        Self::new()\n     }\n }\n \n impl<T> LinkedList<T> {\n     /// Creates an empty `LinkedList`.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> LinkedList<T> {\n+    pub fn new() -> Self {\n         LinkedList {\n-            list_head: None,\n-            list_tail: Rawlink::none(),\n-            length: 0,\n+            head: None,\n+            tail: None,\n+            len: 0,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -281,38 +210,30 @@ impl<T> LinkedList<T> {\n     /// println!(\"{}\", b.len()); // prints 0\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn append(&mut self, other: &mut LinkedList<T>) {\n-        match unsafe { self.list_tail.resolve_mut() } {\n-            None => {\n-                self.length = other.length;\n-                self.list_head = other.list_head.take();\n-                self.list_tail = other.list_tail.take();\n-            }\n-            Some(tail) => {\n-                // Carefully empty `other`.\n-                let o_tail = other.list_tail.take();\n-                let o_length = other.length;\n-                match other.list_head.take() {\n-                    None => return,\n-                    Some(node) => {\n-                        tail.set_next(node);\n-                        self.list_tail = o_tail;\n-                        self.length += o_length;\n-                    }\n+    pub fn append(&mut self, other: &mut Self) {\n+        match self.tail {\n+            None => mem::swap(self, other),\n+            Some(tail) => if let Some(other_head) = other.head.take() {\n+                unsafe {\n+                    (**tail).next = Some(other_head);\n+                    (**other_head).prev = Some(tail);\n                 }\n-            }\n+\n+                self.tail = other.tail.take();\n+                self.len += mem::replace(&mut other.len, 0);\n+            },\n         }\n-        other.length = 0;\n     }\n \n     /// Provides a forward iterator.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter {\n-            nelem: self.len(),\n-            head: &self.list_head,\n-            tail: self.list_tail,\n+            head: self.head,\n+            tail: self.tail,\n+            len: self.len,\n+            marker: PhantomData,\n         }\n     }\n \n@@ -321,9 +242,9 @@ impl<T> LinkedList<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut {\n-            nelem: self.len(),\n-            head: Rawlink::from(&mut self.list_head),\n-            tail: self.list_tail,\n+            head: self.head,\n+            tail: self.tail,\n+            len: self.len,\n             list: self,\n         }\n     }\n@@ -346,7 +267,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.list_head.is_none()\n+        self.head.is_none()\n     }\n \n     /// Returns the length of the `LinkedList`.\n@@ -373,7 +294,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n-        self.length\n+        self.len\n     }\n \n     /// Removes all elements from the `LinkedList`.\n@@ -400,7 +321,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = LinkedList::new()\n+        *self = Self::new();\n     }\n \n     /// Returns `true` if the `LinkedList` contains an element equal to the\n@@ -431,7 +352,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.list_head.as_ref().map(|head| &head.value)\n+        self.head.map(|node| unsafe { &(**node).element })\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -458,7 +379,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.list_head.as_mut().map(|head| &mut head.value)\n+        self.head.map(|node| unsafe { &mut (**node).element })\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -479,7 +400,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        unsafe { self.list_tail.resolve().map(|tail| &tail.value) }\n+        self.tail.map(|node| unsafe { &(**node).element })\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -506,7 +427,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        unsafe { self.list_tail.resolve_mut().map(|tail| &mut tail.value) }\n+        self.tail.map(|node| unsafe { &mut (**node).element })\n     }\n \n     /// Adds an element first in the list.\n@@ -529,7 +450,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n-        self.push_front_node(box Node::new(elt))\n+        self.push_front_node(box Node::new(elt));\n     }\n \n     /// Removes the first element and returns it, or `None` if the list is\n@@ -555,7 +476,7 @@ impl<T> LinkedList<T> {\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|box Node { value, .. }| value)\n+        self.pop_front_node().map(Node::into_element)\n     }\n \n     /// Appends an element to the back of a list\n@@ -572,7 +493,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n-        self.push_back_node(box Node::new(elt))\n+        self.push_back_node(box Node::new(elt));\n     }\n \n     /// Removes the last element from a list and returns it, or `None` if\n@@ -591,7 +512,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|box Node { value, .. }| value)\n+        self.pop_back_node().map(Node::into_element)\n     }\n \n     /// Splits the list into two at the given index. Returns everything after the given index,\n@@ -624,14 +545,14 @@ impl<T> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, LinkedList::new());\n+            return mem::replace(self, Self::new());\n         } else if at == len {\n-            return LinkedList::new();\n+            return Self::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n         // depending on which would be faster.\n-        let mut split_node = if at - 1 <= len - 1 - (at - 1) {\n+        let split_node = if at - 1 <= len - 1 - (at - 1) {\n             let mut iter = self.iter_mut();\n             // instead of skipping using .skip() (which creates a new struct),\n             // we skip manually so we can access the head field without\n@@ -651,25 +572,25 @@ impl<T> LinkedList<T> {\n \n         // The split node is the new tail node of the first part and owns\n         // the head of the second part.\n-        let mut second_part_head;\n+        let second_part_head;\n \n         unsafe {\n-            second_part_head = split_node.resolve_mut().unwrap().next.take();\n-            match second_part_head {\n-                None => {}\n-                Some(ref mut head) => head.prev = Rawlink::none(),\n+            second_part_head = (**split_node.unwrap()).next.take();\n+            if let Some(head) = second_part_head {\n+                (**head).prev = None;\n             }\n         }\n \n         let second_part = LinkedList {\n-            list_head: second_part_head,\n-            list_tail: self.list_tail,\n-            length: len - at,\n+            head: second_part_head,\n+            tail: self.tail,\n+            len: len - at,\n+            marker: PhantomData,\n         };\n \n         // Fix the tail ptr of the first part\n-        self.list_tail = split_node;\n-        self.length = at;\n+        self.tail = split_node;\n+        self.len = at;\n \n         second_part\n     }\n@@ -729,129 +650,100 @@ impl<T> LinkedList<T> {\n impl<T> Drop for LinkedList<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n-        // Dissolve the linked_list in a loop.\n-        // Just dropping the list_head can lead to stack exhaustion\n-        // when length is >> 1_000_000\n-        while let Some(mut head_) = self.list_head.take() {\n-            self.list_head = head_.next.take();\n-        }\n-        self.length = 0;\n-        self.list_tail = Rawlink::none();\n+        while let Some(_) = self.pop_front_node() {}\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> Iterator for Iter<'a, A> {\n-    type Item = &'a A;\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<&'a A> {\n-        if self.nelem == 0 {\n-            return None;\n+    fn next(&mut self) -> Option<&'a T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe {\n+                let node = &**node;\n+                self.len -= 1;\n+                self.head = node.next;\n+                &node.element\n+            })\n         }\n-        self.head.as_ref().map(|head| {\n-            self.nelem -= 1;\n-            self.head = &head.next;\n-            &head.value\n-        })\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.nelem, Some(self.nelem))\n+        (self.len, Some(self.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.tail.resolve().map(|prev| {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                &prev.value\n+    fn next_back(&mut self) -> Option<&'a T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.tail.map(|node| unsafe {\n+                let node = &**node;\n+                self.len -= 1;\n+                self.tail = node.prev;\n+                &node.element\n             })\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> Iterator for IterMut<'a, A> {\n-    type Item = &'a mut A;\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<&'a mut A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.head.resolve_mut().map(|next| {\n-                self.nelem -= 1;\n-                self.head = Rawlink::from(&mut next.next);\n-                &mut next.value\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe {\n+                let node = &mut **node;\n+                self.len -= 1;\n+                self.head = node.next;\n+                &mut node.element\n             })\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.nelem, Some(self.nelem))\n+        (self.len, Some(self.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut A> {\n-        if self.nelem == 0 {\n-            return None;\n-        }\n-        unsafe {\n-            self.tail.resolve_mut().map(|prev| {\n-                self.nelem -= 1;\n-                self.tail = prev.prev;\n-                &mut prev.value\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.tail.map(|node| unsafe {\n+                let node = &mut **node;\n+                self.len -= 1;\n+                self.tail = node.prev;\n+                &mut node.element\n             })\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n-\n-// private methods for IterMut\n-impl<'a, A> IterMut<'a, A> {\n-    fn insert_next_node(&mut self, mut ins_node: Box<Node<A>>) {\n-        // Insert before `self.head` so that it is between the\n-        // previously yielded element and self.head.\n-        //\n-        // The inserted node will not appear in further iteration.\n-        match unsafe { self.head.resolve_mut() } {\n-            None => {\n-                self.list.push_back_node(ins_node);\n-            }\n-            Some(node) => {\n-                let prev_node = match unsafe { node.prev.resolve_mut() } {\n-                    None => return self.list.push_front_node(ins_node),\n-                    Some(prev) => prev,\n-                };\n-                let node_own = prev_node.next.take().unwrap();\n-                ins_node.set_next(node_own);\n-                prev_node.set_next(ins_node);\n-                self.list.length += 1;\n-            }\n-        }\n-    }\n-}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n-impl<'a, A> IterMut<'a, A> {\n-    /// Inserts `elt` just after the element most recently returned by `.next()`.\n+impl<'a, T> IterMut<'a, T> {\n+    /// Inserts the given element just after the element most recently returned by `.next()`.\n     /// The inserted element does not appear in the iteration.\n     ///\n     /// # Examples\n@@ -878,8 +770,27 @@ impl<'a, A> IterMut<'a, A> {\n     #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\",\n                issue = \"27794\")]\n-    pub fn insert_next(&mut self, elt: A) {\n-        self.insert_next_node(box Node::new(elt))\n+    pub fn insert_next(&mut self, element: T) {\n+        match self.head {\n+            None => self.list.push_back(element),\n+            Some(head) => unsafe {\n+                let prev = match (**head).prev {\n+                    None => return self.list.push_front(element),\n+                    Some(prev) => prev,\n+                };\n+\n+                let node = Some(Shared::new(Box::into_raw(box Node {\n+                    next: Some(head),\n+                    prev: Some(prev),\n+                    element: element,\n+                })));\n+\n+                (**prev).next = node;\n+                (**head).prev = node;\n+\n+                self.list.len += 1;\n+            }\n+        }\n     }\n \n     /// Provides a reference to the next element, without changing the iterator.\n@@ -903,46 +814,47 @@ impl<'a, A> IterMut<'a, A> {\n     #[unstable(feature = \"linked_list_extras\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\",\n                issue = \"27794\")]\n-    pub fn peek_next(&mut self) -> Option<&mut A> {\n-        if self.nelem == 0 {\n-            return None;\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        if self.len == 0 {\n+            None\n+        } else {\n+            self.head.map(|node| unsafe { &mut (**node).element })\n         }\n-        unsafe { self.head.resolve_mut().map(|head| &mut head.value) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Iterator for IntoIter<A> {\n-    type Item = A;\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         self.list.pop_front()\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.list.length, Some(self.list.length))\n+        (self.list.len, Some(self.list.len))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> DoubleEndedIterator for IntoIter<A> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<T> {\n         self.list.pop_back()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> ExactSizeIterator for IntoIter<A> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> FromIterator<A> for LinkedList<A> {\n-    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> LinkedList<A> {\n-        let mut ret = LinkedList::new();\n-        ret.extend(iter);\n-        ret\n+impl<T> FromIterator<T> for LinkedList<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+        let mut list = Self::new();\n+        list.extend(iter);\n+        list\n     }\n }\n \n@@ -973,15 +885,15 @@ impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n-    fn into_iter(mut self) -> IterMut<'a, T> {\n+    fn into_iter(self) -> IterMut<'a, T> {\n         self.iter_mut()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A> Extend<A> for LinkedList<A> {\n-    fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n-        <Self as SpecExtend<T>>::spec_extend(self, iter);\n+impl<T> Extend<T> for LinkedList<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n }\n \n@@ -1007,50 +919,50 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialEq> PartialEq for LinkedList<A> {\n-    fn eq(&self, other: &LinkedList<A>) -> bool {\n-        self.len() == other.len() && self.iter().eq(other.iter())\n+impl<T: PartialEq> PartialEq for LinkedList<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.len() == other.len() && self.iter().eq(other)\n     }\n \n-    fn ne(&self, other: &LinkedList<A>) -> bool {\n-        self.len() != other.len() || self.iter().ne(other.iter())\n+    fn ne(&self, other: &Self) -> bool {\n+        self.len() != other.len() || self.iter().ne(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Eq> Eq for LinkedList<A> {}\n+impl<T: Eq> Eq for LinkedList<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: PartialOrd> PartialOrd for LinkedList<A> {\n-    fn partial_cmp(&self, other: &LinkedList<A>) -> Option<Ordering> {\n-        self.iter().partial_cmp(other.iter())\n+impl<T: PartialOrd> PartialOrd for LinkedList<T> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        self.iter().partial_cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Ord> Ord for LinkedList<A> {\n+impl<T: Ord> Ord for LinkedList<T> {\n     #[inline]\n-    fn cmp(&self, other: &LinkedList<A>) -> Ordering {\n-        self.iter().cmp(other.iter())\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.iter().cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Clone for LinkedList<A> {\n-    fn clone(&self) -> LinkedList<A> {\n+impl<T: Clone> Clone for LinkedList<T> {\n+    fn clone(&self) -> Self {\n         self.iter().cloned().collect()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n+impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_list().entries(self.iter()).finish()\n+        f.debug_list().entries(self).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Hash> Hash for LinkedList<A> {\n+impl<T: Hash> Hash for LinkedList<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.len().hash(state);\n         for elt in self {\n@@ -1062,7 +974,7 @@ impl<A: Hash> Hash for LinkedList<A> {\n unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n     let mut node = node.finalize();\n     ptr::write(&mut node.next, None);\n-    ptr::write(&mut node.prev, Rawlink::none());\n+    ptr::write(&mut node.prev, None);\n     node\n }\n \n@@ -1094,7 +1006,7 @@ impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n            issue = \"30172\")]\n impl<'a, T> Place<T> for FrontPlace<'a, T> {\n     fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).value }\n+        unsafe { &mut (*self.node.pointer()).element }\n     }\n }\n \n@@ -1138,7 +1050,7 @@ impl<'a, T> Placer<T> for BackPlace<'a, T> {\n            issue = \"30172\")]\n impl<'a, T> Place<T> for BackPlace<'a, T> {\n     fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).value }\n+        unsafe { &mut (*self.node.pointer()).element }\n     }\n }\n \n@@ -1162,6 +1074,24 @@ fn assert_covariance() {\n     fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> { x }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Send> Send for LinkedList<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: Sync> Sync for LinkedList<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n+\n #[cfg(test)]\n mod tests {\n     use std::clone::Clone;\n@@ -1179,38 +1109,40 @@ mod tests {\n     }\n \n     pub fn check_links<T>(list: &LinkedList<T>) {\n-        let mut len = 0;\n-        let mut last_ptr: Option<&Node<T>> = None;\n-        let mut node_ptr: &Node<T>;\n-        match list.list_head {\n-            None => {\n-                assert_eq!(0, list.length);\n-                return;\n-            }\n-            Some(ref node) => node_ptr = &**node,\n-        }\n-        loop {\n-            match unsafe { (last_ptr, node_ptr.prev.resolve()) } {\n-                (None, None) => {}\n-                (None, _) => panic!(\"prev link for list_head\"),\n-                (Some(p), Some(pptr)) => {\n-                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n+        unsafe {\n+            let mut len = 0;\n+            let mut last_ptr: Option<&Node<T>> = None;\n+            let mut node_ptr: &Node<T>;\n+            match list.head {\n+                None => {\n+                    assert_eq!(0, list.len);\n+                    return;\n                 }\n-                _ => panic!(\"prev link is none, not good\"),\n+                Some(node) => node_ptr = &**node,\n             }\n-            match node_ptr.next {\n-                Some(ref next) => {\n-                    last_ptr = Some(node_ptr);\n-                    node_ptr = &**next;\n-                    len += 1;\n+            loop {\n+                match (last_ptr, node_ptr.prev) {\n+                    (None, None) => {}\n+                    (None, _) => panic!(\"prev link for head\"),\n+                    (Some(p), Some(pptr)) => {\n+                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                    }\n+                    _ => panic!(\"prev link is none, not good\"),\n                 }\n-                None => {\n-                    len += 1;\n-                    break;\n+                match node_ptr.next {\n+                    Some(next) => {\n+                        last_ptr = Some(node_ptr);\n+                        node_ptr = &**next;\n+                        len += 1;\n+                    }\n+                    None => {\n+                        len += 1;\n+                        break;\n+                    }\n                 }\n             }\n+            assert_eq!(len, list.len);\n         }\n-        assert_eq!(len, list.length);\n     }\n \n     #[test]\n@@ -1359,7 +1291,6 @@ mod tests {\n         }\n     }\n \n-\n     #[cfg(test)]\n     fn fuzz_test(sz: i32) {\n         let mut m: LinkedList<_> = LinkedList::new();"}, {"sha": "2c54dc13c8d0b6440494bf927138dfec7a6b06fd", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 237, "deletions": 11, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -151,7 +151,6 @@ mod hack {\n     }\n }\n \n-/// Allocating extension methods for slices.\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -200,28 +199,74 @@ impl<T> [T] {\n         core_slice::SliceExt::first(self)\n     }\n \n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(first) = x.first_mut() {\n+    ///     *first = 5;\n+    /// }\n+    /// assert_eq!(x, &[5, 1, 2]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn first_mut(&mut self) -> Option<&mut T> {\n         core_slice::SliceExt::first_mut(self)\n     }\n \n     /// Returns the first and all the rest of the elements of a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first() {\n+    ///     assert_eq!(first, &0);\n+    ///     assert_eq!(elements, &[1, 2]);\n+    /// }\n+    /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first(&self) -> Option<(&T, &[T])> {\n         core_slice::SliceExt::split_first(self)\n     }\n \n     /// Returns the first and all the rest of the elements of a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_mut() {\n+    ///     *first = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 5]);\n+    /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_first_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n         core_slice::SliceExt::split_first_mut(self)\n     }\n \n     /// Returns the last and all the rest of the elements of a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last() {\n+    ///     assert_eq!(last, &2);\n+    ///     assert_eq!(elements, &[0, 1]);\n+    /// }\n+    /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last(&self) -> Option<(&T, &[T])> {\n@@ -230,6 +275,19 @@ impl<T> [T] {\n     }\n \n     /// Returns the last and all the rest of the elements of a slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_mut() {\n+    ///     *last = 3;\n+    ///     elements[0] = 4;\n+    ///     elements[1] = 5;\n+    /// }\n+    /// assert_eq!(x, &[4, 5, 3]);\n+    /// ```\n     #[stable(feature = \"slice_splits\", since = \"1.5.0\")]\n     #[inline]\n     pub fn split_last_mut(&mut self) -> Option<(&mut T, &mut [T])> {\n@@ -254,6 +312,17 @@ impl<T> [T] {\n     }\n \n     /// Returns a mutable pointer to the last item in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(last) = x.last_mut() {\n+    ///     *last = 10;\n+    /// }\n+    /// assert_eq!(x, &[0, 1, 10]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn last_mut(&mut self) -> Option<&mut T> {\n@@ -276,7 +345,18 @@ impl<T> [T] {\n         core_slice::SliceExt::get(self, index)\n     }\n \n-    /// Returns a mutable reference to the element at the given index,\n+    /// Returns a mutable reference to the element at the given index.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(elem) = x.get_mut(1) {\n+    ///     *elem = 42;\n+    /// }\n+    /// assert_eq!(x, &[0, 42, 2]);\n+    /// ```\n     /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -285,14 +365,37 @@ impl<T> [T] {\n     }\n \n     /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n+    /// bounds checking. So use it very carefully!\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked(1), &2);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n-    /// Returns an unsafe mutable pointer to the element in index\n+    /// Returns an unsafe mutable pointer to the element in index. So use it\n+    /// very carefully!\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    ///\n+    /// unsafe {\n+    ///     let elem = x.get_unchecked_mut(1);\n+    ///     *elem = 13;\n+    /// }\n+    /// assert_eq!(x, &[1, 13, 4]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n@@ -306,6 +409,19 @@ impl<T> [T] {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let x_ptr = x.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         assert_eq!(x.get_unchecked(i), &*x_ptr.offset(i as isize));\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_ptr(&self) -> *const T {\n@@ -319,6 +435,20 @@ impl<T> [T] {\n     ///\n     /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// let x_ptr = x.as_mut_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         *x_ptr.offset(i as isize) += 2;\n+    ///     }\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n@@ -336,7 +466,7 @@ impl<T> [T] {\n     ///\n     /// Panics if `a` or `b` are out of bounds.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n@@ -365,13 +495,39 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &[1, 2, 4];\n+    /// let mut iterator = x.iter();\n+    ///\n+    /// assert_eq!(iterator.next(), Some(&1));\n+    /// assert_eq!(iterator.next(), Some(&2));\n+    /// assert_eq!(iterator.next(), Some(&4));\n+    /// assert_eq!(iterator.next(), None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<T> {\n         core_slice::SliceExt::iter(self)\n     }\n \n-    /// Returns an iterator that allows modifying each value\n+    /// Returns an iterator that allows modifying each value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = &mut [1, 2, 4];\n+    /// {\n+    ///     let iterator = x.iter_mut();\n+    ///\n+    ///     for elem in iterator {\n+    ///         *elem += 2;\n+    ///     }\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 6]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n@@ -419,6 +575,7 @@ impl<T> [T] {\n     ///\n     /// ```rust\n     /// let v = &[1, 2, 3, 4, 5];\n+    ///\n     /// for chunk in v.chunks(2) {\n     ///     println!(\"{:?}\", chunk);\n     /// }\n@@ -437,6 +594,21 @@ impl<T> [T] {\n     /// # Panics\n     ///\n     /// Panics if `chunk_size` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.chunks_mut(2) {\n+    ///     for elem in chunk.iter_mut() {\n+    ///         *elem += count;\n+    ///     }\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n@@ -477,7 +649,7 @@ impl<T> [T] {\n     ///\n     /// Panics if `mid > len`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// let mut v = [1, 2, 3, 4, 5, 6];\n@@ -508,7 +680,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n+    /// `pred`. The matched element is not contained in the subslices.\n     ///\n     /// # Examples\n     ///\n@@ -517,6 +689,7 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n     /// for group in v.split(|num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n@@ -530,7 +703,18 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n+    /// match `pred`. The matched element is not contained in the subslices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_mut(|num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 1]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n@@ -553,6 +737,7 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n     /// for group in v.splitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n@@ -571,6 +756,17 @@ impl<T> [T] {\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n     /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.splitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(v, [1, 40, 30, 1, 60, 50]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n@@ -594,6 +790,7 @@ impl<T> [T] {\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n+    ///\n     /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n@@ -613,6 +810,17 @@ impl<T> [T] {\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n     /// slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in s.rsplitn_mut(2, |num| *num % 3 == 0) {\n+    ///     group[0] = 1;\n+    /// }\n+    /// assert_eq!(s, [1, 40, 30, 20, 60, 1]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn rsplitn_mut<F>(&mut self, n: usize, pred: F) -> RSplitNMut<T, F>\n@@ -848,7 +1056,7 @@ impl<T> [T] {\n \n     /// Copies the elements from `src` into `self`.\n     ///\n-    /// The length of this slice must be the same as the slice passed in.\n+    /// The length of `src` must be the same as `self`.\n     ///\n     /// # Panics\n     ///\n@@ -892,6 +1100,14 @@ impl<T> [T] {\n \n \n     /// Copies `self` into a new `Vec`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = [10, 40, 30];\n+    /// let x = s.to_vec();\n+    /// // Here, `s` and `x` can be modified independently.\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n@@ -902,6 +1118,16 @@ impl<T> [T] {\n     }\n \n     /// Converts `self` into a vector without clones or allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s: Box<[i32]> = Box::new([10, 40, 30]);\n+    /// let x = s.into_vec();\n+    /// // `s` cannot be used anymore because it has been converted into `x`.\n+    ///\n+    /// assert_eq!(x, vec!(10, 40, 30));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec(self: Box<Self>) -> Vec<T> {"}, {"sha": "da56b21cf0c050c8a2c0bd3a1282e583e47f789f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1603,6 +1603,12 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// An iterator that moves out of a vector.\n+///\n+/// This `struct` is created by the `into_iter` method on [`Vec`][`Vec`] (provided\n+/// by the [`IntoIterator`] trait).\n+///\n+/// [`Vec`]: struct.Vec.html\n+/// [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n     _buf: RawVec<T>,\n@@ -1710,6 +1716,11 @@ impl<T> Drop for IntoIter<T> {\n }\n \n /// A draining iterator for `Vec<T>`.\n+///\n+/// This `struct` is created by the [`drain`] method on [`Vec`].\n+///\n+/// [`drain`]: struct.Vec.html#method.drain\n+/// [`Vec`]: struct.Vec.html\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, T: 'a> {\n     /// Index of tail to preserve"}, {"sha": "a452be2565b655e14597eed0116d65386bc53210", "filename": "src/libcore/any.rs", "status": "modified", "additions": 158, "deletions": 2, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -92,6 +92,23 @@ use marker::{Reflect, Sized};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: Reflect + 'static {\n     /// Gets the `TypeId` of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_type_id)]\n+    ///\n+    /// use std::any::{Any, TypeId};\n+    ///\n+    /// fn is_string(s: &Any) -> bool {\n+    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(is_string(&0), false);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    /// }\n+    /// ```\n     #[unstable(feature = \"get_type_id\",\n                reason = \"this method will likely be replaced by an associated static\",\n                issue = \"27745\")]\n@@ -125,7 +142,26 @@ impl fmt::Debug for Any + Send {\n }\n \n impl Any {\n-    /// Returns true if the boxed type is the same as `T`\n+    /// Returns true if the boxed type is the same as `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn is_string(s: &Any) {\n+    ///     if s.is::<String>() {\n+    ///         println!(\"It's a string!\");\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     is_string(&0);\n+    ///     is_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n@@ -141,6 +177,25 @@ impl Any {\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(s: &Any) {\n+    ///     if let Some(string) = s.downcast_ref::<String>() {\n+    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     print_if_string(&0);\n+    ///     print_if_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n@@ -159,6 +214,29 @@ impl Any {\n \n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn modify_if_u32(s: &mut Any) {\n+    ///     if let Some(num) = s.downcast_mut::<u32>() {\n+    ///         *num = 42;\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x = 10u32;\n+    ///     let mut s = \"starlord\".to_owned();\n+    ///\n+    ///     modify_if_u32(&mut x);\n+    ///     modify_if_u32(&mut s);\n+    ///\n+    ///     assert_eq!(x, 42);\n+    ///     assert_eq!(&s, \"starlord\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n@@ -178,20 +256,81 @@ impl Any {\n \n impl Any+Send {\n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn is_string(s: &(Any + Send)) {\n+    ///     if s.is::<String>() {\n+    ///         println!(\"It's a string!\");\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     is_string(&0);\n+    ///     is_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n         Any::is::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn print_if_string(s: &(Any + Send)) {\n+    ///     if let Some(string) = s.downcast_ref::<String>() {\n+    ///         println!(\"It's a string({}): '{}'\", string.len(), string);\n+    ///     } else {\n+    ///         println!(\"Not a string...\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     print_if_string(&0);\n+    ///     print_if_string(&\"cookie monster\".to_owned());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n         Any::downcast_ref::<T>(self)\n     }\n \n     /// Forwards to the method defined on the type `Any`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    ///\n+    /// fn modify_if_u32(s: &mut (Any+ Send)) {\n+    ///     if let Some(num) = s.downcast_mut::<u32>() {\n+    ///         *num = 42;\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let mut x = 10u32;\n+    ///     let mut s = \"starlord\".to_owned();\n+    ///\n+    ///     modify_if_u32(&mut x);\n+    ///     modify_if_u32(&mut s);\n+    ///\n+    ///     assert_eq!(x, 42);\n+    ///     assert_eq!(&s, \"starlord\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn downcast_mut<T: Any>(&mut self) -> Option<&mut T> {\n@@ -220,7 +359,24 @@ pub struct TypeId {\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n-    /// instantiated with\n+    /// instantiated with.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_type_id)]\n+    ///\n+    /// use std::any::{Any, TypeId};\n+    ///\n+    /// fn is_string(s: &Any) -> bool {\n+    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(is_string(&0), false);\n+    ///     assert_eq!(is_string(&\"cookie monster\".to_owned()), true);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId {\n         TypeId {"}, {"sha": "65cb1aaaff6fd1e729d0e9a4ceb9a09ca57269a8", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -237,6 +237,17 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// This call borrows `Cell` mutably (at compile-time) which guarantees\n     /// that we possess the only reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let mut c = Cell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(c.get(), 6);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n@@ -388,6 +399,22 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n     /// `borrow` or `borrow_mut` would succeed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(borrow_state)]\n+    ///\n+    /// use std::cell::{BorrowState, RefCell};\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// match c.borrow_state() {\n+    ///     BorrowState::Writing => println!(\"Cannot be borrowed\"),\n+    ///     BorrowState::Reading => println!(\"Cannot be borrowed mutably\"),\n+    ///     BorrowState::Unused => println!(\"Can be borrowed (mutably as well)\"),\n+    /// }\n+    /// ```\n     #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n     #[inline]\n     pub fn borrow_state(&self) -> BorrowState {\n@@ -498,6 +525,17 @@ impl<T: ?Sized> RefCell<T> {\n     /// This can be used to circumvent `RefCell`'s safety checks.\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_unsafe_cell)]\n+    ///\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    /// let c = unsafe { c.as_unsafe_cell() };\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"as_unsafe_cell\", issue = \"27708\")]\n     pub unsafe fn as_unsafe_cell(&self) -> &UnsafeCell<T> {\n@@ -508,6 +546,17 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// This call borrows `RefCell` mutably (at compile-time) so there is no\n     /// need for dynamic checks.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let mut c = RefCell::new(5);\n+    /// *c.get_mut() += 1;\n+    ///\n+    /// assert_eq!(c, RefCell::new(6));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {"}, {"sha": "0e7f04c775825224cb8defe7af3b02b7681cbb3a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -676,3 +676,50 @@ impl Iterator for EncodeUtf16 {\n         self.as_slice().iter().size_hint()\n     }\n }\n+\n+\n+/// An iterator over an iterator of bytes of the characters the bytes represent\n+/// as UTF-8\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(Clone, Debug)]\n+pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n+\n+/// Decodes an `Iterator` of bytes as UTF-8.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[inline]\n+pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n+    DecodeUtf8(i.into_iter().peekable())\n+}\n+\n+/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+#[derive(PartialEq, Debug)]\n+pub struct InvalidSequence(());\n+\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n+    type Item = Result<char, InvalidSequence>;\n+    #[inline]\n+    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n+        self.0.next().map(|b| {\n+            if b & 0x80 == 0 { Ok(b as char) } else {\n+                let l = (!b).leading_zeros() as usize; // number of bytes in UTF-8 representation\n+                if l < 2 || l > 6 { return Err(InvalidSequence(())) };\n+                let mut x = (b as u32) & (0x7F >> l);\n+                for _ in 0..l-1 {\n+                    match self.0.peek() {\n+                        Some(&b) if b & 0xC0 == 0x80 => {\n+                            self.0.next();\n+                            x = (x << 6) | (b as u32) & 0x3F;\n+                        },\n+                        _ => return Err(InvalidSequence(())),\n+                    }\n+                }\n+                match from_u32(x) {\n+                    Some(x) if l == x.len_utf8() => Ok(x),\n+                    _ => Err(InvalidSequence(())),\n+                }\n+            }\n+        })\n+    }\n+}"}, {"sha": "1bdcc5bfe119dcce59a62e6fa9d4fe396d57d761", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -175,7 +175,6 @@ extern \"rust-intrinsic\" {\n     /// that `rustc_peek(potentially_uninitialized)` would actually\n     /// double-check that dataflow did indeed compute that it is\n     /// uninitialized at that point in the control flow.\n-    #[cfg(not(stage0))]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process."}, {"sha": "d2de0d46d746ba452c7d3aab0f8d0383b3109f22", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1244,39 +1244,6 @@ impl<I: Iterator> Peekable<I> {\n             None => None,\n         }\n     }\n-\n-    /// Checks if the iterator has finished iterating.\n-    ///\n-    /// Returns `true` if there are no more elements in the iterator, and\n-    /// `false` if there are.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(peekable_is_empty)]\n-    ///\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // There are still elements to iterate over\n-    /// assert_eq!(iter.is_empty(), false);\n-    ///\n-    /// // Let's consume the iterator\n-    /// iter.next();\n-    /// iter.next();\n-    /// iter.next();\n-    ///\n-    /// assert_eq!(iter.is_empty(), true);\n-    /// ```\n-    #[unstable(feature = \"peekable_is_empty\", issue = \"32111\")]\n-    #[inline]\n-    #[rustc_deprecated(since = \"1.10.0\", reason = \"replaced by .peek().is_none()\")]\n-    pub fn is_empty(&mut self) -> bool {\n-        self.peek().is_none()\n-    }\n }\n \n /// An iterator that rejects elements while `predicate` is true."}, {"sha": "43868d124a22e00c69ac67e781e0d7b0c84ba114", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -238,6 +238,8 @@ macro_rules! write {\n }\n \n /// Use the `format!` syntax to write data into a buffer, appending a newline.\n+/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`)\n+/// alone (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n /// This macro is typically used with a buffer of `&mut `[`Write`][write].\n ///"}, {"sha": "fcdbde0d19f4f5a1808621423602e199918e1cd0", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -187,13 +187,25 @@ macro_rules! int_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// assert_eq!(i8::min_value(), -128);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn min_value() -> Self {\n             (-1 as Self) << ($BITS - 1)\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// assert_eq!(i8::max_value(), 127);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn max_value() -> Self {\n@@ -287,6 +299,8 @@ macro_rules! int_impl {\n         /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n+        /// Please note this isn't the same operation as `<<`!\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -307,6 +321,8 @@ macro_rules! int_impl {\n         /// wrapping the truncated bits to the beginning of the resulting\n         /// integer.\n         ///\n+        /// Please note this isn't the same operation as `>>`!\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -1249,11 +1265,23 @@ macro_rules! uint_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// assert_eq!(u8::min_value(), 0);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn min_value() -> Self { 0 }\n \n         /// Returns the largest value that can be represented by this integer type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// assert_eq!(u8::max_value(), 255);\n+        /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn max_value() -> Self { !0 }\n@@ -1360,6 +1388,8 @@ macro_rules! uint_impl {\n         /// Shifts the bits to the left by a specified amount, `n`,\n         /// wrapping the truncated bits to the end of the resulting integer.\n         ///\n+        /// Please note this isn't the same operation as `<<`!\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -1382,6 +1412,8 @@ macro_rules! uint_impl {\n         /// wrapping the truncated bits to the beginning of the resulting\n         /// integer.\n         ///\n+        /// Please note this isn't the same operation as `>>`!\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -2276,26 +2308,45 @@ impl usize {\n ///\n /// [`f32::classify()`]: ../../std/primitive.f32.html#method.classify\n /// [`f64::classify()`]: ../../std/primitive.f64.html#method.classify\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::num::FpCategory;\n+/// use std::f32;\n+///\n+/// let num = 12.4_f32;\n+/// let inf = f32::INFINITY;\n+/// let zero = 0f32;\n+/// let sub: f32 = 0.000000000000000000000000000000000000011754942;\n+/// let nan = f32::NAN;\n+///\n+/// assert_eq!(num.classify(), FpCategory::Normal);\n+/// assert_eq!(inf.classify(), FpCategory::Infinite);\n+/// assert_eq!(zero.classify(), FpCategory::Zero);\n+/// assert_eq!(nan.classify(), FpCategory::Nan);\n+/// assert_eq!(sub.classify(), FpCategory::Subnormal);\n+/// ```\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n-    /// \"Not a Number\", often obtained by dividing by zero\n+    /// \"Not a Number\", often obtained by dividing by zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Nan,\n \n-    /// Positive or negative infinity\n+    /// Positive or negative infinity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Infinite ,\n \n-    /// Positive or negative zero\n+    /// Positive or negative zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Zero,\n \n-    /// De-normalized floating point representation (less precise than `Normal`)\n+    /// De-normalized floating point representation (less precise than `Normal`).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Subnormal,\n \n-    /// A regular floating point number\n+    /// A regular floating point number.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal,\n }"}, {"sha": "9347ac2a8c82f0eb40d953f9318c39018ee72fa7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1929,7 +1929,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n-    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n     type Output;\n \n     /// This is called when the call operator is used."}, {"sha": "c8906fed3d2fa28bca17d60c8819c0f9c72c54ee", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -302,3 +302,32 @@ fn eu_iterator_specializations() {\n     check('\\u{12340}');\n     check('\\u{10FFFF}');\n }\n+\n+#[test]\n+fn test_decode_utf8() {\n+    use core::char::*;\n+    use core::iter::FromIterator;\n+\n+    for &(str, bs) in [(\"\", &[] as &[u8]),\n+                       (\"A\", &[0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0xC1u8, 0x81u8] as &[u8]),\n+                       (\"\u2665\", &[0xE2u8, 0x99u8, 0xA5u8]),\n+                       (\"\u2665A\", &[0xE2u8, 0x99u8, 0xA5u8, 0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0xE2u8, 0x99u8] as &[u8]),\n+                       (\"\ufffdA\", &[0xE2u8, 0x99u8, 0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0xC0u8] as &[u8]),\n+                       (\"\ufffdA\", &[0xC0u8, 0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0x80u8] as &[u8]),\n+                       (\"\ufffdA\", &[0x80u8, 0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0xFEu8] as &[u8]),\n+                       (\"\ufffdA\", &[0xFEu8, 0x41u8] as &[u8]),\n+                       (\"\ufffd\", &[0xFFu8] as &[u8]),\n+                       (\"\ufffdA\", &[0xFFu8, 0x41u8] as &[u8])].into_iter() {\n+        assert!(Iterator::eq(str.chars(),\n+                             decode_utf8(bs.into_iter().map(|&b|b))\n+                                 .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))),\n+                \"chars = {}, bytes = {:?}, decoded = {:?}\", str, bs,\n+                Vec::from_iter(decode_utf8(bs.into_iter().map(|&b|b))\n+                                   .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))));\n+    }\n+}"}, {"sha": "1ef2b58351fe5d7820d44c37ff1822bae7cccfbd", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -18,6 +18,7 @@\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(dec2flt)]\n+#![feature(decode_utf8)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(libc)]"}, {"sha": "e7d401f0929fe1910ec87bc256cbe1d3715d49e1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -80,8 +80,6 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The argument will be in the next position. This is the default.\n-    ArgumentNext,\n     /// The argument is located at a specific index.\n     ArgumentIs(usize),\n     /// The argument has a name.\n@@ -127,8 +125,6 @@ pub enum Count<'a> {\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n-    /// The count is specified by the next parameter.\n-    CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n     CountImplied,\n }\n@@ -144,6 +140,8 @@ pub struct Parser<'a> {\n     cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n+    /// Current position of implicit positional argument pointer\n+    curarg: usize,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -186,6 +184,7 @@ impl<'a> Parser<'a> {\n             input: s,\n             cur: s.char_indices().peekable(),\n             errors: vec![],\n+            curarg: 0,\n         }\n     }\n \n@@ -259,21 +258,40 @@ impl<'a> Parser<'a> {\n     /// Parses an Argument structure, or what's contained within braces inside\n     /// the format string\n     fn argument(&mut self) -> Argument<'a> {\n+        let pos = self.position();\n+        let format = self.format();\n+\n+        // Resolve position after parsing format spec.\n+        let pos = match pos {\n+            Some(position) => position,\n+            None => {\n+                let i = self.curarg;\n+                self.curarg += 1;\n+                ArgumentIs(i)\n+            }\n+        };\n+\n         Argument {\n-            position: self.position(),\n-            format: self.format(),\n+            position: pos,\n+            format: format,\n         }\n     }\n \n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n-    fn position(&mut self) -> Position<'a> {\n+    /// Returns `Some(parsed_position)` if the position is not implicitly\n+    /// consuming a macro argument, `None` if it's the case.\n+    fn position(&mut self) -> Option<Position<'a>> {\n         if let Some(i) = self.integer() {\n-            ArgumentIs(i)\n+            Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => ArgumentNamed(self.word()),\n-                _ => ArgumentNext,\n+                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+\n+                // This is an `ArgumentNext`.\n+                // Record the fact and do the resolution after parsing the\n+                // format spec, to make things like `{:.*}` work.\n+                _ => None,\n             }\n         }\n     }\n@@ -340,7 +358,11 @@ impl<'a> Parser<'a> {\n         }\n         if self.consume('.') {\n             if self.consume('*') {\n-                spec.precision = CountIsNextParam;\n+                // Resolve `CountIsNextParam`.\n+                // We can do this immediately as `position` is resolved later.\n+                let i = self.curarg;\n+                self.curarg += 1;\n+                spec.precision = CountIsParam(i);\n             } else {\n                 spec.precision = self.count();\n             }\n@@ -487,7 +509,7 @@ mod tests {\n     fn format_nothing() {\n         same(\"{}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: fmtdflt(),\n                })]);\n     }\n@@ -565,7 +587,7 @@ mod tests {\n     fn format_counts() {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -577,7 +599,7 @@ mod tests {\n                })]);\n         same(\"{:10$.10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -589,19 +611,19 @@ mod tests {\n                })]);\n         same(\"{:.*s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(1),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n                        flags: 0,\n-                       precision: CountIsNextParam,\n+                       precision: CountIsParam(0),\n                        width: CountImplied,\n                        ty: \"s\",\n                    },\n                })]);\n         same(\"{:.10$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -613,7 +635,7 @@ mod tests {\n                })]);\n         same(\"{:a$.b$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -628,7 +650,7 @@ mod tests {\n     fn format_flags() {\n         same(\"{:-}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -640,7 +662,7 @@ mod tests {\n                })]);\n         same(\"{:+#}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentNext,\n+                   position: ArgumentIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,"}, {"sha": "b0d62534d48b711c8978d1bbe8cca0558ae7b1cb", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1 +1 @@\n-Subproject commit 45d85899e99d33e291b2bf3259881b46cc5365d7\n+Subproject commit b0d62534d48b711c8978d1bbe8cca0558ae7b1cb"}, {"sha": "3c46072e17e1a7753aa3939c7676efb8e54ff2bd", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -57,6 +57,7 @@\n #![allow(private_no_mangle_fns)]\n \n use core::any::Any;\n+use core::ptr;\n use alloc::boxed::Box;\n \n use unwind as uw;\n@@ -88,7 +89,7 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n }\n \n pub fn payload() -> *mut u8 {\n-    0 as *mut u8\n+    ptr::null_mut()\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {"}, {"sha": "56801e8cb6bcf3d5583a7ca409a2aac4a8db965d", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -18,6 +18,7 @@ use alloc::boxed::Box;\n \n use core::any::Any;\n use core::intrinsics;\n+use core::ptr;\n use dwarf::eh;\n use windows as c;\n \n@@ -50,7 +51,7 @@ pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n }\n \n pub fn payload() -> *mut u8 {\n-    0 as *mut u8\n+    ptr::null_mut()\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {"}, {"sha": "601d3866b02d452be8808bcb3db6c936fa03d771", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -101,7 +101,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match pat.node {\n             PatKind::Binding(_, _, None) |\n             PatKind::Path(..) |\n-            PatKind::QPath(..) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild => {"}, {"sha": "218681efb7dc167d033b1da220acc94b901bd215", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -137,15 +137,6 @@ impl Def {\n         }\n     }\n \n-    pub fn variant_def_ids(&self) -> Option<(DefId, DefId)> {\n-        match *self {\n-            Def::Variant(enum_id, var_id) => {\n-                Some((enum_id, var_id))\n-            }\n-            _ => None\n-        }\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n             Def::Fn(..) => \"function\","}, {"sha": "5e0e6622185f8b50336cc4409b033a5be0f4793b", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -930,12 +930,11 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                     PatKind::TupleStruct(folder.fold_path(pth),\n                             pats.move_map(|x| folder.fold_pat(x)), ddpos)\n                 }\n-                PatKind::Path(pth) => {\n-                    PatKind::Path(folder.fold_path(pth))\n-                }\n-                PatKind::QPath(qself, pth) => {\n-                    let qself = QSelf { ty: folder.fold_ty(qself.ty), ..qself };\n-                    PatKind::QPath(qself, folder.fold_path(pth))\n+                PatKind::Path(opt_qself, pth) => {\n+                    let opt_qself = opt_qself.map(|qself| {\n+                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n+                    });\n+                    PatKind::Path(opt_qself, folder.fold_path(pth))\n                 }\n                 PatKind::Struct(pth, fields, etc) => {\n                     let pth = folder.fold_path(pth);"}, {"sha": "442c85af22a262967f707484de232e8b06c443ef", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -460,11 +460,10 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_path(path, pattern.id);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref path) => {\n-            visitor.visit_path(path, pattern.id);\n-        }\n-        PatKind::QPath(ref qself, ref path) => {\n-            visitor.visit_ty(&qself.ty);\n+        PatKind::Path(ref opt_qself, ref path) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n             visitor.visit_path(path, pattern.id)\n         }\n         PatKind::Struct(ref path, ref fields, _) => {"}, {"sha": "9d124dadb766adb911324f8a5cdc78f1eed57e38", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -862,7 +862,8 @@ impl<'a> LoweringContext<'a> {\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => hir::PatKind::Path(hir::Path::from_name(pth1.span, pth1.node.name))\n+                            _ => hir::PatKind::Path(None, hir::Path::from_name(pth1.span,\n+                                                                               pth1.node.name))\n                         }\n                     })\n                 }\n@@ -872,15 +873,11 @@ impl<'a> LoweringContext<'a> {\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n-                PatKind::Path(None, ref pth) => {\n-                    hir::PatKind::Path(self.lower_path(pth))\n-                }\n-                PatKind::Path(Some(ref qself), ref pth) => {\n-                    let qself = hir::QSelf {\n-                        ty: self.lower_ty(&qself.ty),\n-                        position: qself.position,\n-                    };\n-                    hir::PatKind::QPath(qself, self.lower_path(pth))\n+                PatKind::Path(ref opt_qself, ref path) => {\n+                    let opt_qself = opt_qself.as_ref().map(|qself| {\n+                        hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n+                    });\n+                    hir::PatKind::Path(opt_qself, self.lower_path(path))\n                 }\n                 PatKind::Struct(ref pth, ref fields, etc) => {\n                     let pth = self.lower_path(pth);\n@@ -1831,7 +1828,7 @@ impl<'a> LoweringContext<'a> {\n                 -> P<hir::Pat> {\n         let def = self.resolver.resolve_generated_global_path(&path, true);\n         let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(path)\n+            hir::PatKind::Path(None, path)\n         } else {\n             hir::PatKind::TupleStruct(path, subpats, None)\n         };"}, {"sha": "655f80ec07238ff9ba97fdb99057415fd6dec35b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -487,8 +487,7 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n             PatKind::Binding(..) |\n-            PatKind::Path(..) |\n-            PatKind::QPath(_, _) => {\n+            PatKind::Path(..) => {\n                 true\n             }\n         }\n@@ -538,15 +537,9 @@ pub enum PatKind {\n     /// 0 <= position <= subpats.len()\n     TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n \n-    /// A path pattern.\n+    /// A possibly qualified path pattern.\n     /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Path),\n-\n-    /// An associated const named using the qualified path `<T>::CONST` or\n-    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatKind::Path, and the resolver will have to sort that out.\n-    QPath(QSelf, Path),\n+    Path(Option<QSelf>, Path),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position."}, {"sha": "593d10ef4f7c4a9910c020b9a4218dc5f345fbba", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,15 +12,12 @@ use hir::def::*;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n use ty::TyCtxt;\n-use util::nodemap::FnvHashMap;\n use syntax::ast;\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n-pub type PatIdMap = FnvHashMap<ast::Name, ast::NodeId>;\n-\n pub struct EnumerateAndAdjust<I> {\n     enumerate: Enumerate<I>,\n     gap_pos: usize,\n@@ -56,7 +53,7 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n+        PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::Path(Some(..), _) => true,\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n@@ -70,23 +67,9 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -96,22 +79,6 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-// Same as above, except that partially-resolved defs cause `false` to be\n-// returned instead of a panic.\n-pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(..) | PatKind::QPath(..) => {\n-            match dm.get(&pat.id)\n-                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n-                                  else { None } ) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n-            }\n-        }\n-        _ => false\n-    }\n-}\n-\n /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)"}, {"sha": "5f2fac5c01b30df8b719ef301e13cafde1a1cbbd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1750,10 +1750,10 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            PatKind::Path(ref path) => {\n+            PatKind::Path(None, ref path) => {\n                 self.print_path(path, true, 0)?;\n             }\n-            PatKind::QPath(ref qself, ref path) => {\n+            PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?;\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {"}, {"sha": "3230a08c27630bbbd4095a1792d24630265350a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -94,12 +94,6 @@ declare_lint! {\n     \"unknown crate type found in #[crate_type] directive\"\n }\n \n-declare_lint! {\n-    pub VARIANT_SIZE_DIFFERENCES,\n-    Allow,\n-    \"detects enums with widely varying variant sizes\"\n-}\n-\n declare_lint! {\n     pub FAT_PTR_TRANSMUTES,\n     Allow,\n@@ -230,7 +224,6 @@ impl LintPass for HardwiredLints {\n             UNUSED_FEATURES,\n             STABLE_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n-            VARIANT_SIZE_DIFFERENCES,\n             FAT_PTR_TRANSMUTES,\n             TRIVIAL_CASTS,\n             TRIVIAL_NUMERIC_CASTS,"}, {"sha": "ce3d72de9ae99a5378cfbbf598833ae4e7cda408", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -29,13 +29,12 @@ use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n use ty::TyCtxt;\n use session::{config, early_error, Session};\n-use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass};\n-use lint::{EarlyLintPassObject, LateLintPass, LateLintPassObject};\n+use lint::{Level, LevelSource, Lint, LintId, LintPass};\n+use lint::{EarlyLintPassObject, LateLintPassObject};\n use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n use lint::builtin;\n use util::nodemap::FnvHashMap;\n \n-use std::cell::RefCell;\n use std::cmp;\n use std::default::Default as StdDefault;\n use std::mem;\n@@ -311,10 +310,6 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// levels, this stack keeps track of the previous lint levels of whatever\n     /// was modified.\n     level_stack: Vec<(LintId, LevelSource)>,\n-\n-    /// Level of lints for certain NodeIds, stored here because the body of\n-    /// the lint needs to run in trans.\n-    node_levels: RefCell<FnvHashMap<(ast::NodeId, LintId), LevelSource>>,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -664,7 +659,6 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             access_levels: access_levels,\n             lints: lint_store,\n             level_stack: vec![],\n-            node_levels: RefCell::new(FnvHashMap()),\n         }\n     }\n \n@@ -1064,38 +1058,6 @@ impl<'a, 'tcx> IdVisitingOperation for LateContext<'a, 'tcx> {\n     }\n }\n \n-// This lint pass is defined here because it touches parts of the `LateContext`\n-// that we don't want to expose. It records the lint level at certain AST\n-// nodes, so that the variant size difference check in trans can call\n-// `raw_emit_lint`.\n-\n-pub struct GatherNodeLevels;\n-\n-impl LintPass for GatherNodeLevels {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!()\n-    }\n-}\n-\n-impl LateLintPass for GatherNodeLevels {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            hir::ItemEnum(..) => {\n-                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCES);\n-                let lvlsrc = cx.lints.get_level_source(lint_id);\n-                match lvlsrc {\n-                    (lvl, _) if lvl != Allow => {\n-                        cx.node_levels.borrow_mut()\n-                            .insert((it.id, lint_id), lvlsrc);\n-                    },\n-                    _ => { }\n-                }\n-            },\n-            _ => { }\n-        }\n-    }\n-}\n-\n enum CheckLintNameResult {\n     Ok,\n     // Lint doesn't exist\n@@ -1234,8 +1196,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    *tcx.node_lint_levels.borrow_mut() = cx.node_levels.into_inner();\n-\n     // Put the lint store back in the session.\n     mem::replace(&mut *tcx.sess.lint_store.borrow_mut(), cx.lints);\n }"}, {"sha": "121033549c0d5b0554c208a6551dca5d6e2bf766", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -41,7 +41,7 @@ use hir;\n \n pub use lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n                         raw_emit_lint, check_crate, check_ast_crate, gather_attrs,\n-                        raw_struct_lint, GatherNodeLevels, FutureIncompatibleInfo};\n+                        raw_struct_lint, FutureIncompatibleInfo};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "6551e0129f88493dacffff9044ca34b10ea112db", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 99, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -945,52 +945,41 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// The core driver for walking a pattern; `match_mode` must be\n     /// established up front, e.g. via `determine_pat_move_mode` (see\n     /// also `walk_irrefutable_pat` for patterns that stand alone).\n-    fn walk_pat(&mut self,\n-                cmt_discr: mc::cmt<'tcx>,\n-                pat: &hir::Pat,\n-                match_mode: MatchMode) {\n-        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr,\n-               pat);\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat, match_mode: MatchMode) {\n+        debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         let tcx = &self.tcx();\n         let mc = &self.mc;\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Binding(bmode, _, _) => {\n-                    debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\",\n-                           cmt_pat,\n-                           pat,\n-                           match_mode);\n-\n-                    // pat_ty: the type of the binding being produced.\n-                    let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n-\n-                    // Each match binding is effectively an assignment to the\n-                    // binding being produced.\n-                    if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                        tcx.expect_def(pat.id)) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n-                    }\n+            if let PatKind::Binding(bmode, _, _) = pat.node {\n+                debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n-                    // It is also a borrow or copy/move of the value being matched.\n-                    match bmode {\n-                        hir::BindByRef(m) => {\n-                            if let ty::TyRef(&r, _) = pat_ty.sty {\n-                                let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, cmt_pat,\n-                                                r, bk, RefBinding);\n-                            }\n-                        }\n-                        hir::BindByValue(..) => {\n-                            let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n-                            debug!(\"walk_pat binding consuming pat\");\n-                            delegate.consume_pat(pat, cmt_pat, mode);\n+                // pat_ty: the type of the binding being produced.\n+                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+\n+                // Each match binding is effectively an assignment to the\n+                // binding being produced.\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n+                                                    tcx.expect_def(pat.id)) {\n+                    delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                }\n+\n+                // It is also a borrow or copy/move of the value being matched.\n+                match bmode {\n+                    hir::BindByRef(m) => {\n+                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                            let bk = ty::BorrowKind::from_mutbl(m);\n+                            delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n+                    hir::BindByValue(..) => {\n+                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n+                        debug!(\"walk_pat binding consuming pat\");\n+                        delegate.consume_pat(pat, cmt_pat, mode);\n+                    }\n                 }\n-                _ => {}\n             }\n         }));\n \n@@ -999,72 +988,23 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Struct(..) | PatKind::TupleStruct(..) |\n-                PatKind::Path(..) | PatKind::QPath(..) => {\n-                    match tcx.expect_def(pat.id) {\n-                        Def::Variant(enum_did, variant_did) => {\n-                            let downcast_cmt =\n-                                if tcx.lookup_adt_def(enum_did).is_univariant() {\n-                                    cmt_pat\n-                                } else {\n-                                    let cmt_pat_ty = cmt_pat.ty;\n-                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n-                                };\n-\n-                            debug!(\"variant downcast_cmt={:?} pat={:?}\",\n-                                   downcast_cmt,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, downcast_cmt, match_mode);\n-                        }\n-\n-                        Def::Struct(..) | Def::TyAlias(..) => {\n-                            // A struct (in either the value or type\n-                            // namespace; we encounter the former on\n-                            // e.g. patterns for unit structs).\n-\n-                            debug!(\"struct cmt_pat={:?} pat={:?}\",\n-                                   cmt_pat,\n-                                   pat);\n-\n-                            delegate.matched_pat(pat, cmt_pat, match_mode);\n-                        }\n-\n-                        Def::Const(..) | Def::AssociatedConst(..) => {\n-                            // This is a leaf (i.e. identifier binding\n-                            // or constant value to match); thus no\n-                            // `matched_pat` call.\n-                        }\n+            match tcx.expect_def_or_none(pat.id) {\n+                Some(Def::Variant(enum_did, variant_did)) => {\n+                    let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n+                        cmt_pat\n+                    } else {\n+                        let cmt_pat_ty = cmt_pat.ty;\n+                        mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n+                    };\n \n-                        def => {\n-                            // An enum type should never be in a pattern.\n-                            // Remaining cases are e.g. Def::Fn, to\n-                            // which identifiers within patterns\n-                            // should not resolve. However, we do\n-                            // encouter this when using the\n-                            // expr-use-visitor during typeck. So just\n-                            // ignore it, an error should have been\n-                            // reported.\n-\n-                            if !tcx.sess.has_errors() {\n-                                span_bug!(pat.span,\n-                                          \"Pattern has unexpected def: {:?} and type {:?}\",\n-                                          def,\n-                                          cmt_pat.ty);\n-                            }\n-                        }\n-                    }\n+                    debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n+                    delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-\n-                PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n-                PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n-                PatKind::Vec(..) | PatKind::Binding(..) => {\n-                    // Each of these cases does not\n-                    // correspond to an enum variant or struct, so we\n-                    // do not do any `matched_pat` calls for these\n-                    // cases either.\n+                Some(Def::Struct(..)) | Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                    debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n+                    delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "28bfb460a14faf75c9fdbbe10fb5a195cfc3e600", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 81, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1050,9 +1050,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n-    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n-                       -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n+        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1099,21 +1098,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        debug!(\"cat_pattern: {:?} cmt={:?}\",\n-               pat,\n-               cmt);\n-\n-        (*op)(self, cmt.clone(), pat);\n+        debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n-        let opt_def = self.tcx().expect_def_or_none(pat.id);\n-        if opt_def == Some(Def::Err) {\n-            return Err(());\n-        }\n+        op(self, cmt.clone(), pat);\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n-        // alone) because struct patterns can refer to struct types or\n-        // to struct variants within enums.\n-        let cmt = match opt_def {\n+        // alone) because PatKind::Struct can also refer to variants.\n+        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n+            Some(Def::Err) => return Err(()),\n             Some(Def::Variant(enum_did, variant_did))\n                 // univariant enums do not need downcasts\n                 if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n@@ -1123,66 +1115,33 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         match pat.node {\n-          PatKind::Wild => {\n-            // _\n-          }\n-\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            match opt_def {\n-                Some(Def::Variant(enum_def, def_id)) => {\n-                    // variant(x, y, z)\n-                    let expected_len = self.tcx().lookup_adt_def(enum_def)\n-                                                 .variant_with_id(def_id).fields.len();\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-\n-                        let subcmt =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-\n-                        self.cat_pattern_(subcmt, &subpat, op)?;\n-                    }\n+            let expected_len = match self.tcx().expect_def(pat.id) {\n+                Def::Variant(enum_def, def_id) => {\n+                    self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n-                Some(Def::Struct(..)) => {\n-                    let expected_len = match self.pat_ty(&pat)?.sty {\n+                Def::Struct(..) => {\n+                    match self.pat_ty(&pat)?.sty {\n                         ty::TyStruct(adt_def, _) => {\n                             adt_def.struct_variant().fields.len()\n                         }\n                         ref ty => {\n                             span_bug!(pat.span, \"tuple struct pattern unexpected type {:?}\", ty);\n                         }\n-                    };\n-\n-                    for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n-                        let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                        let cmt_field =\n-                            self.cat_imm_interior(\n-                                pat, cmt.clone(), subpat_ty,\n-                                InteriorField(PositionalField(i)));\n-                        self.cat_pattern_(cmt_field, &subpat, op)?;\n                     }\n                 }\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n-                    for subpat in subpats {\n-                        self.cat_pattern_(cmt.clone(), &subpat, op)?;\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(\n-                        pat.span,\n-                        \"enum pattern didn't resolve to enum or struct {:?}\",\n-                        opt_def);\n+                def => {\n+                    span_bug!(pat.span, \"tuple struct pattern didn't resolve \\\n+                                         to variant or struct {:?}\", def);\n                 }\n-            }\n-          }\n-\n-          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) => {\n-              // Lone constant, or unit variant or identifier: ignore\n-          }\n+            };\n \n-          PatKind::Binding(_, _, Some(ref subpat)) => {\n-              self.cat_pattern_(cmt, &subpat, op)?;\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n+                let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n+                self.cat_pattern_(subcmt, &subpat, op)?;\n+            }\n           }\n \n           PatKind::Struct(_, ref field_pats, _) => {\n@@ -1194,6 +1153,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n+          PatKind::Binding(_, _, Some(ref subpat)) => {\n+              self.cat_pattern_(cmt, &subpat, op)?;\n+          }\n+\n           PatKind::Tuple(ref subpats, ddpos) => {\n             // (p1, ..., pN)\n             let expected_len = match self.pat_ty(&pat)?.sty {\n@@ -1202,10 +1165,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt =\n-                    self.cat_imm_interior(\n-                        pat, cmt.clone(), subpat_ty,\n-                        InteriorField(PositionalField(i)));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n+                                                   InteriorField(PositionalField(i)));\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1215,25 +1176,26 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // PatKind::Ref since that information is already contained\n             // in the type.\n             let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n-              self.cat_pattern_(subcmt, &subpat, op)?;\n+            self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n \n           PatKind::Vec(ref before, ref slice, ref after) => {\n-              let context = InteriorOffsetKind::Pattern;\n-              let elt_cmt = self.cat_index(pat, cmt, context)?;\n-              for before_pat in before {\n-                  self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n-              }\n-              if let Some(ref slice_pat) = *slice {\n-                  self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n-              }\n-              for after_pat in after {\n-                  self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n-              }\n+            let context = InteriorOffsetKind::Pattern;\n+            let elt_cmt = self.cat_index(pat, cmt, context)?;\n+            for before_pat in before {\n+                self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n+            }\n+            if let Some(ref slice_pat) = *slice {\n+                self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n+            }\n+            for after_pat in after {\n+                self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;\n+            }\n           }\n \n-          PatKind::Lit(_) | PatKind::Range(_, _) => {\n-              /*always ok*/\n+          PatKind::Path(..) | PatKind::Binding(_, _, None) |\n+          PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n+            // always ok\n           }\n         }\n "}, {"sha": "93507246241de62bde905a68e9fde7acc47e7c47", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1063,7 +1063,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             Some(tcx.lookup_item_type(variant_def.did).generics)\n                         })?;\n \n-                        match variant_def.kind() {\n+                        match variant_def.kind {\n                             ty::VariantKind::Unit => Ok(()),\n                             ty::VariantKind::Tuple => fmt_tuple(fmt, lvs),\n                             ty::VariantKind::Struct => {"}, {"sha": "d5a9c38022231268309dd875a9a603cc4eea1c80", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -731,8 +731,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"load extra plugins\"),\n     unstable_options: bool = (false, parse_bool,\n           \"adds unstable command line options to rustc interface\"),\n-    print_enum_sizes: bool = (false, parse_bool,\n-          \"print the size of enums and their variants\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool,\n           \"force overflow checks on or off\"),\n     force_dropflag_checks: Option<bool> = (None, parse_opt_bool,\n@@ -987,7 +985,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              assumed.\", \"[KIND=]NAME\"),\n         opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                   \"[bin|lib|rlib|dylib|staticlib]\"),\n+                   \"[bin|lib|rlib|dylib|cdylib|staticlib]\"),\n         opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n         opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\"}, {"sha": "0e516bdc21194b3c9d5ce473d0e8a9228f871aab", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -304,9 +304,6 @@ impl Session {\n     pub fn unstable_options(&self) -> bool {\n         self.opts.debugging_opts.unstable_options\n     }\n-    pub fn print_enum_sizes(&self) -> bool {\n-        self.opts.debugging_opts.print_enum_sizes\n-    }\n     pub fn nonzeroing_move_hints(&self) -> bool {\n         self.opts.debugging_opts.enable_nonzeroing_move_hints\n     }"}, {"sha": "56938a7a838588d0e0c5d757b1eab9e877e4b763", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,7 +12,6 @@\n \n use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n-use lint;\n use middle;\n use middle::cstore::LOCAL_CRATE;\n use hir::def::DefMap;\n@@ -415,9 +414,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Cache used by const_eval when decoding extern const fns\n     pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n-    pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n-                                              lint::LevelSource>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -591,17 +587,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n+    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n+        // this will need a transmute when reverse-variance is removed\n+        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n+            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n+        }\n+    }\n+\n     pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n                           variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n                           -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n         let interned = self.global_interners.arenas.adt_defs.alloc(def);\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n+        self.insert_adt_def(did, interned);\n         interned\n     }\n \n@@ -722,7 +722,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             populated_external_primitive_impls: RefCell::new(DefIdSet()),\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n-            node_lint_levels: RefCell::new(FnvHashMap()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),"}, {"sha": "27ed88e929e76dba833a9702e52d896b03072391", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -17,8 +17,6 @@ use session::Session;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use util::common::slice_pat;\n-\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n@@ -100,7 +98,7 @@ impl TargetDataLayout {\n \n         let mut dl = TargetDataLayout::default();\n         for spec in sess.target.target.data_layout.split(\"-\") {\n-            match slice_pat(&&spec.split(\":\").collect::<Vec<_>>()[..]) {\n+            match &spec.split(\":\").collect::<Vec<_>>()[..] {\n                 &[\"e\"] => dl.endian = Endian::Little,\n                 &[\"E\"] => dl.endian = Endian::Big,\n                 &[\"a\", ref a..] => dl.aggregate_align = align(a, \"a\"),"}, {"sha": "03e893727d1b58c7d88142ee72bb336dfe509cfd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1715,7 +1715,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n+            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -1925,14 +1925,6 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n         self.fields.iter()\n     }\n \n-    pub fn kind(&self) -> VariantKind {\n-        self.kind\n-    }\n-\n-    pub fn is_tuple_struct(&self) -> bool {\n-        self.kind() == VariantKind::Tuple\n-    }\n-\n     #[inline]\n     pub fn find_field_named(&self,\n                             name: ast::Name)\n@@ -2454,6 +2446,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n     }\n \n+    // Returns `ty::VariantDef` if `def` refers to a struct,\n+    // or variant or their constructors, panics otherwise.\n+    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+        match def {\n+            Def::Variant(enum_did, did) => {\n+                self.lookup_adt_def(enum_did).variant_with_id(did)\n+            }\n+            Def::Struct(did) => {\n+                self.lookup_adt_def(did).struct_variant()\n+            }\n+            _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)\n+        }\n+    }\n+\n     pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n             self.map.def_key(id)"}, {"sha": "bdfb97549d5d512647ce80179eb8d38579cd1378", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -247,15 +247,3 @@ pub fn path2cstr(p: &Path) -> CString {\n pub fn path2cstr(p: &Path) -> CString {\n     CString::new(p.to_str().unwrap()).unwrap()\n }\n-\n-// FIXME(stage0): remove this\n-// HACK: this is needed because the interpretation of slice\n-// patterns changed between stage0 and now.\n-#[cfg(stage0)]\n-pub fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'a &'b [T] {\n-    t\n-}\n-#[cfg(not(stage0))]\n-pub fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'b [T] {\n-    *t\n-}"}, {"sha": "0de00d9d7f631edc634f6b757ac106361f1a5062", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -43,7 +43,6 @@ use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n use rustc::util::nodemap::FnvHashMap;\n-use rustc::util::common::slice_pat;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -246,9 +245,9 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n             let pat_ty = cx.tcx.pat_ty(p);\n             if let ty::TyEnum(edef, _) = pat_ty.sty {\n                 if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                    if edef.variants.iter().any(|variant|\n-                        variant.name == name.node && variant.kind() == VariantKind::Unit\n-                    ) {\n+                    if edef.variants.iter().any(|variant| {\n+                        variant.name == name.node && variant.kind == VariantKind::Unit\n+                    }) {\n                         let ty_path = cx.tcx.item_path_str(edef.did);\n                         let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                             \"pattern binding `{}` is named the same as one \\\n@@ -400,7 +399,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                 hir::MatchSource::ForLoopDesugar => {\n                     // `witnesses[0]` has the form `Some(<head>)`, peel off the `Some`\n                     let witness = match witnesses[0].node {\n-                        PatKind::TupleStruct(_, ref pats, _) => match slice_pat(&&pats[..]) {\n+                        PatKind::TupleStruct(_, ref pats, _) => match &pats[..] {\n                             &[ref pat] => &**pat,\n                             _ => bug!(),\n                         },\n@@ -489,7 +488,7 @@ impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            PatKind::Path(..) | PatKind::QPath(..) => {\n+            PatKind::Path(..) => {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n@@ -563,7 +562,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = ctor.variant_for_adt(adt);\n-            match v.kind() {\n+            match v.kind {\n                 VariantKind::Struct => {\n                     let field_pats: hir::HirVec<_> = v.fields.iter()\n                         .zip(pats)\n@@ -583,7 +582,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                     PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n                 }\n                 VariantKind::Unit => {\n-                    PatKind::Path(def_to_path(cx.tcx, v.did))\n+                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n                 }\n             }\n         }\n@@ -786,16 +785,12 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat.span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                            definition {:?}\", def),\n+                Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(pat.span, \"const pattern should've been rewritten\"),\n+                def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n             },\n-        PatKind::QPath(..) =>\n-            span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n             vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n         PatKind::Range(ref lo, ref hi) =>\n@@ -934,10 +929,6 @@ pub fn specialize<'a, 'b, 'tcx>(\n             }\n         }\n \n-        PatKind::QPath(_, _) => {\n-            span_bug!(pat_span, \"const pattern should've been rewritten\")\n-        }\n-\n         PatKind::Struct(_, ref pattern_fields, _) => {\n             let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n             let variant = constructor.variant_for_adt(adt);"}, {"sha": "a3c707e82a0ff45e45be5c74e951c184296f8cb5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -323,7 +323,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         hir::ExprPath(_, ref path) => {\n             match tcx.expect_def(expr.id) {\n-                Def::Struct(..) | Def::Variant(..) => PatKind::Path(path.clone()),\n+                Def::Struct(..) | Def::Variant(..) => PatKind::Path(None, path.clone()),\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.node_id_item_substs(expr.id).substs);\n                     let (expr, _ty) = lookup_const_by_id(tcx, def_id, substs).unwrap();"}, {"sha": "3b1124a911e5d2ad9bb9b8a3acf91f9d531bc34e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 59, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -50,7 +50,6 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::fold::Folder;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n@@ -211,7 +210,7 @@ pub fn compile_input(sess: &Session,\n             }\n \n             // Discard interned strings as they are no longer required.\n-            token::get_ident_interner().clear();\n+            token::clear_ident_interner();\n \n             Ok((outputs, trans))\n         })??\n@@ -480,7 +479,7 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n     // These may be left in an incoherent state after a previous compile.\n-    // `clear_tables` and `get_ident_interner().clear()` can be used to free\n+    // `clear_tables` and `clear_ident_interner` can be used to free\n     // memory, but they do not restore the initial state.\n     syntax::ext::mtwt::reset_tables();\n     token::reset_ident_interner();\n@@ -695,6 +694,19 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n                                          sess.diagnostic())\n     });\n \n+    let resolver_arenas = Resolver::arenas();\n+    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n+\n+    let krate = time(sess.time_passes(), \"assigning node ids\", || resolver.assign_node_ids(krate));\n+\n+    if sess.opts.debugging_opts.input_stats {\n+        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n+    }\n+\n+    if sess.opts.debugging_opts.ast_json {\n+        println!(\"{}\", json::as_json(&krate));\n+    }\n+\n     time(time_passes,\n          \"checking for inline asm in case the target doesn't support it\",\n          || no_asm::check_crate(sess, &krate));\n@@ -710,15 +722,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         })\n     })?;\n \n-    if sess.opts.debugging_opts.input_stats {\n-        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n-    }\n-\n-    krate = assign_node_ids(sess, krate);\n-\n-    let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n-\n     // Collect defintions for def ids.\n     time(sess.time_passes(), \"collecting defs\", || resolver.definitions.collect(&krate));\n \n@@ -783,53 +786,6 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     })\n }\n \n-pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n-    use syntax::ptr::P;\n-    use syntax::util::move_map::MoveMap;\n-\n-    struct NodeIdAssigner<'a> {\n-        sess: &'a Session,\n-    }\n-\n-    impl<'a> Folder for NodeIdAssigner<'a> {\n-        fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n-            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-            self.sess.next_node_id()\n-        }\n-\n-        fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-            block.map(|mut block| {\n-                block.id = self.new_id(block.id);\n-\n-                let stmt = block.stmts.pop();\n-                block.stmts = block.stmts.move_flat_map(|s| self.fold_stmt(s).into_iter());\n-                if let Some(ast::Stmt { node: ast::StmtKind::Expr(expr), span, .. }) = stmt {\n-                    let expr = self.fold_expr(expr);\n-                    block.stmts.push(ast::Stmt {\n-                        id: expr.id,\n-                        node: ast::StmtKind::Expr(expr),\n-                        span: span,\n-                    });\n-                } else if let Some(stmt) = stmt {\n-                    block.stmts.extend(self.fold_stmt(stmt));\n-                }\n-\n-                block\n-            })\n-        }\n-    }\n-\n-    let krate = time(sess.time_passes(),\n-                     \"assigning node ids\",\n-                     || NodeIdAssigner { sess: sess }.fold_crate(krate));\n-\n-    if sess.opts.debugging_opts.ast_json {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n-    krate\n-}\n-\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis."}, {"sha": "9f3573bd0d9fba288c285d64e5de5960d5e2a800", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -98,7 +98,7 @@ use rustc::session::early_error;\n use syntax::{ast, json};\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n-use syntax::parse::{self, PResult, token};\n+use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n \n@@ -202,7 +202,7 @@ pub fn run_compiler_with_file_loader<'a, L>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let codemap = Rc::new(CodeMap::with_file_loader(loader));\n     let sess = session::build_session_with_codemap(sopts,\n                                                    &dep_graph,\n@@ -433,7 +433,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+                let cstore = Rc::new(CStore::new(&dep_graph));\n                 let sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,"}, {"sha": "911becd3f569b99fadbb0982e5ae155743a67e1f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -106,7 +106,7 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(options, &dep_graph, None, diagnostic_handler,\n                                        Rc::new(CodeMap::new()), cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}, {"sha": "15914838acf0db85289b97ececd3fa5c90696a4b", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -360,7 +360,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        if let PatKind::Path(ref path) = p.node {\n+        if let PatKind::Path(None, ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n                     NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\","}, {"sha": "7b0ee91b69ed0848b82a16252df2905469e3976c", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -108,6 +108,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  HardwiredLints,\n                  WhileTrue,\n                  ImproperCTypes,\n+                 VariantSizeDifferences,\n                  BoxPointers,\n                  UnusedAttributes,\n                  PathStatements,\n@@ -209,9 +210,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         },\n         ]);\n \n-    // We have one lint pass defined specially\n-    store.register_late_pass(sess, false, box lint::GatherNodeLevels);\n-\n     // Register renamed and removed lints\n     store.register_renamed(\"unknown_features\", \"unused_features\");\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");"}, {"sha": "9b08ddcafab8e7d9e773a2d81e85dd15f2549a21", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -13,10 +13,11 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{Layout, Primitive};\n+use rustc::traits::ProjectionMode;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::common::slice_pat;\n use util::nodemap::{FnvHashSet};\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -77,6 +78,12 @@ declare_lint! {\n     \"shift exceeds the type's number of bits\"\n }\n \n+declare_lint! {\n+    VARIANT_SIZE_DIFFERENCES,\n+    Allow,\n+    \"detects enums with widely varying variant sizes\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n@@ -461,7 +468,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 // Check for a repr() attribute to specify the size of the\n                 // discriminant.\n                 let repr_hints = cx.lookup_repr_hints(def.did);\n-                match slice_pat(&&**repr_hints) {\n+                match &repr_hints[..] {\n                     &[] => {\n                         // Special-case types like `Option<extern fn()>`.\n                         if !is_repr_nullable_ptr(cx, def, substs) {\n@@ -676,3 +683,64 @@ impl LateLintPass for ImproperCTypes {\n         }\n     }\n }\n+\n+pub struct VariantSizeDifferences;\n+\n+impl LintPass for VariantSizeDifferences {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(VARIANT_SIZE_DIFFERENCES)\n+    }\n+}\n+\n+impl LateLintPass for VariantSizeDifferences {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n+            if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n+                let t = cx.tcx.node_id_to_type(it.id);\n+                let layout = cx.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                    t.layout(&infcx).unwrap_or_else(|e| {\n+                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n+                    })\n+                });\n+\n+                if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n+                    let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n+\n+                    debug!(\"enum `{}` is {} bytes large\", t, size.bytes());\n+\n+                    let (largest, slargest, largest_index) = enum_definition.variants\n+                        .iter()\n+                        .zip(variants)\n+                        .map(|(variant, variant_layout)| {\n+                            // Subtract the size of the enum discriminant\n+                            let bytes = variant_layout.min_size().bytes()\n+                                                                 .saturating_sub(discr_size);\n+\n+                            debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n+                            bytes\n+                        })\n+                        .enumerate()\n+                        .fold((0, 0, 0),\n+                            |(l, s, li), (idx, size)|\n+                                if size > l {\n+                                    (size, l, idx)\n+                                } else if size > s {\n+                                    (l, size, li)\n+                                } else {\n+                                    (l, s, li)\n+                                }\n+                        );\n+\n+                    // we only warn if the largest variant is at least thrice as large as\n+                    // the second-largest.\n+                    if largest > slargest * 3 && slargest > 0 {\n+                        cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n+                                     enum_definition.variants[largest_index].span,\n+                                     &format!(\"enum variant is more than three times larger \\\n+                                               ({} bytes) than the next largest\", largest));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d4443c6d09d7cb6b6282a7b411eb476427a1715a", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -557,7 +557,6 @@ impl<'a> CrateReader<'a> {\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     &self.cstore.intr,\n             |name, attrs, span, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0."}, {"sha": "850d6c91f66ef05b2c7637d5367a221abe8fb9d1", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n+        decoder::get_adt_def(&cdata, def.index, tcx)\n     }\n \n     fn method_arg_names(&self, did: DefId) -> Vec<String>\n@@ -140,13 +140,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn item_name(&self, def: DefId) -> ast::Name {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_name(&self.intr, &cdata, def.index)\n+        decoder::get_item_name(&cdata, def.index)\n     }\n \n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_name(&self.intr, &cdata, def.index)\n+        decoder::maybe_get_item_name(&cdata, def.index)\n     }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n@@ -176,7 +176,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n+        decoder::get_provided_trait_methods(&cdata, def.index, tcx)\n     }\n \n     fn trait_item_def_ids(&self, def: DefId)\n@@ -222,7 +222,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n+        decoder::get_associated_consts(&cdata, def.index, tcx)\n     }\n \n     fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n@@ -243,11 +243,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_or_trait_item(\n-            self.intr.clone(),\n-            &cdata,\n-            def.index,\n-            tcx)\n+        decoder::get_impl_or_trait_item(&cdata, def.index, tcx)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n@@ -460,7 +456,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_struct_field_names(&self.intr, &cdata, def.index)\n+        decoder::get_struct_field_names(&cdata, def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n@@ -469,14 +465,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(\n-            self.intr.clone(), &crate_data,\n-            def_id.index, get_crate_data,\n-            |def, name, vis| result.push(ChildItem {\n-                def: def,\n-                name: name,\n-                vis: vis\n-            }));\n+        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, name, vis| {\n+            result.push(ChildItem { def: def, name: name, vis: vis });\n+        });\n         result\n     }\n \n@@ -485,13 +476,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_top_level_item_of_crate(\n-            self.intr.clone(), &crate_data, get_crate_data,\n-            |def, name, vis| result.push(ChildItem {\n-                def: def,\n-                name: name,\n-                vis: vis\n-            }));\n+        decoder::each_top_level_item_of_crate(&crate_data, get_crate_data, |def, name, vis| {\n+            result.push(ChildItem { def: def, name: name, vis: vis });\n+        });\n         result\n     }\n "}, {"sha": "6baa0ac23f3f5073103ec8f6fcb709162544a547", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -37,7 +37,6 @@ use flate::Bytes;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap;\n-use syntax::parse::token::IdentInterner;\n use syntax_pos;\n \n pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n@@ -106,21 +105,18 @@ pub struct CStore {\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n     statically_included_foreign_items: RefCell<NodeSet>,\n-    pub intr: Rc<IdentInterner>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph,\n-               intr: Rc<IdentInterner>) -> CStore {\n+    pub fn new(dep_graph: &DepGraph) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FnvHashMap()),\n             extern_mod_crate_map: RefCell::new(FnvHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n-            intr: intr,\n             statically_included_foreign_items: RefCell::new(NodeSet()),\n             visible_parent_map: RefCell::new(FnvHashMap()),\n         }"}, {"sha": "3f5c9a6d3bd83724637bd350a38846d4d60efce5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 55, "deletions": 89, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -53,7 +53,7 @@ use rbml::reader;\n use rbml;\n use rustc_serialize::Decodable;\n use syntax::attr;\n-use syntax::parse::token::{self, IdentInterner};\n+use syntax::parse::token;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap;\n@@ -284,17 +284,14 @@ fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n-    maybe_item_name(intr, item).expect(\"no item in item_name\")\n+fn item_name(item: rbml::Doc) -> ast::Name {\n+    maybe_item_name(item).expect(\"no item in item_name\")\n }\n \n-fn maybe_item_name(intr: &IdentInterner, item: rbml::Doc) -> Option<ast::Name> {\n+fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n     reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n         let string = name.as_str_slice();\n-        match intr.find(string) {\n-            None => token::intern(string),\n-            Some(val) => val,\n-        }\n+        token::intern(string)\n     })\n }\n \n@@ -400,8 +397,7 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                       associated_type_names)\n }\n \n-pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n-                             cdata: Cmd,\n+pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n                              item_id: DefIndex,\n                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> ty::AdtDefMaster<'tcx>\n@@ -412,9 +408,7 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n             _ => bug!(\"unexpected family: {:?}\", family),\n         }\n     }\n-    fn get_enum_variants<'tcx>(intr: &IdentInterner,\n-                               cdata: Cmd,\n-                               doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n+    fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n@@ -428,16 +422,14 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n \n             ty::VariantDefData {\n                 did: did,\n-                name: item_name(intr, item),\n-                fields: get_variant_fields(intr, cdata, item),\n+                name: item_name(item),\n+                fields: get_variant_fields(cdata, item),\n                 disr_val: ConstInt::Infer(disr),\n                 kind: expect_variant_kind(item_family(item)),\n             }\n         }).collect()\n     }\n-    fn get_variant_fields<'tcx>(intr: &IdentInterner,\n-                                cdata: Cmd,\n-                                doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n+    fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n         let mut index = 0;\n         reader::tagged_docs(doc, tag_item_field).map(|f| {\n             let ff = item_family(f);\n@@ -446,53 +438,58 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n                 _ => bug!(\"expected field, found {:?}\", ff)\n             };\n             ty::FieldDefData::new(item_def_id(f, cdata),\n-                                  item_name(intr, f),\n+                                  item_name(f),\n                                   struct_field_family_to_visibility(ff))\n         }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n             let ff = item_family(f);\n-            let name = intr.intern(&index.to_string());\n+            let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n             index += 1;\n             ty::FieldDefData::new(item_def_id(f, cdata), name,\n                                   struct_field_family_to_visibility(ff))\n         })).collect()\n     }\n-    fn get_struct_variant<'tcx>(intr: &IdentInterner,\n-                                cdata: Cmd,\n+    fn get_struct_variant<'tcx>(cdata: Cmd,\n                                 doc: rbml::Doc,\n                                 did: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n-            name: item_name(intr, doc),\n-            fields: get_variant_fields(intr, cdata, doc),\n+            name: item_name(doc),\n+            fields: get_variant_fields(cdata, doc),\n             disr_val: ConstInt::Infer(0),\n             kind: expect_variant_kind(item_family(doc)),\n         }\n     }\n \n     let doc = cdata.lookup_item(item_id);\n     let did = DefId { krate: cdata.cnum, index: item_id };\n+    let mut ctor_did = None;\n     let (kind, variants) = match item_family(doc) {\n         Enum => {\n             (ty::AdtKind::Enum,\n-             get_enum_variants(intr, cdata, doc))\n+             get_enum_variants(cdata, doc))\n         }\n         Struct(..) => {\n-            let ctor_did =\n-                reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n-                map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n+            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+            ctor_did = reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).map(|ctor_doc| {\n+                translated_def_id(cdata, ctor_doc)\n+            });\n             (ty::AdtKind::Struct,\n-             vec![get_struct_variant(intr, cdata, doc, ctor_did)])\n+             vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n         }\n         _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n                   item_family(doc), did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n+    if let Some(ctor_did) = ctor_did {\n+        // Make adt definition available through constructor id as well.\n+        tcx.insert_adt_def(ctor_did, adt);\n+    }\n \n     // this needs to be done *after* the variant is interned,\n     // to support recursive structures\n     for variant in &adt.variants {\n-        if variant.kind() == ty::VariantKind::Tuple &&\n+        if variant.kind == ty::VariantKind::Tuple &&\n             adt.adt_kind() == ty::AdtKind::Enum {\n             // tuple-like enum variant fields aren't real items - get the types\n             // from the ctor.\n@@ -657,8 +654,7 @@ pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     })\n }\n \n-fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n-                                     cdata: Cmd,\n+fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n@@ -684,7 +680,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         // Get the item.\n         if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n             // Hand off the item to the callback.\n-            let child_name = item_name(&intr, child_item_doc);\n+            let child_name = item_name(child_item_doc);\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             let visibility = item_visibility(child_item_doc);\n             callback(def_like, child_name, visibility);\n@@ -705,7 +701,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                 if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n-                        let static_method_name = item_name(&intr, impl_method_doc);\n+                        let static_method_name = item_name(impl_method_doc);\n                         let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n                                                                       impl_item_def_id);\n                         callback(static_method_def_like,\n@@ -749,54 +745,41 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n-                               cdata: Cmd,\n-                               id: DefIndex,\n-                               get_crate_data: G,\n-                               callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex, get_crate_data: G, callback: F)\n+    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n+          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     // Find the item.\n     let item_doc = match cdata.get_item(id) {\n         None => return,\n         Some(item_doc) => item_doc,\n     };\n \n-    each_child_of_item_or_crate(intr,\n-                                cdata,\n-                                item_doc,\n-                                get_crate_data,\n-                                callback)\n+    each_child_of_item_or_crate(cdata, item_doc, get_crate_data, callback)\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n-                                          cdata: Cmd,\n-                                          get_crate_data: G,\n-                                          callback: F) where\n-    F: FnMut(DefLike, ast::Name, ty::Visibility),\n-    G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n+pub fn each_top_level_item_of_crate<F, G>(cdata: Cmd, get_crate_data: G, callback: F)\n+    where F: FnMut(DefLike, ast::Name, ty::Visibility),\n+          G: FnMut(ast::CrateNum) -> Rc<CrateMetadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n \n-    each_child_of_item_or_crate(intr,\n-                                cdata,\n+    each_child_of_item_or_crate(cdata,\n                                 crate_items_doc,\n                                 get_crate_data,\n                                 callback)\n }\n \n-pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Name {\n-    item_name(intr, cdata.lookup_item(id))\n+pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n+    item_name(cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n-                         -> Option<ast::Name> {\n-    maybe_item_name(intr, cdata.lookup_item(id))\n+pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n+    maybe_item_name(cdata.lookup_item(id))\n }\n \n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n@@ -949,12 +932,9 @@ pub fn get_impl_items(cdata: Cmd, impl_id: DefIndex)\n     }).collect()\n }\n \n-pub fn get_trait_name(intr: Rc<IdentInterner>,\n-                      cdata: Cmd,\n-                      id: DefIndex)\n-                      -> ast::Name {\n+pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     let doc = cdata.lookup_item(id);\n-    item_name(&intr, doc)\n+    item_name(doc)\n }\n \n pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n@@ -967,10 +947,7 @@ pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                        cdata: Cmd,\n-                                        id: DefIndex,\n-                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n@@ -987,7 +964,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n         _ => ImplContainer(container_id),\n     };\n \n-    let name = item_name(&intr, item_doc);\n+    let name = item_name(item_doc);\n     let vis = item_visibility(item_doc);\n     let defaultness = item_defaultness(item_doc);\n \n@@ -1062,8 +1039,7 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                            cdata: Cmd,\n+pub fn get_provided_trait_methods<'a, 'tcx>(cdata: Cmd,\n                                             id: DefIndex,\n                                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                             -> Vec<Rc<ty::Method<'tcx>>> {\n@@ -1074,10 +1050,7 @@ pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n         let mth = cdata.lookup_item(did.index);\n \n         if item_sort(mth) == Some('p') {\n-            let trait_item = get_impl_or_trait_item(intr.clone(),\n-                                                    cdata,\n-                                                    did.index,\n-                                                    tcx);\n+            let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n             if let Some(ty::MethodTraitItem(ref method)) = trait_item {\n                 Some((*method).clone())\n             } else {\n@@ -1089,10 +1062,7 @@ pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n-                                       cdata: Cmd,\n-                                       id: DefIndex,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+pub fn get_associated_consts<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                        -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n@@ -1103,10 +1073,7 @@ pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n \n             match item_sort(ac_doc) {\n                 Some('C') | Some('c') => {\n-                    let trait_item = get_impl_or_trait_item(intr.clone(),\n-                                                            cdata,\n-                                                            did.index,\n-                                                            tcx);\n+                    let trait_item = get_impl_or_trait_item(cdata, did.index, tcx);\n                     if let Some(ty::ConstTraitItem(ref ac)) = trait_item {\n                         Some((*ac).clone())\n                     } else {\n@@ -1174,14 +1141,13 @@ fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n     }\n }\n \n-pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n-    -> Vec<ast::Name> {\n+pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n     let item = cdata.lookup_item(id);\n     let mut index = 0;\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n-        item_name(intr, an_item)\n+        item_name(an_item)\n     }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n-        let name = intr.intern(&index.to_string());\n+        let name = token::with_ident_interner(|interner| interner.intern(index.to_string()));\n         index += 1;\n         name\n     })).collect()\n@@ -1497,12 +1463,12 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n         .map(|doc| DefIndex::from_u32(reader::doc_as_u32(doc)))\n }\n \n-pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n+pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n-        let name = item_name(intr, macro_doc);\n+        let name = item_name(macro_doc);\n         let attrs = get_attributes(macro_doc);\n         let span = get_macro_span(macro_doc);\n         let body = reader::get_doc(macro_doc, tag_macro_def_body);"}, {"sha": "7314259423592985f68cd4cd512a17247d7d2fd5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -217,7 +217,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n fn encode_struct_fields(rbml_w: &mut Encoder,\n                         variant: ty::VariantDef) {\n     for f in &variant.fields {\n-        if variant.is_tuple_struct() {\n+        if variant.kind == ty::VariantKind::Tuple {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n             rbml_w.start_tag(tag_item_field);\n@@ -250,7 +250,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let _task = index.record(vid, rbml_w);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, vid);\n-        encode_family(rbml_w, match variant.kind() {\n+        encode_family(rbml_w, match variant.kind {\n             ty::VariantKind::Struct => 'V',\n             ty::VariantKind::Tuple => 'v',\n             ty::VariantKind::Unit => 'w',"}, {"sha": "3484a8b75dded7105c12e44d98d5e3b11ad7ccd2", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -407,7 +407,14 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut Cursor<Vec<u8>>,\n \n     enc_region(w, cx, bs.region_bound);\n \n-    for tp in &bs.projection_bounds {\n+    // Encode projection_bounds in a stable order\n+    let mut projection_bounds: Vec<_> = bs.projection_bounds\n+                                          .iter()\n+                                          .map(|b| (b.item_name().as_str(), b))\n+                                          .collect();\n+    projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n+\n+    for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n         write!(w, \"P\");\n         enc_projection_predicate(w, cx, &tp.0);\n     }"}, {"sha": "88fb65d8eea03569d41c13958d524a7e6cf5fe48", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -700,19 +700,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n         Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => {\n-            let substs = Some(cx.tcx.node_id_item_substs(expr.id).substs);\n-            let tcx = cx.tcx.global_tcx();\n-            if let Some((e, _)) = const_eval::lookup_const_by_id(tcx, def_id, substs) {\n-                // FIXME ConstVal can't be yet used with adjustments, as they would be lost.\n-                if !cx.tcx.tables.borrow().adjustments.contains_key(&e.id) {\n-                    if let Some(v) = cx.try_const_eval_literal(e) {\n-                        return ExprKind::Literal { literal: v };\n-                    }\n-                }\n-            }\n-            def_id\n-        }\n+        Def::AssociatedConst(def_id) => def_id,\n \n         Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,"}, {"sha": "2438f43d24e0a42f8e87854af51e0ffe35c90ddb", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -129,21 +129,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> {\n-        let hint = const_eval::EvalHint::ExprTypeChecked;\n-        let tcx = self.tcx.global_tcx();\n-        const_eval::eval_const_expr_partial(tcx, e, hint, None).ok().and_then(|v| {\n-            match v {\n-                // All of these contain local IDs, unsuitable for storing in MIR.\n-                ConstVal::Struct(_) | ConstVal::Tuple(_) |\n-                ConstVal::Array(..) | ConstVal::Repeat(..) |\n-                ConstVal::Function(_) => None,\n-\n-                _ => Some(Literal::Value { value: v })\n-            }\n-        })\n-    }\n-\n     pub fn trait_method(&mut self,\n                         trait_def_id: DefId,\n                         method_name: &str,"}, {"sha": "c54c8bfb5981ed6d8469510cc76c47a212992f36", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -76,9 +76,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Path(..) | PatKind::QPath(..)\n-                if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n-            {\n+            PatKind::Path(..) => {\n                 match self.cx.tcx.expect_def(pat.id) {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.cx.tcx.global_tcx();\n@@ -104,11 +102,9 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    def =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"def not a constant: {:?}\",\n-                            def),\n+                    _ => {\n+                        self.variant_or_leaf(pat, vec![])\n+                    }\n                 }\n             }\n \n@@ -199,10 +195,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                self.variant_or_leaf(pat, vec![])\n-            }\n-\n             PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n@@ -253,10 +245,6 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n \n                 self.variant_or_leaf(pat, subpatterns)\n             }\n-\n-            PatKind::QPath(..) => {\n-                span_bug!(pat.span, \"unexpanded macro or bad constant etc\");\n-            }\n         };\n \n         Pattern {\n@@ -325,7 +313,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::TyAlias(..) => {\n+            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "acaf9b9b2faeed9d57b1b4da9a0cccd4b3b26238", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -436,7 +436,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprPath(..) => {\n-\n                 if let Def::Struct(..) = self.tcx.expect_def(expr.id) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {"}, {"sha": "d4465822229e953baf1e4d8e38a76138d85cbbd7", "filename": "src/librustc_resolve/assign_ids.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Resolver;\n+use rustc::session::Session;\n+use syntax::ast;\n+use syntax::ext::mtwt;\n+use syntax::fold::{self, Folder};\n+use syntax::ptr::P;\n+use syntax::util::move_map::MoveMap;\n+use syntax::util::small_vector::SmallVector;\n+\n+use std::collections::HashMap;\n+use std::mem;\n+\n+impl<'a> Resolver<'a> {\n+    pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n+        NodeIdAssigner {\n+            sess: self.session,\n+            macros_at_scope: &mut self.macros_at_scope,\n+        }.fold_crate(krate)\n+    }\n+}\n+\n+struct NodeIdAssigner<'a> {\n+    sess: &'a Session,\n+    macros_at_scope: &'a mut HashMap<ast::NodeId, Vec<ast::Mrk>>,\n+}\n+\n+impl<'a> Folder for NodeIdAssigner<'a> {\n+    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n+        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+        self.sess.next_node_id()\n+    }\n+\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+        block.map(|mut block| {\n+            block.id = self.new_id(block.id);\n+\n+            let stmt = block.stmts.pop();\n+            let mut macros = Vec::new();\n+            block.stmts = block.stmts.move_flat_map(|stmt| {\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(mtwt::outer_mark(item.ident.ctxt));\n+                        return None;\n+                    }\n+                }\n+\n+                let stmt = self.fold_stmt(stmt).pop().unwrap();\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                Some(stmt)\n+            });\n+\n+            stmt.and_then(|mut stmt| {\n+                // Avoid wasting a node id on a trailing expression statement,\n+                // which shares a HIR node with the expression itself.\n+                if let ast::StmtKind::Expr(expr) = stmt.node {\n+                    let expr = self.fold_expr(expr);\n+                    stmt.id = expr.id;\n+                    stmt.node = ast::StmtKind::Expr(expr);\n+                    Some(stmt)\n+                } else {\n+                    self.fold_stmt(stmt).pop()\n+                }\n+            }).map(|stmt| {\n+                if !macros.is_empty() {\n+                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n+                }\n+                block.stmts.push(stmt);\n+            });\n+\n+            block\n+        })\n+    }\n+\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        match item.node {\n+            ast::ItemKind::Mac(..) => SmallVector::zero(),\n+            _ => fold::noop_fold_item(item, self),\n+        }\n+    }\n+}"}, {"sha": "2535c264ef8f647fc516231ae8a55a2ed93375f5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 90, "deletions": 54, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -83,6 +83,7 @@ mod diagnostics;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n+mod assign_ids;\n \n enum SuggestionType {\n     Macro(String),\n@@ -461,7 +462,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = HashMap<Name, BindingInfo>;\n+type BindingMap = HashMap<ast::Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -651,6 +652,9 @@ enum RibKind<'a> {\n \n     // We passed through a module.\n     ModuleRibKind(Module<'a>),\n+\n+    // We passed through a `macro_rules!` statement with the given expansion\n+    MacroDefinition(ast::Mrk),\n }\n \n #[derive(Copy, Clone)]\n@@ -667,7 +671,7 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<Name, Def>,\n+    bindings: HashMap<ast::Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -927,6 +931,10 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n+    // Maps the node id of a statement to the expansions of the `macro_rules!`s\n+    // immediately above the statement (if appropriate).\n+    macros_at_scope: HashMap<NodeId, Vec<ast::Mrk>>,\n+\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n@@ -1113,6 +1121,7 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: Definitions::new(),\n+            macros_at_scope: HashMap::new(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1384,15 +1393,17 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: ast::Ident,\n+                                      mut ident: ast::Ident,\n                                       ns: Namespace,\n                                       record_used: bool)\n                                       -> Option<LexicalScopeBinding<'a>> {\n-        let name = match ns { ValueNS => mtwt::resolve(ident), TypeNS => ident.name };\n+        if ns == TypeNS {\n+            ident = ast::Ident::with_empty_ctxt(ident.name);\n+        }\n \n         // Walk backwards up the ribs in scope.\n         for i in (0 .. self.get_ribs(ns).len()).rev() {\n-            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&name).cloned() {\n+            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::LocalDef(LocalDef {\n                     ribs: Some((ns, i)),\n@@ -1419,6 +1430,16 @@ impl<'a> Resolver<'a> {\n                     };\n                 }\n             }\n+\n+            if let MacroDefinition(mac) = self.get_ribs(ns)[i].kind {\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n+                if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n+                    if mac == source_macro {\n+                        ident = source_ident;\n+                    }\n+                }\n+            }\n         }\n \n         None\n@@ -1555,18 +1576,27 @@ impl<'a> Resolver<'a> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, name: Name) -> Option<Def> {\n+    fn search_label(&self, mut ident: ast::Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n                     // Continue\n                 }\n+                MacroDefinition(mac) => {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    if let Some((source_ident, source_macro)) = mtwt::source(ident) {\n+                        if mac == source_macro {\n+                            ident = source_ident;\n+                        }\n+                    }\n+                }\n                 _ => {\n                     // Do not resolve labels across function boundary\n                     return None;\n                 }\n             }\n-            let result = rib.bindings.get(&name).cloned();\n+            let result = rib.bindings.get(&ident).cloned();\n             if result.is_some() {\n                 return result;\n             }\n@@ -1715,7 +1745,7 @@ impl<'a> Resolver<'a> {\n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(space, index as u32, def_id, name);\n-                    function_type_rib.bindings.insert(name, def);\n+                    function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -1886,7 +1916,7 @@ impl<'a> Resolver<'a> {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // plain insert (no renaming, types are not currently hygienic....)\n-        self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n+        self_type_rib.bindings.insert(keywords::SelfType.ident(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         self.type_ribs.pop();\n@@ -1997,7 +2027,7 @@ impl<'a> Resolver<'a> {\n                     _ => false,\n                 } {\n                     let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(mtwt::resolve(ident.node), binding_info);\n+                    binding_map.insert(ident.node, binding_info);\n                 }\n             }\n             true\n@@ -2019,15 +2049,14 @@ impl<'a> Resolver<'a> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                     None => {\n-                        resolve_error(self,\n-                                      p.span,\n-                                      ResolutionError::VariableNotBoundInPattern(key, 1, i + 1));\n+                        let error = ResolutionError::VariableNotBoundInPattern(key.name, 1, i + 1);\n+                        resolve_error(self, p.span, error);\n                     }\n                     Some(binding_i) => {\n                         if binding_0.binding_mode != binding_i.binding_mode {\n                             resolve_error(self,\n                                           binding_i.span,\n-                                          ResolutionError::VariableBoundWithDifferentMode(key,\n+                                          ResolutionError::VariableBoundWithDifferentMode(key.name,\n                                                                                           i + 1));\n                         }\n                     }\n@@ -2038,7 +2067,7 @@ impl<'a> Resolver<'a> {\n                 if !map_0.contains_key(&key) {\n                     resolve_error(self,\n                                   binding.span,\n-                                  ResolutionError::VariableNotBoundInPattern(key, i + 1, 1));\n+                                  ResolutionError::VariableNotBoundInPattern(key.name, i + 1, 1));\n                 }\n             }\n         }\n@@ -2068,6 +2097,7 @@ impl<'a> Resolver<'a> {\n         let orig_module = self.current_module;\n         let anonymous_module = self.module_map.get(&block.id).cloned(); // clones a reference\n \n+        let mut num_macro_definition_ribs = 0;\n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");\n             self.value_ribs.push(Rib::new(ModuleRibKind(anonymous_module)));\n@@ -2078,10 +2108,24 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block);\n+        for stmt in &block.stmts {\n+            if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n+                num_macro_definition_ribs += marks.len() as u32;\n+                for mark in marks {\n+                    self.value_ribs.push(Rib::new(MacroDefinition(mark)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n \n         // Move back up.\n         self.current_module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.value_ribs.pop();\n+            self.label_ribs.pop();\n+        }\n         self.value_ribs.pop();\n         if let Some(_) = anonymous_module {\n             self.type_ribs.pop();\n@@ -2172,15 +2216,15 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut HashMap<Name, NodeId>)\n+                     bindings: &mut HashMap<ast::Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n         // must not add it if it's in the bindings map\n         // because that breaks the assumptions later\n         // passes make about or-patterns.)\n-        let renamed = mtwt::resolve(ident.node);\n-        let def = match bindings.get(&renamed).cloned() {\n+        let mut def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+        match bindings.get(&ident.node).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n                 resolve_error(\n@@ -2189,7 +2233,6 @@ impl<'a> Resolver<'a> {\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n                         &ident.node.name.as_str())\n                 );\n-                Def::Err\n             }\n             Some(..) if pat_src == PatternSource::FnParam => {\n                 // `fn f(a: u8, a: u8)`, error\n@@ -2199,29 +2242,24 @@ impl<'a> Resolver<'a> {\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n                         &ident.node.name.as_str())\n                 );\n-                Def::Err\n             }\n             Some(..) if pat_src == PatternSource::Match => {\n                 // `Variant1(a) | Variant2(a)`, ok\n                 // Reuse definition from the first `a`.\n-                self.value_ribs.last_mut().unwrap().bindings[&renamed]\n+                def = self.value_ribs.last_mut().unwrap().bindings[&ident.node];\n             }\n             Some(..) => {\n                 span_bug!(ident.span, \"two bindings with the same name from \\\n                                        unexpected pattern source {:?}\", pat_src);\n             }\n             None => {\n-                // A completely fresh binding, add to the lists.\n-                // FIXME: Later stages are not ready to deal with `Def::Err` here yet, so\n-                // define `Invalid` bindings as `Def::Local`, just don't add them to the lists.\n-                let def = Def::Local(self.definitions.local_def_id(pat_id), pat_id);\n+                // A completely fresh binding, add to the lists if it's valid.\n                 if ident.node.name != keywords::Invalid.name() {\n-                    bindings.insert(renamed, outer_pat_id);\n-                    self.value_ribs.last_mut().unwrap().bindings.insert(renamed, def);\n+                    bindings.insert(ident.node, outer_pat_id);\n+                    self.value_ribs.last_mut().unwrap().bindings.insert(ident.node, def);\n                 }\n-                def\n             }\n-        };\n+        }\n \n         PathResolution::new(def)\n     }\n@@ -2279,59 +2317,57 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut HashMap<Name, NodeId>) {\n+                       bindings: &mut HashMap<ast::Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             match pat.node {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let local_def = self.resolve_identifier(ident.node, ValueNS, true);\n-                    let resolution = if let Some(LocalDef { def, .. }) = local_def {\n+                    let resolution = self.resolve_identifier(ident.node, ValueNS, true)\n+                                         .map(|local_def| PathResolution::new(local_def.def))\n+                                         .and_then(|resolution| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n-                        match def {\n+                        match resolution.base_def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n-                                PathResolution::new(def)\n+                                Some(resolution)\n                             }\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n                                 // A fresh binding that shadows something unacceptable.\n-                                let kind_name = PathResolution::new(def).kind_name();\n                                 resolve_error(\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), kind_name, ident.node.name)\n+                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n                                 );\n-                                err_path_resolution()\n+                                None\n                             }\n-                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) | Def::Err => {\n+                            Def::Local(..) | Def::Upvar(..) | Def::Fn(..) => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n-                                self.fresh_binding(ident, pat.id, outer_pat_id,\n-                                                   pat_src, bindings)\n+                                None\n                             }\n                             def => {\n                                 span_bug!(ident.span, \"unexpected definition for an \\\n                                                        identifier in pattern {:?}\", def);\n                             }\n                         }\n-                    } else {\n-                        // Fall back to a fresh binding.\n+                    }).unwrap_or_else(|| {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    };\n+                    });\n \n                     self.record_def(pat.id, resolution);\n                 }\n \n                 PatKind::TupleStruct(ref path, _, _) => {\n                     self.resolve_pattern_path(pat.id, None, path, ValueNS, |def| {\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) | Def::Err => true,\n+                            Def::Struct(..) | Def::Variant(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant or struct\");\n@@ -2341,7 +2377,7 @@ impl<'a> Resolver<'a> {\n                     self.resolve_pattern_path(pat.id, qself.as_ref(), path, ValueNS, |def| {\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n-                            Def::Const(..) | Def::AssociatedConst(..) | Def::Err => true,\n+                            Def::Const(..) | Def::AssociatedConst(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant, struct or constant\");\n@@ -2351,7 +2387,7 @@ impl<'a> Resolver<'a> {\n                     self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n                         match def {\n                             Def::Struct(..) | Def::Variant(..) |\n-                            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::Err => true,\n+                            Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n                             _ => false,\n                         }\n                     }, \"variant, struct or type alias\");\n@@ -2482,7 +2518,7 @@ impl<'a> Resolver<'a> {\n                           record_used: bool)\n                           -> Option<LocalDef> {\n         if identifier.name == keywords::Invalid.name() {\n-            return Some(LocalDef::from_def(Def::Err));\n+            return None;\n         }\n \n         self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)\n@@ -2504,7 +2540,7 @@ impl<'a> Resolver<'a> {\n             Def::Local(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | ModuleRibKind(..) => {\n+                        NormalRibKind | ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ClosureRibKind(function_id) => {\n@@ -2553,7 +2589,7 @@ impl<'a> Resolver<'a> {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind(_) | ClosureRibKind(..) |\n-                        ModuleRibKind(..) => {\n+                        ModuleRibKind(..) | MacroDefinition(..) => {\n                             // Nothing to do. Continue.\n                         }\n                         ItemRibKind => {\n@@ -2754,7 +2790,7 @@ impl<'a> Resolver<'a> {\n         let names = self.value_ribs\n                     .iter()\n                     .rev()\n-                    .flat_map(|rib| rib.bindings.keys());\n+                    .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n             if name != found {\n@@ -2765,7 +2801,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n         if let Some(label) = label {\n-            let (label, def) = (mtwt::resolve(label), Def::Label(id));\n+            let def = Def::Label(id);\n             self.with_label_rib(|this| {\n                 this.label_ribs.last_mut().unwrap().bindings.insert(label, def);\n                 this.visit_block(block);\n@@ -2972,15 +3008,15 @@ impl<'a> Resolver<'a> {\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(mtwt::resolve(label.node), def);\n+                        rib.bindings.insert(label.node, def);\n                     }\n \n                     visit::walk_expr(this, expr);\n                 })\n             }\n \n             ExprKind::Break(Some(label)) | ExprKind::Continue(Some(label)) => {\n-                match self.search_label(mtwt::resolve(label.node)) {\n+                match self.search_label(label.node) {\n                     None => {\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,"}, {"sha": "681d9ec735b4fd1f491cb6e5e508299be29ff2bd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -400,26 +400,30 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Resolves an `ImportResolvingError` into the correct enum discriminant\n-    /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n-        // If it's a single failed import then create a \"fake\" import\n-        // resolution for it so that later resolve stages won't complain.\n-        if let SingleImport { target, .. } = e.import_directive.subclass {\n+    // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n+    // failed resolution\n+    fn import_dummy_binding(&self, source_module: Module<'b>, directive: &'b ImportDirective<'b>) {\n+        if let SingleImport { target, .. } = directive.subclass {\n             let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n-            let dummy_binding = e.import_directive.import(dummy_binding, None);\n+            let dummy_binding = directive.import(dummy_binding, None);\n \n-            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n-            let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n+            let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n+            let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n         }\n+    }\n \n+    /// Resolves an `ImportResolvingError` into the correct enum discriminant\n+    /// and passes that on to `resolve_error`.\n+    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n+        // If the error is a single failed import then create a \"fake\" import\n+        // resolution for it so that later resolve stages won't complain.\n+        self.import_dummy_binding(e.source_module, e.import_directive);\n         let path = import_path_to_string(&e.import_directive.module_path,\n                                          &e.import_directive.subclass);\n-\n         resolve_error(self.resolver,\n                       e.span,\n                       ResolutionError::UnresolvedImport(Some((&path, &e.help))));\n@@ -500,6 +504,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 if !binding.is_importable() {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n+                    // Do not import this illegal binding. Import a dummy binding and pretend\n+                    // everything is fine\n+                    self.import_dummy_binding(module_, directive);\n+                    return Success(());\n                 }\n \n                 let privacy_error = if !self.resolver.is_accessible(binding.vis) {"}, {"sha": "5e967f3250f710523440b186f468246a7d65b4e8", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -57,7 +57,7 @@ macro_rules! down_cast_data {\n             data\n         } else {\n             span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n-        }\n+        };\n     };\n }\n "}, {"sha": "08e894ffbcfd48c4e37fde4d75f6565713c79f80", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -796,7 +796,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n             PatKind::Tuple(..) => true,\n             PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n                 match tcx.expect_def(pat.id) {\n-                    Def::Struct(..) | Def::TyAlias(..) => true,\n+                    Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n                     _ => false,\n                 }\n             }\n@@ -2003,7 +2003,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild |\n+        PatKind::Path(..) | PatKind::Wild |\n         PatKind::Lit(..) | PatKind::Range(..) => ()\n     }\n     return bcx;"}, {"sha": "70d142e50edb921b3b7e7082f7b3540e5b690efa", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 184, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -30,7 +30,6 @@ use super::ModuleTranslation;\n \n use back::link;\n use back::linker::LinkerInfo;\n-use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::cfg;\n@@ -75,7 +74,7 @@ use expr;\n use glue;\n use inline;\n use machine;\n-use machine::{llalign_of_min, llsize_of, llsize_of_real};\n+use machine::{llalign_of_min, llsize_of};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -86,7 +85,6 @@ use trans_item::TransItem;\n use tvec;\n use type_::Type;\n use type_of;\n-use type_of::*;\n use value::Value;\n use Disr;\n use util::common::indenter;\n@@ -98,6 +96,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n+use std::ptr;\n use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n@@ -2074,87 +2073,6 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, DebugLoc::None);\n }\n \n-fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span, id: ast::NodeId) {\n-    let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n-\n-    let print_info = ccx.sess().print_enum_sizes();\n-\n-    let levels = ccx.tcx().node_lint_levels.borrow();\n-    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n-    let lvlsrc = levels.get(&(id, lint_id));\n-    let is_allow = lvlsrc.map_or(true, |&(lvl, _)| lvl == lint::Allow);\n-\n-    if is_allow && !print_info {\n-        // we're not interested in anything here\n-        return;\n-    }\n-\n-    let ty = ccx.tcx().node_id_to_type(id);\n-    let avar = adt::represent_type(ccx, ty);\n-    match *avar {\n-        adt::General(_, ref variants, _) => {\n-            for var in variants {\n-                let mut size = 0;\n-                for field in var.fields.iter().skip(1) {\n-                    // skip the discriminant\n-                    size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n-                }\n-                sizes.push(size);\n-            }\n-        },\n-        _ => { /* its size is either constant or unimportant */ }\n-    }\n-\n-    let (largest, slargest, largest_index) = sizes.iter().enumerate().fold((0, 0, 0),\n-        |(l, s, li), (idx, &size)|\n-            if size > l {\n-                (size, l, idx)\n-            } else if size > s {\n-                (l, size, li)\n-            } else {\n-                (l, s, li)\n-            }\n-    );\n-\n-    // FIXME(#30505) Should use logging for this.\n-    if print_info {\n-        let llty = type_of::sizing_type_of(ccx, ty);\n-\n-        let sess = &ccx.tcx().sess;\n-        sess.span_note_without_error(sp,\n-                                     &format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n-        match *avar {\n-            adt::General(..) => {\n-                for (i, var) in enum_def.variants.iter().enumerate() {\n-                    ccx.tcx()\n-                       .sess\n-                       .span_note_without_error(var.span,\n-                                                &format!(\"variant data: {} bytes\", sizes[i]));\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    // we only warn if the largest variant is at least thrice as large as\n-    // the second-largest.\n-    if !is_allow && largest > slargest * 3 && slargest > 0 {\n-        // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n-        // pass for the latter already ran.\n-        lint::raw_struct_lint(&ccx.tcx().sess,\n-                              &ccx.tcx().sess.lint_store.borrow(),\n-                              lint::builtin::VARIANT_SIZE_DIFFERENCES,\n-                              *lvlsrc.unwrap(),\n-                              Some(sp),\n-                              &format!(\"enum variant is more than three times larger ({} bytes) \\\n-                                        than the next largest (ignoring padding)\",\n-                                       largest))\n-            .span_note(enum_def.variants[largest_index].span,\n-                       \"this variant is the largest\")\n-            .emit();\n-    }\n-}\n-\n pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n     // applicable to variable declarations and may not really make sense for\n@@ -2194,26 +2112,6 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n-fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n-    let _icx = push_ctxt(\"trans_item\");\n-\n-    match item.node {\n-        hir::ItemEnum(ref enum_definition, ref gens) => {\n-            if gens.ty_params.is_empty() {\n-                // sizes only make sense for non-generic types\n-                enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n-            }\n-        }\n-        hir::ItemFn(..) |\n-        hir::ItemImpl(..) |\n-        hir::ItemStatic(..) => {\n-            // Don't do anything here. Translation has been moved to\n-            // being \"collector-driven\".\n-        }\n-        _ => {}\n-    }\n-}\n-\n /// Create the `main` function which will initialise the rust runtime and call\n /// users\u2019 main function.\n pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n@@ -2304,7 +2202,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n                                                  start_fn,\n                                                  args.as_ptr(),\n                                                  args.len() as c_uint,\n-                                                 0 as *mut _,\n+                                                 ptr::null_mut(),\n                                                  noname());\n \n             llvm::LLVMBuildRet(bld, result);\n@@ -2659,19 +2557,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     symbol_names_test::report_symbol_names(&shared_ccx);\n \n-    {\n-        let ccx = crate_context_list.get_ccx(0);\n-\n-        // FIXME: #34018\n-        // At this point, we only walk the HIR for running\n-        // enum_variant_size_lint(). This should arguably be moved somewhere\n-        // else.\n-        {\n-            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n-            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n-        }\n-    }\n-\n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n@@ -2758,72 +2643,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// We visit all the items in the krate and translate them.  We do\n-/// this in two walks. The first walk just finds module items. It then\n-/// walks the full contents of those module items and translates all\n-/// the items within. Note that this entire process is O(n). The\n-/// reason for this two phased walk is that each module is\n-/// (potentially) placed into a distinct codegen-unit. This walk also\n-/// ensures that the immediate contents of each module is processed\n-/// entirely before we proceed to find more modules, helping to ensure\n-/// an equitable distribution amongst codegen-units.\n-pub struct TransModVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransModVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        match i.node {\n-            hir::ItemMod(_) => {\n-                let item_ccx = self.ccx.rotate();\n-                intravisit::walk_item(&mut TransItemsWithinModVisitor { ccx: &item_ccx }, i);\n-            }\n-            _ => { }\n-        }\n-    }\n-}\n-\n-/// Translates all the items within a given module. Expects owner to\n-/// invoke `walk_item` on a module item. Ignores nested modules.\n-pub struct TransItemsWithinModVisitor<'a, 'tcx: 'a> {\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n-    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n-        self.visit_item(self.ccx.tcx().map.expect_item(item_id.id));\n-    }\n-\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        match i.node {\n-            hir::ItemMod(..) => {\n-                // skip modules, they will be uncovered by the TransModVisitor\n-            }\n-            _ => {\n-                let def_id = self.ccx.tcx().map.local_def_id(i.id);\n-                let tcx = self.ccx.tcx();\n-\n-                // Create a subtask for trans'ing a particular item. We are\n-                // giving `trans_item` access to this item, so also record a read.\n-                tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n-                    tcx.dep_graph.read(DepNode::Hir(def_id));\n-\n-                    // We are going to be accessing various tables\n-                    // generated by TypeckItemBody; we also assume\n-                    // that the body passes type check. These tables\n-                    // are not individually tracked, so just register\n-                    // a read here.\n-                    tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n-\n-                    trans_item(self.ccx, i);\n-                });\n-\n-                intravisit::walk_item(self, i);\n-            }\n-        }\n-    }\n-}\n-\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();"}, {"sha": "e88257dcd4cf874490d6186b6a0deee09306681b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         check_call(\"invoke\", llfn, args);\n \n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n \n         unsafe {\n             llvm::LLVMRustBuildInvoke(self.llbuilder,\n@@ -859,7 +859,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         check_call(\"call\", llfn, args);\n \n-        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n+        let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(ptr::null_mut());\n \n         unsafe {\n             llvm::LLVMRustBuildCall(self.llbuilder, llfn, args.as_ptr(),\n@@ -961,7 +961,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.count_insn(\"trap\");\n             llvm::LLVMRustBuildCall(self.llbuilder, t,\n                                     args.as_ptr(), args.len() as c_uint,\n-                                    0 as *mut _,\n+                                    ptr::null_mut(),\n                                     noname());\n         }\n     }\n@@ -1000,7 +1000,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                        parent: Option<ValueRef>,\n                        args: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"cleanuppad\");\n-        let parent = parent.unwrap_or(0 as *mut _);\n+        let parent = parent.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"cleanuppad\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn cleanup_ret(&self, cleanup: ValueRef,\n                        unwind: Option<BasicBlockRef>) -> ValueRef {\n         self.count_insn(\"cleanupret\");\n-        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, cleanup, unwind)\n         };\n@@ -1052,8 +1052,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         unwind: Option<BasicBlockRef>,\n                         num_handlers: usize) -> ValueRef {\n         self.count_insn(\"catchswitch\");\n-        let parent = parent.unwrap_or(0 as *mut _);\n-        let unwind = unwind.unwrap_or(0 as *mut _);\n+        let parent = parent.unwrap_or(ptr::null_mut());\n+        let unwind = unwind.unwrap_or(ptr::null_mut());\n         let name = CString::new(\"catchswitch\").unwrap();\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,"}, {"sha": "90443d9ec4f7067b0406ec02db37d4ab974e0f39", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -169,14 +169,14 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }));\n     let llfn = declare::declare_fn(ccx, &symbol, function_type);\n \n-    // set an inline hint for all closures\n-    attributes::inline(llfn, attributes::InlineAttr::Hint);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     debug!(\"get_or_create_declaration_if_closure(): inserting new \\\n             closure {:?}: {:?}\",\n            instance, Value(llfn));\n-    ccx.instances().borrow_mut().insert(instance, llfn);\n+\n+    // NOTE: We do *not* store llfn in the ccx.instances() map here,\n+    //       that is only done, when the closures body is translated.\n \n     llfn\n }\n@@ -197,8 +197,8 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // (*) Note that in the case of inlined functions, the `closure_def_id` will be the\n     // defid of the closure in its original crate, whereas `id` will be the id of the local\n     // inlined copy.\n-\n-    let param_substs = closure_substs.func_substs;\n+    debug!(\"trans_closure_expr(id={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+           id, closure_def_id, closure_substs);\n \n     let ccx = match dest {\n         Dest::SaveIn(bcx, _) => bcx.ccx(),\n@@ -207,41 +207,49 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure_expr\");\n \n-    debug!(\"trans_closure_expr(id={:?}, closure_def_id={:?}, closure_substs={:?})\",\n-           id, closure_def_id, closure_substs);\n-\n-    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n-    llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n-    llvm::SetUniqueComdat(ccx.llmod(), llfn);\n-\n-    // Get the type of this closure. Use the current `param_substs` as\n-    // the closure substitutions. This makes sense because the closure\n-    // takes the same set of type arguments as the enclosing fn, and\n-    // this function (`trans_closure`) is invoked at the point\n-    // of the closure expression.\n-\n-    let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n-    let sig = tcx.erase_late_bound_regions(sig);\n-    let sig = tcx.normalize_associated_type(&sig);\n-\n-    let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n-                                                          closure_substs);\n-    let sig = ty::FnSig {\n-        inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n-                    .into_iter().chain(sig.inputs).collect(),\n-        output: sig.output,\n-        variadic: false\n-    };\n-\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfn,\n-                  Instance::new(closure_def_id, param_substs),\n-                  id,\n-                  &sig,\n-                  Abi::RustCall,\n-                  ClosureEnv::Closure(closure_def_id, id));\n+    let param_substs = closure_substs.func_substs;\n+    let instance = Instance::new(closure_def_id, param_substs);\n+\n+    // If we have not done so yet, translate this closure's body\n+    if  !ccx.instances().borrow().contains_key(&instance) {\n+        let llfn = get_or_create_closure_declaration(ccx, closure_def_id, closure_substs);\n+        llvm::SetLinkage(llfn, llvm::WeakODRLinkage);\n+        llvm::SetUniqueComdat(ccx.llmod(), llfn);\n+\n+        // set an inline hint for all closures\n+        attributes::inline(llfn, attributes::InlineAttr::Hint);\n+\n+        // Get the type of this closure. Use the current `param_substs` as\n+        // the closure substitutions. This makes sense because the closure\n+        // takes the same set of type arguments as the enclosing fn, and\n+        // this function (`trans_closure`) is invoked at the point\n+        // of the closure expression.\n+\n+        let sig = &tcx.closure_type(closure_def_id, closure_substs).sig;\n+        let sig = tcx.erase_late_bound_regions(sig);\n+        let sig = tcx.normalize_associated_type(&sig);\n+\n+        let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n+                                                              closure_substs);\n+        let sig = ty::FnSig {\n+            inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n+                        .into_iter().chain(sig.inputs).collect(),\n+            output: sig.output,\n+            variadic: false\n+        };\n+\n+        trans_closure(ccx,\n+                      decl,\n+                      body,\n+                      llfn,\n+                      Instance::new(closure_def_id, param_substs),\n+                      id,\n+                      &sig,\n+                      Abi::RustCall,\n+                      ClosureEnv::Closure(closure_def_id, id));\n+\n+        ccx.instances().borrow_mut().insert(instance, llfn);\n+    }\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and"}, {"sha": "00feb2cd1de0961f5ec1e97965ea1480d3ee3543", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -900,7 +900,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 Def::Variant(enum_did, variant_did) => {\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n-                    match vinfo.kind() {\n+                    match vinfo.kind {\n                         ty::VariantKind::Unit => {\n                             let repr = adt::represent_type(cx, ety);\n                             adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])"}, {"sha": "88903726d64f7bbee90ed58128e6ec7391d566eb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -219,14 +219,6 @@ impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_ccx<'b>(&'b self, index: usize) -> CrateContext<'b, 'tcx> {\n-        CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: &self.local_ccxs[..],\n-        }\n-    }\n-\n     pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n         self.shared\n     }"}, {"sha": "0b75402486812b4706706c1363a284cdd2341ffd", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -313,7 +313,7 @@ fn walk_pattern(cx: &CrateContext,\n             }\n         }\n \n-        PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n         }\n "}, {"sha": "46813d957dce3b58c5b4268592497aed9ce7aefc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -81,7 +81,7 @@ pub struct UniqueTypeId(ast::Name);\n // UniqueTypeIds.\n pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n-    unique_id_interner: Interner<Rc<String>>,\n+    unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n@@ -313,7 +313,7 @@ impl<'tcx> TypeMap<'tcx> {\n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n \n-        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n+        let key = self.unique_id_interner.intern(unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n@@ -383,7 +383,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n-        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n+        let interner_key = self.unique_id_interner.intern(enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n }\n@@ -1109,7 +1109,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if let ty::VariantKind::Unit = self.variant.kind() {\n+        if self.variant.kind == ty::VariantKind::Unit {\n             return Vec::new();\n         }\n \n@@ -1126,7 +1126,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         };\n \n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n-            let name = if let ty::VariantKind::Tuple = self.variant.kind() {\n+            let name = if self.variant.kind == ty::VariantKind::Tuple {\n                 format!(\"__{}\", i)\n             } else {\n                 f.name.to_string()\n@@ -1356,7 +1356,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.kind() {\n+                    name: match non_null_variant.kind {\n                         ty::VariantKind::Tuple => \"__0\".to_string(),\n                         ty::VariantKind::Struct => {\n                             non_null_variant.fields[0].name.to_string()\n@@ -1524,7 +1524,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant.kind() {\n+    let mut arg_names: Vec<_> = match variant.kind {\n         ty::VariantKind::Unit => vec![],\n         ty::VariantKind::Tuple => {\n             variant.fields"}, {"sha": "8b8e658533ed09db43dad823f5e6914d7901ef2c", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -28,10 +28,10 @@ use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n+use rustc::dep_graph::DepNode;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n-use syntax::parse::token;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n@@ -73,6 +73,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                   self.to_raw_string(),\n                   ccx.codegen_unit().name);\n \n+        self.register_reads(ccx);\n+\n         match *self {\n             TransItem::Static(node_id) => {\n                 let item = ccx.tcx().map.expect_item(node_id);\n@@ -99,6 +101,46 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                ccx.codegen_unit().name);\n     }\n \n+    /// If necessary, creates a subtask for trans'ing a particular item and registers reads on\n+    /// `TypeckItemBody` and `Hir`.\n+    fn register_reads(&self, ccx: &CrateContext<'a, 'tcx>) {\n+        let tcx = ccx.tcx();\n+        let def_id = match *self {\n+            TransItem::Static(node_id) => {\n+                tcx.map.local_def_id(node_id)\n+            }\n+            TransItem::Fn(instance) => {\n+                if let Some(node) = tcx.map.as_local_node_id(instance.def) {\n+                    if let hir_map::Node::NodeItem(_) = tcx.map.get(node) {\n+                        // This already is a \"real\" item\n+                        instance.def\n+                    } else {\n+                        // Get the enclosing item and register a read on it\n+                        tcx.map.get_parent_did(node)\n+                    }\n+                } else {\n+                    // Translating an inlined item from another crate? Don't track anything.\n+                    return;\n+                }\n+            }\n+            TransItem::DropGlue(_) => {\n+                // Nothing to track for drop glue\n+                return;\n+            }\n+        };\n+\n+        tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n+            tcx.dep_graph.read(DepNode::Hir(def_id));\n+\n+            // We are going to be accessing various tables\n+            // generated by TypeckItemBody; we also assume\n+            // that the body passes type check. These tables\n+            // are not individually tracked, so just register\n+            // a read here.\n+            tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n+        });\n+    }\n+\n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n                      linkage: llvm::Linkage) {\n@@ -562,8 +604,8 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     for projection in projections {\n         let projection = projection.skip_binder();\n-        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n-        output.push_str(&name[..]);\n+        let name = &projection.projection_ty.item_name.as_str();\n+        output.push_str(name);\n         output.push_str(\"=\");\n         push_unique_type_name(tcx, projection.ty, output);\n         output.push_str(\", \");"}, {"sha": "9ff30f9ede26295d85f4e94c853d817ce3bf3d84", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -53,7 +53,7 @@ use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n use hir::{self, SelfKind};\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n@@ -1327,7 +1327,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 };\n \n                 if self.ensure_super_predicates(span, trait_did).is_err() {\n-                    return (tcx.types.err, ty_path_def);\n+                    return (tcx.types.err, Def::Err);\n                 }\n \n                 let candidates: Vec<ty::PolyTraitRef> =\n@@ -1341,7 +1341,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                     &assoc_name.as_str(),\n                                                     span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n@@ -1351,7 +1351,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n@@ -1361,15 +1361,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                      assoc_name,\n                                                      span) {\n                     Ok(bound) => bound,\n-                    Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n+                    Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             _ => {\n                 self.report_ambiguous_associated_type(span,\n                                                       &ty.to_string(),\n                                                       \"Trait\",\n                                                       &assoc_name.as_str());\n-                return (tcx.types.err, ty_path_def);\n+                return (tcx.types.err, Def::Err);\n             }\n         };\n \n@@ -1574,45 +1574,46 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Note that both base_segments and assoc_segments may be empty, although not at\n-    // the same time.\n+    // Resolve possibly associated type path into a type and final definition.\n+    // Note that both base_segments and assoc_segments may be empty, although not at same time.\n     pub fn finish_resolving_def_to_ty(&self,\n                                       rscope: &RegionScope,\n                                       span: Span,\n                                       param_mode: PathParamMode,\n-                                      mut def: Def,\n+                                      base_def: Def,\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n                                       assoc_segments: &[hir::PathSegment])\n                                       -> (Ty<'tcx>, Def) {\n-        debug!(\"finish_resolving_def_to_ty(def={:?}, \\\n+        // Convert the base type.\n+        debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n                 base_segments={:?}, \\\n                 assoc_segments={:?})\",\n-               def,\n+               base_def,\n                base_segments,\n                assoc_segments);\n-        let mut ty = self.base_def_to_ty(rscope,\n-                                         span,\n-                                         param_mode,\n-                                         def,\n-                                         opt_self_ty,\n-                                         base_path_ref_id,\n-                                         base_segments);\n-        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", ty);\n+        let base_ty = self.base_def_to_ty(rscope,\n+                                          span,\n+                                          param_mode,\n+                                          base_def,\n+                                          opt_self_ty,\n+                                          base_path_ref_id,\n+                                          base_segments);\n+        debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n+\n         // If any associated type segments remain, attempt to resolve them.\n+        let (mut ty, mut def) = (base_ty, base_def);\n         for segment in assoc_segments {\n             debug!(\"finish_resolving_def_to_ty: segment={:?}\", segment);\n-            if ty.sty == ty::TyError {\n+            // This is pretty bad (it will fail except for T::A and Self::A).\n+            let (new_ty, new_def) = self.associated_path_def_to_ty(span, ty, def, segment);\n+            ty = new_ty;\n+            def = new_def;\n+\n+            if def == Def::Err {\n                 break;\n             }\n-            // This is pretty bad (it will fail except for T::A and Self::A).\n-            let (a_ty, a_def) = self.associated_path_def_to_ty(span,\n-                                                               ty,\n-                                                               def,\n-                                                               segment);\n-            ty = a_ty;\n-            def = a_def;\n         }\n         (ty, def)\n     }\n@@ -1719,23 +1720,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = tcx.expect_resolution(ast_ty.id);\n-                let def = path_res.base_def;\n                 let base_ty_end = path.segments.len() - path_res.depth;\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(rscope, &qself.ty)\n                 });\n-                let (ty, _def) = self.finish_resolving_def_to_ty(rscope,\n-                                                                 ast_ty.span,\n-                                                                 PathParamMode::Explicit,\n-                                                                 def,\n-                                                                 opt_self_ty,\n-                                                                 ast_ty.id,\n-                                                                 &path.segments[..base_ty_end],\n-                                                                 &path.segments[base_ty_end..]);\n-\n-                if path_res.depth != 0 && ty.sty != ty::TyError {\n-                    // Write back the new resolution.\n-                    tcx.def_map.borrow_mut().insert(ast_ty.id, def::PathResolution::new(def));\n+                let (ty, def) = self.finish_resolving_def_to_ty(rscope,\n+                                                                ast_ty.span,\n+                                                                PathParamMode::Explicit,\n+                                                                path_res.base_def,\n+                                                                opt_self_ty,\n+                                                                ast_ty.id,\n+                                                                &path.segments[..base_ty_end],\n+                                                                &path.segments[base_ty_end..]);\n+\n+                // Write back the new resolution.\n+                if path_res.depth != 0 {\n+                    tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n                 }\n \n                 ty"}, {"sha": "e90b32cd5dfc0192c5001b46a8dc2795acab7f39", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 127, "deletions": 195, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -10,13 +10,12 @@\n \n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n+use hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n+use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n use check::{FnCtxt, Expectation};\n use lint;\n use util::nodemap::FnvHashMap;\n-use session::Session;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n@@ -28,20 +27,6 @@ use syntax_pos::Span;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-// This function exists due to the warning \"diagnostic code E0164 already used\"\n-fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n-    let name = pprust::path_to_string(path);\n-    let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\", name);\n-    if lint {\n-        sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-                      pat.id,\n-                      pat.span,\n-                      msg);\n-    } else {\n-        span_err!(sess, pat.span, E0164, \"{}\", msg);\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n@@ -136,22 +121,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-            PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n-                let const_did = tcx.expect_def(pat.id).def_id();\n-                let const_scheme = tcx.lookup_item_type(const_did);\n-                assert!(const_scheme.generics.is_empty());\n-                let const_ty = self.instantiate_type_scheme(pat.span,\n-                                                            &Substs::empty(),\n-                                                            &const_scheme.ty);\n-                self.write_ty(pat.id, const_ty);\n-\n-                // FIXME(#20489) -- we should limit the types here to scalars or something!\n-\n-                // As with PatKind::Lit, what we really want here is that there\n-                // exist a LUB, but for the cases that can occur, subtype\n-                // is good enough.\n-                self.demand_suptype(pat.span, expected, const_ty);\n-            }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n@@ -197,33 +166,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n-                self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n-            }\n-            PatKind::Path(ref path) => {\n-                self.check_pat_enum(pat, path, &[], None, expected, false);\n+                self.check_pat_tuple_struct(pat, path, &subpats, ddpos, expected);\n             }\n-            PatKind::QPath(ref qself, ref path) => {\n-                let self_ty = self.to_ty(&qself.ty);\n-                let path_res = tcx.expect_resolution(pat.id);\n-                if path_res.base_def == Def::Err {\n-                    self.set_tainted_by_errors();\n-                    self.write_error(pat.id);\n-                    return;\n-                }\n-                if let Some((opt_ty, segments, def)) =\n-                        self.resolve_ty_and_def_ufcs(path_res, Some(self_ty),\n-                                                     path, pat.span, pat.id) {\n-                    if self.check_assoc_item_is_const(def, pat.span) {\n-                        let scheme = tcx.lookup_item_type(def.def_id());\n-                        let predicates = tcx.lookup_predicates(def.def_id());\n-                        self.instantiate_path(segments, scheme, &predicates,\n-                                              opt_ty, def, pat.span, pat.id);\n-                        let const_ty = self.node_ty(pat.id);\n-                        self.demand_suptype(pat.span, expected, const_ty);\n-                    } else {\n-                        self.write_error(pat.id)\n-                    }\n-                }\n+            PatKind::Path(ref opt_qself, ref path) => {\n+                let opt_qself_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n+                self.check_pat_path(pat, opt_qself_ty, path, expected);\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n                 self.check_pat_struct(pat, path, fields, etc, expected);\n@@ -403,20 +350,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // subtyping.\n     }\n \n-    fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n-        match def {\n-            Def::AssociatedConst(..) => true,\n-            Def::Method(..) => {\n-                span_err!(self.tcx.sess, span, E0327,\n-                          \"associated items in match patterns must be constants\");\n-                false\n-            }\n-            _ => {\n-                span_bug!(span, \"non-associated item in check_assoc_item_is_const\");\n-            }\n-        }\n-    }\n-\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n@@ -554,167 +487,166 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n-                            path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n-                            etc: bool, expected: Ty<'tcx>) {\n-        let tcx = self.tcx;\n-\n-        let def = tcx.expect_def(pat.id);\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                let name = pprust::path_to_string(path);\n-                span_err!(tcx.sess, pat.span, E0163,\n-                          \"`{}` does not name a struct or a struct variant\", name);\n-                self.write_error(pat.id);\n-\n-                for field in fields {\n-                    self.check_pat(&field.node.pat, tcx.types.err);\n-                }\n-                return;\n+    fn check_pat_struct(&self,\n+                        pat: &'gcx hir::Pat,\n+                        path: &hir::Path,\n+                        fields: &'gcx [Spanned<hir::FieldPat>],\n+                        etc: bool,\n+                        expected: Ty<'tcx>)\n+    {\n+        // Resolve the path and check the definition for errors.\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id,\n+                                                                                 pat.span) {\n+            variant_ty\n+        } else {\n+            self.write_error(pat.id);\n+            for field in fields {\n+                self.check_pat(&field.node.pat, self.tcx.types.err);\n             }\n+            return;\n         };\n \n-        let pat_ty = self.instantiate_type(def.def_id(), path);\n-        let item_substs = match pat_ty.sty {\n+        // Type check the path.\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n+        let substs = match pat_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n             _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n         };\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n-        self.check_struct_pat_fields(pat.span, fields, variant, &item_substs, etc);\n-\n-        self.write_ty(pat.id, pat_ty);\n-        self.write_substs(pat.id, ty::ItemSubsts {\n-            substs: item_substs\n-        });\n+        self.check_struct_pat_fields(pat.span, fields, variant, substs, etc);\n     }\n \n-    fn check_pat_enum(&self,\n+    fn check_pat_path(&self,\n                       pat: &hir::Pat,\n+                      opt_self_ty: Option<Ty<'tcx>>,\n                       path: &hir::Path,\n-                      subpats: &'gcx [P<hir::Pat>],\n-                      ddpos: Option<usize>,\n-                      expected: Ty<'tcx>,\n-                      is_tuple_struct_pat: bool)\n+                      expected: Ty<'tcx>)\n     {\n-        // Typecheck the path.\n         let tcx = self.tcx;\n-\n-        let path_res = tcx.expect_resolution(pat.id);\n-        if path_res.base_def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let report_unexpected_def = || {\n+            span_err!(tcx.sess, pat.span, E0533,\n+                      \"`{}` does not name a unit variant, unit struct or a constant\",\n+                      pprust::path_to_string(path));\n             self.write_error(pat.id);\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n-            return;\n-        }\n-\n-        let (opt_ty, segments, def) = match self.resolve_ty_and_def_ufcs(path_res,\n-                                                                         None, path,\n-                                                                         pat.span, pat.id) {\n-            Some(resolution) => resolution,\n-            // Error handling done inside resolve_ty_and_def_ufcs, so if\n-            // resolution fails just return.\n-            None => {return;}\n         };\n \n-        // Items that were partially resolved before should have been resolved to\n-        // associated constants (i.e. not methods).\n-        if path_res.depth != 0 && !self.check_assoc_item_is_const(def, pat.span) {\n-            self.write_error(pat.id);\n-            return;\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                   pat.id, pat.span);\n+        match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                self.write_error(pat.id);\n+                return;\n+            }\n+            Def::Method(..) => {\n+                report_unexpected_def();\n+                return;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                let variant = tcx.expect_variant_def(def);\n+                if variant.kind != VariantKind::Unit {\n+                    report_unexpected_def();\n+                    return;\n+                }\n+            }\n+            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n         }\n \n-        let enum_def = def.variant_def_ids()\n-            .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+    }\n \n-        let ctor_scheme = tcx.lookup_item_type(enum_def);\n-        let ctor_predicates = tcx.lookup_predicates(enum_def);\n-        let path_scheme = if ctor_scheme.ty.is_fn() {\n-            let fn_ret = tcx.no_late_bound_regions(&ctor_scheme.ty.fn_ret()).unwrap();\n-            ty::TypeScheme {\n-                ty: fn_ret.unwrap(),\n-                generics: ctor_scheme.generics,\n-            }\n-        } else {\n-            ctor_scheme\n-        };\n-        self.instantiate_path(segments, path_scheme, &ctor_predicates,\n-                              opt_ty, def, pat.span, pat.id);\n-        let report_bad_struct_kind = |is_warning| {\n-            bad_struct_kind_err(tcx.sess, pat, path, is_warning);\n-            if is_warning { return; }\n+    fn check_pat_tuple_struct(&self,\n+                              pat: &hir::Pat,\n+                              path: &hir::Path,\n+                              subpats: &'gcx [P<hir::Pat>],\n+                              ddpos: Option<usize>,\n+                              expected: Ty<'tcx>)\n+    {\n+        let tcx = self.tcx;\n+        let on_error = || {\n             self.write_error(pat.id);\n             for pat in subpats {\n                 self.check_pat(&pat, tcx.types.err);\n             }\n         };\n-\n-        // If we didn't have a fully resolved path to start with, we had an\n-        // associated const, and we should quit now, since the rest of this\n-        // function uses checks specific to structs and enums.\n-        if path_res.depth != 0 {\n-            if is_tuple_struct_pat {\n-                report_bad_struct_kind(false);\n+        let report_unexpected_def = |is_lint| {\n+            let msg = format!(\"`{}` does not name a tuple variant or a tuple struct\",\n+                              pprust::path_to_string(path));\n+            if is_lint {\n+                tcx.sess.add_lint(lint::builtin::MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n+                                  pat.id, pat.span, msg);\n             } else {\n-                let pat_ty = self.node_ty(pat.id);\n-                self.demand_suptype(pat.span, expected, pat_ty);\n+                span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+                on_error();\n             }\n-            return;\n-        }\n-\n-        let pat_ty = self.node_ty(pat.id);\n-        self.demand_eqtype(pat.span, expected, pat_ty);\n+        };\n \n-        let real_path_ty = self.node_ty(pat.id);\n-        let (kind_name, variant, expected_substs) = match real_path_ty.sty {\n-            ty::TyEnum(enum_def, expected_substs) => {\n-                let variant = enum_def.variant_of_def(def);\n-                (\"variant\", variant, expected_substs)\n-            }\n-            ty::TyStruct(struct_def, expected_substs) => {\n-                let variant = struct_def.struct_variant();\n-                (\"struct\", variant, expected_substs)\n-            }\n-            _ => {\n-                report_bad_struct_kind(false);\n+        // Resolve the path and check the definition for errors.\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(None, path, pat.id, pat.span);\n+        let variant = match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n                 return;\n             }\n-        };\n-\n-        match (is_tuple_struct_pat, variant.kind()) {\n-            (true, ty::VariantKind::Unit) if subpats.is_empty() && ddpos.is_some() => {\n-                // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n-                // is allowed for backward compatibility.\n-                report_bad_struct_kind(true);\n+            Def::Const(..) | Def::AssociatedConst(..) | Def::Method(..) => {\n+                report_unexpected_def(false);\n+                return;\n             }\n-            (true, ty::VariantKind::Unit) |\n-            (false, ty::VariantKind::Tuple) |\n-            (_, ty::VariantKind::Struct) => {\n-                report_bad_struct_kind(false);\n-                return\n+            Def::Variant(..) | Def::Struct(..) => {\n+                tcx.expect_variant_def(def)\n             }\n-            _ => {}\n+            _ => bug!(\"unexpected pattern definition {:?}\", def)\n+        };\n+        if variant.kind == VariantKind::Unit && subpats.is_empty() && ddpos.is_some() {\n+            // Matching unit structs with tuple variant patterns (`UnitVariant(..)`)\n+            // is allowed for backward compatibility.\n+            report_unexpected_def(true);\n+        } else if variant.kind != VariantKind::Tuple {\n+            report_unexpected_def(false);\n+            return;\n         }\n \n+        // Type check the path.\n+        let scheme = tcx.lookup_item_type(def.def_id());\n+        let scheme = if scheme.ty.is_fn() {\n+            // Replace constructor type with constructed type for tuple struct patterns.\n+            let fn_ret = tcx.no_late_bound_regions(&scheme.ty.fn_ret()).unwrap().unwrap();\n+            ty::TypeScheme { ty: fn_ret, generics: scheme.generics }\n+        } else {\n+            // Leave the type as is for unit structs (backward compatibility).\n+            scheme\n+        };\n+        let predicates = tcx.lookup_predicates(def.def_id());\n+        let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n+                                                 opt_ty, def, pat.span, pat.id);\n+        self.demand_eqtype(pat.span, expected, pat_ty);\n+\n+        // Type check subpatterns.\n         if subpats.len() == variant.fields.len() ||\n                 subpats.len() < variant.fields.len() && ddpos.is_some() {\n+            let substs = match pat_ty.sty {\n+                ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+                ref ty => bug!(\"unexpected pattern type {:?}\", ty),\n+            };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], expected_substs);\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat(&subpat, field_ty);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n-                      \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                      subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"},\n-                      kind_name,\n-                      variant.fields.len(), if variant.fields.len() == 1 {\"\"} else {\"s\"});\n-\n-            for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err);\n-            }\n+                      \"this pattern has {} field{s}, but the corresponding {} has {} field{s}\",\n+                      subpats.len(), def.kind_name(), variant.fields.len(),\n+                      s = if variant.fields.len() == 1 {\"\"} else {\"s\"});\n+            on_error();\n         }\n     }\n "}, {"sha": "fc1d2236f3feaa07c63c5e99e424500bc5704b53", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 136, "deletions": 125, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -84,7 +84,7 @@ use astconv::{AstConv, ast_region_to_region, PathParamMode};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n-use hir::def::{self, Def};\n+use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n@@ -881,7 +881,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n-                        Position::ArgumentIs(_) | Position::ArgumentNext => {\n+                        Position::ArgumentIs(_) => {\n                             span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n@@ -1621,64 +1621,32 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note that this function is only intended to be used with type-paths,\n     /// not with value-paths.\n-    pub fn instantiate_type(&self,\n-                            did: DefId,\n-                            path: &hir::Path)\n-                            -> Ty<'tcx>\n-    {\n-        debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n-        let type_scheme =\n-            self.tcx.lookup_item_type(did);\n-        let type_predicates =\n-            self.tcx.lookup_predicates(did);\n+    pub fn instantiate_type_path(&self,\n+                                 did: DefId,\n+                                 path: &hir::Path,\n+                                 node_id: ast::NodeId)\n+                                 -> Ty<'tcx> {\n+        debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n+        let type_scheme = self.tcx.lookup_item_type(did);\n+        let type_predicates = self.tcx.lookup_predicates(did);\n         let substs = AstConv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n                                                      &type_scheme.generics,\n                                                      path.segments.last().unwrap());\n-        debug!(\"instantiate_type: ty={:?} substs={:?}\", &type_scheme.ty, &substs);\n-        let bounds =\n-            self.instantiate_bounds(path.span, &substs, &type_predicates);\n-        self.add_obligations_for_parameters(\n-            traits::ObligationCause::new(\n-                path.span,\n-                self.body_id,\n-                traits::ItemObligation(did)),\n-            &bounds);\n-\n-        self.instantiate_type_scheme(path.span, &substs, &type_scheme.ty)\n-    }\n-\n-    /// Return the dict-like variant corresponding to a given `Def`.\n-    pub fn def_struct_variant(&self,\n-                              def: Def,\n-                              _span: Span)\n-                              -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n-    {\n-        let (adt, variant) = match def {\n-            Def::Variant(enum_id, variant_id) => {\n-                let adt = self.tcx.lookup_adt_def(enum_id);\n-                (adt, adt.variant_with_id(variant_id))\n-            }\n-            Def::Struct(did) | Def::TyAlias(did) => {\n-                let typ = self.tcx.lookup_item_type(did);\n-                if let ty::TyStruct(adt, _) = typ.ty.sty {\n-                    (adt, adt.struct_variant())\n-                } else {\n-                    return None;\n-                }\n-            }\n-            _ => return None\n-        };\n+        let substs = self.tcx.mk_substs(substs);\n+        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", &type_scheme.ty, substs);\n+        let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+        let cause = traits::ObligationCause::new(path.span, self.body_id,\n+                                                 traits::ItemObligation(did));\n+        self.add_obligations_for_parameters(cause, &bounds);\n \n-        let var_kind = variant.kind();\n-        if var_kind == ty::VariantKind::Struct {\n-            Some((adt, variant))\n-        } else if var_kind == ty::VariantKind::Unit {\n-             Some((adt, variant))\n-         } else {\n-             None\n-         }\n+        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &type_scheme.ty);\n+        self.write_ty(node_id, ty_substituted);\n+        self.write_substs(node_id, ty::ItemSubsts {\n+            substs: substs\n+        });\n+        ty_substituted\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n@@ -2998,7 +2966,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n             let field = match base_t.sty {\n                 ty::TyStruct(base_def, substs) => {\n-                    tuple_like = base_def.struct_variant().is_tuple_struct();\n+                    tuple_like = base_def.struct_variant().kind == ty::VariantKind::Tuple;\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n@@ -3153,35 +3121,57 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn check_struct_path(&self,\n+                         path: &hir::Path,\n+                         node_id: ast::NodeId,\n+                         span: Span)\n+                         -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n+        let def = self.finish_resolving_struct_path(path, node_id, span);\n+        let variant = match def {\n+            Def::Err => {\n+                self.set_tainted_by_errors();\n+                return None;\n+            }\n+            Def::Variant(..) | Def::Struct(..) => {\n+                Some(self.tcx.expect_variant_def(def))\n+            }\n+            Def::TyAlias(did) | Def::AssociatedTy(_, did) => {\n+                if let Some(&ty::TyStruct(adt, _)) = self.tcx.opt_lookup_item_type(did)\n+                                                             .map(|scheme| &scheme.ty.sty) {\n+                    Some(adt.struct_variant())\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None\n+        };\n+        if variant.is_none() || variant.unwrap().kind == ty::VariantKind::Tuple {\n+            // Reject tuple structs for now, braced and unit structs are allowed.\n+            span_err!(self.tcx.sess, span, E0071,\n+                      \"`{}` does not name a struct or a struct variant\",\n+                      pprust::path_to_string(path));\n+            return None;\n+        }\n+\n+        let ty = self.instantiate_type_path(def.def_id(), path, node_id);\n+        Some((variant.unwrap(), ty))\n+    }\n+\n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>)\n     {\n-        let tcx = self.tcx;\n-\n         // Find the relevant variant\n-        let def = tcx.expect_def(expr.id);\n-        if def == Def::Err {\n-            self.set_tainted_by_errors();\n+        let (variant, expr_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n+                                                                                  expr.span) {\n+            variant_ty\n+        } else {\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n             return;\n-        }\n-        let variant = match self.def_struct_variant(def, path.span) {\n-            Some((_, variant)) => variant,\n-            None => {\n-                span_err!(self.tcx.sess, path.span, E0071,\n-                          \"`{}` does not name a structure\",\n-                          pprust::path_to_string(path));\n-                self.check_struct_fields_on_error(expr.id, fields, base_expr);\n-                return;\n-            }\n         };\n \n-        let expr_ty = self.instantiate_type(def.def_id(), path);\n-        self.write_ty(expr.id, expr_ty);\n-\n         self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n@@ -3192,13 +3182,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr.id,\n                         adt.struct_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(\n-                                expr.span, &f.ty(tcx, substs)\n+                                expr.span, &f.ty(self.tcx, substs)\n                             )\n                         }).collect()\n                     );\n                 }\n                 _ => {\n-                    span_err!(tcx.sess, base_expr.span, E0436,\n+                    span_err!(self.tcx.sess, base_expr.span, E0436,\n                               \"functional record update syntax requires a struct\");\n                 }\n             }\n@@ -3349,24 +3339,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n             self.write_ty(id, oprnd_t);\n           }\n-          hir::ExprPath(ref maybe_qself, ref path) => {\n-              let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n-                  self.to_ty(&qself.ty)\n-              });\n-\n-              let path_res = tcx.expect_resolution(id);\n-              if let Some((opt_ty, segments, def)) =\n-                      self.resolve_ty_and_def_ufcs(path_res, opt_self_ty, path,\n-                                                   expr.span, expr.id) {\n-                  if def != Def::Err {\n-                      let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n-                                                                                         def);\n-                      self.instantiate_path(segments, scheme, &predicates,\n-                                            opt_ty, def, expr.span, id);\n-                  } else {\n-                      self.set_tainted_by_errors();\n-                      self.write_ty(id, self.tcx.types.err);\n-                  }\n+          hir::ExprPath(ref opt_qself, ref path) => {\n+              let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n+              let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n+                                                                         expr.id, expr.span);\n+              if def != Def::Err {\n+                  let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n+                                                                                     def);\n+                  self.instantiate_value_path(segments, scheme, &predicates,\n+                                              opt_ty, def, expr.span, id);\n+              } else {\n+                  self.set_tainted_by_errors();\n+                  self.write_error(id);\n               }\n \n               // We always require that the type provided as the value for\n@@ -3704,37 +3688,67 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected);\n     }\n \n+    // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n+    // The newly resolved definition is written into `def_map`.\n+    pub fn finish_resolving_struct_path(&self,\n+                                        path: &hir::Path,\n+                                        node_id: ast::NodeId,\n+                                        span: Span)\n+                                        -> Def\n+    {\n+        let path_res = self.tcx().expect_resolution(node_id);\n+        if path_res.depth == 0 {\n+            // If fully resolved already, we don't have to do anything.\n+            path_res.base_def\n+        } else {\n+            let base_ty_end = path.segments.len() - path_res.depth;\n+            let (_ty, def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n+                                                                 PathParamMode::Optional,\n+                                                                 path_res.base_def,\n+                                                                 None,\n+                                                                 node_id,\n+                                                                 &path.segments[..base_ty_end],\n+                                                                 &path.segments[base_ty_end..]);\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            def\n+        }\n+    }\n+\n+    // Resolve associated value path into a base type and associated constant or method definition.\n+    // The newly resolved definition is written into `def_map`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n-                                       path_res: def::PathResolution,\n                                        opt_self_ty: Option<Ty<'tcx>>,\n                                        path: &'b hir::Path,\n-                                       span: Span,\n-                                       node_id: ast::NodeId)\n-                                       -> Option<(Option<Ty<'tcx>>, &'b [hir::PathSegment], Def)>\n+                                       node_id: ast::NodeId,\n+                                       span: Span)\n+                                       -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-\n-        // If fully resolved already, we don't have to do anything.\n+        let path_res = self.tcx().expect_resolution(node_id);\n         if path_res.depth == 0 {\n-            Some((opt_self_ty, &path.segments, path_res.base_def))\n+            // If fully resolved already, we don't have to do anything.\n+            (path_res.base_def, opt_self_ty, &path.segments)\n         } else {\n-            let def = path_res.base_def;\n+            // Try to resolve everything except for the last segment as a type.\n             let ty_segments = path.segments.split_last().unwrap().1;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let (ty, _def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n                                                                  PathParamMode::Optional,\n-                                                                 def,\n+                                                                 path_res.base_def,\n                                                                  opt_self_ty,\n                                                                  node_id,\n                                                                  &ty_segments[..base_ty_end],\n                                                                  &ty_segments[base_ty_end..]);\n+\n+            // Resolve an associated constant or method on the previously resolved type.\n             let item_segment = path.segments.last().unwrap();\n             let item_name = item_segment.name;\n             let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n-                Ok(def) => Some(def),\n+                Ok(def) => def,\n                 Err(error) => {\n                     let def = match error {\n-                        method::MethodError::PrivateMatch(def) => Some(def),\n-                        _ => None,\n+                        method::MethodError::PrivateMatch(def) => def,\n+                        _ => Def::Err,\n                     };\n                     if item_name != keywords::Invalid.name() {\n                         self.report_method_error(span, ty, item_name, None, error);\n@@ -3743,14 +3757,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            if let Some(def) = def {\n-                // Write back the new resolution.\n-                self.tcx().def_map.borrow_mut().insert(node_id, def::PathResolution::new(def));\n-                Some((Some(ty), slice::ref_slice(item_segment), def))\n-            } else {\n-                self.write_error(node_id);\n-                None\n-            }\n+            // Write back the new resolution.\n+            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            (def, Some(ty), slice::ref_slice(item_segment))\n         }\n     }\n \n@@ -3986,15 +3995,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n-    pub fn instantiate_path(&self,\n-                            segments: &[hir::PathSegment],\n-                            type_scheme: TypeScheme<'tcx>,\n-                            type_predicates: &ty::GenericPredicates<'tcx>,\n-                            opt_self_ty: Option<Ty<'tcx>>,\n-                            def: Def,\n-                            span: Span,\n-                            node_id: ast::NodeId) {\n-        debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n+    pub fn instantiate_value_path(&self,\n+                                  segments: &[hir::PathSegment],\n+                                  type_scheme: TypeScheme<'tcx>,\n+                                  type_predicates: &ty::GenericPredicates<'tcx>,\n+                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  def: Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId)\n+                                  -> Ty<'tcx> {\n+        debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n                segments,\n                def,\n                node_id,\n@@ -4023,7 +4033,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //    actually pass through this function, but rather the\n         //    `ast_ty_to_ty` function in `astconv`. However, in the case\n         //    of struct patterns (and maybe literals) we do invoke\n-        //    `instantiate_path` to get the general type of an instance of\n+        //    `instantiate_value_path` to get the general type of an instance of\n         //    a struct. (In these cases, there are actually no type\n         //    parameters permitted at present, but perhaps we will allow\n         //    them in the future.)\n@@ -4246,20 +4256,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 Err(_) => {\n                     span_bug!(span,\n-                        \"instantiate_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n+                        \"instantiate_value_path: (UFCS) {:?} was a subtype of {:?} but now is not?\",\n                         self_ty,\n                         impl_ty);\n                 }\n             }\n         }\n \n-        debug!(\"instantiate_path: type of {:?} is {:?}\",\n+        debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n         self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });\n+        ty_substituted\n     }\n \n     /// Finds the parameters that the user provided and adds them to `substs`. If too many"}, {"sha": "41e7a467fa33a89ff80aa890306ccdaf63d1b511", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -949,7 +949,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   scheme: ty::TypeScheme<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n-    let ctor_ty = match variant.kind() {\n+    let ctor_ty = match variant.kind {\n         VariantKind::Unit | VariantKind::Struct => scheme.ty,\n         VariantKind::Tuple => {\n             let inputs: Vec<_> =\n@@ -1040,15 +1040,17 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 def: &hir::VariantData)\n                                 -> ty::AdtDefMaster<'tcx>\n {\n-\n     let did = ccx.tcx.map.local_def_id(it.id);\n-    let ctor_id = if !def.is_struct() {\n-        ccx.tcx.map.local_def_id(def.id())\n-    } else {\n-        did\n-    };\n-    ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct,\n-        vec![convert_struct_variant(ccx, ctor_id, it.name, ConstInt::Infer(0), def)])\n+    // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n+    let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n+                                               ConstInt::Infer(0), def)];\n+    let adt = ccx.tcx.intern_adt_def(did, ty::AdtKind::Struct, variants);\n+    if let Some(ctor_id) = ctor_id {\n+        // Make adt definition available through constructor id as well.\n+        ccx.tcx.insert_adt_def(ctor_id, adt);\n+    }\n+    adt\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)"}, {"sha": "8769bc1a32b5080856297c7f7928c14e8b3eeb32", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1895,33 +1895,6 @@ fn my_start(argc: isize, argv: *const *const u8) -> isize {\n ```\n \"##,\n \n-E0163: r##\"\n-This error means that an attempt was made to match an enum variant as a\n-struct type when the variant isn't a struct type:\n-\n-```compile_fail\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        B{i} => i, // error E0163\n-    }\n-}\n-```\n-\n-Try using `()` instead:\n-\n-```\n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B(i) => i,\n-    }\n-}\n-```\n-\"##,\n-\n E0164: r##\"\n This error means that an attempt was made to match a struct type enum\n variant as a non-struct type:\n@@ -3225,42 +3198,6 @@ impl Foo for Bar {\n ```\n \"##,\n \n-E0327: r##\"\n-You cannot use associated items other than constant items as patterns. This\n-includes method items. Example of erroneous code:\n-\n-```compile_fail\n-enum B {}\n-\n-impl B {\n-    fn bb() -> i32 { 0 }\n-}\n-\n-fn main() {\n-    match 0 {\n-        B::bb => {} // error: associated items in match patterns must\n-                    // be constants\n-    }\n-}\n-```\n-\n-Please check that you're not using a method as a pattern. Example:\n-\n-```\n-enum B {\n-    ba,\n-    bb\n-}\n-\n-fn main() {\n-    match B::ba {\n-        B::bb => {} // ok!\n-        _ => {}\n-    }\n-}\n-```\n-\"##,\n-\n E0329: r##\"\n An attempt was made to access an associated constant through either a generic\n type parameter or `Self`. This is not supported yet. An example causing this\n@@ -4106,6 +4043,7 @@ register_diagnostics! {\n //  E0129,\n //  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n+//  E0163, // merged into E0071\n     E0167,\n //  E0168,\n //  E0173, // manual implementations of unboxed closure traits are experimental\n@@ -4162,4 +4100,5 @@ register_diagnostics! {\n     E0527, // expected {} elements, found {}\n     E0528, // expected at least {} elements, found {}\n     E0529, // slice pattern expects array or slice, not `{}`\n+    E0533, // `{}` does not name a unit variant, unit struct or a constant\n }"}, {"sha": "7445ff94eb50277ca217c8f3627f7e4f8aa2ae98", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -39,6 +39,8 @@ pub use core::char::{MAX, from_digit, from_u32, from_u32_unchecked};\n pub use core::char::{EncodeUtf16, EncodeUtf8, EscapeDefault, EscapeUnicode};\n \n // unstable reexports\n+#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n+pub use core::char::{DecodeUtf8, decode_utf8};\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n pub use tables::UNICODE_VERSION;\n \n@@ -232,8 +234,8 @@ impl char {\n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n     /// character, as `char`s.\n     ///\n-    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n-    /// where `NNNN` is the shortest hexadecimal representation.\n+    /// All characters are escaped with Rust syntax of the form `\\u{NNNNNN}`\n+    /// where `NNNNNN` is the shortest hexadecimal representation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "f91a754ab57db3a71359a6b279fe0afc66a82cea", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -33,6 +33,7 @@\n #![no_std]\n \n #![feature(core_char_ext)]\n+#![feature(decode_utf8)]\n #![feature(lang_items)]\n #![feature(staged_api)]\n #![feature(unicode)]"}, {"sha": "21543e2ad073e4d9745f1bd168e5d1e99498987d", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 949, "deletions": 848, "changes": 1797, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44"}, {"sha": "a41d3b0253a3668c794bb72e74fb02120de9c5d0", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -14,6 +14,7 @@ arena = { path = \"../libarena\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_driver = { path = \"../librustc_driver\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "3d6925041cf5b0e2839e3e1d5fea9e137f406149", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n-use rustc::util::common::slice_pat;\n \n use rustc_const_eval::lookup_const_by_id;\n \n@@ -204,7 +203,7 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match slice_pat(&&*variant.fields) {\n+        struct_type: match &variant.fields[..] {\n             &[] => doctree::Unit,\n             &[_] if variant.kind == ty::VariantKind::Tuple => doctree::Newtype,\n             &[..] if variant.kind == ty::VariantKind::Tuple => doctree::Tuple,"}, {"sha": "0211b2c9bc7ba5176c06cfd9d433bc0143264276", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1624,8 +1624,25 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TyVec(ref ty) => Vector(box ty.clean(cx)),\n-            TyFixedLengthVec(ref ty, ref e) =>\n-                FixedVector(box ty.clean(cx), pprust::expr_to_string(e)),\n+            TyFixedLengthVec(ref ty, ref e) => {\n+                let n = if let Some(tcx) = cx.tcx_opt() {\n+                    use rustc_const_math::{ConstInt, ConstUsize};\n+                    use rustc_const_eval::eval_const_expr;\n+                    use rustc::middle::const_val::ConstVal;\n+                    match eval_const_expr(tcx, e) {\n+                        ConstVal::Integral(ConstInt::Usize(u)) => match u {\n+                            ConstUsize::Us16(u) => u.to_string(),\n+                            ConstUsize::Us32(u) => u.to_string(),\n+                            ConstUsize::Us64(u) => u.to_string(),\n+                        },\n+                        // after type checking this can't fail\n+                        _ => unreachable!(),\n+                    }\n+                } else {\n+                    pprust::expr_to_string(e)\n+                };\n+                FixedVector(box ty.clean(cx), n)\n+            },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref p) => {\n                 resolve_type(cx, p.clean(cx), self.id)\n@@ -1904,7 +1921,7 @@ impl Clean<Item> for doctree::Variant {\n \n impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let kind = match self.kind() {\n+        let kind = match self.kind {\n             ty::VariantKind::Unit => CLikeVariant,\n             ty::VariantKind::Tuple => {\n                 TupleVariant(\n@@ -2578,9 +2595,9 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n         PatKind::Binding(_, ref p, _) => p.node.to_string(),\n-        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n-        PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n-                                which is not allowed in function arguments\"),\n+        PatKind::TupleStruct(ref p, _, _) | PatKind::Path(None, ref p) => path_to_string(p),\n+        PatKind::Path(..) => panic!(\"tried to get argument name from qualified PatKind::Path, \\\n+                                     which is not allowed in function arguments\"),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n@@ -2653,7 +2670,7 @@ fn resolve_type(cx: &DocContext,\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());\n         }\n-        Def::SelfTy(..) | Def::TyParam(..) => true,\n+        Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n         _ => false,\n     };\n     let did = register_def(&*cx, def);"}, {"sha": "49a3991ecbe0bfb7b1a51d74bb11c1fd2b6d65e7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -24,7 +24,6 @@ use rustc_metadata::cstore::CStore;\n \n use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token;\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -136,7 +135,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts, &dep_graph, cpath, diagnostic_handler,\n                                        codemap, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));"}, {"sha": "eed2615175b27a62ce77ce4debd5a2de1aff430e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -19,8 +19,7 @@ use std::fmt;\n use std::iter::repeat;\n \n use rustc::middle::cstore::LOCAL_CRATE;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::util::common::slice_pat;\n+use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n@@ -302,18 +301,19 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     }\n \n     let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n-    let &(ref fqp, shortty) = match cache.paths.get(&did) {\n-        Some(p) => p,\n-        None => return None,\n-    };\n-\n-    let mut url = if did.is_local() || cache.inlined.contains(&did) {\n-        repeat(\"../\").take(loc.len()).collect::<String>()\n-    } else {\n-        match cache.extern_locations[&did.krate] {\n-            (_, render::Remote(ref s)) => s.to_string(),\n-            (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-            (_, render::Unknown) => return None,\n+    let (fqp, shortty, mut url) = match cache.paths.get(&did) {\n+        Some(&(ref fqp, shortty)) => {\n+            (fqp, shortty, repeat(\"../\").take(loc.len()).collect())\n+        }\n+        None => match cache.external_paths.get(&did) {\n+            Some(&(ref fqp, shortty)) => {\n+                (fqp, shortty, match cache.extern_locations[&did.krate] {\n+                    (_, render::Remote(ref s)) => s.to_string(),\n+                    (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                    (_, render::Unknown) => return None,\n+                })\n+            }\n+            None => return None,\n         }\n     };\n     for component in &fqp[..fqp.len() - 1] {\n@@ -388,22 +388,18 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[&DefId {\n-                krate: cnum,\n-                index: CRATE_DEF_INDEX,\n-            }];\n             let loc = match m.extern_locations[&cnum] {\n-                (_, render::Remote(ref s)) => Some(s.to_string()),\n-                (_, render::Local) => {\n+                (ref cname, render::Remote(ref s)) => Some((cname, s.to_string())),\n+                (ref cname, render::Local) => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n-                    Some(repeat(\"../\").take(len).collect::<String>())\n+                    Some((cname, repeat(\"../\").take(len).collect::<String>()))\n                 }\n                 (_, render::Unknown) => None,\n             };\n-            if let Some(root) = loc {\n+            if let Some((cname, root)) = loc {\n                 write!(f, \"<a class='primitive' href='{}{}/primitive.{}.html'>\",\n                        root,\n-                       path.0.first().unwrap(),\n+                       cname,\n                        prim.to_url_str())?;\n                 needs_termination = true;\n             }\n@@ -471,7 +467,7 @@ impl fmt::Display for clean::Type {\n                        decl.decl)\n             }\n             clean::Tuple(ref typs) => {\n-                match slice_pat(&&**typs) {\n+                match &typs[..] {\n                     &[] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n                     &[ref one] => {\n                         primitive_link(f, clean::PrimitiveTuple, \"(\")?;"}, {"sha": "2e2fc011ddbe6c3198c0ac3dafb6e144e471769f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -230,7 +230,7 @@ pub struct Cache {\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: HashMap<DefId, Vec<String>>,\n+    pub external_paths: HashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -249,9 +249,6 @@ pub struct Cache {\n     /// Cache of where documentation for primitives can be found.\n     pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n \n-    /// Set of definitions which have been inlined from external crates.\n-    pub inlined: HashSet<DefId>,\n-\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n@@ -505,20 +502,20 @@ pub fn run(mut krate: clean::Crate,\n \n     // Crawl the crate to build various caches used for the output\n     let RenderInfo {\n-        inlined,\n+        inlined: _,\n         external_paths,\n         external_typarams,\n         deref_trait_did,\n     } = renderinfo;\n \n-    let paths = external_paths.into_iter()\n-                              .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n-                              .collect::<HashMap<_, _>>();\n+    let external_paths = external_paths.into_iter()\n+        .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+        .collect();\n \n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone())).collect(),\n-        paths: paths,\n+        external_paths: external_paths,\n+        paths: HashMap::new(),\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n         parent_stack: Vec::new(),\n@@ -534,15 +531,14 @@ pub fn run(mut krate: clean::Crate,\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n         deref_trait_did: deref_trait_did,\n         typarams: external_typarams,\n-        inlined: inlined,\n     };\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n         let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-        cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n     // Cache where all known primitives have their documentation located.\n@@ -753,7 +749,10 @@ fn write_shared(cx: &Context,\n         //        theory it should be...\n         let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => continue,\n+            None => match cache.external_paths.get(&did) {\n+                Some(p) => p,\n+                None => continue,\n+            }\n         };\n \n         let mut mydst = dst.clone();\n@@ -1055,12 +1054,11 @@ impl DocFolder for Cache {\n                         let last = self.parent_stack.last().unwrap();\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n-                            Some(&(_, ItemType::Trait)) =>\n-                                Some(&self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n                             // information if present.\n+                            Some(&(ref fqp, ItemType::Trait)) |\n                             Some(&(ref fqp, ItemType::Struct)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(&fqp[..fqp.len() - 1]),\n@@ -1092,12 +1090,10 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.stripped_mod)=> {\n-                    if parent.is_local() {\n-                        // We have a parent, but we don't know where they're\n-                        // defined yet. Wait for later to index this item.\n-                        self.orphan_methods.push((parent, item.clone()))\n-                    }\n+                (Some(parent), None) if is_method => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_methods.push((parent, item.clone()));\n                 }\n                 _ => {}\n             }\n@@ -1127,7 +1123,6 @@ impl DocFolder for Cache {\n                 // not a public item.\n                 if\n                     !self.paths.contains_key(&item.def_id) ||\n-                    !item.def_id.is_local() ||\n                     self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n@@ -1521,7 +1516,7 @@ impl<'a> Item<'a> {\n         } else {\n             let cache = cache();\n             let external_path = match cache.external_paths.get(&self.item.def_id) {\n-                Some(path) => path,\n+                Some(&(ref path, _)) => path,\n                 None => return None,\n             };\n             let mut path = match cache.extern_locations.get(&self.item.def_id.krate) {\n@@ -2106,7 +2101,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            path = if it.def_id.is_local() {\n                cx.current.join(\"/\")\n            } else {\n-               let path = &cache.external_paths[&it.def_id];\n+               let (ref path, _) = cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n            ty = shortty(it).to_static_str(),"}, {"sha": "d0c4f126550ca177356b4032497309372d3cb436", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -34,6 +34,7 @@ extern crate getopts;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_const_eval;\n+extern crate rustc_const_math;\n extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;"}, {"sha": "bb69ba6e568d573d7618602ad2f7d29ee5c52733", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -37,7 +37,6 @@ use rustc_resolve::MakeGlobMap;\n use syntax::codemap::CodeMap;\n use errors;\n use errors::emitter::ColorConfig;\n-use syntax::parse::token;\n \n use core;\n use clean;\n@@ -82,7 +81,7 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts,\n                                        &dep_graph,\n                                        Some(input_path.clone()),\n@@ -239,7 +238,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = session::build_session_(sessopts,\n                                        &dep_graph,\n                                        None,"}, {"sha": "1459420cdc00ce0b4f446ee5169ba36808f27070", "filename": "src/libstd/error.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -66,10 +66,80 @@ pub trait Error: Debug + Display + Reflect {\n     /// The description should not contain newlines or sentence-ending\n     /// punctuation, to facilitate embedding in larger user-facing\n     /// strings.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::error::Error;\n+    ///\n+    /// match \"xc\".parse::<u32>() {\n+    ///     Err(e) => {\n+    ///         println!(\"Error: {}\", e.description());\n+    ///     }\n+    ///     _ => println!(\"No error\"),\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn description(&self) -> &str;\n \n     /// The lower-level cause of this error, if any.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::error::Error;\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct SuperError {\n+    ///     side: SuperErrorSideKick,\n+    /// }\n+    ///\n+    /// impl fmt::Display for SuperError {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"SuperError is here!\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperError {\n+    ///     fn description(&self) -> &str {\n+    ///         \"I'm the superhero of errors!\"\n+    ///     }\n+    ///\n+    ///     fn cause(&self) -> Option<&Error> {\n+    ///         Some(&self.side)\n+    ///     }\n+    /// }\n+    ///\n+    /// #[derive(Debug)]\n+    /// struct SuperErrorSideKick;\n+    ///\n+    /// impl fmt::Display for SuperErrorSideKick {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"SuperErrorSideKick is here!\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Error for SuperErrorSideKick {\n+    ///     fn description(&self) -> &str {\n+    ///         \"I'm SuperError side kick!\"\n+    ///     }\n+    /// }\n+    ///\n+    /// fn get_super_error() -> Result<(), SuperError> {\n+    ///     Err(SuperError { side: SuperErrorSideKick })\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     match get_super_error() {\n+    ///         Err(e) => {\n+    ///             println!(\"Error: {}\", e.description());\n+    ///             println!(\"Caused by: {}\", e.cause().unwrap());\n+    ///         }\n+    ///         _ => println!(\"No error\"),\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cause(&self) -> Option<&Error> { None }\n "}, {"sha": "83439b3f132153eef1009c507e2bec78318aa408", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -141,7 +141,7 @@ pub struct Permissions(fs_imp::FilePermissions);\n \n /// An structure representing a type of file with accessors for each file type.\n #[stable(feature = \"file_type\", since = \"1.1.0\")]\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FileType(fs_imp::FileType);\n \n /// A builder used to create directories in various manners."}, {"sha": "c8b52fc046769b9ca59986a6ec5e621dee8b9d6b", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -152,8 +152,8 @@ pub struct Sink { _priv: () }\n /// ```rust\n /// use std::io::{self, Write};\n ///\n-/// let mut buffer = vec![1, 2, 3, 5, 8];\n-/// let num_bytes = io::sink().write(&mut buffer).unwrap();\n+/// let buffer = vec![1, 2, 3, 5, 8];\n+/// let num_bytes = io::sink().write(&buffer).unwrap();\n /// assert_eq!(num_bytes, 5);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d05a5a0961483f81202dcc14223d20f109223657", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -468,15 +468,3 @@ pub mod __rand {\n // the rustdoc documentation for primitive types. Using `include!`\n // because rustdoc only looks for these modules at the crate level.\n include!(\"primitive_docs.rs\");\n-\n-// FIXME(stage0): remove this after a snapshot\n-// HACK: this is needed because the interpretation of slice\n-// patterns changed between stage0 and now.\n-#[cfg(stage0)]\n-fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'a &'b [T] {\n-    t\n-}\n-#[cfg(not(stage0))]\n-fn slice_pat<'a, 'b, T>(t: &'a &'b [T]) -> &'b [T] {\n-    *t\n-}"}, {"sha": "6f0f6ecab5ba8271c479a9d674b1dee8b76ae70c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -98,7 +98,9 @@ macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard output, with a newline.\n+/// Macro for printing to the standard output, with a newline. On all\n+/// platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n+/// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n /// Use the `format!` syntax to write data to the standard output.\n /// See `std::fmt` for more information."}, {"sha": "67410e87a8bea898050978c9eb5f0a898e40d942", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -83,6 +83,10 @@ impl Ipv4Addr {\n     }\n \n     /// Returns true for the special 'unspecified' address (0.0.0.0).\n+    ///\n+    /// This property is defined in _UNIX Network Programming, Second Edition_,\n+    /// W. Richard Stevens, p. 891; see also [ip7]\n+    /// [ip7][http://man7.org/linux/man-pages/man7/ip.7.html]\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n     }"}, {"sha": "ba18d15f5c4e384a8be0eeb0c0d83f7442d5ba01", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -227,6 +227,11 @@ impl<T: ?Sized> !RefUnwindSafe for UnsafeCell<T> {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> RefUnwindSafe for AssertUnwindSafe<T> {}\n \n+#[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n+impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n+#[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n+impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n+\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T> Deref for AssertUnwindSafe<T> {\n     type Target = T;"}, {"sha": "de891ea89189a26e40fbe9745f8d6e62c60e71ff", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -506,6 +506,9 @@ mod prim_f64 { }\n ///\n /// *[See also the `std::i8` module](i8/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i64` in there.\n+///\n mod prim_i8 { }\n \n #[doc(primitive = \"i16\")]\n@@ -514,6 +517,9 @@ mod prim_i8 { }\n ///\n /// *[See also the `std::i16` module](i16/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i32` in there.\n+///\n mod prim_i16 { }\n \n #[doc(primitive = \"i32\")]\n@@ -522,6 +528,9 @@ mod prim_i16 { }\n ///\n /// *[See also the `std::i32` module](i32/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i16` in there.\n+///\n mod prim_i32 { }\n \n #[doc(primitive = \"i64\")]\n@@ -530,6 +539,9 @@ mod prim_i32 { }\n ///\n /// *[See also the `std::i64` module](i64/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i8` in there.\n+///\n mod prim_i64 { }\n \n #[doc(primitive = \"u8\")]\n@@ -538,6 +550,9 @@ mod prim_i64 { }\n ///\n /// *[See also the `std::u8` module](u8/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u64` in there.\n+///\n mod prim_u8 { }\n \n #[doc(primitive = \"u16\")]\n@@ -546,6 +561,9 @@ mod prim_u8 { }\n ///\n /// *[See also the `std::u16` module](u16/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u32` in there.\n+///\n mod prim_u16 { }\n \n #[doc(primitive = \"u32\")]\n@@ -554,6 +572,9 @@ mod prim_u16 { }\n ///\n /// *[See also the `std::u32` module](u32/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u16` in there.\n+///\n mod prim_u32 { }\n \n #[doc(primitive = \"u64\")]\n@@ -562,6 +583,9 @@ mod prim_u32 { }\n ///\n /// *[See also the `std::u64` module](u64/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u8` in there.\n+///\n mod prim_u64 { }\n \n #[doc(primitive = \"isize\")]\n@@ -570,6 +594,9 @@ mod prim_u64 { }\n ///\n /// *[See also the `std::isize` module](isize/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `usize` in there.\n+///\n mod prim_isize { }\n \n #[doc(primitive = \"usize\")]\n@@ -578,4 +605,7 @@ mod prim_isize { }\n ///\n /// *[See also the `std::usize` module](usize/index.html).*\n ///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `isize` in there.\n+///\n mod prim_usize { }"}, {"sha": "660c098d30bc29d157bfb8888ae6e145482aa152", "filename": "src/libstd/process.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -27,8 +27,9 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n /// Representation of a running or exited child process.\n ///\n /// This structure is used to represent and manage child processes. A child\n-/// process is created via the `Command` struct, which configures the spawning\n-/// process and can itself be constructed using a builder-style interface.\n+/// process is created via the [`Command`] struct, which configures the\n+/// spawning process and can itself be constructed using a builder-style\n+/// interface.\n ///\n /// # Examples\n ///\n@@ -48,13 +49,18 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n ///\n /// # Note\n ///\n-/// Take note that there is no implementation of\n-/// [`Drop`](../../core/ops/trait.Drop.html) for child processes, so if you\n-/// do not ensure the `Child` has exited then it will continue to run, even\n-/// after the `Child` handle to the child process has gone out of scope.\n+/// Take note that there is no implementation of [`Drop`] for child processes,\n+/// so if you do not ensure the `Child` has exited then it will continue to\n+/// run, even after the `Child` handle to the child process has gone out of\n+/// scope.\n ///\n-/// Calling `wait` (or other functions that wrap around it) will make the\n-/// parent process wait until the child has actually exited before continuing.\n+/// Calling [`wait`][`wait`] (or other functions that wrap around it) will make\n+/// the parent process wait until the child has actually exited before\n+/// continuing.\n+///\n+/// [`Command`]: struct.Command.html\n+/// [`Drop`]: ../../core/ops/trait.Drop.html\n+/// [`wait`]: #method.wait\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct Child {\n     handle: imp::Process,\n@@ -91,7 +97,11 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n-/// A handle to a child process's stdin\n+/// A handle to a child process's stdin. This struct is used in the [`stdin`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stdin`]: struct.Child.html#structfield.stdin\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe\n@@ -122,7 +132,11 @@ impl FromInner<AnonPipe> for ChildStdin {\n     }\n }\n \n-/// A handle to a child process's stdout\n+/// A handle to a child process's stdout. This struct is used in the [`stdout`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stdout`]: struct.Child.html#structfield.stdout\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe\n@@ -152,7 +166,11 @@ impl FromInner<AnonPipe> for ChildStdout {\n     }\n }\n \n-/// A handle to a child process's stderr\n+/// A handle to a child process's stderr. This struct is used in the [`stderr`]\n+/// field on [`Child`].\n+///\n+/// [`Child`]: struct.Child.html\n+/// [`stderr`]: struct.Child.html#structfield.stderr\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe\n@@ -587,6 +605,23 @@ pub struct ExitStatus(imp::ExitStatus);\n impl ExitStatus {\n     /// Was termination successful? Signal termination not considered a success,\n     /// and success is defined as a zero exit status.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"mkdir\")\n+    ///                      .arg(\"projects\")\n+    ///                      .status()\n+    ///                      .expect(\"failed to execute mkdir\");\n+    ///\n+    /// if status.success() {\n+    ///     println!(\"'projects/' directory created\");\n+    /// } else {\n+    ///     println!(\"failed to create 'projects/' directory\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn success(&self) -> bool {\n         self.0.success()"}, {"sha": "3c52ebc72f2cb279f187dbfdd1a1c15af580eebe", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 72, "deletions": 296, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -15,7 +15,7 @@ use sync::{mutex, MutexGuard, PoisonError};\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use sys_common::poison::{self, LockResult};\n-use time::{Instant, Duration};\n+use time::Duration;\n \n /// A type indicating whether a timed wait on a condition variable returned\n /// due to a time out or not.\n@@ -72,59 +72,19 @@ impl WaitTimeoutResult {\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub struct Condvar { inner: Box<StaticCondvar> }\n-\n-/// Statically allocated condition variables.\n-///\n-/// This structure is identical to `Condvar` except that it is suitable for use\n-/// in static initializers for other structures.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_condvar)]\n-///\n-/// use std::sync::{StaticCondvar, CONDVAR_INIT};\n-///\n-/// static CVAR: StaticCondvar = CONDVAR_INIT;\n-/// ```\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticCondvar {\n-    inner: sys::Condvar,\n+pub struct Condvar {\n+    inner: Box<sys::Condvar>,\n     mutex: AtomicUsize,\n }\n \n-/// Constant initializer for a statically allocated condition variable.\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const CONDVAR_INIT: StaticCondvar = StaticCondvar::new();\n-\n-#[allow(deprecated)]\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         Condvar {\n-            inner: box StaticCondvar {\n-                inner: sys::Condvar::new(),\n-                mutex: AtomicUsize::new(0),\n-            }\n+            inner: box sys::Condvar::new(),\n+            mutex: AtomicUsize::new(0),\n         }\n     }\n \n@@ -157,9 +117,16 @@ impl Condvar {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait(guard)\n+        let poisoned = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            self.inner.wait(lock);\n+            mutex::guard_poison(&guard).get()\n+        };\n+        if poisoned {\n+            Err(PoisonError::new(guard))\n+        } else {\n+            Ok(guard)\n         }\n     }\n \n@@ -206,9 +173,16 @@ impl Condvar {\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n                                -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n-        unsafe {\n-            let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(guard, dur)\n+        let (poisoned, result) = unsafe {\n+            let lock = mutex::guard_lock(&guard);\n+            self.verify(lock);\n+            let success = self.inner.wait_timeout(lock, dur);\n+            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n+        };\n+        if poisoned {\n+            Err(PoisonError::new((guard, result)))\n+        } else {\n+            Ok((guard, result))\n         }\n     }\n \n@@ -220,7 +194,9 @@ impl Condvar {\n     ///\n     /// To wake up all threads, see `notify_all()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn notify_one(&self) { unsafe { self.inner.inner.notify_one() } }\n+    pub fn notify_one(&self) {\n+        unsafe { self.inner.notify_one() }\n+    }\n \n     /// Wakes up all blocked threads on this condvar.\n     ///\n@@ -230,169 +206,8 @@ impl Condvar {\n     ///\n     /// To wake up only one thread, see `notify_one()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn notify_all(&self) { unsafe { self.inner.inner.notify_all() } }\n-}\n-\n-#[stable(feature = \"condvar_default\", since = \"1.9.0\")]\n-impl Default for Condvar {\n-    fn default() -> Condvar {\n-        Condvar::new()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl Drop for Condvar {\n-    fn drop(&mut self) {\n-        unsafe { self.inner.inner.destroy() }\n-    }\n-}\n-\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Condvar::new` in a static should \\\n-                             suffice\")]\n-#[unstable(feature = \"static_condvar\",\n-           reason = \"may be merged with Condvar in the future\",\n-           issue = \"27717\")]\n-#[allow(deprecated)]\n-impl StaticCondvar {\n-    /// Creates a new condition variable\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub const fn new() -> StaticCondvar {\n-        StaticCondvar {\n-            inner: sys::Condvar::new(),\n-            mutex: AtomicUsize::new(0),\n-        }\n-    }\n-\n-    /// Blocks the current thread until this condition variable receives a\n-    /// notification.\n-    ///\n-    /// See `Condvar::wait`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n-                       -> LockResult<MutexGuard<'a, T>> {\n-        let poisoned = unsafe {\n-            let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n-            self.inner.wait(lock);\n-            mutex::guard_poison(&guard).get()\n-        };\n-        if poisoned {\n-            Err(PoisonError::new(guard))\n-        } else {\n-            Ok(guard)\n-        }\n-    }\n-\n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait_timeout<'a, T>(&'static self,\n-                               guard: MutexGuard<'a, T>,\n-                               timeout: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n-        let (poisoned, result) = unsafe {\n-            let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, timeout);\n-            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n-        };\n-        if poisoned {\n-            Err(PoisonError::new((guard, result)))\n-        } else {\n-            Ok((guard, result))\n-        }\n-    }\n-\n-    /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.\n-    ///\n-    /// The implementation will repeatedly wait while the duration has not\n-    /// passed and the function returns `false`.\n-    ///\n-    /// See `Condvar::wait_timeout_with`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn wait_timeout_with<'a, T, F>(&'static self,\n-                                       guard: MutexGuard<'a, T>,\n-                                       dur: Duration,\n-                                       mut f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n-            where F: FnMut(LockResult<&mut T>) -> bool {\n-        // This could be made more efficient by pushing the implementation into\n-        // sys::condvar\n-        let start = Instant::now();\n-        let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n-        while !f(guard_result\n-                    .as_mut()\n-                    .map(|g| &mut **g)\n-                    .map_err(|e| PoisonError::new(&mut **e.get_mut()))) {\n-            let consumed = start.elapsed();\n-            let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, timed_out) = if consumed > dur {\n-                (Ok(guard), WaitTimeoutResult(true))\n-            } else {\n-                match self.wait_timeout(guard, dur - consumed) {\n-                    Ok((new_guard, timed_out)) => (Ok(new_guard), timed_out),\n-                    Err(err) => {\n-                        let (new_guard, no_timeout) = err.into_inner();\n-                        (Err(PoisonError::new(new_guard)), no_timeout)\n-                    }\n-                }\n-            };\n-            guard_result = new_guard_result;\n-            if timed_out.timed_out() {\n-                let result = f(guard_result\n-                                    .as_mut()\n-                                    .map(|g| &mut **g)\n-                                    .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n-                let result = WaitTimeoutResult(!result);\n-                return poison::map_result(guard_result, |g| (g, result));\n-            }\n-        }\n-\n-        poison::map_result(guard_result, |g| (g, WaitTimeoutResult(false)))\n-    }\n-\n-    /// Wakes up one blocked thread on this condvar.\n-    ///\n-    /// See `Condvar::notify_one`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n-\n-    /// Wakes up all blocked threads on this condvar.\n-    ///\n-    /// See `Condvar::notify_all`.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n-\n-    /// Deallocates all resources associated with this static condvar.\n-    ///\n-    /// This method is unsafe to call as there is no guarantee that there are no\n-    /// active users of the condvar, and this also doesn't prevent any future\n-    /// users of the condvar. This method is required to be called to not leak\n-    /// memory on all platforms.\n-    #[unstable(feature = \"static_condvar\",\n-               reason = \"may be merged with Condvar in the future\",\n-               issue = \"27717\")]\n-    pub unsafe fn destroy(&'static self) {\n-        self.inner.destroy()\n+    pub fn notify_all(&self) {\n+        unsafe { self.inner.notify_all() }\n     }\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n@@ -414,15 +229,26 @@ impl StaticCondvar {\n     }\n }\n \n+#[stable(feature = \"condvar_default\", since = \"1.9.0\")]\n+impl Default for Condvar {\n+    fn default() -> Condvar {\n+        Condvar::new()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Drop for Condvar {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.destroy() }\n+    }\n+}\n+\n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n \n-    use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, Condvar, Mutex, Arc};\n-    use sync::atomic::{AtomicUsize, Ordering};\n+    use sync::{Condvar, Mutex, Arc};\n     use thread;\n     use time::Duration;\n     use u32;\n@@ -434,27 +260,20 @@ mod tests {\n         c.notify_all();\n     }\n \n-    #[test]\n-    fn static_smoke() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        C.notify_one();\n-        C.notify_all();\n-        unsafe { C.destroy(); }\n-    }\n-\n     #[test]\n     fn notify_one() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let g = M.lock().unwrap();\n+        let g = m.lock().unwrap();\n         let _t = thread::spawn(move|| {\n-            let _g = M.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        let g = C.wait(g).unwrap();\n+        let g = c.wait(g).unwrap();\n         drop(g);\n-        unsafe { C.destroy(); M.destroy(); }\n     }\n \n     #[test]\n@@ -495,84 +314,41 @@ mod tests {\n \n     #[test]\n     fn wait_timeout_ms() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let g = M.lock().unwrap();\n-        let (g, _no_timeout) = C.wait_timeout(g, Duration::from_millis(1)).unwrap();\n+        let g = m.lock().unwrap();\n+        let (g, _no_timeout) = c.wait_timeout(g, Duration::from_millis(1)).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n         let _t = thread::spawn(move || {\n-            let _g = M.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        let (g, timeout_res) = C.wait_timeout(g, Duration::from_millis(u32::MAX as u64)).unwrap();\n+        let (g, timeout_res) = c.wait_timeout(g, Duration::from_millis(u32::MAX as u64)).unwrap();\n         assert!(!timeout_res.timed_out());\n         drop(g);\n-        unsafe { C.destroy(); M.destroy(); }\n-    }\n-\n-    #[test]\n-    fn wait_timeout_with() {\n-        static C: StaticCondvar = StaticCondvar::new();\n-        static M: StaticMutex = StaticMutex::new();\n-        static S: AtomicUsize = AtomicUsize::new(0);\n-\n-        let g = M.lock().unwrap();\n-        let (g, timed_out) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n-            false\n-        }).unwrap();\n-        assert!(timed_out.timed_out());\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move || {\n-            rx.recv().unwrap();\n-            let g = M.lock().unwrap();\n-            S.store(1, Ordering::SeqCst);\n-            C.notify_one();\n-            drop(g);\n-\n-            rx.recv().unwrap();\n-            let g = M.lock().unwrap();\n-            S.store(2, Ordering::SeqCst);\n-            C.notify_one();\n-            drop(g);\n-\n-            rx.recv().unwrap();\n-            let _g = M.lock().unwrap();\n-            S.store(3, Ordering::SeqCst);\n-            C.notify_one();\n-        });\n-\n-        let mut state = 0;\n-        let day = 24 * 60 * 60;\n-        let (_g, timed_out) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n-            assert_eq!(state, S.load(Ordering::SeqCst));\n-            tx.send(()).unwrap();\n-            state += 1;\n-            match state {\n-                1|2 => false,\n-                _ => true,\n-            }\n-        }).unwrap();\n-        assert!(!timed_out.timed_out());\n     }\n \n     #[test]\n     #[should_panic]\n     fn two_mutexes() {\n-        static M1: StaticMutex = StaticMutex::new();\n-        static M2: StaticMutex = StaticMutex::new();\n-        static C: StaticCondvar = StaticCondvar::new();\n+        let m = Arc::new(Mutex::new(()));\n+        let m2 = m.clone();\n+        let c = Arc::new(Condvar::new());\n+        let c2 = c.clone();\n \n-        let mut g = M1.lock().unwrap();\n+        let mut g = m.lock().unwrap();\n         let _t = thread::spawn(move|| {\n-            let _g = M1.lock().unwrap();\n-            C.notify_one();\n+            let _g = m2.lock().unwrap();\n+            c2.notify_one();\n         });\n-        g = C.wait(g).unwrap();\n+        g = c.wait(g).unwrap();\n         drop(g);\n \n-        let _ = C.wait(M2.lock().unwrap()).unwrap();\n+        let m = Mutex::new(());\n+        let _ = c.wait(m.lock().unwrap()).unwrap();\n     }\n }"}, {"sha": "289b47b34847fbd16a08ae080683e5f605e836a7", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -25,23 +25,15 @@ pub use core::sync::atomic;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::barrier::{Barrier, BarrierWaitResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::condvar::{Condvar, StaticCondvar, WaitTimeoutResult, CONDVAR_INIT};\n+pub use self::condvar::{Condvar, WaitTimeoutResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::mutex::MUTEX_INIT;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n+pub use self::mutex::{Mutex, MutexGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n+pub use self::rwlock::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n \n pub mod mpsc;\n "}, {"sha": "d96fd6228e62ebe57a1388159b8431699bfa1edc", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -2180,6 +2180,15 @@ mod sync_tests {\n         assert!(rx.recv().is_err());\n     }\n \n+    #[test]\n+    fn oneshot_single_thread_try_recv_closed_with_data() {\n+        let (tx, rx) = sync_channel::<i32>(1);\n+        tx.send(10).unwrap();\n+        drop(tx);\n+        assert_eq!(rx.try_recv(), Ok(10));\n+        assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n+    }\n+\n     #[test]\n     fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<i32>(1);"}, {"sha": "9d13a71ff95ee29098873374f2e50ec7a9274a38", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -309,7 +309,7 @@ impl<T> Packet<T> {\n         let mut guard = self.lock.lock().unwrap();\n \n         // Easy cases first\n-        if guard.disconnected { return Err(Disconnected) }\n+        if guard.disconnected && guard.buf.size() == 0 { return Err(Disconnected) }\n         if guard.buf.size() == 0 { return Err(Empty) }\n \n         // Be sure to wake up neighbors"}, {"sha": "6bc458397f1632282a8946cff69c45d1214e31de", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 46, "deletions": 173, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -113,14 +113,14 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct Mutex<T: ?Sized> {\n-    // Note that this static mutex is in a *box*, not inlined into the struct\n-    // itself. Once a native mutex has been used once, its address can never\n-    // change (it can't be moved). This mutex type can be safely moved at any\n-    // time, so to ensure that the native mutex is used correctly we box the\n-    // inner lock to give it a constant address.\n-    inner: Box<StaticMutex>,\n+    // Note that this mutex is in a *box*, not inlined into the struct itself.\n+    // Once a native mutex has been used once, its address can never change (it\n+    // can't be moved). This mutex type can be safely moved at any time, so to\n+    // ensure that the native mutex is used correctly we box the inner lock to\n+    // give it a constant address.\n+    inner: Box<sys::Mutex>,\n+    poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n \n@@ -131,91 +131,39 @@ unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n \n-/// The static mutex type is provided to allow for static allocation of mutexes.\n-///\n-/// Note that this is a separate type because using a Mutex correctly means that\n-/// it needs to have a destructor run. In Rust, statics are not allowed to have\n-/// destructors. As a result, a `StaticMutex` has one extra method when compared\n-/// to a `Mutex`, a `destroy` method. This method is unsafe to call, and\n-/// documentation can be found directly on the method.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_mutex)]\n-///\n-/// use std::sync::{StaticMutex, MUTEX_INIT};\n-///\n-/// static LOCK: StaticMutex = MUTEX_INIT;\n-///\n-/// {\n-///     let _g = LOCK.lock().unwrap();\n-///     // do some productive work\n-/// }\n-/// // lock is unlocked here.\n-/// ```\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticMutex {\n-    lock: sys::Mutex,\n-    poison: poison::Flag,\n-}\n-\n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n ///\n /// The data protected by the mutex can be access through this guard via its\n /// `Deref` and `DerefMut` implementations\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n-    __lock: &'a StaticMutex,\n-    __data: &'a mut T,\n+    __lock: &'a Mutex<T>,\n     __poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n-/// Static initialization of a mutex. This constant can be used to initialize\n-/// other mutex constants.\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const MUTEX_INIT: StaticMutex = StaticMutex::new();\n-\n-#[allow(deprecated)]\n impl<T> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n         let mut m = Mutex {\n-            inner: box StaticMutex::new(),\n+            inner: box sys::Mutex::new(),\n+            poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n         };\n         unsafe {\n-            m.inner.lock.init();\n+            m.inner.init();\n         }\n         m\n     }\n }\n \n-#[allow(deprecated)]\n impl<T: ?Sized> Mutex<T> {\n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n@@ -240,8 +188,8 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n         unsafe {\n-            self.inner.lock.lock();\n-            MutexGuard::new(&*self.inner, &self.data)\n+            self.inner.lock();\n+            MutexGuard::new(self)\n         }\n     }\n \n@@ -261,8 +209,8 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_lock() {\n-                Ok(MutexGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_lock() {\n+                Ok(MutexGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -277,7 +225,7 @@ impl<T: ?Sized> Mutex<T> {\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n-        self.inner.poison.get()\n+        self.poison.get()\n     }\n \n     /// Consumes this mutex, returning the underlying data.\n@@ -289,21 +237,22 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner StaticMutex.\n+        // `self` so there's no need to lock the inner lock.\n         //\n         // To get the inner value, we'd like to call `data.into_inner()`,\n         // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n         // we'll have to destructure it manually instead.\n         unsafe {\n-            // Like `let Mutex { inner, data } = self`.\n-            let (inner, data) = {\n-                let Mutex { ref inner, ref data } = self;\n-                (ptr::read(inner), ptr::read(data))\n+            // Like `let Mutex { inner, poison, data } = self`.\n+            let (inner, poison, data) = {\n+                let Mutex { ref inner, ref poison, ref data } = self;\n+                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            drop(inner);\n \n-            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+            poison::map_result(poison.borrow(), |_| data.into_inner())\n         }\n     }\n \n@@ -319,14 +268,13 @@ impl<T: ?Sized> Mutex<T> {\n     #[stable(feature = \"mutex_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner StaticMutex.\n+        // there's no need to lock the inner lock.\n         let data = unsafe { &mut *self.data.get() };\n-        poison::map_result(self.inner.poison.borrow(), |_| data )\n+        poison::map_result(self.poison.borrow(), |_| data )\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<T: ?Sized> Drop for Mutex<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -335,7 +283,7 @@ impl<T: ?Sized> Drop for Mutex<T> {\n         // dropped, that's not our job)\n         //\n         // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n-        unsafe { self.inner.lock.destroy() }\n+        unsafe { self.inner.destroy() }\n     }\n }\n \n@@ -359,72 +307,11 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Mutex<T> {\n     }\n }\n \n-struct Dummy(UnsafeCell<()>);\n-unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n-\n-#[unstable(feature = \"static_mutex\",\n-           reason = \"may be merged with Mutex in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `Mutex::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-impl StaticMutex {\n-    /// Creates a new mutex in an unlocked state ready for use.\n-    pub const fn new() -> StaticMutex {\n-        StaticMutex {\n-            lock: sys::Mutex::new(),\n-            poison: poison::Flag::new(),\n-        }\n-    }\n-\n-    /// Acquires this lock, see `Mutex::lock`\n-    #[inline]\n-    pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n-        unsafe {\n-            self.lock.lock();\n-            MutexGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to grab this lock, see `Mutex::try_lock`\n-    #[inline]\n-    pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n-        unsafe {\n-            if self.lock.try_lock() {\n-                Ok(MutexGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Deallocates resources associated with this static mutex.\n-    ///\n-    /// This method is unsafe because it provides no guarantees that there are\n-    /// no active users of this mutex, and safety is not guaranteed if there are\n-    /// active users of this mutex.\n-    ///\n-    /// This method is required to ensure that there are no memory leaks on\n-    /// *all* platforms. It may be the case that some platforms do not leak\n-    /// memory if this method is not called, but this is not guaranteed to be\n-    /// true on all platforms.\n-    pub unsafe fn destroy(&'static self) {\n-        self.lock.destroy()\n-    }\n-}\n-\n-#[allow(deprecated)]\n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n-    unsafe fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n-           -> LockResult<MutexGuard<'mutex, T>> {\n+    unsafe fn new(lock: &'mutex Mutex<T>) -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             MutexGuard {\n                 __lock: lock,\n-                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -435,43 +322,43 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T {self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n-    fn deref_mut(&mut self) -> &mut T { self.__data }\n+    fn deref_mut(&mut self) -> &mut T {\n+        unsafe { &mut *self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n             self.__lock.poison.done(&self.__poison);\n-            self.__lock.lock.unlock();\n+            self.__lock.inner.unlock();\n         }\n     }\n }\n \n-#[allow(deprecated)]\n pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n-    &guard.__lock.lock\n+    &guard.__lock.inner\n }\n \n-#[allow(deprecated)]\n pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n     &guard.__lock.poison\n }\n \n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::{Arc, Mutex, Condvar};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -490,48 +377,34 @@ mod tests {\n         drop(m.lock().unwrap());\n     }\n \n-    #[test]\n-    fn smoke_static() {\n-        static M: StaticMutex = StaticMutex::new();\n-        unsafe {\n-            drop(M.lock().unwrap());\n-            drop(M.lock().unwrap());\n-            M.destroy();\n-        }\n-    }\n-\n     #[test]\n     fn lots_and_lots() {\n-        static M: StaticMutex = StaticMutex::new();\n-        static mut CNT: u32 = 0;\n         const J: u32 = 1000;\n         const K: u32 = 3;\n \n-        fn inc() {\n+        let m = Arc::new(Mutex::new(0));\n+\n+        fn inc(m: &Mutex<u32>) {\n             for _ in 0..J {\n-                unsafe {\n-                    let _g = M.lock().unwrap();\n-                    CNT += 1;\n-                }\n+                *m.lock().unwrap() += 1;\n             }\n         }\n \n         let (tx, rx) = channel();\n         for _ in 0..K {\n             let tx2 = tx.clone();\n-            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            let m2 = m.clone();\n+            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n             let tx2 = tx.clone();\n-            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            let m2 = m.clone();\n+            thread::spawn(move|| { inc(&m2); tx2.send(()).unwrap(); });\n         }\n \n         drop(tx);\n         for _ in 0..2 * K {\n             rx.recv().unwrap();\n         }\n-        assert_eq!(unsafe {CNT}, J * K * 2);\n-        unsafe {\n-            M.destroy();\n-        }\n+        assert_eq!(*m.lock().unwrap(), J * K * 2);\n     }\n \n     #[test]"}, {"sha": "54c1fe6c5640cebcb7312d0ad67fe8233c316b92", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -65,6 +65,7 @@\n // it!\n \n use marker;\n+use ptr;\n use sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n use thread::{self, Thread};\n \n@@ -297,7 +298,7 @@ impl Once {\n                     let mut node = Waiter {\n                         thread: Some(thread::current()),\n                         signaled: AtomicBool::new(false),\n-                        next: 0 as *mut Waiter,\n+                        next: ptr::null_mut(),\n                     };\n                     let me = &mut node as *mut Waiter as usize;\n                     assert!(me & STATE_MASK == 0);"}, {"sha": "65b5686de869ca7fb05f9369a3435753612d5a35", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 49, "deletions": 200, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -66,9 +66,9 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLock<T: ?Sized> {\n-    inner: Box<StaticRwLock>,\n+    inner: Box<sys::RWLock>,\n+    poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n \n@@ -77,64 +77,12 @@ unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n-/// Structure representing a statically allocated RwLock.\n-///\n-/// This structure is intended to be used inside of a `static` and will provide\n-/// automatic global access as well as lazy initialization. The internal\n-/// resources of this RwLock, however, must be manually deallocated.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(static_rwlock)]\n-///\n-/// use std::sync::{StaticRwLock, RW_LOCK_INIT};\n-///\n-/// static LOCK: StaticRwLock = RW_LOCK_INIT;\n-///\n-/// {\n-///     let _g = LOCK.read().unwrap();\n-///     // ... shared read access\n-/// }\n-/// {\n-///     let _g = LOCK.write().unwrap();\n-///     // ... exclusive write access\n-/// }\n-/// unsafe { LOCK.destroy() } // free all resources\n-/// ```\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-pub struct StaticRwLock {\n-    lock: sys::RWLock,\n-    poison: poison::Flag,\n-}\n-\n-/// Constant initialization for a statically-initialized rwlock.\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n-\n /// RAII structure used to release the shared read access of a lock when\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a T,\n+    __lock: &'a RwLock<T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,17 +92,14 @@ impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a mut T,\n+    __lock: &'a RwLock<T>,\n     __poison: poison::Guard,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n-#[allow(deprecated)]\n impl<T> RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n     ///\n@@ -167,11 +112,14 @@ impl<T> RwLock<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> RwLock<T> {\n-        RwLock { inner: box StaticRwLock::new(), data: UnsafeCell::new(t) }\n+        RwLock {\n+            inner: box sys::RWLock::new(),\n+            poison: poison::Flag::new(),\n+            data: UnsafeCell::new(t),\n+        }\n     }\n }\n \n-#[allow(deprecated)]\n impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n@@ -194,8 +142,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n         unsafe {\n-            self.inner.lock.read();\n-            RwLockReadGuard::new(&*self.inner, &self.data)\n+            self.inner.read();\n+            RwLockReadGuard::new(self)\n         }\n     }\n \n@@ -220,8 +168,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_read() {\n-                Ok(RwLockReadGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_read() {\n+                Ok(RwLockReadGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -246,8 +194,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n         unsafe {\n-            self.inner.lock.write();\n-            RwLockWriteGuard::new(&*self.inner, &self.data)\n+            self.inner.write();\n+            RwLockWriteGuard::new(self)\n         }\n     }\n \n@@ -272,8 +220,8 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n         unsafe {\n-            if self.inner.lock.try_write() {\n-                Ok(RwLockWriteGuard::new(&*self.inner, &self.data)?)\n+            if self.inner.try_write() {\n+                Ok(RwLockWriteGuard::new(self)?)\n             } else {\n                 Err(TryLockError::WouldBlock)\n             }\n@@ -288,7 +236,7 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n-        self.inner.poison.get()\n+        self.poison.get()\n     }\n \n     /// Consumes this `RwLock`, returning the underlying data.\n@@ -302,21 +250,22 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n-        // `self` so there's no need to lock the inner StaticRwLock.\n+        // `self` so there's no need to lock the inner lock.\n         //\n         // To get the inner value, we'd like to call `data.into_inner()`,\n         // but because `RwLock` impl-s `Drop`, we can't move out of it, so\n         // we'll have to destructure it manually instead.\n         unsafe {\n-            // Like `let RwLock { inner, data } = self`.\n-            let (inner, data) = {\n-                let RwLock { ref inner, ref data } = self;\n-                (ptr::read(inner), ptr::read(data))\n+            // Like `let RwLock { inner, poison, data } = self`.\n+            let (inner, poison, data) = {\n+                let RwLock { ref inner, ref poison, ref data } = self;\n+                (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            drop(inner);\n \n-            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+            poison::map_result(poison.borrow(), |_| data.into_inner())\n         }\n     }\n \n@@ -334,19 +283,18 @@ impl<T: ?Sized> RwLock<T> {\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n-        // there's no need to lock the inner StaticRwLock.\n+        // there's no need to lock the inner lock.\n         let data = unsafe { &mut *self.data.get() };\n-        poison::map_result(self.inner.poison.borrow(), |_| data )\n+        poison::map_result(self.poison.borrow(), |_| data)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n impl<T: ?Sized> Drop for RwLock<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         // IMPORTANT: This code needs to be kept in sync with `RwLock::into_inner`.\n-        unsafe { self.inner.lock.destroy() }\n+        unsafe { self.inner.destroy() }\n     }\n }\n \n@@ -370,114 +318,23 @@ impl<T: Default> Default for RwLock<T> {\n     }\n }\n \n-struct Dummy(UnsafeCell<()>);\n-unsafe impl Sync for Dummy {}\n-static DUMMY: Dummy = Dummy(UnsafeCell::new(()));\n-\n-#[unstable(feature = \"static_rwlock\",\n-           reason = \"may be merged with RwLock in the future\",\n-           issue = \"27717\")]\n-#[rustc_deprecated(since = \"1.10.0\",\n-                   reason = \"the lazy-static crate suffices for static sync \\\n-                             primitives and eventually this type shouldn't \\\n-                             be necessary as `RwLock::new` in a static should \\\n-                             suffice\")]\n-#[allow(deprecated)]\n-impl StaticRwLock {\n-    /// Creates a new rwlock.\n-    pub const fn new() -> StaticRwLock {\n-        StaticRwLock {\n-            lock: sys::RWLock::new(),\n-            poison: poison::Flag::new(),\n-        }\n-    }\n-\n-    /// Locks this rwlock with shared read access, blocking the current thread\n-    /// until it can be acquired.\n-    ///\n-    /// See `RwLock::read`.\n-    #[inline]\n-    pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe {\n-            self.lock.read();\n-            RwLockReadGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to acquire this lock with shared read access.\n-    ///\n-    /// See `RwLock::try_read`.\n-    #[inline]\n-    pub fn try_read(&'static self)\n-                    -> TryLockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe {\n-            if self.lock.try_read(){\n-                Ok(RwLockReadGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Locks this rwlock with exclusive write access, blocking the current\n-    /// thread until it can be acquired.\n-    ///\n-    /// See `RwLock::write`.\n-    #[inline]\n-    pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe {\n-            self.lock.write();\n-            RwLockWriteGuard::new(self, &DUMMY.0)\n-        }\n-    }\n-\n-    /// Attempts to lock this rwlock with exclusive write access.\n-    ///\n-    /// See `RwLock::try_write`.\n-    #[inline]\n-    pub fn try_write(&'static self)\n-                     -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe {\n-            if self.lock.try_write() {\n-                Ok(RwLockWriteGuard::new(self, &DUMMY.0)?)\n-            } else {\n-                Err(TryLockError::WouldBlock)\n-            }\n-        }\n-    }\n-\n-    /// Deallocates all resources associated with this static lock.\n-    ///\n-    /// This method is unsafe to call as there is no guarantee that there are no\n-    /// active users of the lock, and this also doesn't prevent any future users\n-    /// of this lock. This method is required to be called to not leak memory on\n-    /// all platforms.\n-    pub unsafe fn destroy(&'static self) {\n-        self.lock.destroy()\n-    }\n-}\n-\n-#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n-    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n+    unsafe fn new(lock: &'rwlock RwLock<T>)\n+                  -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n                 __lock: lock,\n-                __data: &*data.get(),\n             }\n         })\n     }\n }\n \n-#[allow(deprecated)]\n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n-    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n+    unsafe fn new(lock: &'rwlock RwLock<T>)\n+                  -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             RwLockWriteGuard {\n                 __lock: lock,\n-                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n@@ -488,42 +345,43 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { self.__data }\n+    fn deref(&self) -> &T {\n+        unsafe { &*self.__lock.data.get() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n-        self.__data\n+        unsafe { &mut *self.__lock.data.get() }\n     }\n }\n \n-#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n-        unsafe { self.__lock.lock.read_unlock(); }\n+        unsafe { self.__lock.inner.read_unlock(); }\n     }\n }\n \n-#[allow(deprecated)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n-        unsafe { self.__lock.lock.write_unlock(); }\n+        unsafe { self.__lock.inner.write_unlock(); }\n     }\n }\n \n #[cfg(test)]\n-#[allow(deprecated)]\n mod tests {\n     #![allow(deprecated)] // rand\n \n@@ -532,7 +390,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::{Arc, RwLock, TryLockError};\n     use sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Eq, PartialEq, Debug)]\n@@ -547,40 +405,31 @@ mod tests {\n         drop(l.write().unwrap());\n     }\n \n-    #[test]\n-    fn static_smoke() {\n-        static R: StaticRwLock = StaticRwLock::new();\n-        drop(R.read().unwrap());\n-        drop(R.write().unwrap());\n-        drop((R.read().unwrap(), R.read().unwrap()));\n-        drop(R.write().unwrap());\n-        unsafe { R.destroy(); }\n-    }\n-\n     #[test]\n     fn frob() {\n-        static R: StaticRwLock = StaticRwLock::new();\n         const N: usize = 10;\n         const M: usize = 1000;\n \n+        let r = Arc::new(RwLock::new(()));\n+\n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {\n             let tx = tx.clone();\n-            thread::spawn(move|| {\n+            let r = r.clone();\n+            thread::spawn(move || {\n                 let mut rng = rand::thread_rng();\n                 for _ in 0..M {\n                     if rng.gen_weighted_bool(N) {\n-                        drop(R.write().unwrap());\n+                        drop(r.write().unwrap());\n                     } else {\n-                        drop(R.read().unwrap());\n+                        drop(r.read().unwrap());\n                     }\n                 }\n                 drop(tx);\n             });\n         }\n         drop(tx);\n         let _ = rx.recv();\n-        unsafe { R.destroy(); }\n     }\n \n     #[test]"}, {"sha": "4c23ceb63f287bd4a7c9c5efbc344404ed435d98", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -170,7 +170,9 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n                         \"$u20$\", => b\" \",\n                         \"$u27$\", => b\"'\",\n                         \"$u5b$\", => b\"[\",\n-                        \"$u5d$\", => b\"]\"\n+                        \"$u5d$\", => b\"]\",\n+                        \"$u7b$\", => b\"{\",\n+                        \"$u7d$\", => b\"}\"\n                     )\n                 } else {\n                     let idx = match rest.find('$') {"}, {"sha": "442618c55b337f5dc157db2e81893ff8e481e496", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -25,19 +25,23 @@ use time::Duration;\n \n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\"))]\n+          target_os = \"openbsd\", target_os = \"netbsd\",\n+          target_os = \"solaris\"))]\n use sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\")))]\n+              target_os = \"openbsd\", target_os = \"netbsd\",\n+              target_os = \"solaris\")))]\n use sys::net::netc::IPV6_ADD_MEMBERSHIP;\n #[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n           target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\"))]\n+          target_os = \"openbsd\", target_os = \"netbsd\",\n+          target_os = \"solaris\"))]\n use sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n #[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n               target_os = \"ios\", target_os = \"macos\",\n-          target_os = \"openbsd\", target_os = \"netbsd\")))]\n+              target_os = \"openbsd\", target_os = \"netbsd\",\n+              target_os = \"solaris\")))]\n use sys::net::netc::IPV6_DROP_MEMBERSHIP;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -601,3 +605,22 @@ impl fmt::Debug for UdpSocket {\n             .finish()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+\n+    use super::*;\n+    use collections::HashMap;\n+\n+    #[test]\n+    fn no_lookup_host_duplicates() {\n+        let mut addrs = HashMap::new();\n+        let lh = match lookup_host(\"localhost\") {\n+            Ok(lh) => lh,\n+            Err(e) => panic!(\"couldn't resolve `localhost': {}\", e)\n+        };\n+        let _na = lh.map(|sa| *addrs.entry(sa).or_insert(0) += 1).count();\n+        assert!(addrs.values().filter(|&&v| v > 1).count() == 0);\n+    }\n+}"}, {"sha": "55212bf35d698656df80e8d0a55cb767411a0b3a", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -8,22 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cell::Cell;\n use error::{Error};\n use fmt;\n use marker::Reflect;\n+use sync::atomic::{AtomicBool, Ordering};\n use thread;\n \n-pub struct Flag { failed: Cell<bool> }\n+pub struct Flag { failed: AtomicBool }\n \n-// This flag is only ever accessed with a lock previously held. Note that this\n-// a totally private structure.\n-unsafe impl Send for Flag {}\n-unsafe impl Sync for Flag {}\n+// Note that the Ordering uses to access the `failed` field of `Flag` below is\n+// always `Relaxed`, and that's because this isn't actually protecting any data,\n+// it's just a flag whether we've panicked or not.\n+//\n+// The actual location that this matters is when a mutex is **locked** which is\n+// where we have external synchronization ensuring that we see memory\n+// reads/writes to this flag.\n+//\n+// As a result, if it matters, we should see the correct value for `failed` in\n+// all cases.\n \n impl Flag {\n     pub const fn new() -> Flag {\n-        Flag { failed: Cell::new(false) }\n+        Flag { failed: AtomicBool::new(false) }\n     }\n \n     #[inline]\n@@ -39,13 +45,13 @@ impl Flag {\n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n         if !guard.panicking && thread::panicking() {\n-            self.failed.set(true);\n+            self.failed.store(true, Ordering::Relaxed);\n         }\n     }\n \n     #[inline]\n     pub fn get(&self) -> bool {\n-        self.failed.get()\n+        self.failed.load(Ordering::Relaxed)\n     }\n }\n "}, {"sha": "2c1a656290f946a223274910fa6672a6ceabfab0", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -566,7 +566,7 @@ impl Wtf8 {\n         if len < 3 {\n             return None\n         }\n-        match ::slice_pat(&&self.bytes[(len - 3)..]) {\n+        match &self.bytes[(len - 3)..] {\n             &[0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n             _ => None\n         }\n@@ -578,7 +578,7 @@ impl Wtf8 {\n         if len < 3 {\n             return None\n         }\n-        match ::slice_pat(&&self.bytes[..3]) {\n+        match &self.bytes[..3] {\n             &[0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n             _ => None\n         }"}, {"sha": "b315e6762633b3fd982566c5a311360a3ad4065b", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -84,7 +84,7 @@ pub struct OpenOptions {\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FilePermissions { mode: mode_t }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FileType { mode: mode_t }\n \n pub struct DirBuilder { mode: mode_t }\n@@ -205,9 +205,15 @@ impl Iterator for ReadDir {\n                 // of the thread safety, on Illumos the readdir(3C) function is safe to use\n                 // in threaded applications and it is generally preferred over the\n                 // readdir_r(3C) function.\n+                super::os::set_errno(0);\n                 let entry_ptr = libc::readdir(self.dirp.0);\n                 if entry_ptr.is_null() {\n-                    return None\n+                    // NULL can mean either the end is reached or an error occurred.\n+                    // So we had to clear errno beforehand to check for an error now.\n+                    return match super::os::errno() {\n+                        0 => None,\n+                        e => Some(Err(Error::from_raw_os_error(e))),\n+                    }\n                 }\n \n                 let name = (*entry_ptr).d_name.as_ptr();"}, {"sha": "63e13f0bb473849c6b8073190fcc8d8158fb9bc5", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -35,28 +35,37 @@ use vec;\n const TMPBUF_SZ: usize = 128;\n static ENV_LOCK: Mutex = Mutex::new();\n \n+\n+extern {\n+    #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\"),\n+               link_name = \"__errno_location\")]\n+    #[cfg_attr(any(target_os = \"bitrig\",\n+                   target_os = \"netbsd\",\n+                   target_os = \"openbsd\",\n+                   target_os = \"android\",\n+                   target_env = \"newlib\"),\n+               link_name = \"__errno\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n+    #[cfg_attr(any(target_os = \"macos\",\n+                   target_os = \"ios\",\n+                   target_os = \"freebsd\"),\n+               link_name = \"__error\")]\n+    fn errno_location() -> *mut c_int;\n+}\n+\n /// Returns the platform-specific value of errno\n #[cfg(not(target_os = \"dragonfly\"))]\n pub fn errno() -> i32 {\n-    extern {\n-        #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\"),\n-                   link_name = \"__errno_location\")]\n-        #[cfg_attr(any(target_os = \"bitrig\",\n-                       target_os = \"netbsd\",\n-                       target_os = \"openbsd\",\n-                       target_os = \"android\",\n-                       target_env = \"newlib\"),\n-                   link_name = \"__errno\")]\n-        #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n-        #[cfg_attr(any(target_os = \"macos\",\n-                       target_os = \"ios\",\n-                       target_os = \"freebsd\"),\n-                   link_name = \"__error\")]\n-        fn errno_location() -> *const c_int;\n+    unsafe {\n+        (*errno_location()) as i32\n     }\n+}\n \n+/// Sets the platform-specific value of errno\n+#[cfg(target_os = \"solaris\")] // only needed for readdir so far\n+pub fn set_errno(e: i32) {\n     unsafe {\n-        (*errno_location()) as i32\n+        *errno_location() = e as c_int\n     }\n }\n \n@@ -227,11 +236,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                        libc::KERN_PROC_ARGV];\n         let mib = mib.as_mut_ptr();\n         let mut argv_len = 0;\n-        cvt(libc::sysctl(mib, 4, 0 as *mut _, &mut argv_len,\n-                         0 as *mut _, 0))?;\n+        cvt(libc::sysctl(mib, 4, ptr::null_mut(), &mut argv_len,\n+                         ptr::null_mut(), 0))?;\n         let mut argv = Vec::<*const libc::c_char>::with_capacity(argv_len as usize);\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _,\n-                         &mut argv_len, 0 as *mut _, 0))?;\n+                         &mut argv_len, ptr::null_mut(), 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n             return Err(io::Error::new(io::ErrorKind::Other,"}, {"sha": "010594133387a4602261369cf4b0e89cfb81e642", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -14,6 +14,7 @@ use cmp;\n use io;\n use libc::{self, c_int};\n use mem;\n+use ptr;\n use sys::cvt_r;\n use sys::fd::FileDesc;\n \n@@ -92,8 +93,8 @@ pub fn read2(p1: AnonPipe,\n             let mut read: libc::fd_set = mem::zeroed();\n             libc::FD_SET(p1.raw(), &mut read);\n             libc::FD_SET(p2.raw(), &mut read);\n-            libc::select(max + 1, &mut read, 0 as *mut _, 0 as *mut _,\n-                         0 as *mut _)\n+            libc::select(max + 1, &mut read, ptr::null_mut(), ptr::null_mut(),\n+                         ptr::null_mut())\n         })?;\n \n         // Read as much as we can from each pipe, ignoring EWOULDBLOCK or"}, {"sha": "d68867fb3d2ce9d164466ef0a1164a1f8fb008c9", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -96,7 +96,7 @@ impl Command {\n         let mut saw_nul = false;\n         let program = os2c(program, &mut saw_nul);\n         Command {\n-            argv: vec![program.as_ptr(), 0 as *const _],\n+            argv: vec![program.as_ptr(), ptr::null()],\n             program: program,\n             args: Vec::new(),\n             env: None,\n@@ -117,7 +117,7 @@ impl Command {\n         // pointer.\n         let arg = os2c(arg, &mut self.saw_nul);\n         self.argv[self.args.len() + 1] = arg.as_ptr();\n-        self.argv.push(0 as *const _);\n+        self.argv.push(ptr::null());\n \n         // Also make sure we keep track of the owned value to schedule a\n         // destructor for this memory.\n@@ -134,7 +134,7 @@ impl Command {\n                 envp.push(s.as_ptr());\n                 map.insert(k, (envp.len() - 1, s));\n             }\n-            envp.push(0 as *const _);\n+            envp.push(ptr::null());\n             self.env = Some(map);\n             self.envp = Some(envp);\n         }\n@@ -158,7 +158,7 @@ impl Command {\n             Entry::Vacant(e) => {\n                 let len = envp.len();\n                 envp[len - 1] = new_key.as_ptr();\n-                envp.push(0 as *const _);\n+                envp.push(ptr::null());\n                 e.insert((len - 1, new_key));\n             }\n         }\n@@ -183,7 +183,7 @@ impl Command {\n \n     pub fn env_clear(&mut self) {\n         self.env = Some(HashMap::new());\n-        self.envp = Some(vec![0 as *const _]);\n+        self.envp = Some(vec![ptr::null()]);\n     }\n \n     pub fn cwd(&mut self, dir: &OsStr) {"}, {"sha": "1061ca87f6470894dda944ed69fb36d5e5ac75dc", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,7 +12,6 @@ use prelude::v1::*;\n \n use alloc::boxed::FnBox;\n use cmp;\n-#[cfg(not(any(target_env = \"newlib\", target_os = \"solaris\")))]\n use ffi::CStr;\n use io;\n use libc;"}, {"sha": "a08cec38f732dae6ed8c8da0009080f91d08399d", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use cmp::Ordering;\n-use time::Duration;\n use libc;\n+use time::Duration;\n \n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n \n@@ -164,12 +164,14 @@ mod inner {\n \n     impl SystemTime {\n         pub fn now() -> SystemTime {\n+            use ptr;\n+\n             let mut s = libc::timeval {\n                 tv_sec: 0,\n                 tv_usec: 0,\n             };\n             cvt(unsafe {\n-                libc::gettimeofday(&mut s, 0 as *mut _)\n+                libc::gettimeofday(&mut s, ptr::null_mut())\n             }).unwrap();\n             return SystemTime::from(s)\n         }"}, {"sha": "82a44c1c1103b4aa7935a5889e11072c0ef05eae", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -30,9 +30,9 @@ use io;\n use libc::c_void;\n use mem;\n use ptr;\n-use sync::StaticMutex;\n use sys::c;\n use sys::dynamic_lib::DynamicLibrary;\n+use sys::mutex::Mutex;\n \n macro_rules! sym {\n     ($lib:expr, $e:expr, $t:ident) => (\n@@ -101,53 +101,59 @@ impl Drop for Cleanup {\n pub fn write(w: &mut Write) -> io::Result<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n-    static LOCK: StaticMutex = StaticMutex::new();\n-    let _g = LOCK.lock();\n+    static LOCK: Mutex = Mutex::new();\n+    unsafe {\n+        LOCK.lock();\n+        let res = _write(w);\n+        LOCK.unlock();\n+        return res\n+    }\n+}\n \n+unsafe fn _write(w: &mut Write) -> io::Result<()> {\n     let dbghelp = match DynamicLibrary::open(\"dbghelp.dll\") {\n         Ok(lib) => lib,\n         Err(..) => return Ok(()),\n     };\n-    unsafe {\n-        // Fetch the symbols necessary from dbghelp.dll\n-        let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n-        let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n-        let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n-\n-        // Allocate necessary structures for doing the stack walk\n-        let process = c::GetCurrentProcess();\n-        let thread = c::GetCurrentThread();\n-        let mut context: c::CONTEXT = mem::zeroed();\n-        c::RtlCaptureContext(&mut context);\n-        let mut frame: c::STACKFRAME64 = mem::zeroed();\n-        let image = init_frame(&mut frame, &context);\n-\n-        // Initialize this process's symbols\n-        let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n-        if ret != c::TRUE { return Ok(()) }\n-        let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n-\n-        // And now that we're done with all the setup, do the stack walking!\n-        // Start from -1 to avoid printing this stack frame, which will\n-        // always be exactly the same.\n-        let mut i = -1;\n-        write!(w, \"stack backtrace:\\n\")?;\n-        while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut(),\n-                          ptr::null_mut()) == c::TRUE {\n-            let addr = frame.AddrPC.Offset;\n-            if addr == frame.AddrReturn.Offset || addr == 0 ||\n-               frame.AddrReturn.Offset == 0 { break }\n-\n-            i += 1;\n-\n-            if i >= 0 {\n-                printing::print(w, i, addr - 1, process, &dbghelp)?;\n-            }\n-        }\n \n-        Ok(())\n+    // Fetch the symbols necessary from dbghelp.dll\n+    let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn);\n+    let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn);\n+    let StackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n+\n+    // Allocate necessary structures for doing the stack walk\n+    let process = c::GetCurrentProcess();\n+    let thread = c::GetCurrentThread();\n+    let mut context: c::CONTEXT = mem::zeroed();\n+    c::RtlCaptureContext(&mut context);\n+    let mut frame: c::STACKFRAME64 = mem::zeroed();\n+    let image = init_frame(&mut frame, &context);\n+\n+    // Initialize this process's symbols\n+    let ret = SymInitialize(process, ptr::null_mut(), c::TRUE);\n+    if ret != c::TRUE { return Ok(()) }\n+    let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n+\n+    // And now that we're done with all the setup, do the stack walking!\n+    // Start from -1 to avoid printing this stack frame, which will\n+    // always be exactly the same.\n+    let mut i = -1;\n+    write!(w, \"stack backtrace:\\n\")?;\n+    while StackWalk64(image, process, thread, &mut frame, &mut context,\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut()) == c::TRUE {\n+        let addr = frame.AddrPC.Offset;\n+        if addr == frame.AddrReturn.Offset || addr == 0 ||\n+           frame.AddrReturn.Offset == 0 { break }\n+\n+        i += 1;\n+\n+        if i >= 0 {\n+            printing::print(w, i, addr - 1, process, &dbghelp)?;\n+        }\n     }\n+\n+    Ok(())\n }"}, {"sha": "2683e57256dc79afc29a2872a31861f77a788d53", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -38,7 +38,7 @@ pub struct FileAttr {\n     reparse_tag: c::DWORD,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum FileType {\n     Dir, File, SymlinkFile, SymlinkDir, ReparsePoint, MountPoint,\n }\n@@ -117,7 +117,7 @@ impl Drop for FindNextFileHandle {\n \n impl DirEntry {\n     fn new(root: &Arc<PathBuf>, wfd: &c::WIN32_FIND_DATAW) -> Option<DirEntry> {\n-        match ::slice_pat(&&wfd.cFileName[0..3]) {\n+        match &wfd.cFileName[0..3] {\n             // check for '.' and '..'\n             &[46, 0, ..] |\n             &[46, 46, 0, ..] => return None,"}, {"sha": "d10abae2865271dadfc6af7a3c1f3fa62cd41da9", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -46,10 +46,10 @@ impl Handle {\n \n     pub fn new_event(manual: bool, init: bool) -> io::Result<Handle> {\n         unsafe {\n-            let event = c::CreateEventW(0 as *mut _,\n+            let event = c::CreateEventW(ptr::null_mut(),\n                                         manual as c::BOOL,\n                                         init as c::BOOL,\n-                                        0 as *const _);\n+                                        ptr::null());\n             if event.is_null() {\n                 Err(io::Error::last_os_error())\n             } else {"}, {"sha": "6e9c67051a6eb3559c17a3d2d813df4b685816df", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,9 +12,10 @@ use prelude::v1::*;\n use os::windows::prelude::*;\n \n use ffi::OsStr;\n-use path::Path;\n use io;\n use mem;\n+use path::Path;\n+use ptr;\n use rand::{self, Rng};\n use slice;\n use sys::c;\n@@ -66,7 +67,7 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n                                              4096,\n                                              4096,\n                                              0,\n-                                             0 as *mut _);\n+                                             ptr::null_mut());\n \n             // We pass the FILE_FLAG_FIRST_PIPE_INSTANCE flag above, and we're\n             // also just doing a best effort at selecting a unique name. If"}, {"sha": "6b662c6779a4bd118e2dcffbe9c81b47a91c92b6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -26,7 +26,6 @@ use tokenstream::{TokenTree};\n \n use std::fmt;\n use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A name is a part of an identifier, representing a string or gensym. It's\n@@ -46,7 +45,7 @@ pub struct SyntaxContext(pub u32);\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n-#[derive(Clone, Copy, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n     pub name: Name,\n     pub ctxt: SyntaxContext\n@@ -93,40 +92,6 @@ impl Ident {\n     }\n }\n \n-impl PartialEq for Ident {\n-    fn eq(&self, other: &Ident) -> bool {\n-        if self.ctxt != other.ctxt {\n-            // There's no one true way to compare Idents. They can be compared\n-            // non-hygienically `id1.name == id2.name`, hygienically\n-            // `mtwt::resolve(id1) == mtwt::resolve(id2)`, or even member-wise\n-            // `(id1.name, id1.ctxt) == (id2.name, id2.ctxt)` depending on the situation.\n-            // Ideally, PartialEq should not be implemented for Ident at all, but that\n-            // would be too impractical, because many larger structures (Token, in particular)\n-            // including Idents as their parts derive PartialEq and use it for non-hygienic\n-            // comparisons. That's why PartialEq is implemented and defaults to non-hygienic\n-            // comparison. Hash is implemented too and is consistent with PartialEq, i.e. only\n-            // the name of Ident is hashed. Still try to avoid comparing idents in your code\n-            // (especially as keys in hash maps), use one of the three methods listed above\n-            // explicitly.\n-            //\n-            // If you see this panic, then some idents from different contexts were compared\n-            // non-hygienically. It's likely a bug. Use one of the three comparison methods\n-            // listed above explicitly.\n-\n-            panic!(\"idents with different contexts are compared with operator `==`: \\\n-                {:?}, {:?}.\", self, other);\n-        }\n-\n-        self.name == other.name\n-    }\n-}\n-\n-impl Hash for Ident {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.name.hash(state)\n-    }\n-}\n-\n impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}#{}\", self.name, self.ctxt.0)\n@@ -804,6 +769,19 @@ pub struct Stmt {\n     pub span: Span,\n }\n \n+impl Stmt {\n+    pub fn add_trailing_semicolon(mut self) -> Self {\n+        self.node = match self.node {\n+            StmtKind::Expr(expr) => StmtKind::Semi(expr),\n+            StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, _style, attrs)| {\n+                (mac, MacStmtStyle::Semicolon, attrs)\n+            })),\n+            node @ _ => node,\n+        };\n+        self\n+    }\n+}\n+\n impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"stmt({}: {})\", self.id.to_string(), pprust::stmt_to_string(self))"}, {"sha": "67f73d4dd4f711e4798a42200002c5ddf50933a3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -324,7 +324,7 @@ pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Inte\n             if let s@Some(_) = attr.value_str() {\n                 s\n             } else {\n-                struct_span_err!(diag, attr.span, E0533,\n+                struct_span_err!(diag, attr.span, E0558,\n                                  \"export_name attribute has invalid format\")\n                                 .help(\"use #[export_name=\\\"*\\\"]\")\n                                 .emit();\n@@ -373,7 +373,7 @@ pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> In\n                     InlineAttr::None\n                 }\n             }\n-            _ => ia\n+            _ => ia,\n         }\n     })\n }"}, {"sha": "010b1d638e63cf2085e89ea9f265a3376d228b47", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 141, "deletions": 8, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -15,9 +15,146 @@\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n register_long_diagnostics! {\n \n-E0533: r##\"\n-```compile_fail,E0533\n-#[export_name]\n+E0534: r##\"\n+The `inline` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0534\n+#[inline()] // error: expected one argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The parenthesized `inline` attribute requires the parameter to be specified:\n+\n+```ignore\n+#[inline(always)]\n+fn something() {}\n+\n+// or:\n+\n+#[inline(never)]\n+fn something() {}\n+```\n+\n+Alternatively, a paren-less version of the attribute may be used to hint the\n+compiler about inlining opportunity:\n+\n+```\n+#[inline]\n+fn something() {}\n+```\n+\n+For more information about the inline attribute, read:\n+https://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0535: r##\"\n+An unknown argument was given to the `inline` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0535\n+#[inline(unknown)] // error: invalid argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `inline` attribute only supports two arguments:\n+\n+ * always\n+ * never\n+\n+All other arguments given to the `inline` attribute will return this error.\n+Example:\n+\n+```\n+#[inline(never)] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+For more information about the inline attribute, https:\n+read://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0536: r##\"\n+The `not` cfg-predicate was malformed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0536\n+#[cfg(not())] // error: expected 1 cfg-pattern\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+The `not` predicate expects one cfg-pattern. Example:\n+\n+```\n+#[cfg(not(target_os = \"linux\"))] // ok!\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+For more information about the cfg attribute, read:\n+https://doc.rust-lang.org/reference.html#conditional-compilation\n+\"##,\n+\n+E0537: r##\"\n+An unknown predicate was used inside the `cfg` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0537\n+#[cfg(unknown())] // error: invalid predicate `unknown`\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+The `cfg` attribute supports only three kinds of predicates:\n+\n+ * any\n+ * all\n+ * not\n+\n+Example:\n+\n+```\n+#[cfg(not(target_os = \"linux\"))] // ok!\n+pub fn something() {}\n+\n+pub fn main() {}\n+```\n+\n+For more information about the cfg attribute, read:\n+https://doc.rust-lang.org/reference.html#conditional-compilation\n+\"##,\n+\n+E0558: r##\"\n+The `export_name` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0558\n+#[export_name] // error: export_name attribute has invalid format\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `export_name` attribute expects a string in order to determine the name of\n+the exported symbol. Example:\n+\n+```\n+#[export_name = \"some_function\"] // ok!\n pub fn something() {}\n \n fn main() {}\n@@ -27,10 +164,6 @@ fn main() {}\n }\n \n register_diagnostics! {\n-    E0534, // expected one argument\n-    E0535, // invalid argument\n-    E0536, // expected 1 cfg-pattern\n-    E0537, // invalid predicate\n     E0538, // multiple [same] items\n     E0539, // incorrect meta item\n     E0540, // multiple rustc_deprecated attributes"}, {"sha": "7ebcd12cdb9512853b9122c49079f8690a381e65", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -26,7 +26,6 @@ use parse::token::{InternedString, intern, str_to_ident};\n use ptr::P;\n use util::small_vector::SmallVector;\n use util::lev_distance::find_best_match_for_name;\n-use ext::mtwt;\n use fold::Folder;\n \n use std::collections::{HashMap, HashSet};\n@@ -483,15 +482,12 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n pub struct BlockInfo {\n     /// Should macros escape from this scope?\n     pub macros_escape: bool,\n-    /// What are the pending renames?\n-    pub pending_renames: mtwt::RenameList,\n }\n \n impl BlockInfo {\n     pub fn new() -> BlockInfo {\n         BlockInfo {\n             macros_escape: false,\n-            pending_renames: Vec::new(),\n         }\n     }\n }"}, {"sha": "3e9837a6995c3f06ba9791404a010603a49ec61d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 35, "deletions": 566, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -8,23 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, PatKind};\n-use ast::{Local, Ident, Mac_, Name, SpannedIdent};\n+use ast::{Block, Crate, Ident, Mac_, Name, PatKind};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast;\n use attr::HasAttrs;\n use ext::mtwt;\n use attr;\n use attr::AttrMetaMethods;\n-use codemap::{Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{dummy_spanned, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use syntax_pos::{self, Span, ExpnId};\n use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n use fold::*;\n-use util::move_map::MoveMap;\n-use parse::token::{fresh_mark, fresh_name, intern, keywords};\n+use parse::token::{fresh_mark, intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n@@ -96,89 +94,32 @@ impl MacroGenerable for Option<P<ast::Expr>> {\n     }\n }\n \n-pub fn expand_expr(mut expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n     match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n             return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n         }\n+        _ => P(noop_fold_expr(expr, fld)),\n+    }\n+}\n \n-        ast::ExprKind::While(cond, body, opt_ident) => {\n-            let cond = fld.fold_expr(cond);\n-            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            expr.node = ast::ExprKind::While(cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-            let cond = fld.fold_expr(cond);\n-\n-            // Hygienic renaming of the body.\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            expr.node = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::Loop(loop_block, opt_ident) => {\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            expr.node = ast::ExprKind::Loop(loop_block, opt_ident);\n-        }\n-\n-        ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the for loop body (for loop binds its pattern).\n-            let ((body, opt_ident), mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                (body, opt_ident),\n-                                |rename_fld, fld, (body, opt_ident)| {\n-                expand_loop_block(rename_fld.fold_block(body), opt_ident, fld)\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let head = fld.fold_expr(head);\n-            expr.node = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-        }\n-\n-        ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n-            let pat = fld.fold_pat(pat);\n-\n-            // Hygienic renaming of the body.\n-            let (body, mut rewritten_pats) =\n-                rename_in_scope(vec![pat],\n-                                fld,\n-                                body,\n-                                |rename_fld, fld, body| {\n-                fld.fold_block(rename_fld.fold_block(body))\n-            });\n-            assert!(rewritten_pats.len() == 1);\n-\n-            let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n-            let sub_expr = fld.fold_expr(sub_expr);\n-            expr.node = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-        }\n-\n-        ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n-            let (rewritten_fn_decl, rewritten_block)\n-                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n-            expr.node = ast::ExprKind::Closure(capture_clause,\n-                                               rewritten_fn_decl,\n-                                               rewritten_block,\n-                                               fn_decl_span);\n-        }\n-\n-        _ => expr = noop_fold_expr(expr, fld),\n-    };\n-    P(expr)\n+struct MacroScopePlaceholder;\n+impl MacResult for MacroScopePlaceholder {\n+    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n+        Some(SmallVector::one(P(ast::Item {\n+            ident: keywords::Invalid.ident(),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n+                path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n+                tts: Vec::new(),\n+            })),\n+            vis: ast::Visibility::Inherited,\n+            span: syntax_pos::DUMMY_SP,\n+        })))\n+    }\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -219,6 +160,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n         };\n \n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        let marked_tts = mark_tts(&tts, mark);\n         match *extension {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -237,7 +179,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     },\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n             }\n \n@@ -257,7 +198,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     }\n                 });\n \n-                let marked_tts = mark_tts(&tts, mark);\n                 Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n             }\n \n@@ -286,15 +226,14 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n                     span: call_site,\n                     imported_from: None,\n                     use_locally: true,\n-                    body: tts,\n+                    body: marked_tts,\n                     export: attr::contains_name(&attrs, \"macro_export\"),\n                     allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n                     attrs: attrs,\n                 });\n \n                 // macro_rules! has a side effect but expands to nothing.\n-                fld.cx.bt_pop();\n-                None\n+                Some(Box::new(MacroScopePlaceholder))\n             }\n \n             MultiDecorator(..) | MultiModifier(..) => {\n@@ -327,41 +266,6 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n     fully_expanded\n }\n \n-/// Rename loop label and expand its loop body\n-///\n-/// The renaming procedure for loop is different in the sense that the loop\n-/// body is in a block enclosed by loop head so the renaming of loop label\n-/// must be propagated to the enclosed context.\n-fn expand_loop_block(loop_block: P<Block>,\n-                     opt_ident: Option<SpannedIdent>,\n-                     fld: &mut MacroExpander) -> (P<Block>, Option<SpannedIdent>) {\n-    match opt_ident {\n-        Some(label) => {\n-            let new_label = fresh_name(label.node);\n-            let rename = (label.node, new_label);\n-\n-            // The rename *must not* be added to the pending list of current\n-            // syntax context otherwise an unrelated `break` or `continue` in\n-            // the same context will pick that up in the deferred renaming pass\n-            // and be renamed incorrectly.\n-            let mut rename_list = vec!(rename);\n-            let mut rename_fld = IdentRenamer{renames: &mut rename_list};\n-            let renamed_ident = rename_fld.fold_ident(label.node);\n-\n-            // The rename *must* be added to the enclosed syntax context for\n-            // `break` or `continue` to pick up because by definition they are\n-            // in a block enclosed by loop head.\n-            fld.cx.syntax_env.push_frame();\n-            fld.cx.syntax_env.info().pending_renames.push(rename);\n-            let expanded_block = expand_block_elts(loop_block, fld);\n-            fld.cx.syntax_env.pop_frame();\n-\n-            (expanded_block, Some(Spanned { node: renamed_ident, span: label.span }))\n-        }\n-        None => (fld.fold_block(loop_block), opt_ident)\n-    }\n-}\n-\n // eval $e with a new exts frame.\n // must be a macro so that $e isn't evaluated too early.\n macro_rules! with_exts_frame {\n@@ -381,20 +285,6 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-/// Expand item_kind\n-fn expand_item_kind(item: ast::ItemKind, fld: &mut MacroExpander) -> ast::ItemKind {\n-    match item {\n-        ast::ItemKind::Fn(decl, unsafety, constness, abi, generics, body) => {\n-            let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n-            let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemKind::Fn(rewritten_fn_decl, unsafety, constness, abi,\n-                        expanded_generics, rewritten_body)\n-        }\n-        _ => noop_fold_item_kind(item, fld)\n-    }\n-}\n-\n // does this attribute list contain \"macro_use\" ?\n fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n     for attr in attrs {\n@@ -425,16 +315,9 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n \n /// Expand a stmt\n fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n-    // perform all pending renames\n-    let stmt = {\n-        let pending_renames = &mut fld.cx.syntax_env.info().pending_renames;\n-        let mut rename_fld = IdentRenamer{renames:pending_renames};\n-        rename_fld.fold_stmt(stmt).expect_one(\"rename_fold didn't return one value\")\n-    };\n-\n     let (mac, style, attrs) = match stmt.node {\n         StmtKind::Mac(mac) => mac.unwrap(),\n-        _ => return expand_non_macro_stmt(stmt, fld)\n+        _ => return noop_fold_stmt(stmt, fld)\n     };\n \n     let mut fully_expanded: SmallVector<ast::Stmt> =\n@@ -444,181 +327,13 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n     // semicolon to the final statement produced by expansion.\n     if style == MacStmtStyle::Semicolon {\n         if let Some(stmt) = fully_expanded.pop() {\n-            fully_expanded.push(Stmt {\n-                id: stmt.id,\n-                node: match stmt.node {\n-                    StmtKind::Expr(expr) => StmtKind::Semi(expr),\n-                    _ => stmt.node /* might already have a semi */\n-                },\n-                span: stmt.span,\n-            });\n+            fully_expanded.push(stmt.add_trailing_semicolon());\n         }\n     }\n \n     fully_expanded\n }\n \n-// expand a non-macro stmt. this is essentially the fallthrough for\n-// expand_stmt, above.\n-fn expand_non_macro_stmt(stmt: Stmt, fld: &mut MacroExpander)\n-                         -> SmallVector<Stmt> {\n-    // is it a let?\n-    match stmt.node {\n-        StmtKind::Local(local) => {\n-            // take it apart:\n-            let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n-                // expand the ty since TyKind::FixedLengthVec contains an Expr\n-                // and thus may have a macro use\n-                let expanded_ty = ty.map(|t| fld.fold_ty(t));\n-                // expand the pat (it might contain macro uses):\n-                let expanded_pat = fld.fold_pat(pat);\n-                // find the PatIdents in the pattern:\n-                // oh dear heaven... this is going to include the enum\n-                // names, as well... but that should be okay, as long as\n-                // the new names are gensyms for the old ones.\n-                // generate fresh names, push them to a new pending list\n-                let idents = pattern_bindings(&expanded_pat);\n-                let mut new_pending_renames =\n-                    idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n-                // rewrite the pattern using the new names (the old\n-                // ones have already been applied):\n-                let rewritten_pat = {\n-                    // nested binding to allow borrow to expire:\n-                    let mut rename_fld = IdentRenamer{renames: &mut new_pending_renames};\n-                    rename_fld.fold_pat(expanded_pat)\n-                };\n-                // add them to the existing pending renames:\n-                fld.cx.syntax_env.info().pending_renames\n-                      .extend(new_pending_renames);\n-                Local {\n-                    id: id,\n-                    ty: expanded_ty,\n-                    pat: rewritten_pat,\n-                    // also, don't forget to expand the init:\n-                    init: init.map(|e| fld.fold_expr(e)),\n-                    span: span,\n-                    attrs: fold::fold_thin_attrs(attrs, fld),\n-                }\n-            });\n-            SmallVector::one(Stmt {\n-                id: stmt.id,\n-                node: StmtKind::Local(rewritten_local),\n-                span: stmt.span,\n-            })\n-        }\n-        _ => noop_fold_stmt(stmt, fld),\n-    }\n-}\n-\n-// expand the arm of a 'match', renaming for macro hygiene\n-fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n-    // expand pats... they might contain macro uses:\n-    let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n-    if expanded_pats.is_empty() {\n-        panic!(\"encountered match arm with 0 patterns\");\n-    }\n-\n-    // apply renaming and then expansion to the guard and the body:\n-    let ((rewritten_guard, rewritten_body), rewritten_pats) =\n-        rename_in_scope(expanded_pats,\n-                        fld,\n-                        (arm.guard, arm.body),\n-                        |rename_fld, fld, (ag, ab)|{\n-        let rewritten_guard = ag.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n-        let rewritten_body = fld.fold_expr(rename_fld.fold_expr(ab));\n-        (rewritten_guard, rewritten_body)\n-    });\n-\n-    ast::Arm {\n-        attrs: fold::fold_attrs(arm.attrs, fld),\n-        pats: rewritten_pats,\n-        guard: rewritten_guard,\n-        body: rewritten_body,\n-    }\n-}\n-\n-fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n-                         fld: &mut MacroExpander,\n-                         x: X,\n-                         f: F)\n-                         -> (X, Vec<P<ast::Pat>>)\n-    where F: Fn(&mut IdentRenamer, &mut MacroExpander, X) -> X\n-{\n-    // all of the pats must have the same set of bindings, so use the\n-    // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&pats[0]);\n-    let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n-    // apply the renaming, but only to the PatIdents:\n-    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n-    let rewritten_pats = pats.move_map(|pat| rename_pats_fld.fold_pat(pat));\n-\n-    let mut rename_fld = IdentRenamer{ renames:&new_renames };\n-    (f(&mut rename_fld, fld, x), rewritten_pats)\n-}\n-\n-/// A visitor that extracts the PatKind::Ident (binding) paths\n-/// from a given thingy and puts them in a mutable\n-/// array\n-#[derive(Clone)]\n-struct PatIdentFinder {\n-    ident_accumulator: Vec<ast::Ident>\n-}\n-\n-impl Visitor for PatIdentFinder {\n-    fn visit_pat(&mut self, pattern: &ast::Pat) {\n-        match *pattern {\n-            ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n-                self.ident_accumulator.push(path1.node);\n-                // visit optional subpattern of PatKind::Ident:\n-                if let Some(ref subpat) = *inner {\n-                    self.visit_pat(subpat)\n-                }\n-            }\n-            // use the default traversal for non-PatIdents\n-            _ => visit::walk_pat(self, pattern)\n-        }\n-    }\n-}\n-\n-/// find the PatKind::Ident paths in a pattern\n-fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n-    let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-    name_finder.visit_pat(pat);\n-    name_finder.ident_accumulator\n-}\n-\n-/// find the PatKind::Ident paths in a\n-fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n-    let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n-    for arg in &fn_decl.inputs {\n-        pat_idents.visit_pat(&arg.pat);\n-    }\n-    pat_idents.ident_accumulator\n-}\n-\n-// expand a block. pushes a new exts_frame, then calls expand_block_elts\n-pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    // see note below about treatment of exts table\n-    with_exts_frame!(fld.cx.syntax_env,false,\n-                     expand_block_elts(blk, fld))\n-}\n-\n-// expand the elements of a block.\n-pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, stmts, rules, span}| {\n-        let new_stmts = stmts.into_iter().flat_map(|x| {\n-            // perform pending renames and expand macros in the statement\n-            fld.fold_stmt(x).into_iter()\n-        }).collect();\n-        Block {\n-            id: fld.new_id(id),\n-            stmts: new_stmts,\n-            rules: rules,\n-            span: span\n-        }\n-    })\n-}\n-\n fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     match p.node {\n         PatKind::Mac(_) => {}\n@@ -632,62 +347,16 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     })\n }\n \n-/// A tree-folder that applies every rename in its (mutable) list\n-/// to every identifier, including both bindings and varrefs\n-/// (and lots of things that will turn out to be neither)\n-pub struct IdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for IdentRenamer<'a> {\n-    fn fold_ident(&mut self, id: Ident) -> Ident {\n-        mtwt::apply_renames(self.renames, id)\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n-/// A tree-folder that applies every rename in its list to\n-/// the idents that are in PatKind::Ident patterns. This is more narrowly\n-/// focused than IdentRenamer, and is needed for FnDecl,\n-/// where we want to rename the args but not the fn name or the generics etc.\n-pub struct PatIdentRenamer<'a> {\n-    renames: &'a mtwt::RenameList,\n-}\n-\n-impl<'a> Folder for PatIdentRenamer<'a> {\n-    fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        match pat.node {\n-            PatKind::Ident(..) => {},\n-            _ => return noop_fold_pat(pat, self)\n-        }\n-\n-        pat.map(|ast::Pat {id, node, span}| match node {\n-            PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = mtwt::apply_renames(self.renames, ident);\n-                let new_node =\n-                    PatKind::Ident(binding_mode,\n-                                  Spanned{span: sp, node: new_ident},\n-                                  sub.map(|p| self.fold_pat(p)));\n-                ast::Pat {\n-                    id: id,\n-                    node: new_node,\n-                    span: span,\n-                }\n-            },\n-            _ => unreachable!()\n-        })\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-}\n-\n fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector<Annotatable> {\n     match a {\n         Annotatable::Item(it) => match it.node {\n             ast::ItemKind::Mac(..) => {\n+                if match it.node {\n+                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n+                    _ => unreachable!(),\n+                } {\n+                    return SmallVector::one(Annotatable::Item(it));\n+                }\n                 it.and_then(|it| match it.node {\n                     ItemKind::Mac(mac) =>\n                         expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n@@ -781,21 +450,6 @@ fn expand_annotatable(mut item: Annotatable, fld: &mut MacroExpander) -> SmallVe\n fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                  -> SmallVector<ast::ImplItem> {\n     match ii.node {\n-        ast::ImplItemKind::Method(..) => SmallVector::one(ast::ImplItem {\n-            id: ii.id,\n-            ident: ii.ident,\n-            attrs: ii.attrs,\n-            vis: ii.vis,\n-            defaultness: ii.defaultness,\n-            node: match ii.node {\n-                ast::ImplItemKind::Method(sig, body) => {\n-                    let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                    ast::ImplItemKind::Method(sig, body)\n-                }\n-                _ => unreachable!()\n-            },\n-            span: ii.span,\n-        }),\n         ast::ImplItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n         }\n@@ -806,61 +460,13 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n                      -> SmallVector<ast::TraitItem> {\n     match ti.node {\n-        ast::TraitItemKind::Method(_, Some(_)) => {\n-            SmallVector::one(ast::TraitItem {\n-                id: ti.id,\n-                ident: ti.ident,\n-                attrs: ti.attrs,\n-                node: match ti.node  {\n-                    ast::TraitItemKind::Method(sig, Some(body)) => {\n-                        let (sig, body) = expand_and_rename_method(sig, body, fld);\n-                        ast::TraitItemKind::Method(sig, Some(body))\n-                    }\n-                    _ => unreachable!()\n-                },\n-                span: ti.span,\n-            })\n-        }\n         ast::TraitItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n         }\n         _ => fold::noop_fold_trait_item(ti, fld)\n     }\n }\n \n-/// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n-/// PatIdents in its arguments to perform renaming in the FnDecl and\n-/// the block, returning both the new FnDecl and the new Block.\n-fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Block>,\n-                                       fld: &mut MacroExpander)\n-                                       -> (P<ast::FnDecl>, P<ast::Block>) {\n-    let expanded_decl = fld.fold_fn_decl(fn_decl);\n-    let idents = fn_decl_arg_bindings(&expanded_decl);\n-    let renames =\n-        idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n-    // first, a renamer for the PatIdents, for the fn_decl:\n-    let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n-    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n-    // now, a renamer for *all* idents, for the body:\n-    let mut rename_fld = IdentRenamer{renames: &renames};\n-    let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n-    (rewritten_fn_decl,rewritten_body)\n-}\n-\n-fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n-                            fld: &mut MacroExpander)\n-                            -> (ast::MethodSig, P<ast::Block>) {\n-    let (rewritten_fn_decl, rewritten_body)\n-        = expand_and_rename_fn_decl_and_block(sig.decl, body, fld);\n-    (ast::MethodSig {\n-        generics: fld.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: rewritten_fn_decl\n-    }, rewritten_body)\n-}\n-\n pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n     let t = match t.node.clone() {\n         ast::TyKind::Mac(mac) => {\n@@ -983,25 +589,17 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        expand_item_kind(item, self)\n-    }\n-\n     fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n         expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let was_in_block = ::std::mem::replace(&mut self.cx.in_block, true);\n-        let result = expand_block(block, self);\n+        let result = with_exts_frame!(self.cx.syntax_env, false, noop_fold_block(block, self));\n         self.cx.in_block = was_in_block;\n         result\n     }\n \n-    fn fold_arm(&mut self, arm: ast::Arm) -> ast::Arm {\n-        expand_arm(arm, self)\n-    }\n-\n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n         expand_annotatable(Annotatable::TraitItem(P(i)), self)\n             .into_iter().map(|i| i.expect_trait_item()).collect()\n@@ -1152,18 +750,11 @@ fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{pattern_bindings, expand_crate};\n-    use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n+    use super::{expand_crate, ExpansionConfig};\n     use ast;\n-    use ast::Name;\n-    use syntax_pos;\n     use ext::base::{ExtCtxt, DummyMacroLoader};\n-    use ext::mtwt;\n-    use fold::Folder;\n     use parse;\n-    use parse::token;\n     use util::parser_testing::{string_to_parser};\n-    use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n@@ -1184,32 +775,6 @@ mod tests {\n         }\n     }\n \n-    // find the variable references in a crate\n-    fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n-        let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n-        visit::walk_crate(&mut path_finder, the_crate);\n-        path_finder.path_accumulator\n-    }\n-\n-    /// A Visitor that extracts the identifiers from a thingy.\n-    // as a side note, I'm starting to want to abstract over these....\n-    struct IdentFinder {\n-        ident_accumulator: Vec<ast::Ident>\n-    }\n-\n-    impl Visitor for IdentFinder {\n-        fn visit_ident(&mut self, _: syntax_pos::Span, id: ast::Ident){\n-            self.ident_accumulator.push(id);\n-        }\n-    }\n-\n-    /// Find the idents in a crate\n-    fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n-        let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n-        visit::walk_crate(&mut ident_finder, the_crate);\n-        ident_finder.ident_accumulator\n-    }\n-\n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n@@ -1271,13 +836,6 @@ mod tests {\n         expand_crate(ecx, vec![], crate_ast).0\n     }\n \n-    // find the pat_ident paths in a crate\n-    fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n-        let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-        visit::walk_crate(&mut name_finder, the_crate);\n-        name_finder.ident_accumulator\n-    }\n-\n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n             \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n@@ -1294,93 +852,4 @@ mod tests {\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n-\n-    #[test]\n-    fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));\n-macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}));\n-foo_module!();\n-\".to_string();\n-        let cr = expand_crate_str(crate_str);\n-        // find the xx binding\n-        let bindings = crate_bindings(&cr);\n-        let cxbinds: Vec<&ast::Ident> =\n-            bindings.iter().filter(|b| b.name.as_str() == \"xx\").collect();\n-        let cxbinds: &[&ast::Ident] = &cxbinds[..];\n-        let cxbind = match (cxbinds.len(), cxbinds.get(0)) {\n-            (1, Some(b)) => *b,\n-            _ => panic!(\"expected just one binding for ext_cx\")\n-        };\n-        let resolved_binding = mtwt::resolve(*cxbind);\n-        let varrefs = crate_varrefs(&cr);\n-\n-        // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p| {\n-            p.segments.len() == 1\n-            && p.segments[0].identifier.name.as_str() == \"xx\"\n-        }).enumerate() {\n-            if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n-                println!(\"uh oh, xx binding didn't match xx varref:\");\n-                println!(\"this is xx varref \\\\# {}\", idx);\n-                println!(\"binding: {}\", cxbind);\n-                println!(\"resolves to: {}\", resolved_binding);\n-                println!(\"varref: {}\", v.segments[0].identifier);\n-                println!(\"resolves to: {}\",\n-                         mtwt::resolve(v.segments[0].identifier));\n-                mtwt::with_sctable(|x| mtwt::display_sctable(x));\n-            }\n-            assert_eq!(mtwt::resolve(v.segments[0].identifier),\n-                       resolved_binding);\n-        };\n-    }\n-\n-    #[test]\n-    fn pat_idents(){\n-        let pat = string_to_pat(\n-            \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let idents = pattern_bindings(&pat);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n-    }\n-\n-    // test the list of identifier patterns gathered by the visitor. Note that\n-    // 'None' is listed as an identifier pattern because we don't yet know that\n-    // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n-    #[test]\n-    fn crate_bindings_test(){\n-        let the_crate = string_to_crate(\"fn main (a: i32) -> i32 {|b| {\n-        match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n-        let idents = crate_bindings(&the_crate);\n-        assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n-    }\n-\n-    // test the IdentRenamer directly\n-    #[test]\n-    fn ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = IdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)]);\n-    }\n-\n-    // test the PatIdentRenamer; only PatIdents get renamed\n-    #[test]\n-    fn pat_ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n-        let f_ident = token::str_to_ident(\"f\");\n-        let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"i32\");\n-        let renames = vec!((x_ident,Name(16)));\n-        let mut renamer = PatIdentRenamer{renames: &renames};\n-        let renamed_crate = renamer.fold_crate(the_crate);\n-        let idents = crate_idents(&renamed_crate);\n-        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        let x_name = x_ident.name;\n-        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name]);\n-    }\n }"}, {"sha": "d2f6df9d5dbd3f1936609ee2b613a257c70fe5eb", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 28, "deletions": 92, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -17,37 +17,27 @@\n \n pub use self::SyntaxContext_::*;\n \n-use ast::{Ident, Mrk, Name, SyntaxContext};\n+use ast::{Ident, Mrk, SyntaxContext};\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n \n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n /// managed pointers everywhere (that caused an ICE).\n-/// the `marks` and `renames` fields are side-tables\n-/// that ensure that adding the same mark to the same context\n-/// gives you back the same context as before. This should cut\n-/// down on memory use *a lot*; applying a mark to a tree containing\n-/// 50 identifiers would otherwise generate 50 new contexts.\n+/// The `marks` ensures that adding the same mark to the\n+/// same context gives you back the same context as before.\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n     marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    renames: RefCell<HashMap<Name,SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n-    Rename (Name),\n-    /// actually, IllegalCtxt may not be necessary.\n-    IllegalCtxt\n }\n \n-/// A list of ident->name renamings\n-pub type RenameList = Vec<(Ident, Name)>;\n-\n /// Extend a syntax context with a given mark\n pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n     with_sctable(|table| apply_mark_internal(m, ctxt, table))\n@@ -65,32 +55,6 @@ fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxCo\n     }\n }\n \n-/// Extend a syntax context with a given rename\n-pub fn apply_rename(from: Ident, to: Name, ident: Ident) -> Ident {\n-    with_sctable(|table| apply_rename_internal(from, to, ident, table))\n-}\n-\n-/// Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn apply_rename_internal(from: Ident, to: Name, ident: Ident, table: &SCTable) -> Ident {\n-    if (ident.name, ident.ctxt) != (from.name, from.ctxt) {\n-        return ident;\n-    }\n-    let ctxt = *table.renames.borrow_mut().entry(to).or_insert_with(|| {\n-        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(to)))\n-    });\n-    Ident { ctxt: ctxt, ..ident }\n-}\n-\n-/// Apply a list of renamings to a context\n-// if these rename lists get long, it would make sense\n-// to consider memoizing this fold. This may come up\n-// when we add hygiene to item names.\n-pub fn apply_renames(renames: &RenameList, ident: Ident) -> Ident {\n-    renames.iter().fold(ident, |ident, &(from, to)| {\n-        apply_rename(from, to, ident)\n-    })\n-}\n-\n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn with_sctable<T, F>(op: F) -> T where\n     F: FnOnce(&SCTable) -> T,\n@@ -99,21 +63,11 @@ pub fn with_sctable<T, F>(op: F) -> T where\n     SCTABLE_KEY.with(move |slot| op(slot))\n }\n \n-// Make a fresh syntax context table with EmptyCtxt in slot zero\n-// and IllegalCtxt in slot one.\n+// Make a fresh syntax context table with EmptyCtxt in slot zero.\n fn new_sctable_internal() -> SCTable {\n     SCTable {\n-        table: RefCell::new(vec!(EmptyCtxt, IllegalCtxt)),\n+        table: RefCell::new(vec![EmptyCtxt]),\n         marks: RefCell::new(HashMap::new()),\n-        renames: RefCell::new(HashMap::new()),\n-    }\n-}\n-\n-/// Print out an SCTable for debugging\n-pub fn display_sctable(table: &SCTable) {\n-    error!(\"SC table:\");\n-    for (idx,val) in table.table.borrow().iter().enumerate() {\n-        error!(\"{:4} : {:?}\",idx,val);\n     }\n }\n \n@@ -122,16 +76,14 @@ pub fn clear_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = Vec::new();\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n /// Reset the tables to their initial state\n pub fn reset_tables() {\n     with_sctable(|table| {\n-        *table.table.borrow_mut() = vec!(EmptyCtxt, IllegalCtxt);\n+        *table.table.borrow_mut() = vec![EmptyCtxt];\n         *table.marks.borrow_mut() = HashMap::new();\n-        *table.renames.borrow_mut() = HashMap::new();\n     });\n }\n \n@@ -141,25 +93,6 @@ fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n     (vec.len() - 1) as u32\n }\n \n-/// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve(id: Ident) -> Name {\n-    with_sctable(|sctable| {\n-        resolve_internal(id, sctable)\n-    })\n-}\n-\n-/// Resolve a syntax object to a name, per MTWT.\n-/// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n-fn resolve_internal(id: Ident, table: &SCTable) -> Name {\n-    match table.table.borrow()[id.ctxt.0 as usize] {\n-        EmptyCtxt => id.name,\n-        // ignore marks here:\n-        Mark(_, subctxt) => resolve_internal(Ident::new(id.name, subctxt), table),\n-        Rename(name) => name,\n-        IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-    }\n-}\n-\n /// Return the outer mark for a context with a mark at the outside.\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n@@ -171,15 +104,24 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     })\n }\n \n+/// If `ident` is macro expanded, return the source ident from the macro definition\n+/// and the mark of the expansion that created the macro definition.\n+pub fn source(ident: Ident) -> Option<(Ident /* source ident */, Mrk /* source macro */)> {\n+    with_sctable(|sctable| {\n+        let ctxts = sctable.table.borrow();\n+        if let Mark(_expansion_mark, macro_ctxt) = ctxts[ident.ctxt.0 as usize] {\n+            if let Mark(definition_mark, orig_ctxt) = ctxts[macro_ctxt.0 as usize] {\n+                return Some((Ident::new(ident.name, orig_ctxt), definition_mark));\n+            }\n+        }\n+        None\n+    })\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, apply_mark_internal, new_sctable_internal};\n-    use super::{SCTable, Mark};\n-\n-    fn id(n: u32, s: SyntaxContext) -> Ident {\n-        Ident::new(Name(n), s)\n-    }\n+    use ast::{EMPTY_CTXT, Mrk, SyntaxContext};\n+    use super::{apply_mark_internal, new_sctable_internal, Mark, SCTable};\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n@@ -192,27 +134,21 @@ mod tests {\n     #[test] fn unfold_marks_test() {\n         let mut t = new_sctable_internal();\n \n-        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(3));\n+        assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),SyntaxContext(2));\n         {\n             let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(7,EMPTY_CTXT));\n-            assert!((*table)[3] == Mark(3,SyntaxContext(2)));\n+            assert!((*table)[1] == Mark(7,EMPTY_CTXT));\n+            assert!((*table)[2] == Mark(3,SyntaxContext(1)));\n         }\n     }\n \n-    #[test]\n-    fn mtwt_resolve_test(){\n-        let a = 40;\n-        assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n-    }\n-\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n-        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(3));\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // using the same one again should result in the same index:\n-        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(1));\n         // I'm assuming that the rename table will behave the same....\n     }\n }"}, {"sha": "db12ef24f7149fd95fd3ab362af7606ff517793b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -123,7 +123,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => match parser.parse_stmt() {\n+                _ => match parser.parse_full_stmt(true) {\n                     Ok(maybe_stmt) => match maybe_stmt {\n                         Some(stmt) => ret.push(stmt),\n                         None => (),"}, {"sha": "4656ba03e21c3e05d620855435942a31ac0a55b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 82, "deletions": 105, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -259,7 +259,6 @@ pub struct Parser<'a> {\n     pub restrictions: Restrictions,\n     pub quote_depth: usize, // not (yet) related to the quasiquoter\n     pub reader: Box<Reader+'a>,\n-    pub interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n     pub obsolete_set: HashSet<ObsoleteSyntax>,\n@@ -356,7 +355,6 @@ impl<'a> Parser<'a> {\n \n         Parser {\n             reader: rdr,\n-            interner: token::get_ident_interner(),\n             sess: sess,\n             cfg: cfg,\n             token: tok0.tok,\n@@ -3789,7 +3787,13 @@ impl<'a> Parser<'a> {\n         self.span_err(self.last_span, message);\n     }\n \n-    /// Parse a statement. may include decl.\n+    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n+    /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n+    ///\n+    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n+    /// ```rust\n+    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n+    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_())\n     }\n@@ -4038,36 +4042,14 @@ impl<'a> Parser<'a> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Stmt {node, span, ..} = if let Some(s) = self.parse_stmt_() {\n-                s\n+            if let Some(stmt) = self.parse_full_stmt(false)? {\n+                stmts.push(stmt);\n             } else if self.token == token::Eof {\n                 break;\n             } else {\n                 // Found only `;` or `}`.\n                 continue;\n             };\n-\n-            match node {\n-                StmtKind::Expr(e) => {\n-                    self.handle_expression_like_statement(e, span, &mut stmts)?;\n-                }\n-                StmtKind::Mac(mac) => {\n-                    self.handle_macro_in_block(mac.unwrap(), span, &mut stmts)?;\n-                }\n-                _ => { // all other kinds of statements:\n-                    let mut hi = span.hi;\n-                    if classify::stmt_ends_with_semi(&node) {\n-                        self.expect(&token::Semi)?;\n-                        hi = self.last_span.hi;\n-                    }\n-\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: node,\n-                        span: mk_sp(span.lo, hi)\n-                    });\n-                }\n-            }\n         }\n \n         Ok(P(ast::Block {\n@@ -4078,93 +4060,88 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn handle_macro_in_block(&mut self,\n-                             (mac, style, attrs): (ast::Mac, MacStmtStyle, ThinVec<Attribute>),\n-                             span: Span,\n-                             stmts: &mut Vec<Stmt>)\n-                             -> PResult<'a, ()> {\n-        if style == MacStmtStyle::NoBraces {\n-            // statement macro without braces; might be an\n-            // expr depending on whether a semicolon follows\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    let e = self.mk_mac_expr(span.lo, span.hi, mac.node, ThinVec::new());\n-                    let lo = e.span.lo;\n-                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                    self.handle_expression_like_statement(e, span, stmts)?;\n-                }\n-            }\n-        } else {\n-            // statement macro; might be an expr\n-            match self.token {\n-                token::Semi => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, MacStmtStyle::Semicolon, attrs))),\n-                        span: mk_sp(span.lo, self.span.hi),\n-                    });\n-                    self.bump();\n-                }\n-                _ => {\n-                    stmts.push(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Mac(P((mac, style, attrs))),\n-                        span: span\n-                    });\n+    /// Parse a statement, including the trailing semicolon.\n+    /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n+    pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n+        let mut stmt = match self.parse_stmt_() {\n+            Some(stmt) => stmt,\n+            None => return Ok(None),\n+        };\n+\n+        if let StmtKind::Mac(mac) = stmt.node {\n+            if mac.1 != MacStmtStyle::NoBraces ||\n+               self.token == token::Semi || self.token == token::Eof {\n+                stmt.node = StmtKind::Mac(mac);\n+            } else {\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These tokens can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    stmt.node = StmtKind::Mac(mac);\n+                    return Ok(Some(stmt));\n                 }\n+\n+                let (mac, _style, attrs) = mac.unwrap();\n+                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n+                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                stmt.node = StmtKind::Expr(e);\n             }\n         }\n-        Ok(())\n+\n+        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n+        Ok(Some(stmt))\n     }\n \n-    fn handle_expression_like_statement(&mut self,\n-                                        e: P<Expr>,\n-                                        span: Span,\n-                                        stmts: &mut Vec<Stmt>)\n-                                        -> PResult<'a, ()> {\n-        // expression without semicolon\n-        if classify::expr_requires_semi_to_be_stmt(&e) {\n-            // Just check for errors and recover; do not eat semicolon yet.\n-            if let Err(mut e) =\n-                self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n-            {\n-                e.emit();\n-                self.recover_stmt();\n+    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n+                                 -> PResult<'a, Stmt> {\n+        match stmt.node {\n+            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n+                // expression without semicolon\n+                if classify::expr_requires_semi_to_be_stmt(expr) {\n+                    // Just check for errors and recover; do not eat semicolon yet.\n+                    if let Err(mut e) =\n+                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    {\n+                        e.emit();\n+                        self.recover_stmt();\n+                    }\n+                }\n+            }\n+            StmtKind::Local(..) => {\n+                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n+                if macro_expanded && self.token != token::Semi {\n+                    self.warn_missing_semicolon();\n+                } else {\n+                    self.expect_one_of(&[token::Semi], &[])?;\n+                }\n             }\n+            _ => {}\n         }\n \n-        match self.token {\n-            token::Semi => {\n-                self.bump();\n-                let span_with_semi = Span {\n-                    lo: span.lo,\n-                    hi: self.last_span.hi,\n-                    expn_id: span.expn_id,\n-                };\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Semi(e),\n-                    span: span_with_semi,\n-                });\n-            }\n-            _ => {\n-                stmts.push(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Expr(e),\n-                    span: span\n-                });\n-            }\n+        if self.eat(&token::Semi) {\n+            stmt = stmt.add_trailing_semicolon();\n         }\n-        Ok(())\n+\n+        stmt.span.hi = self.last_span.hi;\n+        Ok(stmt)\n+    }\n+\n+    fn warn_missing_semicolon(&self) {\n+        self.diagnostic().struct_span_warn(self.span, {\n+            &format!(\"expected `;`, found `{}`\", self.this_token_to_string())\n+        }).note({\n+            \"This was erroneously allowed and will become a hard error in a future release\"\n+        }).emit();\n     }\n \n     // Parses a sequence of bounds if a `:` is found,"}, {"sha": "fe9d3ef7c234dff8c364e9f4c9bdffb94183c150", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -15,13 +15,12 @@ pub use self::Lit::*;\n pub use self::Token::*;\n \n use ast::{self, BinOpKind};\n-use ext::mtwt;\n use ptr::P;\n-use util::interner::{RcStr, StrInterner};\n-use util::interner;\n+use util::interner::Interner;\n use tokenstream;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n use std::fmt;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -313,17 +312,6 @@ impl Token {\n             _ => false,\n         }\n     }\n-\n-    /// Hygienic identifier equality comparison.\n-    ///\n-    /// See `styntax::ext::mtwt`.\n-    pub fn mtwt_eq(&self, other : &Token) -> bool {\n-        match (self, other) {\n-            (&Ident(id1), &Ident(id2)) | (&Lifetime(id1), &Lifetime(id2)) =>\n-                mtwt::resolve(id1) == mtwt::resolve(id2),\n-            _ => *self == *other\n-        }\n-    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash)]\n@@ -397,7 +385,7 @@ macro_rules! declare_keywords {(\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        interner::StrInterner::prefill(&[$($string,)*])\n+        Interner::prefill(&[$($string,)*])\n     }\n }}\n \n@@ -473,22 +461,25 @@ declare_keywords! {\n }\n \n // looks like we can get rid of this completely...\n-pub type IdentInterner = StrInterner;\n+pub type IdentInterner = Interner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n // FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn get_ident_interner() -> Rc<IdentInterner> {\n-    thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n-        Rc::new(mk_fresh_ident_interner())\n+pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n+    thread_local!(static KEY: RefCell<IdentInterner> = {\n+        RefCell::new(mk_fresh_ident_interner())\n     });\n-    KEY.with(|k| k.clone())\n+    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n }\n \n /// Reset the ident interner to its initial state.\n pub fn reset_ident_interner() {\n-    let interner = get_ident_interner();\n-    interner.reset(mk_fresh_ident_interner());\n+    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n+}\n+\n+pub fn clear_ident_interner() {\n+    with_ident_interner(|interner| *interner = IdentInterner::new());\n }\n \n /// Represents a string stored in the thread-local interner. Because the\n@@ -502,28 +493,27 @@ pub fn reset_ident_interner() {\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n-    string: RcStr,\n+    string: Rc<String>,\n }\n \n impl InternedString {\n     #[inline]\n     pub fn new(string: &'static str) -> InternedString {\n         InternedString {\n-            string: RcStr::new(string),\n+            string: Rc::new(string.to_owned()),\n         }\n     }\n \n     #[inline]\n-    fn new_from_rc_str(string: RcStr) -> InternedString {\n+    fn new_from_rc_str(string: Rc<String>) -> InternedString {\n         InternedString {\n             string: string,\n         }\n     }\n \n     #[inline]\n     pub fn new_from_name(name: ast::Name) -> InternedString {\n-        let interner = get_ident_interner();\n-        InternedString::new_from_rc_str(interner.get(name))\n+        with_ident_interner(|interner| InternedString::new_from_rc_str(interner.get(name)))\n     }\n }\n \n@@ -611,13 +601,13 @@ pub fn intern_and_get_ident(s: &str) -> InternedString {\n /// Maps a string to its interned representation.\n #[inline]\n pub fn intern(s: &str) -> ast::Name {\n-    get_ident_interner().intern(s)\n+    with_ident_interner(|interner| interner.intern(s))\n }\n \n /// gensym's a new usize, using the current interner.\n #[inline]\n pub fn gensym(s: &str) -> ast::Name {\n-    get_ident_interner().gensym(s)\n+    with_ident_interner(|interner| interner.gensym(s))\n }\n \n /// Maps a string to an identifier with an empty syntax context.\n@@ -636,8 +626,7 @@ pub fn gensym_ident(s: &str) -> ast::Ident {\n // note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n // that is, that the new name and the old one are connected to ptr_eq strings.\n pub fn fresh_name(src: ast::Ident) -> ast::Name {\n-    let interner = get_ident_interner();\n-    interner.gensym_copy(src.name)\n+    with_ident_interner(|interner| interner.gensym_copy(src.name))\n     // following: debug version. Could work in final except that it's incompatible with\n     // good error messages and uses of struct names in ambiguous could-be-binding\n     // locations. Also definitely destroys the guarantee given above about ptr_eq.\n@@ -649,21 +638,3 @@ pub fn fresh_name(src: ast::Ident) -> ast::Name {\n pub fn fresh_mark() -> ast::Mrk {\n     gensym(\"mark\").0\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast;\n-    use ext::mtwt;\n-\n-    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident::new(id.name, mtwt::apply_mark(m, id.ctxt))\n-    }\n-\n-    #[test] fn mtwt_token_eq_test() {\n-        assert!(Gt.mtwt_eq(&Gt));\n-        let a = str_to_ident(\"bac\");\n-        let a1 = mark_ident(a,92);\n-        assert!(Ident(a).mtwt_eq(&Ident(a1)));\n-    }\n-}"}, {"sha": "8866ffc2575cca42176d10f1c77c1162d67d2446", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -1638,9 +1638,8 @@ impl<'a> State<'a> {\n                     _ => token::Paren\n                 };\n                 try!(self.print_mac(&mac, delim));\n-                match style {\n-                    ast::MacStmtStyle::Braces => {}\n-                    _ => try!(word(&mut self.s, \";\")),\n+                if style == ast::MacStmtStyle::Semicolon {\n+                    try!(word(&mut self.s, \";\"));\n                 }\n             }\n         }"}, {"sha": "327696e87b08e26fc98ddbc9725f42a1c0a45580", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -185,6 +185,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         mod_folded\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n struct EntryPointCleaner {\n@@ -234,6 +236,8 @@ impl fold::Folder for EntryPointCleaner {\n \n         SmallVector::one(folded)\n     }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,"}, {"sha": "6bb409715aa39ce999a502b8fde12b3bde60748c", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 49, "deletions": 234, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -15,212 +15,72 @@\n use ast::Name;\n \n use std::borrow::Borrow;\n-use std::cell::RefCell;\n-use std::cmp::Ordering;\n use std::collections::HashMap;\n-use std::fmt;\n-use std::hash::Hash;\n-use std::ops::Deref;\n use std::rc::Rc;\n \n-pub struct Interner<T> {\n-    map: RefCell<HashMap<T, Name>>,\n-    vect: RefCell<Vec<T> >,\n-}\n-\n-// when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n-    pub fn new() -> Interner<T> {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    pub fn prefill(init: &[T]) -> Interner<T> {\n-        let rv = Interner::new();\n-        for v in init {\n-            rv.intern((*v).clone());\n-        }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = (*map).get(&val) {\n-            return idx;\n-        }\n-\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        (*map).insert(val.clone(), new_idx);\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: T) -> Name {\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        // leave out of .map to avoid colliding\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn get(&self, idx: Name) -> T {\n-        let vect = self.vect.borrow();\n-        (*vect)[idx.0 as usize].clone()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        let vect = self.vect.borrow();\n-        (*vect).len()\n-    }\n-\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where T: Borrow<Q>, Q: Eq + Hash {\n-        let map = self.map.borrow();\n-        match (*map).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-\n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Hash, PartialOrd)]\n-pub struct RcStr {\n-    string: Rc<String>,\n-}\n-\n-impl RcStr {\n-    pub fn new(string: &str) -> RcStr {\n-        RcStr {\n-            string: Rc::new(string.to_string()),\n-        }\n-    }\n-}\n-\n-impl Eq for RcStr {}\n-\n-impl Ord for RcStr {\n-    fn cmp(&self, other: &RcStr) -> Ordering {\n-        self[..].cmp(&other[..])\n-    }\n-}\n-\n-impl fmt::Debug for RcStr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n-\n-impl fmt::Display for RcStr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self[..].fmt(f)\n-    }\n-}\n+#[derive(PartialEq, Eq, Hash)]\n+struct RcStr(Rc<String>);\n \n impl Borrow<str> for RcStr {\n     fn borrow(&self) -> &str {\n-        &self.string[..]\n+        &self.0\n     }\n }\n \n-impl Deref for RcStr {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.string[..] }\n-}\n-\n-/// A StrInterner differs from Interner<String> in that it accepts\n-/// &str rather than RcStr, resulting in less allocation.\n-pub struct StrInterner {\n-    map: RefCell<HashMap<RcStr, Name>>,\n-    vect: RefCell<Vec<RcStr> >,\n+#[derive(Default)]\n+pub struct Interner {\n+    names: HashMap<RcStr, Name>,\n+    strings: Vec<Rc<String>>,\n }\n \n /// When traits can extend traits, we should extend index<Name,T> to get []\n-impl StrInterner {\n-    pub fn new() -> StrInterner {\n-        StrInterner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner::default()\n     }\n \n-    pub fn prefill(init: &[&str]) -> StrInterner {\n-        let rv = StrInterner::new();\n-        for &v in init { rv.intern(v); }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: &str) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = map.get(val) {\n-            return idx;\n+    pub fn prefill(init: &[&str]) -> Self {\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n         }\n-\n-        let new_idx = Name(self.len() as u32);\n-        let val = RcStr::new(val);\n-        map.insert(val.clone(), new_idx);\n-        self.vect.borrow_mut().push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: &str) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of .map to avoid colliding\n-        self.vect.borrow_mut().push(RcStr::new(val));\n-        new_idx\n+        this\n     }\n \n-    // I want these gensyms to share name pointers\n-    // with existing entries. This would be automatic,\n-    // except that the existing gensym creates its\n-    // own managed ptr using to_managed. I think that\n-    // adding this utility function is the most\n-    // lightweight way to get what I want, though not\n-    // necessarily the cleanest.\n-\n-    /// Create a gensym with the same name as an existing\n-    /// entry.\n-    pub fn gensym_copy(&self, idx : Name) -> Name {\n-        let new_idx = Name(self.len() as u32);\n-        // leave out of map to avoid colliding\n-        let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect)[idx.0 as usize].clone();\n-        vect.push(existing);\n-        new_idx\n-    }\n+    pub fn intern<T: Borrow<str> + Into<String>>(&mut self, string: T) -> Name {\n+        if let Some(&name) = self.names.get(string.borrow()) {\n+            return name;\n+        }\n \n-    pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow())[idx.0 as usize].clone()\n+        let name = Name(self.strings.len() as u32);\n+        let string = Rc::new(string.into());\n+        self.strings.push(string.clone());\n+        self.names.insert(RcStr(string), name);\n+        name\n     }\n \n-    pub fn len(&self) -> usize {\n-        self.vect.borrow().len()\n+    pub fn gensym(&mut self, string: &str) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(Rc::new(string.to_owned()));\n+        gensym\n     }\n \n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where RcStr: Borrow<Q>, Q: Eq + Hash {\n-        match (*self.map.borrow()).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n+    /// Create a gensym with the same name as an existing entry.\n+    pub fn gensym_copy(&mut self, name: Name) -> Name {\n+        let gensym = Name(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        let string = self.strings[name.0 as usize].clone();\n+        self.strings.push(string);\n+        gensym\n     }\n \n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n+    pub fn get(&self, name: Name) -> Rc<String> {\n+        self.strings[name.0 as usize].clone()\n     }\n \n-    pub fn reset(&self, other: StrInterner) {\n-        *self.map.borrow_mut() = other.map.into_inner();\n-        *self.vect.borrow_mut() = other.vect.into_inner();\n+    pub fn find(&self, string: &str) -> Option<Name> {\n+        self.names.get(string).cloned()\n     }\n }\n \n@@ -230,53 +90,8 @@ mod tests {\n     use ast::Name;\n \n     #[test]\n-    #[should_panic]\n-    fn i1 () {\n-        let i : Interner<RcStr> = Interner::new();\n-        i.get(Name(13));\n-    }\n-\n-    #[test]\n-    fn interner_tests () {\n-        let i : Interner<RcStr> = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(RcStr::new(\"dog\")), Name(4));\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n-    }\n-\n-    #[test]\n-    fn i3 () {\n-        let i : Interner<RcStr> = Interner::prefill(&[\n-            RcStr::new(\"Alan\"),\n-            RcStr::new(\"Bob\"),\n-            RcStr::new(\"Carol\")\n-        ]);\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"Alan\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"Bob\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"Carol\"));\n-        assert_eq!(i.intern(RcStr::new(\"Bob\")), Name(1));\n-    }\n-\n-    #[test]\n-    fn string_interner_tests() {\n-        let i : StrInterner = StrInterner::new();\n+    fn interner_tests() {\n+        let mut i: Interner = Interner::new();\n         // first one is zero:\n         assert_eq!(i.intern(\"dog\"), Name(0));\n         // re-use gets the same entry:\n@@ -294,13 +109,13 @@ mod tests {\n         assert_eq!(i.gensym(\"dog\"), Name(4));\n         // gensym tests again with gensym_copy:\n         assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(i.get(Name(5)), RcStr::new(\"zebra\"));\n+        assert_eq!(*i.get(Name(5)), \"zebra\");\n         assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(i.get(Name(6)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n+        assert_eq!(*i.get(Name(6)), \"zebra\");\n+        assert_eq!(*i.get(Name(0)), \"dog\");\n+        assert_eq!(*i.get(Name(1)), \"cat\");\n+        assert_eq!(*i.get(Name(2)), \"zebra\");\n+        assert_eq!(*i.get(Name(3)), \"zebra\");\n+        assert_eq!(*i.get(Name(4)), \"dog\");\n     }\n }"}, {"sha": "94bb78edaacdb617110784fc50dad9c8c8c0ac6b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 245, "deletions": 175, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -24,11 +24,12 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n-    Known(String),\n-    Unsigned\n+    Placeholder(String),\n+    Count,\n }\n \n enum Position {\n@@ -44,17 +45,25 @@ struct Context<'a, 'b:'a> {\n     /// The span of the format string literal.\n     fmtsp: Span,\n \n-    /// Parsed argument expressions and the types that we've found so far for\n-    /// them.\n+    /// List of parsed argument expressions.\n+    /// Named expressions are resolved early, and are appended to the end of\n+    /// argument expressions.\n+    ///\n+    /// Example showing the various data structures in motion:\n+    ///\n+    /// * Original: `\"{foo:o} {:o} {foo:x} {0:x} {1:o} {:x} {1:x} {0:o}\"`\n+    /// * Implicit argument resolution: `\"{foo:o} {0:o} {foo:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * Name resolution: `\"{2:o} {0:o} {2:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n+    /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n+    /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n+    /// * `names` (in JSON): `{\"foo\": 2}`\n     args: Vec<P<ast::Expr>>,\n-    arg_types: Vec<Option<ArgumentType>>,\n-    /// Parsed named expressions and the types that we've found for them so far.\n-    /// Note that we keep a side-array of the ordering of the named arguments\n-    /// found to be sure that we can translate them in the same order that they\n-    /// were declared in.\n-    names: HashMap<String, P<ast::Expr>>,\n-    name_types: HashMap<String, ArgumentType>,\n-    name_ordering: Vec<String>,\n+    /// Placeholder slot numbers indexed by argument.\n+    arg_types: Vec<Vec<usize>>,\n+    /// Unique format specs seen for each argument.\n+    arg_unique_types: Vec<Vec<ArgumentType>>,\n+    /// Map from named arguments to their resolved indices.\n+    names: HashMap<String, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -66,10 +75,41 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, usize>,\n+    /// Mapping between positional argument references and indices into the\n+    /// final generated static argument array. We record the starting indices\n+    /// corresponding to each positional argument, and number of references\n+    /// consumed so far for each argument, to facilitate correct `Position`\n+    /// mapping in `trans_piece`. In effect this can be seen as a \"flattened\"\n+    /// version of `arg_unique_types`.\n+    ///\n+    /// Again with the example described above in docstring for `args`:\n+    ///\n+    /// * `arg_index_map` (in JSON): `[[0, 1, 0], [2, 3, 3], [4, 5]]`\n+    arg_index_map: Vec<Vec<usize>>,\n+\n+    /// Starting offset of count argument slots.\n+    count_args_index_offset: usize,\n \n-    /// Updated as arguments are consumed\n-    next_arg: usize,\n+    /// Count argument slots and tracking data structures.\n+    /// Count arguments are separately tracked for de-duplication in case\n+    /// multiple references are made to one argument. For example, in this\n+    /// format string:\n+    ///\n+    /// * Original: `\"{:.*} {:.foo$} {1:.*} {:.0$}\"`\n+    /// * Implicit argument resolution: `\"{1:.0$} {2:.foo$} {1:.3$} {4:.0$}\"`\n+    /// * Name resolution: `\"{1:.0$} {2:.5$} {1:.3$} {4:.0$}\"`\n+    /// * `count_positions` (in JSON): `{0: 0, 5: 1, 3: 2}`\n+    /// * `count_args`: `vec![Exact(0), Exact(5), Exact(3)]`\n+    count_args: Vec<Position>,\n+    /// Relative slot numbers for count arguments.\n+    count_positions: HashMap<usize, usize>,\n+    /// Number of count slots assigned.\n+    count_positions_count: usize,\n+\n+    /// Current position of the implicit positional arg pointer, as if it\n+    /// still existed in this phase of processing.\n+    /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n+    curarg: usize,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -78,15 +118,12 @@ struct Context<'a, 'b:'a> {\n ///\n /// If parsing succeeds, the return value is:\n /// ```ignore\n-/// Some((fmtstr, unnamed arguments, ordering of named arguments,\n-///       named arguments))\n+/// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                         HashMap<String, P<ast::Expr>>)> {\n-    let mut args = Vec::new();\n-    let mut names = HashMap::<String, P<ast::Expr>>::new();\n-    let mut order = Vec::new();\n+              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, HashMap<String, usize>)> {\n+    let mut args = Vec::<P<ast::Expr>>::new();\n+    let mut names = HashMap::<String, usize>::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -130,23 +167,50 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                 ecx.struct_span_err(e.span,\n                                     &format!(\"duplicate argument named `{}`\",\n                                              name))\n-                    .span_note(prev.span, \"previously here\")\n+                    .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n                 continue;\n             }\n-            order.push(name.to_string());\n-            names.insert(name.to_string(), e);\n+\n+            // Resolve names into slots early.\n+            // Since all the positional args are already seen at this point\n+            // if the input is valid, we can simply append to the positional\n+            // args. And remember the names.\n+            let slot = args.len();\n+            names.insert(name.to_string(), slot);\n+            args.push(e);\n         } else {\n             args.push(panictry!(p.parse_expr()));\n         }\n     }\n-    Some((fmtstr, args, order, names))\n+    Some((fmtstr, args, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n-    /// Verifies one piece of a parse string. All errors are not emitted as\n-    /// fatal so we can continue giving errors about this and possibly other\n-    /// format strings.\n+    fn resolve_name_inplace(&self, p: &mut parse::Piece) {\n+        // NOTE: the `unwrap_or` branch is needed in case of invalid format\n+        // arguments, e.g. `format_args!(\"{foo}\")`.\n+        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+\n+        match *p {\n+            parse::String(_) => {}\n+            parse::NextArgument(ref mut arg) => {\n+                if let parse::ArgumentNamed(s) = arg.position {\n+                    arg.position = parse::ArgumentIs(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.width {\n+                    arg.format.width = parse::CountIsParam(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.precision {\n+                    arg.format.precision = parse::CountIsParam(lookup(s));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Verifies one piece of a parse string, and remembers it if valid.\n+    /// All errors are not emitted as fatal so we can continue giving errors\n+    /// about this and possibly other format strings.\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n@@ -159,16 +223,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n-                    parse::ArgumentNext => {\n-                        let i = self.next_arg;\n-                        self.next_arg += 1;\n-                        Exact(i)\n-                    }\n                     parse::ArgumentIs(i) => Exact(i),\n                     parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n \n-                let ty = Known(arg.format.ty.to_string());\n+                let ty = Placeholder(arg.format.ty.to_string());\n                 self.verify_arg_type(pos, ty);\n             }\n         }\n@@ -178,15 +237,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n-                self.verify_arg_type(Exact(i), Unsigned);\n+                self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_string()), Unsigned);\n-            }\n-            parse::CountIsNextParam => {\n-                let next_arg = self.next_arg;\n-                self.verify_arg_type(Exact(next_arg), Unsigned);\n-                self.next_arg += 1;\n+                self.verify_arg_type(Named(s.to_string()), Count);\n             }\n         }\n     }\n@@ -199,6 +253,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n+    /// Actually verifies and tracks a given format placeholder\n+    /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n@@ -209,84 +265,70 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n                 }\n-                {\n-                    let arg_type = match self.arg_types[arg] {\n-                        None => None,\n-                        Some(ref x) => Some(x)\n-                    };\n-                    self.verify_same(self.args[arg].span, &ty, arg_type);\n-                }\n-                if self.arg_types[arg].is_none() {\n-                    self.arg_types[arg] = Some(ty);\n+                match ty {\n+                    Placeholder(_) => {\n+                        // record every (position, type) combination only once\n+                        let ref mut seen_ty = self.arg_unique_types[arg];\n+                        let i = match seen_ty.iter().position(|x| *x == ty) {\n+                            Some(i) => i,\n+                            None => {\n+                                let i = seen_ty.len();\n+                                seen_ty.push(ty);\n+                                i\n+                            }\n+                        };\n+                        self.arg_types[arg].push(i);\n+                    }\n+                    Count => {\n+                        match self.count_positions.entry(arg) {\n+                            Entry::Vacant(e) => {\n+                                let i = self.count_positions_count;\n+                                e.insert(i);\n+                                self.count_args.push(Exact(arg));\n+                                self.count_positions_count += 1;\n+                            }\n+                            Entry::Occupied(_) => {}\n+                        }\n+                    }\n                 }\n             }\n \n             Named(name) => {\n-                let span = match self.names.get(&name) {\n-                    Some(e) => e.span,\n+                let idx = match self.names.get(&name) {\n+                    Some(e) => *e,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, &msg[..]);\n                         return;\n                     }\n                 };\n-                self.verify_same(span, &ty, self.name_types.get(&name));\n-                if !self.name_types.contains_key(&name) {\n-                    self.name_types.insert(name.clone(), ty);\n-                }\n-                // Assign this named argument a slot in the arguments array if\n-                // it hasn't already been assigned a slot.\n-                if !self.name_positions.contains_key(&name) {\n-                    let slot = self.name_positions.len();\n-                    self.name_positions.insert(name, slot);\n-                }\n+                // Treat as positional arg.\n+                self.verify_arg_type(Exact(idx), ty)\n             }\n         }\n     }\n \n-    /// When we're keeping track of the types that are declared for certain\n-    /// arguments, we assume that `None` means we haven't seen this argument\n-    /// yet, `Some(None)` means that we've seen the argument, but no format was\n-    /// specified, and `Some(Some(x))` means that the argument was declared to\n-    /// have type `x`.\n-    ///\n-    /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n-    /// that: `Some(None) == Some(Some(x))`\n-    fn verify_same(&self,\n-                   sp: Span,\n-                   ty: &ArgumentType,\n-                   before: Option<&ArgumentType>) {\n-        let cur = match before {\n-            None => return,\n-            Some(t) => t,\n-        };\n-        if *ty == *cur {\n-            return\n-        }\n-        match (cur, ty) {\n-            (&Known(ref cur), &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument redeclared with type `{}` when \\\n-                                           it was previously `{}`\",\n-                                          *ty,\n-                                          *cur));\n-            }\n-            (&Known(ref cur), _) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument used to format with `{}` was \\\n-                                           attempted to not be used for formatting\",\n-                                           *cur));\n-            }\n-            (_, &Known(ref ty)) => {\n-                self.ecx.span_err(sp,\n-                                  &format!(\"argument previously used as a format \\\n-                                           argument attempted to be used as `{}`\",\n-                                           *ty));\n-            }\n-            (_, _) => {\n-                self.ecx.span_err(sp, \"argument declared with multiple formats\");\n+    /// Builds the mapping between format placeholders and argument objects.\n+    fn build_index_map(&mut self) {\n+        // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n+        let args_len = self.args.len();\n+        self.arg_index_map.reserve(args_len);\n+\n+        let mut sofar = 0usize;\n+\n+        // Map the arguments\n+        for i in 0..args_len {\n+            let ref arg_types = self.arg_types[i];\n+            let mut arg_offsets = Vec::with_capacity(arg_types.len());\n+            for offset in arg_types {\n+                arg_offsets.push(sofar + *offset);\n             }\n+            self.arg_index_map.push(arg_offsets);\n+            sofar += self.arg_unique_types[i].len();\n         }\n+\n+        // Record starting index for counts, which appear just after arguments\n+        self.count_args_index_offset = sofar;\n     }\n \n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n@@ -306,18 +348,18 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => count(\"Implied\", None),\n-            parse::CountIsNextParam => count(\"NextParam\", None),\n-            parse::CountIsName(n) => {\n-                let i = match self.name_positions.get(n) {\n+                // This needs mapping too, as `i` is referring to a macro\n+                // argument.\n+                let i = match self.count_positions.get(&i) {\n                     Some(&i) => i,\n                     None => 0, // error already emitted elsewhere\n                 };\n-                let i = i + self.args.len();\n+                let i = i + self.count_args_index_offset;\n                 count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n+            parse::CountImplied => count(\"Implied\", None),\n+            // should never be the case, names are already resolved\n+            parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n     }\n \n@@ -331,7 +373,10 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     /// Translate a `parse::Piece` to a static `rt::Argument` or append\n     /// to the `literal` string.\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> Option<P<ast::Expr>> {\n+    fn trans_piece(&mut self,\n+                   piece: &parse::Piece,\n+                   arg_index_consumed: &mut Vec<usize>)\n+                   -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n         match *piece {\n             parse::String(s) => {\n@@ -355,25 +400,34 @@ impl<'a, 'b> Context<'a, 'b> {\n                         }\n                     };\n                     match arg.position {\n-                        // These two have a direct mapping\n-                        parse::ArgumentNext => pos(\"Next\", None),\n-                        parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n-\n-                        // Named arguments are converted to positional arguments\n-                        // at the end of the list of arguments\n-                        parse::ArgumentNamed(n) => {\n-                            let i = match self.name_positions.get(n) {\n-                                Some(&i) => i,\n+                        parse::ArgumentIs(i) => {\n+                            // Map to index in final generated argument array\n+                            // in case of multiple types specified\n+                            let arg_idx = match arg_index_consumed.get_mut(i) {\n                                 None => 0, // error already emitted elsewhere\n+                                Some(offset) => {\n+                                    let arg_idx = self.arg_index_map[i][*offset];\n+                                    *offset += 1;\n+                                    arg_idx\n+                                }\n                             };\n-                            let i = i + self.args.len();\n-                            pos(\"At\", Some(i))\n+                            pos(\"At\", Some(arg_idx))\n                         }\n+\n+                        // should never be the case, because names are already\n+                        // resolved.\n+                        parse::ArgumentNamed(_) => panic!(\"should never happen\"),\n                     }\n                 };\n \n                 let simple_arg = parse::Argument {\n-                    position: parse::ArgumentNext,\n+                    position: {\n+                        // We don't have ArgumentNext any more, so we have to\n+                        // track the current argument ourselves.\n+                        let i = self.curarg;\n+                        self.curarg += 1;\n+                        parse::ArgumentIs(i)\n+                    },\n                     format: parse::FormatSpec {\n                         fill: arg.format.fill,\n                         align: parse::AlignUnknown,\n@@ -449,11 +503,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.expr_block(ecx.block(sp, vec![stmt, ecx.stmt_expr(ecx.expr_ident(sp, name))]))\n     }\n \n-    /// Actually builds the expression which the iformat! block will be expanded\n-    /// to\n+    /// Actually builds the expression which the format_args! block will be\n+    /// expanded to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = vec![None; self.name_positions.len()];\n+        let mut counts = Vec::new();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -470,6 +524,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                                            piece_ty,\n                                            self.str_pieces);\n \n+        // Before consuming the expressions, we have to remember spans for\n+        // count arguments as they are now generated separate from other\n+        // arguments, hence have no access to the `P<ast::Expr>`'s.\n+        let spans_pos: Vec<_> = self.args.iter().map(|e| e.span.clone()).collect();\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -479,38 +537,29 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let arg_ty = match self.arg_types[i].as_ref() {\n-                Some(ty) => ty,\n-                None => continue // error already generated\n-            };\n-\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n-            locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                            self.ecx.expr_ident(e.span, name)));\n+            for ref arg_ty in self.arg_unique_types[i].iter() {\n+                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n+                                                self.ecx.expr_ident(e.span, name)));\n+            }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n-        for name in &self.name_ordering {\n-            let e = match self.names.remove(name) {\n-                Some(e) => e,\n-                None => continue\n+        for pos in self.count_args {\n+            let name = self.ecx.ident_of(&match pos {\n+                Exact(i) => format!(\"__arg{}\", i),\n+                _ => panic!(\"should never happen\"),\n+            });\n+            let span = match pos {\n+                Exact(i) => spans_pos[i],\n+                _ => panic!(\"should never happen\"),\n             };\n-            let arg_ty = match self.name_types.get(name) {\n-                Some(ty) => ty,\n-                None => continue\n-            };\n-\n-            let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n-                                                  *name));\n-            pats.push(self.ecx.pat_ident(DUMMY_SP, lname));\n-            names[*self.name_positions.get(name).unwrap()] =\n-                Some(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                         self.ecx.expr_ident(e.span, lname)));\n-            heads.push(self.ecx.expr_addr_of(e.span, e));\n+            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count,\n+                                            self.ecx.expr_ident(span, name)));\n         }\n \n         // Now create a vector containing all the arguments\n-        let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n+        let args = locals.into_iter().chain(counts.into_iter());\n \n         let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n \n@@ -573,7 +622,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   ty: &ArgumentType, arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n-            Known(ref tyname) => {\n+            Placeholder(ref tyname) => {\n                 match &tyname[..] {\n                     \"\"  => \"Display\",\n                     \"?\" => \"Debug\",\n@@ -592,7 +641,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 }\n             }\n-            Unsigned => {\n+            Count => {\n                 let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"from_usize\"]);\n                 return ecx.expr_call_global(macsp, path, vec![arg])\n             }\n@@ -610,9 +659,9 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n                                -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, tts) {\n-        Some((efmt, args, order, names)) => {\n+        Some((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt,\n-                                                      args, order, names))\n+                                                      args, names))\n         }\n         None => DummyResult::expr(sp)\n     }\n@@ -623,10 +672,12 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<String>,\n-                                    names: HashMap<String, P<ast::Expr>>)\n+                                    names: HashMap<String, usize>)\n                                     -> P<ast::Expr> {\n-    let arg_types: Vec<_> = (0..args.len()).map(|_| None).collect();\n+    // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n+    // `ArgumentType` does not derive `Clone`.\n+    let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n+    let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n     // Expand the format literal so that efmt.span will have a backtrace. This\n     // is essential for locating a bug when the format literal is generated in\n@@ -636,11 +687,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         ecx: ecx,\n         args: args,\n         arg_types: arg_types,\n+        arg_unique_types: arg_unique_types,\n         names: names,\n-        name_positions: HashMap::new(),\n-        name_types: HashMap::new(),\n-        name_ordering: name_ordering,\n-        next_arg: 0,\n+        curarg: 0,\n+        arg_index_map: Vec::new(),\n+        count_args: Vec::new(),\n+        count_positions: HashMap::new(),\n+        count_positions_count: 0,\n+        count_args_index_offset: 0,\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n@@ -656,21 +710,31 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     };\n \n     let mut parser = parse::Parser::new(&fmt);\n+    let mut pieces = vec![];\n \n     loop {\n         match parser.next() {\n-            Some(piece) => {\n+            Some(mut piece) => {\n                 if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n-                if let Some(piece) = cx.trans_piece(&piece) {\n-                    let s = cx.trans_literal_string();\n-                    cx.str_pieces.push(s);\n-                    cx.pieces.push(piece);\n-                }\n+                cx.resolve_name_inplace(&mut piece);\n+                pieces.push(piece);\n             }\n             None => break\n         }\n     }\n+\n+    cx.build_index_map();\n+\n+    let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+    for piece in pieces {\n+        if let Some(piece) = cx.trans_piece(&piece, &mut arg_index_consumed) {\n+            let s = cx.trans_literal_string();\n+            cx.str_pieces.push(s);\n+            cx.pieces.push(piece);\n+        }\n+    }\n+\n     if !parser.errors.is_empty() {\n         cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n                                           parser.errors.remove(0)));\n@@ -682,14 +746,20 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n \n     // Make sure that all arguments were used and all arguments have types.\n+    let num_pos_args = cx.args.len() - cx.names.len();\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.is_none() {\n-            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n-        }\n-    }\n-    for (name, e) in &cx.names {\n-        if !cx.name_types.contains_key(name) {\n-            cx.ecx.span_err(e.span, \"named argument never used\");\n+        if ty.len() == 0 {\n+            if cx.count_positions.contains_key(&i) {\n+                continue;\n+            }\n+            let msg = if i >= num_pos_args {\n+                // named argument\n+                \"named argument never used\"\n+            } else {\n+                // positional argument\n+                \"argument never used\"\n+            };\n+            cx.ecx.span_err(cx.args[i].span, msg);\n         }\n     }\n "}, {"sha": "248f6f98650a526778ae67e84d66f4eb2d3bea6b", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -959,6 +959,8 @@ fn get_concurrency() -> usize {\n               target_os = \"bitrig\",\n               target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n+        use std::ptr;\n+\n         let mut cpus: libc::c_uint = 0;\n         let mut cpus_size = std::mem::size_of_val(&cpus);\n \n@@ -972,7 +974,7 @@ fn get_concurrency() -> usize {\n                              2,\n                              &mut cpus as *mut _ as *mut _,\n                              &mut cpus_size as *mut _ as *mut _,\n-                             0 as *mut _,\n+                             ptr::null_mut(),\n                              0);\n             }\n             if cpus < 1 {\n@@ -984,6 +986,8 @@ fn get_concurrency() -> usize {\n \n     #[cfg(target_os = \"openbsd\")]\n     fn num_cpus() -> usize {\n+        use std::ptr;\n+\n         let mut cpus: libc::c_uint = 0;\n         let mut cpus_size = std::mem::size_of_val(&cpus);\n         let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n@@ -993,7 +997,7 @@ fn get_concurrency() -> usize {\n                          2,\n                          &mut cpus as *mut _ as *mut _,\n                          &mut cpus_size as *mut _ as *mut _,\n-                         0 as *mut _,\n+                         ptr::null_mut(),\n                          0);\n         }\n         if cpus < 1 {"}, {"sha": "4def60e485f7e0a05635c3648f5edf0669ea535a", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -350,6 +350,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"rustc_lint 0.0.0\","}, {"sha": "aaf88a67d27499e360c13d89271ec2b3521303f0", "filename": "src/stage0.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,6 +12,6 @@\n # tarball for a stable release you'll likely see `1.x.0-$date` where `1.x.0` was\n # released on `$date`\n \n-rustc: beta-2016-05-24\n-rustc_key: a4922355\n-cargo: nightly-2016-05-22\n+rustc: beta-2016-07-06\n+rustc_key: 411fd48b\n+cargo: nightly-2016-07-05"}, {"sha": "3c32cb947b382f1107473fd6d81d0437c0ca927e", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -16,6 +16,5 @@ pub use use_from_trait_xc::Trait;\n fn main() {\n     match () {\n         Trait { x: 42 } => () //~ ERROR expected variant, struct or type alias, found trait `Trait`\n-        //~^ ERROR `Trait` does not name a struct or a struct variant\n     }\n }"}, {"sha": "1049bcd15644fcdd87d25ddec4475fb05263f94f", "filename": "src/test/compile-fail/auxiliary/lint_stability.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Flint_stability.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -10,6 +10,7 @@\n #![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n #![feature(staged_api)]\n+#![feature(associated_type_defaults)]\n #![stable(feature = \"lint_stability\", since = \"1.0.0\")]\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n@@ -92,6 +93,15 @@ pub trait Trait {\n     fn trait_stable_text(&self) {}\n }\n \n+#[stable(feature = \"test_feature\", since = \"1.0.0\")]\n+pub trait TraitWithAssociatedTypes {\n+    #[unstable(feature = \"test_feature\", issue = \"0\")]\n+    type TypeUnstable = u8;\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n+    type TypeDeprecated = u8;\n+}\n+\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n impl Trait for MethodTester {}\n "}, {"sha": "74546152ca90fcf77b85c1742cd89768820c8e27", "filename": "src/test/compile-fail/empty-struct-braces-pat-1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-1.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -31,12 +31,14 @@ fn main() {\n         Empty1 => () // Not an error, `Empty1` is interpreted as a new binding\n     }\n     match e3 {\n-        E::Empty3 => () //~ ERROR `E::Empty3` does not name a tuple variant or a tuple struct\n+        E::Empty3 => ()\n+        //~^ ERROR `E::Empty3` does not name a unit variant, unit struct or a constant\n     }\n     match xe1 {\n         XEmpty1 => () // Not an error, `XEmpty1` is interpreted as a new binding\n     }\n     match xe3 {\n-        XE::XEmpty3 => () //~ ERROR `XE::XEmpty3` does not name a tuple variant or a tuple struct\n+        XE::XEmpty3 => ()\n+        //~^ ERROR `XE::XEmpty3` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "272ad980feb467c767f36088f10da6881dd3dade", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -23,9 +23,6 @@ fn main() {\n     format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n     format!(\"\", foo=2);                //~ ERROR: named argument never used\n \n-    format!(\"{0:x} {0:X}\", 1);         //~ ERROR: redeclared with type `X`\n-    format!(\"{foo:x} {foo:X}\", foo=1); //~ ERROR: redeclared with type `X`\n-\n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n "}, {"sha": "75081b10d862ed42a7648d7867f8020a62176c29", "filename": "src/test/compile-fail/import-trait-method.rs", "status": "renamed", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fimport-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fimport-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-trait-method.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo { B(u32) }\n-\n-fn bar(foo: Foo) -> u32 {\n-    match foo {\n-        Foo::B { i } => i, //~ ERROR E0163\n-    }\n+trait Foo {\n+    fn foo();\n }\n \n-fn main() {\n-}\n+use Foo::foo; //~ ERROR not directly importable\n+\n+fn main() { foo(); }", "previous_filename": "src/test/compile-fail/E0163.rs"}, {"sha": "671232e701f872b33721803aba16349e5ca33ed1", "filename": "src/test/compile-fail/issue-16058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -16,7 +16,7 @@ pub struct GslResult {\n \n impl GslResult {\n     pub fn new() -> GslResult {\n-        Result { //~ ERROR: `Result` does not name a structure\n+        Result { //~ ERROR: `Result` does not name a struct or a struct variant\n             val: 0f64,\n             err: 0f64\n         }"}, {"sha": "218f68714ff929821d1f9b5a975fa7ea0634afd8", "filename": "src/test/compile-fail/issue-17001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -11,5 +11,5 @@\n mod foo {}\n \n fn main() {\n-    let p = foo { x: () }; //~ ERROR `foo` does not name a structure\n+    let p = foo { x: () }; //~ ERROR `foo` does not name a struct or a struct variant\n }"}, {"sha": "2f2c252b947c90f38994c142985e6ae3fdd8cdb1", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -15,6 +15,5 @@ enum Foo {\n fn main() {\n     match Foo::Bar(1) {\n         Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n-        //~^ ERROR `Foo` does not name a struct or a struct variant\n     }\n }"}, {"sha": "090b8a0d16e64ca9a890fde406512ce8d22c82bb", "filename": "src/test/compile-fail/issue-21449.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -11,5 +11,5 @@\n mod MyMod {}\n \n fn main() {\n-    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a structure\n+    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a struct or a struct variant\n }"}, {"sha": "afb972faaca0ef71c24ad9d3dfab828e16da98ca", "filename": "src/test/compile-fail/issue-22933-1.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-1.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+struct CNFParser {\n+    token: char,\n+}\n+\n+impl CNFParser {\n+    fn is_whitespace(c: char) -> bool {\n+        c == ' ' || c == '\\n'\n+    }\n+\n+    fn consume_whitespace(&mut self) {\n+        self.consume_while(&(CNFParser::is_whitespace))\n+    }\n+\n+    fn consume_while(&mut self, p: &Fn(char) -> bool) {\n+        while p(self.token) {\n+            return\n+        }\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "7d619c270d32b962913e7999a206a1c0fa38762a", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Delicious {\n+    Pie      = 0x1,\n+    Apple    = 0x2,\n+    ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n+    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+}\n+\n+const FOO: [u32; u8::MIN as usize] = [];\n+//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+\n+fn main() {}"}, {"sha": "24b39eeff0f791c0e3508e77c6e99e82d11ec383", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     match 'a' {\n         char{ch} => true\n         //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n-        //~| ERROR `char` does not name a struct or a struct variant\n     };\n }"}, {"sha": "7a329bac61b22f64a0fa2eee6b1c512423005833", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -11,12 +11,10 @@\n mod A {}\n \n fn main() {\n-    let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n-    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n+    let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n+    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n     match () {\n         A { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found module `A`\n-        //~^ ERROR `A` does not name a struct or a struct variant\n         u32 { x: 1 } => {} //~ ERROR expected variant, struct or type alias, found builtin type `u32\n-        //~^ ERROR `u32` does not name a struct or a struct variant\n     }\n }"}, {"sha": "e20e6ea23198cd3c885fa4bea2d8d90ec4a94567", "filename": "src/test/compile-fail/issue-27831.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -18,7 +18,7 @@ enum Enum {\n \n fn main() {\n     let x = Foo(1);\n-    Foo { ..x }; //~ ERROR `Foo` does not name a structure\n+    Foo { ..x }; //~ ERROR `Foo` does not name a struct or a struct variant\n     let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n \n     let x = Bar;"}, {"sha": "576451f7292a894c1b8606e94401e5893849723b", "filename": "src/test/compile-fail/issue-32004.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32004.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -18,7 +18,7 @@ struct S;\n fn main() {\n     match Foo::Baz {\n         Foo::Bar => {}\n-        //~^ ERROR `Foo::Bar` does not name a tuple variant or a tuple struct\n+        //~^ ERROR `Foo::Bar` does not name a unit variant, unit struct or a constant\n         _ => {}\n     }\n "}, {"sha": "6fae18dec10a67e602338a3f15de815a623b1589", "filename": "src/test/compile-fail/issue-34209.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34209.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum S {\n+    A,\n+}\n+\n+fn bug(l: S) {\n+    match l {\n+        S::B{ } => { },\n+        //~^ ERROR ambiguous associated type; specify the type using the syntax `<S as Trait>::B`\n+    }\n+}\n+\n+fn main () {}"}, {"sha": "55983c672aa08a8553ce28932d2db5202f277b63", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -11,5 +11,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a structure\n+    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a struct or a struct variant\n }"}, {"sha": "505a91f223cc6ceb99afb37edf5540b923105301", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -10,7 +10,7 @@\n \n struct T { i: i32 }\n fn f<T>() {\n-    let t = T { i: 0 }; //~ ERROR `T` does not name a structure\n+    let t = T { i: 0 }; //~ ERROR `T` does not name a struct or a struct variant\n }\n \n mod Foo {"}, {"sha": "953cd4a2ff5eac744efb08592f9c7b13f58da167", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -128,6 +128,11 @@ mod cross_crate {\n         <Foo>::trait_stable_text(&foo);\n         <Foo as Trait>::trait_stable_text(&foo);\n \n+        struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n+        //~^ ERROR use of unstable library feature\n+        struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n+        //~^ ERROR use of deprecated item\n+\n         let _ = DeprecatedStruct { //~ ERROR use of deprecated item\n             i: 0 //~ ERROR use of deprecated item\n         };"}, {"sha": "c2ac99d1f6a2d2bdbfc9c4b0dfb8460b08dcab1d", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -19,7 +19,7 @@ macro_rules! ignored_item {\n }\n \n macro_rules! ignored_expr {\n-    () => ( 1,  //~ ERROR expected expression, found `,`\n+    () => ( 1,  //~ ERROR expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n             2 )\n }\n "}, {"sha": "ef011c89c622ba184eb6e986834946681cb8165e", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -22,12 +22,13 @@ impl MyTrait for Foo {}\n \n fn main() {\n     match 0u32 {\n-        Foo::bar => {} //~ ERROR E0327\n+        Foo::bar => {} //~ ERROR `Foo::bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::bar => {} //~ ERROR E0327\n+        <Foo>::bar => {} //~ ERROR `bar` does not name a unit variant, unit struct or a constant\n     }\n     match 0u32 {\n-        <Foo>::trait_bar => {} //~ ERROR E0327\n+        <Foo>::trait_bar => {}\n+        //~^ ERROR `trait_bar` does not name a unit variant, unit struct or a constant\n     }\n }"}, {"sha": "bbc958b87a571724e93134e4d1599e3c116a0817", "filename": "src/test/compile-fail/missing-semicolon-warning.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! m {\n+    ($($e1:expr),*; $($e2:expr),*) => {\n+        $( let x = $e1 )*; //~ WARN expected `;`\n+        $( println!(\"{}\", $e2) )*; //~ WARN expected `;`\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { m!(0, 0; 0, 0); } //~ ERROR compilation successful"}, {"sha": "9034e24a6fee03fab57aa7f722658c8a72b806f5", "filename": "src/test/compile-fail/qualified-path-params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqualified-path-params.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -27,7 +27,8 @@ impl S {\n \n fn main() {\n     match 10 {\n-        <S as Tr>::A::f::<u8> => {} //~ ERROR associated items in match patterns must be constants\n+        <S as Tr>::A::f::<u8> => {}\n+        //~^ ERROR `Tr::A::f<u8>` does not name a unit variant, unit struct or a constant\n         0 ... <S as Tr>::A::f::<u8> => {} //~ ERROR only char and numeric types are allowed in range\n     }\n }"}, {"sha": "d3f840f4fe9763eb651926233624cab49be00b25", "filename": "src/test/compile-fail/struct-pat-associated-path.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-pat-associated-path.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+fn f<T: Tr>() {\n+    match S {\n+        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+    }\n+}\n+\n+fn g<T: Tr<A = S>>() {\n+    match S {\n+        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+    }\n+}\n+\n+fn main() {\n+    match S {\n+        S::A {} => {} //~ ERROR ambiguous associated type\n+    }\n+}"}, {"sha": "d4a7c4ed0e0f9e61b12c614f58606d97f6312850", "filename": "src/test/compile-fail/trace_macros-gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -26,6 +26,5 @@ fn main() {\n         ($x: ident) => { trace_macros!($x) } //~ ERROR `trace_macros` is not stable\n     }\n \n-    expando!(true); //~ NOTE in this expansion\n-                    //~^ NOTE in this expansion\n+    expando!(true);\n }"}, {"sha": "13fdaa302f70a72ee0a800f21b42a93de4c9050d", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -12,5 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: `TraitNotAStruct` does not name a structure [E0071]\n+    //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n }"}, {"sha": "f2cffeefe9080ca9a1bf1ebdb2eea0e7af4b389a", "filename": "src/test/compile-fail/variant-size-differences.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariant-size-differences.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(variant_size_differences)]\n+\n+enum _En {\n+    V0(u8),\n+    VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n+}\n+\n+fn main() {}"}, {"sha": "7b7bda302250fd8a30c62432d9a588567c320c11", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -21,7 +21,6 @@\n // This test makes sure that the compiler doesn't crash when trying to assign\n // debug locations to const-expressions.\n \n-use std::sync::StaticMutex;\n use std::cell::UnsafeCell;\n \n const CONSTANT: u64 = 3 + 4;\n@@ -63,6 +62,5 @@ fn main() {\n     let mut _string = STRING;\n     let mut _vec = VEC;\n     let mut _nested = NESTED;\n-    let mut _extern = StaticMutex::new();\n     let mut _unsafe_cell = UNSAFE_CELL;\n }"}, {"sha": "2e90b51843263b48ec9f84938050e8713879b414", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -30,18 +30,16 @@ use std::thread::Builder;\n \n use rustc::dep_graph::DepGraph;\n use rustc::hir::map as ast_map;\n-use rustc::middle::cstore::{CrateStore, LinkagePreference};\n+use rustc::middle::cstore::LinkagePreference;\n use rustc::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc_resolve::MakeGlobMap;\n-use rustc_metadata::creader::read_local_crates;\n use rustc_metadata::cstore::CStore;\n use libc::c_void;\n \n use rustc_errors::registry::Registry;\n-use syntax::parse::token;\n \n fn main() {\n     // Currently trips an assertion on i686-msvc, presumably because the support\n@@ -226,7 +224,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n     let handle = thread.spawn(move || {\n         let opts = build_exec_options(sysroot);\n         let dep_graph = DepGraph::new(opts.build_dep_graph());\n-        let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+        let cstore = Rc::new(CStore::new(&dep_graph));\n         let sess = build_session(opts,\n                                  &dep_graph,\n                                  None,"}, {"sha": "d5220316a20ff083381235e0bd499cff04721629", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -23,7 +23,6 @@ use rustc::session::config::{basic_options, build_configuration, Input, OutputTy\n use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n-use syntax::parse::token;\n \n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -57,7 +56,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph, token::get_ident_interner()));\n+    let cstore = Rc::new(CStore::new(&dep_graph));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)"}, {"sha": "9131b609c4ce1895d5f6787404f11e2340cf7075", "filename": "src/test/run-pass/auxiliary/issue34796aux.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue34796aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue34796aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue34796aux.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+pub trait Future {\n+    type Item;\n+    type Error;\n+}\n+\n+impl Future for u32 {\n+    type Item = ();\n+    type Error = Box<()>;\n+}\n+\n+fn foo() -> Box<Future<Item=(), Error=Box<()>>> {\n+    Box::new(0u32)\n+}\n+\n+pub fn bar<F, A, B>(_s: F)\n+    where F: Fn(A) -> B,\n+{\n+    foo();\n+}"}, {"sha": "d72386190ecd2768326ca42afec211098279a76d", "filename": "src/test/run-pass/hygiene.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -106,6 +106,13 @@ fn match_hygiene() {\n     m!(Ok(x), x);\n }\n \n+fn label_hygiene() {\n+    'a: loop {\n+        macro_rules! m { () => { break 'a; } }\n+        m!();\n+    }\n+}\n+\n fn main() {\n     f();\n     g();"}, {"sha": "0a69ccf47dd9f99959e154c3b12e949670a377c4", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -163,6 +163,24 @@ pub fn main() {\n     t!(format!(\"{:?}\", 0.0), \"0\");\n \n \n+    // Ergonomic format_args!\n+    t!(format!(\"{0:x} {0:X}\", 15), \"f F\");\n+    t!(format!(\"{0:x} {0:X} {}\", 15), \"f F 15\");\n+    // NOTE: For now the longer test cases must not be followed immediately by\n+    // >1 empty lines, or the pretty printer will break. Since no one wants to\n+    // touch the current pretty printer (#751), we have no choice but to work\n+    // around it. Some of the following test cases are also affected.\n+    t!(format!(\"{:x}{0:X}{a:x}{:X}{1:x}{a:X}\", 13, 14, a=15), \"dDfEeF\");\n+    t!(format!(\"{a:x} {a:X}\", a=15), \"f F\");\n+\n+    // And its edge cases\n+    t!(format!(\"{a:.0$} {b:.0$} {0:.0$}\\n{a:.c$} {b:.c$} {c:.c$}\",\n+               4, a=\"abcdefg\", b=\"hijklmn\", c=3),\n+               \"abcd hijk 4\\nabc hij 3\");\n+    t!(format!(\"{a:.*} {0} {:.*}\", 4, 3, \"efgh\", a=\"abcdef\"), \"abcd 4 efg\");\n+    t!(format!(\"{:.a$} {a} {a:#x}\", \"aaaaaa\", a=2), \"aa 2 0x2\");\n+\n+\n     // Test that pointers don't get truncated.\n     {\n         let val = usize::MAX;\n@@ -177,6 +195,7 @@ pub fn main() {\n     test_write();\n     test_print();\n     test_order();\n+    test_once();\n \n     // make sure that format! doesn't move out of local variables\n     let a: Box<_> = box 3;\n@@ -260,3 +279,17 @@ fn test_order() {\n                        foo(), foo(), foo(), a=foo(), b=foo(), c=foo()),\n                \"1 2 4 5 3 6\".to_string());\n }\n+\n+fn test_once() {\n+    // Make sure each argument are evaluted only once even though it may be\n+    // formatted multiple times\n+    fn foo() -> isize {\n+        static mut FOO: isize = 0;\n+        unsafe {\n+            FOO += 1;\n+            FOO\n+        }\n+    }\n+    assert_eq!(format!(\"{0} {0} {0} {a} {a} {a}\", foo(), a=foo()),\n+               \"1 1 1 2 2 2\".to_string());\n+}"}, {"sha": "41d02e96cc2ed0f73fa302e189db312ebcc90b9c", "filename": "src/test/run-pass/issue34569.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fissue34569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fissue34569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue34569.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-g\n+\n+// In this test we just want to make sure that the code below does not lead to\n+// a debuginfo verification assertion during compilation. This was caused by the\n+// closure in the guard being translated twice due to how match expressions are\n+// handled.\n+//\n+// See https://github.com/rust-lang/rust/issues/34569 for details.\n+\n+fn main() {\n+    match 0 {\n+        e if (|| { e == 0 })() => {},\n+        1 => {},\n+        _ => {}\n+    }\n+}"}, {"sha": "0fb6ccc0dc8bdd0963ab9d673e755fd267a6c3af", "filename": "src/test/run-pass/issue34796.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fissue34796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fissue34796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue34796.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test case exposes conditions where the encoding of a trait object type\n+// with projection predicates would differ between this crate and the upstream\n+// crate, because the predicates were encoded in different order within each\n+// crate. This led to different symbol hashes of functions using these type,\n+// which in turn led to linker errors because the two crates would not agree on\n+// the symbol name.\n+// The fix was to make the order in which predicates get encoded stable.\n+\n+// aux-build:issue34796aux.rs\n+extern crate issue34796aux;\n+\n+fn mk<T>() -> T { loop {} }\n+\n+struct Data<T, E> {\n+    data: T,\n+    error: E,\n+}\n+\n+fn main() {\n+    issue34796aux::bar(|()| {\n+        Data::<(), std::io::Error> {\n+            data: mk(),\n+            error: mk(),\n+        }\n+    })\n+}"}, {"sha": "493a00ac5d00d947123391101f6ebd60da2c830c", "filename": "src/test/run-pass/panic-safe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-safe.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -36,6 +36,8 @@ fn main() {\n     assert::<Box<i32>>();\n     assert::<Mutex<i32>>();\n     assert::<RwLock<i32>>();\n+    assert::<&Mutex<i32>>();\n+    assert::<&RwLock<i32>>();\n     assert::<Rc<i32>>();\n     assert::<Arc<i32>>();\n "}, {"sha": "03884e8205bd27a866e5e8cf647c03f5364eb4b7", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -18,9 +18,6 @@ use std::sync;\n fn assert_both<T: Sync + Send>() {}\n \n fn main() {\n-    assert_both::<sync::StaticMutex>();\n-    assert_both::<sync::StaticCondvar>();\n-    assert_both::<sync::StaticRwLock>();\n     assert_both::<sync::Mutex<()>>();\n     assert_both::<sync::Condvar>();\n     assert_both::<sync::RwLock<()>>();"}, {"sha": "94b7278e9904b2bfba32c4f0039d7c85ef632151", "filename": "src/test/rustdoc/auxiliary/extern-links.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fextern-links.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Foo;"}, {"sha": "c35a5668dced7d770d3b6b32ea03b79360101869", "filename": "src/test/rustdoc/extern-links.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fextern-links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fextern-links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-links.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:extern-links.rs\n+// ignore-cross-compile\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate extern_links;\n+\n+// @!has foo/index.html '//a' 'extern_links'\n+#[doc(no_inline)]\n+pub use extern_links as extern_links2;\n+\n+// @!has foo/index.html '//a' 'Foo'\n+#[doc(no_inline)]\n+pub use extern_links::Foo;\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    // @!has foo/hidden/extern_links/index.html\n+    // @!has foo/hidden/extern_links/struct.Foo.html\n+    pub use extern_links;\n+}"}, {"sha": "c6da6b0575b87c3bef842f051525a3ae3df97920", "filename": "src/test/rustdoc/issue-33302.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33302.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -34,8 +34,8 @@ macro_rules! make {\n         }\n \n         // @has issue_33302/struct.S.html \\\n-        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 4 * 4]> for S'\n-        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 4 * 4] = [0; 4 * 4]'\n+        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 16]> for S'\n+        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 16] = [0; 4 * 4]'\n         // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n         impl T<[i32; ($n * $n)]> for S {\n             const C: [i32; ($n * $n)] = [0; ($n * $n)];"}, {"sha": "3a70e54ff9745d457b24f0f320eee2fbec43e74d", "filename": "src/tools/tidy/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -25,7 +25,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n                 &mut |file| {\n         let filename = file.file_name().unwrap().to_string_lossy();\n-        if filename != \"diagnostics.rs\" {\n+        if filename != \"diagnostics.rs\" && filename != \"diagnostic_list.rs\" {\n             return\n         }\n "}, {"sha": "199e8a77df71797b7eed2b5d7107e634f6a1a6dc", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c4d621a9622bbc444479c34e46d2e0f86606c44/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=5c4d621a9622bbc444479c34e46d2e0f86606c44", "patch": "@@ -46,7 +46,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n                 &mut |file| {\n         let filename = file.file_name().unwrap().to_string_lossy();\n-        if !filename.ends_with(\".rs\") || filename == \"features.rs\" {\n+        if !filename.ends_with(\".rs\") || filename == \"features.rs\" ||\n+           filename == \"diagnostic_list.rs\" {\n             return\n         }\n "}]}