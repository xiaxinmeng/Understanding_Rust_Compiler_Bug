{"sha": "7a36141465d1f97936cfceca87ed428dbfafdd3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMzYxNDE0NjVkMWY5NzkzNmNmY2VjYTg3ZWQ0MjhkYmZhZmRkM2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-09T16:56:41Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:55Z"}, "message": "rustc: unpack scalar pair newtype layout ABIs.", "tree": {"sha": "48b14db2d6ed30d196da76dc7f0b184c11e10988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b14db2d6ed30d196da76dc7f0b184c11e10988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a36141465d1f97936cfceca87ed428dbfafdd3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a36141465d1f97936cfceca87ed428dbfafdd3f", "html_url": "https://github.com/rust-lang/rust/commit/7a36141465d1f97936cfceca87ed428dbfafdd3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a36141465d1f97936cfceca87ed428dbfafdd3f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "html_url": "https://github.com/rust-lang/rust/commit/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc"}], "stats": {"total": 341, "additions": 185, "deletions": 156}, "files": [{"sha": "fc5d421394959ea0589d5e56a5c1d4d7ab88ef55", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -1087,10 +1087,11 @@ impl<'a, 'tcx> CachedLayout {\n                     // We have exactly one non-ZST field.\n                     match (non_zst_fields.next(), non_zst_fields.next()) {\n                         (Some(field), None) => {\n-                            // Field size match and it has a scalar ABI.\n+                            // Field size matches and it has a scalar or scalar pair ABI.\n                             if size == field.size {\n                                 match field.abi {\n-                                    Abi::Scalar(_) => {\n+                                    Abi::Scalar(_) |\n+                                    Abi::ScalarPair(..) => {\n                                         abi = field.abi.clone();\n                                     }\n                                     _ => {}\n@@ -2228,17 +2229,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TyAdt(def, substs) => {\n                 match self.variants {\n                     Variants::Single { index } => {\n-                        let mut field_ty = def.variants[index].fields[i].ty(tcx, substs);\n-\n-                        // Treat NonZero<*T> as containing &T.\n-                        // This is especially useful for fat pointers.\n-                        if Some(def.did) == tcx.lang_items().non_zero() {\n-                            if let ty::TyRawPtr(mt) = field_ty.sty {\n-                                field_ty = tcx.mk_ref(tcx.types.re_erased, mt);\n-                            }\n-                        }\n-\n-                        field_ty\n+                        def.variants[index].fields[i].ty(tcx, substs)\n                     }\n \n                     // Discriminant field for enums (where applicable).\n@@ -2294,21 +2285,22 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         where C: LayoutOf<Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n                  HasTyCtxt<'tcx>\n     {\n-        if let Abi::Scalar(Scalar { value, ref valid_range }) = self.abi {\n+        let scalar_component = |scalar: &Scalar, offset| {\n             // FIXME(eddyb) support negative/wrap-around discriminant ranges.\n-            return if valid_range.start < valid_range.end {\n+            let Scalar { value, ref valid_range } = *scalar;\n+            if valid_range.start < valid_range.end {\n                 let bits = value.size(cx).bits();\n                 assert!(bits <= 128);\n                 let max_value = !0u128 >> (128 - bits);\n                 if valid_range.start > 0 {\n                     let niche = valid_range.start - 1;\n-                    Ok(Some((self.fields.offset(0), Scalar {\n+                    Ok(Some((offset, Scalar {\n                         value,\n                         valid_range: niche..=valid_range.end\n                     }, niche)))\n                 } else if valid_range.end < max_value {\n                     let niche = valid_range.end + 1;\n-                    Ok(Some((self.fields.offset(0), Scalar {\n+                    Ok(Some((offset, Scalar {\n                         value,\n                         valid_range: valid_range.start..=niche\n                     }, niche)))\n@@ -2317,7 +2309,20 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                 }\n             } else {\n                 Ok(None)\n-            };\n+            }\n+        };\n+\n+        match self.abi {\n+            Abi::Scalar(ref scalar) => {\n+                return scalar_component(scalar, Size::from_bytes(0));\n+            }\n+            Abi::ScalarPair(ref a, ref b) => {\n+                if let Some(result) = scalar_component(a, Size::from_bytes(0))? {\n+                    return Ok(Some(result));\n+                }\n+                return scalar_component(b, a.value.size(cx).abi_align(b.value.align(cx)));\n+            }\n+            _ => {}\n         }\n \n         // Perhaps one of the fields is non-zero, let's recurse and find out."}, {"sha": "b7408681ed0c8a214e24237f94953dc28a4cd499", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -240,6 +240,31 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n             let ptr_ty = bcx.ccx.layout_of(b).llvm_type(bcx.ccx).ptr_to();\n             (bcx.pointercast(src, ptr_ty), unsized_info(bcx.ccx, a, b, None))\n         }\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_layout = bcx.ccx.layout_of(src_ty);\n+            let dst_layout = bcx.ccx.layout_of(dst_ty);\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(bcx.ccx, i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(bcx.ccx, i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(bcx, src, src_f.ty, dst_f.ty));\n+            }\n+            let (lldata, llextra) = result.unwrap();\n+            // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            (bcx.bitcast(lldata, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 0)),\n+             bcx.bitcast(llextra, dst_layout.scalar_pair_element_llvm_type(bcx.ccx, 1)))\n+        }\n         _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n     }\n }"}, {"sha": "67e0f35b46ef9de28e8101df963b678995622c2a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -685,46 +685,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let tuple = self.trans_operand(bcx, operand);\n \n         // Handle both by-ref and immediate tuples.\n-        match tuple.val {\n-            Ref(llval, align) => {\n-                let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n-                for i in 0..tuple.layout.fields.count() {\n-                    let field_ptr = tuple_ptr.project_field(bcx, i);\n-                    self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n-                }\n-\n+        if let Ref(llval, align) = tuple.val {\n+            let tuple_ptr = LvalueRef::new_sized(llval, tuple.layout, align);\n+            for i in 0..tuple.layout.fields.count() {\n+                let field_ptr = tuple_ptr.project_field(bcx, i);\n+                self.trans_argument(bcx, field_ptr.load(bcx), llargs, &args[i]);\n             }\n-            Immediate(llval) => {\n-                for i in 0..tuple.layout.fields.count() {\n-                    let field = tuple.layout.field(bcx.ccx, i);\n-                    let elem = if field.is_zst() {\n-                        C_undef(field.llvm_type(bcx.ccx))\n-                    } else {\n-                        // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                        bcx.bitcast(llval, field.immediate_llvm_type(bcx.ccx))\n-                    };\n-                    // If the tuple is immediate, the elements are as well\n-                    let op = OperandRef {\n-                        val: Immediate(elem),\n-                        layout: field,\n-                    };\n-                    self.trans_argument(bcx, op, llargs, &args[i]);\n-                }\n-            }\n-            Pair(a, b) => {\n-                let elems = [a, b];\n-                assert_eq!(tuple.layout.fields.count(), 2);\n-                for i in 0..2 {\n-                    // Pair is always made up of immediates\n-                    let op = OperandRef {\n-                        val: Immediate(elems[i]),\n-                        layout: tuple.layout.field(bcx.ccx, i),\n-                    };\n-                    self.trans_argument(bcx, op, llargs, &args[i]);\n-                }\n+        } else {\n+            // If the tuple is immediate, the elements are as well.\n+            for i in 0..tuple.layout.fields.count() {\n+                let op = tuple.extract_field(bcx, i);\n+                self.trans_argument(bcx, op, llargs, &args[i]);\n             }\n         }\n-\n     }\n \n     fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> LvalueRef<'tcx> {"}, {"sha": "54907cb747c75de772bd0b47dd3b300b9f42eda8", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -127,8 +127,12 @@ impl<'a, 'tcx> Const<'tcx> {\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let offset = layout.fields.offset(i);\n                 if offset.bytes() == 0 {\n-                    assert_eq!(field.size, a.value.size(ccx));\n-                    const_get_elt(self.llval, 0)\n+                    if field.size == layout.size {\n+                        self.llval\n+                    } else {\n+                        assert_eq!(field.size, a.value.size(ccx));\n+                        const_get_elt(self.llval, 0)\n+                    }\n                 } else {\n                     assert_eq!(offset, a.value.size(ccx)\n                         .abi_align(b.value.align(ccx)));\n@@ -166,8 +170,9 @@ impl<'a, 'tcx> Const<'tcx> {\n         let llvalty = val_ty(self.llval);\n \n         let val = if llty == llvalty && layout.is_llvm_scalar_pair() {\n-            let (a, b) = self.get_pair(ccx);\n-            OperandValue::Pair(a, b)\n+            OperandValue::Pair(\n+                const_get_elt(self.llval, 0),\n+                const_get_elt(self.llval, 1))\n         } else if llty == llvalty && layout.is_llvm_immediate() {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)"}, {"sha": "71d2fda09c9d2c71f5aa37a254feb1ccc24860fe", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -135,6 +135,31 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             return OperandRef::new_zst(bcx.ccx, self.layout);\n         }\n \n+        let scalar_load_metadata = |load, scalar: &layout::Scalar| {\n+            let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n+            let max_next = max.wrapping_add(1);\n+            let bits = scalar.value.size(bcx.ccx).bits();\n+            assert!(bits <= 128);\n+            let mask = !0u128 >> (128 - bits);\n+            // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n+            // However, that is fine here (it would still represent the full range),\n+            // i.e., if the range is everything.  The lo==hi case would be\n+            // rejected by the LLVM verifier (it would mean either an\n+            // empty set, which is impossible, or the entire range of the\n+            // type, which is pointless).\n+            match scalar.value {\n+                layout::Int(..) if max_next & mask != min & mask => {\n+                    // llvm::ConstantRange can deal with ranges that wrap around,\n+                    // so an overflow on (max + 1) is fine.\n+                    bcx.range_metadata(load, min..max_next);\n+                }\n+                layout::Pointer if 0 < min && min < max => {\n+                    bcx.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        };\n+\n         let val = if self.layout.is_llvm_immediate() {\n             let mut const_llval = ptr::null_mut();\n             unsafe {\n@@ -149,39 +174,27 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             } else {\n                 let load = bcx.load(self.llval, self.alignment.non_abi());\n                 if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n-                    let (min, max) = (scalar.valid_range.start, scalar.valid_range.end);\n-                    let max_next = max.wrapping_add(1);\n-                    let bits = scalar.value.size(bcx.ccx).bits();\n-                    assert!(bits <= 128);\n-                    let mask = !0u128 >> (128 - bits);\n-                    // For a (max) value of -1, max will be `-1 as usize`, which overflows.\n-                    // However, that is fine here (it would still represent the full range),\n-                    // i.e., if the range is everything.  The lo==hi case would be\n-                    // rejected by the LLVM verifier (it would mean either an\n-                    // empty set, which is impossible, or the entire range of the\n-                    // type, which is pointless).\n-                    match scalar.value {\n-                        layout::Int(..) if max_next & mask != min & mask => {\n-                            // llvm::ConstantRange can deal with ranges that wrap around,\n-                            // so an overflow on (max + 1) is fine.\n-                            bcx.range_metadata(load, min..max_next);\n-                        }\n-                        layout::Pointer if 0 < min && min < max => {\n-                            bcx.nonnull_metadata(load);\n-                        }\n-                        _ => {}\n-                    }\n+                    scalar_load_metadata(load, scalar);\n                 }\n                 load\n             };\n             OperandValue::Immediate(base::to_immediate(bcx, llval, self.layout))\n-        } else if self.layout.is_llvm_scalar_pair() {\n-            let load = |i| {\n-                let x = self.project_field(bcx, i).load(bcx).immediate();\n-                // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                bcx.bitcast(x, self.layout.scalar_pair_element_llvm_type(bcx.ccx, i))\n+        } else if let layout::Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n+            let load = |i, scalar: &layout::Scalar| {\n+                let mut llptr = bcx.struct_gep(self.llval, i as u64);\n+                // Make sure to always load i1 as i8.\n+                if scalar.is_bool() {\n+                    llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                }\n+                let load = bcx.load(llptr, self.alignment.non_abi());\n+                scalar_load_metadata(load, scalar);\n+                if scalar.is_bool() {\n+                    bcx.trunc(load, Type::i1(bcx.ccx))\n+                } else {\n+                    load\n+                }\n             };\n-            OperandValue::Pair(load(0), load(1))\n+            OperandValue::Pair(load(0, a), load(1, b))\n         } else {\n             OperandValue::Ref(self.llval, self.alignment)\n         };"}, {"sha": "8c43bded1bf217415ab4ca75e25eb5a6623e0e7e", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -15,10 +15,11 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{CrateContext, C_undef, C_usize};\n+use common::{self, CrateContext, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n+use type_::Type;\n \n use std::fmt;\n use std::ptr;\n@@ -84,7 +85,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(C_undef(layout.llvm_type(ccx))),\n+            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(ccx))),\n             layout\n         }\n     }\n@@ -148,6 +149,66 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         };\n         OperandRef { val, layout }\n     }\n+\n+    pub fn extract_field(&self, bcx: &Builder<'a, 'tcx>, i: usize) -> OperandRef<'tcx> {\n+        let field = self.layout.field(bcx.ccx, i);\n+        let offset = self.layout.fields.offset(i);\n+\n+        let mut val = match (self.val, &self.layout.abi) {\n+            // If we're uninhabited, or the field is ZST, it has no data.\n+            _ if self.layout.abi == layout::Abi::Uninhabited || field.is_zst() => {\n+                return OperandRef {\n+                    val: OperandValue::Immediate(C_undef(field.immediate_llvm_type(bcx.ccx))),\n+                    layout: field\n+                };\n+            }\n+\n+            // Newtype of a scalar or scalar pair.\n+            (OperandValue::Immediate(_), _) |\n+            (OperandValue::Pair(..), _) if field.size == self.layout.size => {\n+                assert_eq!(offset.bytes(), 0);\n+                self.val\n+            }\n+\n+            // Extract a scalar component from a pair.\n+            (OperandValue::Pair(a_llval, b_llval), &layout::Abi::ScalarPair(ref a, ref b)) => {\n+                if offset.bytes() == 0 {\n+                    assert_eq!(field.size, a.value.size(bcx.ccx));\n+                    OperandValue::Immediate(a_llval)\n+                } else {\n+                    assert_eq!(offset, a.value.size(bcx.ccx)\n+                        .abi_align(b.value.align(bcx.ccx)));\n+                    assert_eq!(field.size, b.value.size(bcx.ccx));\n+                    OperandValue::Immediate(b_llval)\n+                }\n+            }\n+\n+            // `#[repr(simd)]` types are also immediate.\n+            (OperandValue::Immediate(llval), &layout::Abi::Vector) => {\n+                OperandValue::Immediate(\n+                    bcx.extract_element(llval, C_usize(bcx.ccx, i as u64)))\n+            }\n+\n+            _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n+        };\n+\n+        // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+        match val {\n+            OperandValue::Immediate(ref mut llval) => {\n+                *llval = bcx.bitcast(*llval, field.immediate_llvm_type(bcx.ccx));\n+            }\n+            OperandValue::Pair(ref mut a, ref mut b) => {\n+                *a = bcx.bitcast(*a, field.scalar_pair_element_llvm_type(bcx.ccx, 0));\n+                *b = bcx.bitcast(*b, field.scalar_pair_element_llvm_type(bcx.ccx, 1));\n+            }\n+            OperandValue::Ref(..) => bug!()\n+        }\n+\n+        OperandRef {\n+            val,\n+            layout: field\n+        }\n+    }\n }\n \n impl<'a, 'tcx> OperandValue {\n@@ -167,11 +228,12 @@ impl<'a, 'tcx> OperandValue {\n             }\n             OperandValue::Pair(a, b) => {\n                 for (i, &x) in [a, b].iter().enumerate() {\n-                    let field = dest.project_field(bcx, i);\n-                    // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                    let x = bcx.bitcast(x, field.layout.immediate_llvm_type(bcx.ccx));\n-                    bcx.store(base::from_immediate(bcx, x),\n-                              field.llval, field.alignment.non_abi());\n+                    let mut llptr = bcx.struct_gep(dest.llval, i as u64);\n+                    // Make sure to always store i1 as i8.\n+                    if common::val_ty(x) == Type::i1(bcx.ccx) {\n+                        llptr = bcx.pointercast(llptr, Type::i8p(bcx.ccx));\n+                    }\n+                    bcx.store(base::from_immediate(bcx, x), llptr, dest.alignment.non_abi());\n                 }\n             }\n         }\n@@ -202,52 +264,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         }\n \n-        // Moves out of pair fields are trivial.\n+        // Moves out of scalar and scalar pair fields are trivial.\n         if let &mir::Lvalue::Projection(ref proj) = lvalue {\n             if let mir::ProjectionElem::Field(ref f, _) = proj.elem {\n                 if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n-                    let layout = o.layout.field(bcx.ccx, f.index());\n-                    let offset = o.layout.fields.offset(f.index());\n-\n-                    // Handled in `trans_consume`.\n-                    assert!(!layout.is_zst());\n-\n-                    // Offset has to match a scalar component.\n-                    let llval = match (o.val, &o.layout.abi) {\n-                        (OperandValue::Immediate(llval),\n-                         &layout::Abi::Scalar(ref scalar)) => {\n-                            assert_eq!(offset.bytes(), 0);\n-                            assert_eq!(layout.size, scalar.value.size(bcx.ccx));\n-                            llval\n-                        }\n-                        (OperandValue::Pair(a_llval, b_llval),\n-                         &layout::Abi::ScalarPair(ref a, ref b)) => {\n-                            if offset.bytes() == 0 {\n-                                assert_eq!(layout.size, a.value.size(bcx.ccx));\n-                                a_llval\n-                            } else {\n-                                assert_eq!(offset, a.value.size(bcx.ccx)\n-                                    .abi_align(b.value.align(bcx.ccx)));\n-                                assert_eq!(layout.size, b.value.size(bcx.ccx));\n-                                b_llval\n-                            }\n-                        }\n-\n-                        // `#[repr(simd)]` types are also immediate.\n-                        (OperandValue::Immediate(llval),\n-                         &layout::Abi::Vector) => {\n-                            bcx.extract_element(llval, C_usize(bcx.ccx, f.index() as u64))\n-                        }\n-\n-                        _ => return None\n-                    };\n-\n-                    // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n-                    let llval = bcx.bitcast(llval, layout.immediate_llvm_type(bcx.ccx));\n-                    return Some(OperandRef {\n-                        val: OperandValue::Immediate(llval),\n-                        layout\n-                    });\n+                    return Some(o.extract_field(bcx, f.index()));\n                 }\n             }\n         }"}, {"sha": "bf44434cafea7f03b9e4ca07dc7519c51183de8f", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -223,20 +223,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         operand.val\n                     }\n                     mir::CastKind::Unsize => {\n-                        // unsize targets other than to a fat pointer currently\n-                        // can't be operands.\n-                        assert!(common::type_is_fat_ptr(bcx.ccx, cast.ty));\n-\n                         match operand.val {\n                             OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer - this is a\n                                 // \"trait-object-to-supertrait\" coercion, for\n                                 // example,\n                                 //   &'a fmt::Debug+Send => &'a fmt::Debug,\n-                                // So we need to pointercast the base to ensure\n-                                // the types match up.\n-                                let thin_ptr = cast.field(bcx.ccx, abi::FAT_PTR_ADDR);\n-                                let lldata = bcx.pointercast(lldata, thin_ptr.llvm_type(bcx.ccx));\n+\n+                                // HACK(eddyb) have to bitcast pointers\n+                                // until LLVM removes pointee types.\n+                                let lldata = bcx.pointercast(lldata,\n+                                    cast.scalar_pair_element_llvm_type(bcx.ccx, 0));\n                                 OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {"}, {"sha": "35da258cdb346e487cdc77407f7125de596b7168", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -491,16 +491,6 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n                         }\n                     }\n                 }\n-\n-                if let ty::TyAdt(def, _) = self.ty.sty {\n-                    if Some(def.did) == ccx.tcx().lang_items().non_zero() {\n-                        // FIXME(eddyb) Don't treat NonZero<*T> as\n-                        // as containing &T in ty::layout.\n-                        if let Some(ref mut pointee) = result {\n-                            pointee.safe = None;\n-                        }\n-                    }\n-                }\n             }\n         }\n "}, {"sha": "6c00ffa754b060f0c4357627f3e89a227c2d3794", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a36141465d1f97936cfceca87ed428dbfafdd3f/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=7a36141465d1f97936cfceca87ed428dbfafdd3f", "patch": "@@ -24,7 +24,7 @@ pub fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = bitcast { [0 x i8]*, [[USIZE]] }* %x to [0 x i8]**\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 0\n // CHECK: store [0 x i8]* %s.0, [0 x i8]** [[X0]]\n // CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { [0 x i8]*, [[USIZE]] }* %x, i32 0, i32 1\n // CHECK: store [[USIZE]] %s.1, [[USIZE]]* [[X1]]"}]}