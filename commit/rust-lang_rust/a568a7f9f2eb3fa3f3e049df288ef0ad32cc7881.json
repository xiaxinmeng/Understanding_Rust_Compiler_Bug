{"sha": "a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NjhhN2Y5ZjJlYjNmYTNmM2UwNDlkZjI4OGVmMGFkMzJjYzc4ODE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-18T06:45:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-21T22:23:54Z"}, "message": "std: Bring back f32::from_str_radix as an unstable API\n\nThis API was exercised in a few tests and mirrors the `from_str_radix`\nfunctionality of the integer types.", "tree": {"sha": "2d96b295e43de338e7e650110ba00ac2e116b519", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d96b295e43de338e7e650110ba00ac2e116b519"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "html_url": "https://github.com/rust-lang/rust/commit/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0791f9f406053d84dc7136c2be015a469304d7f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0791f9f406053d84dc7136c2be015a469304d7f0", "html_url": "https://github.com/rust-lang/rust/commit/0791f9f406053d84dc7136c2be015a469304d7f0"}], "stats": {"total": 1709, "additions": 561, "deletions": 1148}, "files": [{"sha": "3e77d3c603bac90909a481f68df961c545b4f566", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -336,7 +336,7 @@ This shows off the additional feature of `where` clauses: they allow bounds\n where the left-hand side is an arbitrary type (`i32` in this case), not just a\n plain type parameter (like `T`).\n \n-# Default methods\n+## Default methods\n \n There\u2019s one last feature of traits we should cover: default methods. It\u2019s\n easiest just to show an example:"}, {"sha": "bb90363bc1ddf383e06746b55f221cf7ee661f2b", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -40,7 +40,6 @@\n //! ```\n //! # #![feature(collections, core, step_by)]\n //! use std::collections::{BitSet, BitVec};\n-//! use std::num::Float;\n //! use std::iter;\n //!\n //! let max_prime = 10000;"}, {"sha": "d8a0e4daf4398192b7223d7671c92cefef70235e", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -175,7 +175,6 @@\n //! # #![feature(core, std_misc)]\n //! use std::fmt;\n //! use std::f64;\n-//! use std::num::Float;\n //!\n //! #[derive(Debug)]\n //! struct Vector2D {\n@@ -200,10 +199,11 @@\n //!         let magnitude = magnitude.sqrt();\n //!\n //!         // Respect the formatting flags by using the helper method\n-//!         // `pad_integral` on the Formatter object. See the method documentation\n-//!         // for details, and the function `pad` can be used to pad strings.\n+//!         // `pad_integral` on the Formatter object. See the method\n+//!         // documentation for details, and the function `pad` can be used\n+//!         // to pad strings.\n //!         let decimals = f.precision().unwrap_or(3);\n-//!         let string = f64::to_str_exact(magnitude, decimals);\n+//!         let string = format!(\"{:.*}\", decimals, magnitude);\n //!         f.pad_integral(true, \"\", &string)\n //!     }\n //! }"}, {"sha": "233ed018119302deceb23bedcdac7e0175a9b0e0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -2327,9 +2327,8 @@ impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n /// An iterator that yields sequential Fibonacci numbers, and stops on overflow.\n ///\n /// ```\n-/// # #![feature(core)]\n+/// #![feature(core)]\n /// use std::iter::Unfold;\n-/// use std::num::Int; // For `.checked_add()`\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max\n /// // value of `u32`. You can simply change `u32` to `u64` in this line if"}, {"sha": "249f0a0c389a3deda580019f845e047ed3aed18d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -108,6 +108,7 @@ mod uint_macros;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n+#[macro_use]\n pub mod num;\n \n /* The libcore prelude, not as all-encompassing as the libstd prelude */"}, {"sha": "50dd3f1661adf6c0fa632841668af366e683c104", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -16,9 +16,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n+use num::{Float, ParseFloatError};\n use num::FpCategory as Fp;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -153,6 +155,8 @@ impl Float for f32 {\n     #[inline]\n     fn one() -> f32 { 1.0 }\n \n+    from_str_radix_float_impl! { f32 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -234,9 +238,6 @@ impl Float for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f32;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "62b566e7eb40cb65f8b45d704e0f8c2fa83d22f7", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -16,10 +16,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use prelude::*;\n+\n use intrinsics;\n use mem;\n-use num::Float;\n use num::FpCategory as Fp;\n+use num::{Float, ParseFloatError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n@@ -153,6 +155,8 @@ impl Float for f64 {\n     #[inline]\n     fn one() -> f64 { 1.0 }\n \n+    from_str_radix_float_impl! { f64 }\n+\n     /// Returns `true` if the number is NaN.\n     #[inline]\n     fn is_nan(self) -> bool { self != self }\n@@ -234,9 +238,6 @@ impl Float for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    ///\n     /// let x = 1.65f64;\n     /// assert!(x == x.trunc() + x.fract())\n     /// ```"}, {"sha": "5ee0dc19f9bf684ca855056f2a8551e63a6ffc2c", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -18,3 +18,145 @@ macro_rules! assert_approx_eq {\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n }\n+\n+macro_rules! from_str_radix_float_impl {\n+    ($T:ty) => {\n+        fn from_str_radix(src: &str, radix: u32)\n+                          -> Result<$T, ParseFloatError> {\n+            use num::FloatErrorKind::*;\n+            use num::ParseFloatError as PFE;\n+\n+            // Special values\n+            match src {\n+                \"inf\"   => return Ok(Float::infinity()),\n+                \"-inf\"  => return Ok(Float::neg_infinity()),\n+                \"NaN\"   => return Ok(Float::nan()),\n+                _       => {},\n+            }\n+\n+            let (is_positive, src) =  match src.slice_shift_char() {\n+                None             => return Err(PFE { kind: Empty }),\n+                Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n+                Some(('-', src)) => (false, src),\n+                Some((_, _))     => (true,  src),\n+            };\n+\n+            // The significand to accumulate\n+            let mut sig = if is_positive { 0.0 } else { -0.0 };\n+            // Necessary to detect overflow\n+            let mut prev_sig = sig;\n+            let mut cs = src.chars().enumerate();\n+            // Exponent prefix and exponent index offset\n+            let mut exp_info = None::<(char, usize)>;\n+\n+            // Parse the integer part of the significand\n+            for (i, c) in cs.by_ref() {\n+                match c.to_digit(radix) {\n+                    Some(digit) => {\n+                        // shift significand one digit left\n+                        sig = sig * (radix as $T);\n+\n+                        // add/subtract current digit depending on sign\n+                        if is_positive {\n+                            sig = sig + ((digit as isize) as $T);\n+                        } else {\n+                            sig = sig - ((digit as isize) as $T);\n+                        }\n+\n+                        // Detect overflow by comparing to last value, except\n+                        // if we've not seen any non-zero digits.\n+                        if prev_sig != 0.0 {\n+                            if is_positive && sig <= prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig >= prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+\n+                            // Detect overflow by reversing the shift-and-add process\n+                            if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n+                                { return Ok(Float::neg_infinity()); }\n+                        }\n+                        prev_sig = sig;\n+                    },\n+                    None => match c {\n+                        'e' | 'E' | 'p' | 'P' => {\n+                            exp_info = Some((c, i + 1));\n+                            break;  // start of exponent\n+                        },\n+                        '.' => {\n+                            break;  // start of fractional part\n+                        },\n+                        _ => {\n+                            return Err(PFE { kind: Invalid });\n+                        },\n+                    },\n+                }\n+            }\n+\n+            // If we are not yet at the exponent parse the fractional\n+            // part of the significand\n+            if exp_info.is_none() {\n+                let mut power = 1.0;\n+                for (i, c) in cs.by_ref() {\n+                    match c.to_digit(radix) {\n+                        Some(digit) => {\n+                            // Decrease power one order of magnitude\n+                            power = power / (radix as $T);\n+                            // add/subtract current digit depending on sign\n+                            sig = if is_positive {\n+                                sig + (digit as $T) * power\n+                            } else {\n+                                sig - (digit as $T) * power\n+                            };\n+                            // Detect overflow by comparing to last value\n+                            if is_positive && sig < prev_sig\n+                                { return Ok(Float::infinity()); }\n+                            if !is_positive && sig > prev_sig\n+                                { return Ok(Float::neg_infinity()); }\n+                            prev_sig = sig;\n+                        },\n+                        None => match c {\n+                            'e' | 'E' | 'p' | 'P' => {\n+                                exp_info = Some((c, i + 1));\n+                                break; // start of exponent\n+                            },\n+                            _ => {\n+                                return Err(PFE { kind: Invalid });\n+                            },\n+                        },\n+                    }\n+                }\n+            }\n+\n+            // Parse and calculate the exponent\n+            let exp = match exp_info {\n+                Some((c, offset)) => {\n+                    let base = match c {\n+                        'E' | 'e' if radix == 10 => 10.0,\n+                        'P' | 'p' if radix == 16 => 2.0,\n+                        _ => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    // Parse the exponent as decimal integer\n+                    let src = &src[offset..];\n+                    let (is_positive, exp) = match src.slice_shift_char() {\n+                        Some(('-', src)) => (false, src.parse::<usize>()),\n+                        Some(('+', src)) => (true,  src.parse::<usize>()),\n+                        Some((_, _))     => (true,  src.parse::<usize>()),\n+                        None             => return Err(PFE { kind: Invalid }),\n+                    };\n+\n+                    match (is_positive, exp) {\n+                        (true,  Ok(exp)) => base.powi(exp as i32),\n+                        (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n+                        (_, Err(_))      => return Err(PFE { kind: Invalid }),\n+                    }\n+                },\n+                None => 1.0, // no exponent\n+            };\n+\n+            Ok(sig * exp)\n+        }\n+    }\n+}"}, {"sha": "44d5333ce1f46bb582a11b97e2fe08718c52029e", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 21, "deletions": 229, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -19,7 +19,6 @@ use char::CharExt;\n use cmp::{Eq, PartialOrd};\n use fmt;\n use intrinsics;\n-use iter::Iterator;\n use marker::Copy;\n use mem::size_of;\n use option::Option::{self, Some, None};\n@@ -148,9 +147,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -164,9 +160,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -183,9 +176,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -202,9 +192,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -221,9 +208,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -242,9 +226,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -261,8 +242,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -282,14 +261,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -306,14 +283,12 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -330,8 +305,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -354,8 +327,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -376,8 +347,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -393,8 +362,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -410,8 +377,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -427,8 +392,6 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -728,9 +691,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n@@ -746,9 +706,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b01001100u8;\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n@@ -765,9 +722,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n@@ -784,9 +738,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0b0101000u16;\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n@@ -803,9 +754,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0x3456789ABCDEF012u64;\n         ///\n@@ -826,9 +774,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xDEF0123456789ABCu64;\n         ///\n@@ -847,8 +792,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         /// let m = 0xEFCDAB8967452301u64;\n         ///\n@@ -868,14 +811,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n-        ///     assert_eq!(Int::from_be(n), n)\n+        ///     assert_eq!(u64::from_be(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_be(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -892,14 +833,12 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n-        ///     assert_eq!(Int::from_le(n), n)\n+        ///     assert_eq!(u64::from_le(n), n)\n         /// } else {\n-        ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+        ///     assert_eq!(u64::from_le(n), n.swap_bytes())\n         /// }\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -916,8 +855,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"big\") {\n@@ -940,8 +877,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// let n = 0x0123456789ABCDEFu64;\n         ///\n         /// if cfg!(target_endian = \"little\") {\n@@ -962,8 +897,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u16.checked_add(65530), Some(65535));\n         /// assert_eq!(6u16.checked_add(65530), None);\n         /// ```\n@@ -979,8 +912,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n         /// assert_eq!((-128i8).checked_sub(1), None);\n         /// ```\n@@ -996,8 +927,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!(5u8.checked_mul(51), Some(255));\n         /// assert_eq!(5u8.checked_mul(52), None);\n         /// ```\n@@ -1013,8 +942,6 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// use std::num::Int;\n-        ///\n         /// assert_eq!((-127i8).checked_div(-1), Some(127));\n         /// assert_eq!((-128i8).checked_div(-1), None);\n         /// assert_eq!((1i8).checked_div(0), None);\n@@ -1147,10 +1074,7 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```rust\n-        /// # #![feature(core)]\n-        /// use std::num::Int;\n-        ///\n-        /// assert_eq!(2.pow(4), 16);\n+        /// assert_eq!(2i32.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1328,6 +1252,8 @@ pub trait Float {\n     fn zero() -> Self;\n     /// Returns 1.0.\n     fn one() -> Self;\n+    /// Parses the string `s` with the radix `r` as a float.\n+    fn from_str_radix(s: &str, r: u32) -> Result<Self, ParseFloatError>;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n@@ -1412,8 +1338,8 @@ pub trait Float {\n     fn to_radians(self) -> Self;\n }\n \n-macro_rules! from_str_radix_float_impl {\n-    ($T:ty) => {\n+macro_rules! from_str_float_impl {\n+    ($T:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStr for $T {\n             type Err = ParseFloatError;\n@@ -1441,152 +1367,19 @@ macro_rules! from_str_radix_float_impl {\n             ///\n             /// # Return value\n             ///\n-            /// `Err(ParseFloatError)` if the string did not represent a valid number.\n-            /// Otherwise, `Ok(n)` where `n` is the floating-point number represented by `src`.\n+            /// `Err(ParseFloatError)` if the string did not represent a valid\n+            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                use self::FloatErrorKind::*;\n-                use self::ParseFloatError as PFE;\n-                let radix = 10;\n-\n-                // Special values\n-                match src {\n-                    \"inf\"   => return Ok(Float::infinity()),\n-                    \"-inf\"  => return Ok(Float::neg_infinity()),\n-                    \"NaN\"   => return Ok(Float::nan()),\n-                    _       => {},\n-                }\n-\n-                let (is_positive, src) =  match src.slice_shift_char() {\n-                    None             => return Err(PFE { kind: Empty }),\n-                    Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n-                    Some(('-', src)) => (false, src),\n-                    Some((_, _))     => (true,  src),\n-                };\n-\n-                // The significand to accumulate\n-                let mut sig = if is_positive { 0.0 } else { -0.0 };\n-                // Necessary to detect overflow\n-                let mut prev_sig = sig;\n-                let mut cs = src.chars().enumerate();\n-                // Exponent prefix and exponent index offset\n-                let mut exp_info = None::<(char, usize)>;\n-\n-                // Parse the integer part of the significand\n-                for (i, c) in cs.by_ref() {\n-                    match c.to_digit(radix) {\n-                        Some(digit) => {\n-                            // shift significand one digit left\n-                            sig = sig * (radix as $T);\n-\n-                            // add/subtract current digit depending on sign\n-                            if is_positive {\n-                                sig = sig + ((digit as isize) as $T);\n-                            } else {\n-                                sig = sig - ((digit as isize) as $T);\n-                            }\n-\n-                            // Detect overflow by comparing to last value, except\n-                            // if we've not seen any non-zero digits.\n-                            if prev_sig != 0.0 {\n-                                if is_positive && sig <= prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig >= prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-\n-                                // Detect overflow by reversing the shift-and-add process\n-                                if is_positive && (prev_sig != (sig - digit as $T) / radix as $T)\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && (prev_sig != (sig + digit as $T) / radix as $T)\n-                                    { return Ok(Float::neg_infinity()); }\n-                            }\n-                            prev_sig = sig;\n-                        },\n-                        None => match c {\n-                            'e' | 'E' | 'p' | 'P' => {\n-                                exp_info = Some((c, i + 1));\n-                                break;  // start of exponent\n-                            },\n-                            '.' => {\n-                                break;  // start of fractional part\n-                            },\n-                            _ => {\n-                                return Err(PFE { kind: Invalid });\n-                            },\n-                        },\n-                    }\n-                }\n-\n-                // If we are not yet at the exponent parse the fractional\n-                // part of the significand\n-                if exp_info.is_none() {\n-                    let mut power = 1.0;\n-                    for (i, c) in cs.by_ref() {\n-                        match c.to_digit(radix) {\n-                            Some(digit) => {\n-                                // Decrease power one order of magnitude\n-                                power = power / (radix as $T);\n-                                // add/subtract current digit depending on sign\n-                                sig = if is_positive {\n-                                    sig + (digit as $T) * power\n-                                } else {\n-                                    sig - (digit as $T) * power\n-                                };\n-                                // Detect overflow by comparing to last value\n-                                if is_positive && sig < prev_sig\n-                                    { return Ok(Float::infinity()); }\n-                                if !is_positive && sig > prev_sig\n-                                    { return Ok(Float::neg_infinity()); }\n-                                prev_sig = sig;\n-                            },\n-                            None => match c {\n-                                'e' | 'E' | 'p' | 'P' => {\n-                                    exp_info = Some((c, i + 1));\n-                                    break; // start of exponent\n-                                },\n-                                _ => {\n-                                    return Err(PFE { kind: Invalid });\n-                                },\n-                            },\n-                        }\n-                    }\n-                }\n-\n-                // Parse and calculate the exponent\n-                let exp = match exp_info {\n-                    Some((c, offset)) => {\n-                        let base = match c {\n-                            'E' | 'e' if radix == 10 => 10.0,\n-                            'P' | 'p' if radix == 16 => 2.0,\n-                            _ => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        // Parse the exponent as decimal integer\n-                        let src = &src[offset..];\n-                        let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, src.parse::<usize>()),\n-                            Some(('+', src)) => (true,  src.parse::<usize>()),\n-                            Some((_, _))     => (true,  src.parse::<usize>()),\n-                            None             => return Err(PFE { kind: Invalid }),\n-                        };\n-\n-                        match (is_positive, exp) {\n-                            (true,  Ok(exp)) => base.powi(exp as i32),\n-                            (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                            (_, Err(_))      => return Err(PFE { kind: Invalid }),\n-                        }\n-                    },\n-                    None => 1.0, // no exponent\n-                };\n-\n-                Ok(sig * exp)\n+                $T::from_str_radix(src, 10)\n             }\n         }\n     }\n }\n-from_str_radix_float_impl! { f32 }\n-from_str_radix_float_impl! { f64 }\n+from_str_float_impl!(f32);\n+from_str_float_impl!(f64);\n \n macro_rules! from_str_radix_int_impl {\n     ($($T:ident)*) => {$(\n@@ -1716,11 +1509,10 @@ impl fmt::Display for ParseIntError {\n \n /// An error which can be returned when parsing a float.\n #[derive(Debug, Clone, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseFloatError { kind: FloatErrorKind }\n+pub struct ParseFloatError { pub kind: FloatErrorKind }\n \n #[derive(Debug, Clone, PartialEq)]\n-enum FloatErrorKind {\n+pub enum FloatErrorKind {\n     Empty,\n     Invalid,\n }"}, {"sha": "e0d396c68b4c4847cb572580b497066de3a00689", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -110,8 +110,6 @@ fn test_partial_max() {\n \n #[test]\n fn test_user_defined_eq() {\n-    use core::num::SignedInt;\n-\n     // Our type.\n     struct SketchyNum {\n         num : isize"}, {"sha": "2866c193c3b1546a99f10736c0f4d11bade8343a", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -11,7 +11,6 @@\n use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n-use core::num::SignedInt;\n use core::usize;\n use core::cmp;\n \n@@ -783,16 +782,6 @@ fn test_range_step() {\n     assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n }\n \n-#[test]\n-fn test_range_step_inclusive() {\n-    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<isize>>(), [0, 5, 10, 15, 20]);\n-    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<isize>>(), [20, 15, 10, 5, 0]);\n-    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n-    assert_eq!(range_step_inclusive(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<isize>>(), []);\n-    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<isize>>(), [200]);\n-}\n-\n #[test]\n fn test_reverse() {\n     let mut ys = [1, 2, 3, 4, 5];"}, {"sha": "e0e8e46af6cdde2a241b352e7d427013866a9ce9", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -10,8 +10,8 @@\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]\n+\n #![feature(box_syntax)]\n-#![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n #![feature(core)]\n@@ -21,13 +21,11 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(hash)]\n-#![feature(io)]\n-#![feature(collections)]\n #![feature(debug_builders)]\n #![feature(unique)]\n #![feature(step_by)]\n #![feature(slice_patterns)]\n-#![allow(deprecated)] // rand\n+#![feature(float_from_str_radix)]\n \n extern crate core;\n extern crate test;"}, {"sha": "b1c8aec3c35e9798b9e30e030001b16e4139ee17", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! int_module { ($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n     use core::isize;\n-    use core::num::{FromStrRadix, Int, SignedInt};\n     use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n \n@@ -129,30 +128,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_signed_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n         assert!(isize::MIN.checked_div(-1) == None);\n     }\n \n@@ -180,26 +179,26 @@ mod tests {\n \n     #[test]\n     fn test_from_str_radix() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(i32::from_str_radix(\"123\", 16), Ok(291 as i32));\n+        assert_eq!(i32::from_str_radix(\"ffff\", 16), Ok(65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"FFFF\", 16), Ok(65535 as i32));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+        assert_eq!($T::from_str_radix(\"Z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"-123\", 10), Ok(-123 as $T));\n+        assert_eq!($T::from_str_radix(\"-1001\", 2), Ok(-9 as $T));\n+        assert_eq!($T::from_str_radix(\"-123\", 8), Ok(-83 as $T));\n+        assert_eq!(i32::from_str_radix(\"-123\", 16), Ok(-291 as i32));\n+        assert_eq!(i32::from_str_radix(\"-ffff\", 16), Ok(-65535 as i32));\n+        assert_eq!(i32::from_str_radix(\"-FFFF\", 16), Ok(-65535 as i32));\n+        assert_eq!($T::from_str_radix(\"-z\", 36), Ok(-35 as $T));\n+        assert_eq!($T::from_str_radix(\"-Z\", 36), Ok(-35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 35).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"-9\", 2).ok(), None::<$T>);\n     }\n \n     #[test]"}, {"sha": "85ca547da85260bfda02b72c8644362ae853e46f", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -10,7 +10,6 @@\n \n use core::cmp::PartialEq;\n use core::fmt::Debug;\n-use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n \n@@ -32,18 +31,12 @@ mod u64;\n \n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n      + Rem<Output=T> + Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n@@ -56,33 +49,33 @@ mod test {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::num::Float;\n-    use core::num::from_str_radix;\n \n     #[test]\n     fn from_str_issue7588() {\n-        let u : Option<u8> = from_str_radix(\"1000\", 10).ok();\n+        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n         assert_eq!(u, None);\n-        let s : Option<i16> = from_str_radix(\"80000\", 10).ok();\n+        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10).ok();\n+        let s = \"10000000000000000000000000000000000000000\";\n+        let f : Option<f32> = f32::from_str_radix(s, 10).ok();\n         assert_eq!(f, Some(Float::infinity()));\n-        let fe : Option<f32> = from_str_radix(\"1e40\", 10).ok();\n+        let fe : Option<f32> = f32::from_str_radix(\"1e40\", 10).ok();\n         assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]\n     fn test_from_str_radix_float() {\n-        let x1 : Option<f64> = from_str_radix(\"-123.456\", 10).ok();\n+        let x1 : Option<f64> = f64::from_str_radix(\"-123.456\", 10).ok();\n         assert_eq!(x1, Some(-123.456));\n-        let x2 : Option<f32> = from_str_radix(\"123.456\", 10).ok();\n+        let x2 : Option<f32> = f32::from_str_radix(\"123.456\", 10).ok();\n         assert_eq!(x2, Some(123.456));\n-        let x3 : Option<f32> = from_str_radix(\"-0.0\", 10).ok();\n+        let x3 : Option<f32> = f32::from_str_radix(\"-0.0\", 10).ok();\n         assert_eq!(x3, Some(-0.0));\n-        let x4 : Option<f32> = from_str_radix(\"0.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"0.0\", 10).ok();\n         assert_eq!(x4, Some(0.0));\n-        let x4 : Option<f32> = from_str_radix(\"1.0\", 10).ok();\n+        let x4 : Option<f32> = f32::from_str_radix(\"1.0\", 10).ok();\n         assert_eq!(x4, Some(1.0));\n-        let x5 : Option<f32> = from_str_radix(\"-1.0\", 10).ok();\n+        let x5 : Option<f32> = f32::from_str_radix(\"-1.0\", 10).ok();\n         assert_eq!(x5, Some(-1.0));\n     }\n "}, {"sha": "1712345f9d9a7c8316b04f1e8e85e3980873a0fd", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ident, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n-    use core::num::Int;\n     use num;\n     use core::ops::{BitOr, BitAnd, BitXor, Shl, Shr, Not};\n \n@@ -97,30 +96,30 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!($T::from_le(A.to_le()), A);\n+        assert_eq!($T::from_le(B.to_le()), B);\n+        assert_eq!($T::from_le(C.to_le()), C);\n+        assert_eq!($T::from_le(_0), _0);\n+        assert_eq!($T::from_le(_1), _1);\n         assert_eq!(_0.to_le(), _0);\n         assert_eq!(_1.to_le(), _1);\n     }\n \n     #[test]\n     fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!($T::from_be(A.to_be()), A);\n+        assert_eq!($T::from_be(B.to_be()), B);\n+        assert_eq!($T::from_be(C.to_be()), C);\n+        assert_eq!($T::from_be(_0), _0);\n+        assert_eq!($T::from_be(_1), _1);\n         assert_eq!(_0.to_be(), _0);\n         assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]\n     fn test_unsigned_checked_div() {\n-        assert!(10.checked_div(2) == Some(5));\n-        assert!(5.checked_div(0) == None);\n+        assert!((10 as $T).checked_div(2) == Some(5));\n+        assert!((5 as $T).checked_div(0) == None);\n     }\n }\n "}, {"sha": "4916e305b70e369141ad8e7743fe59aebdc78865", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -146,7 +146,6 @@ float_impl! { f64 }\n \n #[cfg(test)]\n mod tests {\n-    use std::num::Int;\n     use std::prelude::v1::*;\n     use distributions::{Sample, IndependentSample};\n     use super::Range as Range;"}, {"sha": "9ed827da8b2e4de2194e8289b282b2b6f6c4e5a0", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -540,14 +540,14 @@ mod tests {\n     // A normal addition - no overflow occurs\n     #[test]\n     fn test_add_bytes_to_bits_ok() {\n-        assert!(super::add_bytes_to_bits::<u64>(100, 10) == 180);\n+        assert!(super::add_bytes_to_bits(100, 10) == 180);\n     }\n \n     // A simple failure case - adding 1 to the max value\n     #[test]\n     #[should_panic]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(u64::MAX, 1);\n+        super::add_bytes_to_bits(u64::MAX, 1);\n     }\n \n     struct Test {"}, {"sha": "b1e14bf8f52a751fcae259021116ccfed5cc523d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -1625,7 +1625,7 @@ mod test_map {\n \n     use super::HashMap;\n     use super::Entry::{Occupied, Vacant};\n-    use iter::{range_inclusive, range_step_inclusive, repeat};\n+    use iter::{range_inclusive, repeat};\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n \n@@ -1861,7 +1861,7 @@ mod test_map {\n             }\n \n             // remove backwards\n-            for i in range_step_inclusive(1000, 1, -1) {\n+            for i in (1..1001).rev() {\n                 assert!(m.remove(&i).is_some());\n \n                 for j in range_inclusive(i, 1000) {"}, {"sha": "3ed891d024f7583a785d759825248ba3d0796666", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -772,7 +772,7 @@ mod tests {\n     }\n \n     fn eq(a: Option<OsString>, b: Option<&str>) {\n-        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::from_str).map(|s| &*s));\n+        assert_eq!(a.as_ref().map(|s| &**s), b.map(OsStr::new).map(|s| &*s));\n     }\n \n     #[test]\n@@ -895,7 +895,7 @@ mod tests {\n     fn join_paths_unix() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));\n@@ -911,7 +911,7 @@ mod tests {\n     fn join_paths_windows() {\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n-                OsStr::from_str(output)\n+                OsStr::new(output)\n         }\n \n         assert!(test_eq(&[], \"\"));"}, {"sha": "96665259a4d0c2d6cbf5328cf7fac00602b3ac13", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -129,6 +129,7 @@\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n #![feature(zero_one)]\n+#![cfg_attr(test, feature(float_from_str_radix))]\n #![cfg_attr(test, feature(test, rustc_private, std_misc))]\n \n // Don't link to std. We are std."}, {"sha": "0efc04ef83c6874e96f28ef71dcbd2e0bdeea5ad", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 112, "deletions": 118, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -15,11 +15,13 @@\n #![allow(unsigned_negation)]\n #![doc(primitive = \"f32\")]\n \n-use intrinsics;\n-use libc::c_int;\n-use num::FpCategory;\n+use prelude::v1::*;\n \n use core::num;\n+use intrinsics;\n+use libc::c_int;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -72,6 +74,12 @@ mod cmath {\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f32 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f32, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -1021,7 +1029,7 @@ impl f32 {\n     #[inline]\n     pub fn acosh(self) -> f32 {\n         match self {\n-            x if x < 1.0 => num::Float::nan(),\n+            x if x < 1.0 => ::f32::NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1047,6 +1055,7 @@ impl f32 {\n \n #[cfg(test)]\n mod tests {\n+    use f32;\n     use f32::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1070,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f32 = Float::nan();\n+        let nan: f32 = f32::NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1082,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f32 = Float::infinity();\n+        let inf: f32 = f32::INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1094,7 +1103,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1106,7 +1115,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f32 = Float::zero();\n+        let zero: f32 = 0.0f32;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1119,7 +1128,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f32 = Float::neg_zero();\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1132,7 +1141,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f32 = Float::one();\n+        let one: f32 = 1.0f32;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1145,9 +1154,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f32.is_nan());\n         assert!(!5.3f32.is_nan());\n@@ -1158,9 +1167,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1171,9 +1180,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1184,11 +1193,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1201,11 +1210,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let zero: f32 = Float::zero();\n-        let neg_zero: f32 = Float::neg_zero();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let zero: f32 = 0.0f32;\n+        let neg_zero: f32 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1348,9 +1357,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n@@ -1364,9 +1373,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.recip(), 1.0);\n         assert_eq!(2.0f32.recip(), 0.5);\n         assert_eq!((-0.4f32).recip(), -2.5);\n@@ -1378,9 +1387,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powi(1), 1.0);\n         assert_approx_eq!((-3.1f32).powi(2), 9.61);\n         assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n@@ -1392,9 +1401,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n         assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n@@ -1417,30 +1426,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f32).rsqrt().is_nan());\n-        assert_eq!((-0.0f32).rsqrt(), neg_inf);\n-        assert_eq!(0.0f32.rsqrt(), inf);\n-        assert_eq!(1.0f32.rsqrt(), 1.0);\n-        assert_eq!(4.0f32.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f32.exp());\n         assert_approx_eq!(2.718282, 1.0f32.exp());\n         assert_approx_eq!(148.413162, 5.0f32.exp());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1451,19 +1445,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f32.exp2());\n         assert_eq!(1.0, 0.0f32.exp2());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1476,12 +1470,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log(10.0), 1.0);\n         assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n-        assert_eq!(1.0f32.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n         assert!(1.0f32.log(1.0).is_nan());\n         assert!(1.0f32.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1494,9 +1488,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_approx_eq!(10.0f32.log2(), 3.321928);\n         assert_approx_eq!(2.3f32.log2(), 1.201634);\n         assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n@@ -1510,9 +1504,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(10.0f32.log10(), 1.0);\n         assert_approx_eq!(2.3f32.log10(), 0.361728);\n         assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n@@ -1528,9 +1522,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1542,9 +1536,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f32 = consts::PI;\n-        let nan: f32 = Float::nan();\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n+        let nan: f32 = f32::NAN;\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n         assert_eq!(0.0f32.to_radians(), 0.0);\n         assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n@@ -1558,50 +1552,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f32.ldexp(-123), f1);\n-        assert_eq!(1f32.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f32, -12), f3);\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f32::ldexp(1f32, -123), f1);\n+        assert_eq!(f32::ldexp(1f32, -111), f2);\n+        assert_eq!(f32::ldexp(1.75f32, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n-        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(f32::ldexp(0f32, -123), 0f32);\n+        assert_eq!(f32::ldexp(-0f32, -123), -0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n+        assert_eq!(f32::ldexp(inf, -123), inf);\n+        assert_eq!(f32::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f32::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f32 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f32 = f32::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f32 = f32::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f32 = f32::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n         assert_eq!((x3, exp3), (0.875f32, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f32::ldexp(x1, exp1), f1);\n+        assert_eq!(f32::ldexp(x2, exp2), f2);\n+        assert_eq!(f32::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -1630,9 +1624,9 @@ mod tests {\n         assert_eq!(0.0f32.asinh(), 0.0f32);\n         assert_eq!((-0.0f32).asinh(), -0.0f32);\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -1645,9 +1639,9 @@ mod tests {\n         assert_eq!(1.0f32.acosh(), 0.0f32);\n         assert!(0.999f32.acosh().is_nan());\n \n-        let inf: f32 = Float::infinity();\n-        let neg_inf: f32 = Float::neg_infinity();\n-        let nan: f32 = Float::nan();\n+        let inf: f32 = f32::INFINITY;\n+        let neg_inf: f32 = f32::NEG_INFINITY;\n+        let nan: f32 = f32::NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -1660,17 +1654,17 @@ mod tests {\n         assert_eq!(0.0f32.atanh(), 0.0f32);\n         assert_eq!((-0.0f32).atanh(), -0.0f32);\n \n-        let inf32: f32 = Float::infinity();\n-        let neg_inf32: f32 = Float::neg_infinity();\n+        let inf32: f32 = f32::INFINITY;\n+        let neg_inf32: f32 = f32::NEG_INFINITY;\n         assert_eq!(1.0f32.atanh(), inf32);\n         assert_eq!((-1.0f32).atanh(), neg_inf32);\n \n         assert!(2f64.atanh().atanh().is_nan());\n         assert!((-2f64).atanh().atanh().is_nan());\n \n-        let inf64: f32 = Float::infinity();\n-        let neg_inf64: f32 = Float::neg_infinity();\n-        let nan32: f32 = Float::nan();\n+        let inf64: f32 = f32::INFINITY;\n+        let neg_inf64: f32 = f32::NEG_INFINITY;\n+        let nan32: f32 = f32::NAN;\n         assert!(inf64.atanh().is_nan());\n         assert!(neg_inf64.atanh().is_nan());\n         assert!(nan32.atanh().is_nan());\n@@ -1692,9 +1686,9 @@ mod tests {\n         let frac_pi_8: f32 = consts::FRAC_PI_8;\n         let frac_1_pi: f32 = consts::FRAC_1_PI;\n         let frac_2_pi: f32 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f32 = consts::SQRT2;\n-        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f32 = consts::SQRT_2;\n+        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n         let e: f32 = consts::E;\n         let log2_e: f32 = consts::LOG2_E;\n         let log10_e: f32 = consts::LOG10_E;"}, {"sha": "e1497f3958dabf1bd897c62f0c2598fcd3763999", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 110, "deletions": 132, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -14,11 +14,13 @@\n #![allow(missing_docs)]\n #![doc(primitive = \"f64\")]\n \n-use intrinsics;\n-use libc::c_int;\n-use num::FpCategory;\n+use prelude::v1::*;\n \n use core::num;\n+use intrinsics;\n+use libc::c_int;\n+use num::{FpCategory, ParseFloatError};\n+use sys_common::FromInner;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -80,6 +82,12 @@ mod cmath {\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f64 {\n+    /// Parses a float as with a given radix\n+    #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n+    pub fn from_str_radix(s: &str, radix: u32) -> Result<f64, ParseFloatError> {\n+        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+    }\n+\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n@@ -435,22 +443,6 @@ impl f64 {\n     #[inline]\n     pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n \n-    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// let f = 4.0_f64;\n-    ///\n-    /// let abs_difference = (f.rsqrt() - 0.5).abs();\n-    ///\n-    /// assert!(abs_difference < 1e-10);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n-    #[inline]\n-    pub fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n-\n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n@@ -1013,7 +1005,7 @@ impl f64 {\n     #[inline]\n     pub fn acosh(self) -> f64 {\n         match self {\n-            x if x < 1.0 => num::Float::nan(),\n+            x if x < 1.0 => NAN,\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n     }\n@@ -1039,6 +1031,7 @@ impl f64 {\n \n #[cfg(test)]\n mod tests {\n+    use f64;\n     use f64::*;\n     use num::*;\n     use num::FpCategory as Fp;\n@@ -1062,7 +1055,7 @@ mod tests {\n \n     #[test]\n     fn test_nan() {\n-        let nan: f64 = Float::nan();\n+        let nan: f64 = NAN;\n         assert!(nan.is_nan());\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n@@ -1074,7 +1067,7 @@ mod tests {\n \n     #[test]\n     fn test_infinity() {\n-        let inf: f64 = Float::infinity();\n+        let inf: f64 = INFINITY;\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n         assert!(inf.is_sign_positive());\n@@ -1086,7 +1079,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_infinity() {\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n         assert!(!neg_inf.is_sign_positive());\n@@ -1098,7 +1091,7 @@ mod tests {\n \n     #[test]\n     fn test_zero() {\n-        let zero: f64 = Float::zero();\n+        let zero: f64 = 0.0f64;\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n@@ -1111,7 +1104,7 @@ mod tests {\n \n     #[test]\n     fn test_neg_zero() {\n-        let neg_zero: f64 = Float::neg_zero();\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n@@ -1124,7 +1117,7 @@ mod tests {\n \n     #[test]\n     fn test_one() {\n-        let one: f64 = Float::one();\n+        let one: f64 = 1.0f64;\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n@@ -1137,9 +1130,9 @@ mod tests {\n \n     #[test]\n     fn test_is_nan() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(nan.is_nan());\n         assert!(!0.0f64.is_nan());\n         assert!(!5.3f64.is_nan());\n@@ -1150,9 +1143,9 @@ mod tests {\n \n     #[test]\n     fn test_is_infinite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_infinite());\n         assert!(inf.is_infinite());\n         assert!(neg_inf.is_infinite());\n@@ -1163,9 +1156,9 @@ mod tests {\n \n     #[test]\n     fn test_is_finite() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert!(!nan.is_finite());\n         assert!(!inf.is_finite());\n         assert!(!neg_inf.is_finite());\n@@ -1176,11 +1169,11 @@ mod tests {\n \n     #[test]\n     fn test_is_normal() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert!(!nan.is_normal());\n         assert!(!inf.is_normal());\n         assert!(!neg_inf.is_normal());\n@@ -1193,11 +1186,11 @@ mod tests {\n \n     #[test]\n     fn test_classify() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let zero: f64 = Float::zero();\n-        let neg_zero: f64 = Float::neg_zero();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let zero: f64 = 0.0f64;\n+        let neg_zero: f64 = -0.0;\n         assert_eq!(nan.classify(), Fp::Nan);\n         assert_eq!(inf.classify(), Fp::Infinite);\n         assert_eq!(neg_inf.classify(), Fp::Infinite);\n@@ -1339,9 +1332,9 @@ mod tests {\n \n     #[test]\n     fn test_mul_add() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n         assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n         assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n@@ -1355,9 +1348,9 @@ mod tests {\n \n     #[test]\n     fn test_recip() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.recip(), 1.0);\n         assert_eq!(2.0f64.recip(), 0.5);\n         assert_eq!((-0.4f64).recip(), -2.5);\n@@ -1369,9 +1362,9 @@ mod tests {\n \n     #[test]\n     fn test_powi() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powi(1), 1.0);\n         assert_approx_eq!((-3.1f64).powi(2), 9.61);\n         assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n@@ -1383,9 +1376,9 @@ mod tests {\n \n     #[test]\n     fn test_powf() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(1.0f64.powf(1.0), 1.0);\n         assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n         assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n@@ -1408,30 +1401,15 @@ mod tests {\n         assert_eq!(INFINITY.sqrt(), INFINITY);\n     }\n \n-    #[test]\n-    fn test_rsqrt() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        assert!(nan.rsqrt().is_nan());\n-        assert_eq!(inf.rsqrt(), 0.0);\n-        assert!(neg_inf.rsqrt().is_nan());\n-        assert!((-1.0f64).rsqrt().is_nan());\n-        assert_eq!((-0.0f64).rsqrt(), neg_inf);\n-        assert_eq!(0.0f64.rsqrt(), inf);\n-        assert_eq!(1.0f64.rsqrt(), 1.0);\n-        assert_eq!(4.0f64.rsqrt(), 0.5);\n-    }\n-\n     #[test]\n     fn test_exp() {\n         assert_eq!(1.0, 0.0f64.exp());\n         assert_approx_eq!(2.718282, 1.0f64.exp());\n         assert_approx_eq!(148.413159, 5.0f64.exp());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp());\n         assert_eq!(0.0, neg_inf.exp());\n         assert!(nan.exp().is_nan());\n@@ -1442,19 +1420,19 @@ mod tests {\n         assert_eq!(32.0, 5.0f64.exp2());\n         assert_eq!(1.0, 0.0f64.exp2());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf, inf.exp2());\n         assert_eq!(0.0, neg_inf.exp2());\n         assert!(nan.exp2().is_nan());\n     }\n \n     #[test]\n     fn test_ln() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n         assert!(nan.ln().is_nan());\n         assert_eq!(inf.ln(), inf);\n@@ -1467,12 +1445,12 @@ mod tests {\n \n     #[test]\n     fn test_log() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log(10.0), 1.0);\n         assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n-        assert_eq!(1.0f64.exp().log(1.0.exp()), 1.0);\n+        assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n         assert!(1.0f64.log(1.0).is_nan());\n         assert!(1.0f64.log(-13.9).is_nan());\n         assert!(nan.log(2.3).is_nan());\n@@ -1485,9 +1463,9 @@ mod tests {\n \n     #[test]\n     fn test_log2() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_approx_eq!(10.0f64.log2(), 3.321928);\n         assert_approx_eq!(2.3f64.log2(), 1.201634);\n         assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n@@ -1501,9 +1479,9 @@ mod tests {\n \n     #[test]\n     fn test_log10() {\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(10.0f64.log10(), 1.0);\n         assert_approx_eq!(2.3f64.log10(), 0.361728);\n         assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n@@ -1519,9 +1497,9 @@ mod tests {\n     #[test]\n     fn test_to_degrees() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_degrees(), 0.0);\n         assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n         assert_eq!(pi.to_degrees(), 180.0);\n@@ -1533,9 +1511,9 @@ mod tests {\n     #[test]\n     fn test_to_radians() {\n         let pi: f64 = consts::PI;\n-        let nan: f64 = Float::nan();\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n+        let nan: f64 = NAN;\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n         assert_eq!(0.0f64.to_radians(), 0.0);\n         assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n         assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n@@ -1549,50 +1527,50 @@ mod tests {\n     fn test_ldexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-12\", 16).unwrap();\n-        assert_eq!(1f64.ldexp(-123), f1);\n-        assert_eq!(1f64.ldexp(-111), f2);\n-        assert_eq!(Float::ldexp(1.75f64, -12), f3);\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-12\", 16).unwrap();\n+        assert_eq!(f64::ldexp(1f64, -123), f1);\n+        assert_eq!(f64::ldexp(1f64, -111), f2);\n+        assert_eq!(f64::ldexp(1.75f64, -12), f3);\n \n-        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n-        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(f64::ldexp(0f64, -123), 0f64);\n+        assert_eq!(f64::ldexp(-0f64, -123), -0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n-        assert_eq!(Float::ldexp(inf, -123), inf);\n-        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n-        assert!(Float::ldexp(nan, -123).is_nan());\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n+        assert_eq!(f64::ldexp(inf, -123), inf);\n+        assert_eq!(f64::ldexp(neg_inf, -123), neg_inf);\n+        assert!(f64::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n     fn test_frexp() {\n         // We have to use from_str until base-2 exponents\n         // are supported in floating-point literals\n-        let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n-        let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        let f3: f64 = FromStrRadix::from_str_radix(\"1.Cp-123\", 16).unwrap();\n+        let f1: f64 = f64::from_str_radix(\"1p-123\", 16).unwrap();\n+        let f2: f64 = f64::from_str_radix(\"1p-111\", 16).unwrap();\n+        let f3: f64 = f64::from_str_radix(\"1.Cp-123\", 16).unwrap();\n         let (x1, exp1) = f1.frexp();\n         let (x2, exp2) = f2.frexp();\n         let (x3, exp3) = f3.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n         assert_eq!((x3, exp3), (0.875f64, -122));\n-        assert_eq!(Float::ldexp(x1, exp1), f1);\n-        assert_eq!(Float::ldexp(x2, exp2), f2);\n-        assert_eq!(Float::ldexp(x3, exp3), f3);\n+        assert_eq!(f64::ldexp(x1, exp1), f1);\n+        assert_eq!(f64::ldexp(x2, exp2), f2);\n+        assert_eq!(f64::ldexp(x3, exp3), f3);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));\n     }\n \n     #[test] #[cfg_attr(windows, ignore)] // FIXME #8755\n     fn test_frexp_nowin() {\n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n         assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n@@ -1621,9 +1599,9 @@ mod tests {\n         assert_eq!(0.0f64.asinh(), 0.0f64);\n         assert_eq!((-0.0f64).asinh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.asinh(), inf);\n         assert_eq!(neg_inf.asinh(), neg_inf);\n         assert!(nan.asinh().is_nan());\n@@ -1636,9 +1614,9 @@ mod tests {\n         assert_eq!(1.0f64.acosh(), 0.0f64);\n         assert!(0.999f64.acosh().is_nan());\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(inf.acosh(), inf);\n         assert!(neg_inf.acosh().is_nan());\n         assert!(nan.acosh().is_nan());\n@@ -1651,9 +1629,9 @@ mod tests {\n         assert_eq!(0.0f64.atanh(), 0.0f64);\n         assert_eq!((-0.0f64).atanh(), -0.0f64);\n \n-        let inf: f64 = Float::infinity();\n-        let neg_inf: f64 = Float::neg_infinity();\n-        let nan: f64 = Float::nan();\n+        let inf: f64 = INFINITY;\n+        let neg_inf: f64 = NEG_INFINITY;\n+        let nan: f64 = NAN;\n         assert_eq!(1.0f64.atanh(), inf);\n         assert_eq!((-1.0f64).atanh(), neg_inf);\n         assert!(2f64.atanh().atanh().is_nan());\n@@ -1677,9 +1655,9 @@ mod tests {\n         let frac_pi_8: f64 = consts::FRAC_PI_8;\n         let frac_1_pi: f64 = consts::FRAC_1_PI;\n         let frac_2_pi: f64 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRTPI;\n-        let sqrt2: f64 = consts::SQRT2;\n-        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT2;\n+        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n+        let sqrt2: f64 = consts::SQRT_2;\n+        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n         let e: f64 = consts::E;\n         let log2_e: f64 = consts::LOG2_E;\n         let log10_e: f64 = consts::LOG10_E;"}, {"sha": "cd26be013c41eaa814ec13e728f33290146b4cf1", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 52, "deletions": 500, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -16,34 +16,58 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-#[cfg(test)] use fmt::Debug;\n+use fmt;\n+use core::num;\n \n pub use core::num::{Zero, One};\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::{FpCategory, ParseIntError};\n pub use core::num::{wrapping, Wrapping};\n \n+#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n+#[cfg(test)] use cmp::PartialEq;\n+#[cfg(test)] use marker::Copy;\n+\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where\n-    T: PartialEq + NumCast\n+    T: PartialEq\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Debug\n+     + Rem<Output=T> + fmt::Debug\n      + Copy\n {\n-    assert_eq!(ten.add(two),  cast(12).unwrap());\n-    assert_eq!(ten.sub(two),  cast(8).unwrap());\n-    assert_eq!(ten.mul(two),  cast(20).unwrap());\n-    assert_eq!(ten.div(two),  cast(5).unwrap());\n-    assert_eq!(ten.rem(two),  cast(0).unwrap());\n-\n     assert_eq!(ten.add(two),  ten + two);\n     assert_eq!(ten.sub(two),  ten - two);\n     assert_eq!(ten.mul(two),  ten * two);\n     assert_eq!(ten.div(two),  ten / two);\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n+/// An error which can be returned when parsing a float.\n+#[derive(Debug, Clone, PartialEq)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError { inner: num::ParseFloatError }\n+\n+impl ::sys_common::FromInner<num::ParseFloatError> for ParseFloatError {\n+    fn from_inner(inner: num::ParseFloatError) -> ParseFloatError {\n+        ParseFloatError { inner: inner }\n+    }\n+}\n+\n+impl ParseFloatError {\n+    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    pub fn description(&self) -> &str {\n+        self.inner.description()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;\n@@ -59,432 +83,7 @@ mod tests {\n     use u64;\n     use usize;\n     use string::ToString;\n-\n-    macro_rules! test_cast_20 {\n-        ($_20:expr) => ({\n-            let _20 = $_20;\n-\n-            assert_eq!(20usize, _20.to_uint().unwrap());\n-            assert_eq!(20u8,    _20.to_u8().unwrap());\n-            assert_eq!(20u16,   _20.to_u16().unwrap());\n-            assert_eq!(20u32,   _20.to_u32().unwrap());\n-            assert_eq!(20u64,   _20.to_u64().unwrap());\n-            assert_eq!(20,      _20.to_int().unwrap());\n-            assert_eq!(20i8,    _20.to_i8().unwrap());\n-            assert_eq!(20i16,   _20.to_i16().unwrap());\n-            assert_eq!(20i32,   _20.to_i32().unwrap());\n-            assert_eq!(20i64,   _20.to_i64().unwrap());\n-            assert_eq!(20f32,   _20.to_f32().unwrap());\n-            assert_eq!(20f64,   _20.to_f64().unwrap());\n-\n-            assert_eq!(_20, NumCast::from(20usize).unwrap());\n-            assert_eq!(_20, NumCast::from(20u8).unwrap());\n-            assert_eq!(_20, NumCast::from(20u16).unwrap());\n-            assert_eq!(_20, NumCast::from(20u32).unwrap());\n-            assert_eq!(_20, NumCast::from(20u64).unwrap());\n-            assert_eq!(_20, NumCast::from(20).unwrap());\n-            assert_eq!(_20, NumCast::from(20i8).unwrap());\n-            assert_eq!(_20, NumCast::from(20i16).unwrap());\n-            assert_eq!(_20, NumCast::from(20i32).unwrap());\n-            assert_eq!(_20, NumCast::from(20i64).unwrap());\n-            assert_eq!(_20, NumCast::from(20f32).unwrap());\n-            assert_eq!(_20, NumCast::from(20f64).unwrap());\n-\n-            assert_eq!(_20, cast(20usize).unwrap());\n-            assert_eq!(_20, cast(20u8).unwrap());\n-            assert_eq!(_20, cast(20u16).unwrap());\n-            assert_eq!(_20, cast(20u32).unwrap());\n-            assert_eq!(_20, cast(20u64).unwrap());\n-            assert_eq!(_20, cast(20).unwrap());\n-            assert_eq!(_20, cast(20i8).unwrap());\n-            assert_eq!(_20, cast(20i16).unwrap());\n-            assert_eq!(_20, cast(20i32).unwrap());\n-            assert_eq!(_20, cast(20i64).unwrap());\n-            assert_eq!(_20, cast(20f32).unwrap());\n-            assert_eq!(_20, cast(20f64).unwrap());\n-        })\n-    }\n-\n-    #[test] fn test_u8_cast()    { test_cast_20!(20u8)    }\n-    #[test] fn test_u16_cast()   { test_cast_20!(20u16)   }\n-    #[test] fn test_u32_cast()   { test_cast_20!(20u32)   }\n-    #[test] fn test_u64_cast()   { test_cast_20!(20u64)   }\n-    #[test] fn test_uint_cast()  { test_cast_20!(20usize) }\n-    #[test] fn test_i8_cast()    { test_cast_20!(20i8)    }\n-    #[test] fn test_i16_cast()   { test_cast_20!(20i16)   }\n-    #[test] fn test_i32_cast()   { test_cast_20!(20i32)   }\n-    #[test] fn test_i64_cast()   { test_cast_20!(20i64)   }\n-    #[test] fn test_int_cast()   { test_cast_20!(20)      }\n-    #[test] fn test_f32_cast()   { test_cast_20!(20f32)   }\n-    #[test] fn test_f64_cast()   { test_cast_20!(20f64)   }\n-\n-    #[test]\n-    fn test_cast_range_int_min() {\n-        assert_eq!(isize::MIN.to_int(),  Some(isize::MIN as isize));\n-        assert_eq!(isize::MIN.to_i8(),   None);\n-        assert_eq!(isize::MIN.to_i16(),  None);\n-        // isize::MIN.to_i32() is word-size specific\n-        assert_eq!(isize::MIN.to_i64(),  Some(isize::MIN as i64));\n-        assert_eq!(isize::MIN.to_uint(), None);\n-        assert_eq!(isize::MIN.to_u8(),   None);\n-        assert_eq!(isize::MIN.to_u16(),  None);\n-        assert_eq!(isize::MIN.to_u32(),  None);\n-        assert_eq!(isize::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), Some(isize::MIN as i32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MIN.to_i32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_min() {\n-        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as isize));\n-        assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n-        assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n-        assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n-        assert_eq!(i8::MIN.to_i64(),  Some(i8::MIN as i64));\n-        assert_eq!(i8::MIN.to_uint(), None);\n-        assert_eq!(i8::MIN.to_u8(),   None);\n-        assert_eq!(i8::MIN.to_u16(),  None);\n-        assert_eq!(i8::MIN.to_u32(),  None);\n-        assert_eq!(i8::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_min() {\n-        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as isize));\n-        assert_eq!(i16::MIN.to_i8(),   None);\n-        assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n-        assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n-        assert_eq!(i16::MIN.to_i64(),  Some(i16::MIN as i64));\n-        assert_eq!(i16::MIN.to_uint(), None);\n-        assert_eq!(i16::MIN.to_u8(),   None);\n-        assert_eq!(i16::MIN.to_u16(),  None);\n-        assert_eq!(i16::MIN.to_u32(),  None);\n-        assert_eq!(i16::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_min() {\n-        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as isize));\n-        assert_eq!(i32::MIN.to_i8(),   None);\n-        assert_eq!(i32::MIN.to_i16(),  None);\n-        assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n-        assert_eq!(i32::MIN.to_i64(),  Some(i32::MIN as i64));\n-        assert_eq!(i32::MIN.to_uint(), None);\n-        assert_eq!(i32::MIN.to_u8(),   None);\n-        assert_eq!(i32::MIN.to_u16(),  None);\n-        assert_eq!(i32::MIN.to_u32(),  None);\n-        assert_eq!(i32::MIN.to_u64(),  None);\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_min() {\n-        // i64::MIN.to_int() is word-size specific\n-        assert_eq!(i64::MIN.to_i8(),   None);\n-        assert_eq!(i64::MIN.to_i16(),  None);\n-        assert_eq!(i64::MIN.to_i32(),  None);\n-        assert_eq!(i64::MIN.to_i64(),  Some(i64::MIN as i64));\n-        assert_eq!(i64::MIN.to_uint(), None);\n-        assert_eq!(i64::MIN.to_u8(),   None);\n-        assert_eq!(i64::MIN.to_u16(),  None);\n-        assert_eq!(i64::MIN.to_u32(),  None);\n-        assert_eq!(i64::MIN.to_u64(),  None);\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_int_max() {\n-        assert_eq!(isize::MAX.to_int(),  Some(isize::MAX as isize));\n-        assert_eq!(isize::MAX.to_i8(),   None);\n-        assert_eq!(isize::MAX.to_i16(),  None);\n-        // isize::MAX.to_i32() is word-size specific\n-        assert_eq!(isize::MAX.to_i64(),  Some(isize::MAX as i64));\n-        assert_eq!(isize::MAX.to_u8(),   None);\n-        assert_eq!(isize::MAX.to_u16(),  None);\n-        // isize::MAX.to_u32() is word-size specific\n-        assert_eq!(isize::MAX.to_u64(),  Some(isize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), Some(isize::MAX as i32));\n-            assert_eq!(isize::MAX.to_u32(), Some(isize::MAX as u32));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(isize::MAX.to_i32(), None);\n-            assert_eq!(isize::MAX.to_u32(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i8_max() {\n-        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as isize));\n-        assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n-        assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n-        assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n-        assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n-        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as usize));\n-        assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n-        assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n-        assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n-        assert_eq!(i8::MAX.to_u64(),  Some(i8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i16_max() {\n-        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as isize));\n-        assert_eq!(i16::MAX.to_i8(),   None);\n-        assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n-        assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n-        assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n-        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as usize));\n-        assert_eq!(i16::MAX.to_u8(),   None);\n-        assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n-        assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n-        assert_eq!(i16::MAX.to_u64(),  Some(i16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i32_max() {\n-        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as isize));\n-        assert_eq!(i32::MAX.to_i8(),   None);\n-        assert_eq!(i32::MAX.to_i16(),  None);\n-        assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n-        assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n-        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as usize));\n-        assert_eq!(i32::MAX.to_u8(),   None);\n-        assert_eq!(i32::MAX.to_u16(),  None);\n-        assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n-        assert_eq!(i32::MAX.to_u64(),  Some(i32::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_i64_max() {\n-        // i64::MAX.to_int() is word-size specific\n-        assert_eq!(i64::MAX.to_i8(),   None);\n-        assert_eq!(i64::MAX.to_i16(),  None);\n-        assert_eq!(i64::MAX.to_i32(),  None);\n-        assert_eq!(i64::MAX.to_i64(),  Some(i64::MAX as i64));\n-        // i64::MAX.to_uint() is word-size specific\n-        assert_eq!(i64::MAX.to_u8(),   None);\n-        assert_eq!(i64::MAX.to_u16(),  None);\n-        assert_eq!(i64::MAX.to_u32(),  None);\n-        assert_eq!(i64::MAX.to_u64(),  Some(i64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  None);\n-            assert_eq!(i64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as isize));\n-            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_min() {\n-        assert_eq!(usize::MIN.to_int(),  Some(usize::MIN as isize));\n-        assert_eq!(usize::MIN.to_i8(),   Some(usize::MIN as i8));\n-        assert_eq!(usize::MIN.to_i16(),  Some(usize::MIN as i16));\n-        assert_eq!(usize::MIN.to_i32(),  Some(usize::MIN as i32));\n-        assert_eq!(usize::MIN.to_i64(),  Some(usize::MIN as i64));\n-        assert_eq!(usize::MIN.to_uint(), Some(usize::MIN as usize));\n-        assert_eq!(usize::MIN.to_u8(),   Some(usize::MIN as u8));\n-        assert_eq!(usize::MIN.to_u16(),  Some(usize::MIN as u16));\n-        assert_eq!(usize::MIN.to_u32(),  Some(usize::MIN as u32));\n-        assert_eq!(usize::MIN.to_u64(),  Some(usize::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_min() {\n-        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as isize));\n-        assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n-        assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n-        assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n-        assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n-        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as usize));\n-        assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n-        assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n-        assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n-        assert_eq!(u8::MIN.to_u64(),  Some(u8::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_min() {\n-        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as isize));\n-        assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n-        assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n-        assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n-        assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n-        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as usize));\n-        assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n-        assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n-        assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n-        assert_eq!(u16::MIN.to_u64(),  Some(u16::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_min() {\n-        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as isize));\n-        assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n-        assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n-        assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n-        assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n-        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as usize));\n-        assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n-        assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n-        assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n-        assert_eq!(u32::MIN.to_u64(),  Some(u32::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_min() {\n-        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as isize));\n-        assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n-        assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n-        assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n-        assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n-        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as usize));\n-        assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n-        assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n-        assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n-        assert_eq!(u64::MIN.to_u64(),  Some(u64::MIN as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_uint_max() {\n-        assert_eq!(usize::MAX.to_int(),  None);\n-        assert_eq!(usize::MAX.to_i8(),   None);\n-        assert_eq!(usize::MAX.to_i16(),  None);\n-        assert_eq!(usize::MAX.to_i32(),  None);\n-        // usize::MAX.to_i64() is word-size specific\n-        assert_eq!(usize::MAX.to_u8(),   None);\n-        assert_eq!(usize::MAX.to_u16(),  None);\n-        // usize::MAX.to_u32() is word-size specific\n-        assert_eq!(usize::MAX.to_u64(),  Some(usize::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), Some(usize::MAX as u32));\n-            assert_eq!(usize::MAX.to_i64(), Some(usize::MAX as i64));\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(usize::MAX.to_u32(), None);\n-            assert_eq!(usize::MAX.to_i64(), None);\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u8_max() {\n-        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as isize));\n-        assert_eq!(u8::MAX.to_i8(),   None);\n-        assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n-        assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n-        assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n-        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as usize));\n-        assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n-        assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n-        assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n-        assert_eq!(u8::MAX.to_u64(),  Some(u8::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u16_max() {\n-        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as isize));\n-        assert_eq!(u16::MAX.to_i8(),   None);\n-        assert_eq!(u16::MAX.to_i16(),  None);\n-        assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n-        assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n-        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as usize));\n-        assert_eq!(u16::MAX.to_u8(),   None);\n-        assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n-        assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n-        assert_eq!(u16::MAX.to_u64(),  Some(u16::MAX as u64));\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u32_max() {\n-        // u32::MAX.to_int() is word-size specific\n-        assert_eq!(u32::MAX.to_i8(),   None);\n-        assert_eq!(u32::MAX.to_i16(),  None);\n-        assert_eq!(u32::MAX.to_i32(),  None);\n-        assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n-        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as usize));\n-        assert_eq!(u32::MAX.to_u8(),   None);\n-        assert_eq!(u32::MAX.to_u16(),  None);\n-        assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n-        assert_eq!(u32::MAX.to_u64(),  Some(u32::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as isize));\n-        }\n-\n-        check_word_size();\n-    }\n-\n-    #[test]\n-    fn test_cast_range_u64_max() {\n-        assert_eq!(u64::MAX.to_int(),  None);\n-        assert_eq!(u64::MAX.to_i8(),   None);\n-        assert_eq!(u64::MAX.to_i16(),  None);\n-        assert_eq!(u64::MAX.to_i32(),  None);\n-        assert_eq!(u64::MAX.to_i64(),  None);\n-        // u64::MAX.to_uint() is word-size specific\n-        assert_eq!(u64::MAX.to_u8(),   None);\n-        assert_eq!(u64::MAX.to_u16(),  None);\n-        assert_eq!(u64::MAX.to_u32(),  None);\n-        assert_eq!(u64::MAX.to_u64(),  Some(u64::MAX as u64));\n-\n-        #[cfg(target_pointer_width = \"32\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), None);\n-        }\n-\n-        #[cfg(target_pointer_width = \"64\")]\n-        fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as usize));\n-        }\n-\n-        check_word_size();\n-    }\n+    use ops::Mul;\n \n     #[test]\n     fn test_saturating_add_uint() {\n@@ -507,23 +106,23 @@ mod tests {\n     #[test]\n     fn test_saturating_add_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_add(5), 8);\n-        assert_eq!(3.saturating_add(MAX-1), MAX);\n+        assert_eq!(3i32.saturating_add(5), 8);\n+        assert_eq!(3isize.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n         assert_eq!((MAX-2).saturating_add(1), MAX-1);\n-        assert_eq!(3.saturating_add(-5), -2);\n+        assert_eq!(3i32.saturating_add(-5), -2);\n         assert_eq!(MIN.saturating_add(-1), MIN);\n-        assert_eq!((-2).saturating_add(-MAX), MIN);\n+        assert_eq!((-2isize).saturating_add(-MAX), MIN);\n     }\n \n     #[test]\n     fn test_saturating_sub_int() {\n         use isize::{MIN,MAX};\n-        assert_eq!(3.saturating_sub(5), -2);\n+        assert_eq!(3i32.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n-        assert_eq!((-2).saturating_sub(MAX), MIN);\n-        assert_eq!(3.saturating_sub(-5), 8);\n-        assert_eq!(3.saturating_sub(-(MAX-1)), MAX);\n+        assert_eq!((-2isize).saturating_sub(MAX), MIN);\n+        assert_eq!(3i32.saturating_sub(-5), 8);\n+        assert_eq!(3isize.saturating_sub(-(MAX-1)), MAX);\n         assert_eq!(MAX.saturating_sub(-MAX), MAX);\n         assert_eq!((MAX-2).saturating_sub(-1), MAX-1);\n     }\n@@ -627,56 +226,10 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n \n-    #[derive(PartialEq, Debug)]\n-    struct Value { x: isize }\n-\n-    impl ToPrimitive for Value {\n-        fn to_i64(&self) -> Option<i64> { self.x.to_i64() }\n-        fn to_u64(&self) -> Option<u64> { self.x.to_u64() }\n-    }\n-\n-    impl FromPrimitive for Value {\n-        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }\n-        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }\n-    }\n-\n-    #[test]\n-    fn test_to_primitive() {\n-        let value = Value { x: 5 };\n-        assert_eq!(value.to_int(),  Some(5));\n-        assert_eq!(value.to_i8(),   Some(5));\n-        assert_eq!(value.to_i16(),  Some(5));\n-        assert_eq!(value.to_i32(),  Some(5));\n-        assert_eq!(value.to_i64(),  Some(5));\n-        assert_eq!(value.to_uint(), Some(5));\n-        assert_eq!(value.to_u8(),   Some(5));\n-        assert_eq!(value.to_u16(),  Some(5));\n-        assert_eq!(value.to_u32(),  Some(5));\n-        assert_eq!(value.to_u64(),  Some(5));\n-        assert_eq!(value.to_f32(),  Some(5f32));\n-        assert_eq!(value.to_f64(),  Some(5f64));\n-    }\n-\n-    #[test]\n-    fn test_from_primitive() {\n-        assert_eq!(from_int(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_i16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_i64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_uint(5),   Some(Value { x: 5 }));\n-        assert_eq!(from_u8(5),     Some(Value { x: 5 }));\n-        assert_eq!(from_u16(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u32(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_u64(5),    Some(Value { x: 5 }));\n-        assert_eq!(from_f32(5f32), Some(Value { x: 5 }));\n-        assert_eq!(from_f64(5f64), Some(Value { x: 5 }));\n-    }\n-\n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Int>(base: T, exp: usize) -> T {\n-            let one: T = Int::one();\n+        fn naive_pow<T: Mul<Output=T> + One + Copy>(base: T, exp: usize) -> T {\n+            let one: T = T::one();\n             (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n@@ -686,11 +239,11 @@ mod tests {\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n         }\n-        assert_pow!((3,     0 ) => 1);\n-        assert_pow!((5,     1 ) => 5);\n-        assert_pow!((-4,    2 ) => 16);\n-        assert_pow!((8,     3 ) => 512);\n-        assert_pow!((2u64,   50) => 1125899906842624);\n+        assert_pow!((3u32,     0 ) => 1);\n+        assert_pow!((5u32,     1 ) => 5);\n+        assert_pow!((-4i32,    2 ) => 16);\n+        assert_pow!((8u32,     3 ) => 512);\n+        assert_pow!((2u64,     50) => 1125899906842624);\n     }\n \n     #[test]\n@@ -765,12 +318,11 @@ mod tests {\n mod bench {\n     extern crate test;\n     use self::test::Bencher;\n-    use num::Int;\n     use prelude::v1::*;\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = (0..1024).collect::<Vec<_>>();\n-        b.iter(|| {v.iter().fold(0, |old, new| old.pow(*new as u32));});\n+        let v = (0..1024).collect::<Vec<u32>>();\n+        b.iter(|| {v.iter().fold(0u32, |old, new| old.pow(*new as u32));});\n     }\n }"}, {"sha": "96b0ba1c77f8da8c600cf02a16eebabe43fe0960", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -12,12 +12,11 @@\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n \n-macro_rules! uint_module { ($T:ty) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n-    use num::FromStrRadix;\n \n     fn from_str<T: ::str::FromStr>(t: &str) -> Option<T> {\n         ::str::FromStr::from_str(t).ok()\n@@ -38,15 +37,15 @@ mod tests {\n \n     #[test]\n     pub fn test_parse_bytes() {\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 10), Ok(123 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"1001\", 2), Ok(9 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 8), Ok(83 as $T));\n-        assert_eq!(FromStrRadix::from_str_radix(\"123\", 16), Ok(291 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n-        assert_eq!(FromStrRadix::from_str_radix(\"z\", 36), Ok(35 as $T));\n-\n-        assert_eq!(FromStrRadix::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n-        assert_eq!(FromStrRadix::from_str_radix(\"_\", 2).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"123\", 10), Ok(123 as $T));\n+        assert_eq!($T::from_str_radix(\"1001\", 2), Ok(9 as $T));\n+        assert_eq!($T::from_str_radix(\"123\", 8), Ok(83 as $T));\n+        assert_eq!(u16::from_str_radix(\"123\", 16), Ok(291 as u16));\n+        assert_eq!(u16::from_str_radix(\"ffff\", 16), Ok(65535 as u16));\n+        assert_eq!($T::from_str_radix(\"z\", 36), Ok(35 as $T));\n+\n+        assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n+        assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n     }\n }\n "}, {"sha": "2837bac445697348b4472a7034d27e92e193b059", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -67,7 +67,6 @@ mod test {\n     use prelude::v1::*;\n \n     use super::ReaderRng;\n-    use num::Int;\n     use rand::Rng;\n \n     #[test]\n@@ -78,18 +77,18 @@ mod test {\n                   0,   0, 0, 0, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u64(), 1.to_be());\n-        assert_eq!(rng.next_u64(), 2.to_be());\n-        assert_eq!(rng.next_u64(), 3.to_be());\n+        assert_eq!(rng.next_u64(), 1u64.to_be());\n+        assert_eq!(rng.next_u64(), 2u64.to_be());\n+        assert_eq!(rng.next_u64(), 3u64.to_be());\n     }\n     #[test]\n     fn test_reader_rng_u32() {\n         let v = &[0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3][..];\n         let mut rng = ReaderRng::new(v);\n \n-        assert_eq!(rng.next_u32(), 1.to_be());\n-        assert_eq!(rng.next_u32(), 2.to_be());\n-        assert_eq!(rng.next_u32(), 3.to_be());\n+        assert_eq!(rng.next_u32(), 1u32.to_be());\n+        assert_eq!(rng.next_u32(), 2u32.to_be());\n+        assert_eq!(rng.next_u32(), 3u32.to_be());\n     }\n     #[test]\n     fn test_reader_rng_fill_bytes() {"}, {"sha": "a9ab73feed8d2a4ee3d8d805e59fdafa4166b727", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -13,7 +13,7 @@ use io::prelude::*;\n use os::windows::prelude::*;\n \n use default::Default;\n-use ffi::{OsString, AsOsStr};\n+use ffi::OsString;\n use fmt;\n use io::{self, Error, SeekFrom};\n use libc::{self, HANDLE};"}, {"sha": "5ae5f6f201bad0bcffb03d7f8e978544bb60ba52", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -17,8 +17,7 @@ use prelude::v1::*;\n use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n-#[allow(deprecated)]\n-use num::Int;\n+use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n \n@@ -144,9 +143,8 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n-#[allow(deprecated)]\n-fn cvt<I: Int>(i: I) -> io::Result<I> {\n-    if i == Int::zero() {\n+fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n+    if i == I::zero() {\n         Err(io::Error::last_os_error())\n     } else {\n         Ok(i)"}, {"sha": "6bbcd968157aba084deecae84dbe9fad92a8456a", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -15,8 +15,8 @@ use libc::consts::os::extra::INVALID_SOCKET;\n use libc::{self, c_int, c_void};\n use mem;\n use net::SocketAddr;\n-#[allow(deprecated)]\n-use num::{SignedInt, Int};\n+use num::One;\n+use ops::Neg;\n use rt;\n use sync::{Once, ONCE_INIT};\n use sys::c;\n@@ -49,11 +49,8 @@ fn last_error() -> io::Error {\n /// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n /// and if so, returns the last error from the Windows socket interface. . This\n /// function must be called before another call to the socket API is made.\n-///\n-/// FIXME: generics needed?\n-#[allow(deprecated)]\n-pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n-    let one: T = Int::one();\n+pub fn cvt<T: One + Neg<Output=T> + PartialEq>(t: T) -> io::Result<T> {\n+    let one: T = T::one();\n     if t == -one {\n         Err(last_error())\n     } else {\n@@ -70,7 +67,9 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n \n /// Provides the functionality of `cvt` for a closure.\n #[allow(deprecated)]\n-pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n+pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n+    where F: FnMut() -> T, T: One + Neg<Output=T> + PartialEq\n+{\n     cvt(f())\n }\n "}, {"sha": "5ddcf3d1ea2991f9f62ce90b436b2d6a3510b005", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -140,7 +140,7 @@ impl Process {\n         // read the *child's* PATH if one is provided. See #15149 for more details.\n         let program = cfg.env.as_ref().and_then(|env| {\n             for (key, v) in env {\n-                if OsStr::from_str(\"PATH\") != &**key { continue }\n+                if OsStr::new(\"PATH\") != &**key { continue }\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n@@ -463,7 +463,7 @@ mod tests {\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n             String::from_utf16(\n-                &make_command_line(OsStr::from_str(prog),\n+                &make_command_line(OsStr::new(prog),\n                                    &args.iter()\n                                         .map(|a| OsString::from(a))\n                                         .collect::<Vec<OsString>>())).unwrap()"}, {"sha": "c1ba1260f67e120fdd058c04f6fbf68fc0f13b4a", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -338,14 +338,13 @@ mod tests {\n \n     macro_rules! assert_approx_eq {\n         ($a:expr, $b:expr) => ({\n-            use std::num::Float;\n             let (a, b) = (&$a, &$b);\n             assert!((*a - *b).abs() < 1.0e-6,\n                     \"{} is not approximately equal to {}\", *a, *b);\n         })\n     }\n \n-    fn check(samples: &[f64], summ: &Summary<f64>) {\n+    fn check(samples: &[f64], summ: &Summary) {\n \n         let summ2 = Summary::new(samples);\n "}, {"sha": "efbb5dfb5491ebe855be1249909590a2031c055a", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -14,7 +14,6 @@\n #![feature(rand, core)]\n \n use std::f32::consts::PI;\n-use std::num::Float;\n use std::__rand::{Rng, thread_rng};\n \n #[derive(Copy, Clone)]"}, {"sha": "c576eea3602cb6b95669ac88c29ba6564d4f92c2", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -109,8 +109,7 @@ fn main() {\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n     let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n-        use std::num::Int;\n-        let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n+        let iterations = 2i32.pow((max_depth - depth + min_depth) as u32);\n         thread::spawn(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n "}, {"sha": "accf525b4e6386ffe1e97faf4ea3189dd2c6f405", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -43,7 +43,6 @@ use std::env;\n use std::fs::File;\n use std::io::{self, BufWriter};\n use std::io::prelude::*;\n-use std::num::Float;\n \n const LINE_LENGTH: usize = 60;\n const IM: u32 = 139968;"}, {"sha": "368dbbb931c269e5b48e8041526b7c7ada882873", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -38,9 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core)]\n-\n-use std::num::Float;\n+use std::mem;\n \n const PI: f64 = 3.141592653589793;\n const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -193,16 +191,9 @@ fn main() {\n /// longer contain the mutable reference. This is a safe operation because the\n /// two mutable borrows are entirely disjoint.\n fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n-    use std::mem;\n-    use std::raw::Repr;\n-\n-    if r.is_empty() { return None }\n-    unsafe {\n-        let mut raw = r.repr();\n-        let ret = raw.data as *mut T;\n-        raw.data = raw.data.offset(1);\n-        raw.len -= 1;\n-        *r = mem::transmute(raw);\n-        Some({ &mut *ret })\n-    }\n+    let res = mem::replace(r, &mut []);\n+    if res.is_empty() { return None }\n+    let (a, b) = res.split_at_mut(1);\n+    *r = b;\n+    Some(&mut a[0])\n }"}, {"sha": "0fa22abde3cbd9ee695ec1b392bd9aa6d415b9c1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -46,7 +46,6 @@\n use std::iter::repeat;\n use std::thread;\n use std::mem;\n-use std::num::Float;\n use std::os;\n use std::env;\n use std::raw::Repr;"}, {"sha": "16742f0a6e1a56f5ad2520beaeb591ffd597cb1b", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -16,7 +16,6 @@\n use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n-use std::num::Int;\n use std::env;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "a5246b9300c91ad2f1f4149e0d732ad6b19634c5", "filename": "src/test/pretty/default-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs?ref=a568a7f9f2eb3fa3f3e049df288ef0ad32cc7881", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(optin_builtin_traits, core)]\n+#![feature(optin_builtin_traits)]\n \n // pp-exact\n \n-use std::marker::MarkerTrait;\n-\n-trait MyTrait: MarkerTrait { }\n+trait MyTrait { }\n \n impl MyTrait for .. { }\n "}]}