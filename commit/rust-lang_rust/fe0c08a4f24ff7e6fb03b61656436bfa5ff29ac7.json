{"sha": "fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "node_id": "C_kwDOAAsO6NoAKGZlMGMwOGE0ZjI0ZmY3ZTZmYjAzYjYxNjU2NDM2YmZhNWZmMjlhYzc", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-03-27T07:06:26Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-04-09T03:17:38Z"}, "message": "Make non-power-of-two alignments a validity error in `Layout`\n\nInspired by the zulip conversation about how `Layout` should better enforce `size < isize::MAX as usize`, this uses an N-variant enum on N-bit platforms to require at the validity level that the existing invariant of \"must be a power of two\" is upheld.\n\nThis was MIRI can catch it, and means there's a more-specific type for `Layout` to store than just `NonZeroUsize`.", "tree": {"sha": "1d767c6d460f1fd8b6eb76f32cca54d33e445fda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d767c6d460f1fd8b6eb76f32cca54d33e445fda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "html_url": "https://github.com/rust-lang/rust/commit/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "185a3f0a112fd6439247cf15452d0c5dfb3c8c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/185a3f0a112fd6439247cf15452d0c5dfb3c8c92", "html_url": "https://github.com/rust-lang/rust/commit/185a3f0a112fd6439247cf15452d0c5dfb3c8c92"}], "stats": {"total": 320, "additions": 305, "deletions": 15}, "files": [{"sha": "4bb5e52e23aa043576c7af84a8f3a9bf1fb6031e", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -1,7 +1,6 @@\n use crate::cmp;\n use crate::fmt;\n-use crate::mem;\n-use crate::num::NonZeroUsize;\n+use crate::mem::{self, ValidAlign};\n use crate::ptr::NonNull;\n \n // While this function is used in one place and its implementation\n@@ -40,7 +39,7 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align_: NonZeroUsize,\n+    align_: ValidAlign,\n }\n \n impl Layout {\n@@ -97,8 +96,8 @@ impl Layout {\n     #[must_use]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        // SAFETY: the caller must ensure that `align` is greater than zero.\n-        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }\n+        // SAFETY: the caller must ensure that `align` is a power of two.\n+        Layout { size_: size, align_: unsafe { ValidAlign::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n@@ -117,7 +116,7 @@ impl Layout {\n                   without modifying the layout\"]\n     #[inline]\n     pub const fn align(&self) -> usize {\n-        self.align_.get()\n+        self.align_.as_nonzero().get()\n     }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`."}, {"sha": "1ac32961ad84a99aa610a4512661362e4dacafbb", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -21,6 +21,12 @@ mod maybe_uninit;\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n pub use maybe_uninit::MaybeUninit;\n \n+mod valid_align;\n+// For now this type is left crate-local.  It could potentially make sense to expose\n+// it publicly, as it would be a nice parameter type for methods which need to take\n+// alignment as a parameter, such as `Layout::padding_needed_for`.\n+pub(crate) use valid_align::ValidAlign;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(inline)]\n pub use crate::intrinsics::transmute;"}, {"sha": "596a67f255a1bbcf3cbe003cbc8daab3903f57cf", "filename": "library/core/src/mem/valid_align.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fvalid_align.rs?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -0,0 +1,240 @@\n+use crate::convert::TryFrom;\n+use crate::num::NonZeroUsize;\n+use crate::{cmp, fmt, mem, num};\n+\n+/// A type storing a `usize` which is a power of two, and thus\n+/// represents a possible alignment in the rust abstract machine.\n+///\n+/// Note that particularly large alignments, while representable in this type,\n+/// are likely not to be supported by actual allocators and linkers.\n+#[derive(Copy, Clone)]\n+#[repr(transparent)]\n+pub(crate) struct ValidAlign(ValidAlignEnum);\n+\n+// ValidAlign is `repr(usize)`, but via extra steps.\n+const _: () = assert!(mem::size_of::<ValidAlign>() == mem::size_of::<usize>());\n+const _: () = assert!(mem::align_of::<ValidAlign>() == mem::align_of::<usize>());\n+\n+impl ValidAlign {\n+    /// Creates a `ValidAlign` from a power-of-two `usize`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `align` must be a power of two.\n+    ///\n+    /// Equivalently, it must be `1 << exp` for some `exp` in `0..usize::BITS`.\n+    /// It must *not* be zero.\n+    #[inline]\n+    pub(crate) const unsafe fn new_unchecked(align: usize) -> Self {\n+        debug_assert!(align.is_power_of_two());\n+\n+        // SAFETY: By precondition, this must be a power of two, and\n+        // our variants encompass all possible powers of two.\n+        unsafe { mem::transmute::<usize, ValidAlign>(align) }\n+    }\n+\n+    #[inline]\n+    pub(crate) const fn as_nonzero(self) -> NonZeroUsize {\n+        // SAFETY: All the discriminants are non-zero.\n+        unsafe { NonZeroUsize::new_unchecked(self.0 as usize) }\n+    }\n+\n+    /// Returns the base 2 logarithm of the alignment.\n+    ///\n+    /// This is always exact, as `self` represents a power of two.\n+    #[inline]\n+    pub(crate) fn log2(self) -> u32 {\n+        self.as_nonzero().trailing_zeros()\n+    }\n+}\n+\n+impl fmt::Debug for ValidAlign {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?} (1 << {:?})\", self.as_nonzero(), self.log2())\n+    }\n+}\n+\n+impl TryFrom<NonZeroUsize> for ValidAlign {\n+    type Error = num::TryFromIntError;\n+\n+    #[inline]\n+    fn try_from(align: NonZeroUsize) -> Result<ValidAlign, Self::Error> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked for power-of-two\n+            unsafe { Ok(ValidAlign::new_unchecked(align.get())) }\n+        } else {\n+            Err(num::TryFromIntError(()))\n+        }\n+    }\n+}\n+\n+impl TryFrom<usize> for ValidAlign {\n+    type Error = num::TryFromIntError;\n+\n+    #[inline]\n+    fn try_from(align: usize) -> Result<ValidAlign, Self::Error> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked for power-of-two\n+            unsafe { Ok(ValidAlign::new_unchecked(align)) }\n+        } else {\n+            Err(num::TryFromIntError(()))\n+        }\n+    }\n+}\n+\n+impl cmp::Eq for ValidAlign {}\n+\n+impl cmp::PartialEq for ValidAlign {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.as_nonzero() == other.as_nonzero()\n+    }\n+}\n+\n+impl cmp::Ord for ValidAlign {\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> cmp::Ordering {\n+        self.as_nonzero().cmp(&other.as_nonzero())\n+    }\n+}\n+\n+impl cmp::PartialOrd for ValidAlign {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+type ValidAlignEnum = ValidAlignEnum16;\n+#[cfg(target_pointer_width = \"32\")]\n+type ValidAlignEnum = ValidAlignEnum32;\n+#[cfg(target_pointer_width = \"64\")]\n+type ValidAlignEnum = ValidAlignEnum64;\n+\n+#[derive(Copy, Clone)]\n+#[repr(u16)]\n+enum ValidAlignEnum16 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(u32)]\n+enum ValidAlignEnum32 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+    _Align1Shl16 = 1 << 16,\n+    _Align1Shl17 = 1 << 17,\n+    _Align1Shl18 = 1 << 18,\n+    _Align1Shl19 = 1 << 19,\n+    _Align1Shl20 = 1 << 20,\n+    _Align1Shl21 = 1 << 21,\n+    _Align1Shl22 = 1 << 22,\n+    _Align1Shl23 = 1 << 23,\n+    _Align1Shl24 = 1 << 24,\n+    _Align1Shl25 = 1 << 25,\n+    _Align1Shl26 = 1 << 26,\n+    _Align1Shl27 = 1 << 27,\n+    _Align1Shl28 = 1 << 28,\n+    _Align1Shl29 = 1 << 29,\n+    _Align1Shl30 = 1 << 30,\n+    _Align1Shl31 = 1 << 31,\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(u64)]\n+enum ValidAlignEnum64 {\n+    _Align1Shl0 = 1 << 0,\n+    _Align1Shl1 = 1 << 1,\n+    _Align1Shl2 = 1 << 2,\n+    _Align1Shl3 = 1 << 3,\n+    _Align1Shl4 = 1 << 4,\n+    _Align1Shl5 = 1 << 5,\n+    _Align1Shl6 = 1 << 6,\n+    _Align1Shl7 = 1 << 7,\n+    _Align1Shl8 = 1 << 8,\n+    _Align1Shl9 = 1 << 9,\n+    _Align1Shl10 = 1 << 10,\n+    _Align1Shl11 = 1 << 11,\n+    _Align1Shl12 = 1 << 12,\n+    _Align1Shl13 = 1 << 13,\n+    _Align1Shl14 = 1 << 14,\n+    _Align1Shl15 = 1 << 15,\n+    _Align1Shl16 = 1 << 16,\n+    _Align1Shl17 = 1 << 17,\n+    _Align1Shl18 = 1 << 18,\n+    _Align1Shl19 = 1 << 19,\n+    _Align1Shl20 = 1 << 20,\n+    _Align1Shl21 = 1 << 21,\n+    _Align1Shl22 = 1 << 22,\n+    _Align1Shl23 = 1 << 23,\n+    _Align1Shl24 = 1 << 24,\n+    _Align1Shl25 = 1 << 25,\n+    _Align1Shl26 = 1 << 26,\n+    _Align1Shl27 = 1 << 27,\n+    _Align1Shl28 = 1 << 28,\n+    _Align1Shl29 = 1 << 29,\n+    _Align1Shl30 = 1 << 30,\n+    _Align1Shl31 = 1 << 31,\n+    _Align1Shl32 = 1 << 32,\n+    _Align1Shl33 = 1 << 33,\n+    _Align1Shl34 = 1 << 34,\n+    _Align1Shl35 = 1 << 35,\n+    _Align1Shl36 = 1 << 36,\n+    _Align1Shl37 = 1 << 37,\n+    _Align1Shl38 = 1 << 38,\n+    _Align1Shl39 = 1 << 39,\n+    _Align1Shl40 = 1 << 40,\n+    _Align1Shl41 = 1 << 41,\n+    _Align1Shl42 = 1 << 42,\n+    _Align1Shl43 = 1 << 43,\n+    _Align1Shl44 = 1 << 44,\n+    _Align1Shl45 = 1 << 45,\n+    _Align1Shl46 = 1 << 46,\n+    _Align1Shl47 = 1 << 47,\n+    _Align1Shl48 = 1 << 48,\n+    _Align1Shl49 = 1 << 49,\n+    _Align1Shl50 = 1 << 50,\n+    _Align1Shl51 = 1 << 51,\n+    _Align1Shl52 = 1 << 52,\n+    _Align1Shl53 = 1 << 53,\n+    _Align1Shl54 = 1 << 54,\n+    _Align1Shl55 = 1 << 55,\n+    _Align1Shl56 = 1 << 56,\n+    _Align1Shl57 = 1 << 57,\n+    _Align1Shl58 = 1 << 58,\n+    _Align1Shl59 = 1 << 59,\n+    _Align1Shl60 = 1 << 60,\n+    _Align1Shl61 = 1 << 61,\n+    _Align1Shl62 = 1 << 62,\n+    _Align1Shl63 = 1 << 63,\n+}"}, {"sha": "628ac3a45ff04d49f6c66e26fad1d77ed4012ea6", "filename": "library/core/tests/alloc.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Ftests%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/library%2Fcore%2Ftests%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Falloc.rs?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -11,3 +11,21 @@ fn const_unchecked_layout() {\n     assert_eq!(LAYOUT.align(), ALIGN);\n     assert_eq!(Some(DANGLING), NonNull::new(ALIGN as *mut u8));\n }\n+\n+#[test]\n+fn layout_debug_shows_log2_of_alignment() {\n+    // `Debug` is not stable, but here's what it does right now\n+    let layout = Layout::from_size_align(24576, 8192).unwrap();\n+    let s = format!(\"{:?}\", layout);\n+    assert_eq!(s, \"Layout { size_: 24576, align_: 8192 (1 << 13) }\");\n+}\n+\n+// Running this normally doesn't do much, but it's also run in Miri, which\n+// will double-check that these are allowed by the validity invariants.\n+#[test]\n+fn layout_accepts_all_valid_alignments() {\n+    for align in 0..usize::BITS {\n+        let layout = Layout::from_size_align(0, 1_usize << align).unwrap();\n+        assert_eq!(layout.align(), 1_usize << align);\n+    }\n+}"}, {"sha": "1490314a767884e02ddbca5584d871e42f9ac635", "filename": "src/test/ui/consts/std/alloc.32bit.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.32bit.stderr?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -1,14 +1,25 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:8:1\n+  --> $DIR/alloc.rs:9:1\n    |\n-LL | const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_: encountered 0, but expected something greater or equal to 1\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 4) {\n                00 10 00 00 00 00 00 00                         \u2502 ........\n            }\n \n-error: aborting due to previous error\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/alloc.rs:13:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x00000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               09 00 00 00 03 00 00 00                         \u2502 ........\n+           }\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "58349feec63d476917c2f8f17ce096b067d445df", "filename": "src/test/ui/consts/std/alloc.64bit.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.64bit.stderr?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -1,14 +1,25 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/alloc.rs:8:1\n+  --> $DIR/alloc.rs:9:1\n    |\n-LL | const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_: encountered 0, but expected something greater or equal to 1\n+LL | const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x0000000000000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 16, align: 8) {\n                00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n            }\n \n-error: aborting due to previous error\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/alloc.rs:13:1\n+   |\n+LL | const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .align_.0.<enum-tag>: encountered 0x0000000000000003, but expected a valid enum tag\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               09 00 00 00 00 00 00 00 03 00 00 00 00 00 00 00 \u2502 ................\n+           }\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "708b954e84aeae95b429ef35dc545e2f17152bac", "filename": "src/test/ui/consts/std/alloc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Falloc.rs?ref=fe0c08a4f24ff7e6fb03b61656436bfa5ff29ac7", "patch": "@@ -1,11 +1,16 @@\n // stderr-per-bitwidth\n+// ignore-debug (the debug assertions change the error)\n use std::alloc::Layout;\n \n // ok\n const LAYOUT_VALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x08) };\n \n // not ok, since alignment needs to be non-zero.\n-const LAYOUT_INVALID: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+const LAYOUT_INVALID_ZERO: Layout = unsafe { Layout::from_size_align_unchecked(0x1000, 0x00) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// not ok, since alignment needs to be a power of two.\n+const LAYOUT_INVALID_THREE: Layout = unsafe { Layout::from_size_align_unchecked(9, 3) };\n //~^ ERROR it is undefined behavior to use this value\n \n fn main() {}"}]}