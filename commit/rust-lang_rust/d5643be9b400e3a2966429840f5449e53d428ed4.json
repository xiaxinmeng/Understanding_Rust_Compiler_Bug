{"sha": "d5643be9b400e3a2966429840f5449e53d428ed4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NjQzYmU5YjQwMGUzYTI5NjY0Mjk4NDBmNTQ0OWU1M2Q0MjhlZDQ=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2019-06-04T20:39:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-04T20:39:38Z"}, "message": "Rollup merge of #61488 - matthewjasper:fix-nll-typeck-ices, r=pnkfelix\n\nFix NLL typeck ICEs\n\n* Don't ICE when a type containing a region is constrained by nothing\n* Don't ICE trying to normalize a type in a `ParamEnv` containing global bounds.\n\nTo explain what was happening in the `issue-61311-normalize.rs` case:\n\n* When borrow checking the `the_fn` in the last `impl` we would try to normalize `Self::Proj` (`<Unit as HasProjFn>::Proj`).\n* We would find the `impl` that we're checking and and check its `where` clause.\n* This would need us to check `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound`\n* We find two possible implementations, the blanket impl and the bound in our `ParamEnv`.\n* The bound in our `ParamEnv` was canonicalized, so we don't see it as a global bound. As such we prefer it to the `impl`.\n* This means that we cannot normalize `<Box<dyn Obj + 'static> as HasProj>::Proj` to `Unit`.\n* The `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound` bound, which looks like it should be in our `ParamEnv` has been normalized to `Unit: Bound`.\n* We fail to prove `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound`.\n* We ICE, since we believe typeck have errored.\n\nCloses #61311\nCloses #61315\nCloses #61320\n\nr? @pnkfelix\ncc @nikomatsakis", "tree": {"sha": "0aa0638b9da4d562d7b4ef74c85d0f26183a3b8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aa0638b9da4d562d7b4ef74c85d0f26183a3b8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5643be9b400e3a2966429840f5449e53d428ed4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc9tcKCRBK7hj4Ov3rIwAAdHIIACGuM6wOll0zxefDMdLVjchG\ni3QiHcthqM5pzm19tdZFQ5LNJmeyrGQ0CZqgYIUt+ZR0AhUZK2GIPcmzhtMgftMw\nNcYyRDHYvkkPaOrs1gU5aaR0ZHguh/jR48I2b0CtrBOiYxCAKXkePXc4n6s4EE5G\nP5tcMu4953+pLAuZPHXiF0xrBYKC/Dk15YBcvhBtWIqfTZoDN5F1T6N9/H7kg85h\nIunJ8hAc+ucC6THJzh+5L+IwQDP6AlX9XiOGTve5H3Oxdu4rlE9VdMNZgkHIQpkA\nLMljPPrZTRuDsKB4vKw0a6ENsqCXGR64xyt8ev0IIq4/YwyEMPbdoJ1hWo/9IN0=\n=bT4u\n-----END PGP SIGNATURE-----\n", "payload": "tree 0aa0638b9da4d562d7b4ef74c85d0f26183a3b8c\nparent 98176fc8fbd0ae9ae2629a4929aea18bee8acb9b\nparent 794239d9a4f9ce0e1a0fb26ee737c80044b76587\nauthor Pietro Albini <pietro@pietroalbini.org> 1559680778 +0200\ncommitter GitHub <noreply@github.com> 1559680778 +0200\n\nRollup merge of #61488 - matthewjasper:fix-nll-typeck-ices, r=pnkfelix\n\nFix NLL typeck ICEs\n\n* Don't ICE when a type containing a region is constrained by nothing\n* Don't ICE trying to normalize a type in a `ParamEnv` containing global bounds.\n\nTo explain what was happening in the `issue-61311-normalize.rs` case:\n\n* When borrow checking the `the_fn` in the last `impl` we would try to normalize `Self::Proj` (`<Unit as HasProjFn>::Proj`).\n* We would find the `impl` that we're checking and and check its `where` clause.\n* This would need us to check `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound`\n* We find two possible implementations, the blanket impl and the bound in our `ParamEnv`.\n* The bound in our `ParamEnv` was canonicalized, so we don't see it as a global bound. As such we prefer it to the `impl`.\n* This means that we cannot normalize `<Box<dyn Obj + 'static> as HasProj>::Proj` to `Unit`.\n* The `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound` bound, which looks like it should be in our `ParamEnv` has been normalized to `Unit: Bound`.\n* We fail to prove `<Box<dyn Obj + 'static> as HasProj>::Proj: Bound`.\n* We ICE, since we believe typeck have errored.\n\nCloses #61311\nCloses #61315\nCloses #61320\n\nr? @pnkfelix\ncc @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5643be9b400e3a2966429840f5449e53d428ed4", "html_url": "https://github.com/rust-lang/rust/commit/d5643be9b400e3a2966429840f5449e53d428ed4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5643be9b400e3a2966429840f5449e53d428ed4/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98176fc8fbd0ae9ae2629a4929aea18bee8acb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/98176fc8fbd0ae9ae2629a4929aea18bee8acb9b", "html_url": "https://github.com/rust-lang/rust/commit/98176fc8fbd0ae9ae2629a4929aea18bee8acb9b"}, {"sha": "794239d9a4f9ce0e1a0fb26ee737c80044b76587", "url": "https://api.github.com/repos/rust-lang/rust/commits/794239d9a4f9ce0e1a0fb26ee737c80044b76587", "html_url": "https://github.com/rust-lang/rust/commit/794239d9a4f9ce0e1a0fb26ee737c80044b76587"}], "stats": {"total": 226, "additions": 222, "deletions": 4}, "files": [{"sha": "ae4bfcaa90373920757386fd310b806a63815398", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -115,13 +115,17 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// A hacky variant of `canonicalize_query` that does not\n     /// canonicalize `'static`. Unfortunately, the existing leak\n-    /// check treaks `'static` differently in some cases (see also\n+    /// check treats `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n+    ///\n+    /// `'static` is also special cased when winnowing candidates when\n+    /// selecting implementation candidates, so we also have to leave `'static`\n+    /// alone for queries that do selection.\n     //\n-    // FIXME(#48536): once we have universes, we can remove this and just use\n-    // `canonicalize_query`.\n+    // FIXME(#48536): once the above issues are resolved, we can remove this\n+    // and just use `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,"}, {"sha": "0b20ec884fc4d8f484bab7aa3345b277ecd36af2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -145,7 +145,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 let mut orig_values = OriginalQueryValues::default();\n-                let c_data = self.infcx.canonicalize_query(\n+                // HACK(matthewjasper) `'static` is special-cased in selection,\n+                // so we cannot canonicalize it.\n+                let c_data = self.infcx.canonicalize_hr_query_hack(\n                     &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);"}, {"sha": "361353f8df4c8f864962b69b514421a57b7ea1e7", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -334,6 +334,13 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n \n             match outlives_bound {\n                 OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // `where Type:` is lowered to `where Type: 'empty` so that\n+                    // we check `Type` is well formed, but there's no use for\n+                    // this bound here.\n+                    if let ty::ReEmpty = r1 {\n+                        return;\n+                    }\n+\n                     // The bound says that `r1 <= r2`; we store `r2: r1`.\n                     let r1 = self.universal_regions.to_region_vid(r1);\n                     let r2 = self.universal_regions.to_region_vid(r2);"}, {"sha": "75431d40ce54221952f857a018b23207a49c44cb", "filename": "src/test/ui/nll/empty-type-predicate.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fempty-type-predicate.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -0,0 +1,11 @@\n+// Regression test for #61315\n+//\n+// `dyn T:` is lowered to `dyn T: ReEmpty` - check that we don't ICE in NLL for\n+// the unexpected region.\n+\n+// compile-pass\n+\n+trait T {}\n+fn f() where dyn T: {}\n+\n+fn main() {}"}, {"sha": "1164e9ef2d62feb77d2805cad013ac7db251de82", "filename": "src/test/ui/nll/issue-61311-normalize.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61311-normalize.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -0,0 +1,34 @@\n+// Regression test for #61311\n+// We would ICE after failing to normalize `Self::Proj` in the `impl` below.\n+\n+// compile-pass\n+\n+pub struct Unit;\n+trait Obj {}\n+\n+trait Bound {}\n+impl Bound for Unit {}\n+\n+pub trait HasProj {\n+    type Proj;\n+}\n+\n+impl<T> HasProj for T {\n+    type Proj = Unit;\n+}\n+\n+trait HasProjFn {\n+    type Proj;\n+    fn the_fn(_: Self::Proj);\n+}\n+\n+impl HasProjFn for Unit\n+where\n+    Box<dyn Obj + 'static>: HasProj,\n+    <Box<dyn Obj + 'static> as HasProj>::Proj: Bound,\n+{\n+    type Proj = Unit;\n+    fn the_fn(_: Self::Proj) {}\n+}\n+\n+fn main() {}"}, {"sha": "a36ccd36113b586c9e577f973ee3e96b4ae9e9fe", "filename": "src/test/ui/nll/issue-61320-normalize.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5643be9b400e3a2966429840f5449e53d428ed4/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-61320-normalize.rs?ref=d5643be9b400e3a2966429840f5449e53d428ed4", "patch": "@@ -0,0 +1,160 @@\n+// Regression test for #61320\n+// This is the same issue as #61311, just a larger test case.\n+\n+// compile-pass\n+\n+pub struct AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture,\n+{\n+    state: (A, B::Future, F),\n+}\n+\n+pub struct FutureResult<T, E> {\n+    inner: Option<Result<T, E>>,\n+}\n+\n+impl<T, E> Future for FutureResult<T, E> {\n+    type Item = T;\n+    type Error = E;\n+\n+    fn poll(&mut self) -> Poll<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub type Poll<T, E> = Result<T, E>;\n+\n+impl<A, B, F> Future for AndThen<A, B, F>\n+where\n+    A: Future,\n+    B: IntoFuture<Error = A::Error>,\n+    F: FnOnce(A::Item) -> B,\n+{\n+    type Item = B::Item;\n+    type Error = B::Error;\n+\n+    fn poll(&mut self) -> Poll<B::Item, B::Error> {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait Future {\n+    type Item;\n+\n+    type Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;\n+\n+    fn and_then<F, B>(self, f: F) -> AndThen<Self, B, F>\n+    where\n+        F: FnOnce(Self::Item) -> B,\n+        B: IntoFuture<Error = Self::Error>,\n+        Self: Sized,\n+    {\n+        unimplemented!()\n+    }\n+}\n+\n+pub trait IntoFuture {\n+    /// The future that this type can be converted into.\n+    type Future: Future<Item = Self::Item, Error = Self::Error>;\n+\n+    /// The item that the future may resolve with.\n+    type Item;\n+    /// The error that the future may resolve with.\n+    type Error;\n+\n+    /// Consumes this object and produces a future.\n+    fn into_future(self) -> Self::Future;\n+}\n+\n+impl<F: Future> IntoFuture for F {\n+    type Future = F;\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn into_future(self) -> F {\n+        self\n+    }\n+}\n+\n+impl<F: ?Sized + Future> Future for ::std::boxed::Box<F> {\n+    type Item = F::Item;\n+    type Error = F::Error;\n+\n+    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {\n+        (**self).poll()\n+    }\n+}\n+\n+impl<T, E> IntoFuture for Result<T, E> {\n+    type Future = FutureResult<T, E>;\n+    type Item = T;\n+    type Error = E;\n+\n+    fn into_future(self) -> FutureResult<T, E> {\n+        unimplemented!()\n+    }\n+}\n+\n+struct Request<T>(T);\n+\n+trait RequestContext {}\n+impl<T> RequestContext for T {}\n+struct NoContext;\n+impl AsRef<NoContext> for NoContext {\n+    fn as_ref(&self) -> &Self {\n+        &NoContext\n+    }\n+}\n+\n+type BoxedError = Box<dyn std::error::Error + Send + Sync>;\n+type DefaultFuture<T, E> = Box<dyn Future<Item = T, Error = E> + Send>;\n+\n+trait Guard: Sized {\n+    type Result: IntoFuture<Item = Self, Error = BoxedError>;\n+    fn from_request(request: &Request<()>) -> Self::Result;\n+}\n+\n+trait FromRequest: Sized {\n+    type Context;\n+    type Future: Future<Item = Self, Error = BoxedError> + Send;\n+    fn from_request(request: Request<()>) -> Self::Future;\n+}\n+\n+struct MyGuard;\n+impl Guard for MyGuard {\n+    type Result = Result<Self, BoxedError>;\n+    fn from_request(_request: &Request<()>) -> Self::Result {\n+        Ok(MyGuard)\n+    }\n+}\n+\n+struct Generic<I> {\n+    _inner: I,\n+}\n+\n+impl<I> FromRequest for Generic<I>\n+where\n+    MyGuard: Guard,\n+    <MyGuard as Guard>::Result: IntoFuture<Item = MyGuard, Error = BoxedError>,\n+    <<MyGuard as Guard>::Result as IntoFuture>::Future: Send,\n+    I: FromRequest<Context = NoContext>,\n+{\n+    type Future = DefaultFuture<Self, BoxedError>;\n+    type Context = NoContext;\n+    fn from_request(headers: Request<()>) -> DefaultFuture<Self, BoxedError> {\n+        let _future = <MyGuard as Guard>::from_request(&headers)\n+            .into_future()\n+            .and_then(move |_| {\n+                <I as FromRequest>::from_request(headers)\n+                    .into_future()\n+                    .and_then(move |fld_inner| Ok(Generic { _inner: fld_inner }).into_future())\n+            });\n+        panic!();\n+    }\n+}\n+\n+fn main() {}"}]}