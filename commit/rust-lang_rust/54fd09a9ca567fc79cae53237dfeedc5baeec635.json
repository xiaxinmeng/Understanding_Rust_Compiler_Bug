{"sha": "54fd09a9ca567fc79cae53237dfeedc5baeec635", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZmQwOWE5Y2E1NjdmYzc5Y2FlNTMyMzdkZmVlZGM1YmFlZWM2MzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:27:23Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T16:27:23Z"}, "message": "Finalize Path grammar", "tree": {"sha": "3515a9fb1fc14b6cb66bb3a322b9fc5a9f55faf1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3515a9fb1fc14b6cb66bb3a322b9fc5a9f55faf1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54fd09a9ca567fc79cae53237dfeedc5baeec635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54fd09a9ca567fc79cae53237dfeedc5baeec635", "html_url": "https://github.com/rust-lang/rust/commit/54fd09a9ca567fc79cae53237dfeedc5baeec635", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54fd09a9ca567fc79cae53237dfeedc5baeec635/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d28289d0f83225672fc42abcf684364582e73c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d28289d0f83225672fc42abcf684364582e73c5", "html_url": "https://github.com/rust-lang/rust/commit/8d28289d0f83225672fc42abcf684364582e73c5"}], "stats": {"total": 980, "additions": 492, "deletions": 488}, "files": [{"sha": "1a707ad678fb838afeacbc576b46a467bbc0abed", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 462, "deletions": 461, "changes": 923, "blob_url": "https://github.com/rust-lang/rust/blob/54fd09a9ca567fc79cae53237dfeedc5baeec635/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54fd09a9ca567fc79cae53237dfeedc5baeec635/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=54fd09a9ca567fc79cae53237dfeedc5baeec635", "patch": "@@ -6,6 +6,137 @@ use crate::{\n     SyntaxNode, SyntaxToken, T,\n };\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Path {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl Path {\n+    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl PathSegment {\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n+    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n+    pub fn super_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![super]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n+    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n+    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n+    pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct NameRef {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl NameRef {\n+    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeArgList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl TypeArgList {\n+    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n+    pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n+    pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n+    pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n+    pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ParamList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ParamList {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n+    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }\n+    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RetType {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl RetType {\n+    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathType {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl PathType {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl TypeArg {\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LifetimeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl LifetimeArg {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AssocTypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::TypeBoundsOwner for AssocTypeArg {}\n+impl AssocTypeArg {\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ConstArg {\n+    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n+    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeBoundList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl TypeBoundList {\n+    pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Literal {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for Literal {}\n+impl Literal {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BlockExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for BlockExpr {}\n+impl BlockExpr {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SourceFile {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -256,13 +387,6 @@ impl ItemList {\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NameRef {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl NameRef {\n-    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Rename {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -283,15 +407,6 @@ impl UseTree {\n     pub fn rename(&self) -> Option<Rename> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl Path {\n-    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n-    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct UseTreeList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -317,25 +432,6 @@ impl GenericParamList {\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParamList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ParamList {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn self_param(&self) -> Option<SelfParam> { support::child(&self.syntax) }\n-    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }\n-    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RetType {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl RetType {\n-    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![->]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -344,17 +440,6 @@ impl WhereClause {\n     pub fn predicates(&self) -> AstChildren<WherePred> { support::children(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BlockExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for BlockExpr {}\n-impl BlockExpr {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct SelfParam {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -381,13 +466,6 @@ impl Param {\n     pub fn dotdotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![...]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeBoundList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl TypeBoundList {\n-    pub fn bounds(&self) -> AstChildren<TypeBound> { support::children(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct RecordFieldList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -515,12 +593,6 @@ impl WherePred {\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Literal {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for Literal {}\n-impl Literal {}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -866,19 +938,6 @@ impl ArgList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeArgList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl TypeArgList {\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn type_args(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }\n-    pub fn lifetime_args(&self) -> AstChildren<LifetimeArg> { support::children(&self.syntax) }\n-    pub fn assoc_type_args(&self) -> AstChildren<AssocTypeArg> { support::children(&self.syntax) }\n-    pub fn const_args(&self) -> AstChildren<ConstArg> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -991,13 +1050,6 @@ impl ParenType {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathType {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl PathType {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -1220,91 +1272,40 @@ impl MacroStmts {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathSegment {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl PathSegment {\n-    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }\n-    pub fn crate_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![crate]) }\n-    pub fn self_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![self]) }\n-    pub fn super_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![super]) }\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n-    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n-    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n-    pub fn path_type(&self) -> Option<PathType> { support::child(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+pub enum Type {\n+    ArrayType(ArrayType),\n+    DynTraitType(DynTraitType),\n+    FnPointerType(FnPointerType),\n+    ForType(ForType),\n+    ImplTraitType(ImplTraitType),\n+    InferType(InferType),\n+    NeverType(NeverType),\n+    ParenType(ParenType),\n+    PathType(PathType),\n+    PointerType(PointerType),\n+    ReferenceType(ReferenceType),\n+    SliceType(SliceType),\n+    TupleType(TupleType),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeArg {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl TypeArg {\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LifetimeArg {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl LifetimeArg {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct AssocTypeArg {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::TypeBoundsOwner for AssocTypeArg {}\n-impl AssocTypeArg {\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ConstArg {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ConstArg {\n-    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n-    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum Item {\n-    Const(Const),\n-    Enum(Enum),\n-    ExternBlock(ExternBlock),\n-    ExternCrate(ExternCrate),\n-    Fn(Fn),\n-    Impl(Impl),\n-    MacroCall(MacroCall),\n-    Module(Module),\n-    Static(Static),\n-    Struct(Struct),\n-    Trait(Trait),\n-    TypeAlias(TypeAlias),\n-    Union(Union),\n-    Use(Use),\n+pub enum Item {\n+    Const(Const),\n+    Enum(Enum),\n+    ExternBlock(ExternBlock),\n+    ExternCrate(ExternCrate),\n+    Fn(Fn),\n+    Impl(Impl),\n+    MacroCall(MacroCall),\n+    Module(Module),\n+    Static(Static),\n+    Struct(Struct),\n+    Trait(Trait),\n+    TypeAlias(TypeAlias),\n+    Union(Union),\n+    Use(Use),\n }\n impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum Type {\n-    ArrayType(ArrayType),\n-    DynTraitType(DynTraitType),\n-    FnPointerType(FnPointerType),\n-    ForType(ForType),\n-    ImplTraitType(ImplTraitType),\n-    InferType(InferType),\n-    NeverType(NeverType),\n-    ParenType(ParenType),\n-    PathType(PathType),\n-    PointerType(PointerType),\n-    ReferenceType(ReferenceType),\n-    SliceType(SliceType),\n-    TupleType(TupleType),\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n     OrPat(OrPat),\n     ParenPat(ParenPat),\n@@ -1400,8 +1401,8 @@ pub enum Stmt {\n     Item(Item),\n     LetStmt(LetStmt),\n }\n-impl AstNode for SourceFile {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n+impl AstNode for Path {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1411,8 +1412,8 @@ impl AstNode for SourceFile {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Attr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }\n+impl AstNode for PathSegment {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1422,8 +1423,8 @@ impl AstNode for Attr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Const {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }\n+impl AstNode for NameRef {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1433,8 +1434,8 @@ impl AstNode for Const {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Enum {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }\n+impl AstNode for TypeArgList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1444,8 +1445,8 @@ impl AstNode for Enum {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExternBlock {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_BLOCK }\n+impl AstNode for ParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1455,8 +1456,8 @@ impl AstNode for ExternBlock {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExternCrate {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_CRATE }\n+impl AstNode for RetType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1466,8 +1467,8 @@ impl AstNode for ExternCrate {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Fn {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FN }\n+impl AstNode for PathType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1477,8 +1478,8 @@ impl AstNode for Fn {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Impl {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL }\n+impl AstNode for TypeArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1488,8 +1489,8 @@ impl AstNode for Impl {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MacroCall {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n+impl AstNode for LifetimeArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1499,8 +1500,8 @@ impl AstNode for MacroCall {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Module {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }\n+impl AstNode for AssocTypeArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_TYPE_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1510,8 +1511,8 @@ impl AstNode for Module {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Static {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC }\n+impl AstNode for ConstArg {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1521,8 +1522,8 @@ impl AstNode for Static {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Struct {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT }\n+impl AstNode for TypeBoundList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1532,8 +1533,8 @@ impl AstNode for Struct {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Trait {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT }\n+impl AstNode for Literal {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1543,8 +1544,8 @@ impl AstNode for Trait {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeAlias {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ALIAS }\n+impl AstNode for BlockExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1554,8 +1555,8 @@ impl AstNode for TypeAlias {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Union {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION }\n+impl AstNode for SourceFile {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1565,8 +1566,8 @@ impl AstNode for Union {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Use {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE }\n+impl AstNode for Attr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1576,8 +1577,8 @@ impl AstNode for Use {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Visibility {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }\n+impl AstNode for Const {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1587,8 +1588,8 @@ impl AstNode for Visibility {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Name {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n+impl AstNode for Enum {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1598,8 +1599,8 @@ impl AstNode for Name {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ItemList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }\n+impl AstNode for ExternBlock {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_BLOCK }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1609,8 +1610,8 @@ impl AstNode for ItemList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for NameRef {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }\n+impl AstNode for ExternCrate {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_CRATE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1620,8 +1621,8 @@ impl AstNode for NameRef {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Rename {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RENAME }\n+impl AstNode for Fn {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FN }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1631,8 +1632,8 @@ impl AstNode for Rename {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for UseTree {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }\n+impl AstNode for Impl {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1642,8 +1643,8 @@ impl AstNode for UseTree {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Path {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }\n+impl AstNode for MacroCall {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_CALL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1653,8 +1654,8 @@ impl AstNode for Path {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for UseTreeList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_LIST }\n+impl AstNode for Module {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1664,8 +1665,8 @@ impl AstNode for UseTreeList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Abi {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ABI }\n+impl AstNode for Static {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1675,8 +1676,8 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for GenericParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n+impl AstNode for Struct {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1686,8 +1687,8 @@ impl AstNode for GenericParamList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }\n+impl AstNode for Trait {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1697,8 +1698,8 @@ impl AstNode for ParamList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RetType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }\n+impl AstNode for TypeAlias {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ALIAS }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1708,8 +1709,8 @@ impl AstNode for RetType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for WhereClause {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n+impl AstNode for Union {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1719,8 +1720,8 @@ impl AstNode for WhereClause {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BlockExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }\n+impl AstNode for Use {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1730,8 +1731,8 @@ impl AstNode for BlockExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for SelfParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_PARAM }\n+impl AstNode for Visibility {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1741,8 +1742,8 @@ impl AstNode for SelfParam {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Param {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }\n+impl AstNode for Name {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1752,8 +1753,96 @@ impl AstNode for Param {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeBoundList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n+impl AstNode for ItemList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for Rename {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RENAME }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for UseTree {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for UseTreeList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_TREE_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for Abi {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ABI }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for GenericParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for WhereClause {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for SelfParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_PARAM }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl AstNode for Param {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1895,17 +1984,6 @@ impl AstNode for WherePred {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Literal {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for TokenTree {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == TOKEN_TREE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2280,17 +2358,6 @@ impl AstNode for ArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeArgList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for Condition {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2423,17 +2490,6 @@ impl AstNode for ParenType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for PointerType {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2709,60 +2765,90 @@ impl AstNode for MacroStmts {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathSegment {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+impl From<ArrayType> for Type {\n+    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n }\n-impl AstNode for TypeArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+impl From<DynTraitType> for Type {\n+    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n }\n-impl AstNode for LifetimeArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_ARG }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n+impl From<FnPointerType> for Type {\n+    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n+}\n+impl From<ForType> for Type {\n+    fn from(node: ForType) -> Type { Type::ForType(node) }\n+}\n+impl From<ImplTraitType> for Type {\n+    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n+}\n+impl From<InferType> for Type {\n+    fn from(node: InferType) -> Type { Type::InferType(node) }\n+}\n+impl From<NeverType> for Type {\n+    fn from(node: NeverType) -> Type { Type::NeverType(node) }\n+}\n+impl From<ParenType> for Type {\n+    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n+}\n+impl From<PathType> for Type {\n+    fn from(node: PathType) -> Type { Type::PathType(node) }\n+}\n+impl From<PointerType> for Type {\n+    fn from(node: PointerType) -> Type { Type::PointerType(node) }\n+}\n+impl From<ReferenceType> for Type {\n+    fn from(node: ReferenceType) -> Type { Type::ReferenceType(node) }\n+}\n+impl From<SliceType> for Type {\n+    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n+}\n+impl From<TupleType> for Type {\n+    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n+}\n+impl AstNode for Type {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ARRAY_TYPE | DYN_TRAIT_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE\n+            | INFER_TYPE | NEVER_TYPE | PAREN_TYPE | PATH_TYPE | POINTER_TYPE | REFERENCE_TYPE\n+            | SLICE_TYPE | TUPLE_TYPE => true,\n+            _ => false,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for AssocTypeArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSOC_TYPE_ARG }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n+        let res = match syntax.kind() {\n+            ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),\n+            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n+            FN_POINTER_TYPE => Type::FnPointerType(FnPointerType { syntax }),\n+            FOR_TYPE => Type::ForType(ForType { syntax }),\n+            IMPL_TRAIT_TYPE => Type::ImplTraitType(ImplTraitType { syntax }),\n+            INFER_TYPE => Type::InferType(InferType { syntax }),\n+            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n+            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n+            PATH_TYPE => Type::PathType(PathType { syntax }),\n+            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n+            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n+            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n+            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n     }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n-impl AstNode for ConstArg {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_ARG }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            Type::ArrayType(it) => &it.syntax,\n+            Type::DynTraitType(it) => &it.syntax,\n+            Type::FnPointerType(it) => &it.syntax,\n+            Type::ForType(it) => &it.syntax,\n+            Type::ImplTraitType(it) => &it.syntax,\n+            Type::InferType(it) => &it.syntax,\n+            Type::NeverType(it) => &it.syntax,\n+            Type::ParenType(it) => &it.syntax,\n+            Type::PathType(it) => &it.syntax,\n+            Type::PointerType(it) => &it.syntax,\n+            Type::ReferenceType(it) => &it.syntax,\n+            Type::SliceType(it) => &it.syntax,\n+            Type::TupleType(it) => &it.syntax,\n         }\n     }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n impl From<Const> for Item {\n     fn from(node: Const) -> Item { Item::Const(node) }\n@@ -2853,91 +2939,6 @@ impl AstNode for Item {\n         }\n     }\n }\n-impl From<ArrayType> for Type {\n-    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n-}\n-impl From<DynTraitType> for Type {\n-    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n-}\n-impl From<FnPointerType> for Type {\n-    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n-}\n-impl From<ForType> for Type {\n-    fn from(node: ForType) -> Type { Type::ForType(node) }\n-}\n-impl From<ImplTraitType> for Type {\n-    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n-}\n-impl From<InferType> for Type {\n-    fn from(node: InferType) -> Type { Type::InferType(node) }\n-}\n-impl From<NeverType> for Type {\n-    fn from(node: NeverType) -> Type { Type::NeverType(node) }\n-}\n-impl From<ParenType> for Type {\n-    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n-}\n-impl From<PathType> for Type {\n-    fn from(node: PathType) -> Type { Type::PathType(node) }\n-}\n-impl From<PointerType> for Type {\n-    fn from(node: PointerType) -> Type { Type::PointerType(node) }\n-}\n-impl From<ReferenceType> for Type {\n-    fn from(node: ReferenceType) -> Type { Type::ReferenceType(node) }\n-}\n-impl From<SliceType> for Type {\n-    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n-}\n-impl From<TupleType> for Type {\n-    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n-}\n-impl AstNode for Type {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ARRAY_TYPE | DYN_TRAIT_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE\n-            | INFER_TYPE | NEVER_TYPE | PAREN_TYPE | PATH_TYPE | POINTER_TYPE | REFERENCE_TYPE\n-            | SLICE_TYPE | TUPLE_TYPE => true,\n-            _ => false,\n-        }\n-    }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        let res = match syntax.kind() {\n-            ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),\n-            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n-            FN_POINTER_TYPE => Type::FnPointerType(FnPointerType { syntax }),\n-            FOR_TYPE => Type::ForType(ForType { syntax }),\n-            IMPL_TRAIT_TYPE => Type::ImplTraitType(ImplTraitType { syntax }),\n-            INFER_TYPE => Type::InferType(InferType { syntax }),\n-            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n-            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n-            PATH_TYPE => Type::PathType(PathType { syntax }),\n-            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n-            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n-            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n-            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n-            _ => return None,\n-        };\n-        Some(res)\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        match self {\n-            Type::ArrayType(it) => &it.syntax,\n-            Type::DynTraitType(it) => &it.syntax,\n-            Type::FnPointerType(it) => &it.syntax,\n-            Type::ForType(it) => &it.syntax,\n-            Type::ImplTraitType(it) => &it.syntax,\n-            Type::InferType(it) => &it.syntax,\n-            Type::NeverType(it) => &it.syntax,\n-            Type::ParenType(it) => &it.syntax,\n-            Type::PathType(it) => &it.syntax,\n-            Type::PointerType(it) => &it.syntax,\n-            Type::ReferenceType(it) => &it.syntax,\n-            Type::SliceType(it) => &it.syntax,\n-            Type::TupleType(it) => &it.syntax,\n-        }\n-    }\n-}\n impl From<OrPat> for Pat {\n     fn from(node: OrPat) -> Pat { Pat::OrPat(node) }\n }\n@@ -3379,12 +3380,12 @@ impl From<Item> for Stmt {\n impl From<LetStmt> for Stmt {\n     fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n }\n-impl std::fmt::Display for Item {\n+impl std::fmt::Display for Type {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Type {\n+impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3429,6 +3430,76 @@ impl std::fmt::Display for Stmt {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for Path {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for PathSegment {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for NameRef {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for TypeArgList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for ParamList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for RetType {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for PathType {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for TypeArg {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for LifetimeArg {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for AssocTypeArg {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for ConstArg {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for TypeBoundList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for Literal {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl std::fmt::Display for BlockExpr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for SourceFile {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3524,11 +3595,6 @@ impl std::fmt::Display for ItemList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for NameRef {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for Rename {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3539,11 +3605,6 @@ impl std::fmt::Display for UseTree {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Path {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for UseTreeList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3559,26 +3620,11 @@ impl std::fmt::Display for GenericParamList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for RetType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for WhereClause {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BlockExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for SelfParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3589,11 +3635,6 @@ impl std::fmt::Display for Param {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeBoundList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for RecordFieldList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3654,11 +3695,6 @@ impl std::fmt::Display for WherePred {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Literal {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3829,11 +3865,6 @@ impl std::fmt::Display for ArgList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeArgList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for Condition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3894,11 +3925,6 @@ impl std::fmt::Display for ParenType {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathType {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for PointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4024,28 +4050,3 @@ impl std::fmt::Display for MacroStmts {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathSegment {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for TypeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for LifetimeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for AssocTypeArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n-impl std::fmt::Display for ConstArg {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}"}, {"sha": "13ad67ca18a856a75d39466151faf3175bde932c", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/54fd09a9ca567fc79cae53237dfeedc5baeec635/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/54fd09a9ca567fc79cae53237dfeedc5baeec635/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=54fd09a9ca567fc79cae53237dfeedc5baeec635", "patch": "@@ -1,3 +1,33 @@\n+Path =\n+  (qualifier:Path '::')? segment:PathSegment\n+\n+PathSegment =\n+  '::' | 'crate' | 'self' | 'super'\n+| (NameRef ('::'? TypeArgList)?)\n+| NameRef ParamList RetType?\n+| '<' PathType ('as' PathType)? '>'\n+\n+TypeArgList =\n+  '::'? '<'\n+    TypeArg*\n+    LifetimeArg*\n+    AssocTypeArg*\n+    ConstArg*\n+  '>'\n+\n+TypeArg =\n+  Type\n+\n+AssocTypeArg =\n+  NameRef (':' TypeBoundList | '=' Type)\n+\n+LifetimeArg =\n+  'lifetime'\n+\n+ConstArg =\n+  Literal | BlockExpr BlockExpr\n+\n+\n SourceFile =\n   'shebang'?\n   Attr*\n@@ -521,33 +551,6 @@ MacroStmts =\n   statements:Stmt*\n   Expr?\n \n-Path =\n-  (qualifier:Path '::')? segment:PathSegment\n-\n-PathSegment =\n-  '::' | 'crate' | 'self' | 'super'\n-| '<' NameRef TypeArgList ParamList RetType PathType '>'\n-\n-TypeArgList =\n-  '::'? '<'\n-    TypeArg*\n-    LifetimeArg*\n-    AssocTypeArg*\n-    ConstArg*\n-  '>'\n-\n-TypeArg =\n-  Type\n-\n-AssocTypeArg =\n-  NameRef (':' TypeBoundList | '=' Type)\n-\n-LifetimeArg =\n-  'lifetime'\n-\n-ConstArg =\n-  Literal | BlockExpr BlockExpr\n-\n Pat =\n   OrPat\n | ParenPat"}]}