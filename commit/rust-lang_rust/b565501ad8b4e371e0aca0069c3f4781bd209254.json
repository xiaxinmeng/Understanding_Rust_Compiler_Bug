{"sha": "b565501ad8b4e371e0aca0069c3f4781bd209254", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjU1MDFhZDhiNGUzNzFlMGFjYTAwNjljM2Y0NzgxYmQyMDkyNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T03:02:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-16T03:02:54Z"}, "message": "auto merge of #21213 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "a669459825ecb6e8a78d4615fa2ccc0c2dee7836", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a669459825ecb6e8a78d4615fa2ccc0c2dee7836"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b565501ad8b4e371e0aca0069c3f4781bd209254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b565501ad8b4e371e0aca0069c3f4781bd209254", "html_url": "https://github.com/rust-lang/rust/commit/b565501ad8b4e371e0aca0069c3f4781bd209254", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b565501ad8b4e371e0aca0069c3f4781bd209254/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8903c21d618fd25dca61d9bb668c5299d21feac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8903c21d618fd25dca61d9bb668c5299d21feac9", "html_url": "https://github.com/rust-lang/rust/commit/8903c21d618fd25dca61d9bb668c5299d21feac9"}, {"sha": "42198c18f46aa1841ff2870c4841eafae7ec7e8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/42198c18f46aa1841ff2870c4841eafae7ec7e8d", "html_url": "https://github.com/rust-lang/rust/commit/42198c18f46aa1841ff2870c4841eafae7ec7e8d"}], "stats": {"total": 2398, "additions": 1520, "deletions": 878}, "files": [{"sha": "896731f02515b615582a63bf49684939b5c4188e", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -581,7 +581,7 @@ Robert Knight <robertknight@gmail.com>\n Robert Millar <robert.millar@cantab.net>\n Robin Gloster <robin@loc-com.de>\n Robin Stocker <robin@nibor.org>\n-Rohit Joshi <rohit.joshi@capitalone.com>\n+Rohit Joshi <rohit.c.joshi@gmail.com>\n Roland Tanglao <roland@rolandtanglao.com>\n Rolf Timmermans <rolftimmermans@voormedia.com>\n Rolf van de Krol <info@rolfvandekrol.nl>"}, {"sha": "9f2bd6dc30c5dd9f1054a69f7f8e233d8bc092e2", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -27,7 +27,7 @@ please do two things:\n \n Pull requests will be treated as \"review requests\", and we will give\n feedback we expect to see corrected on\n-[style](https://github.com/rust-lang/rust/wiki/Note-style-guide) and\n+[style](http://aturon.github.io/) and\n substance before pulling.  Changes contributed via pull request should\n focus on a single issue at a time, like any other.  We will not accept\n pull-requests that try to \"sneak\" unrelated changes in."}, {"sha": "63c5742a540d404c0502a38326fceb06e47da22a", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -97,10 +97,9 @@\n #     make check-stage1-std RUST_TEST_TASKS=1\n #\n # This is hardly all there is to know of The Rust Build System's\n-# mysteries. The tale continues on the wiki[1][2].\n+# mysteries. The tale continues on the wiki[1].\n #\n-# [1]: https://github.com/rust-lang/rust/wiki/Note-getting-started-developing-Rust\n-# [2]: https://github.com/rust-lang/rust/wiki/Note-testsuite\n+# [1]: https://github.com/rust-lang/rust/wiki/Note-testsuite\n #\n # If you really feel like getting your hands dirty, then:\n #"}, {"sha": "147d2e9d2f44aa1c377bd06a1757616d7a3840bf", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -58,16 +58,23 @@ documentation.\n \n ### Building on Windows\n \n-To easily build on windows we can use [MSYS2](http://sourceforge.net/projects/msys2/):\n+To easily build on windows we can use [MSYS2](http://msys2.github.io/):\n \n 1. Grab the latest MSYS2 installer and go through the installer.\n 2. Now from the MSYS2 terminal we want to install the mingw64 toolchain and the other\n    tools we need.\n \n-        $ pacman -S mingw-w64-i686-toolchain\n-        $ pacman -S base-devel\n+```bash\n+# choose one based on platform\n+$ pacman -S mingw-w64-i686-toolchain\n+$ pacman -S mingw-w64-x86_64-toolchain\n \n-3. With that now start `mingw32_shell.bat` from where you installed MSYS2 (i.e. `C:\\msys`).\n+$ pacman -S base-devel\n+```\n+\n+3. With that now start `mingw32_shell.bat` or `mingw64_shell.bat`\n+   from where you installed MSYS2 (i.e. `C:\\msys`). Which one you\n+   choose depends on if you want 32 or 64 bit Rust.\n 4. From there just navigate to where you have Rust's source code, configure and build it:\n \n         $ ./configure"}, {"sha": "0219ab960579bb81239b8df362a522c7e4615834", "filename": "mk/cfg/aarch64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Faarch64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Faarch64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-apple-ios.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -11,7 +11,7 @@ AR_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos ar)\n endif\n CFG_LIB_NAME_aarch64-apple-ios = lib$(1).a\n CFG_LIB_GLOB_aarch64-apple-ios = lib$(1)-*.a\n-CFG_LIB_SKIP_INSTALL_aarch64-apple-ios = 1 #lib$(1)-*.a\n+CFG_INSTALL_ONLY_RLIB_aarch64-apple-ios = 1\n CFG_STATIC_LIB_NAME_aarch64-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_aarch64-apple-ios = lib$(1)-*.a.dSYM\n CFG_CFLAGS_aarch64-apple-ios := $(CFG_IOS_SDK_FLAGS_aarch64-apple-ios)"}, {"sha": "aee4e64addfc1834040be1717ca8379d63ea781f", "filename": "mk/cfg/armv7-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Farmv7-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Farmv7-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7-apple-ios.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -11,7 +11,7 @@ AR_armv7-apple-ios = $(shell xcrun -find -sdk iphoneos ar)\n endif\n CFG_LIB_NAME_armv7-apple-ios = lib$(1).a\n CFG_LIB_GLOB_armv7-apple-ios = lib$(1)-*.a\n-CFG_LIB_SKIP_INSTALL_armv7-apple-ios = 1 #lib$(1)-*.a\n+CFG_INSTALL_ONLY_RLIB_armv7-apple-ios = 1\n CFG_STATIC_LIB_NAME_armv7-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_armv7-apple-ios = lib$(1)-*.a.dSYM\n CFG_JEMALLOC_CFLAGS_armv7-apple-ios := -arch armv7 -mfpu=vfp3 $(CFG_IOS_SDK_FLAGS_armv7-apple-ios)"}, {"sha": "7540bd44de878211e1b540e05465c8d1c23358e4", "filename": "mk/cfg/armv7s-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Farmv7s-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Farmv7s-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farmv7s-apple-ios.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -11,7 +11,7 @@ AR_armv7s-apple-ios = $(shell xcrun -find -sdk iphoneos ar)\n endif\n CFG_LIB_NAME_armv7s-apple-ios = lib$(1).a\n CFG_LIB_GLOB_armv7s-apple-ios = lib$(1)-*.a\n-CFG_LIB_SKIP_INSTALL_armv7s-apple-ios = 1 #lib$(1)-*.a\n+CFG_INSTALL_ONLY_RLIB_armv7s-apple-ios = 1\n CFG_STATIC_LIB_NAME_armv7s-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_armv7s-apple-ios = lib$(1)-*.a.dSYM\n CFG_JEMALLOC_CFLAGS_armv7s-apple-ios := -arch armv7s -mfpu=vfp4 $(CFG_IOS_SDK_FLAGS_armv7s-apple-ios)"}, {"sha": "e84bf49d4079a39830b28f95f958e3caf1bc4c21", "filename": "mk/cfg/i386-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Fi386-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Fi386-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi386-apple-ios.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -11,6 +11,7 @@ AR_i386-apple-ios = $(shell xcrun -find -sdk iphonesimulator ar)\n endif\n CFG_LIB_NAME_i386-apple-ios = lib$(1).a\n CFG_LIB_GLOB_i386-apple-ios = lib$(1)-*.dylib\n+CFG_INSTALL_ONLY_RLIB_i386-apple-ios = 1\n CFG_STATIC_LIB_NAME_i386-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_i386-apple-ios = lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_i386-apple-ios := -Wall -Werror -g -fPIC -m32 $(CFG_IOSSIM_FLAGS_i386-apple-ios)"}, {"sha": "b3f05a895a49fe0f65c912ac9997a59270fb1744", "filename": "mk/cfg/x86_64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Fx86_64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fcfg%2Fx86_64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-apple-ios.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -11,7 +11,7 @@ AR_x86_64-apple-ios = $(shell xcrun -find -sdk iphonesimulator ar)\n endif\n CFG_LIB_NAME_x86_64-apple-ios = lib$(1).a\n CFG_LIB_GLOB_x86_64-apple-ios = lib$(1)-*.a\n-CFG_LIB_SKIP_INSTALL_x86_64-apple-ios = 1 #lib$(1)-*.a\n+CFG_INSTALL_ONLY_RLIB_x86_64-apple-ios = 1\n CFG_STATIC_LIB_NAME_x86_64-apple-ios=lib$(1).a\n CFG_LIB_DSYM_GLOB_x86_64-apple-ios = lib$(1)-*.a.dSYM\n CFG_CFLAGS_x86_64-apple-ios := $(CFG_IOSSIM_FLAGS_x86_64-apple-ios)"}, {"sha": "46cbe34904dbcb5698c457130dabbb18ad4e69b0", "filename": "mk/main.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -18,7 +18,7 @@ CFG_RELEASE_NUM=1.0.0\n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n # versions (section 9)\n-CFG_PRERELEASE_VERSION=\n+CFG_PRERELEASE_VERSION=.1\n \n CFG_FILENAME_EXTRA=4e7c5e5c\n \n@@ -30,9 +30,8 @@ CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n-# The beta channel is temporarily called 'alpha'\n-CFG_RELEASE=$(CFG_RELEASE_NUM)-alpha$(CFG_PRERELEASE_VERSION)\n-CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-alpha$(CFG_PRERELEASE_VERSION)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-beta(CFG_PRERELEASE_VERSION)\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-beta(CFG_PRERELEASE_VERSION)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)"}, {"sha": "f1c4aa65f5ffe5943b302698eda17ebdd7697bcc", "filename": "mk/prepare.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -134,7 +134,7 @@ prepare-target-$(2)-host-$(3)-$(1)-$(4): prepare-maybe-clean-$(4) \\\n         $$(if $$(findstring $(3), $$(PREPARE_HOST)), \\\n           $$(call PREPARE_DIR,$$(PREPARE_WORKING_DEST_LIB_DIR)) \\\n           $$(foreach crate,$$(TARGET_CRATES), \\\n-\t    $$(if $$(findstring 1, $$(ONLY_RLIB_$$(crate))),, \\\n+\t    $$(if $$(or $$(findstring 1, $$(ONLY_RLIB_$$(crate))),$$(findstring 1,$$(CFG_INSTALL_ONLY_RLIB_$(2)))),, \\\n               $$(call PREPARE_LIB,$$(call CFG_LIB_GLOB_$(2),$$(crate)))) \\\n             $$(call PREPARE_LIB,$$(call CFG_RLIB_GLOB,$$(crate)))) \\\n           $$(if $$(findstring $(2),$$(CFG_HOST)), \\"}, {"sha": "8238dd3a5ba42d7dcfffc4647a524c08b91b0652", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -10,7 +10,7 @@ There aren't many large programs yet. The Rust [compiler][rustc], 60,000+ lines\n \n A research browser engine called [Servo][servo], currently 30,000+ lines across more than a dozen crates, will be exercising a lot of Rust's distinctive type-system and concurrency features, and integrating many native libraries.\n \n-[servo]: https://github.com/mozilla/servo\n+[servo]: https://github.com/servo/servo\n \n Some examples that demonstrate different aspects of the language:\n "}, {"sha": "bb1805d694fd090e6085690aeef069042dc19656", "filename": "src/doc/complement-project-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fcomplement-project-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fcomplement-project-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-project-faq.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -30,7 +30,7 @@ No. It started as a Graydon Hoare's part-time side project in 2006 and remained\n \n # What will Mozilla use Rust for?\n \n-Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is _[Servo](http://github.com/mozilla/servo)_.\n+Mozilla intends to use Rust as a platform for prototyping experimental browser architectures. Specifically, the hope is to develop a browser that is more amenable to parallelization than existing ones, while also being less prone to common C++ coding errors that result in security exploits. The name of that project is _[Servo](http://github.com/servo/servo)_.\n \n # Why a BSD-style permissive license rather than MPL or tri-license?\n "}, {"sha": "d93b680ae6de704cb83fd73394475fb1681b88e8", "filename": "src/doc/intro.md", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -5,7 +5,7 @@ accomplishes these goals by being memory safe without using garbage collection.\n \n This introduction will give you a rough idea of what Rust is like, eliding many\n details. It does not require prior experience with systems programming, but you\n-may find the syntax easier if you've used a 'curly brace' programming language\n+may find the syntax easier if you've used a \"curly brace\" programming language\n before, like C or JavaScript. The concepts are more important than the syntax,\n so don't worry if you don't get every last detail: you can read [The\n Rust Programming Language](book/index.html) to get a more complete explanation.\n@@ -15,7 +15,7 @@ Rust to follow along. If you'd like to anyway, check out [the\n homepage](http://rust-lang.org) for explanation.\n \n To show off Rust, let's talk about how easy it is to get started with Rust.\n-Then, we'll talk about Rust's most interesting feature, **ownership**, and\n+Then, we'll talk about Rust's most interesting feature, *ownership*, and\n then discuss how it makes concurrency easier to reason about. Finally,\n we'll talk about how Rust breaks down the perceived dichotomy between speed\n and safety.\n@@ -57,7 +57,7 @@ version = \"0.0.1\"\n authors = [\"Your Name <you@example.com>\"]\n ```\n \n-This is called a **manifest**, and it contains all of the metadata that Cargo\n+This is called a *manifest*, and it contains all of the metadata that Cargo\n needs to compile your project.\n \n Here's what's in `src/main.rs`:\n@@ -68,7 +68,7 @@ fn main() {\n }\n ```\n \n-Cargo generated a 'hello world' for us. We'll talk more about the syntax here\n+Cargo generated a \"Hello World\" for us. We'll talk more about the syntax here\n later, but that's what Rust code looks like! Let's compile and run it:\n \n ```{bash}\n@@ -146,8 +146,8 @@ Enough about tools, let's talk code!\n \n # Ownership\n \n-Rust's defining feature is 'memory safety without garbage collection.' Let's\n-take a moment to talk about what that means. **Memory safety** means that the\n+Rust's defining feature is \"memory safety without garbage collection\". Let's\n+take a moment to talk about what that means. *Memory safety* means that the\n programming language eliminates certain kinds of bugs, such as [buffer\n overflows](http://en.wikipedia.org/wiki/Buffer_overflow) and [dangling\n pointers](http://en.wikipedia.org/wiki/Dangling_pointer). These problems occur\n@@ -170,7 +170,7 @@ We make an array, `v`, and then call `push` on it. `push` is a method which\n adds an element to the end of an array.\n \n Next, we make a new variable, `x`, that's equal to the first element of\n-the array. Simple, but this is where the 'bug' will appear.\n+the array. Simple, but this is where the \"bug\" will appear.\n \n Let's keep going. We then call `push` again, pushing \"world\" onto the\n end of the array. `v` now is `[\"Hello\", \"world\"]`.\n@@ -222,7 +222,7 @@ its length changes, we may need to allocate more memory. In Ruby, this happens\n as well, we just don't think about it very often. So why does the C++ version\n segfault when we allocate more memory?\n \n-The answer is that in the C++ version, `x` is a **reference** to the memory\n+The answer is that in the C++ version, `x` is a *reference* to the memory\n location where the first element of the array is stored. But in Ruby, `x` is a\n standalone value, not connected to the underyling array at all. Let's dig into\n the details for a moment. Your program has access to memory, provided to it by\n@@ -332,11 +332,11 @@ error: aborting due to previous error\n \n When we try to mutate the array by `push`ing it the second time, Rust throws\n an error. It says that we \"cannot borrow v as mutable because it is also\n-borrowed as immutable.\" What's up with \"borrowed\"?\n+borrowed as immutable.\" What does it mean by \"borrowed\"?\n \n-In Rust, the type system encodes the notion of **ownership**. The variable `v`\n-is an \"owner\" of the vector. When we make a reference to `v`, we let that\n-variable (in this case, `x`) 'borrow' it for a while. Just like if you own a\n+In Rust, the type system encodes the notion of *ownership*. The variable `v`\n+is an *owner* of the vector. When we make a reference to `v`, we let that\n+variable (in this case, `x`) *borrow* it for a while. Just like if you own a\n book, and you lend it to me, I'm borrowing the book.\n \n So, when I try to modify the vector with the second call to `push`, I need\n@@ -392,22 +392,23 @@ Here's an example of a concurrent Rust program:\n use std::thread::Thread;\n \n fn main() {\n-    for _ in range(0u, 10u) {\n-        Thread::spawn(move || {\n+    let guards: Vec<_> = (0..10).map(|_| {\n+        Thread::scoped(|| {\n             println!(\"Hello, world!\");\n-        });\n-    }\n+        })\n+    }).collect();\n }\n ```\n \n-This program creates ten threads, who all print `Hello, world!`. The\n-`spawn` function takes one argument, a closure, indicated by the\n-double bars `||`. (The `move` keyword indicates that the closure takes\n-ownership of any data it uses; we'll have more on the significance of\n-this shortly.) This closure is executed in a new thread created by\n-`spawn`.\n+This program creates ten threads, which all print `Hello, world!`. The `scoped`\n+function takes one argument, a closure, indicated by the double bars `||`. This\n+closure is executed in a new thread created by `scoped`. The method is called\n+`scoped` because it returns a 'join guard', which will automatically join the\n+child thread when it goes out of scope. Because we `collect` these guards into\n+a `Vec<T>`, and that vector goes out of scope at the end of our program, our\n+program will wait for every thread to finish before finishing.\n \n-One common form of problem in concurrent programs is a 'data race.'\n+One common form of problem in concurrent programs is a *data race*.\n This occurs when two different threads attempt to access the same\n location in memory in a non-synchronized way, where at least one of\n them is a write. If one thread is attempting to read, and one thread\n@@ -460,9 +461,9 @@ code tries to make three owners. This may cause a safety problem, so\n Rust disallows it.\n \n What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n-\"Arc\" stands for \"atomically reference counted.\" In other words, an Arc will\n+*Arc* stands for \"atomically reference counted\". In other words, an Arc will\n keep track of the number of references to something, and not free the\n-associated resource until the count is zero. The 'atomic' portion refers to an\n+associated resource until the count is zero. The *atomic* portion refers to an\n Arc's usage of concurrency primitives to atomically update the count, making it\n safe across threads. If we use an Arc, we can have our three references. But,\n an Arc does not allow mutable borrows of the data it holds, and we want to\n@@ -525,13 +526,13 @@ give us assurance _at compile time_ that we weren't doing something incorrect\n with regards to concurrency. In order to share ownership, we were forced to be\n explicit and use a mechanism to ensure that it would be properly handled.\n \n-# Safety _and_ speed\n+# Safety _and_ Speed\n \n-Safety and speed are always presented as a continuum. On one hand, you have\n-maximum speed, but no safety. On the other, you have absolute safety, with no\n-speed. Rust seeks to break out of this mode by introducing safety at compile\n-time, ensuring that you haven't done anything wrong, while compiling to the\n-same low-level code you'd expect without the safety.\n+Safety and speed are always presented as a continuum. At one end of the spectrum,\n+you have maximum speed, but no safety. On the other end, you have absolute safety\n+with no speed. Rust seeks to break out of this paradigm by introducing safety at\n+compile time, ensuring that you haven't done anything wrong, while compiling to\n+the same low-level code you'd expect without the safety.\n \n As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:"}, {"sha": "c746c5773dd0907ce8fea7c97a69e47c66de178f", "filename": "src/doc/not_found.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fnot_found.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Fnot_found.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnot_found.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -12,17 +12,20 @@ Looks like you've taken a wrong turn.\n Some things that might be helpful to you though:\n \n ## Search\n+\n * <form action=\"https://duckduckgo.com/\">\n     <input type=\"text\" id=\"site-search\" name=\"q\" size=\"80\"></input>\n     <input type=\"submit\" value=\"Search DuckDuckGo\">\n </form>\n * Rust doc search: <span id=\"core-search\"></span>\n \n ## Reference\n+\n * [The Rust official site](http://rust-lang.org)\n-* [The Rust reference](http://doc.rust-lang.org/reference.html) (* [PDF](http://doc.rust-lang.org/reference.pdf))\n+* [The Rust reference](http://doc.rust-lang.org/reference.html)\n \n ## Docs\n+\n * [The standard library](http://doc.rust-lang.org/std/)\n \n <script>"}, {"sha": "c8e31f27b3507629e1824be826960ed9605ec041", "filename": "src/doc/reference.md", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1588,7 +1588,6 @@ pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n ```\n-# use std::boxed::Box;\n # trait Shape { }\n # impl Shape for int { }\n # let mycircle = 0i;\n@@ -1647,7 +1646,6 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n Likewise, supertrait methods may also be called on trait objects.\n \n ```{.ignore}\n-# use std::boxed::Box;\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n@@ -2432,15 +2430,15 @@ There are three different types of inline attributes:\n * `#[inline(always)]` asks the compiler to always perform an inline expansion.\n * `#[inline(never)]` asks the compiler to never perform an inline expansion.\n \n-### Deriving\n+### Derive\n \n-The `deriving` attribute allows certain traits to be automatically implemented\n+The `derive` attribute allows certain traits to be automatically implemented\n for data structures. For example, the following will create an `impl` for the\n `PartialEq` and `Clone` traits for `Foo`, the type parameter `T` will be given\n the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n \n ```\n-#[deriving(PartialEq, Clone)]\n+#[derive(PartialEq, Clone)]\n struct Foo<T> {\n     a: int,\n     b: T\n@@ -2462,7 +2460,7 @@ impl<T: PartialEq> PartialEq for Foo<T> {\n }\n ```\n \n-Supported traits for `deriving` are:\n+Supported traits for `derive` are:\n \n * Comparison traits: `PartialEq`, `Eq`, `PartialOrd`, `Ord`.\n * Serialization: `Encodable`, `Decodable`. These require `serialize`.\n@@ -2967,8 +2965,8 @@ _panicked state_.\n \n ### Unary operator expressions\n \n-Rust defines six symbolic unary operators. They are all written as prefix\n-operators, before the expression they apply to.\n+Rust defines three unary operators. They are all written as prefix operators,\n+before the expression they apply to.\n \n * `-`\n   : Negation. May only be applied to numeric types.\n@@ -2986,13 +2984,6 @@ operators, before the expression they apply to.\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n-* `box`\n-  : [Boxing](#pointer-types) operators. Allocate a box to hold the value they\n-    are applied to, and store the value in it. `box` creates a box.\n-* `&`\n-  : Borrow operator. Returns a reference, pointing to its operand. The operand\n-    of a borrow is statically proven to outlive the resulting pointer. If the\n-    borrow-checker cannot prove this, it is a compilation error.\n \n ### Binary operator expressions\n \n@@ -3799,7 +3790,6 @@ enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n An example of a *recursive* type and its use:\n \n ```\n-# use std::boxed::Box;\n enum List<T> {\n     Nil,\n     Cons(T, Box<List<T>>)\n@@ -3912,7 +3902,6 @@ implementation of `R`, and the pointer value of `E`.\n An example of an object type:\n \n ```\n-# use std::boxed::Box;\n trait Printable {\n   fn stringify(&self) -> String;\n }\n@@ -4120,7 +4109,6 @@ the type of a box is `std::owned::Box<T>`.\n An example of a box type and value:\n \n ```\n-# use std::boxed::Box;\n let x: Box<int> = Box::new(10);\n ```\n \n@@ -4130,7 +4118,6 @@ copy of a box to move ownership of the value. After a value has been moved,\n the source location cannot be used unless it is reinitialized.\n \n ```\n-# use std::boxed::Box;\n let x: Box<int> = Box::new(10);\n let y = x;\n // attempting to use `x` will result in an error here"}, {"sha": "3f59f12e74ca3cd5d28ba0d60eebf506800e2429", "filename": "src/doc/rust.css", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -195,6 +195,7 @@ h5 a:hover {text-decoration: none;}\n \n pre, code {\n     font-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", monospace;\n+    word-wrap: break-word;\n }\n pre {\n     border-left: 2px solid #eee;\n@@ -204,7 +205,6 @@ pre {\n     margin: 20px 0;\n     font-size: 13px;\n     word-break: break-all;\n-    word-wrap: break-word;\n }\n code {\n     padding: 0 2px;\n@@ -315,6 +315,8 @@ hr {\n table {\n     border-collapse: collapse;\n     border-spacing: 0;\n+    overflow-x: auto;\n+    display: block;\n }\n \n table tr.odd {"}, {"sha": "0b686eb76dbfb2d5dcf1eba88d965d1c2b069cc7", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -198,7 +198,7 @@ Rustdoc also supplies some extra sugar for helping with some tedious\n documentation examples. If a line is prefixed with `# `, then the line\n will not show up in the HTML documentation, but it will be used when\n testing the code block (NB. the space after the `#` is required, so\n-that one can still write things like `#[deriving(Eq)]`).\n+that one can still write things like `#[derive(Eq)]`).\n \n ~~~md\n ```\n@@ -217,6 +217,35 @@ spawn(move || { fib(200); })\n The documentation online would look like `spawn(move || { fib(200); })`, but when\n testing this code, the `fib` function will be included (so it can compile).\n \n+Rustdoc will automatically add a `main()` wrapper around your code, and in the right\n+place. For example:\n+\n+```\n+/// ```\n+/// use std::rc::Rc;\n+///\n+/// let five = Rc::new(5);\n+/// ```\n+# fn foo() {}\n+```\n+\n+This will end up testing:\n+\n+```\n+fn main() {\n+    use std::rc::Rc;\n+    let five = Rc::new(5);\n+}\n+```\n+\n+Here's the full algorithm:\n+\n+1. Given a code block, if it does not contain `fn main`, it is wrapped in `fn main() { your_code }`\n+2. Given that result, if it contains no `extern crate` directives but it also\n+   contains the name of the crate being tested, then `extern crate <name>` is\n+   injected at the top.\n+3. Some common `allow` attributes are added for documentation examples at the top.\n+\n ## Running tests (advanced)\n \n Running tests often requires some special configuration to filter tests, find"}, {"sha": "eb9e2b24ac900e0d7f1090cc7697c057111bec19", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -8,7 +8,7 @@ memory safe without using garbage collection.\n \"The Rust Programming Language\" is split into three sections, which you can\n navigate through the menu on the left.\n \n-## Basics\n+<h2 class=\"section-header\"><a href=\"basic.html\">Basics</a></h2>\n \n This section is a linear introduction to the basic syntax and semantics of\n Rust. It has individual sections on each part of Rust's syntax, and culminates\n@@ -17,15 +17,15 @@ in a small project: a guessing game.\n After reading \"Basics,\" you will have a good foundation to learn more about\n Rust, and can write very simple programs.\n \n-## Intermediate\n+<h2 class=\"section-header\"><a href=\"intermediate.html\">Intermediate</a></h2>\n \n This section contains individual chapters, which are self-contained. They focus\n on specific topics, and can be read in any order.\n \n After reading \"Intermediate,\" you will have a solid understanding of Rust,\n and will be able to understand most Rust code and write more complex programs.\n \n-## Advanced\n+<h2 class=\"section-header\"><a href=\"advanced.html\">Advanced</a></h2>\n \n In a similar fashion to \"Intermediate,\" this section is full of individual,\n deep-dive chapters, which stand alone and can be read in any order. These"}, {"sha": "aab03add905bb2f691b58f25cf40b147b7f67656", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -26,7 +26,7 @@\n     * [Iterators](iterators.md)\n     * [Generics](generics.md)\n     * [Traits](traits.md)\n-    * [Tasks](tasks.md)\n+    * [Threads](threads.md)\n     * [Error Handling](error-handling.md)\n * [III: Advanced Topics](advanced.md)\n     * [FFI](ffi.md)"}, {"sha": "e7ac55bfbd30d4ccb26792f059054f8a4f1d0a2f", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -82,7 +82,7 @@ arrays:\n \n ```{rust}\n let a = [0, 1, 2, 3, 4];\n-let middle = a.slice(1, 4);     // A slice of a: just the elements [1,2,3]\n+let middle = &a[1..4];     // A slice of a: just the elements 1, 2, and 3\n \n for e in middle.iter() {\n     println!(\"{}\", e);          // Prints 1, 2, 3"}, {"sha": "51a0bb69a7ce9291df9959dd084794917de0ec41", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -51,7 +51,7 @@ defined. The closure borrows any variables it uses, so this will error:\n \n ```{rust,ignore}\n fn main() {\n-    let mut x = 5;\n+    let mut x: i32 = 5;\n \n     let printer = |&:| { println!(\"x is: {}\", x); };\n "}, {"sha": "5ad9fcd41f554f0052a788801ca03f94be2a06df", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -182,7 +182,7 @@ and with a struct, we have actual names.\n \n There _is_ one case when a tuple struct is very useful, though, and that's a\n tuple struct with only one element. We call this a *newtype*, because it lets\n-you create a new type that's a synonym for another one:\n+you create a new type that's similar to another one:\n \n ```{rust}\n struct Inches(i32);\n@@ -194,7 +194,8 @@ println!(\"length is {} inches\", integer_length);\n ```\n \n As you can see here, you can extract the inner integer type through a\n-destructuring `let`.\n+destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n+`let Inches(integer_length)` assigns `10` to `integer_length`.\n \n ## Enums\n "}, {"sha": "4b1c92239aed348f633b8837f571b4a6da5565a1", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -181,7 +181,7 @@ errors that can occur.\n # Non-recoverable errors with `panic!`\n \n In the case of an error that is unexpected and not recoverable, the `panic!`\n-macro will induce a panic. This will crash the current task, and give an error:\n+macro will induce a panic. This will crash the current thread, and give an error:\n \n ```{rust,ignore}\n panic!(\"boom\");\n@@ -190,7 +190,7 @@ panic!(\"boom\");\n gives\n \n ```text\n-task '<main>' panicked at 'boom', hello.rs:2\n+thread '<main>' panicked at 'boom', hello.rs:2\n ```\n \n when you run it."}, {"sha": "940d2c968be677e33d6754e2fd4d0f7e21ed3414", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -166,12 +166,12 @@ GitHub](https://github.com/thestinger/rust-snappy).\n \n # Stack management\n \n-Rust tasks by default run on a *large stack*. This is actually implemented as a\n+Rust threads by default run on a *large stack*. This is actually implemented as a\n reserving a large segment of the address space and then lazily mapping in pages\n as they are needed. When calling an external C function, the code is invoked on\n the same stack as the rust stack. This means that there is no extra\n stack-switching mechanism in place because it is assumed that the large stack\n-for the rust task is plenty for the C function to have.\n+for the rust thread is plenty for the C function to have.\n \n A planned future improvement (not yet implemented at the time of this writing)\n is to have a guard page at the end of every rust stack. No rust function will\n@@ -184,8 +184,8 @@ For normal external function usage, this all means that there shouldn't be any\n need for any extra effort on a user's perspective. The C stack naturally\n interleaves with the rust stack, and it's \"large enough\" for both to\n interoperate. If, however, it is determined that a larger stack is necessary,\n-there are appropriate functions in the task spawning API to control the size of\n-the stack of the task which is spawned.\n+there are appropriate functions in the thread spawning API to control the size of\n+the stack of the thread which is spawned.\n \n # Destructors\n \n@@ -262,8 +262,6 @@ referenced Rust object.\n Rust code:\n \n ~~~~no_run\n-# use std::boxed::Box;\n-\n #[repr(C)]\n struct RustObject {\n     a: i32,\n@@ -320,16 +318,15 @@ In the previously given examples the callbacks are invoked as a direct reaction\n to a function call to the external C library.\n The control over the current thread is switched from Rust to C to Rust for the\n execution of the callback, but in the end the callback is executed on the\n-same thread (and Rust task) that lead called the function which triggered\n-the callback.\n+same thread that called the function which triggered the callback.\n \n Things get more complicated when the external library spawns its own threads\n and invokes callbacks from there.\n In these cases access to Rust data structures inside the callbacks is\n especially unsafe and proper synchronization mechanisms must be used.\n Besides classical synchronization mechanisms like mutexes, one possibility in\n Rust is to use channels (in `std::comm`) to forward data from the C thread\n-that invoked the callback into a Rust task.\n+that invoked the callback into a Rust thread.\n \n If an asynchronous callback targets a special object in the Rust address space\n it is also absolutely necessary that no more callbacks are performed by the"}, {"sha": "eae7fc1989506d91291b2c47c73304b4399df60c", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -142,5 +142,23 @@ fn foo(x: i32) -> i32 {\n }\n ```\n \n+The previous definition without `return` may look a bit strange if you haven't\n+worked in an expression-based language before, but it becomes intutive over\n+time. If this were production code, we wouldn't write it in that way anyway,\n+we'd write this:\n+\n+```rust\n+fn foo(x: i32) -> i32 {\n+    if x < 5 {\n+        x\n+    } else {\n+        x + 1\n+    }\n+}\n+```\n+\n+Because `if` is an expression, and it's the only expression in this function,\n+the value will be the result of the `if`.\n+\n There are some additional ways to define functions, but they involve features\n that we haven't learned about yet, so let's just leave it at that for now."}, {"sha": "023143ae64e264b90b2df1977fa08a46a81c32bb", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -88,9 +88,9 @@ enum Result<H, N> {\n if we wanted to. Convention says that the first generic parameter should be\n `T`, for 'type,' and that we use `E` for 'error.' Rust doesn't care, however.\n \n-The `Result<T, E>` type is intended to\n-be used to return the result of a computation, and to have the ability to\n-return an error if it didn't work out. Here's an example:\n+The `Result<T, E>` type is intended to be used to return the result of a\n+computation, and to have the ability to return an error if it didn't work out.\n+Here's an example:\n \n ```{rust}\n let x: Result<f64, String> = Ok(2.3f64);"}, {"sha": "474e7db6942e1e260d817a7fce8d13dc083a1e63", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -239,7 +239,7 @@ use std::rand;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -283,7 +283,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -318,7 +318,7 @@ $ cargo build\n src/main.rs:20:15: 20:20 error: mismatched types: expected `i32` but found `collections::string::String` (expected i32 but found struct collections::string::String)\n src/main.rs:20     match cmp(input, secret_number) {\n                              ^~~~~\n-src/main.rs:20:22: 20:35 error: mismatched types: expected `i32` but found `uint` (expected i32 but found uint)\n+src/main.rs:20:22: 20:35 error: mismatched types: expected `i32` but found `u32` (expected i32 but found u32)\n src/main.rs:20     match cmp(input, secret_number) {\n                                     ^~~~~~~~~~~~~\n error: aborting due to 2 previous errors\n@@ -328,7 +328,7 @@ This often happens when writing Rust programs, and is one of Rust's greatest\n strengths. You try out some code, see if it compiles, and Rust tells you that\n you've done something wrong. In this case, our `cmp` function works on integers,\n but we've given it unsigned integers. In this case, the fix is easy, because\n-we wrote the `cmp` function! Let's change it to take `uint`s:\n+we wrote the `cmp` function! Let's change it to take `u32`s:\n \n ```{rust,ignore}\n use std::io;\n@@ -338,7 +338,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -358,7 +358,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -370,13 +370,13 @@ And try compiling again:\n ```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:20:15: 20:20 error: mismatched types: expected `uint` but found `collections::string::String` (expected uint but found struct collections::string::String)\n+src/main.rs:20:15: 20:20 error: mismatched types: expected `u32` but found `collections::string::String` (expected u32 but found struct collections::string::String)\n src/main.rs:20     match cmp(input, secret_number) {\n                              ^~~~~\n error: aborting due to previous error\n ```\n \n-This error is similar to the last one: we expected to get a `uint`, but we got\n+This error is similar to the last one: we expected to get a `u32`, but we got\n a `String` instead! That's because our `input` variable is coming from the\n standard input, and you can guess anything. Try it:\n \n@@ -393,37 +393,37 @@ Oops! Also, you'll note that we just ran our program even though it didn't compi\n This works because the older version we did successfully compile was still lying\n around. Gotta be careful!\n \n-Anyway, we have a `String`, but we need a `uint`. What to do? Well, there's\n+Anyway, we have a `String`, but we need a `u32`. What to do? Well, there's\n a function for that:\n \n ```{rust,ignore}\n let input = io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n-let input_num: Option<uint> = input.parse();\n+let input_num: Option<u32> = input.parse();\n ```\n \n The `parse` function takes in a `&str` value and converts it into something.\n We tell it what kind of something with a type hint. Remember our type hint with\n `random()`? It looked like this:\n \n ```{rust,ignore}\n-rand::random::<uint>();\n+rand::random::<u32>();\n ```\n \n There's an alternate way of providing a hint too, and that's declaring the type\n in a `let`:\n \n ```{rust,ignore}\n-let x: uint = rand::random();\n+let x: u32 = rand::random();\n ```\n \n-In this case, we say `x` is a `uint` explicitly, so Rust is able to properly\n+In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = \"5\".parse::<uint>();         // input_num: Option<uint>\n-let input_num: Option<uint> = \"5\".parse();   // input_num: Option<uint>\n+let input_num = \"5\".parse::<u32>();         // input_num: Option<u32>\n+let input_num: Option<u32> = \"5\".parse();   // input_num: Option<u32>\n ```\n \n Anyway, with us now converting our input to a number, our code looks like this:\n@@ -436,7 +436,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -445,7 +445,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = input.parse();\n+    let input_num: Option<u32> = input.parse();\n \n     println!(\"You guessed: {}\", input_num);\n \n@@ -456,7 +456,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -468,13 +468,13 @@ Let's try it out!\n ```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:22:15: 22:24 error: mismatched types: expected `uint` but found `core::option::Option<uint>` (expected uint but found enum core::option::Option)\n+src/main.rs:22:15: 22:24 error: mismatched types: expected `u32` but found `core::option::Option<u32>` (expected u32 but found enum core::option::Option)\n src/main.rs:22     match cmp(input_num, secret_number) {\n                              ^~~~~~~~~\n error: aborting due to previous error\n ```\n \n-Oh yeah! Our `input_num` has the type `Option<uint>`, rather than `uint`. We\n+Oh yeah! Our `input_num` has the type `Option<u32>`, rather than `u32`. We\n need to unwrap the Option. If you remember from before, `match` is a great way\n to do that. Try this code:\n \n@@ -486,7 +486,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -495,7 +495,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = input.parse();\n+    let input_num: Option<u32> = input.parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -515,14 +515,14 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n }\n ```\n \n-We use a `match` to either give us the `uint` inside of the `Option`, or else\n+We use a `match` to either give us the `u32` inside of the `Option`, or else\n print an error message and return. Let's give this a shot:\n \n ```bash\n@@ -553,7 +553,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -562,7 +562,7 @@ fn main() {\n     let input = io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n-    let input_num: Option<uint> = input.trim().parse();\n+    let input_num: Option<u32> = input.trim().parse();\n \n     let num = match input_num {\n         Some(num) => num,\n@@ -582,7 +582,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -627,7 +627,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -638,7 +638,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -659,7 +659,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -703,7 +703,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -714,7 +714,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -738,7 +738,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -759,7 +759,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     println!(\"The secret number is: {}\", secret_number);\n \n@@ -770,7 +770,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -794,7 +794,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }\n@@ -838,7 +838,7 @@ use std::cmp::Ordering;\n fn main() {\n     println!(\"Guess the number!\");\n \n-    let secret_number = (rand::random::<uint>() % 100u) + 1u;\n+    let secret_number = (rand::random::<u32>() % 100) + 1;\n \n     loop {\n \n@@ -847,7 +847,7 @@ fn main() {\n         let input = io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n-        let input_num: Option<uint> = input.trim().parse();\n+        let input_num: Option<u32> = input.trim().parse();\n \n         let num = match input_num {\n             Some(num) => num,\n@@ -871,7 +871,7 @@ fn main() {\n     }\n }\n \n-fn cmp(a: uint, b: uint) -> Ordering {\n+fn cmp(a: u32, b: u32) -> Ordering {\n     if a < b { Ordering::Less }\n     else if a > b { Ordering::Greater }\n     else { Ordering::Equal }"}, {"sha": "640f0109b0697d841c0bed2d53a89d0014c612ca", "filename": "src/doc/trpl/hello-world.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fhello-world.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fhello-world.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-world.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -71,8 +71,8 @@ These lines define a *function* in Rust. The `main` function is special:\n it's the beginning of every Rust program. The first line says \"I'm declaring a\n function named `main`, which takes no arguments and returns nothing.\" If there\n were arguments, they would go inside the parentheses (`(` and `)`), and because\n-we aren't returning anything from this function, we've dropped that notation\n-entirely.  We'll get to it later.\n+we aren't returning anything from this function, we can omit the return type\n+entirely. We'll get to it later.\n \n You'll also note that the function is wrapped in curly braces (`{` and `}`).\n Rust requires these around all function bodies. It is also considered good"}, {"sha": "8f4db3eee5ae7d0d281bc5c20c2efc572030405a", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -42,7 +42,7 @@ the pattern in the above code:\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n-    ($inp:expr, $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n+    ($inp:expr, $sp:path) => ( // invoke it like `(input_5, SpecialE)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n@@ -59,7 +59,7 @@ early_return!(input_2, T::SpecialB);\n ~~~~\n \n Macros are defined in pattern-matching style: in the above example, the text\n-`($inp:expr $sp:ident)` that appears on the left-hand side of the `=>` is the\n+`($inp:expr, $sp:path)` that appears on the left-hand side of the `=>` is the\n *macro invocation syntax*, a pattern denoting how to write a call to the\n macro. The text on the right-hand side of the `=>`, beginning with `match\n $inp`, is the *macro transcription syntax*: what the macro expands to.\n@@ -74,6 +74,8 @@ conforms to the following rules:\n 2. `$` has special meaning (described below).\n 3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n forbidden.\n+4. Some arguments can be followed only by a limited set of separators, to\n+avoid ambiguity (described below).\n \n Otherwise, the invocation syntax is free-form.\n \n@@ -86,7 +88,8 @@ To take a fragment of Rust code as an argument, write `$` followed by a name\n   `foo`.)\n * `expr` (an expression. Examples: `2 + 2`; `if true then { 1 } else { 2 }`;\n   `f(42)`.)\n-* `ty` (a type. Examples: `int`, `Vec<(char, String)>`, `&T`.)\n+* `ty` (a type. Examples: `i32`, `Vec<(char, String)>`, `&T`.)\n+* `path` (a path to struct or enum variant. Example: `T::SpecialA`)\n * `pat` (a pattern, usually appearing in a `match` or on the left-hand side of\n   a declaration. Examples: `Some(t)`; `(17, 'a')`; `_`.)\n * `block` (a sequence of actions. Example: `{ log(error, \"hi\"); return 12; }`)\n@@ -97,6 +100,12 @@ rules of tokenization apply,\n So `($x:ident -> (($e:expr)))`, though excessively fancy, would designate a macro\n that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n+To avoid ambiguity, macro invocation syntax must conform to the following rules:\n+* `expr` must be followed by `=>`, `,` or `;`.\n+* `ty` and `path` must be followed by `=>`, `,`, `:`, `=`, `>` or `as`.\n+* `pat` must be followed by `=>`, `,` or `=`.\n+* `ident` and `block` can be followed by any token.\n+\n ## Invocation location\n \n A macro invocation may take the place of (and therefore expand to) an\n@@ -571,7 +580,7 @@ intermediate states out, and passing the flag `--pretty expanded` as a\n command-line argument to the compiler will show the result of expansion.\n \n If Rust's macro system can't do what you need, you may want to write a\n-[compiler plugin](plugin.html) instead. Compared to `macro_rules!`\n+[compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and the warnings about debugging apply ten-fold. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax"}, {"sha": "011746cf5b11799266927450c787111e970ad9c6", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -81,7 +81,6 @@ therefore deallocates the memory for you. Here's the equivalent example in\n Rust:\n \n ```rust\n-# use std::boxed::Box;\n {\n     let x = Box::new(5);\n }\n@@ -101,7 +100,6 @@ This is pretty straightforward, but what happens when we want to pass our box\n to a function? Let's look at some code:\n \n ```rust\n-# use std::boxed::Box;\n fn main() {\n     let x = Box::new(5);\n \n@@ -117,7 +115,6 @@ This code works, but it's not ideal. For example, let's add one more line of\n code, where we print out the value of `x`:\n \n ```{rust,ignore}\n-# use std::boxed::Box;\n fn main() {\n     let x = Box::new(5);\n \n@@ -151,7 +148,6 @@ To fix this, we can have `add_one` give ownership back when it's done with the\n box:\n \n ```rust\n-# use std::boxed::Box;\n fn main() {\n     let x = Box::new(5);\n \n@@ -207,6 +203,26 @@ fn add_one(num: &mut i32) {\n This function borrows an `i32` from its caller, and then increments it. When\n the function is over, and `num` goes out of scope, the borrow is over.\n \n+We have to change our `main` a bit too:\n+\n+```rust\n+fn main() {\n+    let mut x = 5;\n+\n+    add_one(&mut x);\n+\n+    println!(\"{}\", x);\n+}\n+\n+fn add_one(num: &mut i32) {\n+    *num += 1;\n+}\n+```\n+\n+We don't need to assign the result of `add_one()` anymore, because it doesn't\n+return anything anymore. This is because we're not passing ownership back,\n+since we just borrow, not take ownership.\n+\n # Lifetimes\n \n Lending out a reference to a resource that someone else owns can be\n@@ -225,7 +241,7 @@ To fix this, we have to make sure that step four never happens after step\n three. The ownership system in Rust does this through a concept called\n *lifetimes*, which describe the scope that a reference is valid for.\n \n-Let's look at that function which borrows an `i32` again:\n+Remember the function that borrowed an `i32`? Let's look at it again.\n \n ```rust\n fn add_one(num: &i32) -> i32 {"}, {"sha": "4cd39d407a243b184c80fa590cbf0dba2a84ef78", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -126,7 +126,7 @@ The advantages over a simple `fn(&str) -> uint` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`deriving`](../reference.html#deriving)-like attributes and other kinds of\n+[`derive`](../reference.html#derive)-like attributes and other kinds of\n extensions.  See\n [`Registry::register_syntax_extension`](../rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension)\n and the [`SyntaxExtension`"}, {"sha": "6832d75245e5cc9ebf51ba6434af0ce52cd94c79", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -455,7 +455,6 @@ fn rc_succ(x: Rc<int>) -> int { *x + 1 }\n Note that the caller of your function will have to modify their calls slightly:\n \n ```{rust}\n-# use std::boxed::Box;\n use std::rc::Rc;\n \n fn succ(x: &int) -> int { *x + 1 }\n@@ -478,15 +477,13 @@ those contents.\n heap allocation in Rust. Creating a box looks like this:\n \n ```{rust}\n-# use std::boxed::Box;\n let x = Box::new(5i);\n ```\n \n Boxes are heap allocated and they are deallocated automatically by Rust when\n they go out of scope:\n \n ```{rust}\n-# use std::boxed::Box;\n {\n     let x = Box::new(5i);\n \n@@ -507,7 +504,6 @@ You don't need to fully grok the theory of affine types or regions to grok\n boxes, though. As a rough approximation, you can treat this Rust code:\n \n ```{rust}\n-# use std::boxed::Box;\n {\n     let x = Box::new(5i);\n \n@@ -548,7 +544,6 @@ for more detail on how lifetimes work.\n Using boxes and references together is very common. For example:\n \n ```{rust}\n-# use std::boxed::Box;\n fn add_one(x: &int) -> int {\n     *x + 1\n }\n@@ -566,7 +561,6 @@ function, and since it's only reading the value, allows it.\n We can borrow `x` multiple times, as long as it's not simultaneous:\n \n ```{rust}\n-# use std::boxed::Box;\n fn add_one(x: &int) -> int {\n     *x + 1\n }\n@@ -583,7 +577,6 @@ fn main() {\n Or as long as it's not a mutable borrow. This will error:\n \n ```{rust,ignore}\n-# use std::boxed::Box;\n fn add_one(x: &mut int) -> int {\n     *x + 1\n }\n@@ -610,7 +603,6 @@ Sometimes, you need a recursive data structure. The simplest is known as a\n \n \n ```{rust}\n-# use std::boxed::Box;\n #[derive(Show)]\n enum List<T> {\n     Cons(T, Box<List<T>>),\n@@ -666,7 +658,6 @@ In many languages with pointers, you'd return a pointer from a function\n so as to avoid copying a large data structure. For example:\n \n ```{rust}\n-# use std::boxed::Box;\n struct BigStruct {\n     one: int,\n     two: int,\n@@ -695,7 +686,6 @@ than the hundred `int`s that make up the `BigStruct`.\n This is an antipattern in Rust. Instead, write this:\n \n ```{rust}\n-# use std::boxed::Box;\n struct BigStruct {\n     one: int,\n     two: int,\n@@ -721,11 +711,10 @@ fn main() {\n This gives you flexibility without sacrificing performance.\n \n You may think that this gives us terrible performance: return a value and then\n-immediately box it up ?! Isn't that the worst of both worlds? Rust is smarter\n-than that. There is no copy in this code. `main` allocates enough room for the\n-`box`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n-the value straight into that pointer. This writes the return value directly into\n-the allocated box.\n+immediately box it up ?! Isn't this pattern the worst of both worlds? Rust is\n+smarter than that. There is no copy in this code. `main` allocates enough room\n+for the `box`, passes a pointer to that memory into `foo` as `x`, and then\n+`foo` writes the value straight into the `Box<T>`.\n \n This is important enough that it bears repeating: pointers are not for\n optimizing returning values from your code. Allow the caller to choose how they"}, {"sha": "aefc7d7aa3d3ce09622e8ed9e40ac69adfa1126e", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -96,7 +96,7 @@ test it_works ... FAILED\n failures:\n \n ---- it_works stdout ----\n-        task 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n+        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3\n \n \n \n@@ -105,7 +105,7 @@ failures:\n \n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n \n-task '<main>' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n+thread '<main>' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247\n ```\n \n Rust indicates that our test failed:\n@@ -254,7 +254,6 @@ a large module, and so this is a common use of the `glob` feature. Let's change\n our `src/lib.rs` to make use of it:\n \n ```{rust,ignore}\n-#![feature(globs)]\n \n pub fn add_two(a: i32) -> i32 {\n     a + 2\n@@ -271,8 +270,7 @@ mod tests {\n }\n ```\n \n-Note the `feature` attribute, as well as the different `use` line. Now we run\n-our tests:\n+Note the different `use` line. Now we run our tests:\n \n ```bash\n $ cargo test\n@@ -370,8 +368,6 @@ with examples:\n //! assert_eq!(4, adder::add_two(2));\n //! ```\n \n-#![feature(globs)]\n-\n /// This function adds two to its argument.\n ///\n /// # Examples\n@@ -440,8 +436,6 @@ Rust also supports benchmark tests, which can test the performance of your\n code. Let's make our `src/lib.rs` look like this (comments elided):\n \n ```{rust,ignore}\n-#![feature(globs)]\n-\n extern crate test;\n \n pub fn add_two(a: i32) -> i32 {"}, {"sha": "4c6a7f1323fb1c492873404fbfca66675b57f117", "filename": "src/doc/trpl/threads.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "previous_filename": "src/doc/trpl/tasks.md"}, {"sha": "96322296407f366773c3f46944230b58c208a4cc", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -315,3 +315,76 @@ The names don't actually change to this, it's just for illustration. But\n as you can see, there's no overhead of deciding which version to call here,\n hence *statically dispatched*. The downside is that we have two copies of\n the same function, so our binary is a little bit larger.\n+\n+## Our `inverse` Example\n+\n+Back in [Generics](generics.html), we were trying to write code like this:\n+\n+```{rust,ignore}\n+fn inverse<T>(x: T) -> Result<T, String> {\n+    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0 / x)\n+}\n+```\n+\n+If we try to compile it, we get this error:\n+\n+```text\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+This is because `T` is too generic: we don't know if a random `T` can be\n+compared. For that, we can use trait bounds. It doesn't quite work, but try\n+this:\n+\n+```{rust,ignore}\n+fn inverse<T: PartialEq>(x: T) -> Result<T, String> {\n+    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n+\n+    Ok(1.0 / x)\n+}\n+```\n+\n+You should get this error:\n+\n+```text\n+error: mismatched types:\n+ expected `T`,\n+    found `_`\n+(expected type parameter,\n+    found floating-point variable)\n+```\n+\n+So this won't work. While our `T` is `PartialEq`, we expected to have another `T`,\n+but instead, we found a floating-point variable. We need a different bound. `Float`\n+to the rescue:\n+\n+```\n+use std::num::Float;\n+\n+fn inverse<T: Float>(x: T) -> Result<T, String> {\n+    if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n+\n+    let one: T = Float::one();\n+    Ok(one / x)\n+}\n+```\n+\n+We've had to replace our generic `0.0` and `1.0` with the appropriate methods\n+from the `Float` trait. Both `f32` and `f64` implement `Float`, so our function\n+works just fine:\n+\n+```\n+# use std::num::Float;\n+# fn inverse<T: Float>(x: T) -> Result<T, String> {\n+#     if x == Float::zero() { return Err(\"x cannot be zero!\".to_string()) }\n+#     let one: T = Float::one();\n+#     Ok(one / x)\n+# }\n+println!(\"the inverse of {} is {:?}\", 2.0f32, inverse(2.0f32));\n+println!(\"the inverse of {} is {:?}\", 2.0f64, inverse(2.0f64));\n+\n+println!(\"the inverse of {} is {:?}\", 0.0f32, inverse(0.0f32));\n+println!(\"the inverse of {} is {:?}\", 0.0f64, inverse(0.0f64));\n+```"}, {"sha": "075340660df154611e042fcdf34abe51df93251d", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -182,7 +182,7 @@ code:\n - implement the `Drop` for resource clean-up via a destructor, and use\n   RAII (Resource Acquisition Is Initialization). This reduces the need\n   for any manual memory management by users, and automatically ensures\n-  that clean-up is always run, even when the task panics.\n+  that clean-up is always run, even when the thread panics.\n - ensure that any data stored behind a raw pointer is destroyed at the\n   appropriate time.\n \n@@ -197,7 +197,6 @@ extern crate libc;\n use libc::{c_void, size_t, malloc, free};\n use std::mem;\n use std::ptr;\n-# use std::boxed::Box;\n \n // Define a wrapper around the handle returned by the foreign code.\n // Unique<T> has the same semantics as Box<T>\n@@ -499,7 +498,7 @@ library, but without it you must define your own.\n The first of these three functions, `stack_exhausted`, is invoked whenever stack\n overflow is detected.  This function has a number of restrictions about how it\n can be called and what it must do, but if the stack limit register is not being\n-maintained then a task always has an \"infinite stack\" and this function\n+maintained then a thread always has an \"infinite stack\" and this function\n shouldn't get triggered.\n \n The second of these three functions, `eh_personality`, is used by the\n@@ -530,7 +529,6 @@ vectors provided from C, using idiomatic Rust practices.\n \n ```\n #![no_std]\n-#![feature(globs)]\n #![feature(lang_items)]\n \n # extern crate libc;"}, {"sha": "e57fc7a120653aa29507b477b04eabefd34c895b", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -89,25 +89,7 @@ what you need, so it's not verboten.\n \n Let's get back to bindings. Rust variable bindings have one more aspect that\n differs from other languages: bindings are required to be initialized with a\n-value before you're allowed to use them. If we try...\n-\n-```{ignore}\n-let x;\n-```\n-\n-...we'll get an error:\n-\n-```text\n-src/main.rs:2:9: 2:10 error: unable to infer enough type information about `_`; type annotations required\n-src/main.rs:2     let x;\n-                      ^\n-```\n-\n-Giving it a type will compile, though:\n-\n-```{rust}\n-let x: i32;\n-```\n+value before you're allowed to use them.\n \n Let's try it out. Change your `src/main.rs` file to look like this:\n "}, {"sha": "87f3a0c765c5ef4fbef558902e5e8c60c2aacdeb", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1,3 +1,3 @@\n % The Rust Tutorial\n \n-This tutorial has been deprecated in favor of [the Guide](guide.html). Go check that out instead!\n+This tutorial has been deprecated in favor of [the Book](book/index.html). Go check that out instead!"}, {"sha": "7d071d5e724b4635c2a9640bcb4685b05f4701e3", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -194,8 +194,13 @@ LIT_STR_RAW\n   : 'r' LIT_STR_RAW_INNER SUFFIX?\n   ;\n \n+\n+QUESTION : '?';\n+\n IDENT : XID_start XID_continue* ;\n \n+fragment QUESTION_IDENTIFIER : QUESTION? IDENT;\n+\n LIFETIME : '\\'' IDENT ;\n \n WHITESPACE : [ \\r\\n\\t]+ ;"}, {"sha": "e9409a6106131ec3870e91776f27cce605e92e33", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(globs, plugin)]\n+#![feature(plugin)]\n \n extern crate syntax;\n extern crate rustc;\n@@ -107,13 +107,14 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"LE\"                => token::Le,\n             \"LIT_BINARY\"        => token::Literal(token::Binary(Name(0)), None),\n             \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0), None),\n+            \"QUESTION\"          => token::Question,\n             _                   => continue,\n         };\n \n         res.insert(num.to_string(), tok);\n     }\n \n-    debug!(\"Token map: {}\", res);\n+    debug!(\"Token map: {:?}\", res);\n     res\n }\n \n@@ -161,7 +162,7 @@ fn fixchar(mut lit: &str) -> ast::Name {\n     parse::token::intern(lit.slice(1, lit.len() - 1))\n }\n \n-fn count(lit: &str) -> uint {\n+fn count(lit: &str) -> usize {\n     lit.chars().take_while(|c| *c == '#').count()\n }\n \n@@ -176,12 +177,12 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>) -> TokenAn\n     let toknum = m.name(\"toknum\").unwrap_or(\"\");\n     let content = m.name(\"content\").unwrap_or(\"\");\n \n-    let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {} in the map\",\n+    let proto_tok = tokens.get(toknum).expect(format!(\"didn't find token {:?} in the map\",\n                                                               toknum).as_slice());\n \n     let nm = parse::token::intern(content);\n \n-    debug!(\"What we got: content (`{}`), proto: {}\", content, proto_tok);\n+    debug!(\"What we got: content (`{}`), proto: {:?}\", content, proto_tok);\n \n     let real_tok = match *proto_tok {\n         token::BinOp(..)           => token::BinOp(str_to_binop(content)),\n@@ -265,7 +266,7 @@ fn main() {\n             continue\n         }\n \n-        assert!(rustc_tok.sp == antlr_tok.sp, \"{} and {} have different spans\", rustc_tok,\n+        assert!(rustc_tok.sp == antlr_tok.sp, \"{:?} and {:?} have different spans\", rustc_tok,\n                 antlr_tok);\n \n         macro_rules! matches {\n@@ -276,12 +277,12 @@ fn main() {\n                             if !tok_cmp(&rustc_tok.tok, &antlr_tok.tok) {\n                                 // FIXME #15677: needs more robust escaping in\n                                 // antlr\n-                                warn!(\"Different names for {} and {}\", rustc_tok, antlr_tok);\n+                                warn!(\"Different names for {:?} and {:?}\", rustc_tok, antlr_tok);\n                             }\n                         }\n-                        _ => panic!(\"{} is not {}\", antlr_tok, rustc_tok)\n+                        _ => panic!(\"{:?} is not {:?}\", antlr_tok, rustc_tok)\n                     },)*\n-                    ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n+                    ref c => assert!(c == &antlr_tok.tok, \"{:?} is not {:?}\", rustc_tok, antlr_tok)\n                 }\n             )\n         }"}, {"sha": "82e5af67ae31649e8cc0b0693a870c5c5671b3ee", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -2526,7 +2526,7 @@ mod bitv_bench {\n             for _ in range(0u, 100) {\n                 bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n             }\n-            black_box(&bitv)\n+            black_box(&bitv);\n         });\n     }\n \n@@ -2538,7 +2538,7 @@ mod bitv_bench {\n             for _ in range(0u, 100) {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n             }\n-            black_box(&bitv)\n+            black_box(&bitv);\n         });\n     }\n "}, {"sha": "6c3767b011158403bed037a173487c8a129a97b7", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1422,7 +1422,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    use std::borrow::BorrowFrom;\n \n     use super::{BTreeMap, Occupied, Vacant};\n "}, {"sha": "6e048e0e83cb58946cd4e133e1183a3b177ac5d4", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -18,6 +18,8 @@ use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n use core::fmt::Show;\n use core::fmt;\n+// NOTE(stage0) remove import after a snapshot\n+#[cfg(stage0)]\n use core::hash::Hash;\n use core::iter::{Peekable, Map, FromIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};"}, {"sha": "cce8cf398e12e06bc9827936b26b93cd6298b634", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 166, "deletions": 6, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -230,7 +230,7 @@ impl<T> DList<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::DList;\n     ///\n     /// let mut a = DList::new();\n@@ -304,6 +304,18 @@ impl<T> DList<T> {\n     /// Returns `true` if the `DList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    /// assert!(dl.is_empty());\n+    ///\n+    /// dl.push_front(\"foo\");\n+    /// assert!(!dl.is_empty());\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_empty(&self) -> bool {\n@@ -313,6 +325,24 @@ impl<T> DList<T> {\n     /// Returns the length of the `DList`.\n     ///\n     /// This operation should compute in O(1) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    ///\n+    /// dl.push_front(2is);\n+    /// assert_eq!(dl.len(), 1);\n+    ///\n+    /// dl.push_front(1);\n+    /// assert_eq!(dl.len(), 2);\n+    ///\n+    /// dl.push_back(3);\n+    /// assert_eq!(dl.len(), 3);\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn len(&self) -> uint {\n@@ -322,6 +352,24 @@ impl<T> DList<T> {\n     /// Removes all elements from the `DList`.\n     ///\n     /// This operation should compute in O(n) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    ///\n+    /// dl.push_front(2is);\n+    /// dl.push_front(1);\n+    /// assert_eq!(dl.len(), 2);\n+    /// assert_eq!(dl.front(), Some(&1is));\n+    ///\n+    /// dl.clear();\n+    /// assert_eq!(dl.len(), 0);\n+    /// assert_eq!(dl.front(), None);\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn clear(&mut self) {\n@@ -330,6 +378,19 @@ impl<T> DList<T> {\n \n     /// Provides a reference to the front element, or `None` if the list is\n     /// empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    /// assert_eq!(dl.front(), None);\n+    ///\n+    /// dl.push_front(1);\n+    /// assert_eq!(dl.front(), Some(&1is));\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn front(&self) -> Option<&T> {\n@@ -338,6 +399,25 @@ impl<T> DList<T> {\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n     /// is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    /// assert_eq!(dl.front(), None);\n+    ///\n+    /// dl.push_front(1);\n+    /// assert_eq!(dl.front(), Some(&1is));\n+    ///\n+    /// match dl.front_mut() {\n+    ///     None => {},\n+    ///     Some(x) => *x = 5is,\n+    /// }\n+    /// assert_eq!(dl.front(), Some(&5is));\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n@@ -346,6 +426,19 @@ impl<T> DList<T> {\n \n     /// Provides a reference to the back element, or `None` if the list is\n     /// empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    /// assert_eq!(dl.back(), None);\n+    ///\n+    /// dl.push_back(1);\n+    /// assert_eq!(dl.back(), Some(&1is));\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn back(&self) -> Option<&T> {\n@@ -354,6 +447,25 @@ impl<T> DList<T> {\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n     /// is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    /// assert_eq!(dl.back(), None);\n+    ///\n+    /// dl.push_back(1);\n+    /// assert_eq!(dl.back(), Some(&1is));\n+    ///\n+    /// match dl.back_mut() {\n+    ///     None => {},\n+    ///     Some(x) => *x = 5is,\n+    /// }\n+    /// assert_eq!(dl.back(), Some(&5is));\n+    ///\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n@@ -363,6 +475,21 @@ impl<T> DList<T> {\n     /// Adds an element first in the list.\n     ///\n     /// This operation should compute in O(1) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut dl = DList::new();\n+    ///\n+    /// dl.push_front(2is);\n+    /// assert_eq!(dl.front().unwrap(), &2is);\n+    ///\n+    /// dl.push_front(1);\n+    /// assert_eq!(dl.front().unwrap(), &1);\n+    ///\n+    /// ```\n     #[stable]\n     pub fn push_front(&mut self, elt: T) {\n         self.push_front_node(box Node::new(elt))\n@@ -372,6 +499,23 @@ impl<T> DList<T> {\n     /// empty.\n     ///\n     /// This operation should compute in O(1) time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut d = DList::new();\n+    /// assert_eq!(d.pop_front(), None);\n+    ///\n+    /// d.push_front(1is);\n+    /// d.push_front(3);\n+    /// assert_eq!(d.pop_front(), Some(3));\n+    /// assert_eq!(d.pop_front(), Some(1));\n+    /// assert_eq!(d.pop_front(), None);\n+    ///\n+    /// ```\n+    ///\n     #[stable]\n     pub fn pop_front(&mut self) -> Option<T> {\n         self.pop_front_node().map(|box Node{value, ..}| value)\n@@ -381,7 +525,7 @@ impl<T> DList<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n@@ -399,7 +543,7 @@ impl<T> DList<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::DList;\n     ///\n     /// let mut d = DList::new();\n@@ -417,6 +561,22 @@ impl<T> DList<T> {\n     /// including the index.\n     ///\n     /// This operation should compute in O(n) time.\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::DList;\n+    ///\n+    /// let mut d = DList::new();\n+    ///\n+    /// d.push_front(1is);\n+    /// d.push_front(2);\n+    /// d.push_front(3);\n+    ///\n+    /// let mut splitted = d.split_off(2);\n+    ///\n+    /// assert_eq!(splitted.pop_front(), Some(1));\n+    /// assert_eq!(splitted.pop_front(), None);\n+    /// ```\n     #[stable]\n     pub fn split_off(&mut self, at: uint) -> DList<T> {\n         let len = self.len();\n@@ -593,7 +753,7 @@ impl<'a, A> IterMut<'a, A> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::DList;\n     ///\n     /// let mut list: DList<int> = vec![1, 3, 4].into_iter().collect();\n@@ -619,7 +779,7 @@ impl<'a, A> IterMut<'a, A> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::collections::DList;\n     ///\n     /// let mut list: DList<int> = vec![1, 2, 3].into_iter().collect();"}, {"sha": "f7668930660b0203481894aaeb05ff408d0e8210", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -2841,7 +2841,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n         b.iter(|| {\n-            for ch in s.chars() { black_box(ch) }\n+            for ch in s.chars() { black_box(ch); }\n         });\n     }\n \n@@ -2869,7 +2869,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n         b.iter(|| {\n-            for ch in s.chars().rev() { black_box(ch) }\n+            for ch in s.chars().rev() { black_box(ch); }\n         });\n     }\n "}, {"sha": "73afefc5a03317c5281a52c8a25a9861f700d031", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A growable list type, written `Vec<T>` but pronounced 'vector.'\n+//! A growable list type with heap-allocated contents, written `Vec<T>` but pronounced 'vector.'\n //!\n //! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n //!\n@@ -1511,6 +1511,9 @@ pub struct IntoIter<T> {\n     end: *const T\n }\n \n+unsafe impl<T: Send> Send for IntoIter<T> { }\n+unsafe impl<T: Sync> Sync for IntoIter<T> { }\n+\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector."}, {"sha": "978e8a19737b4a6164f78aeab68dcf55ae824c45", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -198,6 +198,10 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n+    #[cfg(not(stage0))]\n+    pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n+\n+    #[cfg(stage0)]\n     pub fn get_tydesc<T>() -> *const TyDesc;\n \n     /// Gets an identifier which is globally unique to the specified type. This"}, {"sha": "af7fc875389c07d4fdb416e6b77cfe7e0bee9ce3", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -66,7 +66,6 @@\n //! not (`None`).\n //!\n //! ```\n-//! # use std::boxed::Box;\n //! let optional: Option<Box<int>> = None;\n //! check_optional(&optional);\n //!"}, {"sha": "baf998d0828a27c7f7818c0aca169ee91794ee0f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -46,7 +46,6 @@\n //! though unsafely, transformed from one type to the other.\n //!\n //! ```\n-//! # use std::boxed::Box;\n //! use std::mem;\n //!\n //! unsafe {"}, {"sha": "110bce5c12472a1702113e7fc8d5cd5601c325b8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -119,7 +119,7 @@\n //! drop(file);\n //! ```\n //!\n-//! If you *do* write that in Rust, the compiler will by give you a\n+//! If you *do* write that in Rust, the compiler will give you a\n //! warning (by default, controlled by the `unused_must_use` lint).\n //!\n //! You might instead, if you don't want to handle the error, simply\n@@ -178,13 +178,11 @@\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n //!     // Early return on error\n-//!     match file.write_line(format!(\"name: {}\", info.name).as_slice()) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n+//!     if let Err(e) = file.write_line(format!(\"name: {}\", info.name).as_slice()) {\n+//!         return Err(e)\n //!     }\n-//!     match file.write_line(format!(\"age: {}\", info.age).as_slice()) {\n-//!         Ok(_) => (),\n-//!         Err(e) => return Err(e)\n+//!     if let Err(e) = file.write_line(format!(\"age: {}\", info.age).as_slice()) {\n+//!         return Err(e)\n //!     }\n //!     return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n //! }"}, {"sha": "5baeae236b33ef573d6e37f793db6348ff7d5ab7", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -35,9 +35,6 @@\n \n #![stable]\n \n-#[unstable = \"this is just a documentation module and should not be part \\\n-              of the public api\"]\n-\n use clone::Clone;\n use cmp::*;\n use cmp::Ordering::*;"}, {"sha": "3d8348e8f5a991ddc28ebf53b1ffabae028e59e0", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -28,6 +28,8 @@ pub struct LabelledCFG<'a, 'ast: 'a> {\n     pub ast_map: &'a ast_map::Map<'ast>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n+    /// `labelled_edges` controls whether we emit labels on the edges\n+    pub labelled_edges: bool,\n }\n \n fn replace_newline_with_backslash_l(s: String) -> String {\n@@ -75,6 +77,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n \n     fn edge_label(&self, e: &Edge<'a>) -> dot::LabelText<'a> {\n         let mut label = String::new();\n+        if !self.labelled_edges {\n+            return dot::LabelText::EscStr(label.into_cow());\n+        }\n         let mut put_one = false;\n         for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {"}, {"sha": "017641bd3b71aeb6cbf4f6fbe75412c9fc2c6e4d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -12,7 +12,7 @@\n //\n // There are various parts of the compiler that must impose arbitrary limits\n // on how deeply they recurse to prevent stack overflow. Users can override\n-// this via an attribute on the crate like `#![recursion_limit(22)]`. This pass\n+// this via an attribute on the crate like `#![recursion_limit=\"22\"]`. This pass\n // just peeks and looks for that attribute.\n \n use session::Session;\n@@ -34,6 +34,6 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n-                                  expected #![recursion_limit(\\\"N\\\")]\");\n+                                  expected #![recursion_limit=\\\"N\\\"]\");\n     }\n }"}, {"sha": "8dcbc74f0eb6e6583cebaca4af0f6b53425924cf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -22,6 +22,8 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n+// NOTE(stage0) remove import after a snapshot\n+#[cfg(stage0)]\n use std::hash::{Hash};\n use syntax::codemap::Span;\n use syntax::{ast, visit};"}, {"sha": "11b605e2e2fec57d354cb654926eab62af4f1047", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -2605,12 +2605,17 @@ impl FlagComputation {\n \n             &ty_projection(ref data) => {\n                 self.add_flags(HAS_PROJECTION);\n-                self.add_substs(data.trait_ref.substs);\n+                self.add_projection_ty(data);\n             }\n \n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);\n+                for projection_bound in bounds.projection_bounds.iter() {\n+                    let mut proj_computation = FlagComputation::new();\n+                    proj_computation.add_projection_predicate(&projection_bound.0);\n+                    computation.add_bound_computation(&proj_computation);\n+                }\n                 self.add_bound_computation(&computation);\n \n                 self.add_bounds(bounds);\n@@ -2674,6 +2679,15 @@ impl FlagComputation {\n         }\n     }\n \n+    fn add_projection_predicate(&mut self, projection_predicate: &ProjectionPredicate) {\n+        self.add_projection_ty(&projection_predicate.projection_ty);\n+        self.add_ty(projection_predicate.ty);\n+    }\n+\n+    fn add_projection_ty(&mut self, projection_ty: &ProjectionTy) {\n+        self.add_substs(projection_ty.trait_ref.substs);\n+    }\n+\n     fn add_substs(&mut self, substs: &Substs) {\n         self.add_tys(substs.types.as_slice());\n         match substs.regions {\n@@ -4133,12 +4147,8 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n     }\n }\n \n-pub fn try_node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Option<Ty<'tcx>> {\n-    cx.node_types.borrow().get(&id).cloned()\n-}\n-\n pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n-    match try_node_id_to_type(cx, id) {\n+    match node_id_to_type_opt(cx, id) {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            &format!(\"node_id_to_type: no type for node `{}`\","}, {"sha": "fb44d0cadfa6c8f50ba5965078236e948fc5b331", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1430,7 +1430,7 @@ impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"<{} as {}>::{}\",\n-                self.trait_ref.self_ty().repr(tcx),\n+                self.trait_ref.substs.self_ty().repr(tcx),\n                 self.trait_ref.repr(tcx),\n                 self.item_name.repr(tcx))\n     }"}, {"sha": "be620c72178bbd0a4ee27403ebb578639a4ca39a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -103,6 +103,13 @@ pub fn compile_input(sess: Session,\n \n         write_out_deps(&sess, input, &outputs, &id[]);\n \n+        controller_entry_point!(after_write_deps,\n+                                CompileState::state_after_write_deps(input,\n+                                                                     &sess,\n+                                                                     outdir,\n+                                                                     &ast_map,\n+                                                                     &id[]));\n+\n         let arenas = ty::CtxtArenas::new();\n         let analysis = phase_3_run_analysis_passes(sess,\n                                                    ast_map,\n@@ -176,6 +183,7 @@ pub fn source_name(input: &Input) -> String {\n pub struct CompileController<'a> {\n     pub after_parse: PhaseController<'a>,\n     pub after_expand: PhaseController<'a>,\n+    pub after_write_deps: PhaseController<'a>,\n     pub after_analysis: PhaseController<'a>,\n     pub after_llvm: PhaseController<'a>,\n \n@@ -187,6 +195,7 @@ impl<'a> CompileController<'a> {\n         CompileController {\n             after_parse: PhaseController::basic(),\n             after_expand: PhaseController::basic(),\n+            after_write_deps:  PhaseController::basic(),\n             after_analysis: PhaseController::basic(),\n             after_llvm: PhaseController::basic(),\n             make_glob_map: resolve::MakeGlobMap::No,\n@@ -271,6 +280,19 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n         }\n     }\n \n+    fn state_after_write_deps(input: &'a Input,\n+                              session: &'a Session,\n+                              out_dir: &'a Option<Path>,\n+                              ast_map: &'a ast_map::Map<'ast>,\n+                              crate_name: &'a str)\n+                              -> CompileState<'a, 'ast, 'tcx> {\n+        CompileState {\n+            crate_name: Some(crate_name),\n+            ast_map: Some(ast_map),\n+            .. CompileState::empty(input, session, out_dir)\n+        }\n+    }\n+\n     fn state_after_analysis(input: &'a Input,\n                             session: &'a Session,\n                             out_dir: &'a Option<Path>,"}, {"sha": "40a3eb9fe5b1d646314c76016e60e427b34b6758", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -207,7 +207,7 @@ fn build_controller<'a>(sess: &Session) -> CompileController<'a> {\n     }\n \n     if sess.opts.no_analysis || sess.opts.debugging_opts.ast_json {\n-        control.after_expand.stop = true;\n+        control.after_write_deps.stop = true;\n     }\n \n     if sess.opts.no_trans {"}, {"sha": "279442891bec0c631a91364d3cefd11c21baf831", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -53,10 +53,20 @@ pub enum PpSourceMode {\n     PpmExpandedHygiene,\n }\n \n+\n+#[derive(Copy, PartialEq, Show)]\n+pub enum PpFlowGraphMode {\n+    Default,\n+    /// Drops the labels from the edges in the flowgraph output. This\n+    /// is mostly for use in the --xpretty flowgraph run-make tests,\n+    /// since the labels are largely uninteresting in those cases and\n+    /// have become a pain to maintain.\n+    UnlabelledEdges,\n+}\n #[derive(Copy, PartialEq, Show)]\n pub enum PpMode {\n     PpmSource(PpSourceMode),\n-    PpmFlowGraph,\n+    PpmFlowGraph(PpFlowGraphMode),\n }\n \n pub fn parse_pretty(sess: &Session,\n@@ -73,12 +83,13 @@ pub fn parse_pretty(sess: &Session,\n         (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n         (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n         (\"identified\", _)   => PpmSource(PpmIdentified),\n-        (\"flowgraph\", true)    => PpmFlowGraph,\n+        (\"flowgraph\", true)    => PpmFlowGraph(PpFlowGraphMode::Default),\n+        (\"flowgraph,unlabelled\", true)    => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),\n         _ => {\n             if extended {\n                 sess.fatal(format!(\n                     \"argument to `xpretty` must be one of `normal`, \\\n-                     `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n+                     `expanded`, `flowgraph[,unlabelled]=<nodeid>`, `typed`, `identified`, \\\n                      `expanded,identified`, or `everybody_loops`; got {}\", name).as_slice());\n             } else {\n                 sess.fatal(format!(\n@@ -417,7 +428,7 @@ fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n         PpmSource(PpmExpandedIdentified) |\n         PpmSource(PpmExpandedHygiene) |\n         PpmSource(PpmTyped) |\n-        PpmFlowGraph => true\n+        PpmFlowGraph(_) => true\n     }\n }\n \n@@ -431,7 +442,7 @@ fn needs_expansion(ppm: &PpMode) -> bool {\n         PpmSource(PpmExpandedIdentified) |\n         PpmSource(PpmExpandedHygiene) |\n         PpmSource(PpmTyped) |\n-        PpmFlowGraph => true\n+        PpmFlowGraph(_) => true\n     }\n }\n \n@@ -589,7 +600,7 @@ pub fn pretty_print_input(sess: Session,\n                     pp::eof(&mut pp_state.s)\n                 }),\n \n-        (PpmFlowGraph, opt_uii) => {\n+        (PpmFlowGraph(mode), opt_uii) => {\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n@@ -613,7 +624,7 @@ pub fn pretty_print_input(sess: Session,\n                                                                        &arenas,\n                                                                        id,\n                                                                        resolve::MakeGlobMap::No);\n-                    print_flowgraph(variants, analysis, code, out)\n+                    print_flowgraph(variants, analysis, code, mode, out)\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\\n@@ -635,20 +646,23 @@ pub fn pretty_print_input(sess: Session,\n fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n                                  analysis: ty::CrateAnalysis,\n                                  code: blocks::Code,\n+                                 mode: PpFlowGraphMode,\n                                  mut out: W) -> io::IoResult<()> {\n     let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n     };\n+    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n+    let lcfg = LabelledCFG {\n+        ast_map: &ty_cx.map,\n+        cfg: &cfg,\n+        name: format!(\"node_{}\", code.id()),\n+        labelled_edges: labelled_edges,\n+    };\n \n     match code {\n         _ if variants.len() == 0 => {\n-            let lcfg = LabelledCFG {\n-                ast_map: &ty_cx.map,\n-                cfg: &cfg,\n-                name: format!(\"node_{}\", code.id()),\n-            };\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }\n@@ -662,11 +676,6 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n             let (bccx, analysis_data) =\n                 borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n \n-            let lcfg = LabelledCFG {\n-                ast_map: &ty_cx.map,\n-                cfg: &cfg,\n-                name: format!(\"node_{}\", code.id()),\n-            };\n             let lcfg = borrowck_dot::DataflowLabeller {\n                 inner: lcfg,\n                 variants: variants,"}, {"sha": "c0b1492a7845099c2d22a2a13f5738c269b11d2c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -167,7 +167,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n         llvm::LLVMRustAddPass(pm, \"verify\\0\".as_ptr() as *const _);\n \n+        let opt = sess.opts.cg.opt_level.unwrap_or(0) as libc::c_uint;\n+\n         let builder = llvm::LLVMPassManagerBuilderCreate();\n+        llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt);\n         llvm::LLVMPassManagerBuilderPopulateLTOPassManager(builder, pm,\n             /* Internalize = */ False,\n             /* RunInliner = */ True);"}, {"sha": "be927503badd1d74d78ddb2a555f8f31569721ae", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -201,7 +201,7 @@ use middle::pat_util::*;\n use trans::adt;\n use trans::base::*;\n use trans::build::{AddCase, And, BitCast, Br, CondBr, GEPi, InBoundsGEP, Load};\n-use trans::build::{Mul, Not, Store, Sub, add_comment};\n+use trans::build::{Not, Store, Sub, add_comment};\n use trans::build;\n use trans::callee;\n use trans::cleanup::{self, CleanupMethods};\n@@ -630,8 +630,7 @@ fn bind_subslice_pat(bcx: Block,\n     let vec_datum = match_datum(val, vec_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n-    let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), offset_left));\n-    let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n+    let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n     let slice_len = Sub(bcx, len, slice_len_offset);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n@@ -857,16 +856,9 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             bcx.fcx.schedule_lifetime_end(cs, binding_info.llmatch);\n         }\n \n-        debug!(\"binding {} to {}\",\n-               binding_info.id,\n-               bcx.val_to_string(llval));\n+        debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n-\n-        if bcx.sess().opts.debuginfo == FullDebugInfo {\n-            debuginfo::create_match_binding_metadata(bcx,\n-                                                     ident,\n-                                                     binding_info);\n-        }\n+        debuginfo::create_match_binding_metadata(bcx, ident, binding_info);\n     }\n     bcx\n }"}, {"sha": "3072bcae0bfb9a927d27059f6aa3d94ec9b6f249", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -44,7 +44,7 @@ use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, Ty, UnboxedClosureTyper};\n-use session::config::{self, NoDebugInfo, FullDebugInfo};\n+use session::config::{self, NoDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n@@ -544,15 +544,6 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-// Structural comparison: a rather involved form of glue.\n-pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n-    if cx.sess().opts.cg.save_temps {\n-        let buf = CString::from_slice(s.as_bytes());\n-        unsafe { llvm::LLVMSetValueName(v, buf.as_ptr()) }\n-    }\n-}\n-\n-\n // Used only for creating scalar comparison glue.\n #[derive(Copy)]\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n@@ -1626,9 +1617,8 @@ fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n     result\n }\n \n-fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n+fn copy_args_to_allocas<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     arg_scope: cleanup::CustomScopeIndex,\n-                                    bcx: Block<'blk, 'tcx>,\n                                     args: &[ast::Arg],\n                                     arg_datums: Vec<RvalueDatum<'tcx>>)\n                                     -> Block<'blk, 'tcx> {\n@@ -1649,10 +1639,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n         // the event it's not truly needed.\n \n         bcx = _match::store_arg(bcx, &*args[i].pat, arg_datum, arg_scope_id);\n-\n-        if fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n-            debuginfo::create_argument_metadata(bcx, &args[i]);\n-        }\n+        debuginfo::create_argument_metadata(bcx, &args[i]);\n     }\n \n     bcx\n@@ -1702,9 +1689,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                 tuple_element_datum,\n                                 arg_scope_id);\n \n-        if bcx.fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n-            debuginfo::create_argument_metadata(bcx, &args[j]);\n-        }\n+        debuginfo::create_argument_metadata(bcx, &args[j]);\n     }\n \n     bcx\n@@ -1877,9 +1862,8 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n-            copy_args_to_allocas(&fcx,\n+            copy_args_to_allocas(bcx,\n                                  arg_scope,\n-                                 bcx,\n                                  &decl.inputs[],\n                                  arg_datums)\n         }"}, {"sha": "3eee4637de1995322030c5224f7d65de8cf50946", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -217,12 +217,15 @@ pub fn type_needs_drop<'tcx>(cx: &ty::ctxt<'tcx>,\n     ty::type_contents(cx, ty).needs_drop(cx)\n }\n \n-fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   ty: Ty<'tcx>) -> bool {\n+fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::ty_struct(def_id, substs) => {\n-            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n-            fields.len() == 1 && type_is_immediate(ccx, fields[0].mt.ty)\n+            let fields = ty::lookup_struct_fields(ccx.tcx(), def_id);\n+            fields.len() == 1 && {\n+                let ty = ty::lookup_field_type(ccx.tcx(), def_id, fields[0].id, substs);\n+                let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n+                type_is_immediate(ccx, ty)\n+            }\n         }\n         _ => false\n     }"}, {"sha": "5dc939dc2025bca7d192bd396e7112d7b2568e8f", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -28,7 +28,6 @@ use trans::type_::Type;\n use trans;\n use middle::ty;\n use middle::ty::MethodCall;\n-use session::config::FullDebugInfo;\n use util::ppaux::Repr;\n use util::ppaux;\n \n@@ -66,10 +65,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, &**local);\n-                    if cx.sess().opts.debuginfo == FullDebugInfo {\n-                        trans::debuginfo::create_local_var_metadata(bcx,\n-                                                                    &**local);\n-                    }\n+                    debuginfo::create_local_var_metadata(bcx, &**local);\n                 }\n                 // Inner items are visited by `trans_item`/`trans_meth`.\n                 ast::DeclItem(_) => {},"}, {"sha": "a03a5090c050bc9f73b33618f523a8311c7c596e", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 37, "deletions": 63, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -323,28 +323,26 @@ impl<'tcx> TypeMap<'tcx> {\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n \n-        // basic type               -> {:name of the type:}\n-        // tuple                    -> {tuple_(:param-uid:)*}\n-        // struct                   -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                     -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant             -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)            -> {& :pointee-uid:}\n-        // mut reference (&mut)     -> {&mut :pointee-uid:}\n-        // ptr (*)                  -> {* :pointee-uid:}\n-        // mut ptr (*mut)           -> {*mut :pointee-uid:}\n-        // unique ptr (~)           -> {~ :pointee-uid:}\n-        // @-ptr (@)                -> {@ :pointee-uid:}\n-        // sized vec ([T; x])       -> {[:size:] :element-uid:}\n-        // unsized vec ([T])        -> {[] :element-uid:}\n-        // trait (T)                -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure                  -> {<unsafe_> <once_> :store-sigil:\n-        //                                  |(:param-uid:),* <,_...>| -> \\\n-        //                                  :return-type-uid: : (:bounds:)*}\n-        // function                 -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n-        //                                  :return-type-uid:}\n-        // unique vec box (~[])     -> {HEAP_VEC_BOX<:pointee-uid:>}\n-        // gc box                   -> {GC_BOX<:pointee-uid:>}\n-        // projection (<T as U>::V) -> {<:ty-uid: as :trait-uid:> :: :name-uid: }\n+        // basic type           -> {:name of the type:}\n+        // tuple                -> {tuple_(:param-uid:)*}\n+        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n+        // reference (&)        -> {& :pointee-uid:}\n+        // mut reference (&mut) -> {&mut :pointee-uid:}\n+        // ptr (*)              -> {* :pointee-uid:}\n+        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n+        // unique ptr (~)       -> {~ :pointee-uid:}\n+        // @-ptr (@)            -> {@ :pointee-uid:}\n+        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n+        // unsized vec ([T])    -> {[] :element-uid:}\n+        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n+        //                             :return-type-uid: : (:bounds:)*}\n+        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n+        //                             :return-type-uid:}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n@@ -437,25 +435,6 @@ impl<'tcx> TypeMap<'tcx> {\n                                        principal.substs,\n                                        &mut unique_type_id);\n             },\n-            ty::ty_projection(ref projection) => {\n-                unique_type_id.push_str(\"<\");\n-\n-                let self_ty = projection.trait_ref.self_ty();\n-                let self_type_id = self.get_unique_type_id_of_type(cx, self_ty);\n-                let self_type_id = self.get_unique_type_id_as_string(self_type_id);\n-                unique_type_id.push_str(&self_type_id[]);\n-\n-                unique_type_id.push_str(\" as \");\n-\n-                from_def_id_and_substs(self,\n-                                       cx,\n-                                       projection.trait_ref.def_id,\n-                                       projection.trait_ref.substs,\n-                                       &mut unique_type_id);\n-\n-                unique_type_id.push_str(\">::\");\n-                unique_type_id.push_str(token::get_name(projection.item_name).get());\n-            },\n             ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n                 if unsafety == ast::Unsafety::Unsafe {\n                     unique_type_id.push_str(\"unsafe \");\n@@ -499,10 +478,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n             },\n-            ty::ty_err |\n-            ty::ty_infer(_) |\n-            ty::ty_open(_) |\n-            ty::ty_param(_) => {\n+            _ => {\n                 cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n                                       &ppaux::ty_to_string(cx.tcx(), type_)[],\n                                       type_.sty)[])\n@@ -878,7 +854,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n /// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n-    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo  {\n         return;\n     }\n \n@@ -922,7 +900,9 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                 env_index: uint,\n                                                 captured_by_ref: bool,\n                                                 span: Span) {\n-    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n         return;\n     }\n \n@@ -1005,7 +985,9 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  variable_ident: ast::Ident,\n                                                  binding: BindingInfo<'tcx>) {\n-    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n         return;\n     }\n \n@@ -1045,7 +1027,9 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n-    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n         return;\n     }\n \n@@ -1099,7 +1083,9 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n /// loop variable in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if bcx.unreachable.get() || fn_should_be_ignored(bcx.fcx) {\n+    if bcx.unreachable.get() ||\n+       fn_should_be_ignored(bcx.fcx) ||\n+       bcx.sess().opts.debuginfo != FullDebugInfo {\n         return;\n     }\n \n@@ -3880,22 +3866,10 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_unboxed_closure(..) => {\n             output.push_str(\"closure\");\n         }\n-        ty::ty_projection(ref projection) => {\n-            output.push_str(\"<\");\n-            let self_ty = projection.trait_ref.self_ty();\n-            push_debuginfo_type_name(cx, self_ty, true, output);\n-\n-            output.push_str(\" as \");\n-\n-            push_item_name(cx, projection.trait_ref.def_id, false, output);\n-            push_type_params(cx, projection.trait_ref.substs, output);\n-\n-            output.push_str(\">::\");\n-            output.push_str(token::get_name(projection.item_name).get());\n-        }\n         ty::ty_err |\n         ty::ty_infer(_) |\n         ty::ty_open(_) |\n+        ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);"}, {"sha": "7abd59ca0cd0e27fa6f09597398742db147ff8e7", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -768,7 +768,6 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 tvec::vec_types(bcx,\n                                 ty::sequence_element_type(bcx.tcx(),\n                                                           base_datum.ty));\n-            base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n "}, {"sha": "d3f3f34b76bbb3e3e079df5de26d51c95bc51e11", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -346,12 +346,14 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let align_ptr = GEPi(bcx, info, &[2u]);\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n-        ty::ty_vec(unit_ty, None) => {\n-            // The info in this case is the length of the vec, so the size is that\n+        ty::ty_vec(_, None) | ty::ty_str => {\n+            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+            // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n+            let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t))[])\n@@ -456,8 +458,11 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                  &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n                  None);\n             bcx\n-        }\n-        ty::ty_vec(ty, None) => tvec::make_drop_glue_unboxed(bcx, v0, ty, false),\n+        },\n+        ty::ty_vec(_, None) | ty::ty_str => {\n+            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n+            tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, false)\n+        },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n             if type_needs_drop(bcx.tcx(), t) &&"}, {"sha": "1552ac0bea0fe0f4e714fc81e22a1faaccdc39b4", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -82,17 +82,6 @@ pub fn llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n     return C_uint(cx, llsize_of_alloc(cx, ty));\n }\n \n-// Returns the \"default\" size of t (see above), or 1 if the size would\n-// be zero.  This is important for things like vectors that expect\n-// space to be consumed.\n-pub fn nonzero_llsize_of(cx: &CrateContext, ty: Type) -> ValueRef {\n-    if llbitsize_of_real(cx, ty) == 0 {\n-        unsafe { llvm::LLVMConstInt(cx.int_type().to_ref(), 1, False) }\n-    } else {\n-        llsize_of(cx, ty)\n-    }\n-}\n-\n // Returns the preferred alignment of the given type for the current target.\n // The preferred alignment may be larger than the alignment used when\n // packing the type into structs. This will be used for things like"}, {"sha": "0fb0dffe930fa958547c5cd2375f3b001d91c075", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -288,6 +288,17 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      param_substs,\n                                      callee_substs)\n         }\n+        traits::VtableObject(ref data) => {\n+            let trait_item_def_ids =\n+                ty::trait_item_def_ids(ccx.tcx(), trait_id);\n+            let method_offset_in_trait =\n+                trait_item_def_ids.iter()\n+                                  .position(|item| item.def_id() == method_id)\n+                                  .unwrap();\n+            let (llfn, ty) =\n+                trans_object_shim(ccx, data.object_ty, trait_id, method_offset_in_trait);\n+            immediate_rvalue(llfn, ty)\n+        }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n                                  vtbl.repr(tcx))[]);\n@@ -371,7 +382,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n-            let llfn = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            let (llfn, _) = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableBuiltin(..) |\n@@ -540,7 +551,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     object_ty: Ty<'tcx>,\n     trait_id: ast::DefId,\n     method_offset_in_trait: uint)\n-    -> ValueRef\n+    -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n@@ -667,7 +678,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     finish_fn(&fcx, bcx, sig.output);\n \n-    llfn\n+    (llfn, method_bare_fn_ty)\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin."}, {"sha": "f8b01ebf4ccad1ade99bf6b54d9aea470aa5dad7", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -25,7 +25,7 @@ use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n use trans::glue;\n use trans::machine;\n-use trans::machine::{nonzero_llsize_of, llsize_of_alloc};\n+use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n use middle::ty::{self, Ty};\n@@ -44,13 +44,6 @@ fn get_dataptr(bcx: Block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, expr::get_dataptr(bcx, vptr))\n }\n \n-pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n-    let old_ty = val_ty(ptr);\n-    let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n-    return PointerCast(bcx, InBoundsGEP(bcx, bptr, &[bytes]), old_ty);\n-}\n-\n pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           vptr: ValueRef,\n                                           unit_ty: Ty<'tcx>,\n@@ -94,17 +87,14 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub struct VecTypes<'tcx> {\n     pub unit_ty: Ty<'tcx>,\n     pub llunit_ty: Type,\n-    pub llunit_size: ValueRef,\n     pub llunit_alloc_size: u64\n }\n \n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n-                 llunit_size={}, llunit_alloc_size={}}}\",\n+        format!(\"VecTypes {{unit_ty={}, llunit_ty={}, llunit_alloc_size={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n                 ccx.tn().type_to_string(self.llunit_ty),\n-                ccx.tn().val_to_string(self.llunit_size),\n                 self.llunit_alloc_size)\n     }\n }\n@@ -333,13 +323,11 @@ pub fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              -> VecTypes<'tcx> {\n     let ccx = bcx.ccx();\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n-    let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n     let llunit_alloc_size = llsize_of_alloc(ccx, llunit_ty);\n \n     VecTypes {\n         unit_ty: unit_ty,\n         llunit_ty: llunit_ty,\n-        llunit_size: llunit_size,\n         llunit_alloc_size: llunit_alloc_size\n     }\n }\n@@ -486,17 +474,13 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n \n     let vt = vec_types(bcx, unit_ty);\n-    let fill = Mul(bcx, len, vt.llunit_size);\n \n     if vt.llunit_alloc_size == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-        iter_vec_loop(bcx, data_ptr, &vt, fill, f)\n+        iter_vec_loop(bcx, data_ptr, &vt, len, f)\n     } else {\n         // Calculate the last pointer address we want to handle.\n-        // FIXME (#3729): Optimize this when the size of the unit type is\n-        // statically known to not use pointer casts, which tend to confuse\n-        // LLVM.\n-        let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n+        let data_end_ptr = InBoundsGEP(bcx, data_ptr, &[len]);\n \n         // Now perform the iteration.\n         let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");"}, {"sha": "f2927dfd843400551699b78d77612a71bd5127c7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -516,8 +516,15 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n {\n     let mut projections = Vec::new();\n \n+    // the trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = ShiftedRscope::new(rscope);\n+\n     let trait_ref =\n-        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref,\n+        instantiate_trait_ref(this, &shifted_rscope, &ast_trait_ref.trait_ref,\n                               self_ty, Some(&mut projections));\n \n     for projection in projections.into_iter() {\n@@ -561,6 +568,29 @@ pub fn instantiate_trait_ref<'tcx>(\n     }\n }\n \n+fn object_path_to_poly_trait_ref<'a,'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n+    trait_def_id: ast::DefId,\n+    path: &ast::Path,\n+    mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n+{\n+    // we are introducing a binder here, so shift the\n+    // anonymous regions depth to account for that\n+    let shifted_rscope = ShiftedRscope::new(rscope);\n+\n+    let mut tmp = Vec::new();\n+    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n+                                                     &shifted_rscope,\n+                                                     trait_def_id,\n+                                                     None,\n+                                                     path,\n+                                                     Some(&mut tmp)));\n+    projections.extend(tmp.into_iter().map(ty::Binder));\n+    trait_ref\n+}\n+\n fn ast_path_to_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n@@ -573,13 +603,6 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     debug!(\"ast_path_to_trait_ref {:?}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n-    // the trait reference introduces a binding level here, so\n-    // we need to shift the `rscope`. It'd be nice if we could\n-    // do away with this rscope stuff and work this knowledge\n-    // into resolve_lifetimes, as we do with non-omitted\n-    // lifetimes. Oh well, not there yet.\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n     let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n@@ -595,7 +618,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                             the crate attributes to enable\");\n             }\n \n-            convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n+            convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             // For now, require that parenthetical notation be used\n@@ -616,7 +639,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     };\n \n     let substs = create_substs_for_ast_path(this,\n-                                            &shifted_rscope,\n+                                            rscope,\n                                             path.span,\n                                             &trait_def.generics,\n                                             self_ty,\n@@ -851,15 +874,11 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n-                    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n-                                                                     rscope,\n-                                                                     trait_def_id,\n-                                                                     None,\n-                                                                     path,\n-                                                                     Some(&mut projection_bounds)));\n-                    let projection_bounds = projection_bounds.into_iter()\n-                                                             .map(ty::Binder)\n-                                                             .collect();\n+                    let trait_ref = object_path_to_poly_trait_ref(this,\n+                                                                  rscope,\n+                                                                  trait_def_id,\n+                                                                  path,\n+                                                                  &mut projection_bounds);\n                     Ok((trait_ref, projection_bounds))\n                 }\n                 _ => {\n@@ -1098,16 +1117,13 @@ pub fn ast_ty_to_ty<'tcx>(\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n                         let mut projection_bounds = Vec::new();\n-                        let trait_ref = ast_path_to_trait_ref(this,\n-                                                              rscope,\n-                                                              trait_def_id,\n-                                                              None,\n-                                                              path,\n-                                                              Some(&mut projection_bounds));\n-                        let trait_ref = ty::Binder(trait_ref);\n-                        let projection_bounds = projection_bounds.into_iter()\n-                                                                 .map(ty::Binder)\n-                                                                 .collect();\n+\n+                        let trait_ref = object_path_to_poly_trait_ref(this,\n+                                                                      rscope,\n+                                                                      trait_def_id,\n+                                                                      path,\n+                                                                      &mut projection_bounds);\n+\n                         trait_ref_to_object_type(this, rscope, path.span,\n                                                  trait_ref, projection_bounds, &[])\n                     }"}, {"sha": "2719a09f4f57007443e9fba45989206ef21b88ea", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations checker: builtin traits and default impls are allowed just\n+//! for structs and enums.\n+\n+use middle::ty;\n+use syntax::ast::{Item, ItemImpl};\n+use syntax::ast;\n+use syntax::visit;\n+\n+pub fn check(tcx: &ty::ctxt) {\n+    let mut impls = ImplsChecker { tcx: tcx };\n+    visit::walk_crate(&mut impls, tcx.map.krate());\n+}\n+\n+struct ImplsChecker<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>\n+}\n+\n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        match item.node {\n+            ast::ItemImpl(_, _, _, Some(ref opt_trait), _, _) => {\n+                let trait_ref = ty::node_id_to_trait_ref(self.tcx, opt_trait.ref_id);\n+                if let Some(_) = self.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n+                    match trait_ref.self_ty().sty {\n+                        ty::ty_struct(..) | ty::ty_enum(..) => {}\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                item.span,\n+                                &format!(\"builtin traits can only be \\\n+                                          implemented on structs or enums\")[]);\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "a7ef4c1e9f2a572a9c1409d61d7cb62aff5cdf09", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -49,6 +49,7 @@ use syntax::visit;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use util::ppaux::Repr;\n \n+mod impls;\n mod orphan;\n mod overlap;\n mod unsafety;\n@@ -596,6 +597,7 @@ pub fn check_coherence(crate_context: &CrateCtxt) {\n         inference_context: new_infer_ctxt(crate_context.tcx),\n         inherent_impls: RefCell::new(FnvHashMap::new()),\n     }.check(crate_context.tcx.map.krate());\n+    impls::check(crate_context.tcx);\n     unsafety::check(crate_context.tcx);\n     orphan::check(crate_context.tcx);\n     overlap::check(crate_context.tcx);"}, {"sha": "dc98a56eb1a4e7c1ed598ed393f9d099d44c6e60", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -91,6 +91,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n <html lang=\"en\">\n <head>\n     <meta charset=\"utf-8\">\n+    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n     <meta name=\"generator\" content=\"rustdoc\">\n     <title>{title}</title>\n "}, {"sha": "43ca7b131455b4b2fb14f04bbaae74f704ead1b2", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -21,6 +21,8 @@ use prelude::v1::*;\n use collections::HashMap;\n use ffi::CString;\n use fmt;\n+// NOTE(stage0) remove import after a snapshot\n+#[cfg(stage0)]\n use hash::Hash;\n use io::pipe::{PipeStream, PipePair};\n use io::{IoResult, IoError};"}, {"sha": "8130a6c82ec3e8c0fdae0f11b19f12c568e77692", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -374,9 +374,13 @@ impl Rng for ThreadRng {\n /// `random()` can generate various types of random things, and so may require\n /// type hinting to generate the specific type you want.\n ///\n+/// This function uses the thread local random number generator. This means\n+/// that if you're calling `random()` in a loop, caching the generator can\n+/// increase performance. An example is shown below.\n+///\n /// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::rand;\n ///\n /// let x = rand::random();\n@@ -389,6 +393,27 @@ impl Rng for ThreadRng {\n ///     println!(\"Better lucky than good!\");\n /// }\n /// ```\n+///\n+/// Caching the thread local random number generator:\n+///\n+/// ```\n+/// use std::rand;\n+/// use std::rand::Rng;\n+///\n+/// let mut v = vec![1, 2, 3];\n+///\n+/// for x in v.iter_mut() {\n+///     *x = rand::random()\n+/// }\n+///\n+/// // would be faster as\n+///\n+/// let mut rng = rand::thread_rng();\n+///\n+/// for x in v.iter_mut() {\n+///     *x = rng.gen();\n+/// }\n+/// ```\n #[inline]\n pub fn random<T: Rand>() -> T {\n     thread_rng().gen()"}, {"sha": "4258eb32fdf0f671b47295596944f12a8f20d567", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -63,6 +63,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     'statement: loop {\n         match state {\n             Asm => {\n+                if asm_str_style.is_some() {\n+                    // If we already have a string with instructions,\n+                    // ending up in Asm state again is an error.\n+                    cx.span_err(sp, \"malformed inline assembly\");\n+                    return DummyResult::expr(sp);\n+                }\n                 let (s, style) = match expr_to_string(cx, p.parse_expr(),\n                                                    \"inline assembly must be a string literal\") {\n                     Some((s, st)) => (s, st),"}, {"sha": "f73023ddd1eb05c587928b6ec6e21971fc8c1974", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -92,11 +92,10 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n     let recurse = vec!(cx.ident_of(krate),\n                     cx.ident_of(\"Decodable\"),\n                     cx.ident_of(\"decode\"));\n+    let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n-    let calldecode = cx.expr_call_global(trait_span, recurse, vec!(blkdecoder.clone()));\n-    let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n@@ -116,7 +115,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     cx.expr_method_call(span, blkdecoder.clone(), read_struct_field,\n                                         vec!(cx.expr_str(span, name),\n                                           cx.expr_uint(span, field),\n-                                          lambdadecode.clone())))\n+                                          exprdecode.clone())))\n             });\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n@@ -147,7 +146,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                     let idx = cx.expr_uint(span, field);\n                     cx.expr_try(span,\n                         cx.expr_method_call(span, blkdecoder.clone(), rvariant_arg,\n-                                            vec!(idx, lambdadecode.clone())))\n+                                            vec!(idx, exprdecode.clone())))\n                 });\n \n                 arms.push(cx.arm(v_span,"}, {"sha": "161b27d7abb597e3245c9cb7b0b0c38e476c1bb2", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -21,13 +21,7 @@\n //!   (e.g. `Option<T>`), the parameters are automatically given the\n //!   current trait as a bound. (This includes separate type parameters\n //!   and lifetimes for methods.)\n-//! - Additional bounds on the type parameters, e.g. the `Ord` instance\n-//!   requires an explicit `PartialEq` bound at the\n-//!   moment. (`TraitDef.additional_bounds`)\n-//!\n-//! Unsupported: FIXME #6257: calling methods on reference fields,\n-//! e.g. derive Eq/Ord/Clone don't work on `struct A(&int)`,\n-//! because of how the auto-dereferencing happens.\n+//! - Additional bounds on the type parameters (`TraitDef.additional_bounds`)\n //!\n //! The most important thing for implementers is the `Substructure` and\n //! `SubstructureFields` objects. The latter groups 5 possibilities of the\n@@ -79,6 +73,15 @@\n //! enums (one for each variant). For empty struct and empty enum\n //! variants, it is represented as a count of 0.\n //!\n+//! # \"`cs`\" functions\n+//!\n+//! The `cs_...` functions (\"combine substructure) are designed to\n+//! make life easier by providing some pre-made recipes for common\n+//! tasks; mostly calling the function being derived on all the\n+//! arguments and then combining them back together in some way (or\n+//! letting the user chose that). They are not meant to be the only\n+//! way to handle the structures that this code creates.\n+//!\n //! # Examples\n //!\n //! The following simplified `PartialEq` is used for in-code examples:\n@@ -102,22 +105,22 @@\n //! When generating the `expr` for the `A` impl, the `SubstructureFields` is\n //!\n //! ```{.text}\n-//! Struct(~[FieldInfo {\n+//! Struct(vec![FieldInfo {\n //!            span: <span of x>\n //!            name: Some(<ident of x>),\n //!            self_: <expr for &self.x>,\n-//!            other: ~[<expr for &other.x]\n+//!            other: vec![<expr for &other.x]\n //!          }])\n //! ```\n //!\n //! For the `B` impl, called with `B(a)` and `B(b)`,\n //!\n //! ```{.text}\n-//! Struct(~[FieldInfo {\n+//! Struct(vec![FieldInfo {\n //!           span: <span of `int`>,\n //!           name: None,\n-//!           <expr for &a>\n-//!           ~[<expr for &b>]\n+//!           self_: <expr for &a>\n+//!           other: vec![<expr for &b>]\n //!          }])\n //! ```\n //!\n@@ -128,31 +131,31 @@\n //!\n //! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n-//!              ~[FieldInfo {\n+//!              vec![FieldInfo {\n //!                 span: <span of int>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n-//!                 other: ~[<expr for &b>]\n+//!                 other: vec![<expr for &b>]\n //!               }])\n //! ```\n //!\n //! For `C1 {x}` and `C1 {x}`,\n //!\n //! ```{.text}\n //! EnumMatching(1, <ast::Variant for C1>,\n-//!              ~[FieldInfo {\n+//!              vec![FieldInfo {\n //!                 span: <span of x>\n //!                 name: Some(<ident of x>),\n //!                 self_: <expr for &self.x>,\n-//!                 other: ~[<expr for &other.x>]\n+//!                 other: vec![<expr for &other.x>]\n //!                }])\n //! ```\n //!\n //! For `C0(a)` and `C1 {x}` ,\n //!\n //! ```{.text}\n //! EnumNonMatchingCollapsed(\n-//!     ~[<ident of self>, <ident of __arg_1>],\n+//!     vec![<ident of self>, <ident of __arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n //!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ```\n@@ -168,16 +171,16 @@\n //!\n //! ## Static\n //!\n-//! A static method on the above would result in,\n+//! A static method on the types above would result in,\n //!\n //! ```{.text}\n-//! StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n+//! StaticStruct(<ast::StructDef of A>, Named(vec![(<ident of x>, <span of x>)]))\n //!\n-//! StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n+//! StaticStruct(<ast::StructDef of B>, Unnamed(vec![<span of x>]))\n //!\n-//! StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n-//!                                   (<ident of C1>, <span of C1>,\n-//!                                    Named(~[(<ident of x>, <span of x>)]))])\n+//! StaticEnum(<ast::EnumDef of C>,\n+//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of int>])),\n+//!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n //! ```\n \n pub use self::StaticFields::*;\n@@ -1378,8 +1381,8 @@ pub fn cs_fold<F>(use_foldl: bool,\n /// process the collected results. i.e.\n ///\n /// ```\n-/// f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n-///              self_2.method(__arg_1_2, __arg_2_2)])\n+/// f(cx, span, vec![self_1.method(__arg_1_1, __arg_2_1),\n+///                  self_2.method(__arg_1_2, __arg_2_2)])\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,"}, {"sha": "889a212a2872911931f1b40e965577e27e289527", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -65,9 +65,19 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         [ref state_expr] => state_expr,\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n     };\n-    let hash_ident = substr.method_ident;\n     let call_hash = |&: span, thing_expr| {\n-        let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr.clone()));\n+        let hash_path = {\n+            let strs = vec![\n+                cx.ident_of(\"std\"),\n+                cx.ident_of(\"hash\"),\n+                cx.ident_of(\"Hash\"),\n+                cx.ident_of(\"hash\"),\n+            ];\n+\n+            cx.expr_path(cx.path_global(span, strs))\n+        };\n+        let ref_thing = cx.expr_addr_of(span, thing_expr);\n+        let expr = cx.expr_call(span, hash_path, vec!(ref_thing, state_expr.clone()));\n         cx.stmt_expr(expr)\n     };\n     let mut stmts = Vec::new();"}, {"sha": "9d03ec73af8b127f0f0fa4e606d9510d23fb89e7", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -24,14 +24,6 @@ use ptr::P;\n pub enum ObsoleteSyntax {\n     Sized,\n     ForSized,\n-    OwnedType,\n-    OwnedExpr,\n-    OwnedPattern,\n-    OwnedVector,\n-    OwnedSelf,\n-    ImportRenaming,\n-    SubsliceMatch,\n-    ExternCrateRenaming,\n     ProcType,\n     ProcExpr,\n     ClosureType,\n@@ -69,38 +61,6 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`proc` expression\",\n                 \"use a `move ||` expression instead\",\n             ),\n-            ObsoleteSyntax::OwnedType => (\n-                \"`~` notation for owned pointers\",\n-                \"use `Box<T>` in `std::owned` instead\"\n-            ),\n-            ObsoleteSyntax::OwnedExpr => (\n-                \"`~` notation for owned pointer allocation\",\n-                \"use the `box` operator instead of `~`\"\n-            ),\n-            ObsoleteSyntax::OwnedPattern => (\n-                \"`~` notation for owned pointer patterns\",\n-                \"use the `box` operator instead of `~`\"\n-            ),\n-            ObsoleteSyntax::OwnedVector => (\n-                \"`~[T]` is no longer a type\",\n-                \"use the `Vec` type instead\"\n-            ),\n-            ObsoleteSyntax::OwnedSelf => (\n-                \"`~self` is no longer supported\",\n-                \"write `self: Box<Self>` instead\"\n-            ),\n-            ObsoleteSyntax::ImportRenaming => (\n-                \"`use foo = bar` syntax\",\n-                \"write `use bar as foo` instead\"\n-            ),\n-            ObsoleteSyntax::SubsliceMatch => (\n-                \"subslice match syntax\",\n-                \"instead of `..xs`, write `xs..` in a pattern\"\n-            ),\n-            ObsoleteSyntax::ExternCrateRenaming => (\n-                \"`extern crate foo = bar` syntax\",\n-                \"write `extern crate bar as foo` instead\"\n-            ),\n             ObsoleteSyntax::ClosureType => (\n                 \"`|uint| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\""}, {"sha": "30cc9836374fb598775890b6e2037e21f340cff2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 129, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -52,7 +52,7 @@ use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n-use ast::{TypeField, TyFixedLengthVec, TyBareFn};\n+use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n@@ -71,7 +71,7 @@ use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n-use parse::obsolete::*;\n+use parse::obsolete::{ParserObsoleteMethods, ObsoleteSyntax};\n use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n@@ -1404,22 +1404,6 @@ impl<'a> Parser<'a> {\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n-    /// Parse [mut/const/imm] ID : TY\n-    /// now used only by obsolete record syntax parser...\n-    pub fn parse_ty_field(&mut self) -> TypeField {\n-        let lo = self.span.lo;\n-        let mutbl = self.parse_mutability();\n-        let id = self.parse_ident();\n-        self.expect(&token::Colon);\n-        let ty = self.parse_ty_sum();\n-        let hi = ty.span.hi;\n-        ast::TypeField {\n-            ident: id,\n-            mt: MutTy { ty: ty, mutbl: mutbl },\n-            span: mk_sp(lo, hi),\n-        }\n-    }\n-\n     /// Parse optional return type [ -> TY ] in function decl\n     pub fn parse_ret_ty(&mut self) -> FunctionRetTy {\n         if self.eat(&token::RArrow) {\n@@ -1506,17 +1490,6 @@ impl<'a> Parser<'a> {\n             } else {\n                 TyTup(ts)\n             }\n-        } else if self.token == token::Tilde {\n-            // OWNED POINTER\n-            self.bump();\n-            let last_span = self.last_span;\n-            match self.token {\n-                token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n-                }\n-                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedType)\n-            }\n-            TyTup(vec![self.parse_ty()])\n         } else if self.check(&token::BinOp(token::Star)) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n@@ -2830,20 +2803,6 @@ impl<'a> Parser<'a> {\n             hi = e.span.hi;\n             ex = ExprAddrOf(m, e);\n           }\n-          token::Tilde => {\n-            self.bump();\n-            let last_span = self.last_span;\n-            match self.token {\n-                token::OpenDelim(token::Bracket) => {\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedVector)\n-                },\n-                _ => self.obsolete(last_span, ObsoleteSyntax::OwnedExpr)\n-            }\n-\n-            let e = self.parse_prefix_expr();\n-            hi = e.span.hi;\n-            ex = self.mk_unary(UnUniq, e);\n-          }\n           token::DotDot if !self.restrictions.contains(RESTRICTION_NO_DOTS) => {\n             // A range, closed above: `..expr`.\n             self.bump();\n@@ -3249,10 +3208,6 @@ impl<'a> Parser<'a> {\n                             span: self.span,\n                         }));\n                         before_slice = false;\n-                    } else {\n-                        let _ = self.parse_pat();\n-                        let span = self.span;\n-                        self.obsolete(span, ObsoleteSyntax::SubsliceMatch);\n                     }\n                     continue\n                 }\n@@ -3361,20 +3316,6 @@ impl<'a> Parser<'a> {\n                 span: mk_sp(lo, hi)\n             })\n           }\n-          token::Tilde => {\n-            // parse ~pat\n-            self.bump();\n-            let sub = self.parse_pat();\n-            pat = PatBox(sub);\n-            let last_span = self.last_span;\n-            hi = last_span.hi;\n-            self.obsolete(last_span, ObsoleteSyntax::OwnedPattern);\n-            return P(ast::Pat {\n-                id: ast::DUMMY_NODE_ID,\n-                node: pat,\n-                span: mk_sp(lo, hi)\n-            })\n-          }\n           token::BinOp(token::And) | token::AndAnd => {\n             // parse &pat and &mut pat\n             let lo = self.span.lo;\n@@ -4483,16 +4424,6 @@ impl<'a> Parser<'a> {\n                 self_ident_hi = self.last_span.hi;\n                 eself\n             }\n-            token::Tilde => {\n-                // We need to make sure it isn't a type\n-                if self.look_ahead(1, |t| t.is_keyword(keywords::Self)) {\n-                    self.bump();\n-                    drop(self.expect_self_ident());\n-                    let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf)\n-                }\n-                SelfStatic\n-            }\n             token::BinOp(token::Star) => {\n                 // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n                 // emitting cryptic \"unexpected token\" errors.\n@@ -4533,15 +4464,6 @@ impl<'a> Parser<'a> {\n                     } else {\n                         SelfValue(self_ident)\n                     }\n-                } else if self.token.is_mutability() &&\n-                        self.look_ahead(1, |t| *t == token::Tilde) &&\n-                        self.look_ahead(2, |t| t.is_keyword(keywords::Self)) {\n-                    mutbl_self = self.parse_mutability();\n-                    self.bump();\n-                    drop(self.expect_self_ident());\n-                    let last_span = self.last_span;\n-                    self.obsolete(last_span, ObsoleteSyntax::OwnedSelf);\n-                    SelfStatic\n                 } else {\n                     SelfStatic\n                 }\n@@ -5422,13 +5344,7 @@ impl<'a> Parser<'a> {\n         let (maybe_path, ident) = match self.token {\n             token::Ident(..) => {\n                 let the_ident = self.parse_ident();\n-                let path = if self.token == token::Eq {\n-                    self.bump();\n-                    let path = self.parse_str();\n-                    let span = self.span;\n-                    self.obsolete(span, ObsoleteSyntax::ExternCrateRenaming);\n-                    Some(path)\n-                } else if self.eat_keyword(keywords::As) {\n+                let path = if self.eat_keyword(keywords::As) {\n                     // skip the ident if there is one\n                     if self.token.is_ident() { self.bump(); }\n \n@@ -5698,17 +5614,7 @@ impl<'a> Parser<'a> {\n         }\n         // either a view item or an item:\n         if self.eat_keyword(keywords::Extern) {\n-            let next_is_mod = self.eat_keyword(keywords::Mod);\n-\n-            if next_is_mod || self.eat_keyword(keywords::Crate) {\n-                if next_is_mod {\n-                    let last_span = self.last_span;\n-                    self.span_err(mk_sp(lo, last_span.hi),\n-                                 &format!(\"`extern mod` is obsolete, use \\\n-                                          `extern crate` instead \\\n-                                          to refer to external \\\n-                                          crates.\")[])\n-                }\n+            if self.eat_keyword(keywords::Crate) {\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n \n@@ -6075,35 +5981,7 @@ impl<'a> Parser<'a> {\n \n         let first_ident = self.parse_ident();\n         let mut path = vec!(first_ident);\n-        match self.token {\n-          token::Eq => {\n-            // x = foo::bar\n-            self.bump();\n-            let path_lo = self.span.lo;\n-            path = vec!(self.parse_ident());\n-            while self.check(&token::ModSep) {\n-                self.bump();\n-                let id = self.parse_ident();\n-                path.push(id);\n-            }\n-            let span = mk_sp(path_lo, self.span.hi);\n-            self.obsolete(span, ObsoleteSyntax::ImportRenaming);\n-            let path = ast::Path {\n-                span: span,\n-                global: false,\n-                segments: path.into_iter().map(|identifier| {\n-                    ast::PathSegment {\n-                        identifier: identifier,\n-                        parameters: ast::PathParameters::none(),\n-                    }\n-                }).collect()\n-            };\n-            return P(spanned(lo, self.span.hi,\n-                             ViewPathSimple(first_ident, path,\n-                                           ast::DUMMY_NODE_ID)));\n-          }\n-\n-          token::ModSep => {\n+        if let token::ModSep = self.token {\n             // foo::bar or foo::{a,b,c} or foo::*\n             while self.check(&token::ModSep) {\n                 self.bump();\n@@ -6156,8 +6034,6 @@ impl<'a> Parser<'a> {\n                   _ => break\n                 }\n             }\n-          }\n-          _ => ()\n         }\n         let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {"}, {"sha": "06d510d37bd312dc6a032b0975a1db3380d2bcfb", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 100, "deletions": 89, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -59,10 +59,6 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n-pub use self::PrintStackBreak::*;\n-pub use self::Breaks::*;\n-pub use self::Token::*;\n-\n use std::io;\n use std::string;\n use std::iter::repeat;\n@@ -87,7 +83,7 @@ pub struct BeginToken {\n \n #[derive(Clone)]\n pub enum Token {\n-    String(string::String, int),\n+    String(String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -96,12 +92,15 @@ pub enum Token {\n \n impl Token {\n     pub fn is_eof(&self) -> bool {\n-        match *self { Eof => true, _ => false }\n+        match *self {\n+            Token::Eof => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_hardbreak_tok(&self) -> bool {\n         match *self {\n-            Break(BreakToken {\n+            Token::Break(BreakToken {\n                 offset: 0,\n                 blank_space: bs\n             }) if bs == SIZE_INFINITY =>\n@@ -112,22 +111,22 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> string::String {\n-    match t {\n-        String(s, len) => return format!(\"STR({},{})\", s, len),\n-        Break(_) => return \"BREAK\".to_string(),\n-        Begin(_) => return \"BEGIN\".to_string(),\n-        End => return \"END\".to_string(),\n-        Eof => return \"EOF\".to_string()\n+pub fn tok_str(token: &Token) -> String {\n+    match *token {\n+        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n+        Token::Break(_) => \"BREAK\".to_string(),\n+        Token::Begin(_) => \"BEGIN\".to_string(),\n+        Token::End => \"END\".to_string(),\n+        Token::Eof => \"EOF\".to_string()\n     }\n }\n \n-pub fn buf_str(toks: Vec<Token>,\n-               szs: Vec<int>,\n+pub fn buf_str(toks: &[Token],\n+               szs: &[int],\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> string::String {\n+               -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n@@ -140,7 +139,7 @@ pub fn buf_str(toks: Vec<Token>,\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone()))[]);\n+                           tok_str(&toks[i]))[]);\n         i += 1u;\n         i %= n;\n     }\n@@ -167,7 +166,7 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let token: Vec<Token> = repeat(Token::Eof).take(n).collect();\n     let size: Vec<int> = repeat(0i).take(n).collect();\n     let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n@@ -312,20 +311,18 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n+    pub fn pretty_print(&mut self, token: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n-        match t {\n-          Eof => {\n+        match token {\n+          Token::Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                let left = self.token[self.left].clone();\n-                let left_size = self.size[self.left];\n-                try!(self.advance_left(left, left_size));\n+                try!(self.advance_left());\n             }\n             self.indent(0);\n             Ok(())\n           }\n-          Begin(b) => {\n+          Token::Begin(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -334,27 +331,27 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             if self.scan_stack_empty {\n                 debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n-                self.print(t, 0)\n+                self.print(token, 0)\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t;\n+                self.token[self.right] = token;\n                 self.size[self.right] = -1;\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n             }\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -366,21 +363,21 @@ impl Printer {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n-          String(ref s, len) => {\n+          Token::String(s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n-                       *s, self.left, self.right);\n-                self.print(t.clone(), len)\n+                       s, self.left, self.right);\n+                self.print(Token::String(s, len), len)\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n-                       *s, self.left, self.right);\n+                       s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t.clone();\n+                self.token[self.right] = Token::String(s, len);\n                 self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream()\n@@ -401,9 +398,7 @@ impl Printer {\n                     self.size[scanned] = SIZE_INFINITY;\n                 }\n             }\n-            let left = self.token[self.left].clone();\n-            let left_size = self.size[self.left];\n-            try!(self.advance_left(left, left_size));\n+            try!(self.advance_left());\n             if self.left != self.right {\n                 try!(self.check_stream());\n             }\n@@ -450,42 +445,52 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self, x: Token, l: int) -> io::IoResult<()> {\n+    pub fn advance_left(&mut self) -> io::IoResult<()> {\n         debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n-               self.left, l);\n-        if l >= 0 {\n-            let ret = self.print(x.clone(), l);\n-            match x {\n-              Break(b) => self.left_total += b.blank_space,\n-              String(_, len) => {\n-                assert_eq!(len, l); self.left_total += len;\n-              }\n-              _ => ()\n-            }\n-            if self.left != self.right {\n-                self.left += 1u;\n-                self.left %= self.buf_len;\n-                let left = self.token[self.left].clone();\n-                let left_size = self.size[self.left];\n-                try!(self.advance_left(left, left_size));\n+               self.left, self.size[self.left]);\n+\n+        let mut left_size = self.size[self.left];\n+\n+        while left_size >= 0 {\n+            let left = self.token[self.left].clone();\n+\n+            let len = match left {\n+                Token::Break(b) => b.blank_space,\n+                Token::String(_, len) => {\n+                    assert_eq!(len, left_size);\n+                    len\n+                }\n+                _ => 0\n+            };\n+\n+            try!(self.print(left, left_size));\n+\n+            self.left_total += len;\n+\n+            if self.left == self.right {\n+                break;\n             }\n-            ret\n-        } else {\n-            Ok(())\n+\n+            self.left += 1u;\n+            self.left %= self.buf_len;\n+\n+            left_size = self.size[self.left];\n         }\n+\n+        Ok(())\n     }\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             match self.token[x] {\n-                Begin(_) => {\n+                Token::Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n                         self.size[popped] = self.size[x] + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n-                End => {\n+                Token::End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n                     self.size[popped] = 1;\n@@ -520,7 +525,7 @@ impl Printer {\n         } else {\n             PrintStackElem {\n                 offset: 0,\n-                pbreak: Broken(Inconsistent)\n+                pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n         }\n     }\n@@ -531,56 +536,56 @@ impl Printer {\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, l: int) -> io::IoResult<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), l,\n+    pub fn print(&mut self, token: Token, l: int) -> io::IoResult<()> {\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n-        debug!(\"{}\", buf_str(self.token.clone(),\n-                             self.size.clone(),\n+        debug!(\"{}\", buf_str(&self.token[],\n+                             &self.size[],\n                              self.left,\n                              self.right,\n                              6));\n-        match x {\n-          Begin(b) => {\n+        match token {\n+          Token::Begin(b) => {\n             if l > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!(\"print Begin -> push broken block at col {}\", col);\n                 self.print_stack.push(PrintStackElem {\n                     offset: col,\n-                    pbreak: Broken(b.breaks)\n+                    pbreak: PrintStackBreak::Broken(b.breaks)\n                 });\n             } else {\n                 debug!(\"print Begin -> push fitting block\");\n                 self.print_stack.push(PrintStackElem {\n                     offset: 0,\n-                    pbreak: Fits\n+                    pbreak: PrintStackBreak::Fits\n                 });\n             }\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             let top = self.get_top();\n             match top.pbreak {\n-              Fits => {\n+              PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n                 Ok(())\n               }\n-              Broken(Consistent) => {\n+              PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n                 ret\n               }\n-              Broken(Inconsistent) => {\n+              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n@@ -597,14 +602,14 @@ impl Printer {\n               }\n             }\n           }\n-          String(s, len) => {\n+          Token::String(s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n             self.print_str(&s[])\n           }\n-          Eof => {\n+          Token::Eof => {\n             // Eof should never get here.\n             panic!();\n           }\n@@ -616,41 +621,45 @@ impl Printer {\n //\n // \"raw box\"\n pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n-    p.pretty_print(Begin(BeginToken {\n+    p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n     }))\n }\n \n pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Inconsistent)\n+    rbox(p, indent, Breaks::Inconsistent)\n }\n \n pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Consistent)\n+    rbox(p, indent, Breaks::Consistent)\n }\n \n pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n-    p.pretty_print(Break(BreakToken {\n+    p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n     }))\n }\n \n-pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n+pub fn end(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::End)\n+}\n \n-pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n+pub fn eof(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::Eof)\n+}\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), wrd.len() as int))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as int))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n@@ -670,7 +679,9 @@ pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n }\n \n pub fn hardbreak_tok_offset(off: int) -> Token {\n-    Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n }\n \n-pub fn hardbreak_tok() -> Token { return hardbreak_tok_offset(0); }\n+pub fn hardbreak_tok() -> Token {\n+    hardbreak_tok_offset(0)\n+}"}, {"sha": "5d76dc710060b591e4bed8764fc01ce9a9dfc9c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 152, "deletions": 85, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -25,7 +25,8 @@ use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n-use print::pp::{Breaks, Consistent, Inconsistent, eof};\n+use print::pp::{Breaks, eof};\n+use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n \n use std::{ascii, mem};\n@@ -459,7 +460,7 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n \n impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Inconsistent);\n+        self.boxes.push(pp::Breaks::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n \n@@ -469,7 +470,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn cbox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Consistent);\n+        self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n@@ -531,11 +532,17 @@ impl<'a> State<'a> {\n     }\n \n     pub fn is_begin(&mut self) -> bool {\n-        match self.s.last_token() { pp::Begin(_) => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::Begin(_) => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_end(&mut self) -> bool {\n-        match self.s.last_token() { pp::End => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::End => true,\n+            _ => false,\n+        }\n     }\n \n     // is this the beginning of a line?\n@@ -545,7 +552,7 @@ impl<'a> State<'a> {\n \n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n-            Some(&last_box) => last_box == pp::Consistent,\n+            Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n@@ -1497,108 +1504,168 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n+    fn print_expr_box(&mut self,\n+                      place: &Option<P<ast::Expr>>,\n+                      expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"box\"));\n+        try!(word(&mut self.s, \"(\"));\n+        try!(place.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n+        try!(self.word_space(\")\"));\n+        self.print_expr(expr)\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_repeat(&mut self,\n+                         element: &ast::Expr,\n+                         count: &ast::Expr) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.print_expr(element));\n+        try!(self.word_space(\";\"));\n+        try!(self.print_expr(count));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_struct(&mut self,\n+                         path: &ast::Path,\n+                         fields: &[ast::Field],\n+                         wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n+        try!(self.print_path(path, true));\n+        if !(fields.is_empty() && wth.is_none()) {\n+            try!(word(&mut self.s, \"{\"));\n+            try!(self.commasep_cmnt(\n+                Consistent,\n+                &fields[],\n+                |s, field| {\n+                    try!(s.ibox(indent_unit));\n+                    try!(s.print_ident(field.ident.node));\n+                    try!(s.word_space(\":\"));\n+                    try!(s.print_expr(&*field.expr));\n+                    s.end()\n+                },\n+                |f| f.span));\n+            match *wth {\n+                Some(ref expr) => {\n+                    try!(self.ibox(indent_unit));\n+                    if !fields.is_empty() {\n+                        try!(word(&mut self.s, \",\"));\n+                        try!(space(&mut self.s));\n+                    }\n+                    try!(word(&mut self.s, \"..\"));\n+                    try!(self.print_expr(&**expr));\n+                    try!(self.end());\n+                }\n+                _ => try!(word(&mut self.s, \",\")),\n+            }\n+            try!(word(&mut self.s, \"}\"));\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.popen());\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        if exprs.len() == 1 {\n+            try!(word(&mut self.s, \",\"));\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self,\n+                       func: &ast::Expr,\n+                       args: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.print_expr_maybe_paren(func));\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self,\n+                              ident: ast::SpannedIdent,\n+                              tys: &[P<ast::Ty>],\n+                              args: &[P<ast::Expr>]) -> IoResult<()> {\n+        let base_args = args.slice_from(1);\n+        try!(self.print_expr(&*args[0]));\n+        try!(word(&mut self.s, \".\"));\n+        try!(self.print_ident(ident.node));\n+        if tys.len() > 0u {\n+            try!(word(&mut self.s, \"::<\"));\n+            try!(self.commasep(Inconsistent, tys,\n+                               |s, ty| s.print_type(&**ty)));\n+            try!(word(&mut self.s, \">\"));\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self,\n+                         op: ast::BinOp,\n+                         lhs: &ast::Expr,\n+                         rhs: &ast::Expr) -> IoResult<()> {\n+        try!(self.print_expr(lhs));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(ast_util::binop_to_string(op)));\n+        self.print_expr(rhs)\n+    }\n+\n+    fn print_expr_unary(&mut self,\n+                        op: ast::UnOp,\n+                        expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, ast_util::unop_to_string(op)));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n+    fn print_expr_addr_of(&mut self,\n+                          mutability: ast::Mutability,\n+                          expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"&\"));\n+        try!(self.print_mutability(mutability));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n     pub fn print_expr(&mut self, expr: &ast::Expr) -> IoResult<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprBox(ref p, ref e) => {\n-                try!(word(&mut self.s, \"box\"));\n-                try!(word(&mut self.s, \"(\"));\n-                try!(p.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n-                try!(self.word_space(\")\"));\n-                try!(self.print_expr(&**e));\n+            ast::ExprBox(ref place, ref expr) => {\n+                try!(self.print_expr_box(place, &**expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_vec(&exprs[]));\n             }\n-\n             ast::ExprRepeat(ref element, ref count) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**element));\n-                try!(self.word_space(\";\"));\n-                try!(self.print_expr(&**count));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_repeat(&**element, &**count));\n             }\n-\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_path(path, true));\n-                if !(fields.is_empty() && wth.is_none()) {\n-                    try!(word(&mut self.s, \"{\"));\n-                    try!(self.commasep_cmnt(\n-                        Consistent,\n-                        &fields[],\n-                        |s, field| {\n-                            try!(s.ibox(indent_unit));\n-                            try!(s.print_ident(field.ident.node));\n-                            try!(s.word_space(\":\"));\n-                            try!(s.print_expr(&*field.expr));\n-                            s.end()\n-                        },\n-                        |f| f.span));\n-                    match *wth {\n-                        Some(ref expr) => {\n-                            try!(self.ibox(indent_unit));\n-                            if !fields.is_empty() {\n-                                try!(word(&mut self.s, \",\"));\n-                                try!(space(&mut self.s));\n-                            }\n-                            try!(word(&mut self.s, \"..\"));\n-                            try!(self.print_expr(&**expr));\n-                            try!(self.end());\n-                        }\n-                        _ => try!(word(&mut self.s, \",\")),\n-                    }\n-                    try!(word(&mut self.s, \"}\"));\n-                }\n+                try!(self.print_expr_struct(path, &fields[], wth));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                if exprs.len() == 1 {\n-                    try!(word(&mut self.s, \",\"));\n-                }\n-                try!(self.pclose());\n+                try!(self.print_expr_tup(&exprs[]));\n             }\n             ast::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(&args[]));\n+                try!(self.print_expr_call(&**func, &args[]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n-                let base_args = args.slice_from(1);\n-                try!(self.print_expr(&*args[0]));\n-                try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(ident.node));\n-                if tys.len() > 0u {\n-                    try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, &tys[],\n-                                       |s, ty| s.print_type(&**ty)));\n-                    try!(word(&mut self.s, \">\"));\n-                }\n-                try!(self.print_call_post(base_args));\n+                try!(self.print_expr_method_call(ident, &tys[], &args[]));\n             }\n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n-                try!(space(&mut self.s));\n-                try!(self.word_space(ast_util::binop_to_string(op)));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n             }\n             ast::ExprUnary(op, ref expr) => {\n-                try!(word(&mut self.s, ast_util::unop_to_string(op)));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_unary(op, &**expr));\n             }\n             ast::ExprAddrOf(m, ref expr) => {\n-                try!(word(&mut self.s, \"&\"));\n-                try!(self.print_mutability(m));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_addr_of(m, &**expr));\n+            }\n+            ast::ExprLit(ref lit) => {\n+                try!(self.print_literal(&**lit));\n             }\n-            ast::ExprLit(ref lit) => try!(self.print_literal(&**lit)),\n             ast::ExprCast(ref expr, ref ty) => {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n@@ -2891,7 +2958,7 @@ impl<'a> State<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let is_semi = match self.s.last_token() {\n-                    pp::String(s, _) => \";\" == s,\n+                    pp::Token::String(s, _) => \";\" == s,\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {"}, {"sha": "30173368585d2cf36d0a7c25e2130761b44dd6f2", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -211,6 +211,8 @@ pub struct TestDesc {\n     pub should_fail: ShouldFail,\n }\n \n+unsafe impl Send for TestDesc {}\n+\n #[derive(Show)]\n pub struct TestDescAndFn {\n     pub desc: TestDesc,\n@@ -525,6 +527,8 @@ pub enum TestResult {\n     TrBench(BenchSamples),\n }\n \n+unsafe impl Send for TestResult {}\n+\n enum OutputLocation<T> {\n     Pretty(Box<term::Terminal<term::WriterWrapper> + Send>),\n     Raw(T),\n@@ -978,7 +982,6 @@ enum TestEvent {\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n-unsafe impl Send for MonitorMsg {}\n \n fn run_tests<F>(opts: &TestOpts,\n                 tests: Vec<TestDescAndFn> ,\n@@ -1332,10 +1335,11 @@ impl MetricMap {\n /// elimination.\n ///\n /// This function is a no-op, and does not even read from `dummy`.\n-pub fn black_box<T>(dummy: T) {\n+pub fn black_box<T>(dummy: T) -> T {\n     // we need to \"use\" the argument in some way LLVM can't\n     // introspect.\n     unsafe {asm!(\"\" : : \"r\"(&dummy))}\n+    dummy\n }\n \n "}, {"sha": "50a6ad43aeeb109474781f9ea68196b1b15f27eb", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -20,6 +20,7 @@ use error::{Error, CliResult, CommandResult};\n use book;\n use book::{Book, BookItem};\n use css;\n+use javascript;\n \n use regex::Regex;\n \n@@ -63,7 +64,7 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Writer) -> IoResult<()>\n         Ok(())\n     }\n \n-    try!(writeln!(out, \"<div id='toc'>\"));\n+    try!(writeln!(out, \"<div id='toc' class='mobile-hidden'>\"));\n     try!(writeln!(out, \"<ul class='chapter'>\"));\n     try!(walk_items(&book.chapters[], \"\", path_to_root, out));\n     try!(writeln!(out, \"</ul>\"));\n@@ -102,6 +103,14 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         let prelude = tmp.path().join(\"prelude.html\");\n         {\n             let mut toc = BufferedWriter::new(try!(File::create(&prelude)));\n+            try!(writeln!(&mut toc, r#\"<div id=\"nav\">\n+                <button id=\"toggle-nav\">\n+                  <span class=\"sr-only\">Toggle navigation</span>\n+                  <span class=\"bar\"></span>\n+                  <span class=\"bar\"></span>\n+                  <span class=\"bar\"></span>\n+                </button>\n+              </div>\"#));\n             let _ = write_toc(book, &item.path_to_root, &mut toc);\n             try!(writeln!(&mut toc, \"<div id='page-wrapper'>\"));\n             try!(writeln!(&mut toc, \"<div id='page'>\"));\n@@ -111,6 +120,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n         let postlude = tmp.path().join(\"postlude.html\");\n         {\n             let mut toc = BufferedWriter::new(try!(File::create(&postlude)));\n+            try!(toc.write_str(javascript::JAVASCRIPT));\n             try!(writeln!(&mut toc, \"</div></div>\"));\n         }\n "}, {"sha": "65ba031a2d63488354ddf81c793b3d71ae0362fb", "filename": "src/rustbook/css.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fcss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fcss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fcss.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -45,7 +45,7 @@ body {\n #page {\n     margin-left: auto;\n     margin-right:auto;\n-    width: 750px;\n+    max-width: 750px;\n }\n \n .chapter {\n@@ -69,4 +69,58 @@ body {\n .chapter li a {\n     color: #000000;\n }\n+\n+@media only screen and (max-width: 1060px) {\n+    #toc {\n+        width: 100%;\n+        margin-right: 0;\n+        top: 40px;\n+    }\n+    #page-wrapper {\n+        top: 40px;\n+        left: 15px;\n+        padding-right: 15px;\n+    }\n+    .mobile-hidden {\n+        display: none;\n+    }\n+}\n+\n+\n+#toggle-nav {\n+    height: 20px;\n+    width:  30px;\n+    padding: 3px 3px 0 3px;\n+}\n+\n+#toggle-nav {\n+    margin-top: 5px;\n+    width: 30px;\n+    height: 30px;\n+    background-color: #FFF;\n+    border: 1px solid #666;\n+    border-radius: 3px 3px 3px 3px;\n+}\n+\n+.sr-only {\n+    position: absolute;\n+    width: 1px;\n+    height: 1px;\n+    margin: -1px;\n+    padding: 0;\n+    overflow: hidden;\n+    clip: rect(0, 0, 0, 0);\n+    border: 0;\n+}\n+\n+.bar {\n+    display: block;\n+    background-color: #000;\n+    border-radius: 2px;\n+    width: 100%;\n+    height: 2px;\n+    margin: 2px 0 3px;\n+    padding: 0;\n+}\n+\n \"#;"}, {"sha": "eb4401e1835a25230b394cfc918eda5270369e1c", "filename": "src/rustbook/javascript.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fjavascript.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fjavascript.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fjavascript.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The rust-book JavaScript in string form.\n+\n+pub static JAVASCRIPT: &'static str = r#\"\n+<script type=\"text/javascript\">\n+document.addEventListener(\"DOMContentLoaded\", function(event) {\n+  document.getElementById(\"toggle-nav\").onclick = toggleNav;\n+  function toggleNav() {\n+    var toc = document.getElementById(\"toc\");\n+    var pagewrapper = document.getElementById(\"page-wrapper\");\n+    toggleClass(toc, \"mobile-hidden\");\n+    toggleClass(pagewrapper, \"mobile-hidden\");\n+  };\n+\n+  function toggleClass(el, className) {\n+     // from http://youmightnotneedjquery.com/\n+     if (el.classList) {\n+       el.classList.toggle(className);\n+     } else {\n+       var classes = el.className.split(' ');\n+       var existingIndex = classes.indexOf(className);\n+\n+       if (existingIndex >= 0) {\n+         classes.splice(existingIndex, 1);\n+       } else {\n+         classes.push(className);\n+       }\n+\n+       el.className = classes.join(' ');\n+     }\n+  }\n+});\n+</script>\n+\"#;"}, {"sha": "85b9a7d79dbfefc3bcca48eba8b10faee9ec4427", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -39,6 +39,7 @@ mod serve;\n mod test;\n \n mod css;\n+mod javascript;\n \n #[cfg(not(test))] // thanks #12327\n fn main() {"}, {"sha": "2ca288b60a33fb8a5530014af74f609d3f3d0917", "filename": "src/test/compile-fail/coherence-impls-builtin.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::Send;\n+\n+enum TestE {\n+  A\n+}\n+\n+struct MyType;\n+\n+unsafe impl Send for TestE {}\n+unsafe impl Send for MyType {}\n+unsafe impl Send for (MyType, MyType) {}\n+//~^ ERROR builtin traits can only be implemented on structs or enums\n+\n+unsafe impl Send for &'static MyType {}\n+//~^ ERROR builtin traits can only be implemented on structs or enums\n+\n+unsafe impl Send for [MyType] {}\n+//~^ ERROR builtin traits can only be implemented on structs or enums\n+\n+unsafe impl Send for &'static [MyType] {}\n+//~^ ERROR builtin traits can only be implemented on structs or enums\n+\n+fn is_send<T: Send>() {}\n+\n+fn main() {\n+    is_send::<(MyType, TestE)>();\n+}"}, {"sha": "aaf45f27398914cdc84574b3c91c73fbb0ec22ac", "filename": "src/test/compile-fail/issue-20831-debruijn.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20831-debruijn.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #20831: debruijn index account was thrown off\n+// by the (anonymous) lifetime in `<Self as Publisher>::Output`\n+// below. Note that changing to a named lifetime made the problem go\n+// away.\n+\n+use std::ops::{Shl, Shr};\n+use std::cell::RefCell;\n+\n+pub trait Subscriber {\n+    type Input;\n+}\n+\n+pub trait Publisher<'a> {\n+    type Output;\n+    fn subscribe(&mut self, Box<Subscriber<Input=Self::Output> + 'a>);\n+}\n+\n+pub trait Processor<'a> : Subscriber + Publisher<'a> { }\n+\n+impl<'a, P> Processor<'a> for P where P : Subscriber + Publisher<'a> { }\n+\n+struct MyStruct<'a> {\n+    sub: Box<Subscriber<Input=u64> + 'a>\n+}\n+\n+impl<'a> Publisher<'a> for MyStruct<'a> {\n+    type Output = u64;\n+    fn subscribe(&mut self, t : Box<Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n+        // Not obvious, but there is an implicit lifetime here -------^\n+        //~^^ ERROR cannot infer\n+        //\n+        // The fact that `Publisher` is using an implicit lifetime is\n+        // what was causing the debruijn accounting to be off, so\n+        // leave it that way!\n+        self.sub = t;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "134240f8c8aa3ecd052a5ce7a7104ddd56c65ee5", "filename": "src/test/compile-fail/issue-21045.rs", "status": "renamed", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-21045.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-21045.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21045.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -7,16 +7,10 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+#![feature(asm)]\n \n fn main() {\n-    let x = [1is, 2, 3];\n-    match x {\n-        [a, b, ..c] => {    //~ ERROR obsolete syntax\n-            assert_eq!(a, 1);\n-            assert_eq!(b, 2);\n-            let expected: &[_] = &[3];\n-            assert_eq!(c, expected);\n-        }\n-    }\n+    let a;\n+    asm!(\"nop\" \"nop\"); //~ ERROR malformed inline assembly\n+    asm!(\"nop\" \"nop\" : \"=r\"(a)); //~ ERROR malformed inline assembly\n }\n-", "previous_filename": "src/test/compile-fail/vec-matching-obsolete-syntax.rs"}, {"sha": "0ee381669351a6287a3bea5bddd1454b732945c0", "filename": "src/test/compile-fail/issue-21160.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    struct S(isize);\n-    let s = S(0);\n-    let x = *s; //~ ERROR single-field tuple-structs can no longer be dereferenced\n+struct Bar;\n+\n+impl Bar {\n+    fn hash<T>(&self, _: T) {}\n }\n+\n+#[derive(Hash)]\n+struct Foo(Bar);\n+//~^ error: the trait `core::hash::Hash<__S>` is not implemented for the type `Bar`\n+\n+fn main() {}", "previous_filename": "src/test/compile-fail/obsolete-tuple-struct-deref.rs"}, {"sha": "d290d5536a4a27a3ce8f421707e648d5f75a2c60", "filename": "src/test/compile-fail/obsolete-tilde.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8903c21d618fd25dca61d9bb668c5299d21feac9/src%2Ftest%2Fcompile-fail%2Fobsolete-tilde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8903c21d618fd25dca61d9bb668c5299d21feac9/src%2Ftest%2Fcompile-fail%2Fobsolete-tilde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobsolete-tilde.rs?ref=8903c21d618fd25dca61d9bb668c5299d21feac9", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that ~ pointers give an obsolescence message.\n-\n-fn foo(x: ~isize) {} //~ ERROR obsolete syntax: `~` notation for owned pointers\n-fn bar(x: ~str) {} //~ ERROR obsolete syntax: `~` notation for owned pointers\n-fn baz(x: ~[isize]) {} //~ ERROR obsolete syntax: `~[T]` is no longer a type\n-\n-fn main() {\n-    let x = ~4is; //~ ERROR obsolete syntax: `~` notation for owned pointer allocation\n-    let y = ~\"hello\"; //~ ERROR obsolete syntax: `~` notation for owned pointer allocation\n-    let z = ~[1is, 2, 3]; //~ ERROR obsolete syntax: `~[T]` is no longer a type\n-}"}, {"sha": "00de4497cedbf0ee2e7e88438a350dc0b4f79372", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -48,7 +48,11 @@ fn zzz() {()}\n fn some_function(a: int, b: int) {\n     let some_variable = Struct { a: 11, b: 22 };\n     let some_other_variable = 23i;\n-    zzz(); // #break\n+\n+    for x in range(0, 1) {\n+        zzz(); // #break\n+    }\n }\n \n fn some_other_function(a: int, b: int) -> bool { true }\n+"}, {"sha": "4ac8cb7ae1da7e929d624c0076fc657f4f493c81", "filename": "src/test/run-make/graphviz-flowgraph/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -28,7 +28,7 @@ $(TMPDIR)/%.pp: %.rs\n \n $(TMPDIR)/%.dot: %.rs\n \t$(eval $(call FIND_LAST_BLOCK,$<))\n-\t$(RUSTC_LIB) -Z unstable-options --xpretty flowgraph=$(LASTBLOCKNUM_$<) $< -o $@.tmp\n+\t$(RUSTC_LIB) -Z unstable-options --xpretty flowgraph,unlabelled=$(LASTBLOCKNUM_$<) $< -o $@.tmp\n \tcat $@.tmp | sed -e 's@ (id=[0-9]*)@@g' \\\n                          -e 's@\\[label=\"\"\\]@@' \\\n                          -e 's@digraph [a-zA-Z0-9_]* @digraph block @' \\"}, {"sha": "12b16cc9f8ce8eabf3e7d70b5196bce50443a73a", "filename": "src/test/run-make/graphviz-flowgraph/f12.dot-expected.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff12.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -34,7 +34,7 @@ digraph block {\n     N11 -> N12;\n     N12 -> N13;\n     N13 -> N14;\n-    N14 -> N6[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 2is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 block { x -= 1is; if x == 2is { break ; \\\"unreachable\\\"; } }\"];\n+    N14 -> N6;\n     N15 -> N16;\n     N16 -> N17;\n     N17 -> N18;"}, {"sha": "47e9b3f6cbe1ad09884baa88f6b6021ab90b1da3", "filename": "src/test/run-make/graphviz-flowgraph/f15.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff15.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -61,7 +61,7 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N9[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1is { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1is { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2is { break ; \\\"unreachable\\\"; }\\l    y -= 3is;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { break ; \\\"unreachable\\\"; }\\l        y -= 3is;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { break ; \\\"unreachable\\\"; }\\l        y -= 3is;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2is { break ; \\\"unreachable\\\"; }\\l            y -= 3is;\\l        }\\l    y -= 4is;\\l    x -= 5is;\\l}\\l\"];\n+    N15 -> N9;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n@@ -73,7 +73,7 @@ digraph block {\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N11[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 2is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 2is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2is { break ; \\\"unreachable\\\"; }\\l    y -= 3is;\\l}\\l\"];\n+    N26 -> N11;\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;"}, {"sha": "a37869b2264986e01995827de48d1a2d0e7fab06", "filename": "src/test/run-make/graphviz-flowgraph/f16.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff16.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -64,7 +64,7 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N8[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1is { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1is { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1is { break ; \\\"unreachable\\\"; }\\l        y -= 1is;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 1is { break ; \\\"unreachable\\\"; }\\l        y -= 1is;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 1is { break ; \\\"unreachable\\\"; }\\l            y -= 1is;\\l        }\\l    y -= 1is;\\l    x -= 1is;\\l}\\l\"];\n+    N15 -> N8;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n@@ -76,7 +76,7 @@ digraph block {\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N11[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y >= 1is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y >= 1is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 1is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l}\\l\"];\n+    N26 -> N11;\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;"}, {"sha": "46f1634416e5b8a0dddbf544c96cec6c3d7b6a5a", "filename": "src/test/run-make/graphviz-flowgraph/f21.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff21.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -59,7 +59,7 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N9[label=\"exiting scope_0 expr break \\'outer,\\lexiting scope_1 stmt break \\'outer ;,\\lexiting scope_2 block { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1is { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1is { break \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2is { return; \\\"unreachable\\\"; }\\l    y -= 3is;\\l    x -= 5is;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        y -= 3is;\\l        x -= 5is;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        y -= 3is;\\l        x -= 5is;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2is { return; \\\"unreachable\\\"; }\\l            y -= 3is;\\l            x -= 5is;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N15 -> N9;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n@@ -71,7 +71,7 @@ digraph block {\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        y -= 3is;\\l        x -= 5is;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1is { break \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2is { return; \\\"unreachable\\\"; }\\l                y -= 3is;\\l                x -= 5is;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N26 -> N1;\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;"}, {"sha": "3f35a9b0f9ab3b782a38df6c54c22d14e4461be4", "filename": "src/test/run-make/graphviz-flowgraph/f22.dot-expected.dot", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff22.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -62,7 +62,7 @@ digraph block {\n     N12 -> N13;\n     N13 -> N14;\n     N14 -> N15;\n-    N15 -> N8[label=\"exiting scope_0 expr continue \\'outer,\\lexiting scope_1 stmt continue \\'outer ;,\\lexiting scope_2 block { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 1is { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 1is { continue \\'outer ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l    if y >= 2is { return; \\\"unreachable\\\"; }\\l    x -= 1is;\\l    y -= 3is;\\l}\\l,\\lexiting scope_6 expr \\'inner:\\l    loop  {\\l        if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        x -= 1is;\\l        y -= 3is;\\l    }\\l,\\lexiting scope_7 stmt \\'inner:\\l    loop  {\\l        if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        x -= 1is;\\l        y -= 3is;\\l    }\\l,\\lexiting scope_8 block {\\l    \\'inner:\\l        loop  {\\l            if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l            if y >= 2is { return; \\\"unreachable\\\"; }\\l            x -= 1is;\\l            y -= 3is;\\l        }\\l    \\\"unreachable\\\";\\l}\\l\"];\n+    N15 -> N8;\n     N16 -> N17;\n     N17 -> N18;\n     N18 -> N19;\n@@ -74,7 +74,7 @@ digraph block {\n     N23 -> N24;\n     N24 -> N25;\n     N25 -> N26;\n-    N26 -> N1[label=\"exiting scope_0 expr \\'inner:\\l    loop  {\\l        if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l        if y >= 2is { return; \\\"unreachable\\\"; }\\l        x -= 1is;\\l        y -= 3is;\\l    }\\l,\\lexiting scope_1 expr \\'outer:\\l    loop  {\\l        \\'inner:\\l            loop  {\\l                if x == 1is { continue \\'outer ; \\\"unreachable\\\"; }\\l                if y >= 2is { return; \\\"unreachable\\\"; }\\l                x -= 1is;\\l                y -= 3is;\\l            }\\l        \\\"unreachable\\\";\\l    }\\l\"];\n+    N26 -> N1;\n     N27 -> N28;\n     N28 -> N29;\n     N29 -> N30;"}, {"sha": "c9f7d4cdf0aabf3019b1478481a1ab559eca6837", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -95,7 +95,7 @@ digraph block {\n     N40 -> N41;\n     N41 -> N42;\n     N42 -> N43;\n-    N43 -> N1[label=\"exiting scope_0 expr while y > 0is {\\l    y -= 1is;\\l    while z > 0is { z -= 1is; }\\l    if x > 10is { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr while x > 0is {\\l    x -= 1is;\\l    while y > 0is {\\l        y -= 1is;\\l        while z > 0is { z -= 1is; }\\l        if x > 10is { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N43 -> N1;\n     N44 -> N45;\n     N45 -> N46;\n     N46 -> N47;"}, {"sha": "a5373bda39b188d881e7c00bd8f8775174dc6889", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -90,7 +90,7 @@ digraph block {\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N16;\n-    N16 -> N12[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0is { break ; \\\"unreachable\\\"; }\\l    x -= 1is;\\l    loop  {\\l        if y == 0is { break ; \\\"unreachable\\\"; }\\l        y -= 1is;\\l        loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l        if x > 10is { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N16 -> N12;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n@@ -107,7 +107,7 @@ digraph block {\n     N30 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N33 -> N29[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l    loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l    if x > 10is { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N33 -> N29;\n     N34 -> N35;\n     N35 -> N36;\n     N36 -> N37;\n@@ -124,7 +124,7 @@ digraph block {\n     N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N46[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\"];\n+    N50 -> N46;\n     N51 -> N52;\n     N52 -> N53;\n     N53 -> N54;\n@@ -143,7 +143,7 @@ digraph block {\n     N64 -> N65;\n     N65 -> N66;\n     N66 -> N67;\n-    N67 -> N1[label=\"exiting scope_0 expr loop  {\\l    if y == 0is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l    loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l    if x > 10is { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr loop  {\\l    if x == 0is { break ; \\\"unreachable\\\"; }\\l    x -= 1is;\\l    loop  {\\l        if y == 0is { break ; \\\"unreachable\\\"; }\\l        y -= 1is;\\l        loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l        if x > 10is { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N67 -> N1;\n     N68 -> N69;\n     N69 -> N70;\n     N70 -> N71;"}, {"sha": "2611219e816e950aeb35928b2e58f6790bd9556f", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -90,7 +90,7 @@ digraph block {\n     N13 -> N14;\n     N14 -> N15;\n     N15 -> N16;\n-    N16 -> N12[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0is { break ; \\\"unreachable\\\"; }\\l    x -= 1is;\\l    \\'a:\\l        loop  {\\l            if y == 0is { break ; \\\"unreachable\\\"; }\\l            y -= 1is;\\l            \\'a: loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l            if x > 10is { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n+    N16 -> N12;\n     N17 -> N18;\n     N18 -> N19;\n     N19 -> N20;\n@@ -107,7 +107,7 @@ digraph block {\n     N30 -> N31;\n     N31 -> N32;\n     N32 -> N33;\n-    N33 -> N29[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l    \\'a: loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l    if x > 10is { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N33 -> N29;\n     N34 -> N35;\n     N35 -> N36;\n     N36 -> N37;\n@@ -124,7 +124,7 @@ digraph block {\n     N47 -> N48;\n     N48 -> N49;\n     N49 -> N50;\n-    N50 -> N46[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0is { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\"];\n+    N50 -> N46;\n     N51 -> N52;\n     N52 -> N53;\n     N53 -> N54;\n@@ -143,7 +143,7 @@ digraph block {\n     N64 -> N65;\n     N65 -> N66;\n     N66 -> N67;\n-    N67 -> N28[label=\"exiting scope_0 expr continue \\'a,\\lexiting scope_1 stmt continue \\'a ;,\\lexiting scope_2 block { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x > 10is { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_4 block {\\l    if y == 0is { break ; \\\"unreachable\\\"; }\\l    y -= 1is;\\l    \\'a: loop  { if z == 0is { break ; \\\"unreachable\\\"; } z -= 1is; }\\l    if x > 10is { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N67 -> N28;\n     N68 -> N69;\n     N69 -> N70;\n     N70 -> N71;"}, {"sha": "365cbf93da203cc42ae2073e383d0d04589c7bff", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -51,7 +51,7 @@ endif\n \n # Extra flags needed to compile a working executable with the standard library\n ifdef IS_WINDOWS\n-\tEXTRACFLAGS :=\n+\tEXTRACFLAGS := -lws2_32\n else\n ifeq ($(shell uname),Darwin)\n else"}, {"sha": "c517f61de0c16d076ba2087c8dde81e891013c3c", "filename": "src/test/run-pass/associated-types-normalize-unifield-struct.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-unifield-struct.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #21010: Normalize associated types in\n+// various special paths in the `type_is_immediate` function.\n+\n+#![allow(unstable)]\n+\n+pub trait OffsetState: Sized {}\n+pub trait Offset { type State: OffsetState; }\n+\n+#[derive(Copy)] pub struct X;\n+impl Offset for X { type State = Y; }\n+\n+#[derive(Copy)] pub struct Y;\n+impl OffsetState for Y {}\n+\n+pub fn now() -> DateTime<X> { from_utc(Y) }\n+\n+pub struct DateTime<Off: Offset> { pub offset: Off::State }\n+pub fn from_utc<Off: Offset>(offset: Off::State) -> DateTime<Off> { DateTime { offset: offset } }\n+\n+pub fn main() {\n+    let _x = now();\n+}"}, {"sha": "44dd49b72976edc3aafd4b3d859844ef903f32ee", "filename": "src/test/run-pass/associated-types-projection-in-object-type.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-projection-in-object-type.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Corrected regression test for #20831. The original did not compile.\n+// When fixed, it revealed another problem concerning projections that\n+// appear in associated type bindings in object types, which were not\n+// being properly flagged.\n+\n+use std::ops::{Shl, Shr};\n+use std::cell::RefCell;\n+\n+pub trait Subscriber {\n+    type Input;\n+}\n+\n+pub trait Publisher<'a> {\n+    type Output;\n+    fn subscribe(&mut self, Box<Subscriber<Input=Self::Output> + 'a>);\n+}\n+\n+pub trait Processor<'a> : Subscriber + Publisher<'a> { }\n+\n+impl<'a, P> Processor<'a> for P where P : Subscriber + Publisher<'a> { }\n+\n+struct MyStruct<'a> {\n+    sub: Box<Subscriber<Input=u64> + 'a>\n+}\n+\n+impl<'a> Publisher<'a> for MyStruct<'a> {\n+    type Output = u64;\n+    fn subscribe(&mut self, t : Box<Subscriber<Input=u64> + 'a>) {\n+        self.sub = t;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f83150b95184b15167322500172257ba08346325", "filename": "src/test/run-pass/issue-20575.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-20575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-20575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20575.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that overloaded calls work with zero arity closures\n+\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let functions: [Box<Fn() -> Option<()>>; 1] = [box || None];\n+\n+    let _: Option<Vec<()>> = functions.iter().map(|f| (*f)()).collect();\n+}"}, {"sha": "fd99fc01a23d12810c88b6824274fa60637bcb1e", "filename": "src/test/run-pass/issue-20676.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-20676.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-20676.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20676.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #20676. Error was that we didn't support\n+// UFCS-style calls to a method in `Trait` where `Self` was bound to a\n+// trait object of type `Trait`. See also `ufcs-trait-object.rs`.\n+\n+use std::fmt;\n+\n+fn main() {\n+    let a: &fmt::Show = &1_i32;\n+    format!(\"{:?}\", a);\n+}"}, {"sha": "cbce577451faf94834d0cd35cfea55d7ebe40676", "filename": "src/test/run-pass/issue-21058.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21058.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unstable)]\n+\n+struct NT(str);\n+struct DST { a: u32, b: str }\n+\n+fn main() {\n+    // get_tydesc should support unsized types\n+    assert!(unsafe {(\n+        // Slice\n+        (*std::intrinsics::get_tydesc::<[u8]>()).name,\n+        // str\n+        (*std::intrinsics::get_tydesc::<str>()).name,\n+        // Trait\n+        (*std::intrinsics::get_tydesc::<Copy>()).name,\n+        // Newtype\n+        (*std::intrinsics::get_tydesc::<NT>()).name,\n+        // DST\n+        (*std::intrinsics::get_tydesc::<DST>()).name\n+    )} == (\"[u8]\", \"str\", \"core::marker::Copy + 'static\", \"NT\", \"DST\"));\n+}"}, {"sha": "b9d3ed49c625f6bb1376a2993c18d294e8d45883", "filename": "src/test/run-pass/regions-debruijn-of-object.rs", "status": "renamed", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fregions-debruijn-of-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fregions-debruijn-of-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-debruijn-of-object.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,3 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+struct ctxt<'tcx> {\n+    x: &'tcx i32\n+}\n+\n+trait AstConv<'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ctxt<'tcx>;\n+}\n+\n+fn foo(conv: &AstConv) { }\n+\n+fn bar<'tcx>(conv: &AstConv<'tcx>) {\n+    foo(conv)\n+}\n+\n+fn main() { }", "previous_filename": "src/librustc_driver/mod.rs"}, {"sha": "2ae63040d17850c373b507aeeea377fa03332a41", "filename": "src/test/run-pass/ufcs-trait-object.rs", "status": "renamed", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fufcs-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fufcs-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-trait-object.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,21 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-android: FIXME(#10381)\n-// min-lldb-version: 310\n+// Test that when you use ufcs form to invoke a trait method (on a\n+// trait object) everything works fine.\n \n-// compile-flags:-g\n+trait Foo {\n+    fn test(&self) -> i32;\n+}\n \n-struct Peekable<I> where I: Iterator {\n-    _iter: I,\n-    _next: Option<<I as Iterator>::Item>,\n+impl Foo for i32 {\n+    fn test(&self) -> i32 { *self }\n }\n \n fn main() {\n-    let mut iter = Vec::<i32>::new().into_iter();\n-    let next = iter.next();\n-    let _v = Peekable {\n-        _iter: iter,\n-        _next : next,\n-    };\n+    let a: &Foo = &22_i32;\n+    assert_eq!(Foo::test(a), 22);\n }", "previous_filename": "src/test/debuginfo/associated_types.rs"}, {"sha": "65882d39375c3f0f7638081205ac594b6712c109", "filename": "src/test/run-pass/zero_sized_subslice_match.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b565501ad8b4e371e0aca0069c3f4781bd209254/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs?ref=b565501ad8b4e371e0aca0069c3f4781bd209254", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = [(), ()];\n+\n+    // The subslice used to go out of bounds for zero-sized array items, check that this doesn't\n+    // happen anymore\n+    match x {\n+        [_, y..] => assert_eq!(&x[1] as *const _, &y[0] as *const _)\n+    }\n+}"}]}