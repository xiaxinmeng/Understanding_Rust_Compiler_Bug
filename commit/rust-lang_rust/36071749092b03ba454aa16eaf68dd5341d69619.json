{"sha": "36071749092b03ba454aa16eaf68dd5341d69619", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MDcxNzQ5MDkyYjAzYmE0NTRhYTE2ZWFmNjhkZDUzNDFkNjk2MTk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-02T15:36:30Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-06-09T13:03:34Z"}, "message": "incr.comp.: Uniformly represent DepNodes as (Kind, StableHash) pairs.", "tree": {"sha": "d44f15a107836d807135d280bc8f694372c5da02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44f15a107836d807135d280bc8f694372c5da02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36071749092b03ba454aa16eaf68dd5341d69619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36071749092b03ba454aa16eaf68dd5341d69619", "html_url": "https://github.com/rust-lang/rust/commit/36071749092b03ba454aa16eaf68dd5341d69619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36071749092b03ba454aa16eaf68dd5341d69619/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7ac71b97899f1fac87a70c87a2b98e46877918b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ac71b97899f1fac87a70c87a2b98e46877918b", "html_url": "https://github.com/rust-lang/rust/commit/a7ac71b97899f1fac87a70c87a2b98e46877918b"}], "stats": {"total": 1585, "additions": 864, "deletions": 721}, "files": [{"sha": "e22552008d5a8578079cf7fd3955081ec715c006", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -12,7 +12,6 @@\n \n use super::dep_node::DepNode;\n use std::error::Error;\n-use std::fmt::Debug;\n \n /// A dep-node filter goes from a user-defined string to a query over\n /// nodes. Right now the format is like this:\n@@ -39,7 +38,7 @@ impl DepNodeFilter {\n     }\n \n     /// Tests whether `node` meets the filter, returning true if so.\n-    pub fn test<D: Clone + Debug>(&self, node: &DepNode<D>) -> bool {\n+    pub fn test(&self, node: &DepNode) -> bool {\n         let debug_str = format!(\"{:?}\", node);\n         self.text.split(\"&\")\n                  .map(|s| s.trim())\n@@ -67,10 +66,10 @@ impl EdgeFilter {\n         }\n     }\n \n-    pub fn test<D: Clone + Debug>(&self,\n-                                  source: &DepNode<D>,\n-                                  target: &DepNode<D>)\n-                                  -> bool {\n+    pub fn test(&self,\n+                source: &DepNode,\n+                target: &DepNode)\n+                -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "5f3dd9052034f837483a427bf0d9e6a2b86bb660", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 373, "deletions": 252, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,79 +8,280 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::CrateNum;\n+use hir::def_id::{CrateNum, DefId};\n+use hir::map::DefPathHash;\n+\n use ich::Fingerprint;\n-use rustc_data_structures::stable_hasher::StableHasher;\n-use std::fmt::Debug;\n+use ty::TyCtxt;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use ich::StableHashingContext;\n use std::hash::Hash;\n \n-macro_rules! try_opt {\n-    ($e:expr) => (\n-        match $e {\n-            Some(r) => r,\n-            None => return None,\n+// erase!() just makes tokens go away. It's used to specify which macro argument\n+// is repeated (i.e. which sub-expression of the macro we are in) but don't need\n+// to actually use any of the arguments.\n+macro_rules! erase {\n+    ($x:tt) => ({})\n+}\n+\n+macro_rules! define_dep_nodes {\n+    ($(\n+        $variant:ident $(( $($tuple_arg:tt),* ))*\n+                       $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n+      ),*\n+    ) => (\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub enum DepKind {\n+            $($variant),*\n+        }\n+\n+        impl DepKind {\n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn can_reconstruct_query_key(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            // tuple args\n+                            $({\n+                                return <( $($tuple_arg,)* ) as DepNodeParams>\n+                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                return <( $($struct_arg_ty,)* ) as DepNodeParams>\n+                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                            })*\n+\n+                            true\n+                        }\n+                    )*\n+                }\n+            }\n+\n+            #[allow(unreachable_code)]\n+            #[inline]\n+            pub fn has_params(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            // tuple args\n+                            $({\n+                                $(erase!($tuple_arg);)*\n+                                return true;\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                $(erase!($struct_arg_name);)*\n+                                return true;\n+                            })*\n+\n+                            false\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+\n+        pub enum DepConstructor {\n+            $(\n+                $variant $(( $($tuple_arg),* ))*\n+                         $({ $($struct_arg_name : $struct_arg_ty),* })*\n+            ),*\n+        }\n+\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub struct DepNode {\n+            pub kind: DepKind,\n+            pub hash: Fingerprint,\n+        }\n+\n+        impl DepNode {\n+            #[allow(unreachable_code, non_snake_case)]\n+            pub fn new(tcx: TyCtxt, dep: DepConstructor) -> DepNode {\n+                match dep {\n+                    $(\n+                        DepConstructor :: $variant $(( $($tuple_arg),* ))*\n+                                                   $({ $($struct_arg_name),* })*\n+                            =>\n+                        {\n+                            // tuple args\n+                            $({\n+                                let tupled_args = ( $($tuple_arg,)* );\n+                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n+                                                                         tcx);\n+                                return DepNode {\n+                                    kind: DepKind::$variant,\n+                                    hash\n+                                };\n+                            })*\n+\n+                            // struct args\n+                            $({\n+                                let tupled_args = ( $($struct_arg_name,)* );\n+                                let hash = DepNodeParams::to_fingerprint(&tupled_args,\n+                                                                         tcx);\n+                                return DepNode {\n+                                    kind: DepKind::$variant,\n+                                    hash\n+                                };\n+                            })*\n+\n+                            DepNode {\n+                                kind: DepKind::$variant,\n+                                hash: Fingerprint::zero(),\n+                            }\n+                        }\n+                    )*\n+                }\n+            }\n+\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            #[inline]\n+            pub fn from_def_path_hash(kind: DepKind,\n+                                      def_path_hash: DefPathHash)\n+                                      -> DepNode {\n+                assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: def_path_hash.0,\n+                }\n+            }\n+\n+            /// Create a new, parameterless DepNode. This method will assert\n+            /// that the DepNode corresponding to the given DepKind actually\n+            /// does not require any parameters.\n+            #[inline]\n+            pub fn new_no_params(kind: DepKind) -> DepNode {\n+                assert!(!kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: Fingerprint::zero(),\n+                }\n+            }\n+\n+            /// Extract the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            #[inline]\n+            pub fn extract_def_id(&self, tcx: TyCtxt) -> Option<DefId> {\n+                if self.kind.can_reconstruct_query_key() {\n+                    let def_path_hash = DefPathHash(self.hash);\n+                    tcx.def_path_hash_to_def_id\n+                       .as_ref()\n+                       .unwrap()\n+                       .get(&def_path_hash)\n+                       .cloned()\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            /// Used in testing\n+            pub fn from_label_string(label: &str,\n+                                     def_path_hash: DefPathHash)\n+                                     -> Result<DepNode, ()> {\n+                let kind = match label {\n+                    $(\n+                        stringify!($variant) => DepKind::$variant,\n+                    )*\n+                    _ => return Err(()),\n+                };\n+\n+                if !kind.can_reconstruct_query_key() {\n+                    return Err(());\n+                }\n+\n+                if kind.has_params() {\n+                    Ok(def_path_hash.to_dep_node(kind))\n+                } else {\n+                    Ok(DepNode::new_no_params(kind))\n+                }\n+            }\n         }\n-    )\n+    );\n+}\n+\n+impl DefPathHash {\n+    #[inline]\n+    pub fn to_dep_node(self, kind: DepKind) -> DepNode {\n+        DepNode::from_def_path_hash(kind, self)\n+    }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub enum DepNode<D: Clone + Debug> {\n-    // The `D` type is \"how definitions are identified\".\n-    // During compilation, it is always `DefId`, but when serializing\n-    // it is mapped to `DefPath`.\n-\n-    /// Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    /// distinct from the krate module). This is basically a hash of\n-    /// the entire krate, so if you read from `Krate` (e.g., by calling\n-    /// `tcx.hir.krate()`), we will have to assume that any change\n-    /// means that you need to be recompiled. This is because the\n-    /// `Krate` value gives you access to all other items. To avoid\n-    /// this fate, do not call `tcx.hir.krate()`; instead, prefer\n-    /// wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    /// suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    /// access to the krate, but you must remember to add suitable\n-    /// edges yourself for the individual items that you read.\n+impl DefId {\n+    #[inline]\n+    pub fn to_dep_node(self, tcx: TyCtxt, kind: DepKind) -> DepNode {\n+        DepNode::from_def_path_hash(kind, tcx.def_path_hash(self))\n+    }\n+}\n+\n+define_dep_nodes!(\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.hir.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.hir.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n     Krate,\n \n-    /// Represents the HIR node with the given node-id\n-    Hir(D),\n+    // Represents the HIR node with the given node-id\n+    Hir(DefId),\n \n-    /// Represents the body of a function or method. The def-id is that of the\n-    /// function/method.\n-    HirBody(D),\n+    // Represents the body of a function or method. The def-id is that of the\n+    // function/method.\n+    HirBody(DefId),\n \n-    /// Represents the metadata for a given HIR node, typically found\n-    /// in an extern crate.\n-    MetaData(D),\n+    // Represents the metadata for a given HIR node, typically found\n+    // in an extern crate.\n+    MetaData(DefId),\n \n-    /// Represents some artifact that we save to disk. Note that these\n-    /// do not have a def-id as part of their identifier.\n+    // Represents some artifact that we save to disk. Note that these\n+    // do not have a def-id as part of their identifier.\n     WorkProduct(WorkProductId),\n \n     // Represents different phases in the compiler.\n-    RegionMaps(D),\n+    RegionMaps(DefId),\n     Coherence,\n     Resolve,\n-    CoherenceCheckTrait(D),\n-    CoherenceCheckImpl(D),\n-    CoherenceOverlapCheck(D),\n-    CoherenceOverlapCheckSpecial(D),\n+    CoherenceCheckTrait(DefId),\n+    CoherenceCheckImpl(DefId),\n+    CoherenceOverlapCheck(DefId),\n+    CoherenceOverlapCheckSpecial(DefId),\n     Variance,\n     PrivacyAccessLevels(CrateNum),\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n     MirKrate,\n-    Mir(D),\n-    MirShim(Vec<D>),\n+    Mir(DefId),\n+    MirShim(DefIdList),\n \n     BorrowCheckKrate,\n-    BorrowCheck(D),\n-    RvalueCheck(D),\n+    BorrowCheck(DefId),\n+    RvalueCheck(DefId),\n     Reachability,\n     MirKeys,\n     LateLintCheck,\n-    TransCrateItem(D),\n+    TransCrateItem(DefId),\n     TransWriteMetadata,\n     CrateVariances,\n \n@@ -89,38 +290,38 @@ pub enum DepNode<D: Clone + Debug> {\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n     // predicates for an item wind up in `ItemSignature`).\n-    AssociatedItems(D),\n-    ItemSignature(D),\n-    ItemVarianceConstraints(D),\n-    ItemVariances(D),\n-    IsForeignItem(D),\n-    TypeParamPredicates((D, D)),\n-    SizedConstraint(D),\n-    DtorckConstraint(D),\n-    AdtDestructor(D),\n-    AssociatedItemDefIds(D),\n-    InherentImpls(D),\n+    AssociatedItems(DefId),\n+    ItemSignature(DefId),\n+    ItemVarianceConstraints(DefId),\n+    ItemVariances(DefId),\n+    IsForeignItem(DefId),\n+    TypeParamPredicates { item_id: DefId, param_id: DefId },\n+    SizedConstraint(DefId),\n+    DtorckConstraint(DefId),\n+    AdtDestructor(DefId),\n+    AssociatedItemDefIds(DefId),\n+    InherentImpls(DefId),\n     TypeckBodiesKrate,\n-    TypeckTables(D),\n-    UsedTraitImports(D),\n-    ConstEval(D),\n-    SymbolName(D),\n-    SpecializationGraph(D),\n-    ObjectSafety(D),\n-    IsCopy(D),\n-    IsSized(D),\n-    IsFreeze(D),\n-    NeedsDrop(D),\n-    Layout(D),\n-\n-    /// The set of impls for a given trait. Ultimately, it would be\n-    /// nice to get more fine-grained here (e.g., to include a\n-    /// simplified type), but we can't do that until we restructure the\n-    /// HIR to distinguish the *header* of an impl from its body.  This\n-    /// is because changes to the header may change the self-type of\n-    /// the impl and hence would require us to be more conservative\n-    /// than changes in the impl body.\n-    TraitImpls(D),\n+    TypeckTables(DefId),\n+    UsedTraitImports(DefId),\n+    ConstEval(DefId),\n+    SymbolName(DefId),\n+    SpecializationGraph(DefId),\n+    ObjectSafety(DefId),\n+    IsCopy(DefId),\n+    IsSized(DefId),\n+    IsFreeze(DefId),\n+    NeedsDrop(DefId),\n+    Layout(DefId),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(DefId),\n \n     AllLocalTraitImpls,\n \n@@ -129,184 +330,80 @@ pub enum DepNode<D: Clone + Debug> {\n     // Otherwise the write into the map would be incorrectly\n     // attributed to the first task that happened to fill the cache,\n     // which would yield an overly conservative dep-graph.\n-    TraitItems(D),\n-    ReprHints(D),\n-\n-    /// Trait selection cache is a little funny. Given a trait\n-    /// reference like `Foo: SomeTrait<Bar>`, there could be\n-    /// arbitrarily many def-ids to map on in there (e.g., `Foo`,\n-    /// `SomeTrait`, `Bar`). We could have a vector of them, but it\n-    /// requires heap-allocation, and trait sel in general can be a\n-    /// surprisingly hot path. So instead we pick two def-ids: the\n-    /// trait def-id, and the first def-id in the input types. If there\n-    /// is no def-id in the input types, then we use the trait def-id\n-    /// again. So for example:\n-    ///\n-    /// - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n-    /// - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n-    /// - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n-    /// - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    /// - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n-    ///\n-    /// You can see that we map many trait refs to the same\n-    /// trait-select node.  This is not a problem, it just means\n-    /// imprecision in our dep-graph tracking.  The important thing is\n-    /// that for any given trait-ref, we always map to the **same**\n-    /// trait-select node.\n-    TraitSelect { trait_def_id: D, input_def_id: D },\n-\n-    /// For proj. cache, we just keep a list of all def-ids, since it is\n-    /// not a hotspot.\n-    ProjectionCache { def_ids: Vec<D> },\n-\n-    ParamEnv(D),\n-    DescribeDef(D),\n-    DefSpan(D),\n-    Stability(D),\n-    Deprecation(D),\n-    ItemBodyNestedBodies(D),\n-    ConstIsRvaluePromotableToStatic(D),\n-    ImplParent(D),\n-    TraitOfItem(D),\n-    IsExportedSymbol(D),\n-    IsMirAvailable(D),\n-    ItemAttrs(D),\n-    FnArgNames(D),\n+    TraitItems(DefId),\n+    ReprHints(DefId),\n+\n+    // Trait selection cache is a little funny. Given a trait\n+    // reference like `Foo: SomeTrait<Bar>`, there could be\n+    // arbitrarily many def-ids to map on in there (e.g., `Foo`,\n+    // `SomeTrait`, `Bar`). We could have a vector of them, but it\n+    // requires heap-allocation, and trait sel in general can be a\n+    // surprisingly hot path. So instead we pick two def-ids: the\n+    // trait def-id, and the first def-id in the input types. If there\n+    // is no def-id in the input types, then we use the trait def-id\n+    // again. So for example:\n+    //\n+    // - `i32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `u32: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Clone: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Clone }`\n+    // - `Vec<i32>: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: Vec }`\n+    // - `String: Clone` -> `TraitSelect { trait_def_id: Clone, self_def_id: String }`\n+    // - `Foo: Trait<Bar>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `Foo: Trait<i32>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `(Foo, Bar): Trait` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    // - `i32: Trait<Foo>` -> `TraitSelect { trait_def_id: Trait, self_def_id: Foo }`\n+    //\n+    // You can see that we map many trait refs to the same\n+    // trait-select node.  This is not a problem, it just means\n+    // imprecision in our dep-graph tracking.  The important thing is\n+    // that for any given trait-ref, we always map to the **same**\n+    // trait-select node.\n+    TraitSelect { trait_def_id: DefId, input_def_id: DefId },\n+\n+    // For proj. cache, we just keep a list of all def-ids, since it is\n+    // not a hotspot.\n+    ProjectionCache { def_ids: DefIdList },\n+\n+    ParamEnv(DefId),\n+    DescribeDef(DefId),\n+    DefSpan(DefId),\n+    Stability(DefId),\n+    Deprecation(DefId),\n+    ItemBodyNestedBodies(DefId),\n+    ConstIsRvaluePromotableToStatic(DefId),\n+    ImplParent(DefId),\n+    TraitOfItem(DefId),\n+    IsExportedSymbol(DefId),\n+    IsMirAvailable(DefId),\n+    ItemAttrs(DefId),\n+    FnArgNames(DefId)\n+);\n+\n+trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+    fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint;\n }\n \n-impl<D: Clone + Debug> DepNode<D> {\n-    /// Used in testing\n-    pub fn from_label_string(label: &str, data: D) -> Result<DepNode<D>, ()> {\n-        macro_rules! check {\n-            ($($name:ident,)*) => {\n-                match label {\n-                    $(stringify!($name) => Ok(DepNode::$name(data)),)*\n-                    _ => Err(())\n-                }\n-            }\n-        }\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+{\n+    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n-        if label == \"Krate\" {\n-            // special case\n-            return Ok(DepNode::Krate);\n-        }\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n+        let mut hcx = StableHashingContext::new(tcx);\n+        let mut hasher = StableHasher::new();\n \n-        check! {\n-            BorrowCheck,\n-            Hir,\n-            HirBody,\n-            TransCrateItem,\n-            AssociatedItems,\n-            ItemSignature,\n-            ItemVariances,\n-            IsForeignItem,\n-            AssociatedItemDefIds,\n-            InherentImpls,\n-            TypeckTables,\n-            UsedTraitImports,\n-            TraitImpls,\n-            ReprHints,\n-        }\n+        self.hash_stable(&mut hcx, &mut hasher);\n+\n+        hasher.finish()\n     }\n+}\n \n-    pub fn map_def<E, OP>(&self, mut op: OP) -> Option<DepNode<E>>\n-        where OP: FnMut(&D) -> Option<E>, E: Clone + Debug\n-    {\n-        use self::DepNode::*;\n-\n-        match *self {\n-            Krate => Some(Krate),\n-            BorrowCheckKrate => Some(BorrowCheckKrate),\n-            MirKrate => Some(MirKrate),\n-            TypeckBodiesKrate => Some(TypeckBodiesKrate),\n-            Coherence => Some(Coherence),\n-            CrateVariances => Some(CrateVariances),\n-            Resolve => Some(Resolve),\n-            Variance => Some(Variance),\n-            PrivacyAccessLevels(k) => Some(PrivacyAccessLevels(k)),\n-            Reachability => Some(Reachability),\n-            MirKeys => Some(MirKeys),\n-            LateLintCheck => Some(LateLintCheck),\n-            TransWriteMetadata => Some(TransWriteMetadata),\n-\n-            // work product names do not need to be mapped, because\n-            // they are always absolute.\n-            WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n-\n-            IsCopy(ref d) => op(d).map(IsCopy),\n-            IsSized(ref d) => op(d).map(IsSized),\n-            IsFreeze(ref d) => op(d).map(IsFreeze),\n-            NeedsDrop(ref d) => op(d).map(NeedsDrop),\n-            Layout(ref d) => op(d).map(Layout),\n-            Hir(ref d) => op(d).map(Hir),\n-            HirBody(ref d) => op(d).map(HirBody),\n-            MetaData(ref d) => op(d).map(MetaData),\n-            CoherenceCheckTrait(ref d) => op(d).map(CoherenceCheckTrait),\n-            CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n-            CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n-            CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n-            Mir(ref d) => op(d).map(Mir),\n-            MirShim(ref def_ids) => {\n-                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n-                def_ids.map(MirShim)\n-            }\n-            BorrowCheck(ref d) => op(d).map(BorrowCheck),\n-            RegionMaps(ref d) => op(d).map(RegionMaps),\n-            RvalueCheck(ref d) => op(d).map(RvalueCheck),\n-            TransCrateItem(ref d) => op(d).map(TransCrateItem),\n-            AssociatedItems(ref d) => op(d).map(AssociatedItems),\n-            ItemSignature(ref d) => op(d).map(ItemSignature),\n-            ItemVariances(ref d) => op(d).map(ItemVariances),\n-            ItemVarianceConstraints(ref d) => op(d).map(ItemVarianceConstraints),\n-            IsForeignItem(ref d) => op(d).map(IsForeignItem),\n-            TypeParamPredicates((ref item, ref param)) => {\n-                Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n-            }\n-            SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            DtorckConstraint(ref d) => op(d).map(DtorckConstraint),\n-            AdtDestructor(ref d) => op(d).map(AdtDestructor),\n-            AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n-            InherentImpls(ref d) => op(d).map(InherentImpls),\n-            TypeckTables(ref d) => op(d).map(TypeckTables),\n-            UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n-            ConstEval(ref d) => op(d).map(ConstEval),\n-            SymbolName(ref d) => op(d).map(SymbolName),\n-            SpecializationGraph(ref d) => op(d).map(SpecializationGraph),\n-            ObjectSafety(ref d) => op(d).map(ObjectSafety),\n-            TraitImpls(ref d) => op(d).map(TraitImpls),\n-            AllLocalTraitImpls => Some(AllLocalTraitImpls),\n-            TraitItems(ref d) => op(d).map(TraitItems),\n-            ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect { ref trait_def_id, ref input_def_id } => {\n-                op(trait_def_id).and_then(|trait_def_id| {\n-                    op(input_def_id).and_then(|input_def_id| {\n-                        Some(TraitSelect { trait_def_id: trait_def_id,\n-                                           input_def_id: input_def_id })\n-                    })\n-                })\n-            }\n-            ProjectionCache { ref def_ids } => {\n-                let def_ids: Option<Vec<E>> = def_ids.iter().map(op).collect();\n-                def_ids.map(|d| ProjectionCache { def_ids: d })\n-            }\n-            ParamEnv(ref d) => op(d).map(ParamEnv),\n-            DescribeDef(ref d) => op(d).map(DescribeDef),\n-            DefSpan(ref d) => op(d).map(DefSpan),\n-            Stability(ref d) => op(d).map(Stability),\n-            Deprecation(ref d) => op(d).map(Deprecation),\n-            ItemAttrs(ref d) => op(d).map(ItemAttrs),\n-            FnArgNames(ref d) => op(d).map(FnArgNames),\n-            ImplParent(ref d) => op(d).map(ImplParent),\n-            TraitOfItem(ref d) => op(d).map(TraitOfItem),\n-            IsExportedSymbol(ref d) => op(d).map(IsExportedSymbol),\n-            ItemBodyNestedBodies(ref d) => op(d).map(ItemBodyNestedBodies),\n-            ConstIsRvaluePromotableToStatic(ref d) => op(d).map(ConstIsRvaluePromotableToStatic),\n-            IsMirAvailable(ref d) => op(d).map(IsMirAvailable),\n-        }\n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        tcx.def_path_hash(self.0).0\n     }\n }\n \n@@ -315,14 +412,38 @@ impl<D: Clone + Debug> DepNode<D> {\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct WorkProductId(pub Fingerprint);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+         RustcEncodable, RustcDecodable)]\n+pub struct WorkProductId {\n+    hash: Fingerprint\n+}\n \n impl WorkProductId {\n     pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n         let mut hasher = StableHasher::new();\n         cgu_name.len().hash(&mut hasher);\n         cgu_name.hash(&mut hasher);\n-        WorkProductId(hasher.finish())\n+        WorkProductId {\n+            hash: hasher.finish()\n+        }\n+    }\n+\n+    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n+        WorkProductId {\n+            hash: fingerprint\n+        }\n+    }\n+\n+    pub fn to_dep_node(self) -> DepNode {\n+        DepNode {\n+            kind: DepKind::WorkProduct,\n+            hash: self.hash,\n+        }\n     }\n }\n+\n+impl_stable_hash_for!(struct ::dep_graph::WorkProductId {\n+    hash\n+});\n+\n+type DefIdList = Vec<DefId>;"}, {"sha": "43f8d6b938dab68ef582571879e817a87c0079a3", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n-use std::ops::Index;\n use std::hash::Hash;\n use std::marker::PhantomData;\n+use ty::TyCtxt;\n use util::common::MemoizationMap;\n \n use super::{DepNode, DepGraph};\n@@ -30,7 +29,7 @@ pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId>;\n+    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode;\n }\n \n impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n@@ -44,18 +43,18 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n \n     /// Registers a (synthetic) read from the key `k`. Usually this\n     /// is invoked automatically by `get`.\n-    fn read(&self, k: &M::Key) {\n-        let dep_node = M::to_dep_node(k);\n+    fn read(&self, tcx: TyCtxt, k: &M::Key) {\n+        let dep_node = M::to_dep_node(tcx, k);\n         self.graph.read(dep_node);\n     }\n \n-    pub fn get(&self, k: &M::Key) -> Option<&M::Value> {\n-        self.read(k);\n+    pub fn get(&self, tcx: TyCtxt, k: &M::Key) -> Option<&M::Value> {\n+        self.read(tcx, k);\n         self.map.get(k)\n     }\n \n-    pub fn contains_key(&self, k: &M::Key) -> bool {\n-        self.read(k);\n+    pub fn contains_key(&self, tcx: TyCtxt, k: &M::Key) -> bool {\n+        self.read(tcx, k);\n         self.map.contains_key(k)\n     }\n \n@@ -99,32 +98,22 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// The key is the line marked `(*)`: the closure implicitly\n     /// accesses the body of the item `item`, so we register a read\n     /// from `Hir(item_def_id)`.\n-    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n+    fn memoize<OP>(&self, tcx: TyCtxt, key: M::Key, op: OP) -> M::Value\n         where OP: FnOnce() -> M::Value\n     {\n         let graph;\n         {\n             let this = self.borrow();\n             if let Some(result) = this.map.get(&key) {\n-                this.read(&key);\n+                this.read(tcx, &key);\n                 return result.clone();\n             }\n             graph = this.graph.clone();\n         }\n \n-        let _task = graph.in_task(M::to_dep_node(&key));\n+        let _task = graph.in_task(M::to_dep_node(tcx, &key));\n         let result = op();\n         self.borrow_mut().map.insert(key, result.clone());\n         result\n     }\n }\n-\n-impl<'k, M: DepTrackingMapConfig> Index<&'k M::Key> for DepTrackingMap<M> {\n-    type Output = M::Value;\n-\n-    #[inline]\n-    fn index(&self, k: &'k M::Key) -> &M::Value {\n-        self.get(k).unwrap()\n-    }\n-}\n-"}, {"sha": "a323e44d0d4271537dd56d7c25c88784fdf1a1ce", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -9,13 +9,11 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::fmt::Debug;\n-use std::hash::Hash;\n use super::{DepGraphQuery, DepNode};\n \n-pub struct DepGraphEdges<D: Clone + Debug + Eq + Hash> {\n-    nodes: Vec<DepNode<D>>,\n-    indices: FxHashMap<DepNode<D>, IdIndex>,\n+pub struct DepGraphEdges {\n+    nodes: Vec<DepNode>,\n+    indices: FxHashMap<DepNode, IdIndex>,\n     edges: FxHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n }\n@@ -42,8 +40,8 @@ enum OpenNode {\n     Ignore,\n }\n \n-impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n-    pub fn new() -> DepGraphEdges<D> {\n+impl DepGraphEdges {\n+    pub fn new() -> DepGraphEdges {\n         DepGraphEdges {\n             nodes: vec![],\n             indices: FxHashMap(),\n@@ -52,12 +50,12 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> DepNode<D> {\n+    fn id(&self, index: IdIndex) -> DepNode {\n         self.nodes[index.index()].clone()\n     }\n \n     /// Creates a node for `id` in the graph.\n-    fn make_node(&mut self, id: DepNode<D>) -> IdIndex {\n+    fn make_node(&mut self, id: DepNode) -> IdIndex {\n         if let Some(&i) = self.indices.get(&id) {\n             return i;\n         }\n@@ -82,7 +80,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         assert_eq!(popped_node, OpenNode::Ignore);\n     }\n \n-    pub fn push_task(&mut self, key: DepNode<D>) {\n+    pub fn push_task(&mut self, key: DepNode) {\n         let top_node = self.current_node();\n \n         let new_node = self.make_node(key);\n@@ -95,7 +93,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    pub fn pop_task(&mut self, key: DepNode<D>) {\n+    pub fn pop_task(&mut self, key: DepNode) {\n         let popped_node = self.open_nodes.pop().unwrap();\n         assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n     }\n@@ -105,7 +103,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     /// effect. Note that *reading* from tracked state is harmless if\n     /// you are not in a task; what is bad is *writing* to tracked\n     /// state (and leaking data that you read into a tracked task).\n-    pub fn read(&mut self, v: DepNode<D>) {\n+    pub fn read(&mut self, v: DepNode) {\n         if self.current_node().is_some() {\n             let source = self.make_node(v);\n             self.add_edge_from_current_node(|current| (source, current))\n@@ -115,7 +113,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n     /// Indicates that the current task `C` writes `v` by adding an\n     /// edge from `C` to `v`. If there is no current task, panics. If\n     /// you want to suppress this edge, use `ignore`.\n-    pub fn write(&mut self, v: DepNode<D>) {\n+    pub fn write(&mut self, v: DepNode) {\n         let target = self.make_node(v);\n         self.add_edge_from_current_node(|current| (current, target))\n     }\n@@ -159,7 +157,7 @@ impl<D: Clone + Debug + Eq + Hash> DepGraphEdges<D> {\n         }\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<D> {\n+    pub fn query(&self) -> DepGraphQuery {\n         let edges: Vec<_> = self.edges.iter()\n                                       .map(|&(i, j)| (self.id(i), self.id(j)))\n                                       .collect();"}, {"sha": "6afd31bfe92df4a20fb3e956164a2fd5d903ac54", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n@@ -57,15 +56,15 @@ impl DepGraph {\n         self.data.thread.is_fully_enabled()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<DefId> {\n+    pub fn query(&self) -> DepGraphQuery {\n         self.data.thread.query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n         raii::IgnoreTask::new(&self.data.thread)\n     }\n \n-    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> Option<raii::DepTask<'graph>> {\n+    pub fn in_task<'graph>(&'graph self, key: DepNode) -> Option<raii::DepTask<'graph>> {\n         raii::DepTask::new(&self.data.thread, key)\n     }\n \n@@ -103,14 +102,14 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [README]: README.md\n-    pub fn with_task<C, A, R>(&self, key: DepNode<DefId>, cx: C, arg: A, task: fn(C, A) -> R) -> R\n+    pub fn with_task<C, A, R>(&self, key: DepNode, cx: C, arg: A, task: fn(C, A) -> R) -> R\n         where C: DepGraphSafe, A: DepGraphSafe\n     {\n         let _task = self.in_task(key);\n         task(cx, arg)\n     }\n \n-    pub fn read(&self, v: DepNode<DefId>) {\n+    pub fn read(&self, v: DepNode) {\n         if self.data.thread.is_enqueue_enabled() {\n             self.data.thread.enqueue(DepMessage::Read(v));\n         }"}, {"sha": "92b05f6a6558ee8bf0678d3ce7b44f447e715286", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -28,3 +28,5 @@ pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n pub use self::raii::DepTask;\n+\n+pub use self::dep_node::{DepKind, DepConstructor};"}, {"sha": "116c527bf46d5430d7b88a1a8fff9cfef4df8598", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -10,20 +10,18 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Direction, INCOMING, Graph, NodeIndex, OUTGOING};\n-use std::fmt::Debug;\n-use std::hash::Hash;\n \n use super::DepNode;\n \n-pub struct DepGraphQuery<D: Clone + Debug + Hash + Eq> {\n-    pub graph: Graph<DepNode<D>, ()>,\n-    pub indices: FxHashMap<DepNode<D>, NodeIndex>,\n+pub struct DepGraphQuery {\n+    pub graph: Graph<DepNode, ()>,\n+    pub indices: FxHashMap<DepNode, NodeIndex>,\n }\n \n-impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n-    pub fn new(nodes: &[DepNode<D>],\n-               edges: &[(DepNode<D>, DepNode<D>)])\n-               -> DepGraphQuery<D> {\n+impl DepGraphQuery {\n+    pub fn new(nodes: &[DepNode],\n+               edges: &[(DepNode, DepNode)])\n+               -> DepGraphQuery {\n         let mut graph = Graph::new();\n         let mut indices = FxHashMap();\n         for node in nodes {\n@@ -43,18 +41,18 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n         }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode<D>) -> bool {\n+    pub fn contains_node(&self, node: &DepNode) -> bool {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<&DepNode<D>> {\n+    pub fn nodes(&self) -> Vec<&DepNode> {\n         self.graph.all_nodes()\n                   .iter()\n                   .map(|n| &n.data)\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(&DepNode<D>,&DepNode<D>)> {\n+    pub fn edges(&self) -> Vec<(&DepNode,&DepNode)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n@@ -63,7 +61,7 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n                   .collect()\n     }\n \n-    fn reachable_nodes(&self, node: &DepNode<D>, direction: Direction) -> Vec<&DepNode<D>> {\n+    fn reachable_nodes(&self, node: &DepNode, direction: Direction) -> Vec<&DepNode> {\n         if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction)\n                       .map(|s| self.graph.node_data(s))\n@@ -75,17 +73,17 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn transitive_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn transitive_predecessors(&self, node: &DepNode) -> Vec<&DepNode> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n+    pub fn immediate_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n                       .map(|s| self.graph.node_data(s))"}, {"sha": "b45f5de802714b1bc1e9518d334585b0f69e5749", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::DefId;\n use super::DepNode;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n pub struct DepTask<'graph> {\n     data: &'graph DepGraphThreadData,\n-    key: Option<DepNode<DefId>>,\n+    key: Option<DepNode>,\n }\n \n impl<'graph> DepTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode)\n                -> Option<DepTask<'graph>> {\n         if data.is_enqueue_enabled() {\n             data.enqueue(DepMessage::PushTask(key.clone()));"}, {"sha": "8808ea5948da8b46669b9b52759b83326db55a28", "filename": "src/librustc/dep_graph/shadow.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -26,7 +26,6 @@\n //! specify an edge filter to be applied to each edge as it is\n //! created.  See `./README.md` for details.\n \n-use hir::def_id::DefId;\n use std::cell::RefCell;\n use std::env;\n \n@@ -36,7 +35,7 @@ use super::debug::EdgeFilter;\n \n pub struct ShadowGraph {\n     // if you push None onto the stack, that corresponds to an Ignore\n-    stack: RefCell<Vec<Option<DepNode<DefId>>>>,\n+    stack: RefCell<Vec<Option<DepNode>>>,\n     forbidden_edge: Option<EdgeFilter>,\n }\n \n@@ -114,8 +113,8 @@ impl ShadowGraph {\n     }\n \n     fn check_edge(&self,\n-                  source: Option<Option<&DepNode<DefId>>>,\n-                  target: Option<Option<&DepNode<DefId>>>) {\n+                  source: Option<Option<&DepNode>>,\n+                  target: Option<Option<&DepNode>>) {\n         assert!(ENABLED);\n         match (source, target) {\n             // cannot happen, one side is always Some(Some(_))\n@@ -141,9 +140,9 @@ impl ShadowGraph {\n \n // Do a little juggling: we get back a reference to an option at the\n // top of the stack, convert it to an optional reference.\n-fn top<'s>(stack: &'s Vec<Option<DepNode<DefId>>>) -> Option<Option<&'s DepNode<DefId>>> {\n+fn top<'s>(stack: &'s Vec<Option<DepNode>>) -> Option<Option<&'s DepNode>> {\n     stack.last()\n-        .map(|n: &'s Option<DepNode<DefId>>| -> Option<&'s DepNode<DefId>> {\n+        .map(|n: &'s Option<DepNode>| -> Option<&'s DepNode> {\n             // (*)\n             // (*) type annotation just there to clarify what would\n             // otherwise be some *really* obscure code"}, {"sha": "ad0abfe26f45f7c6e6a78c9311e5e9dfa0faf71b", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -18,7 +18,6 @@\n //! to accumulate more messages. This way we only ever have two vectors\n //! allocated (and both have a fairly large capacity).\n \n-use hir::def_id::DefId;\n use rustc_data_structures::veccell::VecCell;\n use std::sync::mpsc::{self, Sender, Receiver};\n use std::thread;\n@@ -30,10 +29,10 @@ use super::shadow::ShadowGraph;\n \n #[derive(Debug)]\n pub enum DepMessage {\n-    Read(DepNode<DefId>),\n-    Write(DepNode<DefId>),\n-    PushTask(DepNode<DefId>),\n-    PopTask(DepNode<DefId>),\n+    Read(DepNode),\n+    Write(DepNode),\n+    PushTask(DepNode),\n+    PopTask(DepNode),\n     PushIgnore,\n     PopIgnore,\n     Query,\n@@ -63,7 +62,7 @@ pub struct DepGraphThreadData {\n     swap_out: Sender<Vec<DepMessage>>,\n \n     // where to receive query results\n-    query_in: Receiver<DepGraphQuery<DefId>>,\n+    query_in: Receiver<DepGraphQuery>,\n }\n \n const INITIAL_CAPACITY: usize = 2048;\n@@ -120,7 +119,7 @@ impl DepGraphThreadData {\n         self.swap_out.send(old_messages).unwrap();\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<DefId> {\n+    pub fn query(&self) -> DepGraphQuery {\n         assert!(self.is_fully_enabled(), \"should never query if not fully enabled\");\n         self.enqueue(DepMessage::Query);\n         self.swap();\n@@ -151,7 +150,7 @@ impl DepGraphThreadData {\n /// Definition of the depgraph thread.\n pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n             swap_out: Sender<Vec<DepMessage>>,\n-            query_out: Sender<DepGraphQuery<DefId>>) {\n+            query_out: Sender<DepGraphQuery>) {\n     let mut edges = DepGraphEdges::new();\n \n     // the compiler thread always expects a fresh buffer to be"}, {"sha": "a1875cd46a0cb85932408b67796861d2c989d3bb", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -15,7 +15,7 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode};\n+use dep_graph::{DepGraph, DepNode, DepKind};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n \n@@ -235,7 +235,7 @@ impl Forest {\n     }\n \n     pub fn krate<'hir>(&'hir self) -> &'hir Crate {\n-        self.dep_graph.read(DepNode::Krate);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n         &self.krate\n     }\n }\n@@ -280,7 +280,7 @@ impl<'hir> Map<'hir> {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n-    fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n+    fn dep_node(&self, id0: NodeId) -> DepNode {\n         let mut id = id0;\n         let mut last_expr = None;\n         loop {\n@@ -289,14 +289,16 @@ impl<'hir> Map<'hir> {\n                 EntryItem(..) |\n                 EntryTraitItem(..) |\n                 EntryImplItem(..) => {\n+                    let def_index = self.definitions.opt_def_index(id).unwrap();\n+                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+\n                     if let Some(last_id) = last_expr {\n                         // The body may have a separate dep node\n                         if entry.is_body_owner(last_id) {\n-                            let def_id = self.local_def_id(id);\n-                            return DepNode::HirBody(def_id);\n+                            return def_path_hash.to_dep_node(DepKind::HirBody);\n                         }\n                     }\n-                    return DepNode::Hir(self.local_def_id(id));\n+                    return def_path_hash.to_dep_node(DepKind::Hir);\n                 }\n \n                 EntryVariant(p, v) => {\n@@ -305,8 +307,9 @@ impl<'hir> Map<'hir> {\n                     if last_expr.is_some() {\n                         if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n                             // The enum parent holds both Hir and HirBody nodes.\n-                            let def_id = self.local_def_id(id);\n-                            return DepNode::HirBody(def_id);\n+                            let def_index = self.definitions.opt_def_index(id).unwrap();\n+                            let def_path_hash = self.definitions.def_path_hash(def_index);\n+                            return def_path_hash.to_dep_node(DepKind::HirBody);\n                         }\n                     }\n                 }\n@@ -331,16 +334,20 @@ impl<'hir> Map<'hir> {\n                 }\n \n                 RootCrate => {\n-                    return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n+                    let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n+                    return def_path_hash.to_dep_node(DepKind::Hir);\n                 }\n \n                 NotPresent =>\n                     // Some nodes, notably macro definitions, are not\n                     // present in the map for whatever reason, but\n                     // they *do* have def-ids. So if we encounter an\n                     // empty hole, check for that case.\n-                    return self.opt_local_def_id(id)\n-                               .map(|def_id| DepNode::Hir(def_id))\n+                    return self.definitions.opt_def_index(id)\n+                               .map(|def_index| {\n+                                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+                                    def_path_hash.to_dep_node(DepKind::Hir)\n+                                })\n                                .unwrap_or_else(|| {\n                                    bug!(\"Walking parents from `{}` \\\n                                          led to `NotPresent` at `{}`\",\n@@ -497,15 +504,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n-        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n-        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n+        self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n@@ -520,8 +527,9 @@ impl<'hir> Map<'hir> {\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n-        let crate_root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        self.dep_graph.read(DepNode::Hir(crate_root_def_id));\n+        let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n+\n+        self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n         &self.forest.krate.attrs\n     }\n \n@@ -754,11 +762,8 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_inlined_body(&self, def_id: DefId) -> Option<&'hir Body> {\n-        self.inlined_bodies.borrow().get(&def_id).map(|&body| {\n-            self.dep_graph.read(DepNode::MetaData(def_id));\n-            body\n-        })\n+    pub fn get_inlined_body_untracked(&self, def_id: DefId) -> Option<&'hir Body> {\n+        self.inlined_bodies.borrow().get(&def_id).cloned()\n     }\n \n     pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'hir Body {"}, {"sha": "06506e214ed398a4a87acf2e78a7fd9ff12cac3d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -25,7 +25,7 @@\n //! for all lint attributes.\n use self::TargetLint::*;\n \n-use dep_graph::DepNode;\n+use dep_graph::{DepNode, DepKind};\n use middle::privacy::AccessLevels;\n use ty::{self, TyCtxt};\n use session::{config, early_error, Session};\n@@ -1321,7 +1321,7 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n+    let _task = tcx.dep_graph.in_task(DepNode::new_no_params(DepKind::LateLintCheck));\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n "}, {"sha": "16ecc94b9476ab8a8969101e7c4a34e1f0c8aa46", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -183,7 +183,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot());\n \n-        if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+        let tcx = infcx.tcx;\n+\n+        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n             debug!(\"register_predicate_obligation: duplicate\");\n             return\n         }\n@@ -373,7 +375,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n-            if selcx.tcx().fulfilled_predicates.borrow().check_duplicate_trait(data) {\n+            let tcx = selcx.tcx();\n+            if tcx.fulfilled_predicates.borrow().check_duplicate_trait(tcx, data) {\n                 return Ok(Some(vec![]));\n             }\n \n@@ -607,22 +610,22 @@ impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n         }\n     }\n \n-    pub fn check_duplicate(&self, key: &ty::Predicate<'tcx>) -> bool {\n+    pub fn check_duplicate(&self, tcx: TyCtxt, key: &ty::Predicate<'tcx>) -> bool {\n         if let ty::Predicate::Trait(ref data) = *key {\n-            self.check_duplicate_trait(data)\n+            self.check_duplicate_trait(tcx, data)\n         } else {\n             false\n         }\n     }\n \n-    pub fn check_duplicate_trait(&self, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n+    pub fn check_duplicate_trait(&self, tcx: TyCtxt, data: &ty::PolyTraitPredicate<'tcx>) -> bool {\n         // For the global predicate registry, when we find a match, it\n         // may have been computed by some other task, so we want to\n         // add a read from the node corresponding to the predicate\n         // processing to make sure we get the transitive dependencies.\n         if self.set.contains(data) {\n             debug_assert!(data.is_global());\n-            self.dep_graph.read(data.dep_node());\n+            self.dep_graph.read(data.dep_node(tcx));\n             debug!(\"check_duplicate: global predicate `{:?}` already proved elsewhere\", data);\n \n             true"}, {"sha": "10710d963a0156731420bb942f34badff52ddd87", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -381,7 +381,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let tcx = self.tcx();\n-        let dep_node = obligation.predicate.dep_node();\n+        let dep_node = obligation.predicate.dep_node(tcx);\n         let _task = tcx.dep_graph.in_task(dep_node);\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n@@ -514,11 +514,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n \n+        let tcx = self.tcx();\n+\n         // Check the cache from the tcx of predicates that we know\n         // have been proven elsewhere. This cache only contains\n         // predicates that are global in scope and hence unaffected by\n         // the current environment.\n-        if self.tcx().fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+        if tcx.fulfilled_predicates.borrow().check_duplicate(tcx, &obligation.predicate) {\n             return EvaluatedToOk;\n         }\n "}, {"sha": "e3b7757ec5b724f4387eb7f19e1e1e85de064087", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -13,7 +13,8 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig,\n+                DepConstructor};\n use hir::def_id::DefId;\n use infer::TransNormalize;\n use std::cell::RefCell;\n@@ -40,7 +41,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         // Remove any references to regions; this helps improve caching.\n         let trait_ref = self.erase_regions(&trait_ref);\n \n-        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n+        self.trans_trait_caches.trait_cache.memoize(self, trait_ref, || {\n             debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n                    trait_ref, trait_ref.def_id());\n \n@@ -138,7 +139,7 @@ impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n         if !ty.has_projection_types() {\n             ty\n         } else {\n-            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n+            self.tcx.trans_trait_caches.project_cache.memoize(self.tcx, ty, || {\n                 debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n                 self.tcx.normalize_associated_type(&ty)\n             })\n@@ -170,8 +171,8 @@ pub struct TraitSelectionCache<'tcx> {\n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     type Key = ty::PolyTraitRef<'tcx>;\n     type Value = Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n-        key.to_poly_trait_predicate().dep_node()\n+    fn to_dep_node(tcx: TyCtxt, key: &ty::PolyTraitRef<'tcx>) -> DepNode {\n+        key.to_poly_trait_predicate().dep_node(tcx)\n     }\n }\n \n@@ -184,7 +185,7 @@ pub struct ProjectionCache<'gcx> {\n impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n     type Key = Ty<'gcx>;\n     type Value = Ty<'gcx>;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n+    fn to_dep_node(tcx: TyCtxt, key: &Self::Key) -> DepNode {\n         // Ideally, we'd just put `key` into the dep-node, but we\n         // can't put full types in there. So just collect up all the\n         // def-ids of structs/enums as well as any traits that we\n@@ -208,7 +209,7 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n                })\n                .collect();\n \n-        DepNode::ProjectionCache { def_ids: def_ids }\n+        DepNode::new(tcx, DepConstructor::ProjectionCache { def_ids: def_ids })\n     }\n }\n "}, {"sha": "76103148ec3e87e53f50a79f090b5b108239c317", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n+use dep_graph::DepConstructor;\n use hir::def_id::DefId;\n use ty::{self, Ty, TypeFoldable, Substs};\n use util::ppaux;\n@@ -60,7 +60,8 @@ impl<'tcx> InstanceDef<'tcx> {\n         tcx.get_attrs(self.def_id())\n     }\n \n-    pub(crate) fn dep_node(&self) -> DepNode<DefId> {\n+    pub //(crate)\n+     fn dep_node(&self) -> DepConstructor {\n         // HACK: def-id binning, project-style; someone replace this with\n         // real on-demand.\n         let ty = match self {\n@@ -69,7 +70,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => None\n         }.into_iter();\n \n-        DepNode::MirShim(\n+        DepConstructor::MirShim(\n             Some(self.def_id()).into_iter().chain(\n                 ty.flat_map(|t| t.walk()).flat_map(|t| match t.sty {\n                    ty::TyAdt(adt_def, _) => Some(adt_def.did),"}, {"sha": "162a734aa195b3318d0d877b315a170110305229", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepNode, DepTrackingMapConfig};\n+use dep_graph::{DepConstructor, DepNode, DepTrackingMapConfig};\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n@@ -524,10 +524,10 @@ macro_rules! define_maps {\n             type Value = $V;\n \n             #[allow(unused)]\n-            fn to_dep_node(key: &$K) -> DepNode<DefId> {\n-                use dep_graph::DepNode::*;\n+            fn to_dep_node(tcx: TyCtxt, key: &$K) -> DepNode {\n+                use dep_graph::DepConstructor::*;\n \n-                $node(*key)\n+                DepNode::new(tcx, $node(*key))\n             }\n         }\n         impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n@@ -554,7 +554,7 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n-                let _task = tcx.dep_graph.in_task(Self::to_dep_node(&key));\n+                let _task = tcx.dep_graph.in_task(Self::to_dep_node(tcx, &key));\n \n                 let result = tcx.cycle_check(span, Query::$name(key), || {\n                     let provider = tcx.maps.providers[key.map_crate()].$name;\n@@ -569,7 +569,7 @@ macro_rules! define_maps {\n                 // We register the `read` here, but not in `force`, since\n                 // `force` does not give access to the value produced (and thus\n                 // we actually don't read it).\n-                tcx.dep_graph.read(Self::to_dep_node(&key));\n+                tcx.dep_graph.read(Self::to_dep_node(tcx, &key));\n                 Self::try_get_with(tcx, span, key, Clone::clone)\n             }\n \n@@ -782,7 +782,7 @@ define_maps! { <'tcx>\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] type_param_predicates: TypeParamPredicates((DefId, DefId))\n+    [] type_param_predicates: type_param_predicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n     [] trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n@@ -931,74 +931,81 @@ define_maps! { <'tcx>\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n }\n \n-fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n-    DepNode::CoherenceCheckTrait(def_id)\n+fn type_param_predicates((item_id, param_id): (DefId, DefId)) -> DepConstructor {\n+    DepConstructor::TypeParamPredicates {\n+        item_id,\n+        param_id\n+    }\n+}\n+\n+fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepConstructor {\n+    DepConstructor::CoherenceCheckTrait(def_id)\n }\n \n-fn crate_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::Coherence\n+fn crate_inherent_impls_dep_node(_: CrateNum) -> DepConstructor {\n+    DepConstructor::Coherence\n }\n \n-fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::Reachability\n+fn reachability_dep_node(_: CrateNum) -> DepConstructor {\n+    DepConstructor::Reachability\n }\n \n-fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n+fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepConstructor {\n     instance.dep_node()\n }\n \n-fn symbol_name_dep_node(instance: ty::Instance) -> DepNode<DefId> {\n+fn symbol_name_dep_node(instance: ty::Instance) -> DepConstructor {\n     // symbol_name uses the substs only to traverse them to find the\n     // hash, and that does not create any new dep-nodes.\n-    DepNode::SymbolName(instance.def.def_id())\n+    DepConstructor::SymbolName(instance.def.def_id())\n }\n \n-fn typeck_item_bodies_dep_node(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::TypeckBodiesKrate\n+fn typeck_item_bodies_dep_node(_: CrateNum) -> DepConstructor {\n+    DepConstructor::TypeckBodiesKrate\n }\n \n-fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepNode<DefId> {\n-    DepNode::ConstEval(def_id)\n+fn const_eval_dep_node((def_id, _): (DefId, &Substs)) -> DepConstructor {\n+    DepConstructor::ConstEval(def_id)\n }\n \n-fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::MirKeys\n+fn mir_keys(_: CrateNum) -> DepConstructor {\n+    DepConstructor::MirKeys\n }\n \n-fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::CrateVariances\n+fn crate_variances(_: CrateNum) -> DepConstructor {\n+    DepConstructor::CrateVariances\n }\n \n-fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepNode<DefId> {\n-    DepNode::TraitImpls(def_id)\n+fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepConstructor {\n+    DepConstructor::TraitImpls(def_id)\n }\n \n-fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepNode::IsCopy(def_id)\n+    DepConstructor::IsCopy(def_id)\n }\n \n-fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepNode::IsSized(def_id)\n+    DepConstructor::IsSized(def_id)\n }\n \n-fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepNode::IsFreeze(def_id)\n+    DepConstructor::IsFreeze(def_id)\n }\n \n-fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepNode::NeedsDrop(def_id)\n+    DepConstructor::NeedsDrop(def_id)\n }\n \n-fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor {\n     let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n         .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepNode::Layout(def_id)\n+    DepConstructor::Layout(def_id)\n }"}, {"sha": "b09ab57cc41aa443aff32650c9183277468dd41f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -15,7 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n-use dep_graph::DepNode;\n+use dep_graph::{DepNode, DepConstructor};\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -918,7 +918,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n     }\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n-    fn dep_node(&self) -> DepNode<DefId> {\n+    fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n         // Extact the trait-def and first def-id from inputs.  See the\n         // docs for `DepNode::TraitSelect` for more information.\n         let trait_def_id = self.def_id();\n@@ -931,10 +931,10 @@ impl<'tcx> TraitPredicate<'tcx> {\n                 })\n                 .next()\n                 .unwrap_or(trait_def_id);\n-        DepNode::TraitSelect {\n+        DepNode::new(tcx, DepConstructor::TraitSelect {\n             trait_def_id: trait_def_id,\n             input_def_id: input_def_id\n-        }\n+        })\n     }\n \n     pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n@@ -952,9 +952,9 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         self.0.def_id()\n     }\n \n-    pub fn dep_node(&self) -> DepNode<DefId> {\n+    pub fn dep_node(&self, tcx: TyCtxt) -> DepNode {\n         // ok to skip binder since depnode does not care about regions\n-        self.0.dep_node()\n+        self.0.dep_node(tcx)\n     }\n }\n "}, {"sha": "40ee3cd28f56250efd3a1199630962a7628269d6", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -19,6 +19,8 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n+use ty::TyCtxt;\n+\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -209,7 +211,7 @@ pub trait MemoizationMap {\n     /// needed in the `op` to ensure that the correct edges are\n     /// added into the dep graph. See the `DepTrackingMap` impl for\n     /// more details!\n-    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n+    fn memoize<OP>(&self, tcx: TyCtxt, key: Self::Key, op: OP) -> Self::Value\n         where OP: FnOnce() -> Self::Value;\n }\n \n@@ -219,7 +221,7 @@ impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n     type Key = K;\n     type Value = V;\n \n-    fn memoize<OP>(&self, key: K, op: OP) -> V\n+    fn memoize<OP>(&self, _tcx: TyCtxt, key: K, op: OP) -> V\n         where OP: FnOnce() -> V\n     {\n         let result = self.borrow().get(&key).cloned();"}, {"sha": "04192c35ef3ab22f82a6b8dcd49936c30ee97191", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -44,7 +44,7 @@\n //! ```\n \n use graphviz as dot;\n-use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;\n@@ -95,8 +95,8 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     check_paths(tcx, &if_this_changed, &then_this_would_need);\n }\n \n-type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n-type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode<DefId>)>;\n+type Sources = Vec<(Span, DefId, DepNode)>;\n+type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -121,13 +121,14 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n \n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir.local_def_id(node_id);\n+        let def_path_hash = self.tcx.def_path_hash(def_id);\n         for attr in attrs {\n             if attr.check_name(ATTR_IF_THIS_CHANGED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    None => DepNode::Hir(def_id),\n+                    None => def_path_hash.to_dep_node(DepKind::Hir),\n                     Some(n) => {\n-                        match DepNode::from_label_string(&n.as_str(), def_id) {\n+                        match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -142,7 +143,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(n) => {\n-                        match DepNode::from_label_string(&n.as_str(), def_id) {\n+                        match DepNode::from_label_string(&n.as_str(), def_path_hash) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -263,51 +264,51 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode<DefId>>,\n-                                Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n+pub struct GraphvizDepGraph<'q>(FxHashSet<&'q DepNode>,\n+                                Vec<(&'q DepNode, &'q DepNode)>);\n \n impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n-    type Node = &'q DepNode<DefId>;\n-    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n-    fn nodes(&self) -> dot::Nodes<&'q DepNode<DefId>> {\n+    type Node = &'q DepNode;\n+    type Edge = (&'q DepNode, &'q DepNode);\n+    fn nodes(&self) -> dot::Nodes<&'q DepNode> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n     }\n-    fn edges(&self) -> dot::Edges<(&'q DepNode<DefId>, &'q DepNode<DefId>)> {\n+    fn edges(&self) -> dot::Edges<(&'q DepNode, &'q DepNode)> {\n         self.1[..].into_cow()\n     }\n-    fn source(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n+    fn source(&self, edge: &(&'q DepNode, &'q DepNode)) -> &'q DepNode {\n         edge.0\n     }\n-    fn target(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n+    fn target(&self, edge: &(&'q DepNode, &'q DepNode)) -> &'q DepNode {\n         edge.1\n     }\n }\n \n impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n-    type Node = &'q DepNode<DefId>;\n-    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n+    type Node = &'q DepNode;\n+    type Edge = (&'q DepNode, &'q DepNode);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &&'q DepNode<DefId>) -> dot::Id {\n+    fn node_id(&self, n: &&'q DepNode) -> dot::Id {\n         let s: String =\n             format!(\"{:?}\", n).chars()\n                               .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n                               .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &&'q DepNode<DefId>) -> dot::LabelText {\n+    fn node_label(&self, n: &&'q DepNode) -> dot::LabelText {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n \n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-                -> Option<FxHashSet<&'q DepNode<DefId>>>\n+fn node_set<'q>(query: &'q DepGraphQuery, filter: &DepNodeFilter)\n+                -> Option<FxHashSet<&'q DepNode>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -318,10 +319,10 @@ fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n     Some(query.nodes().into_iter().filter(|n| filter.test(n)).collect())\n }\n \n-fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &Option<FxHashSet<&'q DepNode<DefId>>>,\n-                    targets: &Option<FxHashSet<&'q DepNode<DefId>>>)\n-                    -> FxHashSet<&'q DepNode<DefId>>\n+fn filter_nodes<'q>(query: &'q DepGraphQuery,\n+                    sources: &Option<FxHashSet<&'q DepNode>>,\n+                    targets: &Option<FxHashSet<&'q DepNode>>)\n+                    -> FxHashSet<&'q DepNode>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -336,10 +337,10 @@ fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n     }\n }\n \n-fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n-                  starts: &FxHashSet<&'q DepNode<DefId>>,\n+fn walk_nodes<'q>(query: &'q DepGraphQuery,\n+                  starts: &FxHashSet<&'q DepNode>,\n                   direction: Direction)\n-                  -> FxHashSet<&'q DepNode<DefId>>\n+                  -> FxHashSet<&'q DepNode>\n {\n     let mut set = FxHashSet();\n     for &start in starts {\n@@ -360,10 +361,10 @@ fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n     set\n }\n \n-fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n-                    sources: &FxHashSet<&'q DepNode<DefId>>,\n-                    targets: &FxHashSet<&'q DepNode<DefId>>)\n-                    -> FxHashSet<&'q DepNode<DefId>>\n+fn walk_between<'q>(query: &'q DepGraphQuery,\n+                    sources: &FxHashSet<&'q DepNode>,\n+                    targets: &FxHashSet<&'q DepNode>)\n+                    -> FxHashSet<&'q DepNode>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -391,7 +392,7 @@ fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n                 })\n                 .collect();\n \n-    fn recurse(query: &DepGraphQuery<DefId>,\n+    fn recurse(query: &DepGraphQuery,\n                node_states: &mut [State],\n                node: NodeIndex)\n                -> bool\n@@ -428,9 +429,9 @@ fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n     }\n }\n \n-fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n-                    nodes: &FxHashSet<&'q DepNode<DefId>>)\n-                    -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n+fn filter_edges<'q>(query: &'q DepGraphQuery,\n+                    nodes: &FxHashSet<&'q DepNode>)\n+                    -> Vec<(&'q DepNode, &'q DepNode)>\n {\n     query.edges()\n          .into_iter()"}, {"sha": "f30a0f553b98209aa140f654906504fa75aef632", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -29,7 +29,7 @@\n \n use std::cell::RefCell;\n use std::hash::Hash;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, DepKind};\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::map::DefPathHash;\n@@ -44,7 +44,7 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n pub type IchHasher = StableHasher<Fingerprint>;\n \n pub struct IncrementalHashesMap {\n-    hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n+    hashes: FxHashMap<DepNode, Fingerprint>,\n \n     // These are the metadata hashes for the current crate as they were stored\n     // during the last compilation session. They are only loaded if\n@@ -62,16 +62,16 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn get(&self, k: &DepNode<DefId>) -> Option<&Fingerprint> {\n+    pub fn get(&self, k: &DepNode) -> Option<&Fingerprint> {\n         self.hashes.get(k)\n     }\n \n-    pub fn insert(&mut self, k: DepNode<DefId>, v: Fingerprint) -> Option<Fingerprint> {\n-        self.hashes.insert(k, v)\n+    pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n+        assert!(self.hashes.insert(k, v).is_none());\n     }\n \n     pub fn iter<'a>(&'a self)\n-                    -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, Fingerprint> {\n+                    -> ::std::collections::hash_map::Iter<'a, DepNode, Fingerprint> {\n         self.hashes.iter()\n     }\n \n@@ -80,10 +80,10 @@ impl IncrementalHashesMap {\n     }\n }\n \n-impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n+impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n     type Output = Fingerprint;\n \n-    fn index(&self, index: &'a DepNode<DefId>) -> &Fingerprint {\n+    fn index(&self, index: &'a DepNode) -> &Fingerprint {\n         match self.hashes.get(index) {\n             Some(fingerprint) => fingerprint,\n             None => {\n@@ -100,7 +100,7 @@ struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n     fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              dep_node: DepNode<DefId>,\n+                                              dep_node: DepNode,\n                                               hash_bodies: bool,\n                                               item_like: T)\n         where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n@@ -143,36 +143,29 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n         // add each item (in some deterministic order) to the overall\n         // crate hash.\n         {\n-            let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n-                           .filter_map(|(item_dep_node, &item_hash)| {\n+                           .filter_map(|(&item_dep_node, &item_hash)| {\n                                 // This `match` determines what kinds of nodes\n                                 // go into the SVH:\n-                                match *item_dep_node {\n-                                    DepNode::Hir(_) |\n-                                    DepNode::HirBody(_) => {\n+                                match item_dep_node.kind {\n+                                    DepKind::Hir |\n+                                    DepKind::HirBody => {\n                                         // We want to incoporate these into the\n                                         // SVH.\n                                     }\n-                                    DepNode::AllLocalTraitImpls => {\n+                                    DepKind::AllLocalTraitImpls => {\n                                         // These are already covered by hashing\n                                         // the HIR.\n                                         return None\n                                     }\n                                     ref other => {\n-                                        bug!(\"Found unexpected DepNode during \\\n+                                        bug!(\"Found unexpected DepKind during \\\n                                               SVH computation: {:?}\",\n                                              other)\n                                     }\n                                 }\n \n-                                // Convert from a DepNode<DefId> to a\n-                                // DepNode<u64> where the u64 is the hash of\n-                                // the def-id's def-path:\n-                                let item_dep_node =\n-                                    item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n-                                                 .unwrap();\n                                 Some((item_dep_node, item_hash))\n                            })\n                            .collect();\n@@ -183,7 +176,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n         krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n \n         let crate_hash = crate_state.finish();\n-        self.hashes.insert(DepNode::Krate, crate_hash);\n+        self.hashes.insert(DepNode::new_no_params(DepKind::Krate), crate_hash);\n         debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n \n@@ -206,11 +199,11 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             body_ids: _,\n         } = *krate;\n \n-        let def_id = DefId::local(CRATE_DEF_INDEX);\n-        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id),\n+        let def_path_hash = self.hcx.tcx().hir.definitions().def_path_hash(CRATE_DEF_INDEX);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n                                                  false,\n                                                  (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id),\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n                                                  true,\n                                                  (module, (span, attrs)));\n     }\n@@ -255,27 +248,43 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n         let mut hasher = StableHasher::new();\n         impls.hash_stable(&mut self.hcx, &mut hasher);\n \n-        self.hashes.insert(DepNode::AllLocalTraitImpls, hasher.finish());\n+        self.hashes.insert(DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n+                           hasher.finish());\n     }\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n-        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n+        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+                                                 false,\n+                                                 item);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+                                                 true,\n+                                                 item);\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n-        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n+        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+                                                 false,\n+                                                 item);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+                                                 true,\n+                                                 item);\n     }\n \n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        self.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, item);\n-        self.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, item);\n+        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+                                                 false,\n+                                                 item);\n+        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+                                                 true,\n+                                                 item);\n     }\n }\n \n@@ -297,8 +306,13 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n         for macro_def in krate.exported_macros.iter() {\n             let def_id = tcx.hir.local_def_id(macro_def.id);\n-            visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n-            visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n+            let def_path_hash = tcx.def_path_hash(def_id);\n+            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+                                                        false,\n+                                                        macro_def);\n+            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+                                                        true,\n+                                                        macro_def);\n         }\n \n         visitor.compute_and_store_ich_for_trait_impls(krate);"}, {"sha": "c3cd9656afe555bd3b5dd7bff48abe20d2d5d7b2", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>>,\n+    pub nodes: IndexVec<DepNodeIndex, DepNode>,\n     /// For each DepNode, stores the list of edges originating from that\n     /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n     /// which holds the actual DepNodeIndices of the target nodes.\n@@ -34,7 +34,7 @@ pub struct SerializedDepGraph {\n     /// These are output nodes that have no incoming edges. We track\n     /// these separately so that when we reload all edges, we don't\n     /// lose track of these nodes.\n-    pub bootstrap_outputs: Vec<DepNode<DefPathHash>>,\n+    pub bootstrap_outputs: Vec<DepNode>,\n \n     /// These are hashes of two things:\n     /// - the HIR nodes in this crate\n@@ -87,7 +87,7 @@ impl Idx for DepNodeIndex {\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {\n     /// def-id of thing being hashed\n-    pub dep_node: DepNode<DefPathHash>,\n+    pub dep_node: DepNode,\n \n     /// the hash as of previous compilation, computed by code in\n     /// `hash` module"}, {"sha": "01ec0d685268ad35abcff5a59ee1519eb6a0c0fa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -41,7 +41,7 @@\n //!\n \n use super::load::DirtyNodes;\n-use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -64,14 +64,10 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let def_path_hash_to_def_id = tcx.def_path_hash_to_def_id.as_ref().unwrap();\n-    let dirty_inputs: FxHashSet<DepNode<DefId>> =\n+    let dirty_inputs: FxHashSet<DepNode> =\n         dirty_inputs.keys()\n-                    .filter_map(|dep_node| {\n-                        dep_node.map_def(|def_path_hash| {\n-                            def_path_hash_to_def_id.get(def_path_hash).cloned()\n-                        })\n-                    })\n+                    .filter(|dep_node| dep_node.extract_def_id(tcx).is_some())\n+                    .cloned()\n                     .collect();\n \n     let query = tcx.dep_graph.query();\n@@ -100,18 +96,19 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    query: &'a DepGraphQuery<DefId>,\n-    dirty_inputs: FxHashSet<DepNode<DefId>>,\n+    query: &'a DepGraphQuery,\n+    dirty_inputs: FxHashSet<DepNode>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n+    fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode {\n+        let def_path_hash = self.tcx.def_path_hash(def_id);\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, &item);\n-                match DepNode::from_label_string(&value.as_str(), def_id) {\n-                    Ok(def_id) => return def_id,\n+                match DepNode::from_label_string(&value.as_str(), def_path_hash) {\n+                    Ok(dep_node) => return dep_node,\n                     Err(()) => {\n                         self.tcx.sess.span_fatal(\n                             item.span,\n@@ -124,24 +121,30 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         self.tcx.sess.span_fatal(attr.span, \"no `label` found\");\n     }\n \n-    fn dep_node_str(&self, dep_node: &DepNode<DefId>) -> DepNode<String> {\n-        dep_node.map_def(|&def_id| Some(self.tcx.item_path_str(def_id))).unwrap()\n+    fn dep_node_str(&self, dep_node: &DepNode) -> String {\n+        if let Some(def_id) = dep_node.extract_def_id(self.tcx) {\n+            format!(\"{:?}({})\",\n+                    dep_node.kind,\n+                    self.tcx.item_path_str(def_id))\n+        } else {\n+            format!(\"{:?}({:?})\", dep_node.kind, dep_node.hash)\n+        }\n     }\n \n-    fn assert_dirty(&self, item_span: Span, dep_node: DepNode<DefId>) {\n+    fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        match dep_node {\n-            DepNode::Krate |\n-            DepNode::Hir(_) |\n-            DepNode::HirBody(_) => {\n+        match dep_node.kind {\n+            DepKind::Krate |\n+            DepKind::Hir |\n+            DepKind::HirBody => {\n                 // HIR nodes are inputs, so if we are asserting that the HIR node is\n                 // dirty, we check the dirty input set.\n                 if !self.dirty_inputs.contains(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n                         item_span,\n-                        &format!(\"`{:?}` not found in dirty set, but should be dirty\",\n+                        &format!(\"`{}` not found in dirty set, but should be dirty\",\n                                  dep_node_str));\n                 }\n             }\n@@ -152,25 +155,25 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n                         item_span,\n-                        &format!(\"`{:?}` found in dep graph, but should be dirty\", dep_node_str));\n+                        &format!(\"`{}` found in dep graph, but should be dirty\", dep_node_str));\n                 }\n             }\n         }\n     }\n \n-    fn assert_clean(&self, item_span: Span, dep_node: DepNode<DefId>) {\n+    fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        match dep_node {\n-            DepNode::Krate |\n-            DepNode::Hir(_) |\n-            DepNode::HirBody(_) => {\n+        match dep_node.kind {\n+            DepKind::Krate |\n+            DepKind::Hir |\n+            DepKind::HirBody => {\n                 // For HIR nodes, check the inputs.\n                 if self.dirty_inputs.contains(&dep_node) {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n                         item_span,\n-                        &format!(\"`{:?}` found in dirty-node set, but should be clean\",\n+                        &format!(\"`{}` found in dirty-node set, but should be clean\",\n                                  dep_node_str));\n                 }\n             }\n@@ -180,7 +183,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     let dep_node_str = self.dep_node_str(&dep_node);\n                     self.tcx.sess.span_err(\n                         item_span,\n-                        &format!(\"`{:?}` not found in dep graph, but should be clean\",\n+                        &format!(\"`{}` not found in dep graph, but should be clean\",\n                                  dep_node_str));\n                 }\n             }"}, {"sha": "0e8ffb9ee3c969635d0224e44fc8dcbe8500bca7", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, DepKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n@@ -45,42 +45,45 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n-        match *dep_node {\n-            DepNode::Krate |\n-            DepNode::Hir(_) |\n-            DepNode::HirBody(_) =>\n+    pub fn is_hashable(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n+        match dep_node.kind {\n+            DepKind::Krate |\n+            DepKind::Hir |\n+            DepKind::HirBody =>\n                 true,\n-            DepNode::MetaData(def_id) => !def_id.is_local(),\n+            DepKind::MetaData => {\n+                let def_id = dep_node.extract_def_id(tcx).unwrap();\n+                !def_id.is_local()\n+            }\n             _ => false,\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<Fingerprint> {\n-        match *dep_node {\n-            DepNode::Krate => {\n+    pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n+        match dep_node.kind {\n+            DepKind::Krate => {\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n-            DepNode::Hir(def_id) |\n-            DepNode::HirBody(def_id) => {\n-                assert!(def_id.is_local(),\n-                        \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n-                        def_id,\n-                        self.tcx.item_path_str(def_id));\n-\n+            DepKind::Hir |\n+            DepKind::HirBody => {\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n \n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n-            DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some(self.metadata_hash(def_id,\n+            DepKind::MetaData => {\n+                let def_id = dep_node.extract_def_id(self.tcx).unwrap();\n+                if !def_id.is_local() {\n+                    Some(self.metadata_hash(def_id,\n                                         def_id.krate,\n                                         |this| &mut this.metadata_hashes))\n+                } else {\n+                    None\n+                }\n             }\n \n             _ => {"}, {"sha": "53fccfaa39292e9f5f1194bfae9db6ad2bdd735c", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 95, "deletions": 113, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -10,9 +10,8 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{DepNode, WorkProductId};\n+use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::DefPathHash;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n@@ -33,7 +32,7 @@ use super::work_product;\n \n // The key is a dirty node. The value is **some** base-input that we\n // can blame it on.\n-pub type DirtyNodes = FxHashMap<DepNode<DefPathHash>, DepNode<DefPathHash>>;\n+pub type DirtyNodes = FxHashMap<DepNode, DepNode>;\n \n /// If we are in incremental mode, and a previous dep-graph exists,\n /// then load up those nodes/edges that are still valid into the\n@@ -118,14 +117,20 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n     None\n }\n \n-/// Try to convert a DepNode from the old dep-graph into a DepNode in the\n-/// current graph by mapping the DefPathHash to a valid DefId. This will fail\n-/// if the DefPathHash refers to something that has been removed (because\n-/// there is no DefId for that thing anymore).\n-fn retrace(tcx: TyCtxt, dep_node: &DepNode<DefPathHash>) -> Option<DepNode<DefId>> {\n-    dep_node.map_def(|def_path_hash| {\n-        tcx.def_path_hash_to_def_id.as_ref().unwrap().get(def_path_hash).cloned()\n-    })\n+/// Check if a DepNode from the previous dep-graph refers to something that\n+/// still exists in the current compilation session. Only works for DepNode\n+/// variants that represent inputs (HIR and imported Metadata).\n+fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n+    match dep_node.kind {\n+        DepKind::Hir |\n+        DepKind::HirBody |\n+        DepKind::MetaData => {\n+            dep_node.extract_def_id(tcx).is_some()\n+        }\n+        _ => {\n+            bug!(\"unexpected Input DepNode: {:?}\", dep_node)\n+        }\n+    }\n }\n \n /// Decode the dep graph and load the edges/nodes that are still clean\n@@ -161,7 +166,7 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let serialized_dep_graph = SerializedDepGraph::decode(&mut dep_graph_decoder)?;\n \n-    let edge_map: FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>> = {\n+    let edge_map: FxHashMap<DepNode, Vec<DepNode>> = {\n         let capacity = serialized_dep_graph.edge_list_data.len();\n         let mut edge_map = FxHashMap::with_capacity_and_hasher(capacity, Default::default());\n \n@@ -194,48 +199,28 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Recreate the edges in the graph that are still clean.\n     let mut clean_work_products = FxHashSet();\n     let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n-    let mut extra_edges = vec![];\n     for (source, targets) in &edge_map {\n         for target in targets {\n-            process_edges(tcx, source, target, &edge_map, &dirty_raw_nodes,\n-                          &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n+            process_edge(tcx, source, target, &dirty_raw_nodes,\n+                         &mut clean_work_products, &mut dirty_work_products);\n         }\n     }\n \n     // Recreate bootstrap outputs, which are outputs that have no incoming edges (and hence cannot\n     // be dirty).\n     for bootstrap_output in &serialized_dep_graph.bootstrap_outputs {\n-        if let Some(n) = retrace(tcx, bootstrap_output) {\n-            if let DepNode::WorkProduct(ref wp) = n {\n-                clean_work_products.insert(wp.clone());\n-            }\n+        if let DepKind::WorkProduct = bootstrap_output.kind {\n+            let wp_id = WorkProductId::from_fingerprint(bootstrap_output.hash);\n+            clean_work_products.insert(wp_id);\n+        }\n \n-            tcx.dep_graph.with_task(n, (), (), create_node);\n+        tcx.dep_graph.with_task(*bootstrap_output, (), (), create_node);\n \n-            fn create_node((): (), (): ()) {\n-                // just create the node with no inputs\n-            }\n+        fn create_node((): (), (): ()) {\n+            // just create the node with no inputs\n         }\n     }\n \n-    // Subtle. Sometimes we have intermediate nodes that we can't recreate in the new graph.\n-    // This is pretty unusual but it arises in a scenario like this:\n-    //\n-    //     Hir(X) -> Foo(Y) -> Bar\n-    //\n-    // Note that the `Hir(Y)` is not an input to `Foo(Y)` -- this\n-    // almost never happens, but can happen in some obscure\n-    // scenarios. In that case, if `Y` is removed, then we can't\n-    // recreate `Foo(Y)` (the def-id `Y` no longer exists); what we do\n-    // then is to push the edge `Hir(X) -> Bar` onto `extra_edges`\n-    // (along with any other targets of `Foo(Y)`). We will then add\n-    // the edge from `Hir(X)` to `Bar` (or, if `Bar` itself cannot be\n-    // recreated, to the targets of `Bar`).\n-    while let Some((source, target)) = extra_edges.pop() {\n-        process_edges(tcx, source, target, &edge_map, &dirty_raw_nodes,\n-                      &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n-    }\n-\n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n@@ -256,40 +241,37 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FxHashMap();\n \n-    let print_removed_message = |dep_node: &DepNode<_>| {\n-        if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-            println!(\"node {:?} is dirty as it was removed\", dep_node);\n-        }\n-\n-        debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\", dep_node);\n-    };\n-\n     for hash in serialized_hashes {\n-        if let Some(dep_node) = retrace(tcx, &hash.dep_node) {\n-            if let Some(current_hash) = hcx.hash(&dep_node) {\n-                if current_hash == hash.hash {\n-                    debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n-                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+        let dep_node = hash.dep_node;\n+        if does_still_exist(tcx, &dep_node) {\n+            let current_hash = hcx.hash(&dep_node).unwrap_or_else(|| {\n+                bug!(\"Cannot find current ICH for input that still exists?\")\n+            });\n+\n+            if current_hash == hash.hash {\n+                debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n+                       dep_node,\n                        current_hash);\n-                    continue;\n-                }\n-\n-                if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-                    println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n-                             dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                             current_hash,\n-                             hash.hash);\n-                }\n+                continue;\n+            }\n \n-                debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n-                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                       current_hash,\n-                       hash.hash);\n-            } else {\n-                print_removed_message(&hash.dep_node);\n+            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                println!(\"node {:?} is dirty as hash is {:?}, was {:?}\",\n+                         dep_node,\n+                         current_hash,\n+                         hash.hash);\n             }\n+\n+            debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                   dep_node,\n+                   current_hash,\n+                   hash.hash);\n         } else {\n-            print_removed_message(&hash.dep_node);\n+            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                println!(\"node {:?} is dirty as it was removed\", dep_node);\n+            }\n+\n+            debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\", dep_node);\n         }\n \n         dirty_nodes.insert(hash.dep_node.clone(), hash.dep_node.clone());\n@@ -298,11 +280,11 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     dirty_nodes\n }\n \n-fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>>,\n+fn transitive_dirty_nodes(edge_map: &FxHashMap<DepNode, Vec<DepNode>>,\n                           mut dirty_nodes: DirtyNodes)\n                           -> DirtyNodes\n {\n-    let mut stack: Vec<(DepNode<DefPathHash>, DepNode<DefPathHash>)> = vec![];\n+    let mut stack: Vec<(DepNode, DepNode)> = vec![];\n     stack.extend(dirty_nodes.iter().map(|(s, b)| (s.clone(), b.clone())));\n     while let Some((source, blame)) = stack.pop() {\n         // we know the source is dirty (because of the node `blame`)...\n@@ -366,6 +348,7 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n fn load_prev_metadata_hashes(tcx: TyCtxt,\n                              output: &mut FxHashMap<DefId, Fingerprint>) {\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n+        // Previous metadata hashes are only needed for testing.\n         return\n     }\n \n@@ -417,71 +400,70 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n            serialized_hashes.index_map.len());\n }\n \n-fn process_edges<'a, 'tcx, 'edges>(\n+fn process_edge<'a, 'tcx, 'edges>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: &'edges DepNode<DefPathHash>,\n-    target: &'edges DepNode<DefPathHash>,\n-    edges: &'edges FxHashMap<DepNode<DefPathHash>, Vec<DepNode<DefPathHash>>>,\n+    source: &'edges DepNode,\n+    target: &'edges DepNode,\n     dirty_raw_nodes: &DirtyNodes,\n     clean_work_products: &mut FxHashSet<WorkProductId>,\n-    dirty_work_products: &mut FxHashSet<WorkProductId>,\n-    extra_edges: &mut Vec<(&'edges DepNode<DefPathHash>, &'edges DepNode<DefPathHash>)>)\n+    dirty_work_products: &mut FxHashSet<WorkProductId>)\n {\n     // If the target is dirty, skip the edge. If this is an edge\n     // that targets a work-product, we can print the blame\n     // information now.\n     if let Some(blame) = dirty_raw_nodes.get(target) {\n-        if let DepNode::WorkProduct(ref wp) = *target {\n+        if let DepKind::WorkProduct = target.kind {\n             if tcx.sess.opts.debugging_opts.incremental_info {\n-                if dirty_work_products.insert(wp.clone()) {\n+                let wp_id = WorkProductId::from_fingerprint(target.hash);\n+\n+                if dirty_work_products.insert(wp_id) {\n                     // Try to reconstruct the human-readable version of the\n                     // DepNode. This cannot be done for things that where\n                     // removed.\n-                    let readable_blame = if let Some(dep_node) = retrace(tcx, blame) {\n-                        dep_node.map_def(|&def_id| Some(tcx.def_path(def_id).to_string(tcx)))\n-                                .unwrap()\n+                    let blame_str = if let Some(def_id) = blame.extract_def_id(tcx) {\n+                        format!(\"{:?}({})\",\n+                                blame.kind,\n+                                tcx.def_path(def_id).to_string(tcx))\n                     } else {\n-                        blame.map_def(|def_path_hash| Some(format!(\"{:?}\", def_path_hash)))\n-                             .unwrap()\n+                        format!(\"{:?}\", blame)\n                     };\n \n                     println!(\"incremental: module {:?} is dirty because {:?} \\\n                               changed or was removed\",\n-                             wp,\n-                             readable_blame);\n+                             wp_id,\n+                             blame_str);\n                 }\n             }\n         }\n         return;\n     }\n \n-    // If the source is dirty, the target will be dirty.\n-    assert!(!dirty_raw_nodes.contains_key(source));\n-\n-    // Retrace the source -> target edges to def-ids and then create\n-    // an edge in the graph. Retracing may yield none if some of the\n-    // data happens to have been removed.\n-    if let Some(source_node) = retrace(tcx, source) {\n-        if let Some(target_node) = retrace(tcx, target) {\n-            let _task = tcx.dep_graph.in_task(target_node);\n-            tcx.dep_graph.read(source_node);\n-            if let DepNode::WorkProduct(ref wp) = *target {\n-                clean_work_products.insert(wp.clone());\n-            }\n-        } else {\n-            // As discussed in `decode_dep_graph` above, sometimes the\n-            // target cannot be recreated again, in which case we add\n-            // edges to go from `source` to the targets of `target`.\n-            extra_edges.extend(\n-                edges[target].iter().map(|t| (source, t)));\n+    // At this point we have asserted that the target is clean -- otherwise, we\n+    // would have hit the return above. We can do some further consistency\n+    // checks based on this fact:\n+\n+    // We should never have an edge where the target is clean but the source\n+    // was dirty. Otherwise something was wrong with the dirtying pass above:\n+    debug_assert!(!dirty_raw_nodes.contains_key(source));\n+\n+    // We also never should encounter an edge going from a removed input to a\n+    // clean target because removing the input would have dirtied the input\n+    // node and transitively dirtied the target.\n+    debug_assert!(match source.kind {\n+        DepKind::Hir | DepKind::HirBody | DepKind::MetaData => {\n+            does_still_exist(tcx, source)\n+        }\n+        _ => true,\n+    });\n+\n+    if !dirty_raw_nodes.contains_key(target) {\n+        let _task = tcx.dep_graph.in_task(*target);\n+        tcx.dep_graph.read(*source);\n+\n+        if let DepKind::WorkProduct = target.kind {\n+            let wp_id = WorkProductId::from_fingerprint(target.hash);\n+            clean_work_products.insert(wp_id);\n         }\n-    } else {\n-        // It's also possible that the source can't be created! But we\n-        // can ignore such cases, because (a) if `source` is a HIR\n-        // node, it would be considered dirty; and (b) in other cases,\n-        // there must be some input to this node that is clean, and so\n-        // we'll re-create the edges over in the case where target is\n-        // undefined.\n     }\n }\n "}, {"sha": "0a259ad268582e7ca61d882a444c10d483b6bed2", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::dep_graph::{DepGraphQuery, DepNode};\n-use rustc::hir::def_id::DefId;\n+use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n@@ -26,48 +25,50 @@ pub struct Predecessors<'query> {\n     // nodes) and all of the \"work-products\" we may care about\n     // later. Other nodes may be retained if it keeps the overall size\n     // of the graph down.\n-    pub reduced_graph: Graph<&'query DepNode<DefId>, ()>,\n+    pub reduced_graph: Graph<&'query DepNode, ()>,\n \n     // These are output nodes that have no incoming edges. We have to\n     // track these specially because, when we load the data back up\n     // again, we want to make sure and recreate these nodes (we want\n     // to recreate the nodes where all incoming edges are clean; but\n     // since we ordinarily just serialize edges, we wind up just\n     // forgetting that bootstrap outputs even exist in that case.)\n-    pub bootstrap_outputs: Vec<&'query DepNode<DefId>>,\n+    pub bootstrap_outputs: Vec<&'query DepNode>,\n \n     // For the inputs (hir/foreign-metadata), we include hashes.\n-    pub hashes: FxHashMap<&'query DepNode<DefId>, Fingerprint>,\n+    pub hashes: FxHashMap<&'query DepNode, Fingerprint>,\n }\n \n impl<'q> Predecessors<'q> {\n-    pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n+    pub fn new(query: &'q DepGraphQuery, hcx: &mut HashContext) -> Self {\n         let tcx = hcx.tcx;\n \n         // Find the set of \"start nodes\". These are nodes that we will\n         // possibly query later.\n-        let is_output = |node: &DepNode<DefId>| -> bool {\n-            match *node {\n-                DepNode::WorkProduct(_) => true,\n-                DepNode::MetaData(ref def_id) => {\n+        let is_output = |node: &DepNode| -> bool {\n+            match node.kind {\n+                DepKind::WorkProduct => true,\n+                DepKind::MetaData => {\n                     // We do *not* create dep-nodes for the current crate's\n                     // metadata anymore, just for metadata that we import/read\n                     // from other crates.\n-                    debug_assert!(!def_id.is_local());\n+                    debug_assert!(!node.extract_def_id(tcx).unwrap().is_local());\n                     false\n                 }\n                 // if -Z query-dep-graph is passed, save more extended data\n                 // to enable better unit testing\n-                DepNode::TypeckTables(_) |\n-                DepNode::TransCrateItem(_) => tcx.sess.opts.debugging_opts.query_dep_graph,\n+                DepKind::TypeckTables |\n+                DepKind::TransCrateItem => tcx.sess.opts.debugging_opts.query_dep_graph,\n \n                 _ => false,\n             }\n         };\n \n         // Reduce the graph to the most important nodes.\n         let compress::Reduction { graph, input_nodes } =\n-            compress::reduce_graph(&query.graph, HashContext::is_hashable, |n| is_output(n));\n+            compress::reduce_graph(&query.graph,\n+                                   |n| HashContext::is_hashable(tcx, n),\n+                                   |n| is_output(n));\n \n         let mut hashes = FxHashMap();\n         for input_index in input_nodes {\n@@ -81,8 +82,8 @@ impl<'q> Predecessors<'q> {\n             // Not all inputs might have been reachable from an output node,\n             // but we still want their hash for our unit tests.\n             let hir_nodes = query.graph.all_nodes().iter().filter_map(|node| {\n-                match node.data {\n-                    DepNode::Hir(_) => Some(&node.data),\n+                match node.data.kind {\n+                    DepKind::Hir => Some(&node.data),\n                     _ => None,\n                 }\n             });\n@@ -93,7 +94,7 @@ impl<'q> Predecessors<'q> {\n             }\n         }\n \n-        let bootstrap_outputs: Vec<&'q DepNode<DefId>> =\n+        let bootstrap_outputs: Vec<&'q DepNode> =\n             (0 .. graph.len_nodes())\n             .map(NodeIndex)\n             .filter(|&n| graph.incoming_edges(n).next().is_none())"}, {"sha": "48742b424f1e5879f0ce3748e9ffe042bcce7415", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -11,7 +11,6 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n-use rustc::hir::map::DefPathHash;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n@@ -174,16 +173,12 @@ pub fn encode_dep_graph(tcx: TyCtxt,\n     // First encode the commandline arguments hash\n     tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n \n-    let to_hash_based_node = |dep_node: &DepNode<DefId>| {\n-        dep_node.map_def(|&def_id| Some(tcx.def_path_hash(def_id))).unwrap()\n-    };\n-\n     // NB: We rely on this Vec being indexable by reduced_graph's NodeIndex.\n-    let nodes: IndexVec<DepNodeIndex, DepNode<DefPathHash>> = preds\n+    let nodes: IndexVec<DepNodeIndex, DepNode> = preds\n         .reduced_graph\n         .all_nodes()\n         .iter()\n-        .map(|node| to_hash_based_node(node.data))\n+        .map(|node| node.data.clone())\n         .collect();\n \n     let mut edge_list_indices = Vec::with_capacity(nodes.len());\n@@ -206,18 +201,17 @@ pub fn encode_dep_graph(tcx: TyCtxt,\n     // Check that we have a consistent number of edges.\n     assert_eq!(edge_list_data.len(), preds.reduced_graph.len_edges());\n \n-    let bootstrap_outputs = preds\n-        .bootstrap_outputs\n-        .iter()\n-        .map(|n| to_hash_based_node(n))\n-        .collect();\n+    let bootstrap_outputs = preds.bootstrap_outputs\n+                                 .iter()\n+                                 .map(|dep_node| (**dep_node).clone())\n+                                 .collect();\n \n     let hashes = preds\n         .hashes\n         .iter()\n         .map(|(&dep_node, &hash)| {\n             SerializedHash {\n-                dep_node: to_hash_based_node(dep_node),\n+                dep_node: dep_node.clone(),\n                 hash: hash,\n             }\n         })"}, {"sha": "e572be9ffe7d1fa37f8e3d89b41404db5453f18c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -255,6 +255,13 @@ impl CStore {\n     pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n+\n+    pub fn read_dep_node(&self, def_id: DefId) {\n+        use rustc::middle::cstore::CrateStore;\n+        let def_path_hash = self.def_path_hash(def_id);\n+        let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n+        self.dep_graph.read(dep_node);\n+    }\n }\n \n impl CrateMetadata {"}, {"sha": "97f73b25c64d710d2a432e4a0d3f95874b8a2670", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -22,8 +22,6 @@ use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-\n-use rustc::dep_graph::{DepNode};\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData, DefPathHash};\n use rustc::hir::map::definitions::{DefPathTable, GlobalMetaDataKind};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n@@ -48,7 +46,10 @@ macro_rules! provide {\n                                         DepTrackingMapConfig>::Value {\n                 assert!(!$def_id.is_local());\n \n-                $tcx.dep_graph.read(DepNode::MetaData($def_id));\n+                let def_path_hash = $tcx.def_path_hash($def_id);\n+                let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n+\n+                $tcx.dep_graph.read(dep_node);\n \n                 let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n@@ -140,12 +141,12 @@ impl CrateStore for cstore::CStore {\n     }\n \n     fn visibility(&self, def: DefId) -> ty::Visibility {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n     fn item_generics_cloned(&self, def: DefId) -> ty::Generics {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_generics(def.index)\n     }\n \n@@ -161,19 +162,19 @@ impl CrateStore for cstore::CStore {\n \n     fn impl_defaultness(&self, def: DefId) -> hir::Defaultness\n     {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_impl_defaultness(def.index)\n     }\n \n     fn associated_item_cloned(&self, def: DefId) -> ty::AssociatedItem\n     {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_associated_item(def.index)\n     }\n \n     fn is_const_fn(&self, did: DefId) -> bool\n     {\n-        self.dep_graph.read(DepNode::MetaData(did));\n+        self.read_dep_node(did);\n         self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n@@ -344,13 +345,13 @@ impl CrateStore for cstore::CStore {\n \n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def));\n+        self.read_dep_node(def);\n         self.get_crate_data(def.krate).get_struct_field_names(def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<def::Export>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n+        self.read_dep_node(def_id);\n         let mut result = vec![];\n         self.get_crate_data(def_id.krate)\n             .each_child_of_item(def_id.index, |child| result.push(child));\n@@ -398,11 +399,12 @@ impl CrateStore for cstore::CStore {\n                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> &'tcx hir::Body {\n-        if let Some(cached) = tcx.hir.get_inlined_body(def_id) {\n+        self.read_dep_node(def_id);\n+\n+        if let Some(cached) = tcx.hir.get_inlined_body_untracked(def_id) {\n             return cached;\n         }\n \n-        self.dep_graph.read(DepNode::MetaData(def_id));\n         debug!(\"item_body({:?}): inlining item\", def_id);\n \n         self.get_crate_data(def_id.krate).item_body(tcx, def_id.index)"}, {"sha": "2a2010621fcce739e12aa455c5674a91a3b6db76", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -13,7 +13,7 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n-use rustc::dep_graph::{DepGraph, DepNode};\n+use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir::map::definitions::GlobalMetaDataKind;\n use rustc::hir;\n@@ -876,7 +876,8 @@ impl<'a, 'tcx> CrateMetadata {\n             return Rc::new([]);\n         }\n \n-        dep_graph.read(DepNode::MetaData(self.local_def_id(node_id)));\n+        let dep_node = self.def_path_hash(node_id).to_dep_node(DepKind::MetaData);\n+        dep_graph.read(dep_node);\n \n         if let Some(&Some(ref val)) =\n             self.attribute_cache.borrow()[node_as].get(node_index) {\n@@ -1194,8 +1195,9 @@ impl<'a, 'tcx> CrateMetadata {\n         self.codemap_import_info.borrow()\n     }\n \n-    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode<DefId> {\n+    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode {\n         let def_index = kind.def_index(&self.def_path_table);\n-        DepNode::MetaData(self.local_def_id(def_index))\n+        let def_path_hash = self.def_path_table.def_path_hash(def_index);\n+        def_path_hash.to_dep_node(DepKind::MetaData)\n     }\n }"}, {"sha": "1337f90efa74d56c9ff900887e928ef67f8848ee", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -203,7 +203,7 @@ impl<T> Tracked<T> {\n         }\n     }\n \n-    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode<DefId>) -> &T {\n+    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode) -> &T {\n         dep_graph.read(dep_node);\n         &self.state\n     }"}, {"sha": "e4939db5759a5a04a8d3c69008ceba8edbc0815e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::dependency_format::Linkage;\n use CrateTranslation;\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepKind, DepNode};\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n@@ -134,8 +134,9 @@ pub fn find_crate_name(sess: Option<&Session>,\n }\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n+    let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n     let r = LinkMeta {\n-        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n+        crate_hash: Svh::new(incremental_hashes_map[krate_dep_node].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "ead442d338820fb0a732ce32f373e256750fbcd9", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -167,8 +167,8 @@ impl<'tcx> CodegenUnit<'tcx> {\n         WorkProductId::from_cgu_name(self.name())\n     }\n \n-    pub fn work_product_dep_node(&self) -> DepNode<DefId> {\n-        DepNode::WorkProduct(self.work_product_id())\n+    pub fn work_product_dep_node(&self) -> DepNode {\n+        self.work_product_id().to_dep_node()\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,"}, {"sha": "2a36ef9358e4583eb20684789b153d59d49eadb6", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -23,7 +23,7 @@ use common;\n use declare;\n use llvm;\n use monomorphize::Instance;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::DepKind;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -75,14 +75,16 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         match *self {\n             TransItem::Static(node_id) => {\n-                let def_id = ccx.tcx().hir.local_def_id(node_id);\n-                let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)\n-                let item = ccx.tcx().hir.expect_item(node_id);\n+                let tcx = ccx.tcx();\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                let dep_node = def_id.to_dep_node(tcx, DepKind::TransCrateItem);\n+                let _task = ccx.tcx().dep_graph.in_task(dep_node); // (*)\n+                let item = tcx.hir.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, _) = item.node {\n                     match consts::trans_static(&ccx, m, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n                         Err(err) => {\n-                            err.report(ccx.tcx(), item.span, \"static\");\n+                            err.report(tcx, item.span, \"static\");\n                         }\n                     };\n                 } else {\n@@ -99,7 +101,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             }\n             TransItem::Fn(instance) => {\n                 let _task = ccx.tcx().dep_graph.in_task(\n-                    DepNode::TransCrateItem(instance.def_id())); // (*)\n+                    instance.def_id()\n+                            .to_dep_node(ccx.tcx(), DepKind::TransCrateItem)); // (*)\n \n                 base::trans_instance(&ccx, instance);\n             }"}, {"sha": "e24d76600218728d7572d3482c6f0f7d8ae82c72", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -17,7 +17,7 @@\n //! `tcx.inherent_impls(def_id)`). That value, however,\n //! is computed by selecting an idea from this table.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::DepKind;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -79,7 +79,8 @@ pub fn inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n \n     for &impl_def_id in &result[..] {\n-        tcx.dep_graph.read(DepNode::Hir(impl_def_id));\n+        let def_path_hash = tcx.def_path_hash(impl_def_id);\n+        tcx.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n     }\n \n     result"}, {"sha": "781e323dea39207bd1e6c1a80a2b5e56b2a05b59", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -15,7 +15,7 @@\n use rustc::traits;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::DepKind;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -39,7 +39,8 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     }\n \n     let _task =\n-        tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+      tcx.dep_graph.in_task(trait_def_id.to_dep_node(tcx,\n+                                                     DepKind::CoherenceOverlapCheck));\n \n     // Trigger building the specialization graph for the trait of this impl.\n     // This will detect any overlap errors."}, {"sha": "c434edb1c31ab38c595c47559a54d2cba187db45", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -15,7 +15,7 @@\n \n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n-use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n+use rustc::dep_graph::{AssertDepGraphSafe, DepKind};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::map as hir_map;\n@@ -104,7 +104,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n             hir::ItemUnion(..) => {\n-                tcx.dep_graph.with_task(DepNode::ItemVarianceConstraints(def_id),\n+                let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+                tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(self),\n                                         def_id,\n                                         visit_item_task);"}, {"sha": "8f9f40ca40b037ee75e157651546a6a2e14604c7", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -12,7 +12,7 @@\n //! parameters. See README.md for details.\n \n use arena;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::DepKind;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n@@ -72,12 +72,15 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             // Lacking red/green, we read the variances for all items here\n             // but ignore the dependencies, then re-synthesize the ones we need.\n             let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n-            tcx.dep_graph.read(DepNode::ItemVarianceConstraints(item_def_id));\n+            let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+            tcx.dep_graph.read(dep_node);\n             for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n                 if dep_def_id.is_local() {\n-                    tcx.dep_graph.read(DepNode::ItemVarianceConstraints(dep_def_id));\n+                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+                    tcx.dep_graph.read(dep_node);\n                 } else {\n-                    tcx.dep_graph.read(DepNode::ItemVariances(dep_def_id));\n+                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n+                    tcx.dep_graph.read(dep_node);\n                 }\n             }\n "}, {"sha": "ce9865103dcc89d9129cd9f20bf173034b4ee65c", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36071749092b03ba454aa16eaf68dd5341d69619/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36071749092b03ba454aa16eaf68dd5341d69619/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=36071749092b03ba454aa16eaf68dd5341d69619", "patch": "@@ -38,8 +38,8 @@ mod y {\n     #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"TransCrateItem\", cfg=\"cfail2\")]\n     pub fn y() {\n-        //[cfail2]~^ ERROR `TypeckTables(\"y::y\")` not found in dep graph, but should be clean\n-        //[cfail2]~| ERROR `TransCrateItem(\"y::y\")` not found in dep graph, but should be clean\n+        //[cfail2]~^ ERROR `TypeckTables(y::y)` not found in dep graph, but should be clean\n+        //[cfail2]~| ERROR `TransCrateItem(y::y)` not found in dep graph, but should be clean\n         x::x();\n     }\n }\n@@ -48,7 +48,7 @@ mod z {\n     #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n     #[rustc_dirty(label=\"TransCrateItem\", cfg=\"cfail2\")]\n     pub fn z() {\n-        //[cfail2]~^ ERROR `TypeckTables(\"z::z\")` found in dep graph, but should be dirty\n-        //[cfail2]~| ERROR `TransCrateItem(\"z::z\")` found in dep graph, but should be dirty\n+        //[cfail2]~^ ERROR `TypeckTables(z::z)` found in dep graph, but should be dirty\n+        //[cfail2]~| ERROR `TransCrateItem(z::z)` found in dep graph, but should be dirty\n     }\n }"}]}