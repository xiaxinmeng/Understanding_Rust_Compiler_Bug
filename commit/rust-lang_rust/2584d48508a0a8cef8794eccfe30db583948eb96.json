{"sha": "2584d48508a0a8cef8794eccfe30db583948eb96", "node_id": "C_kwDOAAsO6NoAKDI1ODRkNDg1MDhhMGE4Y2VmODc5NGVjY2ZlMzBkYjU4Mzk0OGViOTY", "commit": {"author": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-10T13:36:50Z"}, "committer": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-09-10T14:43:46Z"}, "message": "wip", "tree": {"sha": "9ed9807c623be718d6aa6e00640b2e8916e2b7fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ed9807c623be718d6aa6e00640b2e8916e2b7fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2584d48508a0a8cef8794eccfe30db583948eb96", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE+fRQYdEX7Emd36W/pQASwjJOXfAFAmMcoqIACgkQpQASwjJO\nXfAGJg//Twvd4jCVfIyA0M9DEi0Fd8525q7ffhWPv5GkMdVleWBK/A71N4V9Wysz\nloCX4Ui6Uro/0u6lgmVTUg9rIH8Dbymxvq6oHb++TLMvRqr+NQmhdb+TE9Mh3pTc\n2Ro8F2ityJr750YEKIHqJl/n7OEejMNMDzp1E7BaGcomBwRDAnJoRZ8b0ZsB3SQT\nf7cIi3a8y6C9MlSuXOVJrFb6WGzp2c/uZRHRUpFFOrLu4UVifuphBkslFMcXJq09\nWsUd5tSVP1GWMyEHBTjlokxUlh5OJCTtKSswp1+FcEyEb4LK+lTKSnipc4/nF8At\n42l1dpOWBJmpzSiy7iZmVNccPSlgAcE3PtMKBCJAA/VHW3kfGxKPFDvdrodvR/sT\nxLy1mNyHPgBYHlYGWL+Jg7Uy1Dng2tj3JBQRgBIEVIxj9zAOvBL0z8PfLKaJ3Hng\n4USKkGdNh5TIkhcnj6DUsawQPVOovvxCnzY+VU6jkEtJPsR1C4ylOFl50h1S4BON\nqrecha0VK0342d+IsWwn0F9b8m6F7TMecFc3mNSWF1mDHP5SqEvrVEgS34J0bRvX\nIsEUBdpKPSY5eFf6HLkHD0hw1GHw7y4aZRhhTq9fBkA5Exd7mS54X2zPT2QwY+bk\njvKYd0YMeFj/ScRQPWgDajPrGhCi4NQCqbkTnEu4dk20oIBiKIU=\n=Os5E\n-----END PGP SIGNATURE-----", "payload": "tree 9ed9807c623be718d6aa6e00640b2e8916e2b7fb\nparent b7e8b9a6b8f25f269bc141f2749555418ab0f370\nauthor Kartavya Vashishtha <sendtokartavya@gmail.com> 1662817010 +0530\ncommitter Kartavya Vashishtha <sendtokartavya@gmail.com> 1662821026 +0530\n\nwip\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2584d48508a0a8cef8794eccfe30db583948eb96", "html_url": "https://github.com/rust-lang/rust/commit/2584d48508a0a8cef8794eccfe30db583948eb96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2584d48508a0a8cef8794eccfe30db583948eb96/comments", "author": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7e8b9a6b8f25f269bc141f2749555418ab0f370", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e8b9a6b8f25f269bc141f2749555418ab0f370", "html_url": "https://github.com/rust-lang/rust/commit/b7e8b9a6b8f25f269bc141f2749555418ab0f370"}], "stats": {"total": 697, "additions": 463, "deletions": 234}, "files": [{"sha": "696fd50b5cb2d24b181c38c2a0880dfdb92f7a6b", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -0,0 +1,209 @@\n+use ide_db::{syntax_helpers::{format_string::is_format_string, format_string_exprs::{parse_format_exprs, Arg}}, assists::{AssistId, AssistKind}};\n+use itertools::Itertools;\n+use syntax::{ast, AstToken, AstNode, NodeOrToken, SyntaxKind::COMMA, TextRange};\n+\n+// Assist: move_format_string_arg\n+//\n+// Move an expression out of a format string.\n+//\n+// ```\n+// fn main() {\n+//     println!(\"{x + 1}$0\");\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     println!(\"{a}\", a$0 = x + 1);\n+// }\n+// ```\n+\n+use crate::{AssistContext, /* AssistId, AssistKind, */ Assists};\n+\n+pub(crate) fn move_format_string_arg (acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let t = ctx.find_token_at_offset::<ast::String>()?;\n+    let tt = t.syntax().parent_ancestors().find_map(ast::TokenTree::cast)?;\n+\n+    let expanded_t = ast::String::cast(ctx.sema.descend_into_macros_with_kind_preference(t.syntax().clone()))?;\n+\n+    if !is_format_string(&expanded_t) {\n+        return None;\n+    }\n+\n+    let target = tt.syntax().text_range();\n+    let extracted_args = parse_format_exprs(&t).ok()?;\n+    let str_range = t.syntax().text_range();\n+\n+    let tokens =\n+        tt.token_trees_and_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .collect_vec();\n+\n+    acc.add(AssistId(\"move_format_string_arg\", AssistKind::QuickFix), \"Extract format args\", target, |edit| {\n+        let mut existing_args: Vec<String> = vec![];\n+        let mut current_arg = String::new();\n+\n+        if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] = tokens.as_slice() {\n+            for t in tokens {\n+                if t.kind() == COMMA {\n+                    existing_args.push(current_arg.trim().into());\n+                    current_arg.clear();\n+                } else {\n+                    current_arg.push_str(t.text());\n+                }\n+            }\n+            existing_args.push(current_arg.trim().into());\n+\n+            // delete everything after the format string to the end bracket\n+            // we're going to insert the new arguments later\n+            edit.delete(TextRange::new(format_string.text_range().end(), end_bracket.text_range().start()));\n+        }\n+\n+        let mut existing_args = existing_args.into_iter();\n+\n+        // insert cursor at end of format string\n+        edit.insert(str_range.end(), \"$0\");\n+        let mut placeholder_idx = 1;\n+        let mut args = String::new();\n+\n+        for (text, extracted_args) in extracted_args {\n+            // remove expr from format string\n+            edit.delete(text);\n+\n+            args.push_str(\", \");\n+\n+            match extracted_args {\n+                Arg::Expr(s) => {\n+                    // insert arg\n+                    args.push_str(&s);\n+                },\n+                Arg::Placeholder => {\n+                    // try matching with existing argument\n+                    match existing_args.next() {\n+                        Some(ea) => {\n+                            args.push_str(&ea);\n+                        },\n+                        None => {\n+                            // insert placeholder\n+                            args.push_str(&format!(\"${placeholder_idx}\"));\n+                            placeholder_idx += 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        edit.insert(str_range.end(), args);\n+    });\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::check_assist;\n+\n+    const MACRO_DECL: &'static str = r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\"#;\n+\n+    fn add_macro_decl (s: &'static str) -> String {\n+        MACRO_DECL.to_string() + s\n+    }\n+\n+    #[test]\n+    fn multiple_middle_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {}$0\", y + 2, 2);\n+}\n+\"#),\n+\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, y + 2, x + 1, 2);\n+}\n+\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn single_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{obj.value:b}$0\",);\n+}\n+\"#),\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{:b}\"$0, obj.value);\n+}\n+\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_middle_placeholders_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {} {}$0\", y + 2, 2);\n+}\n+\"#),\n+\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {:b} {} {}\"$0, y + 2, x + 1, 2, $1);\n+}\n+\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_trailing_args() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+}\n+\"#),\n+\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#),\n+        );\n+    }\n+\n+    #[test]\n+    fn improper_commas() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1,);\n+}\n+\"#),\n+\n+            &add_macro_decl(r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#),\n+        );\n+    }\n+\n+}"}, {"sha": "f881be9cf6d03fd84ce8ca447f42046de60eb7e5", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod move_format_string_arg;\n     mod generate_constant;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;"}, {"sha": "fa88abd6c5549df7796873cdda432363ddb8d08b", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -1591,6 +1591,23 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     )\n }\n \n+#[test]\n+fn doctest_move_format_string_arg() {\n+    check_doc_test(\n+        \"move_format_string_arg\",\n+        r#####\"\n+fn main() {\n+    println!(\"{x + 1}$0\");\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    println!(\"{a}\", a$0 = x + 1);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_move_from_mod_rs() {\n     check_doc_test("}, {"sha": "89bfdac74d2170ea8806b7b7279d34e4c8065b0b", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 8, "deletions": 234, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -16,7 +16,7 @@\n //\n // image::https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif[]\n \n-use ide_db::SnippetCap;\n+use ide_db::{syntax_helpers::format_string_exprs::{parse_format_exprs, add_placeholders}, SnippetCap};\n use syntax::ast::{self, AstToken};\n \n use crate::{\n@@ -43,250 +43,24 @@ pub(crate) fn add_format_like_completions(\n     cap: SnippetCap,\n     receiver_text: &ast::String,\n ) {\n-    let input = match string_literal_contents(receiver_text) {\n-        // It's not a string literal, do not parse input.\n-        Some(input) => input,\n-        None => return,\n-    };\n-\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, dot_receiver) {\n         Some(it) => it,\n         None => return,\n     };\n-    let mut parser = FormatStrParser::new(input);\n \n-    if parser.parse().is_ok() {\n+    if let Ok((out, exprs)) = parse_format_exprs(receiver_text) {\n+        let exprs = add_placeholders(exprs.map(|e| e.1)).collect_vec();\n         for (label, macro_name) in KINDS {\n-            let snippet = parser.to_suggestion(macro_name);\n+            let snippet = format!(r#\"{}(\"{}\", {})\"#, macro_name, out, exprs.join(\", \"));\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n     }\n }\n \n-/// Checks whether provided item is a string literal.\n-fn string_literal_contents(item: &ast::String) -> Option<String> {\n-    let item = item.text();\n-    if item.len() >= 2 && item.starts_with('\\\"') && item.ends_with('\\\"') {\n-        return Some(item[1..item.len() - 1].to_owned());\n-    }\n-\n-    None\n-}\n-\n-/// Parser for a format-like string. It is more allowing in terms of string contents,\n-/// as we expect variable placeholders to be filled with expressions.\n-#[derive(Debug)]\n-pub(crate) struct FormatStrParser {\n-    input: String,\n-    output: String,\n-    extracted_expressions: Vec<String>,\n-    state: State,\n-    parsed: bool,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum State {\n-    NotExpr,\n-    MaybeExpr,\n-    Expr,\n-    MaybeIncorrect,\n-    FormatOpts,\n-}\n-\n-impl FormatStrParser {\n-    pub(crate) fn new(input: String) -> Self {\n-        Self {\n-            input,\n-            output: String::new(),\n-            extracted_expressions: Vec::new(),\n-            state: State::NotExpr,\n-            parsed: false,\n-        }\n-    }\n-\n-    pub(crate) fn parse(&mut self) -> Result<(), ()> {\n-        let mut current_expr = String::new();\n-\n-        let mut placeholder_id = 1;\n-\n-        // Count of open braces inside of an expression.\n-        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n-        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n-        let mut inexpr_open_count = 0;\n-\n-        // We need to escape '\\' and '$'. See the comments on `get_receiver_text()` for detail.\n-        let mut chars = self.input.chars().peekable();\n-        while let Some(chr) = chars.next() {\n-            match (self.state, chr) {\n-                (State::NotExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeExpr;\n-                }\n-                (State::NotExpr, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeIncorrect;\n-                }\n-                (State::NotExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-                (State::MaybeIncorrect, '}') => {\n-                    // It's okay, we met \"}}\".\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeIncorrect, _) => {\n-                    // Error in the string.\n-                    return Err(());\n-                }\n-                (State::MaybeExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, '}') => {\n-                    // This is an empty sequence '{}'. Replace it with placeholder.\n-                    self.output.push(chr);\n-                    self.extracted_expressions.push(format!(\"${}\", placeholder_id));\n-                    placeholder_id += 1;\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                    self.state = State::Expr;\n-                }\n-                (State::Expr, '}') => {\n-                    if inexpr_open_count == 0 {\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::NotExpr;\n-                    } else {\n-                        // We're closing one brace met before inside of the expression.\n-                        current_expr.push(chr);\n-                        inexpr_open_count -= 1;\n-                    }\n-                }\n-                (State::Expr, ':') if chars.peek().copied() == Some(':') => {\n-                    // path separator\n-                    current_expr.push_str(\"::\");\n-                    chars.next();\n-                }\n-                (State::Expr, ':') => {\n-                    if inexpr_open_count == 0 {\n-                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::FormatOpts;\n-                    } else {\n-                        // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n-                        current_expr.push(chr);\n-                    }\n-                }\n-                (State::Expr, '{') => {\n-                    current_expr.push(chr);\n-                    inexpr_open_count += 1;\n-                }\n-                (State::Expr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                }\n-                (State::FormatOpts, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::FormatOpts, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-            }\n-        }\n-\n-        if self.state != State::NotExpr {\n-            return Err(());\n-        }\n-\n-        self.parsed = true;\n-        Ok(())\n-    }\n-\n-    pub(crate) fn to_suggestion(&self, macro_name: &str) -> String {\n-        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n-\n-        let expressions_as_string = self.extracted_expressions.join(\", \");\n-        format!(r#\"{}(\"{}\", {})\"#, macro_name, self.output, expressions_as_string)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use expect_test::{expect, Expect};\n-\n-    fn check(input: &str, expect: &Expect) {\n-        let mut parser = FormatStrParser::new((*input).to_owned());\n-        let outcome_repr = if parser.parse().is_ok() {\n-            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n-            if parser.extracted_expressions.is_empty() {\n-                parser.output\n-            } else {\n-                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n-            }\n-        } else {\n-            // Parsing should fail, expected repr is \"-\".\n-            \"-\".to_owned()\n-        };\n-\n-        expect.assert_eq(&outcome_repr);\n-    }\n-\n-    #[test]\n-    fn format_str_parser() {\n-        let test_vector = &[\n-            (\"no expressions\", expect![[\"no expressions\"]]),\n-            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n-            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n-            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n-            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n-            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n-            (\"{malformed\", expect![[\"-\"]]),\n-            (\"malformed}\", expect![[\"-\"]]),\n-            (\"{{correct\", expect![[\"{{correct\"]]),\n-            (\"correct}}\", expect![[\"correct}}\"]]),\n-            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n-            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n-            (\"{incorrect}}\", expect![[\"-\"]]),\n-            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n-            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n-                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n-                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n-            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n-            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n-            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n-        ];\n-\n-        for (input, output) in test_vector {\n-            check(input, output)\n-        }\n-    }\n \n     #[test]\n     fn test_into_suggestion() {\n@@ -302,10 +76,10 @@ mod tests {\n         ];\n \n         for (kind, input, output) in test_vector {\n-            let mut parser = FormatStrParser::new((*input).to_owned());\n-            parser.parse().expect(\"Parsing must succeed\");\n-\n-            assert_eq!(&parser.to_suggestion(*kind), output);\n+            let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n+            let exprs = add_placeholders(exprs.map(|e| e.1)).collect_vec();;\n+            let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n+            assert_eq!(&snippet, output);\n         }\n     }\n }"}, {"sha": "e0bc0f89f0a1d14bdd54d384802ae8587311e41d", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -38,6 +38,7 @@ pub mod syntax_helpers {\n     pub mod node_ext;\n     pub mod insert_whitespace_into_node;\n     pub mod format_string;\n+    pub mod format_string_exprs;\n \n     pub use parser::LexedStr;\n }"}, {"sha": "b6b2eb268d33afda854aec3e294d54630f476f00", "filename": "crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2584d48508a0a8cef8794eccfe30db583948eb96/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=2584d48508a0a8cef8794eccfe30db583948eb96", "patch": "@@ -0,0 +1,227 @@\n+use syntax::{ast, TextRange, AstToken};\n+\n+#[derive(Debug)]\n+pub enum Arg {\n+    Placeholder,\n+    Expr(String)\n+}\n+\n+/**\n+ Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`].\n+ ```rust\n+ assert_eq!(vec![Arg::Expr(\"expr\"), Arg::Placeholder, Arg::Expr(\"expr\")], vec![\"expr\", \"$1\", \"expr\"])\n+ ```\n+*/\n+\n+pub fn add_placeholders (args: impl Iterator<Item = Arg>) -> impl Iterator<Item = String> {\n+    let mut placeholder_id = 1;\n+    args.map(move |a|\n+        match a {\n+            Arg::Expr(s) => s,\n+            Arg::Placeholder => {\n+                let s = format!(\"${placeholder_id}\");\n+                placeholder_id += 1;\n+                s\n+            }\n+        }\n+    )\n+}\n+\n+/**\n+ Parser for a format-like string. It is more allowing in terms of string contents,\n+ as we expect variable placeholders to be filled with expressions.\n+\n+ Built for completions and assists, and escapes `\\` and `$` in output.\n+ (See the comments on `get_receiver_text()` for detail.)\n+ Splits a format string that may contain expressions\n+ like\n+ ```rust\n+ assert_eq!(parse(\"{expr} {} {expr} \").unwrap(), (\"{} {} {}\", vec![Arg::Expr(\"expr\"), Arg::Placeholder, Arg::Expr(\"expr\")]));\n+ ```\n+*/\n+pub fn parse_format_exprs(input: &ast::String) -> Result<Vec<(TextRange, Arg)>, ()> {\n+    #[derive(Debug, Clone, Copy, PartialEq)]\n+    enum State {\n+        NotExpr,\n+        MaybeExpr,\n+        Expr,\n+        MaybeIncorrect,\n+        FormatOpts,\n+    }\n+\n+    let start = input.syntax().text_range().start();\n+\n+    let mut expr_start = start;\n+    let mut current_expr = String::new();\n+    let mut state = State::NotExpr;\n+    let mut extracted_expressions = Vec::new();\n+    let mut output = String::new();\n+\n+    // Count of open braces inside of an expression.\n+    // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+    // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+    let mut inexpr_open_count = 0;\n+\n+    let mut chars = input.text().chars().zip(0u32..).peekable();\n+    while let Some((chr, idx )) = chars.next() {\n+        match (state, chr) {\n+            (State::NotExpr, '{') => {\n+                output.push(chr);\n+                state = State::MaybeExpr;\n+            }\n+            (State::NotExpr, '}') => {\n+                output.push(chr);\n+                state = State::MaybeIncorrect;\n+            }\n+            (State::NotExpr, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+            (State::MaybeIncorrect, '}') => {\n+                // It's okay, we met \"}}\".\n+                output.push(chr);\n+                state = State::NotExpr;\n+            }\n+            (State::MaybeIncorrect, _) => {\n+                // Error in the string.\n+                return Err(());\n+            }\n+            (State::MaybeExpr, '{') => {\n+                output.push(chr);\n+                state = State::NotExpr;\n+            }\n+            (State::MaybeExpr, '}') => {\n+                // This is an empty sequence '{}'. Replace it with placeholder.\n+                output.push(chr);\n+                extracted_expressions.push((TextRange::empty(expr_start), Arg::Placeholder));\n+                state = State::NotExpr;\n+            }\n+            (State::MaybeExpr, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+                expr_start = start.checked_add(idx.into()).ok_or(())?;\n+                state = State::Expr;\n+            }\n+            (State::Expr, '}') => {\n+                if inexpr_open_count == 0 {\n+                    output.push(chr);\n+                    extracted_expressions.push((TextRange::new(expr_start, start.checked_add(idx.into()).ok_or(())?), Arg::Expr(current_expr.trim().into())));\n+                    current_expr = String::new();\n+                    state = State::NotExpr;\n+                } else {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                }\n+            }\n+            (State::Expr, ':') if matches!(chars.peek(), Some((':', _))) => {\n+                // path separator\n+                current_expr.push_str(\"::\");\n+                chars.next();\n+            }\n+            (State::Expr, ':') => {\n+                if inexpr_open_count == 0 {\n+                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                    output.push(chr);\n+                    extracted_expressions.push((TextRange::new(expr_start, start.checked_add(idx.into()).ok_or(())?), Arg::Expr(current_expr.trim().into())));\n+                    current_expr = String::new();\n+                    state = State::FormatOpts;\n+                } else {\n+                    // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n+                    current_expr.push(chr);\n+                }\n+            }\n+            (State::Expr, '{') => {\n+                current_expr.push(chr);\n+                inexpr_open_count += 1;\n+            }\n+            (State::Expr, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+            }\n+            (State::FormatOpts, '}') => {\n+                output.push(chr);\n+                state = State::NotExpr;\n+            }\n+            (State::FormatOpts, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+        }\n+    }\n+\n+    if state != State::NotExpr {\n+        return Err(());\n+    }\n+\n+    Ok(extracted_expressions)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check(input: &str, expect: &Expect) {\n+        let mut parser = FormatStrParser::new((*input).to_owned());\n+        let outcome_repr = if parser.parse().is_ok() {\n+            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n+            if parser.extracted_expressions.is_empty() {\n+                parser.output\n+            } else {\n+                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n+            }\n+        } else {\n+            // Parsing should fail, expected repr is \"-\".\n+            \"-\".to_owned()\n+        };\n+\n+        expect.assert_eq(&outcome_repr);\n+    }\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", expect![[\"no expressions\"]]),\n+            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n+            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n+            (\"{malformed\", expect![[\"-\"]]),\n+            (\"malformed}\", expect![[\"-\"]]),\n+            (\"{{correct\", expect![[\"{{correct\"]]),\n+            (\"correct}}\", expect![[\"correct}}\"]]),\n+            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n+            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{incorrect}}\", expect![[\"-\"]]),\n+            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n+            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n+            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n+            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n+            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            check(input, output)\n+        }\n+    }\n+}"}]}