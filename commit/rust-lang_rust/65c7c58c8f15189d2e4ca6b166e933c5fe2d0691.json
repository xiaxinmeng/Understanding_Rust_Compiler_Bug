{"sha": "65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YzdjNThjOGYxNTE4OWQyZTRjYTZiMTY2ZTkzM2M1ZmUyZDA2OTE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T04:07:55Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T16:22:23Z"}, "message": "std: remove {all*,any*,count} in favour of iterators", "tree": {"sha": "499bb3cc4eab7f6be17a218c1a3dc2ee077f5ea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/499bb3cc4eab7f6be17a218c1a3dc2ee077f5ea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "html_url": "https://github.com/rust-lang/rust/commit/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce4f63dcee8997f8d2881e6e3cf9e04db085bd64", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4f63dcee8997f8d2881e6e3cf9e04db085bd64", "html_url": "https://github.com/rust-lang/rust/commit/ce4f63dcee8997f8d2881e6e3cf9e04db085bd64"}], "stats": {"total": 319, "additions": 78, "deletions": 241}, "files": [{"sha": "23b7cdc09974780cc5fee860b3e272ac52e71232", "filename": "src/libextra/par.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cast;\n use core::ptr;\n use core::sys;\n@@ -122,25 +123,24 @@ pub fn alli<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n-    do vec::all(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> bool = |base, slice| {\n-            vec::alli(slice, |i, x| {\n-                f(i + base, x)\n-            })\n+            slice.iter().enumerate().all(|(i, x)| f(i + base, x))\n         };\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().all(|&x| x)\n }\n \n /// Returns true if the function holds for any elements in the vector.\n pub fn any<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n-    do vec::any(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool =\n-            |_, slice| vec::any(slice, |x| f(x));\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().any(|&x| x)\n }"}, {"sha": "49db0ee7bd30af73891c106678c270dbc1b0b801", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -172,6 +172,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::vec;\n use syntax::ast;\n@@ -798,7 +799,7 @@ pub fn enter_region<'r>(bcx: block,\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n-        if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n+        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -965,7 +966,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.each |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !vec::any(*idents, |x| *x == field_ident) {\n+            if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }\n@@ -976,11 +977,11 @@ pub fn pats_require_rooting(bcx: block,\n                             m: &[@Match],\n                             col: uint)\n                          -> bool {\n-    vec::any(m, |br| {\n+    do m.iter().any |br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n-    })\n+    }\n }\n \n pub fn root_pats_as_necessary(mut bcx: block,\n@@ -1005,12 +1006,12 @@ pub fn root_pats_as_necessary(mut bcx: block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        vec::any($m, |br| {\n+        do ($m).iter().any |br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n             }\n-        })\n+        }\n     )\n )\n \n@@ -1031,7 +1032,7 @@ pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n-    vec::any(m, |br| {\n+    do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n@@ -1043,7 +1044,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n             }\n             _ => false\n         }\n-    })\n+    }\n }\n \n pub type mk_fail = @fn() -> BasicBlockRef;"}, {"sha": "169cd294b43c4324d837e0d7b889c74942f22cd7", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -32,6 +32,7 @@ use middle::ty::{FnSig};\n use middle::typeck;\n use util::ppaux::{Repr,ty_to_str};\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -75,7 +76,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n                                Some(param_uses));\n-    if vec::any(hash_id.params,\n+    if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }"}, {"sha": "e8501904c6f25549d278cda4b04f7005c015eba3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::enum_set::{EnumSet, CLike};\n \n+use core::iterator::IteratorUtil;\n use core::cast;\n use core::cmp;\n use core::hashmap::{HashMap, HashSet};\n@@ -2355,8 +2356,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n           ty_struct(did, ref substs) => {\n               seen.push(did);\n-              let r = vec::any(struct_fields(cx, did, substs),\n-                               |f| type_requires(cx, seen, r_ty, f.mt.ty));\n+              let fields = struct_fields(cx, did, substs);\n+              let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n               seen.pop();\n             r\n           }\n@@ -2372,12 +2373,12 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n-                let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n-                    vec::any(variant.args, |aty| {\n+                let r = vec::len(*vs) > 0u && do vs.iter().all |variant| {\n+                    do variant.args.iter().any |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n-                    })\n-                });\n+                    }\n+                };\n                 seen.pop();\n                 r\n             }\n@@ -2519,11 +2520,12 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_param(_) => result = false,\n       ty_opaque_closure_ptr(_) => result = true,\n       ty_struct(did, ref substs) => {\n-        result = vec::all(lookup_struct_fields(cx, did), |f| {\n+        let fields = lookup_struct_fields(cx, did);\n+        result = do fields.iter().all |f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n-        });\n+        };\n       }\n \n       ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) => {\n@@ -2569,7 +2571,7 @@ pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n             if variants.len() == 0 {\n                 false\n             } else {\n-                variants.all(|v| v.args.len() == 0)\n+                variants.iter().all(|v| v.args.len() == 0)\n             }\n         }\n         _ => false"}, {"sha": "9eb5f8159545efc270fa7bef855a5f920cc4c2c0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -3065,7 +3065,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::node_id) {\n                 return;\n             }\n             let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n-            if !vec::all(fields,\n+            if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n                 return;"}, {"sha": "309e207eaaa8855d875400cf80efc195fbfc4463", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -326,7 +326,7 @@ pub trait IteratorUtil<A> {\n     /// assert!(a.iter().all(|&x| *x > 0));\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ~~~\n-    fn all(&mut self, f: &fn(&A) -> bool) -> bool;\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool;\n \n     /// Tests whether any element of an iterator satisfies the specified\n     /// predicate.\n@@ -341,7 +341,7 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.any(|&x| *x == 3));\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any(&mut self, f: &fn(&A) -> bool) -> bool;\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -462,14 +462,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     fn count(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n \n     #[inline(always)]\n-    fn all(&mut self, f: &fn(&A) -> bool) -> bool {\n-        for self.advance |x| { if !f(&x) { return false; } }\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+        for self.advance |x| { if !f(x) { return false; } }\n         return true;\n     }\n \n     #[inline(always)]\n-    fn any(&mut self, f: &fn(&A) -> bool) -> bool {\n-        for self.advance |x| { if f(&x) { return true; } }\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n+        for self.advance |x| { if f(x) { return true; } }\n         return false;\n     }\n }\n@@ -1080,18 +1080,18 @@ mod tests {\n     #[test]\n     fn test_all() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().all(|&x| *x < 10));\n+        assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n-        assert!(!v.iter().all(|&x| *x > 100));\n+        assert!(!v.iter().all(|&x| x > 100));\n         assert!(v.slice(0, 0).iter().all(|_| fail!()));\n     }\n \n     #[test]\n     fn test_any() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().any(|&x| *x < 10));\n+        assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n-        assert!(!v.iter().any(|&x| *x > 100));\n+        assert!(!v.iter().any(|&x| x > 100));\n         assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }\n }"}, {"sha": "d0345a3953e6172f8d8ea1c7f51a883367b65031", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -2883,6 +2883,7 @@ impl<'self> Iterator<char> for StrCharIterator<'self> {\n \n #[cfg(test)]\n mod tests {\n+    use iterator::IteratorUtil;\n     use container::Container;\n     use char;\n     use option::Some;\n@@ -2977,7 +2978,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n         t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n@@ -2995,7 +2996,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3010,7 +3011,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', 0u, [~\"abc.hello.there\"]);\n         t(\"abc.hello.there\", '.', 1u, [~\"abc\", ~\"hello.there\"]);\n@@ -3037,7 +3038,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3055,7 +3056,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3069,7 +3070,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n         t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n@@ -3088,7 +3089,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3100,7 +3101,7 @@ mod tests {\n         fn t<'a>(s: &str, sep: &'a str, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"--1233345--\", \"12345\", [~\"--1233345--\"]);\n         t(\"abc::hello::there\", \"::\", [~\"abc\", ~\"hello\", ~\"there\"]);\n@@ -3124,7 +3125,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3140,7 +3141,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3159,7 +3160,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(lf, each_line, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n@@ -3179,7 +3180,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n@@ -3193,7 +3194,7 @@ mod tests {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"\", 0, []);\n         t(\"\", 15, []);"}, {"sha": "29f2dba77a6e9d819ba3f83c9b139c3228771b1c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 172, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -1124,80 +1124,12 @@ pub fn foldr<'a, T, U>(v: &'a [T], mut z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n     return z;\n }\n \n-/**\n- * Return true if a predicate matches any elements\n- *\n- * If the vector contains no elements then false is returned.\n- */\n-pub fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n-    for each(v) |elem| { if f(elem) { return true; } }\n-    false\n-}\n-\n-/**\n- * Return true if a predicate matches any elements in both vectors.\n- *\n- * If the vectors contains no elements then false is returned.\n- */\n-pub fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: &fn(a: &T, b: &U) -> bool) -> bool {\n-    let v0_len = len(v0);\n-    let v1_len = len(v1);\n-    let mut i = 0u;\n-    while i < v0_len && i < v1_len {\n-        if f(&v0[i], &v1[i]) { return true; };\n-        i += 1u;\n-    }\n-    false\n-}\n-\n-/**\n- * Return true if a predicate matches all elements\n- *\n- * If the vector contains no elements then true is returned.\n- */\n-pub fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(elem) { return false; } }\n-    true\n-}\n-\n-/**\n- * Return true if a predicate matches all elements\n- *\n- * If the vector contains no elements then true is returned.\n- */\n-pub fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n-    true\n-}\n-\n-/**\n- * Return true if a predicate matches all elements in both vectors.\n- *\n- * If the vectors are not the same size then false is returned.\n- */\n-pub fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: &fn(t: &T, u: &U) -> bool) -> bool {\n-    let v0_len = len(v0);\n-    if v0_len != len(v1) { return false; }\n-    let mut i = 0u;\n-    while i < v0_len { if !f(&v0[i], &v1[i]) { return false; }; i += 1u; }\n-    true\n-}\n-\n /// Return true if a vector contains an element with the given value\n pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     false\n }\n \n-/// Returns the number of elements that are equal to a given value\n-pub fn count<T:Eq>(v: &[T], x: &T) -> uint {\n-    let mut cnt = 0u;\n-    for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n-    cnt\n-}\n-\n /**\n  * Search for the first element that matches a given predicate\n  *\n@@ -2074,7 +2006,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      *     If the vector is empty, true is returned.\n      */\n     fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n-        alli(*self, f)\n+        self.iter().enumerate().all(|(i, t)| f(i,t))\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n@@ -3558,33 +3490,6 @@ mod tests {\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n-    #[test]\n-    fn test_any_and_all() {\n-        assert!(any([1u, 2u, 3u], is_three));\n-        assert!(!any([0u, 1u, 2u], is_three));\n-        assert!(any([1u, 2u, 3u, 4u, 5u], is_three));\n-        assert!(!any([1u, 2u, 4u, 5u, 6u], is_three));\n-\n-        assert!(all([3u, 3u, 3u], is_three));\n-        assert!(!all([3u, 3u, 2u], is_three));\n-        assert!(all([3u, 3u, 3u, 3u, 3u], is_three));\n-        assert!(!all([3u, 3u, 0u, 1u, 2u], is_three));\n-    }\n-\n-    #[test]\n-    fn test_any2_and_all2() {\n-\n-        assert!(any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert!(any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert!(!any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert!(any2([2u, 4u, 6u], [2u, 4u], is_equal));\n-\n-        assert!(all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert!(!all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert!(!all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert!(!all2([2u, 4u, 6u], [2u, 4u], is_equal));\n-    }\n-\n     #[test]\n     fn test_zip_unzip() {\n         let v1 = ~[1, 2, 3];\n@@ -4361,81 +4266,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_any_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do any(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_any2_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do any(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_all_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do all(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_alli_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do alli(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_all2_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do all2(v, v) |_elt1, _elt2| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -4617,7 +4447,7 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iterator() {\n         use iterator::*;\n-        let mut xs = [1, 2, 3, 4, 5];\n+        let mut xs = [1u, 2, 3, 4, 5];\n         for xs.mut_rev_iter().enumerate().advance |(i,x)| {\n             *x += i;\n         }"}, {"sha": "684d2ac5009b521196649239258348db48a07e2a", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -21,6 +21,7 @@ use extra::arc;\n use extra::time;\n use extra::deque::Deque;\n use extra::par;\n+use std::iterator::IteratorUtil;\n use std::hashmap::HashSet;\n use std::int::abs;\n use std::io;\n@@ -111,7 +112,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && vec::any(graph[k], |i| {\n+        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n             *i != k as node_id\n         }) {\n             keys.insert(k as node_id);\n@@ -187,7 +188,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     let mut i = 0;\n-    while vec::any(colors, is_gray) {\n+    while colors.iter().any(is_gray) {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;"}, {"sha": "ae6e04b30180748fb8b9653d61d6d89798ffd962", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::IteratorUtil;\n use std::vec;\n \n // Check usage and precedence of block arguments in expressions:\n@@ -20,28 +21,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do vec::any(v) |e| { e.is_negative() };\n+    let mut any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do vec::any(v) |e| { e.is_negative() };\n+    any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n     let abs_v = do vec::map(v) |e| { e.abs() };\n-    assert!(do vec::all(abs_v) |e| { e.is_positive() });\n-    assert!(!do vec::any(abs_v) |e| { e.is_negative() });\n+    assert!(do abs_v.iter().all |e| { e.is_positive() });\n+    assert!(!do abs_v.iter().any |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do vec::any(v) |e| { e.is_positive() } {\n+    if !do v.iter().any |e| { e.is_positive() } {\n         assert!(false);\n     }\n-    match do vec::all(v) |e| { e.is_negative() } {\n+    match do v.iter().all |e| { e.is_negative() } {\n         true => { fail!(\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do vec::any(v) |e| { e.is_negative() } => {\n+      _ if do v.iter().any |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(\"wrong answer.\");\n@@ -58,7 +59,7 @@ pub fn main() {\n \n     // In the tail of a block\n     let w =\n-        if true { do vec::any(abs_v) |e| { e.is_positive() } }\n+        if true { do abs_v.iter().any |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}, {"sha": "4346d242c06bfd746d641ccde5d11371bfa82207", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -10,6 +10,7 @@\n \n // xfail-fast\n \n+use std::iterator::IteratorUtil;\n use std::cmp::Eq;\n use std::vec;\n \n@@ -54,7 +55,8 @@ fn ret_deep() -> ~str {\n \n pub fn main() {\n     let mut last = 0;\n-    for vec::all(~[1, 2, 3, 4, 5, 6, 7]) |e| {\n+    let v = ~[1, 2, 3, 4, 5, 6, 7];\n+    for v.iter().all |e| {\n         last = *e;\n         if *e == 5 { break; }\n         if *e % 2 == 1 { loop; }"}, {"sha": "cbfaa87b69952aa7731adc99cc1aaa78557376d0", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "patch": "@@ -13,7 +13,7 @@\n \n extern mod extra;\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n #[test]\n #[ignore(cfg(ignorecfg))]\n@@ -30,11 +30,9 @@ fn checktests() {\n     // Pull the tests out of the secreturn test module\n     let tests = __test::tests;\n \n-    assert!(vec::any(\n-        tests,\n-        |t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n+    assert!(\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n \n-    assert!(vec::any(\n-        tests,\n-        |t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n+    assert!(\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n }"}]}