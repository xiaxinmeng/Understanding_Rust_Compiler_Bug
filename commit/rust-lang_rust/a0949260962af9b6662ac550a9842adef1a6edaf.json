{"sha": "a0949260962af9b6662ac550a9842adef1a6edaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOTQ5MjYwOTYyYWY5YjY2NjJhYzU1MGE5ODQyYWRlZjFhNmVkYWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-25T20:41:08Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-27T17:48:06Z"}, "message": "rm -rf librustc_ast_borrowck", "tree": {"sha": "1ee5987422e3993bde613c231cb77cd799ed766e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee5987422e3993bde613c231cb77cd799ed766e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0949260962af9b6662ac550a9842adef1a6edaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0949260962af9b6662ac550a9842adef1a6edaf", "html_url": "https://github.com/rust-lang/rust/commit/a0949260962af9b6662ac550a9842adef1a6edaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0949260962af9b6662ac550a9842adef1a6edaf/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a37fe2de697bb1a9d304e4e811836e125f944cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a37fe2de697bb1a9d304e4e811836e125f944cd5", "html_url": "https://github.com/rust-lang/rust/commit/a37fe2de697bb1a9d304e4e811836e125f944cd5"}], "stats": {"total": 5637, "additions": 0, "deletions": 5637}, "files": [{"sha": "40c4c1fc3fee692ae9d3d88a206a88335b0255a0", "filename": "src/librustc_ast_borrowck/Cargo.toml", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2FCargo.toml?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,20 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_ast_borrowck\"\n-version = \"0.0.0\"\n-edition = \"2018\"\n-\n-[lib]\n-name = \"rustc_ast_borrowck\"\n-path = \"lib.rs\"\n-test = false\n-doctest = false\n-\n-[dependencies]\n-log = \"0.4\"\n-syntax_pos = { path = \"../libsyntax_pos\" }\n-# for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n-# refers to the borrowck-specific graphviz adapter traits.\n-dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n-rustc = { path = \"../librustc\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "3f2175921d48c45a24f22a4a3055d8577956b214", "filename": "src/librustc_ast_borrowck/borrowck/README.md", "status": "removed", "additions": 0, "deletions": 1167, "changes": 1167, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2FREADME.md?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,1167 +0,0 @@\n-% The Borrow Checker\n-\n-> WARNING: This README is more or less obsolete, and will be removed\n-> soon! The new system is described in the [rustc guide].\n-\n-[rustc guide]: https://rust-lang.github.io/rustc-guide/borrow_check.html\n-\n-This pass has the job of enforcing memory safety. This is a subtle\n-topic. This docs aim to explain both the practice and the theory\n-behind the borrow checker. They start with a high-level overview of\n-how it works, and then proceed to dive into the theoretical\n-background. Finally, they go into detail on some of the more subtle\n-aspects.\n-\n-# Table of contents\n-\n-These docs are long. Search for the section you are interested in.\n-\n-- Overview\n-- Formal model\n-- Borrowing and loans\n-- Moves and initialization\n-- Drop flags and structural fragments\n-- Future work\n-\n-# Overview\n-\n-The borrow checker checks one function at a time. It operates in two\n-passes. The first pass, called `gather_loans`, walks over the function\n-and identifies all of the places where borrows (e.g., `&` expressions\n-and `ref` bindings) and moves (copies or captures of a linear value)\n-occur. It also tracks initialization sites. For each borrow and move,\n-it checks various basic safety conditions at this time (for example,\n-that the lifetime of the borrow doesn't exceed the lifetime of the\n-value being borrowed, or that there is no move out of an `&T`\n-referent).\n-\n-It then uses the dataflow module to propagate which of those borrows\n-may be in scope at each point in the procedure. A loan is considered\n-to come into scope at the expression that caused it and to go out of\n-scope when the lifetime of the resulting reference expires.\n-\n-Once the in-scope loans are known for each point in the program, the\n-borrow checker walks the IR again in a second pass called\n-`check_loans`. This pass examines each statement and makes sure that\n-it is safe with respect to the in-scope loans.\n-\n-# Formal model\n-\n-Throughout the docs we'll consider a simple subset of Rust in which\n-you can only borrow from places, defined like so:\n-\n-```text\n-P = x | P.f | *P\n-```\n-\n-Here `x` represents some variable, `P.f` is a field reference,\n-and `*P` is a pointer dereference. There is no auto-deref or other\n-niceties. This means that if you have a type like:\n-\n-```rust\n-struct S { f: i32 }\n-```\n-\n-and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n-to an `P` of `(*a).f`.\n-\n-Here is the formal grammar for the types we'll consider:\n-\n-```text\n-TY = i32 | bool | S<'LT...> | Box<TY> | & 'LT MQ TY\n-MQ = mut | imm\n-```\n-\n-Most of these types should be pretty self explanatory. Here `S` is a\n-struct name and we assume structs are declared like so:\n-\n-```text\n-SD = struct S<'LT...> { (f: TY)... }\n-```\n-\n-# Borrowing and loans\n-\n-## An intuitive explanation\n-\n-### Issuing loans\n-\n-Now, imagine we had a program like this:\n-\n-```rust\n-struct Foo { f: i32, g: i32 }\n-...\n-'a: {\n-    let mut x: Box<Foo> = ...;\n-    let y = &mut (*x).f;\n-    x = ...;\n-}\n-```\n-\n-This is of course dangerous because mutating `x` will free the old\n-value and hence invalidate `y`. The borrow checker aims to prevent\n-this sort of thing.\n-\n-#### Loans and restrictions\n-\n-The way the borrow checker works is that it analyzes each borrow\n-expression (in our simple model, that's stuff like `&P`, though in\n-real life there are a few other cases to consider). For each borrow\n-expression, it computes a `Loan`, which is a data structure that\n-records (1) the value being borrowed, (2) the mutability and scope of\n-the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n-struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n-follows:\n-\n-```text\n-LOAN = (P, LT, MQ, RESTRICTION*)\n-RESTRICTION = (P, ACTION*)\n-ACTION = MUTATE | CLAIM | FREEZE\n-```\n-\n-Here the `LOAN` tuple defines the place `P` being borrowed; the\n-lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n-list of restrictions. The restrictions indicate actions which, if\n-taken, could invalidate the loan and lead to type safety violations.\n-\n-Each `RESTRICTION` is a pair of a restrictive place `P` (which will\n-either be the path that was borrowed or some prefix of the path that\n-was borrowed) and a set of restricted actions.  There are three kinds\n-of actions that may be restricted for the path `P`:\n-\n-- `MUTATE` means that `P` cannot be assigned to;\n-- `CLAIM` means that the `P` cannot be borrowed mutably;\n-- `FREEZE` means that the `P` cannot be borrowed immutably;\n-\n-Finally, it is never possible to move from a place that appears in a\n-restriction. This implies that the \"empty restriction\" `(P, [])`,\n-which contains an empty set of actions, still has a purpose---it\n-prevents moves from `P`. I chose not to make `MOVE` a fourth kind of\n-action because that would imply that sometimes moves are permitted\n-from restricted values, which is not the case.\n-\n-#### Example\n-\n-To give you a better feeling for what kind of restrictions derived\n-from a loan, let's look at the loan `L` that would be issued as a\n-result of the borrow `&mut (*x).f` in the example above:\n-\n-```text\n-L = ((*x).f, 'a, mut, RS) where\n-    RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n-          (*x, [MUTATE, CLAIM, FREEZE]),\n-          (x, [MUTATE, CLAIM, FREEZE])]\n-```\n-\n-The loan states that the expression `(*x).f` has been loaned as\n-mutable for the lifetime `'a`. Because the loan is mutable, that means\n-that the value `(*x).f` may be mutated via the newly created reference\n-(and *only* via that pointer). This is reflected in the\n-restrictions `RS` that accompany the loan.\n-\n-The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n-the lender may not mutate, freeze, nor alias `(*x).f`. Mutation is\n-illegal because `(*x).f` is only supposed to be mutated via the new\n-reference, not by mutating the original path `(*x).f`. Freezing is\n-illegal because the path now has an `&mut` alias; so even if we the\n-lender were to consider `(*x).f` to be immutable, it might be mutated\n-via this alias. They will be enforced for the lifetime `'a` of the\n-loan. After the loan expires, the restrictions no longer apply.\n-\n-The second restriction on `*x` is interesting because it does not\n-apply to the path that was lent (`(*x).f`) but rather to a prefix of\n-the borrowed path. This is due to the rules of inherited mutability:\n-if the user were to assign to (or freeze) `*x`, they would indirectly\n-overwrite (or freeze) `(*x).f`, and thus invalidate the reference\n-that was created. In general it holds that when a path is\n-lent, restrictions are issued for all the owning prefixes of that\n-path. In this case, the path `*x` owns the path `(*x).f` and,\n-because `x` has ownership, the path `x` owns the path `*x`.\n-Therefore, borrowing `(*x).f` yields restrictions on both\n-`*x` and `x`.\n-\n-### Checking for illegal assignments, moves, and reborrows\n-\n-Once we have computed the loans introduced by each borrow, the borrow\n-checker uses a data flow propagation to compute the full set of loans\n-in scope at each expression and then uses that set to decide whether\n-that expression is legal.  Remember that the scope of loan is defined\n-by its lifetime LT.  We sometimes say that a loan which is in-scope at\n-a particular point is an \"outstanding loan\", and the set of\n-restrictions included in those loans as the \"outstanding\n-restrictions\".\n-\n-The kinds of expressions which in-scope loans can render illegal are:\n-- *assignments* (`lv = v`): illegal if there is an in-scope restriction\n-  against mutating `lv`;\n-- *moves*: illegal if there is any in-scope restriction on `lv` at all;\n-- *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n-  against claiming `lv`;\n-- *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n-  against freezing `lv`.\n-\n-## Formal rules\n-\n-Now that we hopefully have some kind of intuitive feeling for how the\n-borrow checker works, let's look a bit more closely now at the precise\n-conditions that it uses.\n-\n-I will present the rules in a modified form of standard inference\n-rules, which looks as follows:\n-\n-```text\n-PREDICATE(X, Y, Z)                  // Rule-Name\n-  Condition 1\n-  Condition 2\n-  Condition 3\n-```\n-\n-The initial line states the predicate that is to be satisfied.  The\n-indented lines indicate the conditions that must be met for the\n-predicate to be satisfied. The right-justified comment states the name\n-of this rule: there are comments in the borrowck source referencing\n-these names, so that you can cross reference to find the actual code\n-that corresponds to the formal rule.\n-\n-### Invariants\n-\n-I want to collect, at a high-level, the invariants the borrow checker\n-maintains. I will give them names and refer to them throughout the\n-text. Together these invariants are crucial for the overall soundness\n-of the system.\n-\n-**Mutability requires uniqueness.** To mutate a path\n-\n-**Unique mutability.** There is only one *usable* mutable path to any\n-given memory at any given time. This implies that when claiming memory\n-with an expression like `p = &mut x`, the compiler must guarantee that\n-the borrowed value `x` can no longer be mutated so long as `p` is\n-live. (This is done via restrictions, read on.)\n-\n-**.**\n-\n-\n-### The `gather_loans` pass\n-\n-We start with the `gather_loans` pass, which walks the AST looking for\n-borrows.  For each borrow, there are three bits of information: the\n-place `P` being borrowed and the mutability `MQ` and lifetime `LT`\n-of the resulting pointer. Given those, `gather_loans` applies four\n-validity tests:\n-\n-1. `MUTABILITY(P, MQ)`: The mutability of the reference is\n-compatible with the mutability of `P` (i.e., not borrowing immutable\n-data as mutable).\n-\n-2. `ALIASABLE(P, MQ)`: The aliasability of the reference is\n-compatible with the aliasability of `P`. The goal is to prevent\n-`&mut` borrows of aliasability data.\n-\n-3. `LIFETIME(P, LT, MQ)`: The lifetime of the borrow does not exceed\n-the lifetime of the value being borrowed.\n-\n-4. `RESTRICTIONS(P, LT, ACTIONS) = RS`: This pass checks and computes the\n-restrictions to maintain memory safety. These are the restrictions\n-that will go into the final loan. We'll discuss in more detail below.\n-\n-## Checking mutability\n-\n-Checking mutability is fairly straightforward. We just want to prevent\n-immutable data from being borrowed as mutable. Note that it is ok to borrow\n-mutable data as immutable, since that is simply a freeze. The judgement\n-`MUTABILITY(P, MQ)` means the mutability of `P` is compatible with a borrow\n-of mutability `MQ`. The Rust code corresponding to this predicate is the\n-function `check_mutability` in `middle::borrowck::gather_loans`.\n-\n-### Checking mutability of variables\n-\n-*Code pointer:* Function `check_mutability()` in `gather_loans/mod.rs`,\n-but also the code in `mem_categorization`.\n-\n-Let's begin with the rules for variables, which state that if a\n-variable is declared as mutable, it may be borrowed any which way, but\n-otherwise the variable must be borrowed as immutable:\n-\n-```text\n-MUTABILITY(X, MQ)                   // M-Var-Mut\n-  DECL(X) = mut\n-\n-MUTABILITY(X, imm)                  // M-Var-Imm\n-  DECL(X) = imm\n-```\n-\n-### Checking mutability of owned content\n-\n-Fields and boxes inherit their mutability from\n-their base expressions, so both of their rules basically\n-delegate the check to the base expression `P`:\n-\n-```text\n-MUTABILITY(P.f, MQ)                // M-Field\n-  MUTABILITY(P, MQ)\n-\n-MUTABILITY(*P, MQ)                 // M-Deref-Unique\n-  TYPE(P) = Box<Ty>\n-  MUTABILITY(P, MQ)\n-```\n-\n-### Checking mutability of immutable pointer types\n-\n-Immutable pointer types like `&T` can only\n-be borrowed if MQ is immutable:\n-\n-```text\n-MUTABILITY(*P, imm)               // M-Deref-Borrowed-Imm\n-  TYPE(P) = &Ty\n-```\n-\n-### Checking mutability of mutable pointer types\n-\n-`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n-\n-```text\n-MUTABILITY(*P, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(P) = &mut Ty\n-```\n-\n-## Checking aliasability\n-\n-The goal of the aliasability check is to ensure that we never permit `&mut`\n-borrows of aliasable data. The judgement `ALIASABLE(P, MQ)` means the\n-aliasability of `P` is compatible with a borrow of mutability `MQ`. The Rust\n-code corresponding to this predicate is the function `check_aliasability()` in\n-`middle::borrowck::gather_loans`.\n-\n-### Checking aliasability of variables\n-\n-Local variables are never aliasable as they are accessible only within\n-the stack frame.\n-\n-```text\n-    ALIASABLE(X, MQ)                   // M-Var-Mut\n-```\n-\n-### Checking aliasable of owned content\n-\n-Owned content is aliasable if it is found in an aliasable location:\n-\n-```text\n-ALIASABLE(P.f, MQ)                // M-Field\n-  ALIASABLE(P, MQ)\n-\n-ALIASABLE(*P, MQ)                 // M-Deref-Unique\n-  ALIASABLE(P, MQ)\n-```\n-\n-### Checking aliasability of immutable pointer types\n-\n-Immutable pointer types like `&T` are aliasable, and hence can only be\n-borrowed immutably:\n-\n-```text\n-ALIASABLE(*P, imm)                // M-Deref-Borrowed-Imm\n-  TYPE(P) = &Ty\n-```\n-\n-### Checking aliasability of mutable pointer types\n-\n-`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n-\n-```text\n-ALIASABLE(*P, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(P) = &mut Ty\n-```\n-\n-## Checking lifetime\n-\n-These rules aim to ensure that no data is borrowed for a scope that exceeds\n-its lifetime. These two computations wind up being intimately related.\n-Formally, we define a predicate `LIFETIME(P, LT, MQ)`, which states that\n-\"the place `P` can be safely borrowed for the lifetime `LT` with mutability\n-`MQ`\". The Rust code corresponding to this predicate is the module\n-`middle::borrowck::gather_loans::lifetime`.\n-\n-### Checking lifetime of variables\n-\n-The rule for variables states that a variable can only be borrowed a\n-lifetime `LT` that is a subregion of the variable's scope:\n-\n-```text\n-LIFETIME(X, LT, MQ)                 // L-Local\n-  LT <= block where X is declared\n-```\n-\n-### Checking lifetime for owned content\n-\n-The lifetime of a field or box is the same as the lifetime\n-of its owner:\n-\n-```text\n-LIFETIME(P.f, LT, MQ)              // L-Field\n-  LIFETIME(P, LT, MQ)\n-\n-LIFETIME(*P, LT, MQ)               // L-Deref-Send\n-  TYPE(P) = Box<Ty>\n-  LIFETIME(P, LT, MQ)\n-```\n-\n-### Checking lifetime for derefs of references\n-\n-References have a lifetime `LT'` associated with them.  The\n-data they point at has been guaranteed to be valid for at least this\n-lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n-of the borrow is shorter than the lifetime `LT'` of the pointer\n-itself:\n-\n-```text\n-LIFETIME(*P, LT, MQ)               // L-Deref-Borrowed\n-  TYPE(P) = &LT' Ty OR &LT' mut Ty\n-  LT <= LT'\n-```\n-\n-## Computing the restrictions\n-\n-The final rules govern the computation of *restrictions*, meaning that\n-we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(P, LT, ACTIONS) =\n-RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n-occurring on `P`, the restrictions `RESTRICTION*` must be respected\n-for the lifetime of the loan\".\n-\n-Note that there is an initial set of restrictions: these restrictions\n-are computed based on the kind of borrow:\n-\n-```text\n-&mut P =>   RESTRICTIONS(P, LT, MUTATE|CLAIM|FREEZE)\n-&P =>       RESTRICTIONS(P, LT, MUTATE|CLAIM)\n-```\n-\n-The reasoning here is that a mutable borrow must be the only writer,\n-therefore it prevents other writes (`MUTATE`), mutable borrows\n-(`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n-permits other immutable borrows but forbids writes and mutable borrows.\n-\n-### Restrictions for loans of a local variable\n-\n-The simplest case is a borrow of a local variable `X`:\n-\n-```text\n-RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n-```\n-\n-In such cases we just record the actions that are not permitted.\n-\n-### Restrictions for loans of fields\n-\n-Restricting a field is the same as restricting the owner of that\n-field:\n-\n-```text\n-RESTRICTIONS(P.f, LT, ACTIONS) = RS, (P.f, ACTIONS)  // R-Field\n-  RESTRICTIONS(P, LT, ACTIONS) = RS\n-```\n-\n-The reasoning here is as follows. If the field must not be mutated,\n-then you must not mutate the owner of the field either, since that\n-would indirectly modify the field. Similarly, if the field cannot be\n-frozen or aliased, we cannot allow the owner to be frozen or aliased,\n-since doing so indirectly freezes/aliases the field. This is the\n-origin of inherited mutability.\n-\n-### Restrictions for loans of owned referents\n-\n-Because the mutability of owned referents is inherited, restricting an\n-owned referent is similar to restricting a field, in that it implies\n-restrictions on the pointer. However, boxes have an important\n-twist: if the owner `P` is mutated, that causes the owned referent\n-`*P` to be freed! So whenever an owned referent `*P` is borrowed, we\n-must prevent the box `P` from being mutated, which means\n-that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n-on `P`:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Send-Pointer\n-  TYPE(P) = Box<Ty>\n-  RESTRICTIONS(P, LT, ACTIONS|MUTATE|CLAIM) = RS\n-```\n-\n-### Restrictions for loans of immutable borrowed referents\n-\n-Immutable borrowed referents are freely aliasable, meaning that\n-the compiler does not prevent you from copying the pointer.  This\n-implies that issuing restrictions is useless. We might prevent the\n-user from acting on `*P` itself, but there could be another path\n-`*P1` that refers to the exact same memory, and we would not be\n-restricting that path. Therefore, the rule for `&Ty` pointers\n-always returns an empty set of restrictions, and it only permits\n-restricting `MUTATE` and `CLAIM` actions:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-  TYPE(P) = &LT' Ty\n-  LT <= LT'                                            // (1)\n-  ACTIONS subset of [MUTATE, CLAIM]\n-```\n-\n-The reason that we can restrict `MUTATE` and `CLAIM` actions even\n-without a restrictions list is that it is never legal to mutate nor to\n-borrow mutably the contents of a `&Ty` pointer. In other words,\n-those restrictions are already inherent in the type.\n-\n-Clause (1) in the rule for `&Ty` deserves mention. Here I\n-specify that the lifetime of the loan must be less than the lifetime\n-of the `&Ty` pointer. In simple cases, this clause is redundant, since\n-the `LIFETIME()` function will already enforce the required rule:\n-\n-```rust\n-fn foo(point: &'a Point) -> &'static i32 {\n-    &point.x // Error\n-}\n-```\n-\n-The above example fails to compile both because of clause (1) above\n-but also by the basic `LIFETIME()` check. However, in more advanced\n-examples involving multiple nested pointers, clause (1) is needed:\n-\n-```rust\n-fn foo(point: &'a &'b mut Point) -> &'b i32 {\n-    &point.x // Error\n-}\n-```\n-\n-The `LIFETIME` rule here would accept `'b` because, in fact, the\n-*memory is* guaranteed to remain valid (i.e., not be freed) for the\n-lifetime `'b`, since the `&mut` pointer is valid for `'b`. However, we\n-are returning an immutable reference, so we need the memory to be both\n-valid and immutable. Even though `point.x` is referenced by an `&mut`\n-pointer, it can still be considered immutable so long as that `&mut`\n-pointer is found in an aliased location. That means the memory is\n-guaranteed to be *immutable* for the lifetime of the `&` pointer,\n-which is only `'a`, not `'b`. Hence this example yields an error.\n-\n-As a final twist, consider the case of two nested *immutable*\n-pointers, rather than a mutable pointer within an immutable one:\n-\n-```rust\n-fn foo(point: &'a &'b Point) -> &'b i32 {\n-    &point.x // OK\n-}\n-```\n-\n-This function is legal. The reason for this is that the inner pointer\n-(`*point : &'b Point`) is enough to guarantee the memory is immutable\n-and valid for the lifetime `'b`.  This is reflected in\n-`RESTRICTIONS()` by the fact that we do not recurse (i.e., we impose\n-no restrictions on `P`, which in this particular case is the pointer\n-`point : &'a &'b Point`).\n-\n-#### Why both `LIFETIME()` and `RESTRICTIONS()`?\n-\n-Given the previous text, it might seem that `LIFETIME` and\n-`RESTRICTIONS` should be folded together into one check, but there is\n-a reason that they are separated. They answer separate concerns.\n-The rules pertaining to `LIFETIME` exist to ensure that we don't\n-create a borrowed pointer that outlives the memory it points at. So\n-`LIFETIME` prevents a function like this:\n-\n-```rust\n-fn get_1<'a>() -> &'a i32 {\n-    let x = 1;\n-    &x\n-}\n-```\n-\n-Here we would be returning a pointer into the stack. Clearly bad.\n-\n-However, the `RESTRICTIONS` rules are more concerned with how memory\n-is used. The example above doesn't generate an error according to\n-`RESTRICTIONS` because, for local variables, we don't require that the\n-loan lifetime be a subset of the local variable lifetime. The idea\n-here is that we *can* guarantee that `x` is not (e.g.) mutated for the\n-lifetime `'a`, even though `'a` exceeds the function body and thus\n-involves unknown code in the caller -- after all, `x` ceases to exist\n-after we return and hence the remaining code in `'a` cannot possibly\n-mutate it. This distinction is important for type checking functions\n-like this one:\n-\n-```rust\n-fn inc_and_get<'a>(p: &'a mut Point) -> &'a i32 {\n-    p.x += 1;\n-    &p.x\n-}\n-```\n-\n-In this case, we take in a `&mut` and return a frozen borrowed pointer\n-with the same lifetime. So long as the lifetime of the returned value\n-doesn't exceed the lifetime of the `&mut` we receive as input, this is\n-fine, though it may seem surprising at first (it surprised me when I\n-first worked it through). After all, we're guaranteeing that `*p`\n-won't be mutated for the lifetime `'a`, even though we can't \"see\" the\n-entirety of the code during that lifetime, since some of it occurs in\n-our caller. But we *do* know that nobody can mutate `*p` except\n-through `p`. So if we don't mutate `*p` and we don't return `p`, then\n-we know that the right to mutate `*p` has been lost to our caller --\n-in terms of capability, the caller passed in the ability to mutate\n-`*p`, and we never gave it back. (Note that we can't return `p` while\n-`*p` is borrowed since that would be a move of `p`, as `&mut` pointers\n-are affine.)\n-\n-### Restrictions for loans of mutable borrowed referents\n-\n-Mutable borrowed pointers are guaranteed to be the only way to mutate\n-their referent. This permits us to take greater license with them; for\n-example, the referent can be frozen simply be ensuring that we do not\n-use the original pointer to perform mutate. Similarly, we can allow\n-the referent to be claimed, so long as the original pointer is unused\n-while the new claimant is live.\n-\n-The rule for mutable borrowed pointers is as follows:\n-\n-```text\n-RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Mut-Borrowed\n-  TYPE(P) = &LT' mut Ty\n-  LT <= LT'                                            // (1)\n-  RESTRICTIONS(P, LT, ACTIONS) = RS                   // (2)\n-```\n-\n-Let's examine the two numbered clauses:\n-\n-Clause (1) specifies that the lifetime of the loan (`LT`) cannot\n-exceed the lifetime of the `&mut` pointer (`LT'`). The reason for this\n-is that the `&mut` pointer is guaranteed to be the only legal way to\n-mutate its referent -- but only for the lifetime `LT'`.  After that\n-lifetime, the loan on the referent expires and hence the data may be\n-modified by its owner again. This implies that we are only able to\n-guarantee that the referent will not be modified or aliased for a\n-maximum of `LT'`.\n-\n-Here is a concrete example of a bug this rule prevents:\n-\n-```rust\n-// Test region-reborrow-from-shorter-mut-ref.rs:\n-fn copy_borrowed_ptr<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n-    &mut **p // ERROR due to clause (1)\n-}\n-fn main() {\n-    let mut x = 1;\n-    let mut y = &mut x; // <-'b-----------------------------+\n-    //      +-'a--------------------+                       |\n-    //      v                       v                       |\n-    let z = copy_borrowed_ptr(&mut y); // y is lent         |\n-    *y += 1; // Here y==z, so both should not be usable...  |\n-    *z += 1; // ...and yet they would be, but for clause 1. |\n-} // <------------------------------------------------------+\n-```\n-\n-Clause (2) propagates the restrictions on the referent to the pointer\n-itself. This is the same as with an box, though the\n-reasoning is mildly different. The basic goal in all cases is to\n-prevent the user from establishing another route to the same data. To\n-see what I mean, let's examine various cases of what can go wrong and\n-show how it is prevented.\n-\n-**Example danger 1: Moving the base pointer.** One of the simplest\n-ways to violate the rules is to move the base pointer to a new name\n-and access it via that new name, thus bypassing the restrictions on\n-the old name. Here is an example:\n-\n-```rust\n-// src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-fn foo(t0: &mut i32) {\n-    let p: &i32 = &*t0; // Freezes `*t0`\n-    let t1 = t0;        //~ ERROR cannot move out of `t0`\n-    *t1 = 22;           // OK, not a write through `*t0`\n-}\n-```\n-\n-Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n-move of `t0` -- or would be, if it were legal. Instead, we get an\n-error, because clause (2) imposes restrictions on `P` (`t0`, here),\n-and any restrictions on a path make it impossible to move from that\n-path.\n-\n-**Example danger 2: Claiming the base pointer.** Another possible\n-danger is to mutably borrow the base path. This can lead to two bad\n-scenarios. The most obvious is that the mutable borrow itself becomes\n-another path to access the same data, as shown here:\n-\n-```rust\n-// src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0;     // Freezes `*t0`\n-    let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n-    **t2 += 1;              // Mutates `*t0`\n-}\n-```\n-\n-In this example, `**t2` is the same memory as `*t0`. Because `t2` is\n-an `&mut` pointer, `**t2` is a unique path and hence it would be\n-possible to mutate `**t2` even though that memory was supposed to be\n-frozen by the creation of `p`. However, an error is reported -- the\n-reason is that the freeze `&*t0` will restrict claims and mutation\n-against `*t0` which, by clause 2, in turn prevents claims and mutation\n-of `t0`. Hence the claim `&mut t0` is illegal.\n-\n-Another danger with an `&mut` pointer is that we could swap the `t0`\n-value away to create a new path:\n-\n-```rust\n-// src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0;     // Freezes `*t0`\n-    swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-    *t1 = 22;\n-}\n-```\n-\n-This is illegal for the same reason as above. Note that if we added\n-back a swap operator -- as we used to have -- we would want to be very\n-careful to ensure this example is still illegal.\n-\n-**Example danger 3: Freeze the base pointer.** In the case where the\n-referent is claimed, even freezing the base pointer can be dangerous,\n-as shown in the following example:\n-\n-```rust\n-// src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &mut i32 = &mut *t0; // Claims `*t0`\n-    let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-    let q: &i32 = &*t2;         // Freezes `*t0` but not through `*p`\n-    *p += 1;                    // violates type of `*q`\n-}\n-```\n-\n-Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n-to be the controlling pointer through which mutation or freezes occur.\n-But `t2` would -- if it were legal -- have the type `& &mut i32`, and\n-hence would be a mutable pointer in an aliasable location, which is\n-considered frozen (since no one can write to `**t2` as it is not a\n-unique path). Therefore, we could reasonably create a frozen `&i32`\n-pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n-which is clearly unsound.\n-\n-However, it is not always unsafe to freeze the base pointer. In\n-particular, if the referent is frozen, there is no harm in it:\n-\n-```rust\n-// src/test/ui/borrowck-borrow-of-mut-base-ptr-safe.rs\n-fn foo<'a>(mut t0: &'a mut i32,\n-           mut t1: &'a mut i32) {\n-    let p: &i32 = &*t0; // Freezes `*t0`\n-    let mut t2 = &t0;\n-    let q: &i32 = &*t2; // Freezes `*t0`, but that's ok...\n-    let r: &i32 = &*t0; // ...after all, could do same thing directly.\n-}\n-```\n-\n-In this case, creating the alias `t2` of `t0` is safe because the only\n-thing `t2` can be used for is to further freeze `*t0`, which is\n-already frozen. In particular, we cannot assign to `*t0` through the\n-new alias `t2`, as demonstrated in this test case:\n-\n-```rust\n-// src/test/ui/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-fn foo(t0: & &mut i32) {\n-    let t1 = t0;\n-    let p: &i32 = &**t0;\n-    **t1 = 22; //~ ERROR cannot assign\n-}\n-```\n-\n-This distinction is reflected in the rules. When doing an `&mut`\n-borrow -- as in the first example -- the set `ACTIONS` will be\n-`CLAIM|MUTATE|FREEZE`, because claiming the referent implies that it\n-cannot be claimed, mutated, or frozen by anyone else. These\n-restrictions are propagated back to the base path and hence the base\n-path is considered unfreezable.\n-\n-In contrast, when the referent is merely frozen -- as in the second\n-example -- the set `ACTIONS` will be `CLAIM|MUTATE`, because freezing\n-the referent implies that it cannot be claimed or mutated but permits\n-others to freeze. Hence when these restrictions are propagated back to\n-the base path, it will still be considered freezable.\n-\n-\n-\n-**FIXME [RFC 1751](https://github.com/rust-lang/rfcs/issues/1751)\n-Restrictions against mutating the base pointer.**\n-When an `&mut` pointer is frozen or claimed, we currently pass along the\n-restriction against MUTATE to the base pointer. I do not believe this\n-restriction is needed. It dates from the days when we had a way to\n-mutate that preserved the value being mutated (i.e., swap). Nowadays\n-the only form of mutation is assignment, which destroys the pointer\n-being mutated -- therefore, a mutation cannot create a new path to the\n-same data. Rather, it removes an existing path. This implies that not\n-only can we permit mutation, we can have mutation kill restrictions in\n-the dataflow sense.\n-\n-**WARNING:** We do not currently have `const` borrows in the\n-language. If they are added back in, we must ensure that they are\n-consistent with all of these examples. The crucial question will be\n-what sorts of actions are permitted with a `&const &mut` pointer. I\n-would suggest that an `&mut` referent found in an `&const` location be\n-prohibited from both freezes and claims. This would avoid the need to\n-prevent `const` borrows of the base pointer when the referent is\n-borrowed.\n-\n-[ Previous revisions of this document discussed `&const` in more detail.\n-See the revision history. ]\n-\n-# Moves and initialization\n-\n-The borrow checker is also in charge of ensuring that:\n-\n-- all memory which is accessed is initialized\n-- immutable local variables are assigned at most once.\n-\n-These are two separate dataflow analyses built on the same\n-framework. Let's look at checking that memory is initialized first;\n-the checking of immutable local variable assignments works in a very\n-similar way.\n-\n-To track the initialization of memory, we actually track all the\n-points in the program that *create uninitialized memory*, meaning\n-moves and the declaration of uninitialized variables. For each of\n-these points, we create a bit in the dataflow set. Assignments to a\n-variable `x` or path `a.b.c` kill the move/uninitialization bits for\n-those paths and any subpaths (e.g., `x`, `x.y`, `a.b.c`, `*a.b.c`).\n-Bits are unioned when two control-flow paths join. Thus, the\n-presence of a bit indicates that the move may have occurred without an\n-intervening assignment to the same memory. At each use of a variable,\n-we examine the bits in scope, and check that none of them are\n-moves/uninitializations of the variable that is being used.\n-\n-Let's look at a simple example:\n-\n-```rust\n-fn foo(a: Box<i32>) {\n-    let b: Box<i32>;   // Gen bit 0.\n-\n-    if cond {          // Bits: 0\n-        use(&*a);\n-        b = a;         // Gen bit 1, kill bit 0.\n-        use(&*b);\n-    } else {\n-                       // Bits: 0\n-    }\n-                       // Bits: 0,1\n-    use(&*a);          // Error.\n-    use(&*b);          // Error.\n-}\n-\n-fn use(a: &i32) { }\n-```\n-\n-In this example, the variable `b` is created uninitialized. In one\n-branch of an `if`, we then move the variable `a` into `b`. Once we\n-exit the `if`, therefore, it is an error to use `a` or `b` since both\n-are only conditionally initialized. I have annotated the dataflow\n-state using comments. There are two dataflow bits, with bit 0\n-corresponding to the creation of `b` without an initializer, and bit 1\n-corresponding to the move of `a`. The assignment `b = a` both\n-generates bit 1, because it is a move of `a`, and kills bit 0, because\n-`b` is now initialized. On the else branch, though, `b` is never\n-initialized, and so bit 0 remains untouched. When the two flows of\n-control join, we union the bits from both sides, resulting in both\n-bits 0 and 1 being set. Thus any attempt to use `a` uncovers the bit 1\n-from the \"then\" branch, showing that `a` may be moved, and any attempt\n-to use `b` uncovers bit 0, from the \"else\" branch, showing that `b`\n-may not be initialized.\n-\n-## Initialization of immutable variables\n-\n-Initialization of immutable variables works in a very similar way,\n-except that:\n-\n-1. we generate bits for each assignment to a variable;\n-2. the bits are never killed except when the variable goes out of scope.\n-\n-Thus the presence of an assignment bit indicates that the assignment\n-may have occurred. Note that assignments are only killed when the\n-variable goes out of scope, as it is not relevant whether or not there\n-has been a move in the meantime. Using these bits, we can declare that\n-an assignment to an immutable variable is legal iff there is no other\n-assignment bit to that same variable in scope.\n-\n-## Why is the design made this way?\n-\n-It may seem surprising that we assign dataflow bits to *each move*\n-rather than *each path being moved*. This is somewhat less efficient,\n-since on each use, we must iterate through all moves and check whether\n-any of them correspond to the path in question. Similar concerns apply\n-to the analysis for double assignments to immutable variables. The\n-main reason to do it this way is that it allows us to print better\n-error messages, because when a use occurs, we can print out the\n-precise move that may be in scope, rather than simply having to say\n-\"the variable may not be initialized\".\n-\n-## Data structures used in the move analysis\n-\n-The move analysis maintains several data structures that enable it to\n-cross-reference moves and assignments to determine when they may be\n-moving/assigning the same memory. These are all collected into the\n-`MoveData` and `FlowedMoveData` structs. The former represents the set\n-of move paths, moves, and assignments, and the latter adds in the\n-results of a dataflow computation.\n-\n-### Move paths\n-\n-The `MovePath` tree tracks every path that is moved or assigned to.\n-These paths have the same form as the `LoanPath` data structure, which\n-in turn is the \"real world version of the places `P` that we\n-introduced earlier. The difference between a `MovePath` and a `LoanPath`\n-is that move paths are:\n-\n-1. Canonicalized, so that we have exactly one copy of each, and\n-   we can refer to move paths by index;\n-2. Cross-referenced with other paths into a tree, so that given a move\n-   path we can efficiently find all parent move paths and all\n-   extensions (e.g., given the `a.b` move path, we can easily find the\n-   move path `a` and also the move paths `a.b.c`)\n-3. Cross-referenced with moves and assignments, so that we can\n-   easily find all moves and assignments to a given path.\n-\n-The mechanism that we use is to create a `MovePath` record for each\n-move path. These are arranged in an array and are referenced using\n-`MovePathIndex` values, which are newtype'd indices. The `MovePath`\n-structs are arranged into a tree, representing using the standard\n-Knuth representation where each node has a child 'pointer' and a \"next\n-sibling\" 'pointer'. In addition, each `MovePath` has a parent\n-'pointer'.  In this case, the 'pointers' are just `MovePathIndex`\n-values.\n-\n-In this way, if we want to find all base paths of a given move path,\n-we can just iterate up the parent pointers (see `each_base_path()` in\n-the `move_data` module). If we want to find all extensions, we can\n-iterate through the subtree (see `each_extending_path()`).\n-\n-### Moves and assignments\n-\n-There are structs to represent moves (`Move`) and assignments\n-(`Assignment`), and these are also placed into arrays and referenced\n-by index. All moves of a particular path are arranged into a linked\n-lists, beginning with `MovePath.first_move` and continuing through\n-`Move.next_move`.\n-\n-We distinguish between \"var\" assignments, which are assignments to a\n-variable like `x = foo`, and \"path\" assignments (`x.f = foo`).  This\n-is because we need to assign dataflows to the former, but not the\n-latter, so as to check for double initialization of immutable\n-variables.\n-\n-### Gathering and checking moves\n-\n-Like loans, we distinguish two phases. The first, gathering, is where\n-we uncover all the moves and assignments. As with loans, we do some\n-basic sanity checking in this phase, so we'll report errors if you\n-attempt to move out of a borrowed pointer etc. Then we do the dataflow\n-(see `FlowedMoveData::new`). Finally, in the `check_loans.rs` code, we\n-walk back over, identify all uses, assignments, and captures, and\n-check that they are legal given the set of dataflow bits we have\n-computed for that program point.\n-\n-# Drop flags and structural fragments\n-\n-In addition to the job of enforcing memory safety, the borrow checker\n-code is also responsible for identifying the *structural fragments* of\n-data in the function, to support out-of-band dynamic drop flags\n-allocated on the stack. (For background, see [RFC PR #320].)\n-\n-[RFC PR #320]: https://github.com/rust-lang/rfcs/pull/320\n-\n-Semantically, each piece of data that has a destructor may need a\n-boolean flag to indicate whether or not its destructor has been run\n-yet. However, in many cases there is no need to actually maintain such\n-a flag: It can be apparent from the code itself that a given path is\n-always initialized (or always deinitialized) when control reaches the\n-end of its owner's scope, and thus we can unconditionally emit (or\n-not) the destructor invocation for that path.\n-\n-A simple example of this is the following:\n-\n-```rust\n-struct D { p: i32 }\n-impl D { fn new(x: i32) -> D { ... }\n-impl Drop for D { ... }\n-\n-fn foo(a: D, b: D, t: || -> bool) {\n-    let c: D;\n-    let d: D;\n-    if t() { c = b; }\n-}\n-```\n-\n-At the end of the body of `foo`, the compiler knows that `a` is\n-initialized, introducing a drop obligation (deallocating the boxed\n-integer) for the end of `a`'s scope that is run unconditionally.\n-Likewise the compiler knows that `d` is not initialized, and thus it\n-leave out the drop code for `d`.\n-\n-The compiler cannot statically know the drop-state of `b` nor `c` at\n-the end of their scope, since that depends on the value of\n-`t`. Therefore, we need to insert boolean flags to track whether we\n-need to drop `b` and `c`.\n-\n-However, the matter is not as simple as just mapping local variables\n-to their corresponding drop flags when necessary. In particular, in\n-addition to being able to move data out of local variables, Rust\n-allows one to move values in and out of structured data.\n-\n-Consider the following:\n-\n-```rust\n-struct S { x: D, y: D, z: D }\n-\n-fn foo(a: S, mut b: S, t: || -> bool) {\n-    let mut c: S;\n-    let d: S;\n-    let e: S = a.clone();\n-    if t() {\n-        c = b;\n-        b.x = e.y;\n-    }\n-    if t() { c.y = D::new(4); }\n-}\n-```\n-\n-As before, the drop obligations of `a` and `d` can be statically\n-determined, and again the state of `b` and `c` depend on dynamic\n-state. But additionally, the dynamic drop obligations introduced by\n-`b` and `c` are not just per-local boolean flags. For example, if the\n-first call to `t` returns `false` and the second call `true`, then at\n-the end of their scope, `b` will be completely initialized, but only\n-`c.y` in `c` will be initialized.  If both calls to `t` return `true`,\n-then at the end of their scope, `c` will be completely initialized,\n-but only `b.x` will be initialized in `b`, and only `e.x` and `e.z`\n-will be initialized in `e`.\n-\n-Note that we need to cover the `z` field in each case in some way,\n-since it may (or may not) need to be dropped, even though `z` is never\n-directly mentioned in the body of the `foo` function. We call a path\n-like `b.z` a *fragment sibling* of `b.x`, since the field `z` comes\n-from the same structure `S` that declared the field `x` in `b.x`.\n-\n-In general we need to maintain boolean flags that match the\n-`S`-structure of both `b` and `c`.  In addition, we need to consult\n-such a flag when doing an assignment (such as `c.y = D::new(4);`\n-above), in order to know whether or not there is a previous value that\n-needs to be dropped before we do the assignment.\n-\n-So for any given function, we need to determine what flags are needed\n-to track its drop obligations. Our strategy for determining the set of\n-flags is to represent the fragmentation of the structure explicitly:\n-by starting initially from the paths that are explicitly mentioned in\n-moves and assignments (such as `b.x` and `c.y` above), and then\n-traversing the structure of the path's type to identify leftover\n-*unmoved fragments*: assigning into `c.y` means that `c.x` and `c.z`\n-are leftover unmoved fragments. Each fragment represents a drop\n-obligation that may need to be tracked. Paths that are only moved or\n-assigned in their entirety (like `a` and `d`) are treated as a single\n-drop obligation.\n-\n-The fragment construction process works by piggy-backing on the\n-existing `move_data` module. We already have callbacks that visit each\n-direct move and assignment; these form the basis for the sets of\n-moved_leaf_paths and assigned_leaf_paths. From these leaves, we can\n-walk up their parent chain to identify all of their parent paths.\n-We need to identify the parents because of cases like the following:\n-\n-```rust\n-struct Pair<X,Y>{ x: X, y: Y }\n-fn foo(dd_d_d: Pair<Pair<Pair<D, D>, D>, D>) {\n-    other_function(dd_d_d.x.y);\n-}\n-```\n-\n-In this code, the move of the path `dd_d.x.y` leaves behind not only\n-the fragment drop-obligation `dd_d.x.x` but also `dd_d.y` as well.\n-\n-Once we have identified the directly-referenced leaves and their\n-parents, we compute the left-over fragments, in the function\n-`fragments::add_fragment_siblings`. As of this writing this works by\n-looking at each directly-moved or assigned path P, and blindly\n-gathering all sibling fields of P (as well as siblings for the parents\n-of P, etc). After accumulating all such siblings, we filter out the\n-entries added as siblings of P that turned out to be\n-directly-referenced paths (or parents of directly referenced paths)\n-themselves, thus leaving the never-referenced \"left-overs\" as the only\n-thing left from the gathering step.\n-\n-## Array structural fragments\n-\n-A special case of the structural fragments discussed above are\n-the elements of an array that has been passed by value, such as\n-the following:\n-\n-```rust\n-fn foo(a: [D; 10], i: i32) -> D {\n-    a[i]\n-}\n-```\n-\n-The above code moves a single element out of the input array `a`.\n-The remainder of the array still needs to be dropped; i.e., it\n-is a structural fragment. Note that after performing such a move,\n-it is not legal to read from the array `a`. There are a number of\n-ways to deal with this, but the important thing to note is that\n-the semantics needs to distinguish in some manner between a\n-fragment that is the *entire* array versus a fragment that represents\n-all-but-one element of the array.  A place where that distinction\n-would arise is the following:\n-\n-```rust\n-fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n-    if t {\n-        a[i]\n-    } else {\n-        b[i]\n-    }\n-\n-    // When control exits, we will need either to drop all of `a`\n-    // and all-but-one of `b`, or to drop all of `b` and all-but-one\n-    // of `a`.\n-}\n-```\n-\n-There are a number of ways that the codegen backend could choose to\n-compile this (e.g. a `[bool; 10]` array for each such moved array;\n-or an `Option<usize>` for each moved array).  From the viewpoint of the\n-borrow-checker, the important thing is to record what kind of fragment\n-is implied by the relevant moves.\n-\n-# Future work\n-\n-While writing up these docs, I encountered some rules I believe to be\n-stricter than necessary:\n-\n-- I think restricting the `&mut` P against moves and `ALIAS` is sufficient,\n-  `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n-  a built-in operator, but as it is not, it is implied by `CLAIM`,\n-  and `CLAIM` is implied by `ALIAS`. The only net effect of this is an\n-  extra error message in some cases, though.\n-- I have not described how closures interact. Current code is unsound.\n-  I am working on describing and implementing the fix.\n-- If we wish, we can easily extend the move checking to allow finer-grained\n-  tracking of what is initialized and what is not, enabling code like\n-  this:\n-\n-      a = x.f.g; // x.f.g is now uninitialized\n-      // here, x and x.f are not usable, but x.f.h *is*\n-      x.f.g = b; // x.f.g is not initialized\n-      // now x, x.f, x.f.g, x.f.h are all usable\n-\n-  What needs to change here, most likely, is that the `moves` module\n-  should record not only what paths are moved, but what expressions\n-  are actual *uses*. For example, the reference to `x` in `x.f.g = b`\n-  is not a true *use* in the sense that it requires `x` to be fully\n-  initialized. This is in fact why the above code produces an error\n-  today: the reference to `x` in `x.f.g = b` is considered illegal\n-  because `x` is not fully initialized.\n-\n-There are also some possible refactorings:\n-\n-- It might be nice to replace all loan paths with the MovePath mechanism,\n-  since they allow lightweight comparison using an integer."}, {"sha": "dd2aeb4276faacd46ac8dabee260bb6a3703adaa", "filename": "src/librustc_ast_borrowck/borrowck/check_loans.rs", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,680 +0,0 @@\n-// ----------------------------------------------------------------------\n-// Checking loans\n-//\n-// Phase 2 of check: we walk down the tree and check that:\n-// 1. assignments are always made to mutable locations;\n-// 2. loans made in overlapping scopes do not conflict\n-// 3. assignments do not affect things loaned out as immutable\n-// 4. moves do not affect things loaned out in any way\n-\n-use crate::borrowck::*;\n-use crate::borrowck::InteriorKind::{InteriorElement, InteriorField};\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt, RegionKind};\n-use syntax_pos::Span;\n-use rustc::hir;\n-use rustc::hir::Node;\n-use log::debug;\n-\n-use std::rc::Rc;\n-\n-// FIXME (#16118): These functions are intended to allow the borrow checker to\n-// be less precise in its handling of Box while still allowing moves out of a\n-// Box. They should be removed when Unique is removed from LoanPath.\n-\n-fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<'tcx> {\n-    //! Returns the base of the leftmost dereference of an Unique in\n-    //! `loan_path`. If there is no dereference of an Unique in `loan_path`,\n-    //! then it just returns `loan_path` itself.\n-\n-    return match helper(loan_path) {\n-        Some(new_loan_path) => new_loan_path,\n-        None => loan_path,\n-    };\n-\n-    fn helper<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> Option<&'a LoanPath<'tcx>> {\n-        match loan_path.kind {\n-            LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n-                match helper(&lp_base) {\n-                    v @ Some(_) => v,\n-                    None => Some(&lp_base)\n-                }\n-            }\n-            LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, ..) => helper(&lp_base)\n-        }\n-    }\n-}\n-\n-fn owned_ptr_base_path_rc<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Rc<LoanPath<'tcx>> {\n-    //! The equivalent of `owned_ptr_base_path` for an &Rc<LoanPath> rather than\n-    //! a &LoanPath.\n-\n-    return match helper(loan_path) {\n-        Some(new_loan_path) => new_loan_path,\n-        None => loan_path.clone()\n-    };\n-\n-    fn helper<'tcx>(loan_path: &Rc<LoanPath<'tcx>>) -> Option<Rc<LoanPath<'tcx>>> {\n-        match loan_path.kind {\n-            LpVar(_) | LpUpvar(_) => None,\n-            LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n-                match helper(lp_base) {\n-                    v @ Some(_) => v,\n-                    None => Some(lp_base.clone())\n-                }\n-            }\n-            LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, ..) => helper(lp_base)\n-        }\n-    }\n-}\n-\n-struct CheckLoanCtxt<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &'a LoanDataFlow<'tcx>,\n-    move_data: &'a move_data::FlowedMoveData<'tcx>,\n-    all_loans: &'a [Loan<'tcx>],\n-    movable_generator: bool,\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               _: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={:?})\", consume_id, cmt);\n-\n-        self.consume_common(consume_id.local_id, cmt, mode);\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: &mc::cmt_<'_>,\n-                   _mode: euv::MatchMode) { }\n-\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={:?}, cmt={:?})\", consume_pat, cmt);\n-\n-        self.consume_common(consume_pat.hir_id.local_id, cmt, mode);\n-    }\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              borrow_span: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n-               bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt, loan_region,\n-               bk, loan_cause);\n-\n-        if let Some(lp) = opt_loan_path(cmt) {\n-            self.check_if_path_is_moved(borrow_id.local_id, &lp);\n-        }\n-\n-        self.check_for_conflicting_loans(borrow_id.local_id);\n-\n-        self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n-    }\n-\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              _: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              mode: euv::MutateMode)\n-    {\n-        debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n-               assignment_id, assignee_cmt);\n-\n-        if let Some(lp) = opt_loan_path(assignee_cmt) {\n-            match mode {\n-                MutateMode::Init | MutateMode::JustWrite => {\n-                    // In a case like `path = 1`, then path does not\n-                    // have to be *FULLY* initialized, but we still\n-                    // must be careful lest it contains derefs of\n-                    // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.hir_id.local_id, &lp);\n-                }\n-                MutateMode::WriteAndRead => {\n-                    // In a case like `path += 1`, then path must be\n-                    // fully initialized, since we will read it before\n-                    // we write it.\n-                    self.check_if_path_is_moved(assignee_cmt.hir_id.local_id,\n-                                                &lp);\n-                }\n-            }\n-        }\n-        self.check_assignment(assignment_id.local_id, assignee_cmt);\n-    }\n-\n-    fn decl_without_init(&mut self, _id: hir::HirId, _span: Span) { }\n-}\n-\n-pub fn check_loans<'a, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    dfcx_loans: &LoanDataFlow<'tcx>,\n-    move_data: &move_data::FlowedMoveData<'tcx>,\n-    all_loans: &[Loan<'tcx>],\n-    body: &hir::Body,\n-) {\n-    debug!(\"check_loans(body id={})\", body.value.hir_id);\n-\n-    let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n-\n-    let hir_id = bccx.tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let movable_generator = !match bccx.tcx.hir().get(hir_id) {\n-        Node::Expr(&hir::Expr {\n-            kind: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n-            ..\n-        }) => true,\n-        _ => false,\n-    };\n-\n-    let param_env = bccx.tcx.param_env(def_id);\n-    let mut clcx = CheckLoanCtxt {\n-        bccx,\n-        dfcx_loans,\n-        move_data,\n-        all_loans,\n-        movable_generator,\n-    };\n-    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n-    euv::ExprUseVisitor::new(&mut clcx,\n-                             bccx.tcx,\n-                             def_id,\n-                             param_env,\n-                             &bccx.region_scope_tree,\n-                             bccx.tables,\n-                             Some(rvalue_promotable_map))\n-        .consume_body(body);\n-}\n-\n-fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n-                           borrow_kind2: ty::BorrowKind)\n-                           -> bool {\n-    borrow_kind1 == ty::ImmBorrow && borrow_kind2 == ty::ImmBorrow\n-}\n-\n-impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n-\n-    pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Iterates over each loan that has been issued\n-        //! on entrance to `node`, regardless of whether it is\n-        //! actually *in scope* at that point. Sometimes loans\n-        //! are issued for future scopes and thus they may have been\n-        //! *issued* but not yet be in effect.\n-\n-        self.dfcx_loans.each_bit_on_entry(node, |loan_index| {\n-            let loan = &self.all_loans[loan_index];\n-            op(loan)\n-        })\n-    }\n-\n-    pub fn each_in_scope_loan<F>(&self, scope: region::Scope, mut op: F) -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Like `each_issued_loan()`, but only considers loans that are\n-        //! currently in scope.\n-\n-        self.each_issued_loan(scope.item_local_id(), |loan| {\n-            if self.bccx.region_scope_tree.is_subscope_of(scope, loan.kill_scope) {\n-                op(loan)\n-            } else {\n-                true\n-            }\n-        })\n-    }\n-\n-    fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::Scope,\n-                                            loan_path: &LoanPath<'tcx>,\n-                                            mut op: F)\n-                                            -> bool where\n-        F: FnMut(&Loan<'tcx>) -> bool,\n-    {\n-        //! Iterates through all of the in-scope loans affecting `loan_path`,\n-        //! calling `op`, and ceasing iteration if `false` is returned.\n-\n-        // First, we check for a loan restricting the path P being used. This\n-        // accounts for borrows of P but also borrows of subpaths, like P.a.b.\n-        // Consider the following example:\n-        //\n-        //     let x = &mut a.b.c; // Restricts a, a.b, and a.b.c\n-        //     let y = a;          // Conflicts with restriction\n-\n-        let loan_path = owned_ptr_base_path(loan_path);\n-        let cont = self.each_in_scope_loan(scope, |loan| {\n-            let mut ret = true;\n-            for restr_path in &loan.restricted_paths {\n-                if **restr_path == *loan_path {\n-                    if !op(loan) {\n-                        ret = false;\n-                        break;\n-                    }\n-                }\n-            }\n-            ret\n-        });\n-\n-        if !cont {\n-            return false;\n-        }\n-\n-        // Next, we must check for *loans* (not restrictions) on the path P or\n-        // any base path. This rejects examples like the following:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.b.c;\n-        //\n-        // Limiting this search to *loans* and not *restrictions* means that\n-        // examples like the following continue to work:\n-        //\n-        //     let x = &mut a.b;\n-        //     let y = a.c;\n-\n-        let mut loan_path = loan_path;\n-        loop {\n-            match loan_path.kind {\n-                LpVar(_) | LpUpvar(_) => {\n-                    break;\n-                }\n-                LpDowncast(ref lp_base, _) |\n-                LpExtend(ref lp_base, ..) => {\n-                    loan_path = &lp_base;\n-                }\n-            }\n-\n-            let cont = self.each_in_scope_loan(scope, |loan| {\n-                if *loan.loan_path == *loan_path {\n-                    op(loan)\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            if !cont {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    pub fn loans_generated_by(&self, node: hir::ItemLocalId) -> Vec<usize> {\n-        //! Returns a vector of the loans that are generated as\n-        //! we enter `node`.\n-\n-        let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit(node, |loan_index| {\n-            result.push(loan_index);\n-            true\n-        });\n-        return result;\n-    }\n-\n-    pub fn check_for_loans_across_yields(&self,\n-                                         cmt: &mc::cmt_<'tcx>,\n-                                         loan_region: ty::Region<'tcx>,\n-                                         borrow_span: Span) {\n-        pub fn borrow_of_local_data(cmt: &mc::cmt_<'_>) -> bool {\n-            match cmt.cat {\n-                // Borrows of static items is allowed\n-                Categorization::StaticItem => false,\n-                // Reborrow of already borrowed data is ignored\n-                // Any errors will be caught on the initial borrow\n-                Categorization::Deref(..) => false,\n-\n-                // By-ref upvars has Derefs so they will get ignored.\n-                // Generators counts as FnOnce so this leaves only\n-                // by-move upvars, which is local data for generators\n-                Categorization::Upvar(..) => true,\n-\n-                Categorization::ThreadLocal(region) |\n-                Categorization::Rvalue(region) => {\n-                    // Rvalues promoted to 'static are no longer local\n-                    if let RegionKind::ReStatic = *region {\n-                        false\n-                    } else {\n-                        true\n-                    }\n-                }\n-\n-                // Borrow of local data must be checked\n-                Categorization::Local(..) => true,\n-\n-                // For interior references and downcasts, find out if the base is local\n-                Categorization::Downcast(ref cmt_base, _) |\n-                Categorization::Interior(ref cmt_base, _) => borrow_of_local_data(&cmt_base),\n-            }\n-        }\n-\n-        if !self.movable_generator {\n-            return;\n-        }\n-\n-        if !borrow_of_local_data(cmt) {\n-            return;\n-        }\n-\n-        let scope = match *loan_region {\n-            // A concrete region in which we will look for a yield expression\n-            RegionKind::ReScope(scope) => scope,\n-\n-            // There cannot be yields inside an empty region\n-            RegionKind::ReEmpty => return,\n-\n-            // Local data cannot have these lifetimes\n-            RegionKind::ReEarlyBound(..) |\n-            RegionKind::ReLateBound(..) |\n-            RegionKind::ReFree(..) |\n-            RegionKind::ReStatic => {\n-                self.bccx\n-                    .tcx\n-                    .sess.delay_span_bug(borrow_span,\n-                                         &format!(\"unexpected region for local data {:?}\",\n-                                                  loan_region));\n-                return\n-            }\n-\n-            // These cannot exist in borrowck\n-            RegionKind::ReVar(..) |\n-            RegionKind::RePlaceholder(..) |\n-            RegionKind::ReClosureBound(..) |\n-            RegionKind::ReErased => span_bug!(borrow_span,\n-                                              \"unexpected region in borrowck {:?}\",\n-                                              loan_region),\n-        };\n-\n-        let body_id = self.bccx.body.value.hir_id.local_id;\n-\n-        if self.bccx.region_scope_tree.containing_body(scope) != Some(body_id) {\n-            // We are borrowing local data longer than its storage.\n-            // This should result in other borrowck errors.\n-            self.bccx.tcx.sess.delay_span_bug(borrow_span,\n-                                              \"borrowing local data longer than its storage\");\n-            return;\n-        }\n-\n-        if let Some(_) = self.bccx.region_scope_tree\n-            .yield_in_scope_for_expr(scope, cmt.hir_id, self.bccx.body)\n-        {\n-            self.bccx.signal_error();\n-        }\n-    }\n-\n-    pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n-        //! Checks to see whether any of the loans that are issued\n-        //! on entrance to `node` conflict with loans that have already been\n-        //! issued when we enter `node` (for example, we do not\n-        //! permit two `&mut` borrows of the same variable).\n-        //!\n-        //! (Note that some loans can be *issued* without necessarily\n-        //! taking effect yet.)\n-\n-        debug!(\"check_for_conflicting_loans(node={:?})\", node);\n-\n-        let new_loan_indices = self.loans_generated_by(node);\n-        debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n-\n-        for &new_loan_index in &new_loan_indices {\n-            self.each_issued_loan(node, |issued_loan| {\n-                let new_loan = &self.all_loans[new_loan_index];\n-                // Only report an error for the first issued loan that conflicts\n-                // to avoid O(n^2) errors.\n-                self.report_error_if_loans_conflict(issued_loan, new_loan)\n-            });\n-        }\n-\n-        for (i, &x) in new_loan_indices.iter().enumerate() {\n-            let old_loan = &self.all_loans[x];\n-            for &y in &new_loan_indices[(i+1) ..] {\n-                let new_loan = &self.all_loans[y];\n-                self.report_error_if_loans_conflict(old_loan, new_loan);\n-            }\n-        }\n-    }\n-\n-    pub fn report_error_if_loans_conflict(\n-        &self,\n-        old_loan: &Loan<'tcx>,\n-        new_loan: &Loan<'tcx>,\n-    ) -> bool {\n-        //! Checks whether `old_loan` and `new_loan` can safely be issued\n-        //! simultaneously.\n-\n-        debug!(\"report_error_if_loans_conflict(old_loan={:?}, new_loan={:?})\",\n-               old_loan,\n-               new_loan);\n-\n-        // Should only be called for loans that are in scope at the same time.\n-        assert!(self.bccx.region_scope_tree.scopes_intersect(old_loan.kill_scope,\n-                                                       new_loan.kill_scope));\n-\n-        self.report_error_if_loan_conflicts_with_restriction(\n-            old_loan, new_loan)\n-        && self.report_error_if_loan_conflicts_with_restriction(\n-                new_loan, old_loan)\n-    }\n-\n-    pub fn report_error_if_loan_conflicts_with_restriction(\n-        &self,\n-        loan1: &Loan<'tcx>,\n-        loan2: &Loan<'tcx>,\n-    ) -> bool {\n-        //! Checks whether the restrictions introduced by `loan1` would\n-        //! prohibit `loan2`.\n-        debug!(\"report_error_if_loan_conflicts_with_restriction(\\\n-                loan1={:?}, loan2={:?})\",\n-               loan1,\n-               loan2);\n-\n-        if compatible_borrow_kinds(loan1.kind, loan2.kind) {\n-            return true;\n-        }\n-\n-        let loan2_base_path = owned_ptr_base_path_rc(&loan2.loan_path);\n-        for restr_path in &loan1.restricted_paths {\n-            if *restr_path != loan2_base_path { continue; }\n-\n-            self.bccx.signal_error();\n-            return false;\n-        }\n-\n-        true\n-    }\n-\n-    fn consume_common(\n-        &self,\n-        id: hir::ItemLocalId,\n-        cmt: &mc::cmt_<'tcx>,\n-        mode: euv::ConsumeMode,\n-    ) {\n-        if let Some(lp) = opt_loan_path(cmt) {\n-            match mode {\n-                euv::Copy => {\n-                    self.check_for_copy_of_frozen_path(id, &lp);\n-                }\n-                euv::Move(_) => {\n-                    // Sometimes moves aren't from a move path;\n-                    // this either means that the original move\n-                    // was from something illegal to move,\n-                    // or was moved from referent of an unsafe\n-                    // pointer or something like that.\n-                    if self.move_data.is_move_path(id, &lp) {\n-                        self.check_for_move_of_borrowed_path(id, &lp);\n-                    }\n-                }\n-            }\n-            self.check_if_path_is_moved(id, &lp);\n-        }\n-    }\n-\n-    fn check_for_copy_of_frozen_path(&self,\n-                                     id: hir::ItemLocalId,\n-                                     copy_path: &LoanPath<'tcx>) {\n-        self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow);\n-    }\n-\n-    fn check_for_move_of_borrowed_path(&self,\n-                                       id: hir::ItemLocalId,\n-                                       move_path: &LoanPath<'tcx>) {\n-        // We want to detect if there are any loans at all, so we search for\n-        // any loans incompatible with MutBorrrow, since all other kinds of\n-        // loans are incompatible with that.\n-        self.analyze_restrictions_on_use(id, move_path, ty::MutBorrow);\n-    }\n-\n-    fn analyze_restrictions_on_use(&self,\n-                                       expr_id: hir::ItemLocalId,\n-                                       use_path: &LoanPath<'tcx>,\n-                                       borrow_kind: ty::BorrowKind) {\n-        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n-               expr_id, use_path);\n-\n-        let scope = region::Scope {\n-            id: expr_id,\n-            data: region::ScopeData::Node\n-        };\n-        self.each_in_scope_loan_affecting_path(\n-            scope, use_path, |loan| {\n-            if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n-                self.bccx.signal_error();\n-                false\n-            } else {\n-                true\n-            }\n-        });\n-    }\n-\n-    /// Reports an error if `expr` (which should be a path)\n-    /// is using a moved/uninitialized value\n-    fn check_if_path_is_moved(&self,\n-                              id: hir::ItemLocalId,\n-                              lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={:?}, lp={:?})\", id, lp);\n-\n-        // FIXME: if you find yourself tempted to cut and paste\n-        // the body below and then specializing the error reporting,\n-        // consider refactoring this instead!\n-\n-        let base_lp = owned_ptr_base_path_rc(lp);\n-        self.move_data.each_move_of(id, &base_lp, |_, _| {\n-            self.bccx.signal_error();\n-            false\n-        });\n-    }\n-\n-    /// Reports an error if assigning to `lp` will use a\n-    /// moved/uninitialized value. Mainly this is concerned with\n-    /// detecting derefs of uninitialized pointers.\n-    ///\n-    /// For example:\n-    ///\n-    /// ```\n-    /// let a: i32;\n-    /// a = 10; // ok, even though a is uninitialized\n-    /// ```\n-    ///\n-    /// ```\n-    /// struct Point { x: u32, y: u32 }\n-    /// let mut p: Point;\n-    /// p.x = 22; // ok, even though `p` is uninitialized\n-    /// ```\n-    ///\n-    /// ```compile_fail,E0381\n-    /// # struct Point { x: u32, y: u32 }\n-    /// let mut p: Box<Point>;\n-    /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n-    /// ```\n-    fn check_if_assigned_path_is_moved(&self,\n-                                       id: hir::ItemLocalId,\n-                                       lp: &Rc<LoanPath<'tcx>>)\n-    {\n-        match lp.kind {\n-            LpVar(_) | LpUpvar(_) => {\n-                // assigning to `x` does not require that `x` is initialized\n-            }\n-            LpDowncast(ref lp_base, _) => {\n-                // assigning to `(P->Variant).f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, lp_base);\n-            }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n-                match lp_base.to_type().kind {\n-                    ty::Adt(def, _) if def.has_dtor(self.tcx()) => {\n-                        // In the case where the owner implements drop, then\n-                        // the path must be initialized to prevent a case of\n-                        // partial reinitialization\n-                        //\n-                        // FIXME: could refactor via hypothetical\n-                        // generalized check_if_path_is_moved\n-                        let loan_path = owned_ptr_base_path_rc(lp_base);\n-                        self.move_data.each_move_of(id, &loan_path, |_, _| {\n-                            self.bccx\n-                                .signal_error();\n-                            false\n-                        });\n-                        return;\n-                    },\n-                    _ => {},\n-                }\n-\n-                // assigning to `P.f` is ok if assigning to `P` is ok\n-                self.check_if_assigned_path_is_moved(id, lp_base);\n-            }\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) |\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // assigning to `P[i]` requires `P` is initialized\n-                // assigning to `(*P)` requires `P` is initialized\n-                self.check_if_path_is_moved(id, lp_base);\n-            }\n-        }\n-    }\n-\n-    fn check_assignment(&self,\n-                        assignment_id: hir::ItemLocalId,\n-                        assignee_cmt: &mc::cmt_<'tcx>) {\n-        debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n-\n-        // Check that we don't invalidate any outstanding loans\n-        if let Some(loan_path) = opt_loan_path(assignee_cmt) {\n-            let scope = region::Scope {\n-                id: assignment_id,\n-                data: region::ScopeData::Node\n-            };\n-            self.each_in_scope_loan_affecting_path(scope, &loan_path, |_| {\n-                self.bccx.signal_error();\n-                false\n-            });\n-        }\n-\n-        // Check for reassignments to (immutable) local variables. This\n-        // needs to be done here instead of in check_loans because we\n-        // depend on move data.\n-        if let Categorization::Local(_) = assignee_cmt.cat {\n-            let lp = opt_loan_path(assignee_cmt).unwrap();\n-            self.move_data.each_assignment_of(assignment_id, &lp, |_| {\n-                if !assignee_cmt.mutbl.is_mutable() {\n-                    self.bccx.signal_error();\n-                }\n-                false\n-            });\n-            return\n-        }\n-    }\n-}"}, {"sha": "2239bf56bbed2bd96b46cd9a1f94d8cb7fe05b1a", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,135 +0,0 @@\n-//! Computes moves.\n-\n-use crate::borrowck::*;\n-use crate::borrowck::move_data::*;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::mem_categorization::InteriorOffsetKind as Kind;\n-use rustc::ty::{self, Ty};\n-\n-use std::rc::Rc;\n-use syntax_pos::Span;\n-use log::debug;\n-\n-struct GatherMoveInfo<'c, 'tcx> {\n-    id: hir::ItemLocalId,\n-    cmt: &'c mc::cmt_<'tcx>,\n-}\n-\n-pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                             move_data: &MoveData<'tcx>,\n-                             var_id: hir::HirId,\n-                             var_ty: Ty<'tcx>) {\n-    let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id.local_id);\n-}\n-\n-pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                       move_data: &MoveData<'tcx>,\n-                                       move_expr_id: hir::ItemLocalId,\n-                                       cmt: &mc::cmt_<'tcx>) {\n-    let move_info = GatherMoveInfo {\n-        id: move_expr_id,\n-        cmt,\n-    };\n-    gather_move(bccx, move_data, move_info);\n-}\n-\n-pub fn gather_move_from_pat<'a, 'c, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    move_data: &MoveData<'tcx>,\n-    move_pat: &hir::Pat,\n-    cmt: &'c mc::cmt_<'tcx>,\n-) {\n-    let move_info = GatherMoveInfo {\n-        id: move_pat.hir_id.local_id,\n-        cmt,\n-    };\n-\n-    debug!(\"gather_move_from_pat: move_pat={:?}\", move_pat);\n-\n-    gather_move(bccx, move_data, move_info);\n-}\n-\n-fn gather_move<'a, 'c, 'tcx>(\n-    bccx: &BorrowckCtxt<'a, 'tcx>,\n-    move_data: &MoveData<'tcx>,\n-    move_info: GatherMoveInfo<'c, 'tcx>,\n-) {\n-    debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n-           move_info.id, move_info.cmt);\n-\n-    let potentially_illegal_move = check_and_get_illegal_move_origin(bccx, move_info.cmt);\n-    if let Some(_) = potentially_illegal_move {\n-        bccx.signal_error();\n-        return;\n-    }\n-\n-    match opt_loan_path(&move_info.cmt) {\n-        Some(loan_path) => {\n-            move_data.add_move(bccx.tcx, loan_path,\n-                               move_info.id);\n-        }\n-        None => {\n-            // move from rvalue or raw pointer, hence ok\n-        }\n-    }\n-}\n-\n-pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                   move_data: &MoveData<'tcx>,\n-                                   assignment_id: hir::ItemLocalId,\n-                                   assignment_span: Span,\n-                                   assignee_loan_path: Rc<LoanPath<'tcx>>) {\n-    move_data.add_assignment(bccx.tcx,\n-                             assignee_loan_path,\n-                             assignment_id,\n-                             assignment_span);\n-}\n-\n-// (keep in sync with move_error::report_cannot_move_out_of )\n-fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                               cmt: &mc::cmt_<'tcx>)\n-                                               -> Option<mc::cmt_<'tcx>> {\n-    match cmt.cat {\n-        Categorization::Deref(_, mc::BorrowedPtr(..)) |\n-        Categorization::Deref(_, mc::UnsafePtr(..)) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            Some(cmt.clone())\n-        }\n-\n-        Categorization::Rvalue(..) |\n-        Categorization::Local(..) |\n-        Categorization::Upvar(..) => {\n-            None\n-        }\n-\n-        Categorization::Downcast(ref b, _) |\n-        Categorization::Interior(ref b, mc::InteriorField(_)) |\n-        Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern)) => {\n-            match b.ty.kind {\n-                ty::Adt(def, _) => {\n-                    if def.has_dtor(bccx.tcx) {\n-                        Some(cmt.clone())\n-                    } else {\n-                        check_and_get_illegal_move_origin(bccx, b)\n-                    }\n-                }\n-                ty::Slice(..) => Some(cmt.clone()),\n-                _ => {\n-                    check_and_get_illegal_move_origin(bccx, b)\n-                }\n-            }\n-        }\n-\n-        Categorization::Interior(_, mc::InteriorElement(Kind::Index)) => {\n-            // Forbid move of arr[i] for arr: [T; 3]; see RFC 533.\n-            Some(cmt.clone())\n-        }\n-\n-        Categorization::Deref(ref b, mc::Unique) => {\n-            check_and_get_illegal_move_origin(bccx, b)\n-        }\n-    }\n-}"}, {"sha": "ff7dd66793d1880d2ce321c31c950cd2ca227b3c", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/lifetime.rs", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,113 +0,0 @@\n-//! This module implements the check that the lifetime of a borrow\n-//! does not exceed the lifetime of the value being borrowed.\n-\n-use crate::borrowck::*;\n-use rustc::hir::HirId;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty;\n-\n-use log::debug;\n-\n-type R = Result<(),()>;\n-\n-pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::Scope,\n-                                    cmt: &'a mc::cmt_<'tcx>,\n-                                    loan_region: ty::Region<'tcx>)\n-                                    -> Result<(),()> {\n-    //! Reports error if `loan_region` is larger than S\n-    //! where S is `item_scope` if `cmt` is an upvar,\n-    //! and is scope of `cmt` otherwise.\n-    debug!(\"guarantee_lifetime(cmt={:?}, loan_region={:?})\",\n-           cmt, loan_region);\n-    let ctxt = GuaranteeLifetimeContext { bccx, item_scope, loan_region };\n-    ctxt.check(cmt, None)\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Private\n-\n-struct GuaranteeLifetimeContext<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-\n-    // the scope of the function body for the enclosing item\n-    item_scope: region::Scope,\n-\n-    loan_region: ty::Region<'tcx>,\n-}\n-\n-impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n-    fn check(&self, cmt: &mc::cmt_<'tcx>, discr_scope: Option<HirId>) -> R {\n-        //! Main routine. Walks down `cmt` until we find the\n-        //! \"guarantor\". Reports an error if `self.loan_region` is\n-        //! larger than scope of `cmt`.\n-        debug!(\"guarantee_lifetime.check(cmt={:?}, loan_region={:?})\",\n-               cmt,\n-               self.loan_region);\n-\n-        match cmt.cat {\n-            Categorization::Rvalue(..) |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Local(..) |                     // L-Local\n-            Categorization::Upvar(..) |\n-            Categorization::Deref(_, mc::BorrowedPtr(..)) | // L-Deref-Borrowed\n-            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n-                self.check_scope(self.scope(cmt))\n-            }\n-\n-            Categorization::StaticItem => {\n-                Ok(())\n-            }\n-\n-            Categorization::Downcast(ref base, _) |\n-            Categorization::Deref(ref base, mc::Unique) |   // L-Deref-Send\n-            Categorization::Interior(ref base, _) => {      // L-Field\n-                self.check(base, discr_scope)\n-            }\n-        }\n-    }\n-\n-    fn check_scope(&self, max_scope: ty::Region<'tcx>) -> R {\n-        //! Reports an error if `loan_region` is larger than `max_scope`\n-\n-        if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            Err(self.bccx.signal_error())\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn scope(&self, cmt: &mc::cmt_<'tcx>) -> ty::Region<'tcx> {\n-        //! Returns the maximal region scope for the which the\n-        //! place `cmt` is guaranteed to be valid without any\n-        //! rooting etc, and presuming `cmt` is not mutated.\n-\n-        match cmt.cat {\n-            Categorization::ThreadLocal(temp_scope) |\n-            Categorization::Rvalue(temp_scope) => {\n-                temp_scope\n-            }\n-            Categorization::Upvar(..) => {\n-                self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n-            }\n-            Categorization::Local(hir_id) => {\n-                self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_scope_tree.var_scope(hir_id.local_id)))\n-            }\n-            Categorization::StaticItem |\n-            Categorization::Deref(_, mc::UnsafePtr(..)) => {\n-                self.bccx.tcx.lifetimes.re_static\n-            }\n-            Categorization::Deref(_, mc::BorrowedPtr(_, r)) => {\n-                r\n-            }\n-            Categorization::Downcast(ref cmt, _) |\n-            Categorization::Deref(ref cmt, mc::Unique) |\n-            Categorization::Interior(ref cmt, _) => {\n-                self.scope(cmt)\n-            }\n-        }\n-    }\n-}"}, {"sha": "16fef705ec9538ef6339b4e121e9d5738418110b", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/mod.rs", "status": "removed", "additions": 0, "deletions": 433, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,433 +0,0 @@\n-// ----------------------------------------------------------------------\n-// Gathering loans\n-//\n-// The borrow check proceeds in two phases. In phase one, we gather the full\n-// set of loans that are required at any point.  These are sorted according to\n-// their associated scopes.  In phase two, checking loans, we will then make\n-// sure that all of these loans are honored.\n-\n-use crate::borrowck::*;\n-use crate::borrowck::move_data::MoveData;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt};\n-\n-use syntax_pos::Span;\n-use rustc::hir;\n-use log::debug;\n-\n-use restrictions::RestrictionResult;\n-\n-mod lifetime;\n-mod restrictions;\n-mod gather_moves;\n-\n-pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    body: hir::BodyId)\n-                                    -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n-    let def_id = bccx.tcx.hir().body_owner_def_id(body);\n-    let param_env = bccx.tcx.param_env(def_id);\n-    let mut glcx = GatherLoanCtxt {\n-        bccx,\n-        all_loans: Vec::new(),\n-        item_ub: region::Scope {\n-            id: bccx.tcx.hir().body(body).value.hir_id.local_id,\n-            data: region::ScopeData::Node\n-        },\n-        move_data: MoveData::default(),\n-    };\n-\n-    let rvalue_promotable_map = bccx.tcx.rvalue_promotable_map(def_id);\n-    euv::ExprUseVisitor::new(&mut glcx,\n-                             bccx.tcx,\n-                             def_id,\n-                             param_env,\n-                             &bccx.region_scope_tree,\n-                             bccx.tables,\n-                             Some(rvalue_promotable_map))\n-        .consume_body(bccx.body);\n-\n-    let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n-    (all_loans, move_data)\n-}\n-\n-struct GatherLoanCtxt<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    move_data: move_data::MoveData<'tcx>,\n-    all_loans: Vec<Loan<'tcx>>,\n-    /// `item_ub` is used as an upper-bound on the lifetime whenever we\n-    /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::Scope,\n-}\n-\n-impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n-    fn consume(&mut self,\n-               consume_id: hir::HirId,\n-               _consume_span: Span,\n-               cmt: &mc::cmt_<'tcx>,\n-               mode: euv::ConsumeMode) {\n-        debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n-               consume_id, cmt, mode);\n-\n-        match mode {\n-            euv::Move(_) => {\n-                gather_moves::gather_move_from_expr(\n-                    self.bccx, &self.move_data,\n-                    consume_id.local_id, cmt);\n-            }\n-            euv::Copy => { }\n-        }\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   matched_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::MatchMode) {\n-        debug!(\"matched_pat(matched_pat={:?}, cmt={:?}, mode={:?})\",\n-               matched_pat,\n-               cmt,\n-               mode);\n-    }\n-\n-    fn consume_pat(&mut self,\n-                   consume_pat: &hir::Pat,\n-                   cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n-        debug!(\"consume_pat(consume_pat={:?}, cmt={:?}, mode={:?})\",\n-               consume_pat,\n-               cmt,\n-               mode);\n-\n-        match mode {\n-            euv::Copy => { return; }\n-            euv::Move(_) => { }\n-        }\n-\n-        gather_moves::gather_move_from_pat(\n-            self.bccx, &self.move_data,\n-            consume_pat, cmt);\n-    }\n-\n-    fn borrow(&mut self,\n-              borrow_id: hir::HirId,\n-              _: Span,\n-              cmt: &mc::cmt_<'tcx>,\n-              loan_region: ty::Region<'tcx>,\n-              bk: ty::BorrowKind,\n-              loan_cause: euv::LoanCause)\n-    {\n-        debug!(\"borrow(borrow_id={}, cmt={:?}, loan_region={:?}, \\\n-               bk={:?}, loan_cause={:?})\",\n-               borrow_id, cmt, loan_region,\n-               bk, loan_cause);\n-\n-        self.guarantee_valid(borrow_id.local_id,\n-                             cmt,\n-                             bk,\n-                             loan_region);\n-    }\n-\n-    fn mutate(&mut self,\n-              assignment_id: hir::HirId,\n-              assignment_span: Span,\n-              assignee_cmt: &mc::cmt_<'tcx>,\n-              _: euv::MutateMode)\n-    {\n-        self.guarantee_assignment_valid(assignment_id,\n-                                        assignment_span,\n-                                        assignee_cmt);\n-    }\n-\n-    fn decl_without_init(&mut self, id: hir::HirId, _span: Span) {\n-        let ty = self.bccx\n-                     .tables\n-                     .node_type(id);\n-        gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n-    }\n-\n-    fn nested_body(&mut self, body_id: hir::BodyId) {\n-        debug!(\"nested_body(body_id={:?})\", body_id);\n-        // rust-lang/rust#58776: MIR and AST borrow check disagree on where\n-        // certain closure errors are reported. As such migrate borrowck has to\n-        // operate at the level of items, rather than bodies. Check if the\n-        // contained closure had any errors and set `signalled_any_error` if it\n-        // has.\n-        let bccx = self.bccx;\n-        if bccx.tcx.migrate_borrowck() {\n-            if let SignalledError::NoErrorsSeen = bccx.signalled_any_error.get() {\n-                let closure_def_id = bccx.tcx.hir().body_owner_def_id(body_id);\n-                debug!(\"checking closure: {:?}\", closure_def_id);\n-\n-                bccx.signalled_any_error.set(bccx.tcx.borrowck(closure_def_id).signalled_any_error);\n-            }\n-        }\n-    }\n-}\n-\n-/// Implements the A-* rules in README.md.\n-fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                cmt: &mc::cmt_<'tcx>,\n-                                req_kind: ty::BorrowKind)\n-                                -> Result<(),()> {\n-\n-    let aliasability = cmt.freely_aliasable();\n-    debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n-           aliasability, req_kind);\n-\n-    match (aliasability, req_kind) {\n-        (mc::Aliasability::NonAliasable, _) => {\n-            /* Uniquely accessible path -- OK for `&` and `&mut` */\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(mc::AliasableStatic), ty::ImmBorrow) => {\n-            // Borrow of an immutable static item.\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(mc::AliasableStaticMut), _) => {\n-            // Even touching a static mut is considered unsafe. We assume the\n-            // user knows what they're doing in these cases.\n-            Ok(())\n-        }\n-        (mc::Aliasability::FreelyAliasable(_), ty::UniqueImmBorrow) |\n-        (mc::Aliasability::FreelyAliasable(_), ty::MutBorrow) => {\n-            bccx.signal_error();\n-            Err(())\n-        }\n-        (..) => {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-/// Implements the M-* rules in README.md.\n-fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                              cmt: &mc::cmt_<'tcx>,\n-                              req_kind: ty::BorrowKind)\n-                              -> Result<(),()> {\n-    debug!(\"check_mutability(cmt={:?} req_kind={:?}\", cmt, req_kind);\n-    match req_kind {\n-        ty::UniqueImmBorrow | ty::ImmBorrow => {\n-            match cmt.mutbl {\n-                // I am intentionally leaving this here to help\n-                // refactoring if, in the future, we should add new\n-                // kinds of mutability.\n-                mc::McImmutable | mc::McDeclared | mc::McInherited => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n-                    Ok(())\n-                }\n-            }\n-        }\n-\n-        ty::MutBorrow => {\n-            // Only mutable data can be lent as mutable.\n-            if !cmt.mutbl.is_mutable() {\n-                Err(bccx.signal_error())\n-            } else {\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'tcx> { self.bccx.tcx }\n-\n-    /// Guarantees that `cmt` is assignable, or reports an error.\n-    fn guarantee_assignment_valid(&mut self,\n-                                  assignment_id: hir::HirId,\n-                                  assignment_span: Span,\n-                                  cmt: &mc::cmt_<'tcx>) {\n-\n-        let opt_lp = opt_loan_path(cmt);\n-        debug!(\"guarantee_assignment_valid(assignment_id={}, cmt={:?}) opt_lp={:?}\",\n-               assignment_id, cmt, opt_lp);\n-\n-        if let Categorization::Local(..) = cmt.cat {\n-            // Only re-assignments to locals require it to be\n-            // mutable - this is checked in check_loans.\n-        } else {\n-            // Check that we don't allow assignments to non-mutable data.\n-            if check_mutability(self.bccx, cmt, ty::MutBorrow).is_err() {\n-                return; // reported an error, no sense in reporting more.\n-            }\n-        }\n-\n-        // Check that we don't allow assignments to aliasable data\n-        if check_aliasability(self.bccx, cmt, ty::MutBorrow).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        match opt_lp {\n-            Some(lp) => {\n-                gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id.local_id,\n-                                                assignment_span,\n-                                                lp);\n-            }\n-            None => {\n-                // This can occur with e.g., `*foo() = 5`.  In such\n-                // cases, there is no need to check for conflicts\n-                // with moves etc, just ignore.\n-            }\n-        }\n-    }\n-\n-    /// Guarantees that `addr_of(cmt)` will be valid for the duration of `static_scope_r`, or\n-    /// reports an error. This may entail taking out loans, which will be added to the\n-    /// `req_loan_map`.\n-    fn guarantee_valid(&mut self,\n-                       borrow_id: hir::ItemLocalId,\n-                       cmt: &mc::cmt_<'tcx>,\n-                       req_kind: ty::BorrowKind,\n-                       loan_region: ty::Region<'tcx>) {\n-        debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n-                req_mutbl={:?}, loan_region={:?})\",\n-               borrow_id,\n-               cmt,\n-               req_kind,\n-               loan_region);\n-\n-        // a loan for the empty region can never be dereferenced, so\n-        // it is always safe\n-        if *loan_region == ty::ReEmpty {\n-            return;\n-        }\n-\n-        // Check that the lifetime of the borrow does not exceed\n-        // the lifetime of the data being borrowed.\n-        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, cmt, loan_region).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, cmt, req_kind).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, cmt, req_kind).is_err() {\n-            return; // reported an error, no sense in reporting more.\n-        }\n-\n-        // Compute the restrictions that are required to enforce the\n-        // loan is safe.\n-        let restr = restrictions::compute_restrictions(self.bccx, &cmt, loan_region);\n-\n-        debug!(\"guarantee_valid(): restrictions={:?}\", restr);\n-\n-        // Create the loan record (if needed).\n-        let loan = match restr {\n-            RestrictionResult::Safe => {\n-                // No restrictions---no loan record necessary\n-                return;\n-            }\n-\n-            RestrictionResult::SafeIf(loan_path, restricted_paths) => {\n-                let loan_scope = match *loan_region {\n-                    ty::ReScope(scope) => scope,\n-\n-                    ty::ReEarlyBound(ref br) => {\n-                        self.bccx.region_scope_tree.early_free_scope(self.tcx(), br)\n-                    }\n-\n-                    ty::ReFree(ref fr) => {\n-                        self.bccx.region_scope_tree.free_scope(self.tcx(), fr)\n-                    }\n-\n-                    ty::ReStatic => self.item_ub,\n-\n-                    ty::ReEmpty |\n-                    ty::ReClosureBound(..) |\n-                    ty::ReLateBound(..) |\n-                    ty::ReVar(..) |\n-                    ty::RePlaceholder(..) |\n-                    ty::ReErased => {\n-                        span_bug!(\n-                            cmt.span,\n-                            \"invalid borrow lifetime: {:?}\",\n-                            loan_region);\n-                    }\n-                };\n-                debug!(\"loan_scope = {:?}\", loan_scope);\n-\n-                let borrow_scope = region::Scope {\n-                    id: borrow_id,\n-                    data: region::ScopeData::Node\n-                };\n-                let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n-                debug!(\"gen_scope = {:?}\", gen_scope);\n-\n-                let kill_scope = self.compute_kill_scope(loan_scope, &loan_path);\n-                debug!(\"kill_scope = {:?}\", kill_scope);\n-\n-                Loan {\n-                    index: self.all_loans.len(),\n-                    loan_path,\n-                    kind: req_kind,\n-                    gen_scope,\n-                    kill_scope,\n-                    restricted_paths,\n-                }\n-            }\n-        };\n-\n-        debug!(\"guarantee_valid(borrow_id={:?}), loan={:?}\",\n-               borrow_id, loan);\n-\n-        // let loan_path = loan.loan_path;\n-        // let loan_gen_scope = loan.gen_scope;\n-        // let loan_kill_scope = loan.kill_scope;\n-        self.all_loans.push(loan);\n-    }\n-\n-    pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::Scope,\n-                             loan_scope: region::Scope)\n-                             -> region::Scope {\n-        //! Determine when to introduce the loan. Typically the loan\n-        //! is introduced at the point of the borrow, but in some cases,\n-        //! notably method arguments, the loan may be introduced only\n-        //! later, once it comes into scope.\n-\n-        if self.bccx.region_scope_tree.is_subscope_of(borrow_scope, loan_scope) {\n-            borrow_scope\n-        } else {\n-            loan_scope\n-        }\n-    }\n-\n-    pub fn compute_kill_scope(&self, loan_scope: region::Scope, lp: &LoanPath<'tcx>)\n-                              -> region::Scope {\n-        //! Determine when the loan restrictions go out of scope.\n-        //! This is either when the lifetime expires or when the\n-        //! local variable which roots the loan-path goes out of scope,\n-        //! whichever happens faster.\n-        //!\n-        //! It may seem surprising that we might have a loan region\n-        //! larger than the variable which roots the loan-path; this can\n-        //! come about when variables of `&mut` type are re-borrowed,\n-        //! as in this example:\n-        //!\n-        //!     struct Foo { counter: u32 }\n-        //!\n-        //!     fn counter<'a>(v: &'a mut Foo) -> &'a mut u32 {\n-        //!         &mut v.counter\n-        //!     }\n-        //!\n-        //! In this case, the reference (`'a`) outlives the\n-        //! variable `v` that hosts it. Note that this doesn't come up\n-        //! with immutable `&` pointers, because borrows of such pointers\n-        //! do not require restrictions and hence do not cause a loan.\n-\n-        let lexical_scope = lp.kill_scope(self.bccx);\n-        if self.bccx.region_scope_tree.is_subscope_of(lexical_scope, loan_scope) {\n-            lexical_scope\n-        } else {\n-            assert!(self.bccx.region_scope_tree.is_subscope_of(loan_scope, lexical_scope));\n-            loan_scope\n-        }\n-    }\n-}"}, {"sha": "ee5099a97d57fcf8fc88e04d39d477bb65ad2bd8", "filename": "src/librustc_ast_borrowck/borrowck/gather_loans/restrictions.rs", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,179 +0,0 @@\n-//! Computes the restrictions that result from a borrow.\n-\n-use crate::borrowck::*;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::ty;\n-use log::debug;\n-\n-use crate::borrowck::ToInteriorKind;\n-\n-use std::rc::Rc;\n-\n-#[derive(Debug)]\n-pub enum RestrictionResult<'tcx> {\n-    Safe,\n-    SafeIf(Rc<LoanPath<'tcx>>, Vec<Rc<LoanPath<'tcx>>>)\n-}\n-\n-pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      cmt: &mc::cmt_<'tcx>,\n-                                      loan_region: ty::Region<'tcx>)\n-                                      -> RestrictionResult<'tcx> {\n-    let ctxt = RestrictionsContext { bccx, loan_region };\n-\n-    ctxt.restrict(cmt)\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Private\n-\n-struct RestrictionsContext<'a, 'tcx> {\n-    bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    loan_region: ty::Region<'tcx>,\n-}\n-\n-impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n-    fn restrict(&self,\n-                cmt: &mc::cmt_<'tcx>) -> RestrictionResult<'tcx> {\n-        debug!(\"restrict(cmt={:?})\", cmt);\n-\n-        let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n-\n-        match cmt.cat.clone() {\n-            Categorization::Rvalue(..) => {\n-                // Effectively, rvalues are stored into a\n-                // non-aliasable temporary on the stack. Since they\n-                // are inherently non-aliasable, they can only be\n-                // accessed later through the borrow itself and hence\n-                // must inherently comply with its terms.\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::ThreadLocal(..) => {\n-                // Thread-locals are statics that have a scope, with\n-                // no underlying structure to provide restrictions.\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::Local(local_id) => {\n-                // R-Variable, locally declared\n-                let lp = new_lp(LpVar(local_id));\n-                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n-            }\n-\n-            Categorization::Upvar(mc::Upvar { id, .. }) => {\n-                // R-Variable, captured into closure\n-                let lp = new_lp(LpUpvar(id));\n-                RestrictionResult::SafeIf(lp.clone(), vec![lp])\n-            }\n-\n-            Categorization::Downcast(cmt_base, _) => {\n-                // When we borrow the interior of an enum, we have to\n-                // ensure the enum itself is not mutated, because that\n-                // could cause the type of the memory to change.\n-                self.restrict(&cmt_base)\n-            }\n-\n-            Categorization::Interior(cmt_base, interior) => {\n-                // R-Field\n-                //\n-                // Overwriting the base would not change the type of\n-                // the memory, so no additional restrictions are\n-                // needed.\n-                let opt_variant_id = match cmt_base.cat {\n-                    Categorization::Downcast(_, variant_id) => Some(variant_id),\n-                    _ => None\n-                };\n-                let interior = interior.cleaned();\n-                let base_ty = cmt_base.ty;\n-                let result = self.restrict(&cmt_base);\n-                // Borrowing one union field automatically borrows all its fields.\n-                match base_ty.kind {\n-                    ty::Adt(adt_def, _) if adt_def.is_union() => match result {\n-                        RestrictionResult::Safe => RestrictionResult::Safe,\n-                        RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                            for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                                let field = InteriorKind::InteriorField(\n-                                    mc::FieldIndex(i, field.ident.name)\n-                                );\n-                                let field_ty = if field == interior {\n-                                    cmt.ty\n-                                } else {\n-                                    self.bccx.tcx.types.err // Doesn't matter\n-                                };\n-                                let sibling_lp_kind = LpExtend(base_lp.clone(), cmt.mutbl,\n-                                                               LpInterior(opt_variant_id, field));\n-                                let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                                base_vec.push(sibling_lp);\n-                            }\n-\n-                            let lp = new_lp(LpExtend(base_lp, cmt.mutbl,\n-                                                     LpInterior(opt_variant_id, interior)));\n-                            RestrictionResult::SafeIf(lp, base_vec)\n-                        }\n-                    },\n-                    _ => self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n-                }\n-            }\n-\n-            Categorization::StaticItem => {\n-                RestrictionResult::Safe\n-            }\n-\n-            Categorization::Deref(cmt_base, pk) => {\n-                match pk {\n-                    mc::Unique => {\n-                        // R-Deref-Send-Pointer\n-                        //\n-                        // When we borrow the interior of a box, we\n-                        // cannot permit the base to be mutated, because that\n-                        // would cause the unique pointer to be freed.\n-                        //\n-                        // Eventually we should make these non-special and\n-                        // just rely on Deref<T> implementation.\n-                        let result = self.restrict(&cmt_base);\n-                        self.extend(result, &cmt, LpDeref(pk))\n-                    }\n-                    mc::BorrowedPtr(bk, lt) => {\n-                        // R-Deref-[Mut-]Borrowed\n-                        if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                            self.bccx.signal_error();\n-                            return RestrictionResult::Safe;\n-                        }\n-\n-                        match bk {\n-                            ty::ImmBorrow => RestrictionResult::Safe,\n-                            ty::MutBorrow | ty::UniqueImmBorrow => {\n-                                // R-Deref-Mut-Borrowed\n-                                //\n-                                // The referent can be aliased after the\n-                                // references lifetime ends (by a newly-unfrozen\n-                                // borrow).\n-                                let result = self.restrict(&cmt_base);\n-                                self.extend(result, &cmt, LpDeref(pk))\n-                            }\n-                        }\n-                    }\n-                    // Borrowck is not relevant for raw pointers\n-                    mc::UnsafePtr(..) => RestrictionResult::Safe\n-                }\n-            }\n-        }\n-    }\n-\n-    fn extend(&self,\n-              result: RestrictionResult<'tcx>,\n-              cmt: &mc::cmt_<'tcx>,\n-              elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n-        match result {\n-            RestrictionResult::Safe => RestrictionResult::Safe,\n-            RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n-                let v = LpExtend(base_lp, cmt.mutbl, elem);\n-                let lp = Rc::new(LoanPath::new(v, cmt.ty));\n-                base_vec.push(lp.clone());\n-                RestrictionResult::SafeIf(lp, base_vec)\n-            }\n-        }\n-    }\n-}"}, {"sha": "40e28299a5c0a15eac451b9565c236298d125dc7", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,621 +0,0 @@\n-//! See The Book chapter on the borrow checker for more details.\n-\n-#![allow(non_camel_case_types)]\n-\n-pub use LoanPathKind::*;\n-pub use LoanPathElem::*;\n-\n-use InteriorKind::*;\n-\n-use rustc::hir::HirId;\n-use rustc::hir::Node;\n-use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n-use rustc::hir::def_id::{DefId, LocalDefId};\n-use rustc::middle::mem_categorization as mc;\n-use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::region;\n-use rustc::middle::free_region::RegionRelations;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::query::Providers;\n-\n-use std::borrow::Cow;\n-use std::cell::{Cell};\n-use std::fmt;\n-use std::rc::Rc;\n-use std::hash::{Hash, Hasher};\n-use log::debug;\n-\n-use rustc::hir;\n-\n-use crate::cfg;\n-use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n-\n-pub mod check_loans;\n-\n-pub mod gather_loans;\n-\n-pub mod move_data;\n-\n-#[derive(Clone, Copy)]\n-pub struct LoanDataFlowOperator;\n-\n-pub type LoanDataFlow<'tcx> = DataFlowContext<'tcx, LoanDataFlowOperator>;\n-\n-pub fn check_crate(tcx: TyCtxt<'_>) {\n-    tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().borrowck(body_owner_def_id);\n-    });\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        borrowck,\n-        ..*providers\n-    };\n-}\n-\n-/// Collection of conclusions determined via borrow checker analyses.\n-pub struct AnalysisData<'tcx> {\n-    pub all_loans: Vec<Loan<'tcx>>,\n-    pub loans: DataFlowContext<'tcx, LoanDataFlowOperator>,\n-    pub move_data: move_data::FlowedMoveData<'tcx>,\n-}\n-\n-fn borrowck(tcx: TyCtxt<'_>, owner_def_id: DefId) -> &BorrowCheckResult {\n-    assert!(tcx.use_ast_borrowck() || tcx.migrate_borrowck());\n-\n-    debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n-\n-    let signalled_error = tcx.check_match(owner_def_id);\n-    if let SignalledError::SawSomeError = signalled_error {\n-        return tcx.arena.alloc(BorrowCheckResult {\n-            signalled_any_error: SignalledError::SawSomeError,\n-        })\n-    }\n-\n-    let owner_id = tcx.hir().as_local_hir_id(owner_def_id).unwrap();\n-\n-    match tcx.hir().get(owner_id) {\n-        Node::Ctor(..) => {\n-            // We get invoked with anything that has MIR, but some of\n-            // those things (notably the synthesized constructors from\n-            // tuple structs/variants) do not have an associated body\n-            // and do not need borrowchecking.\n-            return tcx.arena.alloc(BorrowCheckResult {\n-                signalled_any_error: SignalledError::NoErrorsSeen,\n-            })\n-        }\n-        _ => { }\n-    }\n-\n-    let body_id = tcx.hir().body_owned_by(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    // Eventually, borrowck will always read the MIR, but at the\n-    // moment we do not. So, for now, we always force MIR to be\n-    // constructed for a given fn, since this may result in errors\n-    // being reported and we want that to happen.\n-    //\n-    // Note that `mir_validated` is a \"stealable\" result; the\n-    // thief, `optimized_mir()`, forces borrowck, so we know that\n-    // is not yet stolen.\n-    tcx.ensure().mir_validated(owner_def_id);\n-\n-    // option dance because you can't capture an uninitialized variable\n-    // by mut-ref.\n-    let mut cfg = None;\n-    if let Some(AnalysisData { all_loans,\n-                               loans: loan_dfcx,\n-                               move_data: flowed_moves }) =\n-        build_borrowck_dataflow_data(&mut bccx, false, body_id,\n-                                     |bccx| {\n-                                         cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n-                                         cfg.as_mut().unwrap()\n-                                     })\n-    {\n-        check_loans::check_loans(&mut bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n-    }\n-\n-    tcx.arena.alloc(BorrowCheckResult {\n-        signalled_any_error: bccx.signalled_any_error.into_inner(),\n-    })\n-}\n-\n-fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                                 force_analysis: bool,\n-                                                 body_id: hir::BodyId,\n-                                                 get_cfg: F)\n-                                                 -> Option<AnalysisData<'tcx>>\n-    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n-{\n-    // Check the body of fn items.\n-    let (all_loans, move_data) =\n-        gather_loans::gather_loans_in_fn(this, body_id);\n-\n-    if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n-        // large arrays of data inserted as constants can take a lot of\n-        // time and memory to borrow-check - see issue #36799. However,\n-        // they don't have places, so no borrow-check is actually needed.\n-        // Recognize that case and skip borrow-checking.\n-        debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n-        return None;\n-    } else {\n-        debug!(\"propagating loans in {:?}\", body_id);\n-    }\n-\n-    let cfg = get_cfg(this);\n-    let mut loan_dfcx =\n-        DataFlowContext::new(this.tcx,\n-                             \"borrowck\",\n-                             Some(this.body),\n-                             cfg,\n-                             LoanDataFlowOperator,\n-                             all_loans.len());\n-    for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n-        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.item_local_id(),\n-                           loan_idx);\n-    }\n-    loan_dfcx.add_kills_from_flow_exits(cfg);\n-    loan_dfcx.propagate(cfg, this.body);\n-\n-    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                      this,\n-                                                      cfg,\n-                                                      this.body);\n-\n-    Some(AnalysisData { all_loans,\n-                        loans: loan_dfcx,\n-                        move_data:flowed_moves })\n-}\n-\n-/// Accessor for introspective clients inspecting `AnalysisData` and\n-/// the `BorrowckCtxt` itself , e.g., the flowgraph visualizer.\n-pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    body_id: hir::BodyId,\n-    cfg: &cfg::CFG)\n-    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>)\n-{\n-    let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id(owner_id);\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-    let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n-    let body = tcx.hir().body(body_id);\n-    let mut bccx = BorrowckCtxt {\n-        tcx,\n-        tables,\n-        region_scope_tree,\n-        owner_def_id,\n-        body,\n-        signalled_any_error: Cell::new(SignalledError::NoErrorsSeen),\n-    };\n-\n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n-    (bccx, dataflow_data.unwrap())\n-}\n-\n-// ----------------------------------------------------------------------\n-// Type definitions\n-\n-pub struct BorrowckCtxt<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    // tables for the current thing we are checking; set to\n-    // Some in `borrowck_fn` and cleared later\n-    tables: &'a ty::TypeckTables<'tcx>,\n-\n-    region_scope_tree: &'tcx region::ScopeTree,\n-\n-    owner_def_id: DefId,\n-\n-    body: &'tcx hir::Body,\n-\n-    signalled_any_error: Cell<SignalledError>,\n-}\n-\n-\n-impl<'a, 'tcx: 'a> BorrowckCtxt<'a, 'tcx> {\n-    fn signal_error(&self) {\n-        self.signalled_any_error.set(SignalledError::SawSomeError);\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Loans and loan paths\n-\n-/// Record of a loan that was issued.\n-pub struct Loan<'tcx> {\n-    index: usize,\n-    loan_path: Rc<LoanPath<'tcx>>,\n-    kind: ty::BorrowKind,\n-    restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n-\n-    /// gen_scope indicates where loan is introduced. Typically the\n-    /// loan is introduced at the point of the borrow, but in some\n-    /// cases, notably method arguments, the loan may be introduced\n-    /// only later, once it comes into scope. See also\n-    /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::Scope,\n-\n-    /// kill_scope indicates when the loan goes out of scope. This is\n-    /// either when the lifetime expires or when the local variable\n-    /// which roots the loan-path goes out of scope, whichever happens\n-    /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::Scope,\n-}\n-\n-impl<'tcx> Loan<'tcx> {\n-    pub fn loan_path(&self) -> Rc<LoanPath<'tcx>> {\n-        self.loan_path.clone()\n-    }\n-}\n-\n-#[derive(Eq)]\n-pub struct LoanPath<'tcx> {\n-    kind: LoanPathKind<'tcx>,\n-    ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> PartialEq for LoanPath<'tcx> {\n-    fn eq(&self, that: &LoanPath<'tcx>) -> bool {\n-        self.kind == that.kind\n-    }\n-}\n-\n-impl<'tcx> Hash for LoanPath<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.kind.hash(state);\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathKind<'tcx> {\n-    LpVar(hir::HirId),                          // `x` in README.md\n-    LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n-    LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n-}\n-\n-impl<'tcx> LoanPath<'tcx> {\n-    fn new(kind: LoanPathKind<'tcx>, ty: Ty<'tcx>) -> LoanPath<'tcx> {\n-        LoanPath { kind: kind, ty: ty }\n-    }\n-\n-    fn to_type(&self) -> Ty<'tcx> { self.ty }\n-}\n-\n-// FIXME (pnkfelix): See discussion here\n-// https://github.com/pnkfelix/rust/commit/\n-//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n-const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n-\n-// A local, \"cleaned\" version of `mc::InteriorKind` that drops\n-// information that is not relevant to loan-path analysis. (In\n-// particular, the distinction between how precisely an array-element\n-// is tracked is irrelevant here.)\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum InteriorKind {\n-    InteriorField(mc::FieldIndex),\n-    InteriorElement,\n-}\n-\n-trait ToInteriorKind { fn cleaned(self) -> InteriorKind; }\n-impl ToInteriorKind for mc::InteriorKind {\n-    fn cleaned(self) -> InteriorKind {\n-        match self {\n-            mc::InteriorField(name) => InteriorField(name),\n-            mc::InteriorElement(_) => InteriorElement,\n-        }\n-    }\n-}\n-\n-// This can be:\n-// - a pointer dereference (`*P` in README.md)\n-// - a field reference, with an optional definition of the containing\n-//   enum variant (`P.f` in README.md)\n-// `DefId` is present when the field is part of struct that is in\n-// a variant of an enum. For instance in:\n-// `enum E { X { foo: u32 }, Y { foo: u32 }}`\n-// each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathElem<'tcx> {\n-    LpDeref(mc::PointerKind<'tcx>),\n-    LpInterior(Option<DefId>, InteriorKind),\n-}\n-\n-fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n-    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n-    match tcx.hir().get(closure_id) {\n-        Node::Expr(expr) => match expr.kind {\n-            hir::ExprKind::Closure(.., body_id, _, _) => {\n-                body_id.hir_id\n-            }\n-            _ => {\n-                bug!(\"encountered non-closure id: {}\", closure_id)\n-            }\n-        },\n-        _ => bug!(\"encountered non-expr id: {}\", closure_id)\n-    }\n-}\n-\n-impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::Scope {\n-        match self.kind {\n-            LpVar(hir_id) => {\n-                bccx.region_scope_tree.var_scope(hir_id.local_id)\n-            }\n-            LpUpvar(upvar_id) => {\n-                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::Scope { id: block_id.local_id, data: region::ScopeData::Node }\n-            }\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => base.kill_scope(bccx),\n-        }\n-    }\n-}\n-\n-// Avoid \"cannot borrow immutable field `self.x` as mutable\" as that implies that a field *can* be\n-// mutable independently of the struct it belongs to. (#35937)\n-pub fn opt_loan_path_is_field<'tcx>(cmt: &mc::cmt_<'tcx>) -> (Option<Rc<LoanPath<'tcx>>>, bool) {\n-    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n-\n-    match cmt.cat {\n-        Categorization::Rvalue(..) |\n-        Categorization::ThreadLocal(..) |\n-        Categorization::StaticItem => {\n-            (None, false)\n-        }\n-\n-        Categorization::Local(id) => {\n-            (Some(new_lp(LpVar(id))), false)\n-        }\n-\n-        Categorization::Upvar(mc::Upvar { id, .. }) => {\n-            (Some(new_lp(LpUpvar(id))), false)\n-        }\n-\n-        Categorization::Deref(ref cmt_base, pk) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n-            }), lp.1)\n-        }\n-\n-        Categorization::Interior(ref cmt_base, ik) => {\n-            (opt_loan_path(cmt_base).map(|lp| {\n-                let opt_variant_id = match cmt_base.cat {\n-                    Categorization::Downcast(_, did) =>  Some(did),\n-                    _ => None\n-                };\n-                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(opt_variant_id, ik.cleaned())))\n-            }), true)\n-        }\n-\n-        Categorization::Downcast(ref cmt_base, variant_def_id) => {\n-            let lp = opt_loan_path_is_field(cmt_base);\n-            (lp.0.map(|lp| {\n-                new_lp(LpDowncast(lp, variant_def_id))\n-            }), lp.1)\n-        }\n-    }\n-}\n-\n-/// Computes the `LoanPath` (if any) for a `cmt`.\n-/// Note that this logic is somewhat duplicated in\n-/// the method `compute()` found in `gather_loans::restrictions`,\n-/// which allows it to share common loan path pieces as it\n-/// traverses the CMT.\n-pub fn opt_loan_path<'tcx>(cmt: &mc::cmt_<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n-    opt_loan_path_is_field(cmt).0\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Misc\n-\n-impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n-    pub fn is_subregion_of(&self,\n-                           r_sub: ty::Region<'tcx>,\n-                           r_sup: ty::Region<'tcx>)\n-                           -> bool\n-    {\n-        let region_rels = RegionRelations::new(self.tcx,\n-                                               self.owner_def_id,\n-                                               &self.region_scope_tree,\n-                                               &self.tables.free_region_map);\n-        region_rels.is_subregion_of(r_sub, r_sup)\n-    }\n-\n-    pub fn append_loan_path_to_string(&self,\n-                                      loan_path: &LoanPath<'tcx>,\n-                                      out: &mut String) {\n-        match loan_path.kind {\n-            LpUpvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id: id }, closure_expr_id: _ }) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-            LpVar(id) => {\n-                out.push_str(&self.tcx.hir().name(id).as_str());\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(_, info)))) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push('.');\n-                out.push_str(&info.as_str());\n-            }\n-\n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(\"[..]\");\n-            }\n-\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                out.push('*');\n-                self.append_loan_path_to_string(&lp_base, out);\n-            }\n-        }\n-    }\n-\n-    pub fn append_autoderefd_loan_path_to_string(&self,\n-                                                 loan_path: &LoanPath<'tcx>,\n-                                                 out: &mut String) {\n-        match loan_path.kind {\n-            LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n-                // rules would normally allow users to omit the `*x`.\n-                // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out)\n-            }\n-\n-            LpDowncast(ref lp_base, variant_def_id) => {\n-                out.push('(');\n-                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&self.tcx.def_path_str(variant_def_id));\n-                out.push(')');\n-            }\n-\n-            LpVar(..) | LpUpvar(..) | LpExtend(.., LpInterior(..)) => {\n-                self.append_loan_path_to_string(loan_path, out)\n-            }\n-        }\n-    }\n-\n-    pub fn loan_path_to_string(&self, loan_path: &LoanPath<'tcx>) -> String {\n-        let mut result = String::new();\n-        self.append_loan_path_to_string(loan_path, &mut result);\n-        result\n-    }\n-\n-    pub fn cmt_to_cow_str(&self, cmt: &mc::cmt_<'tcx>) -> Cow<'static, str> {\n-        cmt.descriptive_string(self.tcx)\n-    }\n-\n-    pub fn cmt_to_path_or_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n-        match opt_loan_path(cmt) {\n-            Some(lp) => format!(\"`{}`\", self.loan_path_to_string(&lp)),\n-            None => self.cmt_to_cow_str(cmt).into_owned(),\n-        }\n-    }\n-}\n-\n-impl BitwiseOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // loans from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for LoanDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-impl fmt::Debug for InteriorKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            InteriorField(mc::FieldIndex(_, info)) => write!(f, \"{}\", info),\n-            InteriorElement => write!(f, \"[]\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Loan<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Loan_{}({:?}, {:?}, {:?}-{:?}, {:?})\",\n-               self.index,\n-               self.loan_path,\n-               self.kind,\n-               self.gen_scope,\n-               self.kill_scope,\n-               self.restricted_paths)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(var_id)\n-                });\n-                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({:?}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{:?}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{:?}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for LoanPath<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.kind {\n-            LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_user_string(id)))\n-            }\n-\n-            LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| {\n-                    tcx.hir().node_to_string(hir_id)\n-                });\n-                write!(f, \"$({} captured by closure)\", s)\n-            }\n-\n-            LpDowncast(ref lp, variant_def_id) => {\n-                let variant_str = if variant_def_id.is_local() {\n-                    ty::tls::with(|tcx| tcx.def_path_str(variant_def_id))\n-                } else {\n-                    format!(\"{:?}\", variant_def_id)\n-                };\n-                write!(f, \"({}{}{})\", lp, DOWNCAST_PRINTED_OPERATOR, variant_str)\n-            }\n-\n-            LpExtend(ref lp, _, LpDeref(_)) => {\n-                write!(f, \"{}.*\", lp)\n-            }\n-\n-            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n-                write!(f, \"{}.{:?}\", lp, interior)\n-            }\n-        }\n-    }\n-}"}, {"sha": "6bc42348bcf6c8db059c44a4b8d17a17f9b3a1e5", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "removed", "additions": 0, "deletions": 730, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,730 +0,0 @@\n-//! Data structures used for tracking moves. Please see the extensive\n-//! comments in the section \"Moves and initialization\" in `README.md`.\n-\n-use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n-\n-use crate::borrowck::*;\n-use crate::cfg;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::FxHashMap;\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-use std::usize;\n-use syntax_pos::Span;\n-use rustc::hir;\n-use log::debug;\n-\n-#[derive(Default)]\n-pub struct MoveData<'tcx> {\n-    /// Move paths. See section \"Move paths\" in `README.md`.\n-    pub paths: RefCell<Vec<MovePath<'tcx>>>,\n-\n-    /// Cache of loan path to move path index, for easy lookup.\n-    pub path_map: RefCell<FxHashMap<Rc<LoanPath<'tcx>>, MovePathIndex>>,\n-\n-    /// Each move or uninitialized variable gets an entry here.\n-    pub moves: RefCell<Vec<Move>>,\n-\n-    /// Assignments to a variable, like `x = foo`. These are assigned\n-    /// bits for dataflow, since we must track them to ensure that\n-    /// immutable variables are assigned at most once along each path.\n-    pub var_assignments: RefCell<Vec<Assignment>>,\n-\n-    /// Assignments to a path, like `x.f = foo`. These are not\n-    /// assigned dataflow bits, but we track them because they still\n-    /// kill move bits.\n-    pub path_assignments: RefCell<Vec<Assignment>>,\n-}\n-\n-pub struct FlowedMoveData<'tcx> {\n-    pub move_data: MoveData<'tcx>,\n-\n-    pub dfcx_moves: MoveDataFlow<'tcx>,\n-\n-    // We could (and maybe should, for efficiency) combine both move\n-    // and assign data flow into one, but this way it's easier to\n-    // distinguish the bits that correspond to moves and assignments.\n-    pub dfcx_assign: AssignDataFlow<'tcx>,\n-}\n-\n-/// Index into `MoveData.paths`, used like a pointer\n-#[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-pub struct MovePathIndex(usize);\n-\n-impl MovePathIndex {\n-    fn get(&self) -> usize {\n-        let MovePathIndex(v) = *self; v\n-    }\n-}\n-\n-impl Clone for MovePathIndex {\n-    fn clone(&self) -> MovePathIndex {\n-        MovePathIndex(self.get())\n-    }\n-}\n-\n-#[allow(non_upper_case_globals)]\n-const InvalidMovePathIndex: MovePathIndex = MovePathIndex(usize::MAX);\n-\n-/// Index into `MoveData.moves`, used like a pointer\n-#[derive(Copy, Clone, PartialEq)]\n-pub struct MoveIndex(usize);\n-\n-impl MoveIndex {\n-    fn get(&self) -> usize {\n-        let MoveIndex(v) = *self; v\n-    }\n-}\n-\n-#[allow(non_upper_case_globals)]\n-const InvalidMoveIndex: MoveIndex = MoveIndex(usize::MAX);\n-\n-pub struct MovePath<'tcx> {\n-    /// Loan path corresponding to this move path\n-    pub loan_path: Rc<LoanPath<'tcx>>,\n-\n-    /// Parent pointer, `InvalidMovePathIndex` if root\n-    pub parent: MovePathIndex,\n-\n-    /// Head of linked list of moves to this path,\n-    /// `InvalidMoveIndex` if not moved\n-    pub first_move: MoveIndex,\n-\n-    /// First node in linked list of children, `InvalidMovePathIndex` if leaf\n-    pub first_child: MovePathIndex,\n-\n-    /// Next node in linked list of parent's children (siblings),\n-    /// `InvalidMovePathIndex` if none.\n-    pub next_sibling: MovePathIndex,\n-}\n-\n-\n-#[derive(Copy, Clone)]\n-pub struct Move {\n-    /// Path being moved.\n-    pub path: MovePathIndex,\n-\n-    /// ID of node that is doing the move.\n-    pub id: hir::ItemLocalId,\n-\n-    /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n-    pub next_move: MoveIndex\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Assignment {\n-    /// Path being assigned.\n-    pub path: MovePathIndex,\n-\n-    /// ID where assignment occurs\n-    pub id: hir::ItemLocalId,\n-\n-    /// span of node where assignment occurs\n-    pub span: Span,\n-}\n-\n-#[derive(Clone, Copy)]\n-pub struct MoveDataFlowOperator;\n-\n-pub type MoveDataFlow<'tcx> = DataFlowContext<'tcx, MoveDataFlowOperator>;\n-\n-#[derive(Clone, Copy)]\n-pub struct AssignDataFlowOperator;\n-\n-pub type AssignDataFlow<'tcx> = DataFlowContext<'tcx, AssignDataFlowOperator>;\n-\n-fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n-    match loan_path.kind {\n-        LpVar(_) | LpUpvar(_) => {\n-            true\n-        }\n-        LpExtend(.., LpInterior(_, InteriorKind::InteriorElement)) => {\n-            // Paths involving element accesses a[i] do not refer to a unique\n-            // location, as there is no accurate tracking of the indices.\n-            //\n-            // (Paths involving element accesses via slice pattern bindings\n-            // can in principle be tracked precisely, but that is future\n-            // work. For now, continue claiming that they are imprecise.)\n-            false\n-        }\n-        LpDowncast(ref lp_base, _) |\n-        LpExtend(ref lp_base, ..) => {\n-            loan_path_is_precise(&lp_base)\n-        }\n-    }\n-}\n-\n-impl MoveData<'tcx> {\n-    /// Returns `true` if there are no trackable assignments or moves\n-    /// in this move data -- that means that there is nothing that\n-    /// could cause a borrow error.\n-    pub fn is_empty(&self) -> bool {\n-        self.moves.borrow().is_empty() &&\n-            self.path_assignments.borrow().is_empty() &&\n-            self.var_assignments.borrow().is_empty()\n-    }\n-\n-    pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath<'tcx>> {\n-        (*self.paths.borrow())[index.get()].loan_path.clone()\n-    }\n-\n-    fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].parent\n-    }\n-\n-    fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n-        (*self.paths.borrow())[index.get()].first_move\n-    }\n-\n-    /// Returns the index of first child, or `InvalidMovePathIndex` if\n-    /// `index` is leaf.\n-    fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].first_child\n-    }\n-\n-    fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n-        (*self.paths.borrow())[index.get()].next_sibling\n-    }\n-\n-    fn set_path_first_move(&self,\n-                           index: MovePathIndex,\n-                           first_move: MoveIndex) {\n-        (*self.paths.borrow_mut())[index.get()].first_move = first_move\n-    }\n-\n-    fn set_path_first_child(&self,\n-                            index: MovePathIndex,\n-                            first_child: MovePathIndex) {\n-        (*self.paths.borrow_mut())[index.get()].first_child = first_child\n-    }\n-\n-    fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n-        //! Type safe indexing operator\n-        (*self.moves.borrow())[index.get()].next_move\n-    }\n-\n-    fn is_var_path(&self, index: MovePathIndex) -> bool {\n-        //! True if `index` refers to a variable\n-        self.path_parent(index) == InvalidMovePathIndex\n-    }\n-\n-    /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n-    /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'tcx>, lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n-        if let Some(&index) = self.path_map.borrow().get(&lp) {\n-            return index;\n-        }\n-\n-        let index = match lp.kind {\n-            LpVar(..) | LpUpvar(..) => {\n-                let index = MovePathIndex(self.paths.borrow().len());\n-\n-                self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp.clone(),\n-                    parent: InvalidMovePathIndex,\n-                    first_move: InvalidMoveIndex,\n-                    first_child: InvalidMovePathIndex,\n-                    next_sibling: InvalidMovePathIndex,\n-                });\n-\n-                index\n-            }\n-\n-            LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => {\n-                let parent_index = self.move_path(tcx, base.clone());\n-\n-                let index = MovePathIndex(self.paths.borrow().len());\n-\n-                let next_sibling = self.path_first_child(parent_index);\n-                self.set_path_first_child(parent_index, index);\n-\n-                self.paths.borrow_mut().push(MovePath {\n-                    loan_path: lp.clone(),\n-                    parent: parent_index,\n-                    first_move: InvalidMoveIndex,\n-                    first_child: InvalidMovePathIndex,\n-                    next_sibling,\n-                });\n-\n-                index\n-            }\n-        };\n-\n-        debug!(\"move_path(lp={:?}, index={:?})\",\n-               lp,\n-               index);\n-\n-        assert_eq!(index.get(), self.paths.borrow().len() - 1);\n-        self.path_map.borrow_mut().insert(lp, index);\n-        return index;\n-    }\n-\n-    fn existing_move_path(&self, lp: &Rc<LoanPath<'tcx>>)\n-                          -> Option<MovePathIndex> {\n-        self.path_map.borrow().get(lp).cloned()\n-    }\n-\n-    fn existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>)\n-                           -> Vec<MovePathIndex> {\n-        let mut result = vec![];\n-        self.add_existing_base_paths(lp, &mut result);\n-        result\n-    }\n-\n-    /// Adds any existing move path indices for `lp` and any base paths of `lp` to `result`, but\n-    /// does not add new move paths\n-    fn add_existing_base_paths(&self, lp: &Rc<LoanPath<'tcx>>,\n-                               result: &mut Vec<MovePathIndex>) {\n-        match self.path_map.borrow().get(lp).cloned() {\n-            Some(index) => {\n-                self.each_base_path(index, |p| {\n-                    result.push(p);\n-                    true\n-                });\n-            }\n-            None => {\n-                match lp.kind {\n-                    LpVar(..) | LpUpvar(..) => { }\n-                    LpDowncast(ref b, _) |\n-                    LpExtend(ref b, ..) => {\n-                        self.add_existing_base_paths(b, result);\n-                    }\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        orig_lp: Rc<LoanPath<'tcx>>,\n-        id: hir::ItemLocalId,\n-    ) {\n-        // Moving one union field automatically moves all its fields. Also move siblings of\n-        // all parent union fields, moves do not propagate upwards automatically.\n-        let mut lp = orig_lp.clone();\n-        while let LpExtend(ref base_lp, mutbl, lp_elem) = lp.clone().kind {\n-            if let (&ty::Adt(adt_def, _), LpInterior(opt_variant_id, interior))\n-                    = (&base_lp.ty.kind, lp_elem) {\n-                if adt_def.is_union() {\n-                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field =\n-                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n-                        if field != interior {\n-                            let sibling_lp_kind =\n-                                LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n-                            let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, tcx.types.err));\n-                            self.add_move_helper(tcx, sibling_lp, id);\n-                        }\n-                    }\n-                }\n-            }\n-            lp = base_lp.clone();\n-        }\n-\n-        self.add_move_helper(tcx, orig_lp, id);\n-    }\n-\n-    fn add_move_helper(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        id: hir::ItemLocalId,\n-    ) {\n-        debug!(\"add_move(lp={:?}, id={:?})\", lp, id);\n-\n-        let path_index = self.move_path(tcx, lp);\n-        let move_index = MoveIndex(self.moves.borrow().len());\n-\n-        let next_move = self.path_first_move(path_index);\n-        self.set_path_first_move(path_index, move_index);\n-\n-        self.moves.borrow_mut().push(Move {\n-            path: path_index,\n-            id,\n-            next_move,\n-        });\n-    }\n-\n-    /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n-    /// `span`.\n-    pub fn add_assignment(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        assign_id: hir::ItemLocalId,\n-        span: Span,\n-    ) {\n-        // Assigning to one union field automatically assigns to all its fields.\n-        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n-            if let ty::Adt(adt_def, _) = base_lp.ty.kind {\n-                if adt_def.is_union() {\n-                    for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field =\n-                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n-                        let field_ty = if field == interior {\n-                            lp.ty\n-                        } else {\n-                            tcx.types.err // Doesn't matter\n-                        };\n-                        let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n-                                                    LpInterior(opt_variant_id, field));\n-                        let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n-                        self.add_assignment_helper(tcx, sibling_lp, assign_id,\n-                                                   span);\n-                    }\n-                    return;\n-                }\n-            }\n-        }\n-\n-        self.add_assignment_helper(tcx, lp, assign_id, span);\n-    }\n-\n-    fn add_assignment_helper(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        lp: Rc<LoanPath<'tcx>>,\n-        assign_id: hir::ItemLocalId,\n-        span: Span,\n-    ) {\n-        debug!(\"add_assignment(lp={:?}, assign_id={:?}\", lp, assign_id);\n-\n-        let path_index = self.move_path(tcx, lp.clone());\n-\n-        let assignment = Assignment {\n-            path: path_index,\n-            id: assign_id,\n-            span,\n-        };\n-\n-        if self.is_var_path(path_index) {\n-            debug!(\"add_assignment[var](lp={:?}, assignment={}, path_index={:?})\",\n-                   lp, self.var_assignments.borrow().len(), path_index);\n-\n-            self.var_assignments.borrow_mut().push(assignment);\n-        } else {\n-            debug!(\"add_assignment[path](lp={:?}, path_index={:?})\",\n-                   lp, path_index);\n-\n-            self.path_assignments.borrow_mut().push(assignment);\n-        }\n-    }\n-\n-    /// Adds the gen/kills for the various moves and\n-    /// assignments into the provided data flow contexts.\n-    /// Moves are generated by moves and killed by assignments and\n-    /// scoping. Assignments are generated by assignment to variables and\n-    /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(\n-        &self,\n-        bccx: &BorrowckCtxt<'_, 'tcx>,\n-        dfcx_moves: &mut MoveDataFlow<'_>,\n-        dfcx_assign: &mut AssignDataFlow<'_>,\n-    ) {\n-        for (i, the_move) in self.moves.borrow().iter().enumerate() {\n-            dfcx_moves.add_gen(the_move.id, i);\n-        }\n-\n-        for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {\n-            dfcx_assign.add_gen(assignment.id, i);\n-            self.kill_moves(assignment.path, assignment.id,\n-                            KillFrom::Execution, dfcx_moves);\n-        }\n-\n-        for assignment in self.path_assignments.borrow().iter() {\n-            self.kill_moves(assignment.path, assignment.id,\n-                            KillFrom::Execution, dfcx_moves);\n-        }\n-\n-        // Kill all moves related to a variable `x` when\n-        // it goes out of scope:\n-        for path in self.paths.borrow().iter() {\n-            match path.loan_path.kind {\n-                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = path.loan_path.kill_scope(bccx);\n-                    let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.item_local_id(),\n-                                    KillFrom::ScopeEnd, dfcx_moves);\n-                }\n-                LpExtend(..) => {}\n-            }\n-        }\n-\n-        // Kill all assignments when the variable goes out of scope:\n-        for (assignment_index, assignment) in\n-                self.var_assignments.borrow().iter().enumerate() {\n-            let lp = self.path_loan_path(assignment.path);\n-            match lp.kind {\n-                LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = lp.kill_scope(bccx);\n-                    dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.item_local_id(),\n-                                         assignment_index);\n-                }\n-                LpExtend(..) => {\n-                    bug!(\"var assignment for non var path\");\n-                }\n-            }\n-        }\n-    }\n-\n-    fn each_base_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        let mut p = index;\n-        while p != InvalidMovePathIndex {\n-            if !f(p) {\n-                return false;\n-            }\n-            p = self.path_parent(p);\n-        }\n-        return true;\n-    }\n-\n-    // FIXME(#19596) This is a workaround, but there should be better way to do this\n-    fn each_extending_path_<F>(&self, index: MovePathIndex, f: &mut F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        if !(*f)(index) {\n-            return false;\n-        }\n-\n-        let mut p = self.path_first_child(index);\n-        while p != InvalidMovePathIndex {\n-            if !self.each_extending_path_(p, f) {\n-                return false;\n-            }\n-            p = self.path_next_sibling(p);\n-        }\n-\n-        return true;\n-    }\n-\n-    fn each_extending_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MovePathIndex) -> bool,\n-    {\n-        self.each_extending_path_(index, &mut f)\n-    }\n-\n-    fn each_applicable_move<F>(&self, index0: MovePathIndex, mut f: F) -> bool where\n-        F: FnMut(MoveIndex) -> bool,\n-    {\n-        let mut ret = true;\n-        self.each_extending_path(index0, |index| {\n-            let mut p = self.path_first_move(index);\n-            while p != InvalidMoveIndex {\n-                if !f(p) {\n-                    ret = false;\n-                    break;\n-                }\n-                p = self.move_next_move(p);\n-            }\n-            ret\n-        });\n-        ret\n-    }\n-\n-    fn kill_moves(\n-        &self,\n-        path: MovePathIndex,\n-        kill_id: hir::ItemLocalId,\n-        kill_kind: KillFrom,\n-        dfcx_moves: &mut MoveDataFlow<'_>,\n-    ) {\n-        // We can only perform kills for paths that refer to a unique location,\n-        // since otherwise we may kill a move from one location with an\n-        // assignment referring to another location.\n-\n-        let loan_path = self.path_loan_path(path);\n-        if loan_path_is_precise(&loan_path) {\n-            self.each_applicable_move(path, |move_index| {\n-                debug!(\"kill_moves add_kill {:?} kill_id={:?} move_index={}\",\n-                       kill_kind, kill_id, move_index.get());\n-                dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n-                true\n-            });\n-        }\n-    }\n-}\n-\n-impl<'tcx> FlowedMoveData<'tcx> {\n-    pub fn new(\n-        move_data: MoveData<'tcx>,\n-        bccx: &BorrowckCtxt<'_, 'tcx>,\n-        cfg: &cfg::CFG,\n-        body: &hir::Body,\n-    ) -> FlowedMoveData<'tcx> {\n-        let tcx = bccx.tcx;\n-\n-        let mut dfcx_moves =\n-            DataFlowContext::new(tcx,\n-                                 \"flowed_move_data_moves\",\n-                                 Some(body),\n-                                 cfg,\n-                                 MoveDataFlowOperator,\n-                                 move_data.moves.borrow().len());\n-        let mut dfcx_assign =\n-            DataFlowContext::new(tcx,\n-                                 \"flowed_move_data_assigns\",\n-                                 Some(body),\n-                                 cfg,\n-                                 AssignDataFlowOperator,\n-                                 move_data.var_assignments.borrow().len());\n-\n-        move_data.add_gen_kills(bccx,\n-                                &mut dfcx_moves,\n-                                &mut dfcx_assign);\n-\n-        dfcx_moves.add_kills_from_flow_exits(cfg);\n-        dfcx_assign.add_kills_from_flow_exits(cfg);\n-\n-        dfcx_moves.propagate(cfg, body);\n-        dfcx_assign.propagate(cfg, body);\n-\n-        FlowedMoveData {\n-            move_data,\n-            dfcx_moves,\n-            dfcx_assign,\n-        }\n-    }\n-\n-    pub fn is_move_path(&self, id: hir::ItemLocalId, loan_path: &Rc<LoanPath<'tcx>>) -> bool {\n-        //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n-\n-        let mut ret = false;\n-        if let Some(loan_path_index) = self.move_data.path_map.borrow().get(&*loan_path) {\n-            self.dfcx_moves.each_gen_bit(id, |move_index| {\n-                let the_move = self.move_data.moves.borrow();\n-                let the_move = (*the_move)[move_index];\n-                if the_move.path == *loan_path_index {\n-                    ret = true;\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-        }\n-        ret\n-    }\n-\n-    /// Iterates through each move of `loan_path` (or some base path of `loan_path`) that *may*\n-    /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n-    /// that would invalidate a reference to `loan_path` at location `id`.\n-    pub fn each_move_of<F>(&self,\n-                           id: hir::ItemLocalId,\n-                           loan_path: &Rc<LoanPath<'tcx>>,\n-                           mut f: F)\n-                           -> bool where\n-        F: FnMut(&Move, &LoanPath<'tcx>) -> bool,\n-    {\n-        // Bad scenarios:\n-        //\n-        // 1. Move of `a.b.c`, use of `a.b.c`\n-        // 2. Move of `a.b.c`, use of `a.b.c.d`\n-        // 3. Move of `a.b.c`, use of `a` or `a.b`\n-        //\n-        // OK scenario:\n-        //\n-        // 4. move of `a.b.c`, use of `a.b.d`\n-\n-        let base_indices = self.move_data.existing_base_paths(loan_path);\n-        if base_indices.is_empty() {\n-            return true;\n-        }\n-\n-        let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n-\n-        let mut ret = true;\n-\n-        self.dfcx_moves.each_bit_on_entry(id, |index| {\n-            let the_move = self.move_data.moves.borrow();\n-            let the_move = &(*the_move)[index];\n-            let moved_path = the_move.path;\n-            if base_indices.iter().any(|x| x == &moved_path) {\n-                // Scenario 1 or 2: `loan_path` or some base path of\n-                // `loan_path` was moved.\n-                if !f(the_move, &self.move_data.path_loan_path(moved_path)) {\n-                    ret = false;\n-                }\n-            } else {\n-                if let Some(loan_path_index) = opt_loan_path_index {\n-                    let cont = self.move_data.each_base_path(moved_path, |p| {\n-                        if p == loan_path_index {\n-                            // Scenario 3: some extension of `loan_path`\n-                            // was moved\n-                            f(the_move,\n-                              &self.move_data.path_loan_path(moved_path))\n-                        } else {\n-                            true\n-                        }\n-                    });\n-                    if !cont { ret = false; }\n-                }\n-            }\n-            ret\n-        })\n-    }\n-\n-    /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n-    /// `loan_path` must be a single variable.\n-    pub fn each_assignment_of<F>(&self,\n-                                 id: hir::ItemLocalId,\n-                                 loan_path: &Rc<LoanPath<'tcx>>,\n-                                 mut f: F)\n-                                 -> bool where\n-        F: FnMut(&Assignment) -> bool,\n-    {\n-        let loan_path_index = {\n-            match self.move_data.existing_move_path(loan_path) {\n-                Some(i) => i,\n-                None => {\n-                    // if there were any assignments, it'd have an index\n-                    return true;\n-                }\n-            }\n-        };\n-\n-        self.dfcx_assign.each_bit_on_entry(id, |index| {\n-            let assignment = self.move_data.var_assignments.borrow();\n-            let assignment = &(*assignment)[index];\n-            if assignment.path == loan_path_index && !f(assignment) {\n-                false\n-            } else {\n-                true\n-            }\n-        })\n-    }\n-}\n-\n-impl BitwiseOperator for MoveDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // moves from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for MoveDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-impl BitwiseOperator for AssignDataFlowOperator {\n-    #[inline]\n-    fn join(&self, succ: usize, pred: usize) -> usize {\n-        succ | pred // moves from both preds are in scope\n-    }\n-}\n-\n-impl DataFlowOperator for AssignDataFlowOperator {\n-    #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no assignments in scope by default\n-    }\n-}"}, {"sha": "ec7f40f8c9718f1c2fc09a6e6c6eaf382da169fb", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "removed", "additions": 0, "deletions": 545, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,545 +0,0 @@\n-use crate::cfg::*;\n-\n-use rustc::hir::{self, PatKind};\n-use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n-use rustc::middle::region;\n-use rustc::ty::{self, TyCtxt};\n-\n-use rustc_data_structures::graph::implementation as graph;\n-\n-struct CFGBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    owner_def_id: DefId,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    graph: CFGGraph,\n-    fn_exit: CFGIndex,\n-    loop_scopes: Vec<LoopScope>,\n-    breakable_block_scopes: Vec<BlockScope>,\n-}\n-\n-#[derive(Copy, Clone)]\n-struct BlockScope {\n-    block_expr_id: hir::ItemLocalId, // ID of breakable block expr node\n-    break_index: CFGIndex, // where to go on `break`\n-}\n-\n-#[derive(Copy, Clone)]\n-struct LoopScope {\n-    loop_id: hir::ItemLocalId, // ID of `loop`/`while` node\n-    continue_index: CFGIndex, // where to go on a `loop`\n-    break_index: CFGIndex, // where to go on a `break`\n-}\n-\n-pub(super) fn construct(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n-    let mut graph = graph::Graph::new();\n-    let entry = graph.add_node(CFGNodeData::Entry);\n-\n-    // `fn_exit` is target of return exprs, which lies somewhere\n-    // outside input `body`. (Distinguishing `fn_exit` and `body_exit`\n-    // also resolves chicken-and-egg problem that arises if you try to\n-    // have return exprs jump to `body_exit` during construction.)\n-    let fn_exit = graph.add_node(CFGNodeData::Exit);\n-    let body_exit;\n-\n-    // Find the tables for this body.\n-    let owner_def_id = tcx.hir().body_owner_def_id(body.id());\n-    let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut cfg_builder = CFGBuilder {\n-        tcx,\n-        owner_def_id,\n-        tables,\n-        graph,\n-        fn_exit,\n-        loop_scopes: Vec::new(),\n-        breakable_block_scopes: Vec::new(),\n-    };\n-    body_exit = cfg_builder.expr(&body.value, entry);\n-    cfg_builder.add_contained_edge(body_exit, fn_exit);\n-    let CFGBuilder { graph, .. } = cfg_builder;\n-    CFG {\n-        owner_def_id,\n-        graph,\n-        entry,\n-        exit: fn_exit,\n-    }\n-}\n-\n-impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n-    fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n-        if blk.targeted_by_break {\n-            let expr_exit = self.add_ast_node(blk.hir_id.local_id, &[]);\n-\n-            self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: blk.hir_id.local_id,\n-                break_index: expr_exit,\n-            });\n-\n-            let mut stmts_exit = pred;\n-            for stmt in &blk.stmts {\n-                stmts_exit = self.stmt(stmt, stmts_exit);\n-            }\n-            let blk_expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n-            self.add_contained_edge(blk_expr_exit, expr_exit);\n-\n-            self.breakable_block_scopes.pop();\n-\n-            expr_exit\n-        } else {\n-            let mut stmts_exit = pred;\n-            for stmt in &blk.stmts {\n-                stmts_exit = self.stmt(stmt, stmts_exit);\n-            }\n-\n-            let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n-\n-            self.add_ast_node(blk.hir_id.local_id, &[expr_exit])\n-        }\n-    }\n-\n-    fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let exit = match stmt.kind {\n-            hir::StmtKind::Local(ref local) => {\n-                let init_exit = self.opt_expr(&local.init, pred);\n-                self.pat(&local.pat, init_exit)\n-            }\n-            hir::StmtKind::Item(_) => pred,\n-            hir::StmtKind::Expr(ref expr) |\n-            hir::StmtKind::Semi(ref expr) => {\n-                self.expr(&expr, pred)\n-            }\n-        };\n-        self.add_ast_node(stmt.hir_id.local_id, &[exit])\n-    }\n-\n-    fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n-        match pat.kind {\n-            PatKind::Binding(.., None) |\n-            PatKind::Path(_) |\n-            PatKind::Lit(..) |\n-            PatKind::Range(..) |\n-            PatKind::Wild => self.add_ast_node(pat.hir_id.local_id, &[pred]),\n-\n-            PatKind::Box(ref subpat) |\n-            PatKind::Ref(ref subpat, _) |\n-            PatKind::Binding(.., Some(ref subpat)) => {\n-                let subpat_exit = self.pat(&subpat, pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[subpat_exit])\n-            }\n-\n-            PatKind::TupleStruct(_, ref subpats, _) |\n-            PatKind::Tuple(ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n-            }\n-\n-            PatKind::Struct(_, ref subpats, _) => {\n-                let pats_exit = self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n-                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n-            }\n-\n-            PatKind::Or(ref pats) => {\n-                let branches: Vec<_> = pats.iter().map(|p| self.pat(p, pred)).collect();\n-                self.add_ast_node(pat.hir_id.local_id, &branches)\n-            }\n-\n-            PatKind::Slice(ref pre, ref vec, ref post) => {\n-                let pre_exit = self.pats_all(pre.iter(), pred);\n-                let vec_exit = self.pats_all(vec.iter(), pre_exit);\n-                let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_ast_node(pat.hir_id.local_id, &[post_exit])\n-            }\n-        }\n-    }\n-\n-    /// Handles case where all of the patterns must match.\n-    fn pats_all<'b, I: Iterator<Item = &'b P<hir::Pat>>>(\n-        &mut self,\n-        pats: I,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n-    }\n-\n-    fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n-        match expr.kind {\n-            hir::ExprKind::Block(ref blk, _) => {\n-                let blk_exit = self.block(&blk, pred);\n-                self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n-            }\n-\n-            hir::ExprKind::Loop(ref body, _, _) => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //   [loopback] <---+\n-                //       |      4   |\n-                //       v 3        |\n-                //     [body] ------+\n-                //\n-                //     [expr] 2\n-                //\n-                // Note that `break` and `loop` statements\n-                // may cause additional edges.\n-\n-                let loopback = self.add_dummy_node(&[pred]); // 1\n-                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]); // 2\n-                self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.hir_id.local_id,\n-                    continue_index: loopback,\n-                    break_index: expr_exit,\n-                });\n-                let body_exit = self.block(&body, loopback); // 3\n-                self.add_contained_edge(body_exit, loopback); // 4\n-                self.loop_scopes.pop();\n-                expr_exit\n-            }\n-\n-            hir::ExprKind::Match(ref discr, ref arms, _) => {\n-                self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n-            }\n-\n-            hir::ExprKind::Binary(op, ref l, ref r) if op.node.is_lazy() => {\n-                //\n-                //     [pred]\n-                //       |\n-                //       v 1\n-                //      [l]\n-                //       |\n-                //      / \\\n-                //     /   \\\n-                //    v 2  *\n-                //   [r]   |\n-                //    |    |\n-                //    v 3  v 4\n-                //   [..exit..]\n-                //\n-                let l_exit = self.expr(&l, pred); // 1\n-                let r_exit = self.expr(&r, l_exit); // 2\n-                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit]) // 3,4\n-            }\n-\n-            hir::ExprKind::Ret(ref v) => {\n-                let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n-                self.add_returning_edge(expr, b);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Break(destination, ref opt_expr) => {\n-                let v = self.opt_expr(opt_expr, pred);\n-                let (target_scope, break_dest) =\n-                    self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n-                let b = self.add_ast_node(expr.hir_id.local_id, &[v]);\n-                self.add_exiting_edge(expr, b, target_scope, break_dest);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Continue(destination) => {\n-                let (target_scope, cont_dest) =\n-                    self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n-                let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n-                self.add_exiting_edge(expr, a, target_scope, cont_dest);\n-                self.add_unreachable_node()\n-            }\n-\n-            hir::ExprKind::Array(ref elems) => {\n-                self.straightline(expr, pred, elems.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Call(ref func, ref args) => {\n-                self.call(expr, pred, &func, args.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::MethodCall(.., ref args) => {\n-                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) if self.tables.is_method_call(expr) => {\n-                self.call(expr, pred, &l, Some(&**r).into_iter())\n-            }\n-\n-            hir::ExprKind::Unary(_, ref e) if self.tables.is_method_call(expr) => {\n-                self.call(expr, pred, &e, None::<hir::Expr>.iter())\n-            }\n-\n-            hir::ExprKind::Tup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.iter().map(|e| &*e))\n-            }\n-\n-            hir::ExprKind::Struct(_, ref fields, ref base) => {\n-                let field_cfg = self.straightline(expr, pred, fields.iter().map(|f| &*f.expr));\n-                self.opt_expr(base, field_cfg)\n-            }\n-\n-            hir::ExprKind::Assign(ref l, ref r) |\n-            hir::ExprKind::AssignOp(_, ref l, ref r) => {\n-                self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n-            }\n-\n-            hir::ExprKind::Index(ref l, ref r) |\n-            hir::ExprKind::Binary(_, ref l, ref r) => { // N.B., && and || handled earlier\n-                self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n-            }\n-\n-            hir::ExprKind::Box(ref e) |\n-            hir::ExprKind::AddrOf(_, ref e) |\n-            hir::ExprKind::Cast(ref e, _) |\n-            hir::ExprKind::Type(ref e, _) |\n-            hir::ExprKind::DropTemps(ref e) |\n-            hir::ExprKind::Unary(_, ref e) |\n-            hir::ExprKind::Field(ref e, _) |\n-            hir::ExprKind::Yield(ref e, _) |\n-            hir::ExprKind::Repeat(ref e, _) => {\n-                self.straightline(expr, pred, Some(&**e).into_iter())\n-            }\n-\n-            hir::ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n-                let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n-                self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n-            }\n-\n-            hir::ExprKind::Closure(..) |\n-            hir::ExprKind::Lit(..) |\n-            hir::ExprKind::Path(_) |\n-            hir::ExprKind::Err => {\n-                self.straightline(expr, pred, None::<hir::Expr>.iter())\n-            }\n-        }\n-    }\n-\n-    fn call<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        call_expr: &hir::Expr,\n-        pred: CFGIndex,\n-        func_or_rcvr: &hir::Expr,\n-        args: I,\n-    ) -> CFGIndex {\n-        let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n-        let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n-        if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n-            self.add_unreachable_node()\n-        } else {\n-            ret\n-        }\n-    }\n-\n-    /// Constructs graph for `exprs` evaluated in order.\n-    fn exprs<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        exprs: I,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        exprs.fold(pred, |p, e| self.expr(e, p))\n-    }\n-\n-    /// Constructs graph for `opt_expr` evaluated, if `Some`.\n-    fn opt_expr(\n-        &mut self,\n-        opt_expr: &Option<P<hir::Expr>>,\n-        pred: CFGIndex,\n-    ) -> CFGIndex {\n-        opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n-    }\n-\n-    /// Handles case of an expression that evaluates `subexprs` in order.\n-    fn straightline<'b, I: Iterator<Item = &'b hir::Expr>>(\n-        &mut self,\n-        expr: &hir::Expr,\n-        pred: CFGIndex,\n-        subexprs: I,\n-    ) -> CFGIndex {\n-        let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n-    }\n-\n-    fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n-              arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n-        // The CFG for match expressions is quite complex, so no ASCII\n-        // art for it (yet).\n-        //\n-        // The CFG generated below matches roughly what MIR contains.\n-        // Each pattern and guard is visited in parallel, with\n-        // arms containing multiple patterns generating multiple nodes\n-        // for the same guard expression. The guard expressions chain\n-        // into each other from top to bottom, with a specific\n-        // exception to allow some additional valid programs\n-        // (explained below). MIR differs slightly in that the\n-        // pattern matching may continue after a guard but the visible\n-        // behaviour should be the same.\n-        //\n-        // What is going on is explained in further comments.\n-\n-        // Visit the discriminant expression.\n-        let discr_exit = self.expr(discr, pred);\n-\n-        // Add a node for the exit of the match expression as a whole.\n-        let expr_exit = self.add_ast_node(id, &[]);\n-\n-        // Keep track of the previous guard expressions.\n-        let mut prev_guard = None;\n-        let match_scope = region::Scope { id, data: region::ScopeData::Node };\n-\n-        for arm in arms {\n-            // Add an exit node for when we've visited all the\n-            // patterns and the guard (if there is one) in the arm.\n-            let bindings_exit = self.add_dummy_node(&[]);\n-\n-            for pat in arm.top_pats_hack() {\n-                // Visit the pattern, coming from the discriminant exit\n-                let mut pat_exit = self.pat(&pat, discr_exit);\n-\n-                // If there is a guard expression, handle it here.\n-                if let Some(ref guard) = arm.guard {\n-                    // Add a dummy node for the previous guard\n-                    // expression to target.\n-                    let guard_start = self.add_dummy_node(&[pat_exit]);\n-                    // Visit the guard expression.\n-                    let guard_exit = match guard {\n-                        hir::Guard::If(ref e) => (&**e, self.expr(e, guard_start)),\n-                    };\n-                    // #47295: We used to have very special case code\n-                    // here for when a pair of arms are both formed\n-                    // solely from constants, and if so, not add these\n-                    // edges.  But this was not actually sound without\n-                    // other constraints that we stopped enforcing at\n-                    // some point.\n-                    if let Some((prev_guard, prev_index)) = prev_guard.take() {\n-                        self.add_exiting_edge(prev_guard, prev_index, match_scope, guard_start);\n-                    }\n-\n-                    // Push the guard onto the list of previous guards.\n-                    prev_guard = Some(guard_exit);\n-\n-                    // Update the exit node for the pattern.\n-                    pat_exit = guard_exit.1;\n-                }\n-\n-                // Add an edge from the exit of this pattern to the exit of the arm.\n-                self.add_contained_edge(pat_exit, bindings_exit);\n-            }\n-\n-            // Visit the body of this arm.\n-            let body_exit = self.expr(&arm.body, bindings_exit);\n-\n-            let arm_exit = self.add_ast_node(arm.hir_id.local_id, &[body_exit]);\n-\n-            // Link the body to the exit of the expression.\n-            self.add_contained_edge(arm_exit, expr_exit);\n-        }\n-\n-        expr_exit\n-    }\n-\n-    fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(CFGNodeData::Dummy, preds)\n-    }\n-\n-    fn add_ast_node(&mut self, id: hir::ItemLocalId, preds: &[CFGIndex]) -> CFGIndex {\n-        self.add_node(CFGNodeData::AST(id), preds)\n-    }\n-\n-    fn add_unreachable_node(&mut self) -> CFGIndex {\n-        self.add_node(CFGNodeData::Unreachable, &[])\n-    }\n-\n-    fn add_node(&mut self, data: CFGNodeData, preds: &[CFGIndex]) -> CFGIndex {\n-        let node = self.graph.add_node(data);\n-        for &pred in preds {\n-            self.add_contained_edge(pred, node);\n-        }\n-        node\n-    }\n-\n-    fn add_contained_edge(\n-        &mut self,\n-        source: CFGIndex,\n-        target: CFGIndex,\n-    ) {\n-        let data = CFGEdgeData {exiting_scopes: vec![] };\n-        self.graph.add_edge(source, target, data);\n-    }\n-\n-    fn add_exiting_edge(\n-        &mut self,\n-        from_expr: &hir::Expr,\n-        from_index: CFGIndex,\n-        target_scope: region::Scope,\n-        to_index: CFGIndex,\n-    ) {\n-        let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = region::Scope {\n-            id: from_expr.hir_id.local_id,\n-            data: region::ScopeData::Node\n-        };\n-        let region_scope_tree = self.tcx.region_scope_tree(self.owner_def_id);\n-        while scope != target_scope {\n-            data.exiting_scopes.push(scope.item_local_id());\n-            scope = region_scope_tree.encl_scope(scope);\n-        }\n-        self.graph.add_edge(from_index, to_index, data);\n-    }\n-\n-    fn add_returning_edge(\n-        &mut self,\n-        _from_expr: &hir::Expr,\n-        from_index: CFGIndex,\n-    ) {\n-        let data = CFGEdgeData {\n-            exiting_scopes: self.loop_scopes.iter()\n-                                            .rev()\n-                                            .map(|&LoopScope { loop_id: id, .. }| id)\n-                                            .collect()\n-        };\n-        self.graph.add_edge(from_index, self.fn_exit, data);\n-    }\n-\n-    fn find_scope_edge(\n-        &self,\n-        expr: &hir::Expr,\n-        destination: hir::Destination,\n-        scope_cf_kind: ScopeCfKind,\n-    ) -> (region::Scope, CFGIndex) {\n-        match destination.target_id {\n-            Ok(loop_id) => {\n-                for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == loop_id.local_id {\n-                        let scope = region::Scope {\n-                            id: loop_id.local_id,\n-                            data: region::ScopeData::Node\n-                        };\n-                        return (scope, match scope_cf_kind {\n-                            ScopeCfKind::Break => b.break_index,\n-                            ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n-                        });\n-                    }\n-                }\n-                for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id.local_id {\n-                        let scope = region::Scope {\n-                            id: loop_id.local_id,\n-                            data: region::ScopeData::Node\n-                        };\n-                        return (scope, match scope_cf_kind {\n-                            ScopeCfKind::Break => l.break_index,\n-                            ScopeCfKind::Continue => l.continue_index,\n-                        });\n-                    }\n-                }\n-                span_bug!(expr.span, \"no scope for ID {}\", loop_id);\n-            }\n-            Err(err) => span_bug!(expr.span, \"scope error: {}\",  err),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Eq, PartialEq)]\n-enum ScopeCfKind {\n-    Break,\n-    Continue,\n-}"}, {"sha": "99c6b49cad5d908f9529d0a5737016a9b8e3a23f", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,119 +0,0 @@\n-/// This module provides linkage between `rustc::middle::graph` and\n-/// libgraphviz traits.\n-\n-use crate::cfg;\n-use rustc::hir;\n-use rustc::ty::TyCtxt;\n-\n-pub(crate) type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n-pub(crate) type Edge<'a> = &'a cfg::CFGEdge;\n-\n-pub struct LabelledCFG<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub cfg: &'a cfg::CFG,\n-    pub name: String,\n-    /// `labelled_edges` controls whether we emit labels on the edges.\n-    pub labelled_edges: bool,\n-}\n-\n-impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n-    fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n-        assert!(self.cfg.owner_def_id.is_local());\n-        let hir_id = hir::HirId {\n-            owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n-            local_id\n-        };\n-        let s = self.tcx.hir().node_to_string(hir_id);\n-\n-        // Replacing newlines with `\\\\l` causes each line to be left-aligned,\n-        // improving presentation of (long) pretty-printed expressions.\n-        if s.contains(\"\\n\") {\n-            let mut s = s.replace(\"\\n\", \"\\\\l\");\n-            // Apparently left-alignment applies to the line that precedes\n-            // `\\l`, not the line that follows; so, add `\\l` at end of string\n-            // if not already present, ensuring last line gets left-aligned\n-            // as well.\n-            let mut last_two: Vec<_> =\n-                s.chars().rev().take(2).collect();\n-            last_two.reverse();\n-            if last_two != ['\\\\', 'l'] {\n-                s.push_str(\"\\\\l\");\n-            }\n-            s\n-        } else {\n-            s\n-        }\n-    }\n-}\n-\n-impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).unwrap() }\n-\n-    fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n-        dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n-    }\n-\n-    fn node_label(&'a self, &(i, n): &Node<'a>) -> dot::LabelText<'a> {\n-        if i == self.cfg.entry {\n-            dot::LabelText::LabelStr(\"entry\".into())\n-        } else if i == self.cfg.exit {\n-            dot::LabelText::LabelStr(\"exit\".into())\n-        } else if n.data.id() == hir::DUMMY_ITEM_LOCAL_ID {\n-            dot::LabelText::LabelStr(\"(dummy_node)\".into())\n-        } else {\n-            let s = self.local_id_to_string(n.data.id());\n-            dot::LabelText::EscStr(s.into())\n-        }\n-    }\n-\n-    fn edge_label(&self, e: &Edge<'a>) -> dot::LabelText<'a> {\n-        let mut label = String::new();\n-        if !self.labelled_edges {\n-            return dot::LabelText::EscStr(label.into());\n-        }\n-        let mut put_one = false;\n-        for (i, &id) in e.data.exiting_scopes.iter().enumerate() {\n-            if put_one {\n-                label.push_str(\",\\\\l\");\n-            } else {\n-                put_one = true;\n-            }\n-            let s = self.local_id_to_string(id);\n-            label.push_str(&format!(\"exiting scope_{} {}\",\n-                                   i,\n-                                   &s[..]));\n-        }\n-        dot::LabelText::EscStr(label.into())\n-    }\n-}\n-\n-impl<'a> dot::GraphWalk<'a> for &'a cfg::CFG {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> {\n-        let v: Vec<_> = self.graph.enumerated_nodes().collect();\n-        v.into()\n-    }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> {\n-        self.graph.all_edges().iter().collect()\n-    }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> {\n-        let i = edge.source();\n-        (i, self.graph.node(i))\n-    }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> {\n-        let i = edge.target();\n-        (i, self.graph.node(i))\n-    }\n-}\n-\n-impl<'a, 'hir> dot::GraphWalk<'a> for LabelledCFG<'a, 'hir> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.source(edge) }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.cfg.target(edge) }\n-}"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,55 +0,0 @@\n-//! Module that constructs a control-flow graph representing an item.\n-//! Uses `Graph` as the underlying representation.\n-\n-use rustc_data_structures::graph::implementation as graph;\n-use rustc::ty::TyCtxt;\n-use rustc::hir;\n-use rustc::hir::def_id::DefId;\n-\n-mod construct;\n-pub mod graphviz;\n-\n-pub struct CFG {\n-    owner_def_id: DefId,\n-    pub(crate) graph: CFGGraph,\n-    pub(crate) entry: CFGIndex,\n-    exit: CFGIndex,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum CFGNodeData {\n-    AST(hir::ItemLocalId),\n-    Entry,\n-    Exit,\n-    Dummy,\n-    Unreachable,\n-}\n-\n-impl CFGNodeData {\n-    pub(crate) fn id(&self) -> hir::ItemLocalId {\n-        if let CFGNodeData::AST(id) = *self {\n-            id\n-        } else {\n-            hir::DUMMY_ITEM_LOCAL_ID\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct CFGEdgeData {\n-    pub(crate) exiting_scopes: Vec<hir::ItemLocalId>\n-}\n-\n-pub(crate) type CFGIndex = graph::NodeIndex;\n-\n-pub(crate) type CFGGraph = graph::Graph<CFGNodeData, CFGEdgeData>;\n-\n-pub(crate) type CFGNode = graph::Node<CFGNodeData>;\n-\n-pub(crate) type CFGEdge = graph::Edge<CFGEdgeData>;\n-\n-impl CFG {\n-    pub fn new(tcx: TyCtxt<'_>, body: &hir::Body) -> CFG {\n-        construct::construct(tcx, body)\n-    }\n-}"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "removed", "additions": 0, "deletions": 672, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,672 +0,0 @@\n-//! A module for propagating forward dataflow information. The analysis\n-//! assumes that the items to be propagated can be represented as bits\n-//! and thus uses bitvectors. Your job is simply to specify the so-called\n-//! GEN and KILL bits for each expression.\n-\n-use crate::cfg::{self, CFGIndex};\n-use std::mem;\n-use std::usize;\n-use log::debug;\n-\n-use rustc_data_structures::graph::implementation::OUTGOING;\n-\n-use rustc::util::nodemap::FxHashMap;\n-use rustc::hir;\n-use rustc::hir::intravisit;\n-use rustc::hir::print as pprust;\n-use rustc::ty::TyCtxt;\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EntryOrExit {\n-    Entry,\n-    Exit,\n-}\n-\n-#[derive(Clone)]\n-pub struct DataFlowContext<'tcx, O> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    /// a name for the analysis using this dataflow instance\n-    analysis_name: &'static str,\n-\n-    /// the data flow operator\n-    oper: O,\n-\n-    /// number of bits to propagate per id\n-    bits_per_id: usize,\n-\n-    /// number of words we will use to store bits_per_id.\n-    /// equal to bits_per_id/usize::BITS rounded up.\n-    words_per_id: usize,\n-\n-    // mapping from node to cfg node index\n-    // FIXME (#6298): Shouldn't this go with CFG?\n-    local_id_to_index: FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-\n-    // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n-    // and `on_entry`) all have the same structure. For each id in\n-    // `id_range`, there is a range of words equal to `words_per_id`.\n-    // So, to access the bits for any given id, you take a slice of\n-    // the full vector (see the method `compute_id_range()`).\n-    /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n-    gens: Vec<usize>,\n-\n-    /// bits killed as we exit the cfg node, or non-locally jump over\n-    /// it. Updated by `add_kill(KillFrom::ScopeEnd)`.\n-    scope_kills: Vec<usize>,\n-\n-    /// bits killed as we exit the cfg node directly; if it is jumped\n-    /// over, e.g., via `break`, the kills are not reflected in the\n-    /// jump's effects. Updated by `add_kill(KillFrom::Execution)`.\n-    action_kills: Vec<usize>,\n-\n-    /// bits that are valid on entry to the cfg node. Updated by\n-    /// `propagate()`.\n-    on_entry: Vec<usize>,\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: usize, pred: usize) -> usize;\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-pub trait DataFlowOperator : BitwiseOperator {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn initial_value(&self) -> bool;\n-}\n-\n-struct PropagationContext<'a, 'tcx, O> {\n-    dfcx: &'a mut DataFlowContext<'tcx, O>,\n-    changed: bool,\n-}\n-\n-fn get_cfg_indices(id: hir::ItemLocalId,\n-                   index: &FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n-                   -> &[CFGIndex] {\n-    index.get(&id).map_or(&[], |v| &v[..])\n-}\n-\n-impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n-    fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n-        assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n-        self.local_id_to_index.contains_key(&n)\n-    }\n-}\n-\n-impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n-    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) {\n-        pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n-    }\n-    fn pre(&self,\n-           ps: &mut pprust::State<'_>,\n-           node: pprust::AnnNode<'_>) {\n-        let id = match node {\n-            pprust::AnnNode::Name(_) => return,\n-            pprust::AnnNode::Expr(expr) => expr.hir_id.local_id,\n-            pprust::AnnNode::Block(blk) => blk.hir_id.local_id,\n-            pprust::AnnNode::Item(_) |\n-            pprust::AnnNode::SubItem(_) => return,\n-            pprust::AnnNode::Pat(pat) => pat.hir_id.local_id,\n-            pprust::AnnNode::Arm(arm) => arm.hir_id.local_id,\n-        };\n-\n-        if !self.has_bitset_for_local_id(id) {\n-            return;\n-        }\n-\n-        assert!(self.bits_per_id > 0);\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let on_entry = &self.on_entry[start.. end];\n-            let entry_str = bits_to_string(on_entry);\n-\n-            let gens = &self.gens[start.. end];\n-            let gens_str = if gens.iter().any(|&u| u != 0) {\n-                format!(\" gen: {}\", bits_to_string(gens))\n-            } else {\n-                String::new()\n-            };\n-\n-            let action_kills = &self.action_kills[start .. end];\n-            let action_kills_str = if action_kills.iter().any(|&u| u != 0) {\n-                format!(\" action_kill: {}\", bits_to_string(action_kills))\n-            } else {\n-                String::new()\n-            };\n-\n-            let scope_kills = &self.scope_kills[start .. end];\n-            let scope_kills_str = if scope_kills.iter().any(|&u| u != 0) {\n-                format!(\" scope_kill: {}\", bits_to_string(scope_kills))\n-            } else {\n-                String::new()\n-            };\n-\n-            ps.synth_comment(\n-                format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n-                        gens_str, action_kills_str, scope_kills_str));\n-            ps.s.space();\n-        }\n-    }\n-}\n-\n-fn build_local_id_to_index(body: Option<&hir::Body>,\n-                           cfg: &cfg::CFG)\n-                           -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n-    let mut index = FxHashMap::default();\n-\n-    // FIXME(#15020) Would it be better to fold formals from decl\n-    // into cfg itself?  i.e., introduce a fn-based flow-graph in\n-    // addition to the current block-based flow-graph, rather than\n-    // have to put traversals like this here?\n-    if let Some(body) = body {\n-        add_entries_from_fn_body(&mut index, body, cfg.entry);\n-    }\n-\n-    cfg.graph.each_node(|node_idx, node| {\n-        if let cfg::CFGNodeData::AST(id) = node.data {\n-            index.entry(id).or_default().push(node_idx);\n-        }\n-        true\n-    });\n-\n-    return index;\n-\n-    /// Adds mappings from the ast nodes for the formal bindings to\n-    /// the entry-node in the graph.\n-    fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-                                body: &hir::Body,\n-                                entry: CFGIndex) {\n-        use rustc::hir::intravisit::Visitor;\n-\n-        struct Formals<'a> {\n-            entry: CFGIndex,\n-            index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n-        }\n-        let mut formals = Formals { entry: entry, index: index };\n-        for param in &body.params {\n-            formals.visit_pat(&param.pat);\n-        }\n-        impl<'a, 'v> Visitor<'v> for Formals<'a> {\n-            fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n-                intravisit::NestedVisitorMap::None\n-            }\n-\n-            fn visit_pat(&mut self, p: &hir::Pat) {\n-                self.index.entry(p.hir_id.local_id).or_default().push(self.entry);\n-                intravisit::walk_pat(self, p)\n-            }\n-        }\n-    }\n-}\n-\n-/// Flag used by `add_kill` to indicate whether the provided kill\n-/// takes effect only when control flows directly through the node in\n-/// question, or if the kill's effect is associated with any\n-/// control-flow directly through or indirectly over the node.\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum KillFrom {\n-    /// A `ScopeEnd` kill is one that takes effect when any control\n-    /// flow goes over the node. A kill associated with the end of the\n-    /// scope of a variable declaration `let x;` is an example of a\n-    /// `ScopeEnd` kill.\n-    ScopeEnd,\n-\n-    /// An `Execution` kill is one that takes effect only when control\n-    /// flow goes through the node to completion. A kill associated\n-    /// with an assignment statement `x = expr;` is an example of an\n-    /// `Execution` kill.\n-    Execution,\n-}\n-\n-impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        analysis_name: &'static str,\n-        body: Option<&hir::Body>,\n-        cfg: &cfg::CFG,\n-        oper: O,\n-        bits_per_id: usize,\n-    ) -> DataFlowContext<'tcx, O> {\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n-        let num_nodes = cfg.graph.all_nodes().len();\n-\n-        debug!(\"DataFlowContext::new(analysis_name: {}, \\\n-                                     bits_per_id={}, words_per_id={}) \\\n-                                     num_nodes: {}\",\n-               analysis_name, bits_per_id, words_per_id,\n-               num_nodes);\n-\n-        let entry = if oper.initial_value() { usize::MAX } else {0};\n-\n-        let zeroes = vec![0; num_nodes * words_per_id];\n-        let gens = zeroes.clone();\n-        let kills1 = zeroes.clone();\n-        let kills2 = zeroes;\n-        let on_entry = vec![entry; num_nodes * words_per_id];\n-\n-        let local_id_to_index = build_local_id_to_index(body, cfg);\n-\n-        DataFlowContext {\n-            tcx,\n-            analysis_name,\n-            words_per_id,\n-            local_id_to_index,\n-            bits_per_id,\n-            oper,\n-            gens,\n-            action_kills: kills1,\n-            scope_kills: kills2,\n-            on_entry,\n-        }\n-    }\n-\n-    pub fn add_gen(&mut self, id: hir::ItemLocalId, bit: usize) {\n-        //! Indicates that `id` generates `bit`\n-        debug!(\"{} add_gen(id={:?}, bit={})\",\n-               self.analysis_name, id, bit);\n-        assert!(self.local_id_to_index.contains_key(&id));\n-        assert!(self.bits_per_id > 0);\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let gens = &mut self.gens[start.. end];\n-            set_bit(gens, bit);\n-        }\n-    }\n-\n-    pub fn add_kill(&mut self, kind: KillFrom, id: hir::ItemLocalId, bit: usize) {\n-        //! Indicates that `id` kills `bit`\n-        debug!(\"{} add_kill(id={:?}, bit={})\",\n-               self.analysis_name, id, bit);\n-        assert!(self.local_id_to_index.contains_key(&id));\n-        assert!(self.bits_per_id > 0);\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let kills = match kind {\n-                KillFrom::Execution => &mut self.action_kills[start.. end],\n-                KillFrom::ScopeEnd =>  &mut self.scope_kills[start.. end],\n-            };\n-            set_bit(kills, bit);\n-        }\n-    }\n-\n-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [usize]) {\n-        //! Applies the gen and kill sets for `cfgidx` to `bits`\n-        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-        assert!(self.bits_per_id > 0);\n-\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &self.gens[start.. end];\n-        bitwise(bits, gens, &Union);\n-        let kills = &self.action_kills[start.. end];\n-        bitwise(bits, kills, &Subtract);\n-        let kills = &self.scope_kills[start.. end];\n-        bitwise(bits, kills, &Subtract);\n-\n-        debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n-               self.analysis_name, cfgidx, mut_bits_to_string(bits));\n-    }\n-\n-    fn compute_id_range(&self, cfgidx: CFGIndex) -> (usize, usize) {\n-        let n = cfgidx.node_id();\n-        let start = n * self.words_per_id;\n-        let end = start + self.words_per_id;\n-\n-        assert!(start < self.gens.len());\n-        assert!(end <= self.gens.len());\n-        assert!(self.gens.len() == self.action_kills.len());\n-        assert!(self.gens.len() == self.scope_kills.len());\n-        assert!(self.gens.len() == self.on_entry.len());\n-\n-        (start, end)\n-    }\n-\n-\n-    pub fn each_bit_on_entry<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit that is set on entry to `id`.\n-        //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_local_id(id) {\n-            return true;\n-        }\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            if !self.each_bit_for_node(EntryOrExit::Entry, cfgidx, |i| f(i)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n-        //! Only useful after `propagate()` has been called.\n-\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return true;\n-        }\n-\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let on_entry = &self.on_entry[start.. end];\n-        let temp_bits;\n-        let slice = match e {\n-            EntryOrExit::Entry => on_entry,\n-            EntryOrExit::Exit => {\n-                let mut t = on_entry.to_vec();\n-                self.apply_gen_kill(cfgidx, &mut t);\n-                temp_bits = t;\n-                &temp_bits[..]\n-            }\n-        };\n-        debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n-               self.analysis_name, e, cfgidx, bits_to_string(slice));\n-        self.each_bit(slice, f)\n-    }\n-\n-    pub fn each_gen_bit<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset_for_local_id(id) {\n-            return true;\n-        }\n-\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return true;\n-        }\n-\n-        let indices = get_cfg_indices(id, &self.local_id_to_index);\n-        for &cfgidx in indices {\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            let gens = &self.gens[start.. end];\n-            debug!(\"{} each_gen_bit(id={:?}, gens={})\",\n-                   self.analysis_name, id, bits_to_string(gens));\n-            if !self.each_bit(gens, |i| f(i)) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_bit<F>(&self, words: &[usize], mut f: F) -> bool where\n-        F: FnMut(usize) -> bool,\n-    {\n-        //! Helper for iterating over the bits in a bit set.\n-        //! Returns false on the first call to `f` that returns false;\n-        //! if all calls to `f` return true, then returns true.\n-\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        for (word_index, &word) in words.iter().enumerate() {\n-            if word != 0 {\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // N.B., we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS.  This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value.  So before we callback, check\n-                        // whether the bit_index is greater than the\n-                        // actual value the user specified and stop\n-                        // iterating if so.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= self.bits_per_id {\n-                            return true;\n-                        } else if !f(bit_index) {\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn add_kills_from_flow_exits(&mut self, cfg: &cfg::CFG) {\n-        //! Whenever you have a `break` or `continue` statement, flow\n-        //! exits through any number of enclosing scopes on its way to\n-        //! the new destination. This function infers the kill bits of\n-        //! those control operators based on the kill bits associated\n-        //! with those scopes.\n-        //!\n-        //! This is usually called (if it is called at all), after\n-        //! all add_gen and add_kill calls, but before propagate.\n-\n-        debug!(\"{} add_kills_from_flow_exits\", self.analysis_name);\n-        if self.bits_per_id == 0 {\n-            // Skip the surprisingly common degenerate case.  (Note\n-            // compute_id_range requires self.words_per_id > 0.)\n-            return;\n-        }\n-        cfg.graph.each_edge(|_edge_index, edge| {\n-            let flow_exit = edge.source();\n-            let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.scope_kills[start.. end].to_vec();\n-\n-            let mut changed = false;\n-            for &id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.local_id_to_index.get(&id);\n-                match opt_cfg_idx {\n-                    Some(indices) => {\n-                        for &cfg_idx in indices {\n-                            let (start, end) = self.compute_id_range(cfg_idx);\n-                            let kills = &self.scope_kills[start.. end];\n-                            if bitwise(&mut orig_kills, kills, &Union) {\n-                                debug!(\"scope exits: scope id={:?} \\\n-                                        (node={:?} of {:?}) added killset: {}\",\n-                                       id, cfg_idx, indices,\n-                                       bits_to_string(kills));\n-                                changed = true;\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n-                                no cfg_idx for exiting_scope={:?}\",\n-                               self.analysis_name, flow_exit, id);\n-                    }\n-                }\n-            }\n-\n-            if changed {\n-                let bits = &mut self.scope_kills[start.. end];\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.copy_from_slice(&orig_kills[..]);\n-                debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n-                       self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-            }\n-            true\n-        });\n-    }\n-}\n-\n-// N.B. `Clone + 'static` only needed for pretty printing.\n-impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n-    pub fn propagate(&mut self, cfg: &cfg::CFG, body: &hir::Body) {\n-        //! Performs the data flow analysis.\n-\n-        if self.bits_per_id == 0 {\n-            // Optimize the surprisingly common degenerate case.\n-            return;\n-        }\n-\n-        {\n-            let words_per_id = self.words_per_id;\n-            let mut propcx = PropagationContext {\n-                dfcx: &mut *self,\n-                changed: true\n-            };\n-\n-            let nodes_po = cfg.graph.nodes_in_postorder(OUTGOING, cfg.entry);\n-            let mut temp = vec![0; words_per_id];\n-            let mut num_passes = 0;\n-            while propcx.changed {\n-                num_passes += 1;\n-                propcx.changed = false;\n-                propcx.reset(&mut temp);\n-                propcx.walk_cfg(cfg, &nodes_po, &mut temp);\n-            }\n-            debug!(\"finished in {} iterations\", num_passes);\n-        }\n-\n-        debug!(\"Dataflow result for {}:\", self.analysis_name);\n-        debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::INDENT_UNIT);\n-            s.ibox(0);\n-            s.print_expr(&body.value)\n-        }));\n-    }\n-}\n-\n-impl<O: DataFlowOperator> PropagationContext<'_, 'tcx, O> {\n-    fn walk_cfg(&mut self,\n-                cfg: &cfg::CFG,\n-                nodes_po: &[CFGIndex],\n-                in_out: &mut [usize]) {\n-        debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n-               bits_to_string(in_out), self.dfcx.analysis_name);\n-        assert!(self.dfcx.bits_per_id > 0);\n-\n-        // Iterate over nodes in reverse post-order.\n-        for &node_index in nodes_po.iter().rev() {\n-            let node = cfg.graph.node(node_index);\n-            debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n-                   node_index, node.data.id(), bits_to_string(in_out));\n-\n-            let (start, end) = self.dfcx.compute_id_range(node_index);\n-\n-            // Initialize local bitvector with state on-entry.\n-            in_out.copy_from_slice(&self.dfcx.on_entry[start.. end]);\n-\n-            // Compute state on-exit by applying transfer function to\n-            // state on-entry.\n-            self.dfcx.apply_gen_kill(node_index, in_out);\n-\n-            // Propagate state on-exit from node into its successors.\n-            self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n-        }\n-    }\n-\n-    fn reset(&mut self, bits: &mut [usize]) {\n-        let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n-        for b in bits {\n-            *b = e;\n-        }\n-    }\n-\n-    fn propagate_bits_into_graph_successors_of(&mut self,\n-                                               pred_bits: &[usize],\n-                                               cfg: &cfg::CFG,\n-                                               cfgidx: CFGIndex) {\n-        for (_, edge) in cfg.graph.outgoing_edges(cfgidx) {\n-            self.propagate_bits_into_entry_set_for(pred_bits, edge);\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(&mut self,\n-                                         pred_bits: &[usize],\n-                                         edge: &cfg::CFGEdge) {\n-        let source = edge.source();\n-        let cfgidx = edge.target();\n-        debug!(\"{} propagate_bits_into_entry_set_for(pred_bits={}, {:?} to {:?})\",\n-               self.dfcx.analysis_name, bits_to_string(pred_bits), source, cfgidx);\n-        assert!(self.dfcx.bits_per_id > 0);\n-\n-        let (start, end) = self.dfcx.compute_id_range(cfgidx);\n-        let changed = {\n-            // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = &mut self.dfcx.on_entry[start.. end];\n-            bitwise(on_entry, pred_bits, &self.dfcx.oper)\n-        };\n-        if changed {\n-            debug!(\"{} changed entry set for {:?} to {}\",\n-                   self.dfcx.analysis_name, cfgidx,\n-                   bits_to_string(&self.dfcx.on_entry[start.. end]));\n-            self.changed = true;\n-        }\n-    }\n-}\n-\n-fn mut_bits_to_string(words: &mut [usize]) -> String {\n-    bits_to_string(words)\n-}\n-\n-fn bits_to_string(words: &[usize]) -> String {\n-    let mut result = String::new();\n-    let mut sep = '[';\n-\n-    // Note: this is a little endian printout of bytes.\n-\n-    for &word in words {\n-        let mut v = word;\n-        for _ in 0..mem::size_of::<usize>() {\n-            result.push(sep);\n-            result.push_str(&format!(\"{:02x}\", v & 0xFF));\n-            v >>= 8;\n-            sep = '-';\n-        }\n-    }\n-    result.push(']');\n-    return result\n-}\n-\n-#[inline]\n-fn bitwise<Op: BitwiseOperator>(out_vec: &mut [usize],\n-                                in_vec: &[usize],\n-                                op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-fn set_bit(words: &mut [usize], bit: usize) -> bool {\n-    debug!(\"set_bit: words={} bit={}\",\n-           mut_bits_to_string(words), bit_str(bit));\n-    let usize_bits = mem::size_of::<usize>() * 8;\n-    let word = bit / usize_bits;\n-    let bit_in_word = bit % usize_bits;\n-    let bit_mask = 1 << bit_in_word;\n-    debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n-    let oldv = words[word];\n-    let newv = oldv | bit_mask;\n-    words[word] = newv;\n-    oldv != newv\n-}\n-\n-fn bit_str(bit: usize) -> String {\n-    let byte = bit >> 3;\n-    let lobits = 1 << (bit & 0b111);\n-    format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n-}\n-\n-struct Union;\n-impl BitwiseOperator for Union {\n-    fn join(&self, a: usize, b: usize) -> usize { a | b }\n-}\n-struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n-}"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,145 +0,0 @@\n-//! This module provides linkage between rustc::middle::graph and\n-//! libgraphviz traits, specialized to attaching borrowck analysis\n-//! data to rendered labels.\n-\n-pub use Variant::*;\n-\n-pub(crate) use crate::cfg::graphviz::{Node, Edge};\n-use crate::cfg::graphviz as cfg_dot;\n-use crate::cfg::CFGIndex;\n-use crate::borrowck::{self, BorrowckCtxt, LoanPath};\n-use crate::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n-use log::debug;\n-use std::rc::Rc;\n-\n-#[derive(Debug, Copy, Clone)]\n-pub enum Variant {\n-    Loans,\n-    Moves,\n-    Assigns,\n-}\n-\n-impl Variant {\n-    pub fn short_name(&self) -> &'static str {\n-        match *self {\n-            Loans   => \"loans\",\n-            Moves   => \"moves\",\n-            Assigns => \"assigns\",\n-        }\n-    }\n-}\n-\n-pub struct DataflowLabeller<'a, 'tcx> {\n-    pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n-    pub variants: Vec<Variant>,\n-    pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n-    pub analysis_data: &'a borrowck::AnalysisData<'tcx>,\n-}\n-\n-impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n-    fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n-        let id = n.1.data.id();\n-        debug!(\"dataflow_for({:?}, id={:?}) {:?}\", e, id, self.variants);\n-        let mut sets = String::new();\n-        let mut seen_one = false;\n-        for &variant in &self.variants {\n-            if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n-            sets.push_str(variant.short_name());\n-            sets.push_str(\": \");\n-            sets.push_str(&self.dataflow_for_variant(e, n, variant));\n-        }\n-        sets\n-    }\n-\n-    fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node<'_>, v: Variant) -> String {\n-        let cfgidx = n.0;\n-        match v {\n-            Loans   => self.dataflow_loans_for(e, cfgidx),\n-            Moves   => self.dataflow_moves_for(e, cfgidx),\n-            Assigns => self.dataflow_assigns_for(e, cfgidx),\n-        }\n-    }\n-\n-    fn build_set<O: DataFlowOperator, F>(\n-        &self,\n-        e: EntryOrExit,\n-        cfgidx: CFGIndex,\n-        dfcx: &DataFlowContext<'tcx, O>,\n-        mut to_lp: F,\n-    ) -> String\n-    where\n-        F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n-    {\n-        let mut saw_some = false;\n-        let mut set = \"{\".to_string();\n-        dfcx.each_bit_for_node(e, cfgidx, |index| {\n-            let lp = to_lp(index);\n-            if saw_some {\n-                set.push_str(\", \");\n-            }\n-            let loan_str = self.borrowck_ctxt.loan_path_to_string(&lp);\n-            set.push_str(&loan_str);\n-            saw_some = true;\n-            true\n-        });\n-        set.push_str(\"}\");\n-        set\n-    }\n-\n-    fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.loans;\n-        let loan_index_to_path = |loan_index| {\n-            let all_loans = &self.analysis_data.all_loans;\n-            let l: &borrowck::Loan<'_> = &all_loans[loan_index];\n-            l.loan_path()\n-        };\n-        self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n-    }\n-\n-    fn dataflow_moves_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.move_data.dfcx_moves;\n-        let move_index_to_path = |move_index| {\n-            let move_data = &self.analysis_data.move_data.move_data;\n-            let moves = move_data.moves.borrow();\n-            let the_move: &borrowck::move_data::Move = &(*moves)[move_index];\n-            move_data.path_loan_path(the_move.path)\n-        };\n-        self.build_set(e, cfgidx, dfcx, move_index_to_path)\n-    }\n-\n-    fn dataflow_assigns_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n-        let dfcx = &self.analysis_data.move_data.dfcx_assign;\n-        let assign_index_to_path = |assign_index| {\n-            let move_data = &self.analysis_data.move_data.move_data;\n-            let assignments = move_data.var_assignments.borrow();\n-            let assignment: &borrowck::move_data::Assignment = &(*assignments)[assign_index];\n-            move_data.path_loan_path(assignment.path)\n-        };\n-        self.build_set(e, cfgidx, dfcx, assign_index_to_path)\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::Labeller<'a> for DataflowLabeller<'a, 'tcx> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn graph_id(&'a self) -> dot::Id<'a> { self.inner.graph_id() }\n-    fn node_id(&'a self, n: &Node<'a>) -> dot::Id<'a> { self.inner.node_id(n) }\n-    fn node_label(&'a self, n: &Node<'a>) -> dot::LabelText<'a> {\n-        let prefix = self.dataflow_for(EntryOrExit::Entry, n);\n-        let suffix = self.dataflow_for(EntryOrExit::Exit, n);\n-        let inner_label = self.inner.node_label(n);\n-        inner_label\n-            .prefix_line(dot::LabelText::LabelStr(prefix.into()))\n-            .suffix_line(dot::LabelText::LabelStr(suffix.into()))\n-    }\n-    fn edge_label(&'a self, e: &Edge<'a>) -> dot::LabelText<'a> { self.inner.edge_label(e) }\n-}\n-\n-impl<'a, 'tcx> dot::GraphWalk<'a> for DataflowLabeller<'a, 'tcx> {\n-    type Node = Node<'a>;\n-    type Edge = Edge<'a>;\n-    fn nodes(&'a self) -> dot::Nodes<'a, Node<'a>> { self.inner.nodes() }\n-    fn edges(&'a self) -> dot::Edges<'a, Edge<'a>> { self.inner.edges() }\n-    fn source(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.source(edge) }\n-    fn target(&'a self, edge: &Edge<'a>) -> Node<'a> { self.inner.target(edge) }\n-}"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a37fe2de697bb1a9d304e4e811836e125f944cd5/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=a37fe2de697bb1a9d304e4e811836e125f944cd5", "patch": "@@ -1,23 +0,0 @@\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n-#![allow(non_camel_case_types)]\n-\n-#![feature(in_band_lifetimes)]\n-#![feature(nll)]\n-\n-#![recursion_limit=\"256\"]\n-\n-#[macro_use]\n-extern crate rustc;\n-\n-pub use borrowck::check_crate;\n-pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-\n-mod borrowck;\n-\n-pub mod graphviz;\n-\n-mod dataflow;\n-pub mod cfg;\n-\n-pub use borrowck::provide;"}]}