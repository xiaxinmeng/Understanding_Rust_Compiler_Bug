{"sha": "2a57b019808370d6b4d95a7e7dae354fe12de9db", "node_id": "C_kwDOAAsO6NoAKDJhNTdiMDE5ODA4MzcwZDZiNGQ5NWE3ZTdkYWUzNTRmZTEyZGU5ZGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T07:37:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-14T07:37:53Z"}, "message": "Auto merge of #14122 - lowr:patch/abort-macro-expansion-on-overflow, r=Veykril\n\nfix: Don't expand macros in the same expansion tree after overflow\n\nThis patch fixes 2 bugs:\n\n- In `Expander::enter_expand_id()` (and in code paths it's called), we never check whether we've reached the recursion limit. Although it hasn't been reported as far as I'm aware, this may cause hangs or stack overflows if some malformed attribute macro is used on associated items.\n- We keep expansion even when recursion limit is reached. Take the following for example:\n\n  ```rust\n  macro_rules! foo { () => {{ foo!(); foo!(); }} }\n  fn main() { foo!(); }\n  ```\n\n  We keep expanding the first `foo!()` in each expansion and would reach the limit at some point, *after which* we would try expanding the second `foo!()` in each expansion until it hits the limit again. This will (by default) lead to ~2^128 expansions.\n\n  This is essentially what's happening in #14074. Unlike rustc, we don't just stop expanding macros when we fail as long as it produces some tokens so that we can provide completions and other services in incomplete macro calls.\n\nThis patch provides a method that takes care of recursion depths (`Expander::within_limit()`) and stops macro expansions in the whole macro expansion tree once it detects recursion depth overflow. To be honest, I'm not really satisfied with this fix because it can still be used in unintended ways to bypass overflow checks, and I'm still seeking ways such that misuses are caught by the compiler by leveraging types or something.\n\nFixes #14074", "tree": {"sha": "7dcc4e66871a796d866dea6b5506b58921b293e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dcc4e66871a796d866dea6b5506b58921b293e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a57b019808370d6b4d95a7e7dae354fe12de9db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a57b019808370d6b4d95a7e7dae354fe12de9db", "html_url": "https://github.com/rust-lang/rust/commit/2a57b019808370d6b4d95a7e7dae354fe12de9db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a57b019808370d6b4d95a7e7dae354fe12de9db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381295144e86f52f9a371a4798b01678eaa523a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/381295144e86f52f9a371a4798b01678eaa523a8", "html_url": "https://github.com/rust-lang/rust/commit/381295144e86f52f9a371a4798b01678eaa523a8"}, {"sha": "ae7e62c50fb2974430cf401e24747bafef7f701a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7e62c50fb2974430cf401e24747bafef7f701a", "html_url": "https://github.com/rust-lang/rust/commit/ae7e62c50fb2974430cf401e24747bafef7f701a"}], "stats": {"total": 163, "additions": 114, "deletions": 49}, "files": [{"sha": "8fd9255b8b130e1ea963cfbff333f88d6e462cc7", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=2a57b019808370d6b4d95a7e7dae354fe12de9db", "patch": "@@ -19,7 +19,7 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n@@ -51,7 +51,8 @@ pub struct Expander {\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n     module: LocalModuleId,\n-    recursion_limit: usize,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: usize,\n }\n \n impl CfgExpander {\n@@ -84,7 +85,7 @@ impl Expander {\n             def_map,\n             current_file_id,\n             module: module.local_id,\n-            recursion_limit: 0,\n+            recursion_depth: 0,\n         }\n     }\n \n@@ -93,47 +94,52 @@ impl Expander {\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n-        if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return Ok(ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            )));\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+\n+            let resolver =\n+                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n+\n+            let mut err = None;\n+            let call_id = match macro_call.as_call_id_with_errors(\n+                db,\n+                this.def_map.krate(),\n+                resolver,\n+                &mut |e| {\n+                    err.get_or_insert(e);\n+                },\n+            ) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    return ExpandResult { value: None, err: None };\n+                }\n+            };\n+            ExpandResult { value: call_id.ok(), err }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n         }\n-\n-        let macro_call = InFile::new(self.current_file_id, &macro_call);\n-\n-        let resolver =\n-            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-        let mut err = None;\n-        let call_id =\n-            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n-                err.get_or_insert(e);\n-            })?;\n-        let call_id = match call_id {\n-            Ok(it) => it,\n-            Err(_) => {\n-                return Ok(ExpandResult { value: None, err });\n-            }\n-        };\n-\n-        Ok(self.enter_expand_inner(db, call_id, err))\n     }\n \n     pub fn enter_expand_id<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n-        self.enter_expand_inner(db, call_id, None)\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n     }\n \n-    fn enter_expand_inner<T: ast::AstNode>(\n-        &mut self,\n+    fn enter_expand_inner(\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n         mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n+    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -154,29 +160,21 @@ impl Expander {\n             }\n         };\n \n-        let node = match T::cast(raw_node) {\n-            Some(it) => it,\n-            None => {\n-                // This can happen without being an error, so only forward previous errors.\n-                return ExpandResult { value: None, err };\n-            }\n-        };\n-\n-        tracing::debug!(\"macro expansion {:#?}\", node.syntax());\n-\n-        self.recursion_limit += 1;\n-        let mark =\n-            Mark { file_id: self.current_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-        self.current_file_id = file_id;\n-\n-        ExpandResult { value: Some((mark, node)), err }\n+        ExpandResult { value: Some((file_id, raw_node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n-        self.recursion_limit -= 1;\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n         mark.bomb.defuse();\n     }\n \n@@ -215,6 +213,50 @@ impl Expander {\n         #[cfg(test)]\n         return Limit::new(std::cmp::min(32, limit));\n     }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, T)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n+            self.recursion_depth = usize::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|(new_file_id, node)| {\n+                let node = T::cast(node)?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, node))\n+            })\n+        })\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "04b1c4f01e22a4f0c263d9dc794ae413b986abed", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=2a57b019808370d6b4d95a7e7dae354fe12de9db", "patch": "@@ -624,6 +624,10 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n+                Some(ExpandError::RecursionOverflowPosioned) => {\n+                    // Recursion limit has been reached in the macro expansion tree, but not in\n+                    // this very macro call. Don't add diagnostics to avoid duplication.\n+                }\n                 Some(err) => {\n                     self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n                         node: InFile::new(outer_file, syntax_ptr),\n@@ -636,6 +640,8 @@ impl ExprCollector<'_> {\n \n         match res.value {\n             Some((mark, expansion)) => {\n+                // Keep collecting even with expansion errors so we can provide completions and\n+                // other services in incomplete macro expressions.\n                 self.source_map.expansions.insert(macro_call_ptr, self.expander.current_file_id);\n                 let prev_ast_id_map = mem::replace(\n                     &mut self.ast_id_map,"}, {"sha": "edee2c7ff96bfb76809bf91a8a03f77e6bc0234b", "filename": "crates/hir-def/src/body/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs?ref=2a57b019808370d6b4d95a7e7dae354fe12de9db", "patch": "@@ -61,6 +61,19 @@ fn main() { n_nuple!(1,2,3); }\n     );\n }\n \n+#[test]\n+fn your_stack_belongs_to_me2() {\n+    cov_mark::check!(overflow_but_not_me);\n+    lower(\n+        r#\"\n+macro_rules! foo {\n+    () => {{ foo!(); foo!(); }}\n+}\n+fn main() { foo!(); }\n+\"#,\n+    );\n+}\n+\n #[test]\n fn recursion_limit() {\n     cov_mark::check!(your_stack_belongs_to_me);"}, {"sha": "a52716cc02c2589fa459b1d6015e8b1c59747ed8", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a57b019808370d6b4d95a7e7dae354fe12de9db/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=2a57b019808370d6b4d95a7e7dae354fe12de9db", "patch": "@@ -55,6 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n+    RecursionOverflowPosioned,\n     Other(Box<str>),\n }\n \n@@ -69,6 +70,9 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n+            ExpandError::RecursionOverflowPosioned => {\n+                f.write_str(\"overflow expanding the original macro\")\n+            }\n             ExpandError::Other(it) => f.write_str(it),\n         }\n     }"}]}