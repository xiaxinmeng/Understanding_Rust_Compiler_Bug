{"sha": "819f76ca8251b2fd1910546d133e305fda8dc5e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOWY3NmNhODI1MWIyZmQxOTEwNTQ2ZDEzM2UzMDVmZGE4ZGM1ZTU=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-10T21:03:19Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T18:36:27Z"}, "message": "Store the registered lints in the Session", "tree": {"sha": "2dfb9db9b53d4fb16f777343733df03841dda519", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dfb9db9b53d4fb16f777343733df03841dda519"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/819f76ca8251b2fd1910546d133e305fda8dc5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/819f76ca8251b2fd1910546d133e305fda8dc5e5", "html_url": "https://github.com/rust-lang/rust/commit/819f76ca8251b2fd1910546d133e305fda8dc5e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/819f76ca8251b2fd1910546d133e305fda8dc5e5/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "442fbc473e10d1efe3359b19f342d11097259fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/442fbc473e10d1efe3359b19f342d11097259fc4", "html_url": "https://github.com/rust-lang/rust/commit/442fbc473e10d1efe3359b19f342d11097259fc4"}], "stats": {"total": 336, "additions": 208, "deletions": 128}, "files": [{"sha": "9a36ea1e65cdbbf991d0fb018901d918b7104d88", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -79,8 +79,12 @@ pub fn compile_input(sess: Session,\n                                                  &sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n                                          outputs.out_filestem.as_slice());\n-            let (expanded_crate, ast_map) =\n-                phase_2_configure_and_expand(&sess, krate, &id);\n+            let (expanded_crate, ast_map)\n+                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                    None => return,\n+                    Some(p) => p,\n+                };\n+\n             (outputs, expanded_crate, ast_map)\n         };\n         write_out_deps(&sess, input, &outputs, &expanded_crate);\n@@ -173,10 +177,12 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n+///\n+/// Returns `None` if we're aborting after handling -W help.\n pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_id: &CrateId)\n-                                    -> (ast::Crate, syntax::ast_map::Map) {\n+                                    -> Option<(ast::Crate, syntax::ast_map::Map)> {\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, krate.attrs.as_slice());\n@@ -212,6 +218,17 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     let Registry { syntax_exts, .. } = registry;\n \n+    // Process command line flags for lints.\n+    // Do this here because we will have lint plugins eventually.\n+    if sess.opts.describe_lints {\n+        super::describe_lints(&*sess.lint_store.borrow());\n+        return None;\n+    }\n+    sess.lint_store.borrow_mut().process_command_line(sess);\n+\n+    // Abort if there are errors from lint processing or a plugin registrar.\n+    sess.abort_if_errors();\n+\n     krate = time(time_passes, \"expansion\", (krate, macros, syntax_exts),\n         |(krate, macros, syntax_exts)| {\n             // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -254,7 +271,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         krate.encode(&mut json).unwrap();\n     }\n \n-    (krate, map)\n+    Some((krate, map))\n }\n \n pub struct CrateAnalysis {\n@@ -631,9 +648,11 @@ pub fn pretty_print_input(sess: Session,\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {\n-            let (krate, ast_map) = phase_2_configure_and_expand(&sess,\n-                                                                krate,\n-                                                                &id);\n+            let (krate, ast_map)\n+                = match phase_2_configure_and_expand(&sess, krate, &id) {\n+                    None => return,\n+                    Some(p) => p,\n+                };\n             (krate, Some(ast_map), true)\n         }\n         _ => (krate, None, false)"}, {"sha": "7c8f5a90b5a80a4cad53dec0bafb0f91f89993a0", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -13,6 +13,7 @@ pub use syntax::diagnostic;\n use back::link;\n use driver::driver::{Input, FileInput, StrInput};\n use driver::session::{Session, build_session};\n+use lint::Lint;\n use lint;\n use metadata;\n \n@@ -48,15 +49,18 @@ fn run_compiler(args: &[String]) {\n         Some(matches) => matches,\n         None => return\n     };\n-\n     let sopts = config::build_session_options(&matches);\n-    if sopts.describe_lints {\n-        describe_lints();\n-        return;\n-    }\n \n     let (input, input_file_path) = match matches.free.len() {\n-        0u => early_error(\"no input filename given\"),\n+        0u => {\n+            if sopts.describe_lints {\n+                let mut ls = lint::LintStore::new();\n+                ls.register_builtin(None);\n+                describe_lints(&ls);\n+                return;\n+            }\n+            early_error(\"no input filename given\");\n+        }\n         1u => {\n             let ifile = matches.free.get(0).as_slice();\n             if ifile == \"-\" {\n@@ -128,43 +132,56 @@ Additional help:\n                              config::optgroups().as_slice()));\n }\n \n-fn describe_lints() {\n+fn describe_lints(lint_store: &lint::LintStore) {\n     println!(\"\n Available lint options:\n     -W <foo>           Warn about <foo>\n     -A <foo>           Allow <foo>\n     -D <foo>           Deny <foo>\n     -F <foo>           Forbid <foo> (deny, and deny all overrides)\n+\n \");\n \n-    let mut builtin_specs = lint::builtin_lint_specs();\n-    builtin_specs.sort_by(|x, y| {\n-        match x.default_level.cmp(&y.default_level) {\n-            Equal => x.name.cmp(&y.name),\n-            r => r,\n-        }\n-    });\n+    fn sort_lints(lints: Vec<(&'static Lint, bool)>) -> Vec<&'static Lint> {\n+        let mut lints: Vec<_> = lints.move_iter().map(|(x, _)| x).collect();\n+        lints.sort_by(|x: &&Lint, y: &&Lint| {\n+            match x.default_level.cmp(&y.default_level) {\n+                Equal => x.name.cmp(&y.name),\n+                r => r,\n+            }\n+        });\n+        lints\n+    }\n \n-    // FIXME: What if someone uses combining characters or East Asian fullwidth\n-    // characters in a lint name?!?!?\n-    let max_name_len = builtin_specs.iter()\n+    let (_plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n+    // let plugin = sort_lints(plugin);\n+    let builtin = sort_lints(builtin);\n+\n+    // FIXME (#7043): We should use the width in character cells rather than\n+    // the number of codepoints.\n+    let max_name_len = builtin.iter()\n         .map(|&s| s.name.char_len())\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        format!(\"{}{}\", \" \".repeat(max_name_len - x.char_len()), x)\n+        \" \".repeat(max_name_len - x.char_len()).append(x)\n     };\n \n-    println!(\"\\nAvailable lint checks:\\n\");\n+    println!(\"Lint checks provided by rustc:\\n\");\n     println!(\"    {}  {:7.7s}  {}\", padded(\"name\"), \"default\", \"meaning\");\n     println!(\"    {}  {:7.7s}  {}\", padded(\"----\"), \"-------\", \"-------\");\n-    println!(\"\");\n \n-    for spec in builtin_specs.move_iter() {\n-        let name = spec.name.replace(\"_\", \"-\");\n-        println!(\"    {}  {:7.7s}  {}\",\n-            padded(name.as_slice()), spec.default_level.as_str(), spec.desc);\n-    }\n-    println!(\"\");\n+    let print_lints = |lints: Vec<&Lint>| {\n+        for lint in lints.move_iter() {\n+            let name = lint.name.replace(\"_\", \"-\");\n+            println!(\"    {}  {:7.7s}  {}\",\n+                padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lints(builtin);\n+\n+    // Describe lint plugins here once they exist.\n }\n \n fn describe_debug_flags() {"}, {"sha": "07366f34c4e03d7018c1821d408645025f59ccee", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -43,6 +43,7 @@ pub struct Session {\n     // expected to be absolute. `None` means that there is no source file.\n     pub local_crate_source_file: Option<Path>,\n     pub working_dir: Path,\n+    pub lint_store: RefCell<lint::LintStore>,\n     pub lints: RefCell<NodeMap<Vec<(lint::LintId, codemap::Span, String)>>>,\n     pub node_id: Cell<ast::NodeId>,\n     pub crate_types: RefCell<Vec<config::CrateType>>,\n@@ -226,7 +227,7 @@ pub fn build_session_(sopts: config::Options,\n         }\n     );\n \n-    Session {\n+    let sess = Session {\n         targ_cfg: target_cfg,\n         opts: sopts,\n         cstore: CStore::new(token::get_ident_interner()),\n@@ -238,12 +239,16 @@ pub fn build_session_(sopts: config::Options,\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd(),\n+        lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap::new()),\n         node_id: Cell::new(1),\n         crate_types: RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new(),\n         recursion_limit: Cell::new(64),\n-    }\n+    };\n+\n+    sess.lint_store.borrow_mut().register_builtin(Some(&sess));\n+    sess\n }\n \n // Seems out of place, but it uses session, so I'm putting it here"}, {"sha": "83a0c22dec19a719c5a5f25fc2297d55cdbb1fa3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -1517,7 +1517,7 @@ impl LintPass for GatherNodeLevels {\n         match it.node {\n             ast::ItemEnum(..) => {\n                 let lint_id = lint::LintId::of(variant_size_difference);\n-                match cx.get_level_source(lint_id) {\n+                match cx.lints.get_level_source(lint_id) {\n                     lvlsrc @ (lvl, _) if lvl != lint::Allow => {\n                         cx.insert_node_level(it.id, lint_id, lvlsrc);\n                     },"}, {"sha": "c481c5081d173f9cb56c7adc67de404d79466cce", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 123, "deletions": 88, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -48,6 +48,7 @@ use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n use driver::session::Session;\n+use driver::early_error;\n \n use std::collections::HashMap;\n use std::rc::Rc;\n@@ -58,6 +59,7 @@ use std::default::Default;\n use std::hash::Hash;\n use std::tuple::Tuple2;\n use std::hash;\n+use std::mem;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -115,15 +117,15 @@ pub struct Lint {\n     pub desc: &'static str,\n }\n \n-type LintArray = &'static [&'static Lint];\n+pub type LintArray = &'static [&'static Lint];\n \n /// Trait for types providing lint checks. Each `check` method checks a single\n /// syntax node, and should not invoke methods recursively (unlike `Visitor`).\n /// By default they do nothing.\n //\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n-trait LintPass {\n+pub trait LintPass {\n     /// Get descriptions of the lints this `LintPass` object can emit.\n     ///\n     /// NB: there is no enforcement that the object only emits lints it registered.\n@@ -246,15 +248,117 @@ pub enum LintSource {\n \n pub type LevelSource = (Level, LintSource);\n \n-struct Context<'a> {\n+/// Information about the registered lints.\n+/// This is basically the subset of `Context` that we can\n+/// build early in the compile pipeline.\n+pub struct LintStore {\n+    /// Registered lints. The bool is true if the lint was\n+    /// added by a plugin.\n+    lints: Vec<(&'static Lint, bool)>,\n+\n     /// Trait objects for each lint pass.\n-    lint_objects: Vec<RefCell<LintPassObject>>,\n+    passes: Vec<RefCell<LintPassObject>>,\n \n     /// Lints indexed by name.\n-    lints_by_name: HashMap<&'static str, LintId>,\n+    by_name: HashMap<&'static str, LintId>,\n \n     /// Current levels of each lint, and where they were set.\n     levels: HashMap<LintId, LevelSource>,\n+}\n+\n+impl LintStore {\n+    fn get_level_source(&self, lint: LintId) -> LevelSource {\n+        match self.levels.find(&lint) {\n+            Some(&s) => s,\n+            None => (Allow, Default),\n+        }\n+    }\n+\n+    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n+        if lvlsrc.val0() == Allow {\n+            self.levels.remove(&lint);\n+        } else {\n+            self.levels.insert(lint, lvlsrc);\n+        }\n+    }\n+\n+    pub fn new() -> LintStore {\n+        LintStore {\n+            lints: vec!(),\n+            passes: vec!(),\n+            by_name: HashMap::new(),\n+            levels: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n+        self.lints.as_slice()\n+    }\n+\n+    pub fn register_pass(&mut self, sess: Option<&Session>,\n+                         from_plugin: bool, pass: LintPassObject) {\n+        for &lint in pass.get_lints().iter() {\n+            self.lints.push((lint, from_plugin));\n+\n+            let id = LintId::of(lint);\n+            if !self.by_name.insert(lint.name, id) {\n+                let msg = format!(\"duplicate specification of lint {}\", lint.name);\n+                match (sess, from_plugin) {\n+                    // We load builtin lints first, so a duplicate is a compiler bug.\n+                    // Use early_error when handling -W help with no crate.\n+                    (None, _) => early_error(msg.as_slice()),\n+                    (Some(sess), false) => sess.bug(msg.as_slice()),\n+\n+                    // A duplicate name from a plugin is a user error.\n+                    (Some(sess), true)  => sess.err(msg.as_slice()),\n+                }\n+            }\n+\n+            if lint.default_level != Allow {\n+                self.levels.insert(id, (lint.default_level, Default));\n+            }\n+        }\n+        self.passes.push(RefCell::new(pass));\n+    }\n+\n+    pub fn register_builtin(&mut self, sess: Option<&Session>) {\n+        macro_rules! add_builtin_lints ( ( $sess:ident, $($name:ident),*, ) => (\n+            {$(\n+                {\n+                    let obj: builtin::$name = Default::default();\n+                    self.register_pass($sess, false, box obj as LintPassObject);\n+                };\n+            )*}\n+        ))\n+\n+        add_builtin_lints!(sess,\n+            WhileTrue, UnusedCasts, TypeLimits, CTypes, HeapMemory,\n+            RawPointerDeriving, UnusedAttribute, PathStatement,\n+            UnusedResult, DeprecatedOwnedVector, NonCamelCaseTypes,\n+            NonSnakeCaseFunctions, NonUppercaseStatics,\n+            NonUppercasePatternStatics, UppercaseVariables,\n+            UnnecessaryParens, UnusedUnsafe, UnsafeBlock, UnusedMut,\n+            UnnecessaryAllocation, MissingDoc, Stability,\n+\n+            GatherNodeLevels, HardwiredLints,\n+        )\n+    }\n+\n+    pub fn process_command_line(&mut self, sess: &Session) {\n+        for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n+            match self.by_name.find_equiv(&lint_name.as_slice()) {\n+                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+                None => sess.err(format!(\"unknown {} flag: {}\",\n+                    level.as_str(), lint_name).as_slice()),\n+            }\n+        }\n+    }\n+}\n+\n+/// Context for lint checking.\n+pub struct Context<'a> {\n+    /// The store of registered lints.\n+    lints: LintStore,\n \n     /// Context we're checking in (used to access fields like sess).\n     tcx: &'a ty::ctxt,\n@@ -271,7 +375,7 @@ struct Context<'a> {\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => (\n-    for obj in $cx.lint_objects.iter() {\n+    for obj in $cx.lints.passes.iter() {\n         obj.borrow_mut().$f($cx, $($args),*);\n     }\n ))\n@@ -316,26 +420,11 @@ pub fn emit_lint(sess: &Session, lint: &'static Lint,\n }\n \n impl<'a> Context<'a> {\n-    fn get_level_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.find(&lint) {\n-            Some(&s) => s,\n-            None => (Allow, Default),\n-        }\n-    }\n-\n-    fn set_level(&mut self, lint: LintId, lvlsrc: LevelSource) {\n-        if lvlsrc.val0() == Allow {\n-            self.levels.remove(&lint);\n-        } else {\n-            self.levels.insert(lint, lvlsrc);\n-        }\n-    }\n-\n-    fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n-        let (level, src) = match self.levels.find(&LintId::of(lint)) {\n+    pub fn span_lint(&self, lint: &'static Lint, span: Span, msg: &str) {\n+        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src))\n-                => (self.get_level_source(LintId::of(builtin::warnings)).val0(), src),\n+                => (self.lints.get_level_source(LintId::of(builtin::warnings)).val0(), src),\n             Some(&pair) => pair,\n         };\n \n@@ -357,17 +446,17 @@ impl<'a> Context<'a> {\n         let lint_attrs = self.gather_lint_attrs(attrs);\n         let mut pushed = 0u;\n         for (lint_id, level, span) in lint_attrs.move_iter() {\n-            let now = self.get_level_source(lint_id).val0();\n+            let now = self.lints.get_level_source(lint_id).val0();\n             if now == Forbid && level != Forbid {\n                 let lint_name = lint_id.as_str();\n                 self.tcx.sess.span_err(span,\n                 format!(\"{}({}) overruled by outer forbid({})\",\n                         level.as_str(), lint_name, lint_name).as_slice());\n             } else if now != level {\n-                let src = self.get_level_source(lint_id).val1();\n+                let src = self.lints.get_level_source(lint_id).val1();\n                 self.level_stack.push((lint_id, (now, src)));\n                 pushed += 1;\n-                self.set_level(lint_id, (level, Node(span)));\n+                self.lints.set_level(lint_id, (level, Node(span)));\n             }\n         }\n \n@@ -378,7 +467,7 @@ impl<'a> Context<'a> {\n         // rollback\n         for _ in range(0, pushed) {\n             let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n-            self.set_level(lint, lvlsrc);\n+            self.lints.set_level(lint, lvlsrc);\n         }\n     }\n \n@@ -419,7 +508,7 @@ impl<'a> Context<'a> {\n             for meta in metas.iter() {\n                 match meta.node {\n                     ast::MetaWord(ref lint_name) => {\n-                        match self.lints_by_name.find_equiv(lint_name) {\n+                        match self.lints.by_name.find_equiv(lint_name) {\n                             Some(lint_id) => out.push((*lint_id, level, meta.span)),\n \n                             None => self.span_lint(builtin::unrecognized_lint,\n@@ -636,75 +725,21 @@ impl<'a> IdVisitingOperation for Context<'a> {\n     }\n }\n \n-fn builtin_lints() -> Vec<Box<LintPass>> {\n-    macro_rules! builtin_lints (( $($name:ident),*, ) => (\n-        vec!($(\n-            {\n-                let obj: builtin::$name = Default::default();\n-                box obj as LintPassObject\n-            }\n-        ),*)\n-    ))\n-\n-    builtin_lints!(\n-        WhileTrue, UnusedCasts, TypeLimits, CTypes, HeapMemory,\n-        RawPointerDeriving, UnusedAttribute, PathStatement,\n-        UnusedResult, DeprecatedOwnedVector, NonCamelCaseTypes,\n-        NonSnakeCaseFunctions, NonUppercaseStatics,\n-        NonUppercasePatternStatics, UppercaseVariables,\n-        UnnecessaryParens, UnusedUnsafe, UnsafeBlock, UnusedMut,\n-        UnnecessaryAllocation, MissingDoc, Stability,\n-\n-        GatherNodeLevels, HardwiredLints,\n-    )\n-}\n-\n-/// Get specs for all builtin lints.  Used for `-W help`.\n-pub fn builtin_lint_specs() -> Vec<&'static Lint> {\n-    builtin_lints().move_iter()\n-        .flat_map(|x| x.get_lints().iter().map(|&y| y))\n-        .collect()\n-}\n-\n pub fn check_crate(tcx: &ty::ctxt,\n                    exported_items: &ExportedItems,\n                    krate: &ast::Crate) {\n-    let lints = builtin_lints().move_iter().map(|x| RefCell::new(x)).collect();\n+\n+    // We want to own the lint store, so move it out of the session.\n+    let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n+        LintStore::new());\n \n     let mut cx = Context {\n-        lint_objects: lints,\n-        lints_by_name: HashMap::new(),\n-        levels: HashMap::new(),\n+        lints: lint_store,\n         tcx: tcx,\n         level_stack: Vec::new(),\n         node_levels: RefCell::new(HashMap::new()),\n     };\n \n-    // Index the lints by name, and set the default levels.\n-    for obj in cx.lint_objects.iter() {\n-        for &lint in obj.borrow_mut().get_lints().iter() {\n-            let id = LintId::of(lint);\n-            if !cx.lints_by_name.insert(lint.name, id) {\n-                cx.tcx.sess.err(format!(\"duplicate specification of lint {}\",\n-                    lint.name).as_slice());\n-            }\n-            if lint.default_level != Allow {\n-                cx.levels.insert(id, (lint.default_level, Default));\n-            }\n-        }\n-    }\n-\n-    // Set command line lint levels.\n-    for &(ref lint_name, level) in tcx.sess.opts.lint_opts.iter() {\n-        match cx.lints_by_name.find_equiv(&lint_name.as_slice()) {\n-            Some(&lint_id) => cx.set_level(lint_id, (level, CommandLine)),\n-            None => cx.tcx.sess.err(format!(\"unknown {} flag: {}\",\n-                level.as_str(), lint_name).as_slice()),\n-        }\n-    }\n-\n-    tcx.sess.abort_if_errors();\n-\n     // Visit the whole crate.\n     cx.with_lint_attrs(krate.attrs.as_slice(), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);"}, {"sha": "5ae469c41f2dfa39ed0f37b06b50454db956cf3c", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -120,7 +120,8 @@ fn test_env(_test_name: &str,\n                              name: \"test\".to_owned(),\n                              version: None };\n     let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, &krate_id);\n+        driver::phase_2_configure_and_expand(&sess, krate, &krate_id)\n+            .expect(\"phase 2 aborted\");\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&krate, &sess);"}, {"sha": "36bf02cac3050ddaa0eb5ab3b587e4b75cb8c7fa", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -102,8 +102,10 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n     }\n \n     let krate = phase_1_parse_input(&sess, cfg, &input);\n-    let (krate, ast_map) = phase_2_configure_and_expand(&sess, krate,\n-                                                        &from_str(\"rustdoc\").unwrap());\n+    let (krate, ast_map)\n+        = phase_2_configure_and_expand(&sess, krate, &from_str(\"rustdoc\").unwrap())\n+            .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n+\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &krate, ast_map);"}, {"sha": "e7fc3cedf5ec9cd40cc834997b1ccb9d387b3397", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819f76ca8251b2fd1910546d133e305fda8dc5e5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=819f76ca8251b2fd1910546d133e305fda8dc5e5", "patch": "@@ -69,7 +69,8 @@ pub fn run(input: &str,\n     }));\n     let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n     let (krate, _) = driver::phase_2_configure_and_expand(&sess, krate,\n-                                                          &from_str(\"rustdoc-test\").unwrap());\n+            &from_str(\"rustdoc-test\").unwrap())\n+        .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let ctx = box(GC) core::DocContext {\n         krate: krate,"}]}