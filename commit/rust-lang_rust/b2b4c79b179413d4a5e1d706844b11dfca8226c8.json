{"sha": "b2b4c79b179413d4a5e1d706844b11dfca8226c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjRjNzliMTc5NDEzZDRhNWUxZDcwNjg0NGIxMWRmY2E4MjI2Yzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T19:45:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:23Z"}, "message": "resolve -- rewrite conflict closure into method", "tree": {"sha": "61589c843a10b4e3138c949005fcac7705f517eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61589c843a10b4e3138c949005fcac7705f517eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b4c79b179413d4a5e1d706844b11dfca8226c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b4c79b179413d4a5e1d706844b11dfca8226c8", "html_url": "https://github.com/rust-lang/rust/commit/b2b4c79b179413d4a5e1d706844b11dfca8226c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b4c79b179413d4a5e1d706844b11dfca8226c8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "949e1c7935776ddb3e67ade590e9df58a5894cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/949e1c7935776ddb3e67ade590e9df58a5894cf8", "html_url": "https://github.com/rust-lang/rust/commit/949e1c7935776ddb3e67ade590e9df58a5894cf8"}], "stats": {"total": 91, "additions": 50, "deletions": 41}, "files": [{"sha": "9623f6f0cbc851b7f3f19beb86a62421153c6dab", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b2b4c79b179413d4a5e1d706844b11dfca8226c8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b4c79b179413d4a5e1d706844b11dfca8226c8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b2b4c79b179413d4a5e1d706844b11dfca8226c8", "patch": "@@ -2567,52 +2567,15 @@ impl Resolver {\n             }\n         }\n \n-        let merge_import_resolution = |name, name_bindings: @NameBindings| {\n-            let dest_import_resolution;\n-            let mut import_resolutions = module_.import_resolutions\n-                                                .borrow_mut();\n-            match import_resolutions.get().find(&name) {\n-                None => {\n-                    // Create a new import resolution from this child.\n-                    dest_import_resolution =\n-                        @ImportResolution::new(id, is_public);\n-                    import_resolutions.get().insert(name,\n-                                                    dest_import_resolution);\n-                }\n-                Some(&existing_import_resolution) => {\n-                    dest_import_resolution = existing_import_resolution;\n-                }\n-            }\n-\n-            debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n-                    to `{}`\",\n-                   token::get_ident(name).get().to_str(),\n-                   self.module_to_str(containing_module),\n-                   self.module_to_str(module_));\n-\n-            // Merge the child item into the import resolution.\n-            if name_bindings.defined_in_public_namespace(ValueNS) {\n-                debug!(\"(resolving glob import) ... for value target\");\n-                dest_import_resolution.value_target.set(\n-                    Some(Target::new(containing_module, name_bindings)));\n-                dest_import_resolution.value_id.set(id);\n-            }\n-            if name_bindings.defined_in_public_namespace(TypeNS) {\n-                debug!(\"(resolving glob import) ... for type target\");\n-                dest_import_resolution.type_target.set(\n-                    Some(Target::new(containing_module, name_bindings)));\n-                dest_import_resolution.type_id.set(id);\n-            }\n-            dest_import_resolution.is_public.set(is_public);\n-        };\n-\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n \n         {\n             let children = containing_module.children.borrow();\n             for (&name, name_bindings) in children.get().iter() {\n-                merge_import_resolution(name, *name_bindings);\n+                self.merge_import_resolution(module_, containing_module,\n+                                             id, is_public,\n+                                             name, *name_bindings);\n             }\n         }\n \n@@ -2623,7 +2586,9 @@ impl Resolver {\n             for (&name, module) in external_module_children.get().iter() {\n                 let name_bindings =\n                     @Resolver::create_name_bindings_from_module(*module);\n-                merge_import_resolution(name, name_bindings);\n+                self.merge_import_resolution(module_, containing_module,\n+                                             id, is_public,\n+                                             name, name_bindings);\n             }\n         }\n \n@@ -2641,6 +2606,50 @@ impl Resolver {\n         return Success(());\n     }\n \n+    fn merge_import_resolution(&mut self,\n+                               module_: @Module,\n+                               containing_module: @Module,\n+                               id: NodeId,\n+                               is_public: bool,\n+                               name: Name,\n+                               name_bindings: @NameBindings) {\n+        let dest_import_resolution;\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        match import_resolutions.get().find(&name) {\n+            None => {\n+                // Create a new import resolution from this child.\n+                dest_import_resolution =\n+                    @ImportResolution::new(id, is_public);\n+                import_resolutions.get().insert(name,\n+                                                dest_import_resolution);\n+            }\n+            Some(&existing_import_resolution) => {\n+                dest_import_resolution = existing_import_resolution;\n+            }\n+        }\n+\n+        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+               to `{}`\",\n+               token::get_ident(name).get().to_str(),\n+               self.module_to_str(containing_module),\n+               self.module_to_str(module_));\n+\n+        // Merge the child item into the import resolution.\n+        if name_bindings.defined_in_public_namespace(ValueNS) {\n+            debug!(\"(resolving glob import) ... for value target\");\n+            dest_import_resolution.value_target.set(\n+                Some(Target::new(containing_module, name_bindings)));\n+            dest_import_resolution.value_id.set(id);\n+        }\n+        if name_bindings.defined_in_public_namespace(TypeNS) {\n+            debug!(\"(resolving glob import) ... for type target\");\n+            dest_import_resolution.type_target.set(\n+                Some(Target::new(containing_module, name_bindings)));\n+            dest_import_resolution.type_id.set(id);\n+        }\n+        dest_import_resolution.is_public.set(is_public);\n+    }\n+\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: @Module,"}]}