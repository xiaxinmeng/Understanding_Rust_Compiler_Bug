{"sha": "3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZjg0ZmM1ZmRkOTUwOWZjM2VlNDU5NWZkNzZhYTMxZDQ4MTViMmE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:13:40Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:57:42Z"}, "message": "impl {i,u}{8,16,32,64,size}", "tree": {"sha": "3e60a6c33bf7a8abea171cae5168ebb13c3cd137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e60a6c33bf7a8abea171cae5168ebb13c3cd137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "html_url": "https://github.com/rust-lang/rust/commit/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/comments", "author": null, "committer": null, "parents": [{"sha": "8afcaabee32fb41eaf065041d7510c6762f12822", "url": "https://api.github.com/repos/rust-lang/rust/commits/8afcaabee32fb41eaf065041d7510c6762f12822", "html_url": "https://github.com/rust-lang/rust/commit/8afcaabee32fb41eaf065041d7510c6762f12822"}], "stats": {"total": 1007, "additions": 1004, "deletions": 3}, "files": [{"sha": "029d9d03835e88773ba8ed543fc876aa938012c7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -46,6 +46,7 @@ use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n use std::marker;\n use std::mem;\n+#[cfg(stage0)]\n use std::num::{Int, UnsignedInt};\n use std::ptr;\n use std::rc::Rc;"}, {"sha": "006d6bb040e6533992fb288fdb3363b12350df56", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -23,7 +23,7 @@ use core::iter::Zip;\n use core::marker::PhantomData;\n use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n-use core::{slice, mem, ptr, cmp, num, raw};\n+use core::{slice, mem, ptr, cmp, raw};\n use alloc::heap::{self, EMPTY};\n \n use borrow::Borrow;\n@@ -105,7 +105,10 @@ struct MutNodeSlice<'a, K: 'a, V: 'a> {\n /// Fails if `target_alignment` is not a power of two.\n #[inline]\n fn round_up_to_next(unrounded: usize, target_alignment: usize) -> usize {\n-    assert!(num::UnsignedInt::is_power_of_two(target_alignment));\n+    #[cfg(stage0)]\n+    use core::num::UnsignedInt;\n+\n+    assert!(target_alignment.is_power_of_two());\n     (unrounded + target_alignment - 1) & !(target_alignment - 1)\n }\n "}, {"sha": "82d68caeb3642749254dbddeb94b06e9455e6849", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -59,6 +59,7 @@ use core::intrinsics::assume;\n use core::iter::{repeat, FromIterator, IntoIterator};\n use core::marker::PhantomData;\n use core::mem;\n+#[cfg(stage0)]\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut, Deref, Add};\n use core::ops;"}, {"sha": "65e44703df10822d89623d691f55d99ad29c7c1d", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -25,6 +25,7 @@ use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n+#[cfg(stage0)]\n use core::num::{Int, UnsignedInt};\n use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};"}, {"sha": "4381b1fb3c907a4fe66184e62e38084f862446c4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 990, "deletions": 0, "changes": 990, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -708,6 +708,7 @@ signed_int_impl! { i32 }\n signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n+#[cfg(stage0)]\n /// A built-in unsigned integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait UnsignedInt: Int + WrappingOps {\n@@ -742,21 +743,1010 @@ pub trait UnsignedInt: Int + WrappingOps {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for uint {}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u8 {}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u16 {}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u32 {}\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl UnsignedInt for u64 {}\n \n+// NB(japaric) I added this module to avoid adding several `cfg(not(stage0))`, and avoid name\n+// clashes between macros. We should move all the items inside this module into the outer scope\n+// once the `Int` trait is removed\n+#[cfg(not(stage0))]\n+mod inherent {\n+    use intrinsics;\n+    use mem::size_of;\n+    use option::Option::{self, Some, None};\n+\n+    use super::wrapping::{OverflowingOps, WrappingOps};\n+\n+    // `Int` + `SignedInt` implemented for signed integers\n+    macro_rules! int_impl {\n+        ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+         $add_with_overflow:path,\n+         $sub_with_overflow:path,\n+         $mul_with_overflow:path) => {\n+            /// Returns the `0` value of this integer type.\n+            // FIXME (#5527): Should be an associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn zero() -> $T { 0 }\n+\n+            /// Returns the `1` value of this integer type.\n+            // FIXME (#5527): Should be an associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn one() -> $T { 1 }\n+\n+            /// Returns the smallest value that can be represented by this integer type.\n+            // FIXME (#5527): Should be and associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n+\n+            /// Returns the largest value that can be represented by this integer type.\n+            // FIXME (#5527): Should be and associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn max_value() -> $T { let min: $T = <$T>::min_value(); !min }\n+\n+            /// Returns the number of ones in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b01001100u8;\n+            ///\n+            /// assert_eq!(n.count_ones(), 3);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n+\n+            /// Returns the number of zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b01001100u8;\n+            ///\n+            /// assert_eq!(n.count_zeros(), 5);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+\n+            /// Returns the number of leading zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b0101000u16;\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 10);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn leading_zeros(self) -> u32 { (self as $UnsignedT).leading_zeros() }\n+\n+            /// Returns the number of trailing zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b0101000u16;\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 3);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 { (self as $UnsignedT).trailing_zeros() }\n+\n+            /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n+            /// the truncated bits to the end of the resulting integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0x3456789ABCDEF012u64;\n+            ///\n+            /// assert_eq!(n.rotate_left(12), m);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn rotate_left(self, n: u32) -> $T { (self as $UnsignedT).rotate_left(n) as $T }\n+\n+            /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n+            /// the truncated bits to the beginning of the resulting integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0xDEF0123456789ABCu64;\n+            ///\n+            /// assert_eq!(n.rotate_right(12), m);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn rotate_right(self, n: u32) -> $T { (self as $UnsignedT).rotate_right(n) as $T }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0xEFCDAB8967452301u64;\n+            ///\n+            /// assert_eq!(n.swap_bytes(), m);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn swap_bytes(self) -> $T { (self as $UnsignedT).swap_bytes() as $T }\n+\n+            /// Convert an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(Int::from_be(n), n)\n+            /// } else {\n+            ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_be(x: $T) -> $T {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n+\n+            /// Convert an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(Int::from_le(n), n)\n+            /// } else {\n+            ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_le(x: $T) -> $T {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            }\n+\n+            /// Convert `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_be(self) -> $T { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            }\n+\n+            /// Convert `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_le(self) -> $T {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n+\n+            /// Checked integer addition. Computes `self + other`, returning `None` if\n+            /// overflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+            /// assert_eq!(6u16.checked_add(65530), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer subtraction. Computes `self - other`, returning `None`\n+            /// if underflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+            /// assert_eq!((-128i8).checked_sub(1), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer multiplication. Computes `self * other`, returning\n+            /// `None` if underflow or overflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(5u8.checked_mul(51), Some(255));\n+            /// assert_eq!(5u8.checked_mul(52), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer division. Computes `self / other`, returning `None` if\n+            /// `other == 0` or the operation results in underflow or overflow.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+            /// assert_eq!((-128i8).checked_div(-1), None);\n+            /// assert_eq!((1i8).checked_div(0), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0   => None,\n+                   -1 if self == <$T>::min_value()\n+                        => None,\n+                    v   => Some(self / v),\n+                }\n+            }\n+\n+            /// Saturating integer addition. Computes `self + other`, saturating at\n+            /// the numeric bounds instead of overflowing.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_add(self, other: $T) -> $T {\n+                match self.checked_add(other) {\n+                    Some(x)                       => x,\n+                    None if other >= <$T>::zero() => <$T>::max_value(),\n+                    None                          => <$T>::min_value(),\n+                }\n+            }\n+\n+            /// Saturating integer subtraction. Computes `self - other`, saturating at\n+            /// the numeric bounds instead of overflowing.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_sub(self, other: $T) -> $T {\n+                match self.checked_sub(other) {\n+                    Some(x)                      => x,\n+                    None if other >= <$T>::zero() => <$T>::min_value(),\n+                    None                          => <$T>::max_value(),\n+                }\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(2.pow(4), 16);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn pow(self, mut exp: u32) -> $T {\n+                let mut base = self;\n+                let mut acc = <$T>::one();\n+\n+                let mut prev_base = self;\n+                let mut base_oflo = false;\n+                while exp > 0 {\n+                    if (exp & 1) == 1 {\n+                        if base_oflo {\n+                            // ensure overflow occurs in the same manner it\n+                            // would have otherwise (i.e. signal any exception\n+                            // it would have otherwise).\n+                            acc = acc * (prev_base * prev_base);\n+                        } else {\n+                            acc = acc * base;\n+                        }\n+                    }\n+                    prev_base = base;\n+                    let (new_base, new_base_oflo) = base.overflowing_mul(base);\n+                    base = new_base;\n+                    base_oflo = new_base_oflo;\n+                    exp /= 2;\n+                }\n+                acc\n+            }\n+\n+            /// Computes the absolute value of `self`. `Int::min_value()` will be\n+            /// returned if the number is `Int::min_value()`.\n+            #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n+            #[inline]\n+            pub fn abs(self) -> $T {\n+                if self.is_negative() { -self } else { self }\n+            }\n+\n+            /// Returns a number representing sign of `self`.\n+            ///\n+            /// - `0` if the number is zero\n+            /// - `1` if the number is positive\n+            /// - `-1` if the number is negative\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn signum(self) -> $T {\n+                match self {\n+                    n if n > 0 =>  1,\n+                    0          =>  0,\n+                    _          => -1,\n+                }\n+            }\n+\n+            /// Returns `true` if `self` is positive and `false` if the number\n+            /// is zero or negative.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_positive(self) -> bool { self > 0 }\n+\n+            /// Returns `true` if `self` is negative and `false` if the number\n+            /// is zero or positive.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_negative(self) -> bool { self < 0 }\n+        }\n+    }\n+\n+    #[lang = \"i8\"]\n+    impl i8 {\n+        int_impl! { i8 = i8, u8, 8,\n+            intrinsics::i8_add_with_overflow,\n+            intrinsics::i8_sub_with_overflow,\n+            intrinsics::i8_mul_with_overflow }\n+    }\n+\n+    #[lang = \"i16\"]\n+    impl i16 {\n+        int_impl! { i16 = i16, u16, 16,\n+            intrinsics::i16_add_with_overflow,\n+            intrinsics::i16_sub_with_overflow,\n+            intrinsics::i16_mul_with_overflow }\n+    }\n+\n+    #[lang = \"i32\"]\n+    impl i32 {\n+        int_impl! { i32 = i32, u32, 32,\n+            intrinsics::i32_add_with_overflow,\n+            intrinsics::i32_sub_with_overflow,\n+            intrinsics::i32_mul_with_overflow }\n+    }\n+\n+    #[lang = \"i64\"]\n+    impl i64 {\n+        int_impl! { i64 = i64, u64, 64,\n+            intrinsics::i64_add_with_overflow,\n+            intrinsics::i64_sub_with_overflow,\n+            intrinsics::i64_mul_with_overflow }\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[lang = \"isize\"]\n+    impl isize {\n+        int_impl! { int = i32, u32, 32,\n+            intrinsics::i32_add_with_overflow,\n+            intrinsics::i32_sub_with_overflow,\n+            intrinsics::i32_mul_with_overflow }\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[lang = \"isize\"]\n+    impl isize {\n+        int_impl! { int = i64, u64, 64,\n+            intrinsics::i64_add_with_overflow,\n+            intrinsics::i64_sub_with_overflow,\n+            intrinsics::i64_mul_with_overflow }\n+    }\n+\n+    // `Int` + `UnsignedInt` implemented for signed integers\n+    macro_rules! uint_impl {\n+        ($T:ty = $ActualT:ty, $BITS:expr,\n+         $ctpop:path,\n+         $ctlz:path,\n+         $cttz:path,\n+         $bswap:path,\n+         $add_with_overflow:path,\n+         $sub_with_overflow:path,\n+         $mul_with_overflow:path) => {\n+            /// Returns the `0` value of this integer type.\n+            // FIXME (#5527): Should be an associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn zero() -> $T { 0 }\n+\n+            /// Returns the `1` value of this integer type.\n+            // FIXME (#5527): Should be an associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn one() -> $T { 1 }\n+\n+            /// Returns the smallest value that can be represented by this integer type.\n+            // FIXME (#5527): Should be and associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn min_value() -> $T { 0 }\n+\n+            /// Returns the largest value that can be represented by this integer type.\n+            // FIXME (#5527): Should be and associated constant\n+            #[unstable(feature = \"core\",\n+                       reason = \"unsure about its place in the world\")]\n+            #[inline]\n+            pub fn max_value() -> $T { -1 }\n+\n+            /// Returns the number of ones in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b01001100u8;\n+            ///\n+            /// assert_eq!(n.count_ones(), 3);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn count_ones(self) -> u32 { unsafe { $ctpop(self as $ActualT) as u32 } }\n+\n+            /// Returns the number of zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b01001100u8;\n+            ///\n+            /// assert_eq!(n.count_zeros(), 5);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn count_zeros(self) -> u32 {\n+                (!self).count_ones()\n+            }\n+\n+            /// Returns the number of leading zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b0101000u16;\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 10);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn leading_zeros(self) -> u32 { unsafe { $ctlz(self as $ActualT) as u32 } }\n+\n+            /// Returns the number of trailing zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0b0101000u16;\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 3);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn trailing_zeros(self) -> u32 { unsafe { $cttz(self as $ActualT) as u32 } }\n+\n+            /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n+            /// the truncated bits to the end of the resulting integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0x3456789ABCDEF012u64;\n+            ///\n+            /// assert_eq!(n.rotate_left(12), m);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn rotate_left(self, n: u32) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self << n) | (self >> (($BITS - n) % $BITS))\n+            }\n+\n+            /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n+            /// the truncated bits to the beginning of the resulting integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0xDEF0123456789ABCu64;\n+            ///\n+            /// assert_eq!(n.rotate_right(12), m);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn rotate_right(self, n: u32) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self >> n) | (self << (($BITS - n) % $BITS))\n+            }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            /// let m = 0xEFCDAB8967452301u64;\n+            ///\n+            /// assert_eq!(n.swap_bytes(), m);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn swap_bytes(self) -> $T { unsafe { $bswap(self as $ActualT) as $T } }\n+\n+            /// Convert an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(Int::from_be(n), n)\n+            /// } else {\n+            ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_be(x: $T) -> $T {\n+                if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+            }\n+\n+            /// Convert an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(Int::from_le(n), n)\n+            /// } else {\n+            ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn from_le(x: $T) -> $T {\n+                if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+            }\n+\n+            /// Convert `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_be(self) -> $T { // or not to be?\n+                if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+            }\n+\n+            /// Convert `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// let n = 0x0123456789ABCDEFu64;\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn to_le(self) -> $T {\n+                if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+            }\n+\n+            /// Checked integer addition. Computes `self + other`, returning `None` if\n+            /// overflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(5u16.checked_add(65530), Some(65535));\n+            /// assert_eq!(6u16.checked_add(65530), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_add(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer subtraction. Computes `self - other`, returning `None`\n+            /// if underflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n+            /// assert_eq!((-128i8).checked_sub(1), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_sub(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer multiplication. Computes `self * other`, returning\n+            /// `None` if underflow or overflow occurred.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(5u8.checked_mul(51), Some(255));\n+            /// assert_eq!(5u8.checked_mul(52), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_mul(self, other: $T) -> Option<$T> {\n+                checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+            }\n+\n+            /// Checked integer division. Computes `self / other`, returning `None` if\n+            /// `other == 0` or the operation results in underflow or overflow.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!((-127i8).checked_div(-1), Some(127));\n+            /// assert_eq!((-128i8).checked_div(-1), None);\n+            /// assert_eq!((1i8).checked_div(0), None);\n+            /// ```\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn checked_div(self, v: $T) -> Option<$T> {\n+                match v {\n+                    0 => None,\n+                    v => Some(self / v),\n+                }\n+            }\n+\n+            /// Saturating integer addition. Computes `self + other`, saturating at\n+            /// the numeric bounds instead of overflowing.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_add(self, other: $T) -> $T {\n+                match self.checked_add(other) {\n+                    Some(x)                       => x,\n+                    None if other >= <$T>::zero() => <$T>::max_value(),\n+                    None                          => <$T>::min_value(),\n+                }\n+            }\n+\n+            /// Saturating integer subtraction. Computes `self - other`, saturating at\n+            /// the numeric bounds instead of overflowing.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn saturating_sub(self, other: $T) -> $T {\n+                match self.checked_sub(other) {\n+                    Some(x)                       => x,\n+                    None if other >= <$T>::zero() => <$T>::min_value(),\n+                    None                          => <$T>::max_value(),\n+                }\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```rust\n+            /// use std::num::Int;\n+            ///\n+            /// assert_eq!(2.pow(4), 16);\n+            /// ```\n+            #[unstable(feature = \"core\",\n+                       reason = \"pending integer conventions\")]\n+            #[inline]\n+            pub fn pow(self, mut exp: u32) -> $T {\n+                let mut base = self;\n+                let mut acc = <$T>::one();\n+\n+                let mut prev_base = self;\n+                let mut base_oflo = false;\n+                while exp > 0 {\n+                    if (exp & 1) == 1 {\n+                        if base_oflo {\n+                            // ensure overflow occurs in the same manner it\n+                            // would have otherwise (i.e. signal any exception\n+                            // it would have otherwise).\n+                            acc = acc * (prev_base * prev_base);\n+                        } else {\n+                            acc = acc * base;\n+                        }\n+                    }\n+                    prev_base = base;\n+                    let (new_base, new_base_oflo) = base.overflowing_mul(base);\n+                    base = new_base;\n+                    base_oflo = new_base_oflo;\n+                    exp /= 2;\n+                }\n+                acc\n+            }\n+\n+            /// Returns `true` iff `self == 2^k` for some `k`.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn is_power_of_two(self) -> bool {\n+                (self.wrapping_sub(<$T>::one())) & self == <$T>::zero() && !(self == <$T>::zero())\n+            }\n+\n+            /// Returns the smallest power of two greater than or equal to `self`.\n+            /// Unspecified behavior on overflow.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[inline]\n+            pub fn next_power_of_two(self) -> $T {\n+                let bits = size_of::<$T>() * 8;\n+                let one: $T = <$T>::one();\n+                one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n+            }\n+\n+            /// Returns the smallest power of two greater than or equal to `n`. If the\n+            /// next power of two is greater than the type's maximum value, `None` is\n+            /// returned, otherwise the power of two is wrapped in `Some`.\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            pub fn checked_next_power_of_two(self) -> Option<$T> {\n+                let npot = self.next_power_of_two();\n+                if npot >= self {\n+                    Some(npot)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Swapping a single byte is a no-op. This is marked as `unsafe` for\n+    /// consistency with the other `bswap` intrinsics.\n+    unsafe fn bswap8(x: u8) -> u8 { x }\n+\n+    #[lang = \"u8\"]\n+    impl u8 {\n+        uint_impl! { u8 = u8, 8,\n+            intrinsics::ctpop8,\n+            intrinsics::ctlz8,\n+            intrinsics::cttz8,\n+            bswap8,\n+            intrinsics::u8_add_with_overflow,\n+            intrinsics::u8_sub_with_overflow,\n+            intrinsics::u8_mul_with_overflow }\n+    }\n+\n+    #[lang = \"u16\"]\n+    impl u16 {\n+        uint_impl! { u16 = u16, 16,\n+            intrinsics::ctpop16,\n+            intrinsics::ctlz16,\n+            intrinsics::cttz16,\n+            intrinsics::bswap16,\n+            intrinsics::u16_add_with_overflow,\n+            intrinsics::u16_sub_with_overflow,\n+            intrinsics::u16_mul_with_overflow }\n+    }\n+\n+    #[lang = \"u32\"]\n+    impl u32 {\n+        uint_impl! { u32 = u32, 32,\n+            intrinsics::ctpop32,\n+            intrinsics::ctlz32,\n+            intrinsics::cttz32,\n+            intrinsics::bswap32,\n+            intrinsics::u32_add_with_overflow,\n+            intrinsics::u32_sub_with_overflow,\n+            intrinsics::u32_mul_with_overflow }\n+    }\n+\n+\n+    #[lang = \"u64\"]\n+    impl u64 {\n+        uint_impl! { u64 = u64, 64,\n+            intrinsics::ctpop64,\n+            intrinsics::ctlz64,\n+            intrinsics::cttz64,\n+            intrinsics::bswap64,\n+            intrinsics::u64_add_with_overflow,\n+            intrinsics::u64_sub_with_overflow,\n+            intrinsics::u64_mul_with_overflow }\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[lang = \"usize\"]\n+    impl usize {\n+        uint_impl! { uint = u32, 32,\n+            intrinsics::ctpop32,\n+            intrinsics::ctlz32,\n+            intrinsics::cttz32,\n+            intrinsics::bswap32,\n+            intrinsics::u32_add_with_overflow,\n+            intrinsics::u32_sub_with_overflow,\n+            intrinsics::u32_mul_with_overflow }\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[lang = \"usize\"]\n+    impl usize {\n+        uint_impl! { uint = u64, 64,\n+            intrinsics::ctpop64,\n+            intrinsics::ctlz64,\n+            intrinsics::cttz64,\n+            intrinsics::bswap64,\n+            intrinsics::u64_add_with_overflow,\n+            intrinsics::u64_sub_with_overflow,\n+            intrinsics::u64_mul_with_overflow }\n+    }\n+}\n+\n /// A generic trait for converting a value to a number.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {"}, {"sha": "47bc2f5a11348910acac455288a94fdfee8f71fb", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -123,7 +123,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n \n-        let mut running_total = 0;\n+        let mut running_total = 0_usize;\n \n         // we convert the list from individual weights to cumulative\n         // weights so we can binary search. This *could* drop elements"}, {"sha": "6f8151c2b9f0a09f2a8cd261854c0069783a2871", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -23,6 +23,7 @@ use hash::{Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n+#[cfg(stage0)]\n use num::{Int, UnsignedInt};\n use ops::{Deref, FnMut, Index, IndexMut};\n use option::Option::{self, Some, None};"}, {"sha": "cba46859f348e5d1bd3a983e9bf1003089b08756", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -19,6 +19,7 @@ use iter::{Iterator, IteratorExt, ExactSizeIterator, count};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;\n+#[cfg(stage0)]\n use num::{Int, UnsignedInt};\n use num::wrapping::{OverflowingOps, WrappingOps};\n use ops::{Deref, DerefMut, Drop};"}, {"sha": "599f3f02a8b76c93e20fdaa3d7519f05b57d0df0", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=3ff84fc5fdd9509fc3ee4595fd76aa31d4815b2a", "patch": "@@ -23,7 +23,10 @@ use marker::Copy;\n use clone::Clone;\n use cmp::{PartialOrd, PartialEq};\n \n+#[cfg(stage0)]\n pub use core::num::{Int, SignedInt, UnsignedInt};\n+#[cfg(not(stage0))]\n+pub use core::num::{Int, SignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};"}]}