{"sha": "09ae370c62de136a7f474ceb64a4faa1a0b15906", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YWUzNzBjNjJkZTEzNmE3ZjQ3NGNlYjY0YTRmYWExYTBiMTU5MDY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-27T01:28:36Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-27T01:28:36Z"}, "message": "convert std::arc types to camelcase", "tree": {"sha": "ef6006447a9c2269a0debe31dd2aac9daff20c88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef6006447a9c2269a0debe31dd2aac9daff20c88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09ae370c62de136a7f474ceb64a4faa1a0b15906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09ae370c62de136a7f474ceb64a4faa1a0b15906", "html_url": "https://github.com/rust-lang/rust/commit/09ae370c62de136a7f474ceb64a4faa1a0b15906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09ae370c62de136a7f474ceb64a4faa1a0b15906/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dadee1ee72ae2c12ba6ead0bdb274afe444ceda", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dadee1ee72ae2c12ba6ead0bdb274afe444ceda", "html_url": "https://github.com/rust-lang/rust/commit/5dadee1ee72ae2c12ba6ead0bdb274afe444ceda"}], "stats": {"total": 156, "additions": 79, "deletions": 77}, "files": [{"sha": "75fdf0c3457bd04692c4e7b3da8c2f847695da4c", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 78, "deletions": 77, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/09ae370c62de136a7f474ceb64a4faa1a0b15906/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09ae370c62de136a7f474ceb64a4faa1a0b15906/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=09ae370c62de136a7f474ceb64a4faa1a0b15906", "patch": "@@ -13,15 +13,16 @@ import sync;\n import sync::{Mutex,  mutex,  mutex_with_condvars,\n               RWlock, rwlock, rwlock_with_condvars};\n \n-export arc, clone, get;\n-export condvar, mutex_arc, mutex_arc_with_condvars, unwrap_mutex_arc;\n-export rw_arc, rw_arc_with_condvars, rw_write_mode, rw_read_mode;\n+export ARC, arc, clone, get;\n+export Condvar;\n+export MutexARC, mutex_arc, mutex_arc_with_condvars, unwrap_mutex_arc;\n+export RWARC, rw_arc, rw_arc_with_condvars, RWWriteMode, RWReadMode;\n export unwrap_rw_arc;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n-struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::Condvar; }\n+struct Condvar { is_mutex: bool; failed: &mut bool; cond: &sync::Condvar; }\n \n-impl &condvar {\n+impl &Condvar {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n     #[inline(always)]\n     fn wait() { self.wait_on(0) }\n@@ -69,18 +70,18 @@ impl &condvar {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-struct arc<T: const send> { x: SharedMutableState<T>; }\n+struct ARC<T: const send> { x: SharedMutableState<T>; }\n \n /// Create an atomically reference counted wrapper.\n-fn arc<T: const send>(+data: T) -> arc<T> {\n-    arc { x: unsafe { shared_mutable_state(data) } }\n+fn arc<T: const send>(+data: T) -> ARC<T> {\n+    ARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-fn get<T: const send>(rc: &arc<T>) -> &T {\n+fn get<T: const send>(rc: &ARC<T>) -> &T {\n     unsafe { get_shared_immutable_state(&rc.x) }\n }\n \n@@ -91,8 +92,8 @@ fn get<T: const send>(rc: &arc<T>) -> &T {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n-    arc { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n+fn clone<T: const send>(rc: &ARC<T>) -> ARC<T> {\n+    ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n }\n \n /**\n@@ -104,8 +105,8 @@ fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n  * unwrap from a task that holds another reference to the same ARC; it is\n  * guaranteed to deadlock.\n  */\n-fn unwrap<T: const send>(+rc: arc<T>) -> T {\n-    let arc { x: x } = rc;\n+fn unwrap<T: const send>(+rc: ARC<T>) -> T {\n+    let ARC { x: x } = rc;\n     unsafe { unwrap_shared_mutable_state(x) }\n }\n \n@@ -114,32 +115,32 @@ fn unwrap<T: const send>(+rc: arc<T>) -> T {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct mutex_arc_inner<T: send> { lock: Mutex; failed: bool; data: T; }\n+struct MutexARCInner<T: send> { lock: Mutex; failed: bool; data: T; }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct mutex_arc<T: send> { x: SharedMutableState<mutex_arc_inner<T>>; }\n+struct MutexARC<T: send> { x: SharedMutableState<MutexARCInner<T>>; }\n \n /// Create a mutex-protected ARC with the supplied data.\n-fn mutex_arc<T: send>(+user_data: T) -> mutex_arc<T> {\n+fn mutex_arc<T: send>(+user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n fn mutex_arc_with_condvars<T: send>(+user_data: T,\n-                                    num_condvars: uint) -> mutex_arc<T> {\n+                                    num_condvars: uint) -> MutexARC<T> {\n     let data =\n-        mutex_arc_inner { lock: mutex_with_condvars(num_condvars),\n+        MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n-    mutex_arc { x: unsafe { shared_mutable_state(data) } }\n+    MutexARC { x: unsafe { shared_mutable_state(data) } }\n }\n \n-impl<T: send> &mutex_arc<T> {\n+impl<T: send> &MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n-    fn clone() -> mutex_arc<T> {\n+    fn clone() -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n         // count would be exactly the same as the shared state's.\n-        mutex_arc { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+        MutexARC { x: unsafe { clone_shared_mutable_state(&self.x) } }\n     }\n \n     /**\n@@ -172,19 +173,19 @@ impl<T: send> &mutex_arc<T> {\n         // unsafe. See borrow_rwlock, far below.\n         do (&state.lock).lock {\n             check_poison(true, state.failed);\n-            let _z = poison_on_fail(&mut state.failed);\n+            let _z = PoisonOnFail(&mut state.failed);\n             blk(&mut state.data)\n         }\n     }\n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n-    unsafe fn access_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n+    unsafe fn access_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do (&state.lock).lock_cond |cond| {\n             check_poison(true, state.failed);\n-            let _z = poison_on_fail(&mut state.failed);\n+            let _z = PoisonOnFail(&mut state.failed);\n             blk(&mut state.data,\n-                &condvar { is_mutex: true, failed: &mut state.failed,\n+                &Condvar { is_mutex: true, failed: &mut state.failed,\n                            cond: cond })\n         }\n     }\n@@ -197,12 +198,12 @@ impl<T: send> &mutex_arc<T> {\n  * Will additionally fail if another task has failed while accessing the arc.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_mutex_arc<T: send>(+arc: mutex_arc<T>) -> T {\n-    let mutex_arc { x: x } = arc;\n+fn unwrap_mutex_arc<T: send>(+arc: MutexARC<T>) -> T {\n+    let MutexARC { x: x } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n-    let mutex_arc_inner { failed: failed, data: data, _ } = inner;\n+    let MutexARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n-        fail ~\"Can't unwrap poisoned mutex_arc - another task failed inside!\"\n+        fail ~\"Can't unwrap poisoned MutexARC - another task failed inside!\"\n     }\n     data\n }\n@@ -213,15 +214,15 @@ fn unwrap_mutex_arc<T: send>(+arc: mutex_arc<T>) -> T {\n fn check_poison(is_mutex: bool, failed: bool) {\n     if failed {\n         if is_mutex {\n-            fail ~\"Poisoned mutex_arc - another task failed inside!\";\n+            fail ~\"Poisoned MutexARC - another task failed inside!\";\n         } else {\n             fail ~\"Poisoned rw_arc - another task failed inside!\";\n         }\n     }\n }\n \n #[doc(hidden)]\n-struct poison_on_fail {\n+struct PoisonOnFail {\n     failed: &mut bool;\n     new(failed: &mut bool) { self.failed = failed; }\n     drop {\n@@ -235,39 +236,39 @@ struct poison_on_fail {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct rw_arc_inner<T: const send> { lock: RWlock; failed: bool; data: T; }\n+struct RWARCInner<T: const send> { lock: RWlock; failed: bool; data: T; }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n  *\n  * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n  */\n-struct rw_arc<T: const send> {\n-    x: SharedMutableState<rw_arc_inner<T>>;\n+struct RWARC<T: const send> {\n+    x: SharedMutableState<RWARCInner<T>>;\n     mut cant_nest: ();\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-fn rw_arc<T: const send>(+user_data: T) -> rw_arc<T> {\n+fn rw_arc<T: const send>(+user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n fn rw_arc_with_condvars<T: const send>(+user_data: T,\n-                                       num_condvars: uint) -> rw_arc<T> {\n+                                       num_condvars: uint) -> RWARC<T> {\n     let data =\n-        rw_arc_inner { lock: rwlock_with_condvars(num_condvars),\n-                       failed: false, data: user_data };\n-    rw_arc { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n+        RWARCInner { lock: rwlock_with_condvars(num_condvars),\n+                     failed: false, data: user_data };\n+    RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n }\n \n-impl<T: const send> &rw_arc<T> {\n+impl<T: const send> &RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n-    fn clone() -> rw_arc<T> {\n-        rw_arc { x: unsafe { clone_shared_mutable_state(&self.x) },\n-                 cant_nest: () }\n+    fn clone() -> RWARC<T> {\n+        RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n+                cant_nest: () }\n     }\n \n     /**\n@@ -277,27 +278,27 @@ impl<T: const send> &rw_arc<T> {\n      * # Failure\n      *\n      * Failing while inside the ARC will unlock the ARC while unwinding, so\n-     * that other tasks won't block forever. As mutex_arc.access, it will also\n+     * that other tasks won't block forever. As MutexARC.access, it will also\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write {\n             check_poison(false, state.failed);\n-            let _z = poison_on_fail(&mut state.failed);\n+            let _z = PoisonOnFail(&mut state.failed);\n             blk(&mut state.data)\n         }\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n+    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write_cond |cond| {\n             check_poison(false, state.failed);\n-            let _z = poison_on_fail(&mut state.failed);\n+            let _z = PoisonOnFail(&mut state.failed);\n             blk(&mut state.data,\n-                &condvar { is_mutex: false, failed: &mut state.failed,\n+                &Condvar { is_mutex: false, failed: &mut state.failed,\n                            cond: cond })\n         }\n     }\n@@ -320,9 +321,9 @@ impl<T: const send> &rw_arc<T> {\n \n     /**\n      * As write(), but with the ability to atomically 'downgrade' the lock.\n-     * See sync::rwlock.write_downgrade(). The rw_write_mode token must be\n-     * used to obtain the &mut T, and can be transformed into a rw_read_mode\n-     * token by calling downgrade(), after which a &T can be obtained instead.\n+     * See sync::rwlock.write_downgrade(). The RWWriteMode token must be used\n+     * to obtain the &mut T, and can be transformed into a RWReadMode token by\n+     * calling downgrade(), after which a &T can be obtained instead.\n      * ~~~\n      * do arc.write_downgrade |write_mode| {\n      *     do (&write_mode).write_cond |state, condvar| {\n@@ -335,20 +336,20 @@ impl<T: const send> &rw_arc<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(+rw_write_mode<T>) -> U) -> U {\n+    fn write_downgrade<U>(blk: fn(+RWWriteMode<T>) -> U) -> U {\n         let state = unsafe { get_shared_mutable_state(&self.x) };\n         do borrow_rwlock(state).write_downgrade |write_mode| {\n             check_poison(false, state.failed);\n-            blk(rw_write_mode((&mut state.data, write_mode,\n-                               poison_on_fail(&mut state.failed))))\n+            blk(RWWriteMode((&mut state.data, write_mode,\n+                              PoisonOnFail(&mut state.failed))))\n         }\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(+token: rw_write_mode/&a<T>) -> rw_read_mode/&a<T> {\n+    fn downgrade(+token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let rw_write_mode((data, t, _poison)) = token;\n+        let RWWriteMode((data, t, _poison)) = token;\n         // Let readers in\n         let new_token = (&state.lock).downgrade(t);\n         // Whatever region the input reference had, it will be safe to use\n@@ -358,7 +359,7 @@ impl<T: const send> &rw_arc<T> {\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n         assert ptr::ref_eq(&state.data, new_data);\n         // Produce new token\n-        rw_read_mode((new_data, new_token))\n+        RWReadMode((new_data, new_token))\n     }\n }\n \n@@ -370,12 +371,12 @@ impl<T: const send> &rw_arc<T> {\n  * in write mode.\n  */\n // FIXME(#2585) make this a by-move method on the arc\n-fn unwrap_rw_arc<T: const send>(+arc: rw_arc<T>) -> T {\n-    let rw_arc { x: x, _ } = arc;\n+fn unwrap_rw_arc<T: const send>(+arc: RWARC<T>) -> T {\n+    let RWARC { x: x, _ } = arc;\n     let inner = unsafe { unwrap_shared_mutable_state(x) };\n-    let rw_arc_inner { failed: failed, data: data, _ } = inner;\n+    let RWARCInner { failed: failed, data: data, _ } = inner;\n     if failed {\n-        fail ~\"Can't unwrap poisoned rw_arc - another task failed inside!\"\n+        fail ~\"Can't unwrap poisoned RWARC - another task failed inside!\"\n     }\n     data\n }\n@@ -384,35 +385,35 @@ fn unwrap_rw_arc<T: const send>(+arc: rw_arc<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: const send>(state: &r/mut rw_arc_inner<T>) -> &r/RWlock {\n+fn borrow_rwlock<T: const send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n     unsafe { unsafe::transmute_immut(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n \n-/// The \"write permission\" token used for rw_arc.write_downgrade().\n-enum rw_write_mode<T: const send> =\n-    (&mut T, sync::RWlockWriteMode, poison_on_fail);\n-/// The \"read permission\" token used for rw_arc.write_downgrade().\n-enum rw_read_mode<T:const send> = (&T, sync::RWlockReadMode);\n+/// The \"write permission\" token used for RWARC.write_downgrade().\n+enum RWWriteMode<T: const send> =\n+    (&mut T, sync::RWlockWriteMode, PoisonOnFail);\n+/// The \"read permission\" token used for RWARC.write_downgrade().\n+enum RWReadMode<T:const send> = (&T, sync::RWlockReadMode);\n \n-impl<T: const send> &rw_write_mode<T> {\n-    /// Access the pre-downgrade rw_arc in write mode.\n+impl<T: const send> &RWWriteMode<T> {\n+    /// Access the pre-downgrade RWARC in write mode.\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n         match *self {\n-            rw_write_mode((data, ref token, _)) => {\n+            RWWriteMode((data, ref token, _)) => {\n                 do token.write {\n                     blk(data)\n                 }\n             }\n         }\n     }\n-    /// Access the pre-downgrade rw_arc in write mode with a condvar.\n-    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n+    /// Access the pre-downgrade RWARC in write mode with a condvar.\n+    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         match *self {\n-            rw_write_mode((data, ref token, ref poison)) => {\n+            RWWriteMode((data, ref token, ref poison)) => {\n                 do token.write_cond |cond| {\n-                    let cvar = condvar {\n+                    let cvar = Condvar {\n                         is_mutex: false, failed: poison.failed,\n                         cond: cond };\n                     blk(data, &cvar)\n@@ -422,11 +423,11 @@ impl<T: const send> &rw_write_mode<T> {\n     }\n }\n \n-impl<T: const send> &rw_read_mode<T> {\n+impl<T: const send> &RWReadMode<T> {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn(x: &T) -> U) -> U {\n         match *self {\n-            rw_read_mode((data, ref token)) => {\n+            RWReadMode((data, ref token)) => {\n                 do token.read { blk(data) }\n             }\n         }"}, {"sha": "0dd139250fb41261a031a8039d42332db51d0981", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09ae370c62de136a7f474ceb64a4faa1a0b15906/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/09ae370c62de136a7f474ceb64a4faa1a0b15906/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=09ae370c62de136a7f474ceb64a4faa1a0b15906", "patch": "@@ -52,6 +52,7 @@ mod cell;\n \n #[warn(non_camel_case_types)]\n mod sync;\n+#[warn(non_camel_case_types)]\n mod arc;\n mod comm;\n "}]}