{"sha": "e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOGE4OWQwYjBmY2MzYjJmNWNhZDYwMGQ3YjNhMTZmYWViOTQyNDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-09T19:02:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T20:23:57Z"}, "message": "Fix usage of libuv for windows", "tree": {"sha": "68f474d86ebf9a96a47259aaf2f3626a02d70eb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f474d86ebf9a96a47259aaf2f3626a02d70eb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "html_url": "https://github.com/rust-lang/rust/commit/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fdd69d3e197cef64a4f29faff5d42a95010647", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5fdd69d3e197cef64a4f29faff5d42a95010647", "html_url": "https://github.com/rust-lang/rust/commit/c5fdd69d3e197cef64a4f29faff5d42a95010647"}], "stats": {"total": 131, "additions": 89, "deletions": 42}, "files": [{"sha": "7e997334cecaf1b42baebddc4a17905603b8c9b7", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -4,7 +4,7 @@\n \tbranch = master\n [submodule \"src/libuv\"]\n \tpath = src/libuv\n-\turl = https://github.com/joyent/libuv.git\n+\turl = https://github.com/alexcrichton/libuv.git\n \tbranch = master\n [submodule \"src/gyp\"]\n \tpath = src/gyp"}, {"sha": "32c9b6c3d172999f6efffb262b81ca3624840784", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -883,6 +883,7 @@ mod test {\n     }\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10102) server never sees second packet\n     fn test_udp_twice() {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();"}, {"sha": "c123f916ef23f73973dd514419b8992268f4f26b", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -251,6 +251,7 @@ mod tests {\n     use super::super::local_loop;\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn connect_err() {\n         match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n             Ok(*) => fail!(),\n@@ -259,6 +260,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn bind_err() {\n         match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n             Ok(*) => fail!(),\n@@ -267,6 +269,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn bind() {\n         let p = next_test_unix().to_c_str();\n         match PipeListener::bind(local_loop(), &p) {\n@@ -276,13 +279,15 @@ mod tests {\n     }\n \n     #[test] #[should_fail]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn bind_fail() {\n         let p = next_test_unix().to_c_str();\n         let _w = PipeListener::bind(local_loop(), &p).unwrap();\n         fail!();\n     }\n \n     #[test]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn connect() {\n         let path = next_test_unix();\n         let path2 = path.clone();\n@@ -308,6 +313,7 @@ mod tests {\n     }\n \n     #[test] #[should_fail]\n+    #[ignore(cfg(windows))] // FIXME(#10386): how windows pipes work\n     fn connect_fail() {\n         let path = next_test_unix();\n         let path2 = path.clone();"}, {"sha": "7e75515972cb8893a195286b68aaaecd9d8b1e3f", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -232,6 +232,6 @@ impl Drop for Process {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n         assert!(self.to_wake.is_none());\n-        self.close_async_();\n+        self.close();\n     }\n }"}, {"sha": "da2e1d8837c458e21acda539cd62c79a272d5764", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -30,26 +30,21 @@ pub struct SignalWatcher {\n impl SignalWatcher {\n     pub fn new(loop_: &mut Loop, signum: Signum,\n                channel: SharedChan<Signum>) -> Result<~SignalWatcher, UvError> {\n-        let handle = UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL);\n+        let s = ~SignalWatcher {\n+            handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n+            home: get_handle_to_current_scheduler!(),\n+            channel: channel,\n+            signal: signum,\n+        };\n         assert_eq!(unsafe {\n-            uvll::uv_signal_init(loop_.handle, handle)\n-\n+            uvll::uv_signal_init(loop_.handle, s.handle)\n         }, 0);\n \n-        match unsafe { uvll::uv_signal_start(handle, signal_cb, signum as c_int) } {\n-            0 => {\n-                let s = ~SignalWatcher {\n-                    handle: handle,\n-                    home: get_handle_to_current_scheduler!(),\n-                    channel: channel,\n-                    signal: signum,\n-                };\n-                Ok(s.install())\n-            }\n-            n => {\n-                unsafe { uvll::free_handle(handle) }\n-                Err(UvError(n))\n-            }\n+        match unsafe {\n+            uvll::uv_signal_start(s.handle, signal_cb, signum as c_int)\n+        } {\n+            0 => Ok(s.install()),\n+            n => Err(UvError(n)),\n         }\n \n     }"}, {"sha": "017639903051752f78ebcdce7730e6ad3636b362", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -67,12 +67,27 @@ impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n \n impl RtioTimer for TimerWatcher {\n     fn sleep(&mut self, msecs: u64) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n+        // As with all of the below functions, we must be extra careful when\n+        // destroying the previous action. If the previous action was a channel,\n+        // destroying it could invoke a context switch. For these situtations,\n+        // we must temporarily un-home ourselves, then destroy the action, and\n+        // then re-home again.\n+        let missile = self.fire_homing_missile();\n+        self.stop();\n+        let _missile = match util::replace(&mut self.action, None) {\n+            None => missile, // no need to do a homing dance\n+            Some(action) => {\n+                util::ignore(missile);      // un-home ourself\n+                util::ignore(action);       // destroy the previous action\n+                self.fire_homing_missile()  // re-home ourself\n+            }\n+        };\n \n         // If the descheduling operation unwinds after the timer has been\n         // started, then we need to call stop on the timer.\n         let _f = ForbidUnwind::new(\"timer\");\n \n+        let sched: ~Scheduler = Local::take();\n         do sched.deschedule_running_task_and_then |_sched, task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n@@ -87,6 +102,7 @@ impl RtioTimer for TimerWatcher {\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n+            self.stop();\n             self.start(msecs, 0);\n             util::replace(&mut self.action, Some(SendOnce(chan)))\n         };\n@@ -97,12 +113,11 @@ impl RtioTimer for TimerWatcher {\n     fn period(&mut self, msecs: u64) -> Port<()> {\n         let (port, chan) = stream();\n \n-        let _m = self.fire_homing_missile();\n-\n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n         let _prev_action = {\n             let _m = self.fire_homing_missile();\n+            self.stop();\n             self.start(msecs, msecs);\n             util::replace(&mut self.action, Some(SendMany(chan)))\n         };\n@@ -236,6 +251,18 @@ mod test {\n \n         timer.oneshot(1);\n     }\n+    #[test]\n+    fn reset_doesnt_switch_tasks2() {\n+        // similar test to the one above.\n+        let mut timer = TimerWatcher::new(local_loop());\n+        let timer_port = Cell::new(timer.period(1000));\n+\n+        do spawn {\n+            timer_port.take().try_recv();\n+        }\n+\n+        timer.sleep(1);\n+    }\n \n     #[test]\n     fn sender_goes_away_oneshot() {"}, {"sha": "d3f001f39312f055bb4444f6f8d5b76b91065b91", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -113,6 +113,6 @@ impl HomingIO for TtyWatcher {\n impl Drop for TtyWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.close();\n+        self.close_async_();\n     }\n }"}, {"sha": "c76d03bfe6c33a6985ef182f9b020646b7c1c2ff", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -47,14 +47,14 @@ pub static UNKNOWN: c_int = -4094;\n pub mod errors {\n     use std::libc::c_int;\n \n-    pub static EACCES: c_int = -4093;\n-    pub static ECONNREFUSED: c_int = -4079;\n-    pub static ECONNRESET: c_int = -4078;\n-    pub static ENOTCONN: c_int = -4054;\n-    pub static EPIPE: c_int = -4048;\n-    pub static ECONNABORTED: c_int = -4080;\n-    pub static ECANCELED: c_int = -4082;\n-    pub static EBADF: c_int = -4084;\n+    pub static EACCES: c_int = -4092;\n+    pub static ECONNREFUSED: c_int = -4078;\n+    pub static ECONNRESET: c_int = -4077;\n+    pub static ENOTCONN: c_int = -4053;\n+    pub static EPIPE: c_int = -4047;\n+    pub static ECONNABORTED: c_int = -4079;\n+    pub static ECANCELED: c_int = -4081;\n+    pub static EBADF: c_int = -4083;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -87,19 +87,19 @@ pub static STDIO_WRITABLE_PIPE: c_int = 0x20;\n #[cfg(unix)]\n pub type uv_buf_len_t = libc::size_t;\n #[cfg(windows)]\n-pub type uv_buf_len_t = u32;\n+pub type uv_buf_len_t = libc::c_ulong;\n \n // see libuv/include/uv-unix.h\n #[cfg(unix)]\n pub struct uv_buf_t {\n     base: *u8,\n-    len: libc::size_t,\n+    len: uv_buf_len_t,\n }\n \n // see libuv/include/uv-win.h\n #[cfg(windows)]\n pub struct uv_buf_t {\n-    len: u32,\n+    len: uv_buf_len_t,\n     base: *u8,\n }\n \n@@ -544,7 +544,19 @@ pub unsafe fn guess_handle(handle: c_int) -> c_int {\n \n \n // uv_support is the result of compiling rust_uv.cpp\n+//\n+// Note that this is in a cfg'd block so it doesn't get linked during testing.\n+// There's a bit of a conundrum when testing in that we're actually assuming\n+// that the tests are running in a uv loop, but they were created from the\n+// statically linked uv to the original rustuv crate. When we create the test\n+// executable, on some platforms if we re-link against uv, it actually creates\n+// second copies of everything. We obviously don't want this, so instead of\n+// dying horribly during testing, we allow all of the test rustuv's references\n+// to get resolved to the original rustuv crate.\n #[link_args = \"-luv_support -luv\"]\n+#[cfg(not(test))]\n+extern {}\n+\n extern {\n     fn rust_uv_loop_new() -> *c_void;\n "}, {"sha": "acc2e11f067e6fff714c74ec4facfe3b50a34497", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -33,7 +33,8 @@ use result::{Ok, Err};\n use rt::io::buffered::LineBufferedWriter;\n use rt::rtio::{IoFactory, RtioTTY, RtioFileStream, with_local_io,\n                CloseAsynchronously};\n-use super::{Reader, Writer, io_error, IoError, OtherIoError};\n+use super::{Reader, Writer, io_error, IoError, OtherIoError,\n+            standard_error, EndOfFile};\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -203,6 +204,15 @@ impl Reader for StdReader {\n             File(ref mut file) => file.read(buf).map(|i| i as uint),\n         };\n         match ret {\n+            // When reading a piped stdin, libuv will return 0-length reads when\n+            // stdin reaches EOF. For pretty much all other streams it will\n+            // return an actual EOF error, but apparently for stdin it's a\n+            // little different. Hence, here we convert a 0 length read to an\n+            // end-of-file indicator so the caller knows to stop reading.\n+            Ok(0) => {\n+                io_error::cond.raise(standard_error(EndOfFile));\n+                None\n+            }\n             Ok(amt) => Some(amt as uint),\n             Err(e) => {\n                 io_error::cond.raise(e);"}, {"sha": "b0cf7dee10abb434a6017e249da21c0308717845", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -142,14 +142,10 @@ mod test {\n     fn oneshot_twice() {\n         do run_in_mt_newsched_task {\n             let mut timer = Timer::new().unwrap();\n-            let port1 = timer.oneshot(100000000000);\n+            let port1 = timer.oneshot(10000);\n             let port = timer.oneshot(1);\n             port.recv();\n-            let port1 = Cell::new(port1);\n-            let ret = do task::try {\n-                port1.take().recv();\n-            };\n-            assert!(ret.is_err());\n+            assert_eq!(port1.try_recv(), None);\n         }\n     }\n "}, {"sha": "7ac7e0248b34732e9963cdb8e31f7e612d23d14b", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=e38a89d0b0fcc3b2f5cad600d7b3a16faeb94248", "patch": "@@ -1 +1 @@\n-Subproject commit c6ecf97aafc858c2ad1089fb78da6c586d61d8b6\n+Subproject commit 7ac7e0248b34732e9963cdb8e31f7e612d23d14b"}]}