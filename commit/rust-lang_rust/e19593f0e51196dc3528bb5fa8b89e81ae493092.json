{"sha": "e19593f0e51196dc3528bb5fa8b89e81ae493092", "node_id": "C_kwDOAAsO6NoAKGUxOTU5M2YwZTUxMTk2ZGMzNTI4YmI1ZmE4Yjg5ZTgxYWU0OTMwOTI", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-28T02:53:00Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-12-28T02:53:00Z"}, "message": "rustdoc: Remove some unnecessary `cache` parameters\n\nBased on\nhttps://github.com/rust-lang/rust/pull/80883#issuecomment-774437832.\nThe `tcx` parameters do seem to be used though, so I only removed the\n`cache` parameters.", "tree": {"sha": "1fe5c9e5846bd90b40fd783318bb7b9bf975b1d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fe5c9e5846bd90b40fd783318bb7b9bf975b1d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e19593f0e51196dc3528bb5fa8b89e81ae493092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e19593f0e51196dc3528bb5fa8b89e81ae493092", "html_url": "https://github.com/rust-lang/rust/commit/e19593f0e51196dc3528bb5fa8b89e81ae493092", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e19593f0e51196dc3528bb5fa8b89e81ae493092/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a1abe4c5b6399e62144fc94d236b6f7eefcdf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a1abe4c5b6399e62144fc94d236b6f7eefcdf0", "html_url": "https://github.com/rust-lang/rust/commit/60a1abe4c5b6399e62144fc94d236b6f7eefcdf0"}], "stats": {"total": 37, "additions": 13, "deletions": 24}, "files": [{"sha": "528d48a8d059e45dc25d533011588e1c52fe2429", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e19593f0e51196dc3528bb5fa8b89e81ae493092/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19593f0e51196dc3528bb5fa8b89e81ae493092/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=e19593f0e51196dc3528bb5fa8b89e81ae493092", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, self.tcx, self.cache),\n+                            search_type: get_index_search_type(&item, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }"}, {"sha": "5d4df3ee5ff3ae8441bbaf7d4c820bf4724b6a02", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e19593f0e51196dc3528bb5fa8b89e81ae493092/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e19593f0e51196dc3528bb5fa8b89e81ae493092/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=e19593f0e51196dc3528bb5fa8b89e81ae493092", "patch": "@@ -42,7 +42,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(item, tcx, cache),\n+                search_type: get_index_search_type(item, tcx),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -194,12 +194,11 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n crate fn get_index_search_type<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx, cache),\n-        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx, cache),\n-        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx, cache),\n+        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx),\n+        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx),\n+        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx),\n         _ => return None,\n     };\n \n@@ -254,14 +253,12 @@ crate fn get_real_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n-    cache: &Cache,\n ) {\n     fn insert_ty(\n         res: &mut Vec<TypeWithKind>,\n         tcx: TyCtxt<'_>,\n         ty: Type,\n         mut generics: Vec<TypeWithKind>,\n-        _cache: &Cache,\n     ) {\n         let is_full_generic = ty.is_full_generic();\n \n@@ -350,32 +347,25 @@ crate fn get_real_types<'tcx>(\n                     for param_def in poly_trait.generic_params.iter() {\n                         match &param_def.kind {\n                             clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n-                                get_real_types(\n-                                    generics,\n-                                    ty,\n-                                    tcx,\n-                                    recurse + 1,\n-                                    &mut ty_generics,\n-                                    cache,\n-                                )\n+                                get_real_types(generics, ty, tcx, recurse + 1, &mut ty_generics)\n                             }\n                             _ => {}\n                         }\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n         // Otherwise we check if the trait bounds are \"inlined\" like `T: Option<u32>`...\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::Path { path };\n-                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics, cache);\n+                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics);\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n@@ -386,10 +376,10 @@ crate fn get_real_types<'tcx>(\n         let mut ty_generics = Vec::new();\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n-                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics, cache);\n+                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+        insert_ty(res, tcx, arg.clone(), ty_generics);\n     }\n }\n \n@@ -401,15 +391,14 @@ crate fn get_all_types<'tcx>(\n     generics: &Generics,\n     decl: &FnDecl,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n             continue;\n         }\n         let mut args = Vec::new();\n-        get_real_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n+        get_real_types(generics, &arg.type_, tcx, 0, &mut args);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -423,7 +412,7 @@ crate fn get_all_types<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            get_real_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n+            get_real_types(generics, return_type, tcx, 0, &mut ret_types);\n             if ret_types.is_empty() {\n                 if let Some(kind) =\n                     return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())"}]}