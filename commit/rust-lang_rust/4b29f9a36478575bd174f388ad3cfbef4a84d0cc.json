{"sha": "4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMjlmOWEzNjQ3ODU3NWJkMTc0ZjM4OGFkM2NmYmVmNGE4NGQwY2M=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-02-11T09:10:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-11T09:10:54Z"}, "message": "Merge pull request #1512 from pengowen123/patch-large_enum_variant\n\nChange large_enum_variant to lint against difference in sizes between variants", "tree": {"sha": "321f45a13d61db1a6c2be5b5ffa1e7f0aba8117e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/321f45a13d61db1a6c2be5b5ffa1e7f0aba8117e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "html_url": "https://github.com/rust-lang/rust/commit/4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a0e52a1ed5077ab587f5524a9ac623cc71b223", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a0e52a1ed5077ab587f5524a9ac623cc71b223", "html_url": "https://github.com/rust-lang/rust/commit/37a0e52a1ed5077ab587f5524a9ac623cc71b223"}, {"sha": "8fb582ea1c4aece4c0f6634c562c4a46de481dc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb582ea1c4aece4c0f6634c562c4a46de481dc6", "html_url": "https://github.com/rust-lang/rust/commit/8fb582ea1c4aece4c0f6634c562c4a46de481dc6"}], "stats": {"total": 193, "additions": 106, "deletions": 87}, "files": [{"sha": "1f6fb4ff9c0b0ffc72b066496823de1b00b994f1", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "patch": "@@ -256,7 +256,7 @@ name\n [iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                                       | warn    | for-looping over `_.next()` which is probably not intended\n [iter_nth](https://github.com/Manishearth/rust-clippy/wiki#iter_nth)                                                   | warn    | using `.iter().nth()` on a standard library type with O(1) element access\n [iter_skip_next](https://github.com/Manishearth/rust-clippy/wiki#iter_skip_next)                                       | warn    | using `.skip(x).next()` on an iterator\n-[large_enum_variant](https://github.com/Manishearth/rust-clippy/wiki#large_enum_variant)                               | warn    | large variants on an enum\n+[large_enum_variant](https://github.com/Manishearth/rust-clippy/wiki#large_enum_variant)                               | warn    | large size difference between variants on an enum\n [len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)                           | warn    | traits or impls with a public `len` method but no corresponding `is_empty` method\n [len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                                   | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block"}, {"sha": "f656d513b516cb3d49f8f2af59d5261e3d7742f1", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "patch": "@@ -1,4 +1,4 @@\n-//! lint when there are large variants on an enum\n+//! lint when there is a large size difference between variants on an enum\n \n use rustc::lint::*;\n use rustc::hir::*;\n@@ -7,7 +7,7 @@ use rustc::ty::layout::TargetDataLayout;\n use rustc::ty::TypeFoldable;\n use rustc::traits::Reveal;\n \n-/// **What it does:** Checks for large variants on `enum`s.\n+/// **What it does:** Checks for large size differences between variants on `enum`s.\n ///\n /// **Why is this bad?** Enum size is bounded by the largest variant. Having a large variant\n /// can penalize the memory layout of that enum.\n@@ -24,17 +24,17 @@ use rustc::traits::Reveal;\n declare_lint! {\n     pub LARGE_ENUM_VARIANT,\n     Warn,\n-    \"large variants on an enum\"\n+    \"large size difference between variants on an enum\"\n }\n \n #[derive(Copy,Clone)]\n pub struct LargeEnumVariant {\n-    maximum_variant_size_allowed: u64,\n+    maximum_size_difference_allowed: u64,\n }\n \n impl LargeEnumVariant {\n-    pub fn new(maximum_variant_size_allowed: u64) -> Self {\n-        LargeEnumVariant { maximum_variant_size_allowed: maximum_variant_size_allowed }\n+    pub fn new(maximum_size_difference_allowed: u64) -> Self {\n+        LargeEnumVariant { maximum_size_difference_allowed: maximum_size_difference_allowed }\n     }\n }\n \n@@ -50,6 +50,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n         if let ItemEnum(ref def, _) = item.node {\n             let ty = cx.tcx.item_type(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n+\n+            let mut smallest_variant: Option<(_, _)> = None;\n+            let mut largest_variant: Option<(_, _)> = None;\n+\n             for (i, variant) in adt.variants.iter().enumerate() {\n                 let data_layout = TargetDataLayout::parse(cx.sess());\n                 cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n@@ -67,32 +71,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n                             }\n                         })\n                         .sum();\n-                    if size > self.maximum_variant_size_allowed {\n-                        span_lint_and_then(cx,\n-                                           LARGE_ENUM_VARIANT,\n-                                           def.variants[i].span,\n-                                           \"large enum variant found\",\n-                                           |db| {\n-                            if variant.fields.len() == 1 {\n-                                let span = match def.variants[i].node.data {\n-                                    VariantData::Struct(ref fields, _) |\n-                                    VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n-                                    VariantData::Unit(_) => unreachable!(),\n-                                };\n-                                if let Some(snip) = snippet_opt(cx, span) {\n-                                    db.span_suggestion(span,\n-                                                       \"consider boxing the large fields to reduce the total size of \\\n-                                                        the enum\",\n-                                                       format!(\"Box<{}>\", snip));\n-                                    return;\n-                                }\n-                            }\n-                            db.span_help(def.variants[i].span,\n-                                         \"consider boxing the large fields to reduce the total size of the enum\");\n-                        });\n-                    }\n+\n+                    let grouped = (size, (i, variant));\n+\n+                    update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n+                    update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n                 });\n             }\n+\n+            if let (Some(smallest), Some(largest)) = (smallest_variant, largest_variant) {\n+                let difference = largest.0 - smallest.0;\n+\n+                if difference > self.maximum_size_difference_allowed {\n+                    let (i, variant) = largest.1;\n+\n+                    span_lint_and_then(cx,\n+                                       LARGE_ENUM_VARIANT,\n+                                       def.variants[i].span,\n+                                       \"large size difference between variants\",\n+                                       |db| {\n+                        if variant.fields.len() == 1 {\n+                            let span = match def.variants[i].node.data {\n+                                VariantData::Struct(ref fields, _) |\n+                                VariantData::Tuple(ref fields, _) => fields[0].ty.span,\n+                                VariantData::Unit(_) => unreachable!(),\n+                            };\n+                            if let Some(snip) = snippet_opt(cx, span) {\n+                                db.span_suggestion(span,\n+                                                   \"consider boxing the large fields to reduce the total size of the \\\n+                                                    enum\",\n+                                                   format!(\"Box<{}>\", snip));\n+                                return;\n+                            }\n+                        }\n+                        db.span_help(def.variants[i].span,\n+                                     \"consider boxing the large fields to reduce the total size of the enum\");\n+                    });\n+                }\n+            }\n+\n+        }\n+    }\n+}\n+\n+fn update_if<T, F>(old: &mut Option<T>, new: T, f: F)\n+    where F: Fn(&T, &T) -> bool\n+{\n+    if let Some(ref mut val) = *old {\n+        if f(val, &new) {\n+            *val = new;\n         }\n+    } else {\n+        *old = Some(new);\n     }\n }"}, {"sha": "8ac7571c1b1f043740e350c9872e73a4429cd72d", "filename": "tests/ui/large_enum_variant.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/tests%2Fui%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/tests%2Fui%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.rs?ref=4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "patch": "@@ -8,46 +8,50 @@\n enum LargeEnum {\n     A(i32),\n     B([i32; 8000]),\n+}\n \n-\n+enum GenericEnumOk<T> {\n+    A(i32),\n+    B([T; 8000]),\n }\n \n-enum GenericEnum<T> {\n+enum GenericEnum2<T> {\n     A(i32),\n     B([i32; 8000]),\n-\n-\n-    C([T; 8000]),\n-    D(T, [i32; 8000]),\n-\n+    C(T, [i32; 8000]),\n }\n \n trait SomeTrait {\n     type Item;\n }\n \n enum LargeEnumGeneric<A: SomeTrait> {\n-    Var(A::Item), // regression test, this used to ICE\n+    Var(A::Item),\n }\n \n-enum AnotherLargeEnum {\n+enum LargeEnum2 {\n     VariantOk(i32, u32),\n     ContainingLargeEnum(LargeEnum),\n-\n-\n+}\n+enum LargeEnum3 {\n     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n-\n     VoidVariant,\n     StructLikeLittle { x: i32, y: i32 },\n-    StructLikeLarge { x: [i32; 8000], y: i32 },\n-\n-    StructLikeLarge2 {\n-        x:\n-        [i32; 8000]\n+}\n \n-    },\n+enum LargeEnum4 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge { x: [i32; 8000], y: i32 },\n }\n \n-fn main() {\n+enum LargeEnum5 {\n+    VariantOk(i32, u32),\n+    StructLikeLarge2 { x: [i32; 8000] },\n+}\n \n+enum LargeEnumOk {\n+    LargeA([i32; 8000]),\n+    LargeB([i32; 8001]),\n }\n+\n+fn main() {}"}, {"sha": "84213003eb70d80036759c7891ef03105b073580", "filename": "tests/ui/large_enum_variant.stderr", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/tests%2Fui%2Flarge_enum_variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b29f9a36478575bd174f388ad3cfbef4a84d0cc/tests%2Fui%2Flarge_enum_variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_enum_variant.stderr?ref=4b29f9a36478575bd174f388ad3cfbef4a84d0cc", "patch": "@@ -1,4 +1,4 @@\n-error: large enum variant found\n+error: large size difference between variants\n   --> $DIR/large_enum_variant.rs:10:5\n    |\n 10 |     B([i32; 8000]),\n@@ -12,73 +12,59 @@ note: lint level defined here\n help: consider boxing the large fields to reduce the total size of the enum\n    |     B(Box<[i32; 8000]>),\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:17:5\n-   |\n-17 |     B([i32; 8000]),\n-   |     ^^^^^^^^^^^^^^\n-   |\n-help: consider boxing the large fields to reduce the total size of the enum\n-   |     B(Box<[i32; 8000]>),\n-\n-error: large enum variant found\n+error: large size difference between variants\n   --> $DIR/large_enum_variant.rs:21:5\n    |\n-21 |     D(T, [i32; 8000]),\n+21 |     C(T, [i32; 8000]),\n    |     ^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n   --> $DIR/large_enum_variant.rs:21:5\n    |\n-21 |     D(T, [i32; 8000]),\n+21 |     C(T, [i32; 8000]),\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:35:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:34:5\n    |\n-35 |     ContainingLargeEnum(LargeEnum),\n+34 |     ContainingLargeEnum(LargeEnum),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n    |     ContainingLargeEnum(Box<LargeEnum>),\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:38:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:37:5\n    |\n-38 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+37 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:38:5\n+  --> $DIR/large_enum_variant.rs:37:5\n    |\n-38 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n+37 |     ContainingMoreThanOneField(i32, [i32; 8000], [i32; 9500]),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:42:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:44:5\n    |\n-42 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n+44 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-  --> $DIR/large_enum_variant.rs:42:5\n+  --> $DIR/large_enum_variant.rs:44:5\n    |\n-42 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n+44 |     StructLikeLarge { x: [i32; 8000], y: i32 },\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: large enum variant found\n-  --> $DIR/large_enum_variant.rs:44:5\n+error: large size difference between variants\n+  --> $DIR/large_enum_variant.rs:49:5\n    |\n-44 |       StructLikeLarge2 {\n-   |  _____^ starting here...\n-45 | |         x:\n-46 | |         [i32; 8000]\n-47 | |\n-48 | |     },\n-   | |_____^ ...ending here\n+49 |     StructLikeLarge2 { x: [i32; 8000] },\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider boxing the large fields to reduce the total size of the enum\n-   |         Box<[i32; 8000]>\n+   |     StructLikeLarge2 { x: Box<[i32; 8000]> },\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 6 previous errors\n "}]}