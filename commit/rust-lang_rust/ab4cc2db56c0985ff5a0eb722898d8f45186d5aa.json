{"sha": "ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNGNjMmRiNTZjMDk4NWZmNWEwZWI3MjI4OThkOGY0NTE4NmQ1YWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T22:18:14Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-16T18:10:12Z"}, "message": "resolve: Move some code around", "tree": {"sha": "413cfde307299775ea98e751674e930366fc773f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/413cfde307299775ea98e751674e930366fc773f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "html_url": "https://github.com/rust-lang/rust/commit/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe2524cb9cf09e7a0aa84bbb36a130e65255e1c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2524cb9cf09e7a0aa84bbb36a130e65255e1c0", "html_url": "https://github.com/rust-lang/rust/commit/fe2524cb9cf09e7a0aa84bbb36a130e65255e1c0"}], "stats": {"total": 147, "additions": 73, "deletions": 74}, "files": [{"sha": "9f4d35525a86a3151c136efed36bf025bcae4852", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "patch": "@@ -868,6 +868,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // This is only a guess, two equivalent idents may incorrectly get different gensyms here.\n         let ident = ident.gensym_if_underscore();\n         let expansion = ExpnId::root(); // FIXME(jseyfried) intercrate hygiene\n+        // Record primary definitions.\n         match res {\n             Res::Def(kind @ DefKind::Mod, def_id)\n             | Res::Def(kind @ DefKind::Enum, def_id)\n@@ -879,51 +880,50 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                                              span);\n                 self.r.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Res::Def(DefKind::Variant, _)\n+            Res::Def(DefKind::Struct, _)\n+            | Res::Def(DefKind::Union, _)\n+            | Res::Def(DefKind::Variant, _)\n             | Res::Def(DefKind::TyAlias, _)\n             | Res::Def(DefKind::ForeignTy, _)\n             | Res::Def(DefKind::OpaqueTy, _)\n             | Res::Def(DefKind::TraitAlias, _)\n             | Res::Def(DefKind::AssocTy, _)\n             | Res::Def(DefKind::AssocOpaqueTy, _)\n             | Res::PrimTy(..)\n-            | Res::ToolMod => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-            }\n+            | Res::ToolMod =>\n+                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion)),\n             Res::Def(DefKind::Fn, _)\n+            | Res::Def(DefKind::Method, _)\n             | Res::Def(DefKind::Static, _)\n             | Res::Def(DefKind::Const, _)\n             | Res::Def(DefKind::AssocConst, _)\n-            | Res::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-            }\n-            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n-                if let Some(struct_def_id) =\n-                        self.r.cstore.def_key(def_id).parent\n-                            .map(|index| DefId { krate: def_id.krate, index: index }) {\n-                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n-                }\n+            | Res::Def(DefKind::Ctor(..), _) =>\n+                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::Macro(..), _)\n+            | Res::NonMacroAttr(..) =>\n+                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion)),\n+            Res::Def(DefKind::TyParam, _) | Res::Def(DefKind::ConstParam, _)\n+            | Res::Local(..) | Res::SelfTy(..) | Res::SelfCtor(..) | Res::Err =>\n+                bug!(\"unexpected resolution: {:?}\", res)\n+        }\n+        // Record some extra data for better diagnostics.\n+        match res {\n+            Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n+                let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n+                self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::Method, def_id) => {\n-                self.r.define(parent, ident, ValueNS, (res, vis, DUMMY_SP, expansion));\n-\n                 if self.r.cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n-            Res::Def(DefKind::Struct, def_id) | Res::Def(DefKind::Union, def_id) => {\n-                self.r.define(parent, ident, TypeNS, (res, vis, DUMMY_SP, expansion));\n-\n-                // Record field names for error reporting.\n-                let field_names = self.r.cstore.struct_field_names_untracked(def_id);\n-                self.insert_field_names(def_id, field_names);\n-            }\n-            Res::Def(DefKind::Macro(..), _) | Res::NonMacroAttr(..) => {\n-                self.r.define(parent, ident, MacroNS, (res, vis, DUMMY_SP, expansion));\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n+                let parent = self.r.cstore.def_key(def_id).parent;\n+                if let Some(struct_def_id) = parent.map(|index| DefId { index, ..def_id }) {\n+                    self.r.struct_constructors.insert(struct_def_id, (res, vis));\n+                }\n             }\n-            _ => bug!(\"unexpected resolution: {:?}\", res)\n+            _ => {}\n         }\n     }\n "}, {"sha": "afdcec19d8ef6014f8a190bb8a742cf3c9df5ae8", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "patch": "@@ -73,23 +73,23 @@ crate fn add_typo_suggestion(\n     false\n }\n \n-crate fn add_module_candidates<'a>(\n-    resolver: &mut Resolver<'a>,\n-    module: Module<'a>,\n-    names: &mut Vec<TypoSuggestion>,\n-    filter_fn: &impl Fn(Res) -> bool,\n-) {\n-    for (&(ident, _), resolution) in resolver.resolutions(module).borrow().iter() {\n-        if let Some(binding) = resolution.borrow().binding {\n-            let res = binding.res();\n-            if filter_fn(res) {\n-                names.push(TypoSuggestion::from_res(ident.name, res));\n+impl<'a> Resolver<'a> {\n+    crate fn add_module_candidates(\n+        &mut self,\n+        module: Module<'a>,\n+        names: &mut Vec<TypoSuggestion>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) {\n+        for (&(ident, _), resolution) in self.resolutions(module).borrow().iter() {\n+            if let Some(binding) = resolution.borrow().binding {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    names.push(TypoSuggestion::from_res(ident.name, res));\n+                }\n             }\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// Combines an error with provided span and emits it.\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n@@ -405,10 +405,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    add_module_candidates(this, root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n                 Scope::Module(module) => {\n-                    add_module_candidates(this, module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(|(name, binding)| {\n@@ -456,7 +456,7 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        add_module_candidates(this, prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n                         suggestions.extend(tmp_suggestions.into_iter().filter(|s| {\n                             use_prelude || this.is_builtin_macro(s.res)\n                         }));"}, {"sha": "a822fa049ca1c5467175d881af0110230c7d1b4c", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "patch": "@@ -1,8 +1,7 @@\n use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n use crate::path_names_to_string;\n-use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n-use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::diagnostics::{add_typo_suggestion, ImportSuggestion, TypoSuggestion};\n use crate::late::{LateResolutionVisitor, RibKind};\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -548,7 +547,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(self.r, module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -577,7 +576,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                add_module_candidates(self.r, prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -599,7 +598,7 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(self.r, module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }"}, {"sha": "1c1448c9aa1238e0946b5ccfc9a619ef75c26438", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "patch": "@@ -59,6 +59,7 @@ use std::collections::BTreeSet;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n \n+use build_reduced_graph::BuildReducedGraphVisitor;\n use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use late::{PathSource, Rib, RibKind::*};\n@@ -1257,6 +1258,25 @@ impl<'a> Resolver<'a> {\n         self.arenas.alloc_module(module)\n     }\n \n+    fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n+        if module.populate_on_access.get() {\n+            module.populate_on_access.set(false);\n+            let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n+            for child in self.cstore.item_children_untracked(def_id, self.session) {\n+                let child = child.map_id(|_| panic!(\"unexpected id\"));\n+                BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n+                    .build_reduced_graph_for_external_crate_res(module, child);\n+            }\n+        }\n+        &module.lazy_resolutions\n+    }\n+\n+    fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n     fn record_use(&mut self, ident: Ident, ns: Namespace,\n                   used_binding: &'a NameBinding<'a>, is_lexical_scope: bool) {\n         if let Some((b2, kind)) = used_binding.ambiguity {"}, {"sha": "b49f1868706695674667f097f10563e96b2bf7e0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4cc2db56c0985ff5a0eb722898d8f45186d5aa/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ab4cc2db56c0985ff5a0eb722898d8f45186d5aa", "patch": "@@ -7,10 +7,8 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolutions, Resolver, ResolutionError, Segment};\n+use crate::{Resolver, ResolutionError, Segment, ModuleKind};\n use crate::{names_to_string, module_to_string};\n-use crate::ModuleKind;\n-use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::diagnostics::Suggestion;\n \n use errors::Applicability;\n@@ -38,7 +36,7 @@ use syntax_pos::{MultiSpan, Span};\n \n use log::*;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n@@ -162,25 +160,6 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn resolutions(&mut self, module: Module<'a>) -> &'a Resolutions<'a> {\n-        if module.populate_on_access.get() {\n-            module.populate_on_access.set(false);\n-            let def_id = module.def_id().expect(\"unpopulated module without a def-id\");\n-            for child in self.cstore.item_children_untracked(def_id, self.session) {\n-                let child = child.map_id(|_| panic!(\"unexpected id\"));\n-                BuildReducedGraphVisitor { parent_scope: self.dummy_parent_scope(), r: self }\n-                    .build_reduced_graph_for_external_crate_res(module, child);\n-            }\n-        }\n-        &module.lazy_resolutions\n-    }\n-\n-    crate fn resolution(&mut self, module: Module<'a>, ident: Ident, ns: Namespace)\n-                  -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions(module).borrow_mut().entry((ident.modern(), ns))\n-               .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n     crate fn resolve_ident_in_module_unadjusted(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n@@ -1039,7 +1018,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => Some(self.r.resolutions(module).borrow()),\n+                    ModuleOrUniformRoot::Module(module) =>\n+                        Some(self.r.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -1292,8 +1272,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(&ident, resolution)| {\n-            resolution.borrow().binding().map(|binding| (ident, binding))\n+        let bindings = self.r.resolutions(module).borrow().iter().filter_map(|(ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (*ident, binding))\n         }).collect::<Vec<_>>();\n         for ((mut ident, ns), binding) in bindings {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {"}]}