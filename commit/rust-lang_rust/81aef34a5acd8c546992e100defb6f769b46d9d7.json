{"sha": "81aef34a5acd8c546992e100defb6f769b46d9d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYWVmMzRhNWFjZDhjNTQ2OTkyZTEwMGRlZmI2Zjc2OWI0NmQ5ZDc=", "commit": {"author": {"name": "alexrp", "email": "alex@lycus.org", "date": "2012-08-08T11:30:31Z"}, "committer": {"name": "alexrp", "email": "alex@lycus.org", "date": "2012-08-08T11:30:31Z"}, "message": "Alter the manual to speak of pure functions instead of predicate functions.\n\nSince the typestate system is gone, this makes more sense now.", "tree": {"sha": "fe7fcaffce386eae13902f504aeaa043f03254a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7fcaffce386eae13902f504aeaa043f03254a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81aef34a5acd8c546992e100defb6f769b46d9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81aef34a5acd8c546992e100defb6f769b46d9d7", "html_url": "https://github.com/rust-lang/rust/commit/81aef34a5acd8c546992e100defb6f769b46d9d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81aef34a5acd8c546992e100defb6f769b46d9d7/comments", "author": null, "committer": null, "parents": [{"sha": "52c517383ef57f96ce1a97babc627d03329ac5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c517383ef57f96ce1a97babc627d03329ac5e6", "html_url": "https://github.com/rust-lang/rust/commit/52c517383ef57f96ce1a97babc627d03329ac5e6"}], "stats": {"total": 31, "additions": 12, "deletions": 19}, "files": [{"sha": "513c2a63d991da7460e5c7151abca98f89bc81a3", "filename": "doc/rust.md", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/81aef34a5acd8c546992e100defb6f769b46d9d7/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/81aef34a5acd8c546992e100defb6f769b46d9d7/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=81aef34a5acd8c546992e100defb6f769b46d9d7", "patch": "@@ -899,58 +899,51 @@ express that `f` requires no explicit `return`, as if it returns\n control to the caller, it returns a value (true because it never returns\n control).\n \n-#### Predicate functions\n+#### Pure functions\n \n-Any pure boolean function is called a *predicate function*, and may be used in\n-a [constraint](#constraints), as part of the static [typestate\n-system](#typestate-system). A predicate declaration is identical to a function\n-declaration, except that it is declared with the additional keyword `pure`. In\n-addition, the typechecker checks the body of a predicate with a restricted set\n-of typechecking rules. A predicate\n+A pure function declaration is identical to a function declaration, except that\n+it is declared with the additional keyword `pure`. In addition, the typechecker\n+checks the body of a pure function with a restricted set of typechecking rules.\n+A pure function\n \n * may not contain an assignment or self-call expression; and\n-* may only call other predicates, not general functions.\n+* may only call other pure functions, not general functions.\n \n-An example of a predicate:\n+An example of a pure function:\n \n ~~~~\n pure fn lt_42(x: int) -> bool {\n     return (x < 42);\n }\n ~~~~\n \n-A non-boolean function may also be declared with `pure fn`. This allows\n-predicates to call non-boolean functions as long as they are pure. For example:\n+Pure functions may call other pure functions:\n \n ~~~~{.xfail-test}\n pure fn pure_length<T>(ls: list<T>) -> uint { /* ... */ }\n \n pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n ~~~~\n \n-In this example, `nonempty_list` is a predicate---it can be used in a\n-typestate constraint---but the auxiliary function `pure_length` is\n-not.\n-\n *TODO:* should actually define referential transparency.\n \n The effect checking rules previously enumerated are a restricted set of\n typechecking rules meant to approximate the universe of observably\n referentially transparent Rust procedures conservatively. Sometimes, these\n rules are *too* restrictive. Rust allows programmers to violate these rules by\n-writing predicates that the compiler cannot prove to be referentially\n+writing pure functions that the compiler cannot prove to be referentially\n transparent, using an escape-hatch feature called \"unchecked blocks\". When\n writing code that uses unchecked blocks, programmers should always be aware\n that they have an obligation to show that the code *behaves* referentially\n transparently at all times, even if the compiler cannot *prove* automatically\n that the code is referentially transparent. In the presence of unchecked\n blocks, the compiler provides no static guarantee that the code will behave as\n expected at runtime. Rather, the programmer has an independent obligation to\n-verify the semantics of the predicates they write.\n+verify the semantics of the pure functions they write.\n \n *TODO:* last two sentences are vague.\n \n-An example of a predicate that uses an unchecked block:\n+An example of a pure function that uses an unchecked block:\n \n ~~~~\n # import std::list::*;\n@@ -972,7 +965,7 @@ pure fn pure_length<T>(ls: list<T>) -> uint {\n \n Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n way in Rust to specify that the higher-order function argument `f` is a pure\n-function. So, to use `foldl` in a pure list length function that a predicate\n+function. So, to use `foldl` in a pure list length function that a pure function\n could then use, we must use an `unchecked` block wrapped around the call to\n `pure_foldl` in the definition of `pure_length`.\n "}]}