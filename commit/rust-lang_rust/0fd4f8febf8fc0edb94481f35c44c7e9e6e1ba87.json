{"sha": "0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZDRmOGZlYmY4ZmMwZWRiOTQ0ODFmMzVjNDRjN2U5ZTZlMWJhODc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-19T04:35:44Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-22T16:45:15Z"}, "message": "Add a custom `Res` type\n\n- Don't make rustc_resolve::Res public; use a new type alias instead", "tree": {"sha": "74c0d1e9e1d151c503a76229083f1e7f54c554bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74c0d1e9e1d151c503a76229083f1e7f54c554bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87", "html_url": "https://github.com/rust-lang/rust/commit/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50a90975c0f78219db45d3bee0676a22695ec103", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a90975c0f78219db45d3bee0676a22695ec103", "html_url": "https://github.com/rust-lang/rust/commit/50a90975c0f78219db45d3bee0676a22695ec103"}], "stats": {"total": 277, "additions": 161, "deletions": 116}, "files": [{"sha": "1f1fb9754cfed63077dd5f70686e442ad2171c8a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 161, "deletions": 116, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=0fd4f8febf8fc0edb94481f35c44c7e9e6e1ba87", "patch": "@@ -10,24 +10,24 @@ use rustc_hir as hir;\n use rustc_hir::def::{\n     DefKind,\n     Namespace::{self, *},\n-    PerNS, Res,\n+    PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty;\n+use rustc_middle::{bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::{\n     builtin::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS},\n     Lint,\n };\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n use smallvec::{smallvec, SmallVec};\n \n use std::borrow::Cow;\n use std::cell::Cell;\n+use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n@@ -61,6 +61,71 @@ impl<'a> From<ResolutionFailure<'a>> for ErrorKind<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Hash)]\n+enum Res {\n+    Def(DefKind, DefId),\n+    Primitive(PrimitiveType),\n+}\n+\n+type ResolveRes = rustc_hir::def::Res<rustc_ast::NodeId>;\n+\n+impl Res {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            Res::Def(kind, id) => ResolveRes::Def(kind, id).descr(),\n+            Res::Primitive(_) => \"builtin type\",\n+        }\n+    }\n+\n+    fn article(self) -> &'static str {\n+        match self {\n+            Res::Def(kind, id) => ResolveRes::Def(kind, id).article(),\n+            Res::Primitive(_) => \"a\",\n+        }\n+    }\n+\n+    fn name(self, tcx: ty::TyCtxt<'_>) -> String {\n+        match self {\n+            Res::Def(_, id) => tcx.item_name(id).to_string(),\n+            Res::Primitive(prim) => prim.as_str().to_string(),\n+        }\n+    }\n+\n+    fn def_id(self) -> DefId {\n+        self.opt_def_id().expect(\"called def_id() on a primitive\")\n+    }\n+\n+    fn opt_def_id(self) -> Option<DefId> {\n+        match self {\n+            Res::Def(_, id) => Some(id),\n+            Res::Primitive(_) => None,\n+        }\n+    }\n+\n+    fn as_hir_res(self) -> Option<rustc_hir::def::Res> {\n+        match self {\n+            Res::Def(kind, id) => Some(rustc_hir::def::Res::Def(kind, id)),\n+            // FIXME: maybe this should handle the subset of PrimitiveType that fits into hir::PrimTy?\n+            Res::Primitive(_) => None,\n+        }\n+    }\n+}\n+\n+impl TryFrom<ResolveRes> for Res {\n+    type Error = ();\n+\n+    fn try_from(res: ResolveRes) -> Result<Self, ()> {\n+        use rustc_hir::def::Res::*;\n+        match res {\n+            Def(kind, id) => Ok(Res::Def(kind, id)),\n+            PrimTy(prim) => Ok(Res::Primitive(PrimitiveType::from_hir(prim))),\n+            // e.g. `#[derive]`\n+            NonMacroAttr(..) | Err => Result::Err(()),\n+            other => bug!(\"unrecognized res {:?}\", other),\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n /// A link failed to resolve.\n enum ResolutionFailure<'a> {\n@@ -253,12 +318,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n-            .map(|(_, res)| res)\n-            .unwrap_or(Res::Err);\n-        if let Res::Err = ty_res {\n-            return Err(no_res().into());\n-        }\n-        let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n+            .and_then(|(_, res)| res.try_into())\n+            .map_err(|()| no_res())?;\n+\n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n                 if cx\n@@ -309,15 +371,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n-        prim_ty: hir::PrimTy,\n+        prim_ty: PrimitiveType,\n         ns: Namespace,\n         module_id: DefId,\n         item_name: Symbol,\n         item_str: &'path str,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n         let cx = self.cx;\n \n-        PrimitiveType::from_hir(prim_ty)\n+        prim_ty\n             .impls(cx.tcx)\n             .into_iter()\n             .find_map(|&impl_| {\n@@ -336,21 +398,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     })\n                     .map(|out| {\n                         (\n-                            Res::PrimTy(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str)),\n+                            Res::Primitive(prim_ty),\n+                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_str)),\n                         )\n                     })\n             })\n             .ok_or_else(|| {\n                 debug!(\n                     \"returning primitive error for {}::{} in {} namespace\",\n-                    prim_ty.name(),\n+                    prim_ty.as_str(),\n                     item_name,\n                     ns.descr()\n                 );\n                 ResolutionFailure::NotResolved {\n                     module_id,\n-                    partial_res: Some(Res::PrimTy(prim_ty)),\n+                    partial_res: Some(Res::Primitive(prim_ty)),\n                     unresolved: item_str.into(),\n                 }\n                 .into()\n@@ -377,19 +439,18 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 false,\n             ) {\n                 if let SyntaxExtensionKind::LegacyBang { .. } = ext.kind {\n-                    return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n+                    return Ok(res.try_into().unwrap());\n                 }\n             }\n-            if let Some(res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Ok(res.map_id(|_| panic!(\"unexpected id\")));\n+            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n+                return Ok(res.try_into().unwrap());\n             }\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n             if let Ok((_, res)) =\n                 resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n             {\n                 // don't resolve builtins like `#[derive]`\n-                if let Res::Def(..) = res {\n-                    let res = res.map_id(|_| panic!(\"unexpected node_id\"));\n+                if let Ok(res) = res.try_into() {\n                     return Ok(res);\n                 }\n             }\n@@ -408,14 +469,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     /// Associated items will never be resolved by this function.\n     fn resolve_path(&self, path_str: &str, ns: Namespace, module_id: DefId) -> Option<Res> {\n         let result = self.cx.enter_resolver(|resolver| {\n-            resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+            resolver\n+                .resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n+                .and_then(|(_, res)| res.try_into())\n         });\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        match result.map(|(_, res)| res) {\n+        match result {\n             // resolver doesn't know about true and false so we'll have to resolve them\n             // manually as bool\n-            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n-            Ok(res) => Some(res.map_id(|_| panic!(\"unexpected node_id\"))),\n+            Err(()) => is_bool_value(path_str, ns),\n+            Ok(res) => Some(res),\n         }\n     }\n \n@@ -444,13 +507,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return handle_variant(cx, res, extra_fragment);\n                 }\n                 // Not a trait item; just return what we found.\n-                Res::PrimTy(ty) => {\n+                Res::Primitive(ty) => {\n                     if extra_fragment.is_some() {\n                         return Err(ErrorKind::AnchorFailure(\n                             AnchorFailure::RustdocAnchorConflict(res),\n                         ));\n                     }\n-                    return Ok((res, Some(ty.name_str().to_owned())));\n+                    return Ok((res, Some(ty.as_str().to_owned())));\n                 }\n                 Res::Def(DefKind::Mod, _) => {\n                     return Ok((res, extra_fragment.clone()));\n@@ -483,7 +546,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         // FIXME: are these both necessary?\n         let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n-            .map(|(_, res)| res)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n         {\n             ty_res\n@@ -502,7 +564,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n \n         let res = match ty_res {\n-            Res::PrimTy(prim) => Some(\n+            Res::Primitive(prim) => Some(\n                 self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n             ),\n             Res::Def(\n@@ -1068,9 +1130,9 @@ impl LinkCollector<'_, '_> {\n         if matches!(\n             disambiguator,\n             None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n-        ) && !matches!(res, Res::PrimTy(_))\n+        ) && !matches!(res, Res::Primitive(_))\n         {\n-            if let Some((path, prim)) = resolve_primitive(path_str, TypeNS) {\n+            if let Some(prim) = resolve_primitive(path_str, TypeNS) {\n                 // `prim@char`\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n@@ -1085,7 +1147,7 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     res = prim;\n-                    fragment = Some(path.as_str().to_string());\n+                    fragment = Some(prim.name(self.cx.tcx));\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1111,21 +1173,20 @@ impl LinkCollector<'_, '_> {\n             };\n             report_diagnostic(cx, BROKEN_INTRA_DOC_LINKS, &msg, &item, dox, &link_range, callback);\n         };\n-        if let Res::PrimTy(..) = res {\n-            match disambiguator {\n+        match res {\n+            Res::Primitive(_) => match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n                     Some(ItemLink { link: ori_link, link_text, did: None, fragment })\n                 }\n                 Some(other) => {\n                     report_mismatch(other, Disambiguator::Primitive);\n                     None\n                 }\n-            }\n-        } else {\n-            debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+            },\n+            Res::Def(kind, id) => {\n+                debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n-            // Disallow e.g. linking to enums with `struct@`\n-            if let Res::Def(kind, _) = res {\n+                // Disallow e.g. linking to enums with `struct@`\n                 debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n                 match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n                     | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n@@ -1144,27 +1205,26 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                 }\n-            }\n \n-            // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-            if let Some((src_id, dst_id)) = res\n-                .opt_def_id()\n-                .and_then(|def_id| def_id.as_local())\n-                .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-            {\n-                use rustc_hir::def_id::LOCAL_CRATE;\n+                // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+                if let Some((src_id, dst_id)) = id\n+                    .as_local()\n+                    .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+                {\n+                    use rustc_hir::def_id::LOCAL_CRATE;\n \n-                let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n+                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n \n-                if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                    && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-                {\n-                    privacy_error(cx, &item, &path_str, dox, link_range);\n+                    if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                        && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+                    {\n+                        privacy_error(cx, &item, &path_str, dox, link_range);\n+                    }\n                 }\n+                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+                Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n             }\n-            let id = clean::register_res(cx, res);\n-            Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n@@ -1296,16 +1356,18 @@ impl LinkCollector<'_, '_> {\n                     .and_then(|(res, fragment)| {\n                         // Constructors are picked up in the type namespace.\n                         match res {\n-                            Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n+                            Res::Def(DefKind::Ctor(..), _) => {\n                                 Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n                             }\n-                            _ => match (fragment, extra_fragment.clone()) {\n-                                (Some(fragment), Some(_)) => {\n-                                    // Shouldn't happen but who knows?\n-                                    Ok((res, Some(fragment)))\n+                            _ => {\n+                                match (fragment, extra_fragment.clone()) {\n+                                    (Some(fragment), Some(_)) => {\n+                                        // Shouldn't happen but who knows?\n+                                        Ok((res, Some(fragment)))\n+                                    }\n+                                    (fragment, None) | (None, fragment) => Ok((res, fragment)),\n                                 }\n-                                (fragment, None) | (None, fragment) => Ok((res, fragment)),\n-                            },\n+                            }\n                         }\n                     }),\n                 };\n@@ -1445,12 +1507,10 @@ impl Disambiguator {\n         }\n     }\n \n-    /// WARNING: panics on `Res::Err`\n     fn from_res(res: Res) -> Self {\n         match res {\n             Res::Def(kind, _) => Disambiguator::Kind(kind),\n-            Res::PrimTy(_) => Disambiguator::Primitive,\n-            _ => Disambiguator::Namespace(res.ns().expect(\"can't call `from_res` on Res::err\")),\n+            Res::Primitive(_) => Disambiguator::Primitive,\n         }\n     }\n \n@@ -1631,6 +1691,7 @@ fn resolution_failure(\n     link_range: Option<Range<usize>>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n+    let tcx = collector.cx.tcx;\n     report_diagnostic(\n         collector.cx,\n         BROKEN_INTRA_DOC_LINKS,\n@@ -1639,16 +1700,9 @@ fn resolution_failure(\n         dox,\n         &link_range,\n         |diag, sp| {\n-            let item = |res: Res| {\n-                format!(\n-                    \"the {} `{}`\",\n-                    res.descr(),\n-                    collector.cx.tcx.item_name(res.def_id()).to_string()\n-                )\n-            };\n+            let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n             let assoc_item_not_allowed = |res: Res| {\n-                let def_id = res.def_id();\n-                let name = collector.cx.tcx.item_name(def_id);\n+                let name = res.name(tcx);\n                 format!(\n                     \"`{}` is {} {}, not a module or type, and cannot have associated items\",\n                     name,\n@@ -1714,7 +1768,7 @@ fn resolution_failure(\n                     if let Some(module) = last_found_module {\n                         let note = if partial_res.is_some() {\n                             // Part of the link resolved; e.g. `std::io::nonexistent`\n-                            let module_name = collector.cx.tcx.item_name(module);\n+                            let module_name = tcx.item_name(module);\n                             format!(\"no item named `{}` in module `{}`\", unresolved, module_name)\n                         } else {\n                             // None of the link resolved; e.g. `Notimported`\n@@ -1738,14 +1792,10 @@ fn resolution_failure(\n \n                     // Otherwise, it must be an associated item or variant\n                     let res = partial_res.expect(\"None case was handled by `last_found_module`\");\n-                    let diagnostic_name;\n-                    let (kind, name) = match res {\n-                        Res::Def(kind, def_id) => {\n-                            diagnostic_name = collector.cx.tcx.item_name(def_id).as_str();\n-                            (Some(kind), &*diagnostic_name)\n-                        }\n-                        Res::PrimTy(ty) => (None, ty.name_str()),\n-                        _ => unreachable!(\"only ADTs and primitives are in scope at module level\"),\n+                    let name = res.name(tcx);\n+                    let kind = match res {\n+                        Res::Def(kind, _) => Some(kind),\n+                        Res::Primitive(_) => None,\n                     };\n                     let path_description = if let Some(kind) = kind {\n                         match kind {\n@@ -2003,50 +2053,45 @@ fn handle_variant(\n         .parent(res.def_id())\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n-            let variant = cx.tcx.expect_variant_res(res);\n+            let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n             (parent_def, Some(format!(\"variant.{}\", variant.ident.name)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }\n \n-// FIXME: At this point, this is basically a copy of the PrimitiveTypeTable\n-const PRIMITIVES: &[(Symbol, Res)] = &[\n-    (sym::u8, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U8))),\n-    (sym::u16, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U16))),\n-    (sym::u32, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U32))),\n-    (sym::u64, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U64))),\n-    (sym::u128, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::U128))),\n-    (sym::usize, Res::PrimTy(hir::PrimTy::Uint(rustc_ast::UintTy::Usize))),\n-    (sym::i8, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I8))),\n-    (sym::i16, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I16))),\n-    (sym::i32, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I32))),\n-    (sym::i64, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I64))),\n-    (sym::i128, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::I128))),\n-    (sym::isize, Res::PrimTy(hir::PrimTy::Int(rustc_ast::IntTy::Isize))),\n-    (sym::f32, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F32))),\n-    (sym::f64, Res::PrimTy(hir::PrimTy::Float(rustc_ast::FloatTy::F64))),\n-    (sym::str, Res::PrimTy(hir::PrimTy::Str)),\n-    (sym::bool, Res::PrimTy(hir::PrimTy::Bool)),\n-    (sym::char, Res::PrimTy(hir::PrimTy::Char)),\n-];\n-\n /// Resolve a primitive type or value.\n-fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n-    is_bool_value(path_str, ns).or_else(|| {\n-        if ns == TypeNS {\n-            // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n-            let maybe_primitive = Symbol::intern(path_str);\n-            PRIMITIVES.iter().find(|x| x.0 == maybe_primitive).copied()\n-        } else {\n-            None\n-        }\n-    })\n+fn resolve_primitive(path_str: &str, ns: Namespace) -> Option<Res> {\n+    if ns != TypeNS {\n+        return None;\n+    }\n+    use PrimitiveType::*;\n+    let prim = match path_str {\n+        \"u8\" => U8,\n+        \"u16\" => U16,\n+        \"u32\" => U32,\n+        \"u64\" => U64,\n+        \"u128\" => U128,\n+        \"usize\" => Usize,\n+        \"i8\" => I8,\n+        \"i16\" => I16,\n+        \"i32\" => I32,\n+        \"i64\" => I64,\n+        \"i128\" => I128,\n+        \"isize\" => Isize,\n+        \"f32\" => F32,\n+        \"f64\" => F64,\n+        \"str\" => Str,\n+        \"bool\" | \"true\" | \"false\" => Bool,\n+        \"char\" => Char,\n+        _ => return None,\n+    };\n+    Some(Res::Primitive(prim))\n }\n \n /// Resolve a primitive value.\n-fn is_bool_value(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n+fn is_bool_value(path_str: &str, ns: Namespace) -> Option<Res> {\n     if ns == TypeNS && (path_str == \"true\" || path_str == \"false\") {\n-        Some((sym::bool, Res::PrimTy(hir::PrimTy::Bool)))\n+        Some(Res::Primitive(PrimitiveType::Bool))\n     } else {\n         None\n     }"}]}