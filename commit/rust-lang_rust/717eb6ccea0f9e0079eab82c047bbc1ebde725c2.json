{"sha": "717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxN2ViNmNjZWEwZjllMDA3OWVhYjgyYzA0N2JiYzFlYmRlNzI1YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T14:52:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-28T14:52:20Z"}, "message": "Auto merge of #78409 - pietroalbini:build-manifest-checksum-cache, r=Mark-Simulacrum\n\nAdd checksums cache to build-manifest\n\nDuring the release process we're currently calculating the SHA256 of each file three times:\n\n1. In `build-manifest`, to fill the `hash = \"f00\"` keys of the manifests.\n2. In `promote-release`, to generate the `.sha256` files.\n3. In `promote-release`, to generate the `.asc` GPG signatures.\n\nCalculations 1. and 2. could be merged into a single one if there was a way for `build-manifest` to pass the checksums it generated over to `promote-release`. Unfortunately calculation 3. can't be merged as GPG requires extra metadata to be hashed.\n\nThis PR adds support for merging 1. and 2. by creating the `BUILD_MANIFEST_CHECKSUM_CACHE` environment variable, which points to a JSON file storing a cache of all the calculated checksums. `build-manifest` will load it at startup and avoid generating existing checksums, and it will dump its internal checksums cache into it when it exits successfully.\n\nThis PR also allows to run `build-manifest` multiple times without the need to wait for checksums to be calculated in the following invocations. The speedup will allow to work torwards a fix for https://github.com/rust-lang/promote-release/issues/15 without impacting the release process duration nor our storage costs.\n\nThis PR can be reviewed commit-by-commit.\nr? `@Mark-Simulacrum`", "tree": {"sha": "2d8519cfa14bffce13c5d7dc95c81b0486862083", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d8519cfa14bffce13c5d7dc95c81b0486862083"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "html_url": "https://github.com/rust-lang/rust/commit/717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/717eb6ccea0f9e0079eab82c047bbc1ebde725c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb4fc800aaf5006f89af3af591e2aa34f469d81", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb4fc800aaf5006f89af3af591e2aa34f469d81", "html_url": "https://github.com/rust-lang/rust/commit/2eb4fc800aaf5006f89af3af591e2aa34f469d81"}, {"sha": "c2f4bbd17614bf54353ccd913463744d6f7c9242", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f4bbd17614bf54353ccd913463744d6f7c9242", "html_url": "https://github.com/rust-lang/rust/commit/c2f4bbd17614bf54353ccd913463744d6f7c9242"}], "stats": {"total": 156, "additions": 106, "deletions": 50}, "files": [{"sha": "c019c7a2f7aec597608a757beb8f9050c71cbcd2", "filename": "src/tools/build-manifest/src/checksum.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/717eb6ccea0f9e0079eab82c047bbc1ebde725c2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fchecksum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717eb6ccea0f9e0079eab82c047bbc1ebde725c2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fchecksum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fchecksum.rs?ref=717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "patch": "@@ -0,0 +1,97 @@\n+use crate::manifest::{FileHash, Manifest};\n+use rayon::prelude::*;\n+use sha2::{Digest, Sha256};\n+use std::collections::{HashMap, HashSet};\n+use std::error::Error;\n+use std::fs::File;\n+use std::io::BufReader;\n+use std::path::{Path, PathBuf};\n+use std::sync::Mutex;\n+use std::time::Instant;\n+\n+pub(crate) struct Checksums {\n+    cache_path: Option<PathBuf>,\n+    collected: Mutex<HashMap<PathBuf, String>>,\n+}\n+\n+impl Checksums {\n+    pub(crate) fn new() -> Result<Self, Box<dyn Error>> {\n+        let cache_path = std::env::var_os(\"BUILD_MANIFEST_CHECKSUM_CACHE\").map(PathBuf::from);\n+\n+        let mut collected = HashMap::new();\n+        if let Some(path) = &cache_path {\n+            if path.is_file() {\n+                collected = serde_json::from_slice(&std::fs::read(path)?)?;\n+            }\n+        }\n+\n+        Ok(Checksums { cache_path, collected: Mutex::new(collected) })\n+    }\n+\n+    pub(crate) fn store_cache(&self) -> Result<(), Box<dyn Error>> {\n+        if let Some(path) = &self.cache_path {\n+            std::fs::write(path, &serde_json::to_vec(&self.collected)?)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub(crate) fn fill_missing_checksums(&mut self, manifest: &mut Manifest) {\n+        let need_checksums = self.find_missing_checksums(manifest);\n+        if !need_checksums.is_empty() {\n+            self.collect_checksums(&need_checksums);\n+        }\n+        self.replace_checksums(manifest);\n+    }\n+\n+    fn find_missing_checksums(&mut self, manifest: &mut Manifest) -> HashSet<PathBuf> {\n+        let collected = self.collected.lock().unwrap();\n+        let mut need_checksums = HashSet::new();\n+        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n+            if let FileHash::Missing(path) = file_hash {\n+                let path = std::fs::canonicalize(path).unwrap();\n+                if !collected.contains_key(&path) {\n+                    need_checksums.insert(path);\n+                }\n+            }\n+        });\n+        need_checksums\n+    }\n+\n+    fn replace_checksums(&mut self, manifest: &mut Manifest) {\n+        let collected = self.collected.lock().unwrap();\n+        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n+            if let FileHash::Missing(path) = file_hash {\n+                let path = std::fs::canonicalize(path).unwrap();\n+                match collected.get(&path) {\n+                    Some(hash) => *file_hash = FileHash::Present(hash.clone()),\n+                    None => panic!(\"missing hash for file {}\", path.display()),\n+                }\n+            }\n+        });\n+    }\n+\n+    fn collect_checksums(&mut self, files: &HashSet<PathBuf>) {\n+        let collection_start = Instant::now();\n+        println!(\n+            \"collecting hashes for {} tarballs across {} threads\",\n+            files.len(),\n+            rayon::current_num_threads().min(files.len()),\n+        );\n+\n+        files.par_iter().for_each(|path| match hash(path) {\n+            Ok(hash) => {\n+                self.collected.lock().unwrap().insert(path.clone(), hash);\n+            }\n+            Err(err) => eprintln!(\"error while fetching the hash for {}: {}\", path.display(), err),\n+        });\n+\n+        println!(\"collected {} hashes in {:.2?}\", files.len(), collection_start.elapsed());\n+    }\n+}\n+\n+fn hash(path: &Path) -> Result<String, Box<dyn Error>> {\n+    let mut file = BufReader::new(File::open(path)?);\n+    let mut sha256 = Sha256::default();\n+    std::io::copy(&mut file, &mut sha256)?;\n+    Ok(hex::encode(sha256.finalize()))\n+}"}, {"sha": "2863216855b833d645c7b2ab80c241d5ba09f049", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/717eb6ccea0f9e0079eab82c047bbc1ebde725c2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/717eb6ccea0f9e0079eab82c047bbc1ebde725c2/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=717eb6ccea0f9e0079eab82c047bbc1ebde725c2", "patch": "@@ -4,22 +4,19 @@\n //! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n //! by rustbuild (in `src/bootstrap/dist.rs`).\n \n+mod checksum;\n mod manifest;\n mod versions;\n \n-use crate::manifest::{Component, FileHash, Manifest, Package, Rename, Target};\n+use crate::checksum::Checksums;\n+use crate::manifest::{Component, Manifest, Package, Rename, Target};\n use crate::versions::{PkgType, Versions};\n-use rayon::prelude::*;\n-use sha2::Digest;\n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;\n-use std::error::Error;\n use std::fs::{self, File};\n-use std::io::{self, BufReader, Read, Write};\n+use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n-use std::sync::Mutex;\n-use std::time::Instant;\n \n static HOSTS: &[&str] = &[\n     \"aarch64-apple-darwin\",\n@@ -186,6 +183,7 @@ macro_rules! t {\n \n struct Builder {\n     versions: Versions,\n+    checksums: Checksums,\n     shipped_files: HashSet<String>,\n \n     input: PathBuf,\n@@ -240,6 +238,7 @@ fn main() {\n \n     Builder {\n         versions: Versions::new(&channel, &input).unwrap(),\n+        checksums: t!(Checksums::new()),\n         shipped_files: HashSet::new(),\n \n         input,\n@@ -276,6 +275,8 @@ impl Builder {\n         if let Some(path) = std::env::var_os(\"BUILD_MANIFEST_SHIPPED_FILES_PATH\") {\n             self.write_shipped_files(&Path::new(&path));\n         }\n+\n+        t!(self.checksums.store_cache());\n     }\n \n     /// If a tool does not pass its tests, don't ship it.\n@@ -321,7 +322,7 @@ impl Builder {\n         self.add_renames_to(&mut manifest);\n         manifest.pkg.insert(\"rust\".to_string(), self.rust_package(&manifest));\n \n-        self.fill_missing_hashes(&mut manifest);\n+        self.checksums.fill_missing_checksums(&mut manifest);\n \n         manifest\n     }\n@@ -595,41 +596,6 @@ impl Builder {\n         assert!(t!(child.wait()).success());\n     }\n \n-    fn fill_missing_hashes(&self, manifest: &mut Manifest) {\n-        // First collect all files that need hashes\n-        let mut need_hashes = HashSet::new();\n-        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n-            if let FileHash::Missing(path) = file_hash {\n-                need_hashes.insert(path.clone());\n-            }\n-        });\n-\n-        let collected = Mutex::new(HashMap::new());\n-        let collection_start = Instant::now();\n-        println!(\n-            \"collecting hashes for {} tarballs across {} threads\",\n-            need_hashes.len(),\n-            rayon::current_num_threads().min(need_hashes.len()),\n-        );\n-        need_hashes.par_iter().for_each(|path| match fetch_hash(path) {\n-            Ok(hash) => {\n-                collected.lock().unwrap().insert(path, hash);\n-            }\n-            Err(err) => eprintln!(\"error while fetching the hash for {}: {}\", path.display(), err),\n-        });\n-        let collected = collected.into_inner().unwrap();\n-        println!(\"collected {} hashes in {:.2?}\", collected.len(), collection_start.elapsed());\n-\n-        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n-            if let FileHash::Missing(path) = file_hash {\n-                match collected.get(path) {\n-                    Some(hash) => *file_hash = FileHash::Present(hash.clone()),\n-                    None => panic!(\"missing hash for file {}\", path.display()),\n-                }\n-            }\n-        })\n-    }\n-\n     fn write_channel_files(&mut self, channel_name: &str, manifest: &Manifest) {\n         self.write(&toml::to_string(&manifest).unwrap(), channel_name, \".toml\");\n         self.write(&manifest.date, channel_name, \"-date.txt\");\n@@ -660,10 +626,3 @@ impl Builder {\n         t!(std::fs::write(path, content.as_bytes()));\n     }\n }\n-\n-fn fetch_hash(path: &Path) -> Result<String, Box<dyn Error>> {\n-    let mut file = BufReader::new(File::open(path)?);\n-    let mut sha256 = sha2::Sha256::default();\n-    std::io::copy(&mut file, &mut sha256)?;\n-    Ok(hex::encode(sha256.finalize()))\n-}"}]}