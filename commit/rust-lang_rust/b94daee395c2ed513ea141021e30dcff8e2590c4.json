{"sha": "b94daee395c2ed513ea141021e30dcff8e2590c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NGRhZWUzOTVjMmVkNTEzZWExNDEwMjFlMzBkY2ZmOGUyNTkwYzQ=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-13T06:02:09Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-16T23:34:02Z"}, "message": "Clean up std::task docs, make TaskBuilder a real builder\n\nDelete all the documentation from std::task that references linked\nfailure.\n\nTweak TaskBuilder to be more builder-like. .name() is now .named() and\n.add_wrapper() is now .with_wrapper(). Remove .watched() and\n.unwatched() as they didn't actually do anything.", "tree": {"sha": "0a354cfb5d63f0e417cc99a89b202f46af6dc35b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a354cfb5d63f0e417cc99a89b202f46af6dc35b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b94daee395c2ed513ea141021e30dcff8e2590c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b94daee395c2ed513ea141021e30dcff8e2590c4", "html_url": "https://github.com/rust-lang/rust/commit/b94daee395c2ed513ea141021e30dcff8e2590c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b94daee395c2ed513ea141021e30dcff8e2590c4/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ba6d4885fc71ca7156e1fe689edb939e1d9d418", "html_url": "https://github.com/rust-lang/rust/commit/0ba6d4885fc71ca7156e1fe689edb939e1d9d418"}], "stats": {"total": 123, "additions": 26, "deletions": 97}, "files": [{"sha": "e139cfa1025a140aa6f3ed7111a37d50b8e2597f", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=b94daee395c2ed513ea141021e30dcff8e2590c4", "patch": "@@ -175,7 +175,6 @@ impl GreenTask {\n                      opts: TaskOpts,\n                      f: proc()) -> ~GreenTask {\n         let TaskOpts {\n-            watched: _watched,\n             notify_chan, name, stack_size,\n             stderr, stdout, logger,\n         } = opts;"}, {"sha": "b0f063ff06e1934c9b70bb49437a8e173964563b", "filename": "src/libnative/task.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=b94daee395c2ed513ea141021e30dcff8e2590c4", "patch": "@@ -57,7 +57,6 @@ pub fn spawn(f: proc()) {\n /// inside the task.\n pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n     let TaskOpts {\n-        watched: _watched,\n         notify_chan, name, stack_size,\n         logger, stderr, stdout,\n     } = opts;"}, {"sha": "1de5322b157ed7cafaa4abd17fad40bdb7377882", "filename": "src/libstd/task.rs", "status": "modified", "additions": 26, "deletions": 95, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94daee395c2ed513ea141021e30dcff8e2590c4/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=b94daee395c2ed513ea141021e30dcff8e2590c4", "patch": "@@ -13,26 +13,12 @@\n  *\n  * An executing Rust program consists of a tree of tasks, each with their own\n  * stack, and sole ownership of their allocated heap data. Tasks communicate\n- * with each other using ports and channels (see std::rt::comm for more info\n+ * with each other using ports and channels (see std::comm for more info\n  * about how communication works).\n  *\n- * Tasks can be spawned in 3 different modes.\n- *\n- *  * Bidirectionally linked: This is the default mode and it's what ```spawn``` does.\n- *  Failures will be propagated from parent to child and vice versa.\n- *\n- *  * Unidirectionally linked (parent->child): This type of task can be created with\n- *  ```spawn_supervised```. In this case, failures are propagated from parent to child\n- *  but not the other way around.\n- *\n- *  * Unlinked: Tasks can be completely unlinked. These tasks can be created by using\n- *  ```spawn_unlinked```. In this case failures are not propagated at all.\n- *\n- * Tasks' failure modes can be further configured. For instance, parent tasks can (un)watch\n- * children failures. Please, refer to TaskBuilder's documentation bellow for more information.\n- *\n- * When a (bi|uni)directionally linked task fails, its failure will be propagated to all tasks\n- * linked to it, this will cause such tasks to fail by a `linked failure`.\n+ * Failure in one task does not propagate to any others (not to parent, not to child).\n+ * Failure propagation is instead handled by using Chan.send() and Port.recv(), which\n+ * will fail if the other end has hung up already.\n  *\n  * Task Scheduling:\n  *\n@@ -51,8 +37,6 @@\n  * ```\n  */\n \n-#[allow(missing_doc)];\n-\n use any::Any;\n use comm::{Chan, Port};\n use io::Writer;\n@@ -70,40 +54,24 @@ use str::{Str, SendStr, IntoMaybeOwned};\n /// Indicates the manner in which a task exited.\n ///\n /// A task that completes without failing is considered to exit successfully.\n-/// Supervised ancestors and linked siblings may yet fail after this task\n-/// succeeds. Also note that in such a case, it may be nondeterministic whether\n-/// linked failure or successful exit happen first.\n ///\n-/// If you wish for this result's delivery to block until all linked and/or\n+/// If you wish for this result's delivery to block until all\n /// children tasks complete, recommend using a result future.\n pub type TaskResult = Result<(), ~Any>;\n \n-/**\n- * Task configuration options\n- *\n- * # Fields\n- *\n- * * watched - Make parent task collect exit status notifications from child\n- *             before reporting its own exit status. (This delays the parent\n- *             task's death and cleanup until after all transitively watched\n- *             children also exit.) True by default.\n- *\n- * * notify_chan - Enable lifecycle notifications on the given channel\n- *\n- * * name - A name for the task-to-be, for identification in failure messages.\n- *\n- * * sched - Specify the configuration of a new scheduler to create the task\n- *           in. This is of particular importance for libraries which want to call\n- *           into foreign code that blocks. Without doing so in a different\n- *           scheduler other tasks will be impeded or even blocked indefinitely.\n- */\n+/// Task configuration options\n pub struct TaskOpts {\n-    watched: bool,\n+    /// Enable lifecycle notifications on the given channel\n     notify_chan: Option<Chan<TaskResult>>,\n+    /// A name for the task-to-be, for identification in failure messages\n     name: Option<SendStr>,\n+    /// The size of the stack for the spawned task\n     stack_size: Option<uint>,\n+    /// Task-local logger (see std::logging)\n     logger: Option<~Logger>,\n+    /// Task-local stdout\n     stdout: Option<~Writer>,\n+    /// Task-local stderr\n     stderr: Option<~Writer>,\n }\n \n@@ -120,6 +88,7 @@ pub struct TaskOpts {\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n pub struct TaskBuilder {\n+    /// Options to spawn the new task with\n     opts: TaskOpts,\n     priv gen_body: Option<proc(v: proc()) -> proc()>,\n     priv nopod: Option<marker::NoPod>,\n@@ -128,7 +97,6 @@ pub struct TaskBuilder {\n /**\n  * Generate the base configuration for spawning a task, off of which more\n  * configuration methods can be chained.\n- * For example, task().unlinked().spawn is equivalent to spawn_unlinked.\n  */\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n@@ -139,31 +107,13 @@ pub fn task() -> TaskBuilder {\n }\n \n impl TaskBuilder {\n-    /// Cause the parent task to collect the child's exit status (and that of\n-    /// all transitively-watched grandchildren) before reporting its own.\n-    pub fn watched(&mut self) {\n-        self.opts.watched = true;\n-    }\n-\n-    /// Allow the child task to outlive the parent task, at the possible cost\n-    /// of the parent reporting success even if the child task fails later.\n-    pub fn unwatched(&mut self) {\n-        self.opts.watched = false;\n-    }\n-\n     /// Get a future representing the exit status of the task.\n     ///\n     /// Taking the value of the future will block until the child task\n     /// terminates. The future result return value will be created *before* the task is\n     /// spawned; as such, do not invoke .get() on it directly;\n     /// rather, store it in an outer variable/list for later use.\n     ///\n-    /// Note that the future returned by this function is only useful for\n-    /// obtaining the value of the next task to be spawning with the\n-    /// builder. If additional tasks are spawned with the same builder\n-    /// then a new result future must be obtained prior to spawning each\n-    /// task.\n-    ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n     pub fn future_result(&mut self) -> Port<TaskResult> {\n@@ -187,8 +137,9 @@ impl TaskBuilder {\n \n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in failure messages.\n-    pub fn name<S: IntoMaybeOwned<'static>>(&mut self, name: S) {\n+    pub fn named<S: IntoMaybeOwned<'static>>(mut self, name: S) -> TaskBuilder {\n         self.opts.name = Some(name.into_maybe_owned());\n+        self\n     }\n \n     /**\n@@ -203,7 +154,7 @@ impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    pub fn add_wrapper(&mut self, wrapper: proc(v: proc()) -> proc()) {\n+    pub fn with_wrapper(mut self, wrapper: proc(v: proc()) -> proc()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body.take();\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n@@ -219,6 +170,7 @@ impl TaskBuilder {\n             f\n         };\n         self.gen_body = Some(next_gen_body);\n+        self\n     }\n \n     /**\n@@ -227,11 +179,6 @@ impl TaskBuilder {\n      * Sets up a new task with its own call stack and schedules it to run\n      * the provided unique closure. The task has the properties and behavior\n      * specified by the task_builder.\n-     *\n-     * # Failure\n-     *\n-     * When spawning into a new scheduler, the number of threads requested\n-     * must be greater than zero.\n      */\n     pub fn spawn(mut self, f: proc()) {\n         let gen_body = self.gen_body.take();\n@@ -278,13 +225,9 @@ impl TaskOpts {\n     pub fn new() -> TaskOpts {\n         /*!\n          * The default task options\n-         *\n-         * By default all tasks are supervised by their parent, are spawned\n-         * into the same scheduler, and do not post lifecycle notifications.\n          */\n \n         TaskOpts {\n-            watched: true,\n             notify_chan: None,\n             name: None,\n             stack_size: None,\n@@ -313,7 +256,7 @@ pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n      *\n-     * This is equivalent to task().supervised().try.\n+     * This is equivalent to task().try.\n      */\n \n     let task = task();\n@@ -370,9 +313,7 @@ fn test_unnamed_task() {\n \n #[test]\n fn test_owned_named_task() {\n-    let mut t = task();\n-    t.name(~\"ada lovelace\");\n-    t.spawn(proc() {\n+    task().named(~\"ada lovelace\").spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n@@ -381,9 +322,7 @@ fn test_owned_named_task() {\n \n #[test]\n fn test_static_named_task() {\n-    let mut t = task();\n-    t.name(\"ada lovelace\");\n-    t.spawn(proc() {\n+    task().named(\"ada lovelace\").spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n@@ -392,9 +331,7 @@ fn test_static_named_task() {\n \n #[test]\n fn test_send_named_task() {\n-    let mut t = task();\n-    t.name(\"ada lovelace\".into_maybe_owned());\n-    t.spawn(proc() {\n+    task().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n@@ -411,18 +348,16 @@ fn test_run_basic() {\n }\n \n #[test]\n-fn test_add_wrapper() {\n+fn test_with_wrapper() {\n     let (po, ch) = Chan::new();\n-    let mut b0 = task();\n-    b0.add_wrapper(proc(body) {\n+    task().with_wrapper(proc(body) {\n         let ch = ch;\n         let result: proc() = proc() {\n             body();\n             ch.send(());\n         };\n         result\n-    });\n-    b0.spawn(proc() { });\n+    }).spawn(proc() { });\n     po.recv();\n }\n \n@@ -553,15 +488,11 @@ fn test_child_doesnt_ref_parent() {\n     fn child_no(x: uint) -> proc() {\n         return proc() {\n             if x < generations {\n-                let mut t = task();\n-                t.unwatched();\n-                t.spawn(child_no(x+1));\n+                task().spawn(child_no(x+1));\n             }\n         }\n     }\n-    let mut t = task();\n-    t.unwatched();\n-    t.spawn(child_no(0));\n+    task().spawn(child_no(0));\n }\n \n #[test]"}]}