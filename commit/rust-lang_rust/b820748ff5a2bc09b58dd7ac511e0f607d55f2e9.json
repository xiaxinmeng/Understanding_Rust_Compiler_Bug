{"sha": "b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjA3NDhmZjVhMmJjMDliNThkZDdhYzUxMWUwZjYwN2Q1NWYyZTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-10T07:28:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-13T06:18:51Z"}, "message": "Implement formatting arguments for strings and integers\n\nCloses #1651", "tree": {"sha": "7a34e364ae23968eadba2e7bc0ecae8e20b3fced", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a34e364ae23968eadba2e7bc0ecae8e20b3fced"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "html_url": "https://github.com/rust-lang/rust/commit/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44675ac6aff91889f960655b0034964740415e8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/44675ac6aff91889f960655b0034964740415e8c", "html_url": "https://github.com/rust-lang/rust/commit/44675ac6aff91889f960655b0034964740415e8c"}], "stats": {"total": 400, "additions": 295, "deletions": 105}, "files": [{"sha": "a0635f6f12eb29767b1f1faa901dc67dcbfea546", "filename": "src/libstd/char.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -20,6 +20,15 @@ use unicode::{derived_property, general_category};\n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use num::Zero;\n \n+// UTF-8 ranges and tags for encoding characters\n+static TAG_CONT: uint = 128u;\n+static MAX_ONE_B: uint = 128u;\n+static TAG_TWO_B: uint = 192u;\n+static MAX_TWO_B: uint = 2048u;\n+static TAG_THREE_B: uint = 224u;\n+static MAX_THREE_B: uint = 65536u;\n+static TAG_FOUR_B: uint = 240u;\n+\n /*\n     Lu  Uppercase_Letter        an uppercase letter\n     Ll  Lowercase_Letter        a lowercase letter\n@@ -278,6 +287,12 @@ pub trait Char {\n     fn escape_unicode(&self, f: &fn(char));\n     fn escape_default(&self, f: &fn(char));\n     fn len_utf8_bytes(&self) -> uint;\n+\n+    /// Encodes this character as utf-8 into the provided byte-buffer. The\n+    /// buffer must be at least 4 bytes long or a runtime failure will occur.\n+    ///\n+    /// This will then return the number of characters written to the slice.\n+    fn encode_utf8(&self, dst: &mut [u8]) -> uint;\n }\n \n impl Char for char {\n@@ -308,6 +323,29 @@ impl Char for char {\n     fn escape_default(&self, f: &fn(char)) { escape_default(*self, f) }\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n+\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+        let code = *self as uint;\n+        if code < MAX_ONE_B {\n+            dst[0] = code as u8;\n+            return 1;\n+        } else if code < MAX_TWO_B {\n+            dst[0] = (code >> 6u & 31u | TAG_TWO_B) as u8;\n+            dst[1] = (code & 63u | TAG_CONT) as u8;\n+            return 2;\n+        } else if code < MAX_THREE_B {\n+            dst[0] = (code >> 12u & 15u | TAG_THREE_B) as u8;\n+            dst[1] = (code >> 6u & 63u | TAG_CONT) as u8;\n+            dst[2] = (code & 63u | TAG_CONT) as u8;\n+            return 3;\n+        } else {\n+            dst[0] = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n+            dst[1] = (code >> 12u & 63u | TAG_CONT) as u8;\n+            dst[2] = (code >> 6u & 63u | TAG_CONT) as u8;\n+            dst[3] = (code & 63u | TAG_CONT) as u8;\n+            return 4;\n+        }\n+    }\n }\n \n #[cfg(not(test))]"}, {"sha": "a25620cfa6953e38f433790561dcde2462d35bc5", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 145, "deletions": 22, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -11,7 +11,7 @@\n use prelude::*;\n \n use cast;\n-use int;\n+use char::Char;\n use rt::io::Decorator;\n use rt::io::mem::MemWriter;\n use rt::io;\n@@ -122,6 +122,11 @@ pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n }\n \n impl<'self> Formatter<'self> {\n+\n+    // First up is the collection of functions used to execute a format string\n+    // at runtime. This consumes all of the compile-time statics generated by\n+    // the ifmt! syntax extension.\n+\n     fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n         let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n             match *cnt {\n@@ -240,6 +245,118 @@ impl<'self> Formatter<'self> {\n             }\n         }\n     }\n+\n+    // Helper methods used for padding and processing formatting arguments that\n+    // all formatting traits can use.\n+\n+    /// TODO: dox\n+    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n+                        positive: bool) {\n+        use fmt::parse::{FlagAlternate, FlagSignPlus};\n+\n+        let mut actual_len = s.len();\n+        if self.flags & 1 << (FlagAlternate as uint) != 0 {\n+            actual_len += alternate_prefix.len();\n+        }\n+        if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n+            actual_len += 1;\n+        }\n+        if !positive {\n+            actual_len += 1;\n+        }\n+\n+        let emit = |this: &mut Formatter| {\n+            if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n+                this.buf.write(['+' as u8]);\n+            } else if !positive {\n+                this.buf.write(['-' as u8]);\n+            }\n+            if this.flags & 1 << (FlagAlternate as uint) != 0 {\n+                this.buf.write(alternate_prefix.as_bytes());\n+            }\n+            this.buf.write(s);\n+        };\n+\n+        match self.width {\n+            None => { emit(self) }\n+            Some(min) if actual_len >= min => { emit(self) }\n+            Some(min) => {\n+                do self.with_padding(min - actual_len) |me| {\n+                    emit(me);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// This function takes a string slice and emits it to the internal buffer\n+    /// after applying the relevant formatting flags specified. The flags\n+    /// recognized for generic strings are:\n+    ///\n+    /// * width - the minimum width of what to emit\n+    /// * fill/alignleft - what to emit and where to emit it if the string\n+    ///                    provided needs to be padded\n+    /// * precision - the maximum length to emit, the string is truncated if it\n+    ///               is longer than this length\n+    ///\n+    /// Notably this function ignored the `flag` parameters\n+    pub fn pad(&mut self, s: &str) {\n+        // Make sure there's a fast path up front\n+        if self.width.is_none() && self.precision.is_none() {\n+            self.buf.write(s.as_bytes());\n+            return\n+        }\n+        // The `precision` field can be interpreted as a `max-width` for the\n+        // string being formatted\n+        match self.precision {\n+            Some(max) => {\n+                // If there's a maximum width and our string is longer than\n+                // that, then we must always have truncation. This is the only\n+                // case where the maximum length will matter.\n+                let char_len = s.char_len();\n+                if char_len >= max {\n+                    let nchars = uint::min(max, char_len);\n+                    self.buf.write(s.slice_chars(0, nchars).as_bytes());\n+                    return\n+                }\n+            }\n+            None => {}\n+        }\n+\n+        // The `width` field is more of a `min-width` parameter at this point.\n+        match self.width {\n+            // If we're under the maximum length, and there's no minimum length\n+            // requirements, then we can just emit the string\n+            None => { self.buf.write(s.as_bytes()) }\n+\n+            // If we're under the maximum width, check if we're over the minimum\n+            // width, if so it's as easy as just emitting the string.\n+            Some(width) if s.char_len() >= width => {\n+                self.buf.write(s.as_bytes())\n+            }\n+\n+            // If we're under both the maximum and the minimum width, then fill\n+            // up the minimum width with the specified string + some alignment.\n+            Some(width) => {\n+                do self.with_padding(width - s.len()) |me| {\n+                    me.buf.write(s.as_bytes());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn with_padding(&mut self, padding: uint, f: &fn(&mut Formatter)) {\n+        if self.alignleft {\n+            f(self);\n+        }\n+        let mut fill = [0u8, ..4];\n+        let len = self.fill.encode_utf8(fill);\n+        for _ in range(0, padding) {\n+            self.buf.write(fill.slice_to(len));\n+        }\n+        if !self.alignleft {\n+            f(self);\n+        }\n+    }\n }\n \n /// This is a function which calls are emitted to by the compiler itself to\n@@ -279,60 +396,53 @@ impl Bool for bool {\n \n impl<'self> String for &'self str {\n     fn fmt(s: & &'self str, f: &mut Formatter) {\n-        // XXX: formatting args\n-        f.buf.write(s.as_bytes())\n+        f.pad(*s);\n     }\n }\n \n impl Char for char {\n     fn fmt(c: &char, f: &mut Formatter) {\n-        // XXX: formatting args\n-        // XXX: shouldn't require an allocation\n-        let mut s = ~\"\";\n-        s.push_char(*c);\n-        f.buf.write(s.as_bytes());\n+        let mut utf8 = [0u8, ..4];\n+        let amt = c.encode_utf8(utf8);\n+        let s: &str = unsafe { cast::transmute(utf8.slice_to(amt)) };\n+        String::fmt(&s, f);\n     }\n }\n \n impl Signed for int {\n     fn fmt(c: &int, f: &mut Formatter) {\n-        // XXX: formatting args\n-        do int::to_str_bytes(*c, 10) |buf| {\n-            f.buf.write(buf);\n+        do uint::to_str_bytes(c.abs() as uint, 10) |buf| {\n+            f.pad_integral(buf, \"\", *c >= 0);\n         }\n     }\n }\n \n impl Unsigned for uint {\n     fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n         do uint::to_str_bytes(*c, 10) |buf| {\n-            f.buf.write(buf);\n+            f.pad_integral(buf, \"\", true);\n         }\n     }\n }\n \n impl Octal for uint {\n     fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n         do uint::to_str_bytes(*c, 8) |buf| {\n-            f.buf.write(buf);\n+            f.pad_integral(buf, \"0o\", true);\n         }\n     }\n }\n \n impl LowerHex for uint {\n     fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n         do uint::to_str_bytes(*c, 16) |buf| {\n-            f.buf.write(buf);\n+            f.pad_integral(buf, \"0x\", true);\n         }\n     }\n }\n \n impl UpperHex for uint {\n     fn fmt(c: &uint, f: &mut Formatter) {\n-        // XXX: formatting args\n         do uint::to_str_bytes(*c, 16) |buf| {\n             let mut local = [0u8, ..16];\n             for (l, &b) in local.mut_iter().zip(buf.iter()) {\n@@ -341,16 +451,29 @@ impl UpperHex for uint {\n                     _ => b,\n                 };\n             }\n-            f.buf.write(local.slice_to(buf.len()));\n+            f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n         }\n     }\n }\n \n impl<T> Poly for T {\n     fn fmt(t: &T, f: &mut Formatter) {\n-        // XXX: formatting args\n-        let s = sys::log_str(t);\n-        f.buf.write(s.as_bytes());\n+        match (f.width, f.precision) {\n+            (None, None) => {\n+                // XXX: sys::log_str should have a variant which takes a stream\n+                //      and we should directly call that (avoids unnecessary\n+                //      allocations)\n+                let s = sys::log_str(t);\n+                f.buf.write(s.as_bytes());\n+            }\n+\n+            // If we have a specified width for formatting, then we have to make\n+            // this allocation of a new string\n+            _ => {\n+                let s = sys::log_str(t);\n+                f.pad(s);\n+            }\n+        }\n     }\n }\n "}, {"sha": "10df45922b5ea7be881cc610de23c087b4328586", "filename": "src/libstd/str.rs", "status": "modified", "additions": 12, "deletions": 41, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -33,6 +33,7 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n+use unstable::raw::{Repr, Slice};\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n \n@@ -758,15 +759,7 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as uint)\n )\n \n-// UTF-8 tags and ranges\n static TAG_CONT_U8: u8 = 128u8;\n-static TAG_CONT: uint = 128u;\n-static MAX_ONE_B: uint = 128u;\n-static TAG_TWO_B: uint = 192u;\n-static MAX_TWO_B: uint = 2048u;\n-static TAG_THREE_B: uint = 224u;\n-static MAX_THREE_B: uint = 65536u;\n-static TAG_FOUR_B: uint = 240u;\n static MAX_UNICODE: uint = 1114112u;\n \n /// Unsafe operations\n@@ -1988,40 +1981,18 @@ impl OwnedStr for ~str {\n     #[inline]\n     fn push_char(&mut self, c: char) {\n         assert!((c as uint) < MAX_UNICODE); // FIXME: #7609: should be enforced on all `char`\n+        let cur_len = self.len();\n+        self.reserve_at_least(cur_len + 4); // may use up to 4 bytes\n+\n+        // Attempt to not use an intermediate buffer by just pushing bytes\n+        // directly onto this string.\n         unsafe {\n-            let code = c as uint;\n-            let nb = if code < MAX_ONE_B { 1u }\n-            else if code < MAX_TWO_B { 2u }\n-            else if code < MAX_THREE_B { 3u }\n-            else { 4u };\n-            let len = self.len();\n-            let new_len = len + nb;\n-            self.reserve_at_least(new_len);\n-            let off = len as int;\n-            do self.as_mut_buf |buf, _len| {\n-                match nb {\n-                    1u => {\n-                        *ptr::mut_offset(buf, off) = code as u8;\n-                    }\n-                    2u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    3u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    4u => {\n-                        *ptr::mut_offset(buf, off) = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1) = (code >> 12u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 3) = (code & 63u | TAG_CONT) as u8;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            raw::set_len(self, new_len);\n+            let v = self.repr();\n+            let len = c.encode_utf8(cast::transmute(Slice {\n+                data: ((&(*v).data) as *u8).offset(cur_len as int),\n+                len: 4,\n+            }));\n+            raw::set_len(self, cur_len + len);\n         }\n     }\n "}, {"sha": "bdf84604fb37f852bf3898ba49efe3d800c996b6", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -56,6 +56,7 @@ impl<'self, T> Repr<Slice<T>> for &'self [T] {}\n impl<'self> Repr<Slice<u8>> for &'self str {}\n impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n+impl Repr<*String> for ~str {}\n \n // sure would be nice to have this\n // impl<T> Repr<*Vec<T>> for ~[T] {}"}, {"sha": "66b091849c0cd7ab5a709d72190a781dff06e700", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -127,7 +127,13 @@ impl Context {\n                 }\n             }\n             parse::Argument(ref arg) => {\n-                // argument first (it's first in the format string)\n+                // width/precision first, if they have implicit positional\n+                // parameters it makes more sense to consume them first.\n+                self.verify_count(arg.format.width);\n+                self.verify_count(arg.format.precision);\n+\n+                // argument second, if it's an implicit positional parameter\n+                // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentNext => {\n                         let i = self.next_arg;\n@@ -144,10 +150,6 @@ impl Context {\n                 } else { Known(arg.format.ty.to_managed()) };\n                 self.verify_arg_type(pos, ty);\n \n-                // width/precision next\n-                self.verify_count(arg.format.width);\n-                self.verify_count(arg.format.precision);\n-\n                 // and finally the method being applied\n                 match arg.method {\n                     None => {}"}, {"sha": "df61ac76d3676ba2cefd57814eddd5c00826f003", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 92, "deletions": 37, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "patch": "@@ -22,50 +22,105 @@ impl fmt::Signed for B {\n }\n \n pub fn main() {\n-    fn t(a: ~str, b: &str) { assert_eq!(a, b.to_owned()); }\n+    macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n     // Make sure there's a poly formatter that takes anything\n-    t(ifmt!(\"{}\", 1), \"1\");\n-    t(ifmt!(\"{}\", A), \"{}\");\n-    t(ifmt!(\"{}\", ()), \"()\");\n-    t(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+    t!(ifmt!(\"{}\", 1), \"1\");\n+    t!(ifmt!(\"{}\", A), \"{}\");\n+    t!(ifmt!(\"{}\", ()), \"()\");\n+    t!(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n-    t(ifmt!(\"\"), \"\");\n-    t(ifmt!(\"hello\"), \"hello\");\n-    t(ifmt!(\"hello \\\\{\"), \"hello {\");\n+    t!(ifmt!(\"\"), \"\");\n+    t!(ifmt!(\"hello\"), \"hello\");\n+    t!(ifmt!(\"hello \\\\{\"), \"hello {\");\n \n     // At least exercise all the formats\n-    t(ifmt!(\"{:b}\", true), \"true\");\n-    t(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n-    t(ifmt!(\"{:d}\", 10), \"10\");\n-    t(ifmt!(\"{:i}\", 10), \"10\");\n-    t(ifmt!(\"{:u}\", 10u), \"10\");\n-    t(ifmt!(\"{:o}\", 10u), \"12\");\n-    t(ifmt!(\"{:x}\", 10u), \"a\");\n-    t(ifmt!(\"{:X}\", 10u), \"A\");\n-    t(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n-    t(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n-    t(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n-    t(ifmt!(\"{:d}\", A), \"aloha\");\n-    t(ifmt!(\"{:d}\", B), \"adios\");\n-    t(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n-    t(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n-    t(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n-    t(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n-    t(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n-    t(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n+    t!(ifmt!(\"{:b}\", true), \"true\");\n+    t!(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t!(ifmt!(\"{:d}\", 10), \"10\");\n+    t!(ifmt!(\"{:i}\", 10), \"10\");\n+    t!(ifmt!(\"{:u}\", 10u), \"10\");\n+    t!(ifmt!(\"{:o}\", 10u), \"12\");\n+    t!(ifmt!(\"{:x}\", 10u), \"a\");\n+    t!(ifmt!(\"{:X}\", 10u), \"A\");\n+    t!(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n+    t!(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t!(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t!(ifmt!(\"{:d}\", A), \"aloha\");\n+    t!(ifmt!(\"{:d}\", B), \"adios\");\n+    t!(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t!(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t!(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t!(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t!(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t!(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n \n     // Methods should probably work\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n-    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n-    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n-    t(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n-    t(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t!(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t!(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t!(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+\n+    // Formatting strings and their arguments\n+    t!(ifmt!(\"{:s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:>4s}\", \"a\"), \"   a\");\n+    t!(ifmt!(\"{:<4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:.4s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:4.4s}\", \"a\"), \"a   \");\n+    t!(ifmt!(\"{:4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:<4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:>4.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:>10.4s}\", \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aaa\"), \"aaa\");\n+    t!(ifmt!(\"{:2.4s}\", \"aa\"), \"aa\");\n+    t!(ifmt!(\"{:2.4s}\", \"a\"), \"a \");\n+    t!(ifmt!(\"{:0>2s}\", \"a\"), \"0a\");\n+    t!(ifmt!(\"{:.*s}\", 4, \"aaaaaaaaaaaaaaaaaa\"), \"aaaa\");\n+    t!(ifmt!(\"{:.1$s}\", \"aaaaaaaaaaaaaaaaaa\", 4), \"aaaa\");\n+    t!(ifmt!(\"{:1$s}\", \"a\", 4), \"a   \");\n+    t!(ifmt!(\"{:-#s}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{:+#s}\", \"a\"), \"a\");\n+\n+    // Precision overrides 0-padding\n+    // FIXME #2481: Recent gcc's report some of these as warnings\n+    /*t!(ifmt!(\"{:0>6.5d}\", 0), ~\" 00000\");*/\n+    /*t!(ifmt!(\"{:0>6.5u}\", 0u), ~\" 00000\");*/\n+    /*t!(ifmt!(\"{:0>6.5x}\", 0u), ~\" 00000\");*/\n+    /*t!(ifmt!(\"{:0>6.5d}\", 10), ~\" 00010\");*/\n+    /*t!(ifmt!(\"{:0>6.5d}\", -10), ~\"-00010\");*/\n+    /*t!(ifmt!(\"{:0>6.5u}\", 10u), ~\" 00010\");*/\n+    /*t!(ifmt!(\"{:0>6.5s}\", ~\"t!\"), ~\"  t!\");*/\n+    /*t!(ifmt!(\"{:0>6.5c}\", 'A'), ~\"     A\");*/\n+    /*t!(ifmt!(\"{:0>6.5x}\", 127u), ~\" 0007f\");*/\n+    /*t!(ifmt!(\"{:0>6.5X}\", 127u), ~\" 0007F\");*/\n+    /*t!(ifmt!(\"{:0>6.5o}\", 10u), ~\" 00012\");*/\n+\n+    // Signed combinations\n+    /*t!(ifmt!(\"{:5d}\", 1), ~\"    1\");*/\n+    /*t!(ifmt!(\"{: >5d}\", -1), ~\"   -1\");*/\n+    /*t!(ifmt!(\"{:+5d}\", 1), ~\"   +1\");*/\n+    /*t!(ifmt!(\"{:+5d}\", -1), ~\"   -1\");*/\n+    /*t!(ifmt!(\"{:0>5d}\", 1), ~\" 0001\");*/\n+    /*t!(ifmt!(\"{:0>5d}\", -1), ~\"-0001\");*/\n+    /*t!(ifmt!(\"{:0>+5d}\", 1), ~\"+0001\");*/\n+    /*t!(ifmt!(\"{:0>+5d}\", -1), ~\"-0001\");*/\n+    /*t!(ifmt!(\"%- 5d\", 1), ~\" 1   \");*/\n+    /*t!(ifmt!(\"%- 5d\", -1), ~\"-1   \");*/\n+    /*t!(ifmt!(\"%-+5d\", 1), ~\"+1   \");*/\n+    /*t!(ifmt!(\"%-+5d\", -1), ~\"-1   \");*/\n+    /*t!(ifmt!(\"%- 05d\", 1), ~\" 1   \");*/\n+    /*t!(ifmt!(\"%- 05d\", -1), ~\"-1   \");*/\n+    /*t!(ifmt!(\"%-+05d\", 1), ~\"+1   \");*/\n+    /*t!(ifmt!(\"%-+05d\", -1), ~\"-1   \");*/\n }\n "}]}