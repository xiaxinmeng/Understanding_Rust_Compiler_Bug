{"sha": "c6669776e1174170c157b685a66026d1a31ede85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjY5Nzc2ZTExNzQxNzBjMTU3YjY4NWE2NjAyNmQxYTMxZWRlODU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-06-22T12:23:31Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-06-22T22:21:11Z"}, "message": "Rewrite `convert_tokens` to use an explicit stack", "tree": {"sha": "d842fcbf296548edee40553157fef124ce9aab74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d842fcbf296548edee40553157fef124ce9aab74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6669776e1174170c157b685a66026d1a31ede85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6669776e1174170c157b685a66026d1a31ede85", "html_url": "https://github.com/rust-lang/rust/commit/c6669776e1174170c157b685a66026d1a31ede85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6669776e1174170c157b685a66026d1a31ede85/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e", "html_url": "https://github.com/rust-lang/rust/commit/6504c3c32a9795173fc0c9c94befe7f5d0e7fe9e"}], "stats": {"total": 120, "additions": 80, "deletions": 40}, "files": [{"sha": "ae6058cbc8892e75fe70153663fdce6b88218faa", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 80, "deletions": 40, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c6669776e1174170c157b685a66026d1a31ede85/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6669776e1174170c157b685a66026d1a31ede85/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=c6669776e1174170c157b685a66026d1a31ede85", "patch": "@@ -122,20 +122,25 @@ pub fn parse_exprs_with_sep(tt: &tt::Subtree, sep: char) -> Vec<tt::Subtree> {\n }\n \n fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n-    let mut subtree = tt::Subtree { delimiter: None, ..Default::default() };\n-    while conv.peek().is_some() {\n-        collect_leaf(conv, &mut subtree.token_trees);\n+    struct StackEntry {\n+        subtree: tt::Subtree,\n+        idx: usize,\n+        open_range: TextRange,\n     }\n-    if subtree.token_trees.len() == 1 {\n-        if let tt::TokenTree::Subtree(first) = &subtree.token_trees[0] {\n-            return first.clone();\n-        }\n-    }\n-    return subtree;\n \n-    fn collect_leaf<C: TokenConvertor>(conv: &mut C, result: &mut Vec<tt::TokenTree>) {\n+    let entry = StackEntry {\n+        subtree: tt::Subtree { delimiter: None, ..Default::default() },\n+        // never used (delimiter is `None`)\n+        idx: !0,\n+        open_range: TextRange::empty(TextSize::of('.')),\n+    };\n+    let mut stack = vec![entry];\n+\n+    loop {\n+        let entry = stack.last_mut().unwrap();\n+        let result = &mut entry.subtree.token_trees;\n         let (token, range) = match conv.bump() {\n-            None => return,\n+            None => break,\n             Some(it) => it,\n         };\n \n@@ -144,44 +149,40 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n             if let Some(tokens) = conv.convert_doc_comment(&token) {\n                 result.extend(tokens);\n             }\n-            return;\n+            continue;\n         }\n \n         result.push(if k.is_punct() && k != UNDERSCORE {\n             assert_eq!(range.len(), TextSize::of('.'));\n+\n+            if let Some(delim) = entry.subtree.delimiter {\n+                let expected = match delim.kind {\n+                    tt::DelimiterKind::Parenthesis => T![')'],\n+                    tt::DelimiterKind::Brace => T!['}'],\n+                    tt::DelimiterKind::Bracket => T![']'],\n+                };\n+\n+                if k == expected {\n+                    let entry = stack.pop().unwrap();\n+                    conv.id_alloc().close_delim(entry.idx, Some(range));\n+                    stack.last_mut().unwrap().subtree.token_trees.push(entry.subtree.into());\n+                    continue;\n+                }\n+            }\n+\n             let delim = match k {\n-                T!['('] => Some((tt::DelimiterKind::Parenthesis, T![')'])),\n-                T!['{'] => Some((tt::DelimiterKind::Brace, T!['}'])),\n-                T!['['] => Some((tt::DelimiterKind::Bracket, T![']'])),\n+                T!['('] => Some(tt::DelimiterKind::Parenthesis),\n+                T!['{'] => Some(tt::DelimiterKind::Brace),\n+                T!['['] => Some(tt::DelimiterKind::Bracket),\n                 _ => None,\n             };\n \n-            if let Some((kind, closed)) = delim {\n+            if let Some(kind) = delim {\n                 let mut subtree = tt::Subtree::default();\n                 let (id, idx) = conv.id_alloc().open_delim(range);\n                 subtree.delimiter = Some(tt::Delimiter { id, kind });\n-\n-                while conv.peek().map_or(false, |it| it.kind() != closed) {\n-                    collect_leaf(conv, &mut subtree.token_trees);\n-                }\n-                let last_range = match conv.bump() {\n-                    None => {\n-                        // For error resilience, we insert an char punct for the opening delim here\n-                        conv.id_alloc().close_delim(idx, None);\n-                        let leaf: tt::Leaf = tt::Punct {\n-                            id: conv.id_alloc().alloc(range),\n-                            char: token.to_char().unwrap(),\n-                            spacing: tt::Spacing::Alone,\n-                        }\n-                        .into();\n-                        result.push(leaf.into());\n-                        result.extend(subtree.token_trees);\n-                        return;\n-                    }\n-                    Some(it) => it.1,\n-                };\n-                conv.id_alloc().close_delim(idx, Some(last_range));\n-                subtree.into()\n+                stack.push(StackEntry { subtree, idx, open_range: range });\n+                continue;\n             } else {\n                 let spacing = match conv.peek() {\n                     Some(next)\n@@ -233,14 +234,44 @@ fn convert_tokens<C: TokenConvertor>(conv: &mut C) -> tt::Subtree {\n                         id: conv.id_alloc().alloc(r),\n                     });\n                     result.push(ident.into());\n-                    return;\n+                    continue;\n                 }\n-                _ => return,\n+                _ => continue,\n             };\n \n             leaf.into()\n         });\n     }\n+\n+    // If we get here, we've consumed all input tokens.\n+    // We might have more than one subtree in the stack, if the delimiters are improperly balanced.\n+    // Merge them so we're left with one.\n+    while stack.len() > 1 {\n+        let entry = stack.pop().unwrap();\n+        let parent = stack.last_mut().unwrap();\n+\n+        conv.id_alloc().close_delim(entry.idx, None);\n+        let leaf: tt::Leaf = tt::Punct {\n+            id: conv.id_alloc().alloc(entry.open_range),\n+            char: match entry.subtree.delimiter.unwrap().kind {\n+                tt::DelimiterKind::Parenthesis => '(',\n+                tt::DelimiterKind::Brace => '{',\n+                tt::DelimiterKind::Bracket => '[',\n+            },\n+            spacing: tt::Spacing::Alone,\n+        }\n+        .into();\n+        parent.subtree.token_trees.push(leaf.into());\n+        parent.subtree.token_trees.extend(entry.subtree.token_trees);\n+    }\n+\n+    let subtree = stack.pop().unwrap().subtree;\n+    if subtree.token_trees.len() == 1 {\n+        if let tt::TokenTree::Subtree(first) = &subtree.token_trees[0] {\n+            return first.clone();\n+        }\n+    }\n+    subtree\n }\n \n /// Returns the textual content of a doc comment block as a quoted string\n@@ -683,6 +714,7 @@ mod tests {\n         algo::{insert_children, InsertPosition},\n         ast::AstNode,\n     };\n+    use test_utils::assert_eq_text;\n \n     #[test]\n     fn convert_tt_token_source() {\n@@ -792,4 +824,12 @@ mod tests {\n         let tt = ast_to_token_tree(&struct_def).0;\n         token_tree_to_syntax_node(&tt, FragmentKind::Item).unwrap();\n     }\n+\n+    #[test]\n+    fn test_missing_closing_delim() {\n+        let source_file = ast::SourceFile::parse(\"m!(x\").tree();\n+        let node = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        let tt = ast_to_token_tree(&node).0.to_string();\n+        assert_eq_text!(&*tt, \"( x\");\n+    }\n }"}]}