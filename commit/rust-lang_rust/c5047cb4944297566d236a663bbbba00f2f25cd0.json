{"sha": "c5047cb4944297566d236a663bbbba00f2f25cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDQ3Y2I0OTQ0Mjk3NTY2ZDIzNmE2NjNiYmJiYTAwZjJmMjVjZDA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-13T21:04:00Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-24T22:33:13Z"}, "message": "Add tests for new match borrows", "tree": {"sha": "062417d6930738f22325b53131878b1b09f8d2b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/062417d6930738f22325b53131878b1b09f8d2b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5047cb4944297566d236a663bbbba00f2f25cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5047cb4944297566d236a663bbbba00f2f25cd0", "html_url": "https://github.com/rust-lang/rust/commit/c5047cb4944297566d236a663bbbba00f2f25cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5047cb4944297566d236a663bbbba00f2f25cd0/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46e247bcec13f3e1e850c3baffc23e64a8023ae4", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e247bcec13f3e1e850c3baffc23e64a8023ae4", "html_url": "https://github.com/rust-lang/rust/commit/46e247bcec13f3e1e850c3baffc23e64a8023ae4"}], "stats": {"total": 457, "additions": 457, "deletions": 0}, "files": [{"sha": "4cf5bcd6b4f683fb71cea3ab0c5a3ac3451685eb", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-3.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.rs?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,30 @@\n+// This is testing an attempt to corrupt the discriminant of the match\n+// arm in a guard, followed by an attempt to continue matching on that\n+// corrupted discriminant in the remaining match arms.\n+//\n+// Basically this is testing that our new NLL feature of emitting a\n+// fake read on each match arm is catching cases like this.\n+//\n+// This case is interesting because a borrow of **x is untracked, because **x is\n+// immutable. However, for matches we care that **x refers to the same value\n+// until we have chosen a match arm.\n+#![feature(nll)]\n+struct ForceFnOnce;\n+fn main() {\n+    let mut x = &mut &Some(&2);\n+    let force_fn_once = ForceFnOnce;\n+    match **x {\n+        None => panic!(\"unreachable\"),\n+        Some(&_) if {\n+            // ForceFnOnce needed to exploit #27282\n+            (|| { *x = &None; drop(force_fn_once); })();\n+            //~^ ERROR cannot mutably borrow `x` in match guard [E0510]\n+            false\n+        } => {}\n+        Some(&a) if { // this binds to garbage if we've corrupted discriminant\n+            println!(\"{}\", a);\n+            panic!()\n+        } => {}\n+        _ => panic!(\"unreachable\"),\n+    }\n+}"}, {"sha": "f46a42d7508176853d3c7e07edc9abd4b075008c", "filename": "src/test/ui/issues/issue-27282-mutate-before-diverging-arm-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-mutate-before-diverging-arm-3.stderr?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,14 @@\n+error[E0510]: cannot mutably borrow `x` in match guard\n+  --> $DIR/issue-27282-mutate-before-diverging-arm-3.rs:20:14\n+   |\n+LL |     match **x {\n+   |           --- value is immutable in match guard\n+...\n+LL |             (|| { *x = &None; drop(force_fn_once); })();\n+   |              ^^    - borrow occurs due to use of `x` in closure\n+   |              |\n+   |              cannot mutably borrow\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0510`."}, {"sha": "49846f620f0c010cbfd339f3d2a9651a54074679", "filename": "src/test/ui/nll/match-guards-partially-borrow.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.rs?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,164 @@\n+// Test that a (partially) mutably borrowed place can be matched on, so long as\n+// we don't have to read any values that are mutably borrowed to determine\n+// which arm to take.\n+//\n+// Test that we don't allow mutating the value being matched on in a way that\n+// changes which patterns it matches, until we have chosen an arm.\n+\n+// compile-flags: -Zdisable-ast-check-for-mutation-in-guard\n+\n+#![feature(nll)]\n+\n+fn ok_mutation_in_guard(mut q: i32) {\n+    match q {\n+        // OK, mutation doesn't change which patterns g matches\n+        _ if { q = 1; false } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn ok_indirect_mutation_in_guard(mut p: &bool) {\n+    match *p {\n+        // OK, mutation doesn't change which patterns s matches\n+        _ if {\n+            p = &true;\n+            false\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn mutation_invalidates_pattern_in_guard(mut q: bool) {\n+    match q {\n+        // s doesn't match the pattern with the guard by the end of the guard.\n+        false if {\n+            q = true; //~ ERROR\n+            true\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn mutation_invalidates_previous_pattern_in_guard(mut r: bool) {\n+    match r {\n+        // s matches a previous pattern by the end of the guard.\n+        true => (),\n+        _ if {\n+            r = true; //~ ERROR\n+            true\n+        } => (),\n+        _ => (),\n+    }\n+}\n+\n+fn match_on_borrowed_early_end(mut s: bool) {\n+    let h = &mut s;\n+    match s { //~ ERROR\n+        // s changes value between the start of the match and when its value is checked.\n+        _ if {\n+            *h = !*h;\n+            false\n+        } => (),\n+        true => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_mutation_in_guard(mut t: bool) {\n+    match t {\n+        true => (),\n+        false if {\n+            t = true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_mutation_in_guard2(mut u: bool) {\n+    match u {\n+        // Guard changes the value bound in the last pattern.\n+        _ => (),\n+        _ if {\n+            u = true; //~ ERROR\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+pub fn bad_mutation_in_guard3(mut x: Option<Option<&i32>>) {\n+    // Check that nested patterns are checked.\n+    match x {\n+        None => (),\n+        Some(None) => (),\n+        _ if {\n+            match x {\n+                Some(ref mut r) => *r = None, //~ ERROR\n+                _ => return,\n+            };\n+            false\n+        } => (),\n+        Some(Some(r)) => println!(\"{}\", r),\n+    }\n+}\n+\n+\n+fn bad_mutation_in_guard4(mut w: (&mut bool,)) {\n+    match w {\n+        // Guard changes the value bound in the last pattern.\n+        _ => (),\n+        _ if {\n+            *w.0 = true; //~ ERROR\n+            false\n+        } => (),\n+        x => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard(mut y: &bool) {\n+    match *y {\n+        true => (),\n+        false if {\n+            y = &true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard2(mut z: &bool) {\n+    match z {\n+        &true => (),\n+        &false if {\n+            z = &true; //~ ERROR\n+            false\n+        } => (),\n+        &false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard3(mut a: &bool) {\n+    // Same as bad_indirect_mutation_in_guard2, but using match ergonomics\n+    match a {\n+        true => (),\n+        false if {\n+            a = &true; //~ ERROR\n+            false\n+        } => (),\n+        false => (),\n+    }\n+}\n+\n+fn bad_indirect_mutation_in_guard4(mut b: &bool) {\n+    match b {\n+        &_ => (),\n+        &_ if {\n+            b = &true; //~ ERROR\n+            false\n+        } => (),\n+        &b => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2cbfeb886b57238558e766267ce696e4b31f32df", "filename": "src/test/ui/nll/match-guards-partially-borrow.stderr", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-guards-partially-borrow.stderr?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,132 @@\n+error[E0510]: cannot assign `q` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:35:13\n+   |\n+LL |     match q {\n+   |           - value is immutable in match guard\n+...\n+LL |             q = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         _ => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot assign `r` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:47:13\n+   |\n+LL |     match r {\n+   |           - value is immutable in match guard\n+...\n+LL |             r = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         _ => (),\n+   |         - borrow later used here\n+\n+error[E0503]: cannot use `s` because it was mutably borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:56:11\n+   |\n+LL |     let h = &mut s;\n+   |             ------ borrow of `s` occurs here\n+LL |     match s { //~ ERROR\n+   |           ^ use of borrowed `s`\n+...\n+LL |             *h = !*h;\n+   |                   -- borrow later used here\n+\n+error[E0510]: cannot assign `t` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:71:13\n+   |\n+LL |     match t {\n+   |           - value is immutable in match guard\n+...\n+LL |             t = true; //~ ERROR\n+   |             ^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0506]: cannot assign to `u` because it is borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:83:13\n+   |\n+LL |     match u {\n+   |           - borrow of `u` occurs here\n+...\n+LL |             u = true; //~ ERROR\n+   |             ^^^^^^^^ assignment to borrowed `u` occurs here\n+...\n+LL |         x => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot mutably borrow `x.0` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:97:22\n+   |\n+LL |     match x {\n+   |           - value is immutable in match guard\n+...\n+LL |                 Some(ref mut r) => *r = None, //~ ERROR\n+   |                      ^^^^^^^^^ cannot mutably borrow\n+\n+error[E0506]: cannot assign to `*w.0` because it is borrowed\n+  --> $DIR/match-guards-partially-borrow.rs:112:13\n+   |\n+LL |     match w {\n+   |           - borrow of `*w.0` occurs here\n+...\n+LL |             *w.0 = true; //~ ERROR\n+   |             ^^^^^^^^^^^ assignment to borrowed `*w.0` occurs here\n+...\n+LL |         x => (),\n+   |         - borrow later used here\n+\n+error[E0510]: cannot assign `y` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:123:13\n+   |\n+LL |     match *y {\n+   |           -- value is immutable in match guard\n+...\n+LL |             y = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0510]: cannot assign `z` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:134:13\n+   |\n+LL |     match z {\n+   |           - value is immutable in match guard\n+...\n+LL |             z = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         &false => (),\n+   |         ------ borrow later used here\n+\n+error[E0510]: cannot assign `a` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:146:13\n+   |\n+LL |     match a {\n+   |           - value is immutable in match guard\n+...\n+LL |             a = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         false => (),\n+   |         ----- borrow later used here\n+\n+error[E0510]: cannot assign `b` in match guard\n+  --> $DIR/match-guards-partially-borrow.rs:157:13\n+   |\n+LL |     match b {\n+   |           - value is immutable in match guard\n+...\n+LL |             b = &true; //~ ERROR\n+   |             ^^^^^^^^^ cannot assign\n+...\n+LL |         &b => (),\n+   |         -- borrow later used here\n+\n+error: aborting due to 11 previous errors\n+\n+Some errors occurred: E0503, E0506, E0510.\n+For more information about an error, try `rustc --explain E0503`."}, {"sha": "6a8ce03e8fd255cba0ec950ed7fc8e1924f7e944", "filename": "src/test/ui/nll/match-on-borrowed.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,95 @@\n+// Test that a (partially) mutably borrowed place can be matched on, so long as\n+// we don't have to read any values that are mutably borrowed to determine\n+// which arm to take.\n+//\n+// Test that we don't allow mutating the value being matched on in a way that\n+// changes which patterns it matches, until we have chosen an arm.\n+\n+#![feature(nll)]\n+\n+struct A(i32, i32);\n+\n+fn struct_example(mut a: A) {\n+    let x = &mut a.0;\n+    match a { // OK, no access of borrowed data\n+        _ if false => (),\n+        A(_, r) => (),\n+    }\n+    x;\n+}\n+\n+fn indirect_struct_example(mut b: &mut A) {\n+    let x = &mut b.0;\n+    match *b { // OK, no access of borrowed data\n+        _ if false => (),\n+        A(_, r) => (),\n+    }\n+    x;\n+}\n+\n+fn underscore_example(mut c: i32) {\n+    let r = &mut c;\n+    match c { // OK, no access of borrowed data (or any data at all)\n+        _ if false => (),\n+        _ => (),\n+    }\n+    r;\n+}\n+\n+enum E {\n+    V(i32, i32),\n+    W,\n+}\n+\n+fn enum_example(mut e: E) {\n+    let x = match e {\n+        E::V(ref mut x, _) => x,\n+        E::W => panic!(),\n+    };\n+    match e { // OK, no access of borrowed data\n+        _ if false => (),\n+        E::V(_, r) => (),\n+        E::W => (),\n+    }\n+    x;\n+}\n+\n+fn indirect_enum_example(mut f: &mut E) {\n+    let x = match *f {\n+        E::V(ref mut x, _) => x,\n+        E::W => panic!(),\n+    };\n+    match f { // OK, no access of borrowed data\n+        _ if false => (),\n+        E::V(_, r) => (),\n+        E::W => (),\n+    }\n+    x;\n+}\n+\n+fn match_on_muatbly_borrowed_ref(mut p: &bool) {\n+    let r = &mut p;\n+    match *p { // OK, no access at all\n+        _ if false => (),\n+        _ => (),\n+    }\n+    r;\n+}\n+\n+fn match_on_borrowed(mut t: bool) {\n+    let x = &mut t;\n+    match t {\n+        true => (), //~ ERROR\n+        false => (),\n+    }\n+    x;\n+}\n+\n+enum Never {}\n+\n+fn never_init() {\n+    let n: Never;\n+    match n {} //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "cdff29d44b85bf904ca22917546ea6f07c2b4965", "filename": "src/test/ui/nll/match-on-borrowed.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c5047cb4944297566d236a663bbbba00f2f25cd0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr?ref=c5047cb4944297566d236a663bbbba00f2f25cd0", "patch": "@@ -0,0 +1,22 @@\n+error[E0503]: cannot use `t` because it was mutably borrowed\n+  --> $DIR/match-on-borrowed.rs:82:9\n+   |\n+LL |     let x = &mut t;\n+   |             ------ borrow of `t` occurs here\n+LL |     match t {\n+LL |         true => (), //~ ERROR\n+   |         ^^^^ use of borrowed `t`\n+...\n+LL |     x;\n+   |     - borrow later used here\n+\n+error[E0381]: use of possibly uninitialized variable: `n`\n+  --> $DIR/match-on-borrowed.rs:92:11\n+   |\n+LL |     match n {} //~ ERROR\n+   |           ^ use of possibly uninitialized `n`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0381, E0503.\n+For more information about an error, try `rustc --explain E0381`."}]}