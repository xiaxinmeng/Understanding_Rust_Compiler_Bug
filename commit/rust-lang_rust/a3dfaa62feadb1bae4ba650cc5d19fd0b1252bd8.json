{"sha": "a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZGZhYTYyZmVhZGIxYmFlNGJhNjUwY2M1ZDE5ZmQwYjEyNTJiZDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:04:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:27:34Z"}, "message": "rollup merge of #20027: michaelwoerister/for-loop-var\n\nBack when for-loop iteration variables were just de-sugared into `let` bindings, debuginfo for them was created like for any other `let` binding. When the implementation approach for for-loops changed, we ceased having debuginfo for the iteration variable. This PR fixes this omission and adds a more prominent test case for it.\n\nAlso contains some minor, general cleanup of the debuginfo module.\n\nFixes #19732", "tree": {"sha": "f57cb42698c74f9cbc508d90b088c9e4a97deca0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f57cb42698c74f9cbc508d90b088c9e4a97deca0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "html_url": "https://github.com/rust-lang/rust/commit/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de7abcf6d3d2d0928fa03a7522e23f4aba0d5254", "url": "https://api.github.com/repos/rust-lang/rust/commits/de7abcf6d3d2d0928fa03a7522e23f4aba0d5254", "html_url": "https://github.com/rust-lang/rust/commit/de7abcf6d3d2d0928fa03a7522e23f4aba0d5254"}, {"sha": "87c5927b79b8eec8763659da8a3cf4561a4ceabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c5927b79b8eec8763659da8a3cf4561a4ceabd", "html_url": "https://github.com/rust-lang/rust/commit/87c5927b79b8eec8763659da8a3cf4561a4ceabd"}], "stats": {"total": 373, "additions": 302, "deletions": 71}, "files": [{"sha": "135e192a2fd49d59c3f04d2362b4940a5a9ae3b1", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "patch": "@@ -286,6 +286,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     debug!(\"iterator type is {}, datum type is {}\",\n            ppaux::ty_to_string(bcx.tcx(), iterator_type),\n            ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n+\n     let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n \n     // Create our basic blocks and set up our loop cleanups.\n@@ -365,6 +366,8 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        llpayload,\n                                        binding_cleanup_scope_id);\n \n+    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n+\n     // Codegen the body.\n     body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n     body_bcx_out ="}, {"sha": "1e5737f398a20ab5d3a4ce6febf73a1011f4ab77", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 121, "deletions": 70, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "patch": "@@ -182,7 +182,6 @@\n //! comparatively expensive to construct, though, `ty::type_id()` is still used\n //! additionally as an optimization for cases where the exact same type has been\n //! seen before (which is most of the time).\n-use self::FunctionDebugContextRepr::*;\n use self::VariableAccess::*;\n use self::VariableKind::*;\n use self::MemberOffset::*;\n@@ -679,12 +678,8 @@ impl<'tcx> CrateDebugContext<'tcx> {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    repr: FunctionDebugContextRepr,\n-}\n-\n-enum FunctionDebugContextRepr {\n-    DebugInfo(Box<FunctionDebugContextData>),\n+pub enum FunctionDebugContext {\n+    RegularContext(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -694,13 +689,13 @@ impl FunctionDebugContext {\n                    cx: &CrateContext,\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n-        match self.repr {\n-            DebugInfo(box ref data) => data,\n-            DebugInfoDisabled => {\n+        match *self {\n+            FunctionDebugContext::RegularContext(box ref data) => data,\n+            FunctionDebugContext::DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n             }\n-            FunctionWithoutDebugInfo => {\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::should_be_ignored_message());\n             }\n@@ -844,6 +839,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n /// Creates debug information for the given local variable.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// local in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n     if fn_should_be_ignored(bcx.fcx) {\n@@ -852,11 +849,10 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n \n     let cx = bcx.ccx();\n     let def_map = &cx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, path1| {\n-        let var_ident = path1.node;\n-\n-        let datum = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -865,10 +861,15 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             }\n         };\n \n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            cx.sess().span_bug(span, \"debuginfo::create_local_var_metadata() - \\\n+                                      Referenced variable location is not an alloca!\");\n+        }\n+\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident,\n+                      var_ident.node,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -981,7 +982,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // for the binding. For ByRef bindings that's a `T*` but for ByMove bindings we\n     // actually have `T**`. So to get the actual variable we need to dereference once\n     // more. For ByCopy we just use the stack slot we created for the binding.\n-    let var_type = match binding.trmode {\n+    let var_access = match binding.trmode {\n         TrByCopy(llbinding) => DirectVariable {\n             alloca: llbinding\n         },\n@@ -998,27 +999,31 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   variable_ident,\n                   binding.ty,\n                   scope_metadata,\n-                  var_type,\n+                  var_access,\n                   LocalVariable,\n                   binding.span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// argument in `bcx.fcx.lllocals`.\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n+    let def_map = &bcx.tcx().def_map;\n+    let scope_metadata = bcx\n+                         .fcx\n+                         .debug_context\n+                         .get_ref(bcx.ccx(), arg.pat.span)\n+                         .fn_metadata;\n+    let locals = bcx.fcx.lllocals.borrow();\n \n-    let def_map = &cx.tcx().def_map;\n-    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n-\n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, path1| {\n-        let llarg = match bcx.fcx.lllocals.borrow().get(&node_id).cloned() {\n+    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n@@ -1027,28 +1032,72 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null_mut() {\n-            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n-                                    Referenced variable location is not an alloca!\");\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n         }\n \n         let argument_index = {\n-            let counter = &fcx.debug_context.get_ref(cx, span).argument_counter;\n+            let counter = &bcx\n+                          .fcx\n+                          .debug_context\n+                          .get_ref(bcx.ccx(), span)\n+                          .argument_counter;\n             let argument_index = counter.get();\n             counter.set(argument_index + 1);\n             argument_index\n         };\n \n         declare_local(bcx,\n-                      path1.node,\n-                      llarg.ty,\n+                      var_ident.node,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llarg.val },\n+                      DirectVariable { alloca: datum.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n }\n \n+/// Creates debug information for the given for-loop variable.\n+///\n+/// This function assumes that there's a datum for each pattern component of the\n+/// loop variable in `bcx.fcx.lllocals`.\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let def_map = &bcx.tcx().def_map;\n+    let locals = bcx.fcx.lllocals.borrow();\n+\n+    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n+        let datum = match locals.get(&node_id) {\n+            Some(datum) => datum,\n+            None => {\n+                bcx.sess().span_bug(span,\n+                    format!(\"no entry in lllocals table for {}\",\n+                            node_id).as_slice());\n+            }\n+        };\n+\n+        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n+            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n+                                       Referenced variable location is not an alloca!\");\n+        }\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      var_ident.node,\n+                      datum.ty,\n+                      scope_metadata,\n+                      DirectVariable { alloca: datum.val },\n+                      LocalVariable,\n+                      span);\n+    })\n+}\n+\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n@@ -1117,13 +1166,13 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n-    match fcx.debug_context.repr {\n-        DebugInfoDisabled => return,\n-        FunctionWithoutDebugInfo => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::DebugInfoDisabled => return,\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        DebugInfo(box ref function_debug_context) => {\n+        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1160,8 +1209,8 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context.repr {\n-        DebugInfo(box ref data) => {\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1179,7 +1228,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                param_substs: &Substs<'tcx>,\n                                                llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n-        return FunctionDebugContext { repr: DebugInfoDisabled };\n+        return FunctionDebugContext::DebugInfoDisabled;\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n@@ -1189,7 +1238,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     if fn_ast_id == ast::DUMMY_NODE_ID {\n         // This is a function not linked to any source location, so don't\n         // generate debuginfo for it.\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let empty_generics = ast_util::empty_generics();\n@@ -1199,7 +1248,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(item.attrs.as_slice()) {\n-                return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+                return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n             match item.node {\n@@ -1216,9 +1265,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **item {\n                 ast::MethodImplItem(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1257,9 +1304,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match **trait_method {\n                 ast::ProvidedMethod(ref method) => {\n                     if contains_nodebug_attribute(method.attrs.as_slice()) {\n-                        return FunctionDebugContext {\n-                            repr: FunctionWithoutDebugInfo\n-                        };\n+                        return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n                     (method.pe_ident(),\n@@ -1280,7 +1325,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeForeignItem(..) |\n         ast_map::NodeVariant(..) |\n         ast_map::NodeStructCtor(..) => {\n-            return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+            return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n@@ -1289,7 +1334,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == codemap::DUMMY_SP {\n-        return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n+        return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n     let loc = span_start(cx, span);\n@@ -1356,22 +1401,23 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n     });\n \n+    let scope_map = create_scope_map(cx,\n+                                     fn_decl.inputs.as_slice(),\n+                                     &*top_level_block,\n+                                     fn_metadata,\n+                                     fn_ast_id);\n+\n     // Initialize fn debug context (including scope map and namespace map)\n     let fn_debug_context = box FunctionDebugContextData {\n-        scope_map: RefCell::new(NodeMap::new()),\n+        scope_map: RefCell::new(scope_map),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    populate_scope_map(cx,\n-                       fn_decl.inputs.as_slice(),\n-                       &*top_level_block,\n-                       fn_metadata,\n-                       fn_ast_id,\n-                       &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n+\n+    return FunctionDebugContext::RegularContext(fn_debug_context);\n \n     fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                         fn_ast_id: ast::NodeId,\n@@ -3134,8 +3180,8 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n-    match fcx.debug_context.repr {\n-        DebugInfo(_) => false,\n+    match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(_) => false,\n         _ => true\n     }\n }\n@@ -3169,12 +3215,14 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // what belongs to which scope, creating DIScope DIEs along the way, and\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n-fn populate_scope_map(cx: &CrateContext,\n-                      args: &[ast::Arg],\n-                      fn_entry_block: &ast::Block,\n-                      fn_metadata: DISubprogram,\n-                      fn_ast_id: ast::NodeId,\n-                      scope_map: &mut NodeMap<DIScope>) {\n+fn create_scope_map(cx: &CrateContext,\n+                    args: &[ast::Arg],\n+                    fn_entry_block: &ast::Block,\n+                    fn_metadata: DISubprogram,\n+                    fn_ast_id: ast::NodeId)\n+                 -> NodeMap<DIScope> {\n+    let mut scope_map = NodeMap::new();\n+\n     let def_map = &cx.tcx().def_map;\n \n     struct ScopeStackEntry {\n@@ -3200,11 +3248,14 @@ fn populate_scope_map(cx: &CrateContext,\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n-                   scope_map,\n+                   &mut scope_map,\n                    |cx, scope_stack, scope_map| {\n         walk_block(cx, fn_entry_block, scope_stack, scope_map);\n     });\n \n+    return scope_map;\n+\n+\n     // local helper functions for walking the AST.\n     fn with_new_scope<F>(cx: &CrateContext,\n                          scope_span: Span,\n@@ -3440,7 +3491,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::PatMac(_) => {\n-                cx.sess().span_bug(pat.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(pat.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n         }\n@@ -3526,7 +3577,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprIfLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded if-let.\");\n             }\n \n@@ -3543,7 +3594,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprWhileLet(..) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded while-let.\");\n             }\n \n@@ -3568,7 +3619,7 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                cx.sess().span_bug(exp.span, \"debuginfo::create_scope_map() - \\\n                                               Found unexpanded macro.\");\n             }\n "}, {"sha": "19a82ee5e67b3f5a702dfbf4e02b78ad0d6af303", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// gdb-command:print x\n+// gdb-check:$1 = 400\n+// gdb-command:print y\n+// gdb-check:$2 = 401.5\n+// gdb-command:print z\n+// gdb-check:$3 = true\n+// gdb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// gdb-command:print/x _i8\n+// gdb-check:$4 = 0x6f\n+// gdb-command:print/x _u8\n+// gdb-check:$5 = 0x70\n+// gdb-command:print _i16\n+// gdb-check:$6 = -113\n+// gdb-command:print _u16\n+// gdb-check:$7 = 114\n+// gdb-command:print _i32\n+// gdb-check:$8 = -115\n+// gdb-command:print _u32\n+// gdb-check:$9 = 116\n+// gdb-command:print _i64\n+// gdb-check:$10 = -117\n+// gdb-command:print _u64\n+// gdb-check:$11 = 118\n+// gdb-command:print _f32\n+// gdb-check:$12 = 119.5\n+// gdb-command:print _f64\n+// gdb-check:$13 = 120.5\n+// gdb-command:continue\n+\n+// MORE COMPLEX CASE\n+// gdb-command:print v1\n+// gdb-check:$14 = 80000\n+// gdb-command:print x1\n+// gdb-check:$15 = 8000\n+// gdb-command:print *y1\n+// gdb-check:$16 = 80001.5\n+// gdb-command:print z1\n+// gdb-check:$17 = false\n+// gdb-command:print *x2\n+// gdb-check:$18 = -30000\n+// gdb-command:print y2\n+// gdb-check:$19 = -300001.5\n+// gdb-command:print *z2\n+// gdb-check:$20 = true\n+// gdb-command:print v2\n+// gdb-check:$21 = 854237.5\n+// gdb-command:continue\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:type format add --format hex char\n+// lldb-command:type format add --format hex 'unsigned char'\n+\n+// lldb-command:run\n+\n+// DESTRUCTURED STRUCT\n+// lldb-command:print x\n+// lldb-check:[...]$0 = 400\n+// lldb-command:print y\n+// lldb-check:[...]$1 = 401.5\n+// lldb-command:print z\n+// lldb-check:[...]$2 = true\n+// lldb-command:continue\n+\n+// DESTRUCTURED TUPLE\n+// lldb-command:print _i8\n+// lldb-check:[...]$3 = 0x6f\n+// lldb-command:print _u8\n+// lldb-check:[...]$4 = 0x70\n+// lldb-command:print _i16\n+// lldb-check:[...]$5 = -113\n+// lldb-command:print _u16\n+// lldb-check:[...]$6 = 114\n+// lldb-command:print _i32\n+// lldb-check:[...]$7 = -115\n+// lldb-command:print _u32\n+// lldb-check:[...]$8 = 116\n+// lldb-command:print _i64\n+// lldb-check:[...]$9 = -117\n+// lldb-command:print _u64\n+// lldb-check:[...]$10 = 118\n+// lldb-command:print _f32\n+// lldb-check:[...]$11 = 119.5\n+// lldb-command:print _f64\n+// lldb-check:[...]$12 = 120.5\n+// lldb-command:continue\n+\n+// MORE COMPLEX CASE\n+// lldb-command:print v1\n+// lldb-check:[...]$13 = 80000\n+// lldb-command:print x1\n+// lldb-check:[...]$14 = 8000\n+// lldb-command:print *y1\n+// lldb-check:[...]$15 = 80001.5\n+// lldb-command:print z1\n+// lldb-check:[...]$16 = false\n+// lldb-command:print *x2\n+// lldb-check:[...]$17 = -30000\n+// lldb-command:print y2\n+// lldb-check:[...]$18 = -300001.5\n+// lldb-command:print *z2\n+// lldb-check:[...]$19 = true\n+// lldb-command:print v2\n+// lldb-check:[...]$20 = 854237.5\n+// lldb-command:continue\n+\n+\n+struct Struct {\n+    x: i16,\n+    y: f32,\n+    z: bool\n+}\n+\n+fn main() {\n+\n+    let s = Struct {\n+        x: 400,\n+        y: 401.5,\n+        z: true\n+    };\n+\n+    for &Struct { x, y, z } in [s].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let tuple: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64) =\n+        (0x6f, 0x70, -113, 114, -115, 116, -117, 118, 119.5, 120.5);\n+\n+    for &(_i8, _u8, _i16, _u16, _i32, _u32, _i64, _u64, _f32, _f64) in [tuple].iter() {\n+        zzz(); // #break\n+    }\n+\n+    let more_complex: (i32, &Struct, Struct, Box<f64>) =\n+        (80000,\n+         &Struct {\n+            x: 8000,\n+            y: 80001.5,\n+            z: false\n+         },\n+         Struct {\n+            x: -30000,\n+            y: -300001.5,\n+            z: true\n+         },\n+         box 854237.5);\n+\n+    for &(v1,\n+          &Struct { x: x1, y: ref y1, z: z1 },\n+          Struct { x: ref x2, y: y2, z: ref z2 },\n+          box v2) in [more_complex].iter() {\n+        zzz(); // #break\n+    }\n+}\n+\n+fn zzz() {()}"}, {"sha": "7636ffdb07dcd6a02a54e656d3db53d5a5a9bd75", "filename": "src/test/debuginfo/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-for-loop.rs?ref=a3dfaa62feadb1bae4ba650cc5d19fd0b1252bd8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // ignore-android: FIXME(#10381)\n-// ignore-test: Not sure what is going on here --pcwalton\n // min-lldb-version: 310\n \n // compile-flags:-g"}]}