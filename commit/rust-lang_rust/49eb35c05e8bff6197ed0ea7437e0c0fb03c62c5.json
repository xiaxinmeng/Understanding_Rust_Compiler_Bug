{"sha": "49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZWIzNWMwNWU4YmZmNjE5N2VkMGVhNzQzN2UwYzBmYjAzYzYyYzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-04-29T17:47:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-05-14T07:45:11Z"}, "message": "linker: More systematic handling of CRT objects", "tree": {"sha": "612f1cbb26c12ba485b7a646651c271c2a276e82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/612f1cbb26c12ba485b7a646651c271c2a276e82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "html_url": "https://github.com/rust-lang/rust/commit/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23ffeea307c31f0c20ebb5a15d5171e0c414629d", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ffeea307c31f0c20ebb5a15d5171e0c414629d", "html_url": "https://github.com/rust-lang/rust/commit/23ffeea307c31f0c20ebb5a15d5171e0c414629d"}], "stats": {"total": 557, "additions": 405, "deletions": 152}, "files": [{"sha": "c56114f14caa9744da7b48530ca0a49ac687121a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -125,15 +125,16 @@ fn copy_third_party_objects(\n         target_deps.push(target);\n     };\n \n-    // Copies the crt(1,i,n).o startup objects\n+    // Copies the CRT objects.\n     //\n-    // Since musl supports fully static linking, we can cross link for it even\n-    // with a glibc-targeting toolchain, given we have the appropriate startup\n-    // files. As those shipped with glibc won't work, copy the ones provided by\n-    // musl so we have them on linux-gnu hosts.\n+    // rustc historically provides a more self-contained installation for musl targets\n+    // not requiring the presence of a native musl toolchain. For example, it can fall back\n+    // to using gcc from a glibc-targeting toolchain for linking.\n+    // To do that we have to distribute musl startup objects as a part of Rust toolchain\n+    // and link with them manually in the self-contained mode.\n     if target.contains(\"musl\") {\n         let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n-        for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n+        for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n             copy_and_stamp(&srcdir, obj);\n         }\n     } else if target.ends_with(\"-wasi\") {"}, {"sha": "3b9355404ea491bb7ccd5b9ac4faf8c7cc06ab2d", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 86, "deletions": 61, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -11,7 +11,9 @@ use rustc_session::search_paths::PathKind;\n /// need out of the shared crate context before we get rid of it.\n use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, RelroLevel};\n+use rustc_target::spec::crt_objects::CrtObjectsFallback;\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel};\n \n use super::archive::ArchiveBuilder;\n use super::command::Command;\n@@ -1130,33 +1132,70 @@ fn exec_linker(\n     }\n }\n \n-/// Add begin object files defined by the target spec.\n-fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n-    let pre_link_objects = if crate_type == CrateType::Executable {\n-        &sess.target.target.options.pre_link_objects_exe\n-    } else {\n-        &sess.target.target.options.pre_link_objects_dll\n+fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n+    let kind = match (crate_type, sess.crt_static(Some(crate_type)), sess.relocation_model()) {\n+        (CrateType::Executable, false, RelocModel::Pic) => LinkOutputKind::DynamicPicExe,\n+        (CrateType::Executable, false, _) => LinkOutputKind::DynamicNoPicExe,\n+        (CrateType::Executable, true, RelocModel::Pic) => LinkOutputKind::StaticPicExe,\n+        (CrateType::Executable, true, _) => LinkOutputKind::StaticNoPicExe,\n+        (_, true, _) => LinkOutputKind::StaticDylib,\n+        (_, false, _) => LinkOutputKind::DynamicDylib,\n     };\n-    for obj in pre_link_objects {\n-        cmd.add_object(&get_object_file_path(sess, obj));\n+\n+    // Adjust the output kind to target capabilities.\n+    let pic_exe_supported = sess.target.target.options.position_independent_executables;\n+    let static_pic_exe_supported = false; // FIXME: Add this option to target specs.\n+    let static_dylib_supported = sess.target.target.options.crt_static_allows_dylibs;\n+    match kind {\n+        LinkOutputKind::DynamicPicExe if !pic_exe_supported => LinkOutputKind::DynamicNoPicExe,\n+        LinkOutputKind::StaticPicExe if !static_pic_exe_supported => LinkOutputKind::StaticNoPicExe,\n+        LinkOutputKind::StaticDylib if !static_dylib_supported => LinkOutputKind::DynamicDylib,\n+        _ => kind,\n     }\n+}\n \n-    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n-            cmd.add_object(&get_object_file_path(sess, obj));\n-        }\n+/// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n+/// We only provide such support for a very limited number of targets.\n+fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n+    match sess.target.target.options.crt_objects_fallback {\n+        // FIXME: Find a better heuristic for \"native musl toolchain is available\",\n+        // based on host and linker path, for example.\n+        // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n+        Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n+        // FIXME: Find some heuristic for \"native mingw toolchain is available\",\n+        // likely based on `get_crt_libs_path` (https://github.com/rust-lang/rust/pull/67429).\n+        Some(CrtObjectsFallback::Mingw) => sess.target.target.target_vendor != \"uwp\",\n+        // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n+        Some(CrtObjectsFallback::Wasm) => true,\n+        None => false,\n     }\n }\n \n-/// Add end object files defined by the target spec.\n-fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n-    for obj in &sess.target.target.options.post_link_objects {\n+/// Add pre-link object files defined by the target spec.\n+fn add_pre_link_objects(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    link_output_kind: LinkOutputKind,\n+    fallback: bool,\n+) {\n+    let opts = &sess.target.target.options;\n+    let objects = if fallback { &opts.pre_link_objects_fallback } else { &opts.pre_link_objects };\n+    for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n-    if sess.crt_static(Some(crate_type)) {\n-        for obj in &sess.target.target.options.post_link_objects_crt {\n-            cmd.add_object(&get_object_file_path(sess, obj));\n-        }\n+}\n+\n+/// Add post-link object files defined by the target spec.\n+fn add_post_link_objects(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    link_output_kind: LinkOutputKind,\n+    fallback: bool,\n+) {\n+    let opts = &sess.target.target.options;\n+    let objects = if fallback { &opts.post_link_objects_fallback } else { &opts.post_link_objects };\n+    for obj in objects.get(&link_output_kind).iter().copied().flatten() {\n+        cmd.add_object(&get_object_file_path(sess, obj));\n     }\n }\n \n@@ -1320,38 +1359,6 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n-/// Add options requesting executables to be position-independent or not position-independent.\n-fn add_position_independent_executable_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    flavor: LinkerFlavor,\n-    crate_type: CrateType,\n-    codegen_results: &CodegenResults,\n-) {\n-    if crate_type != CrateType::Executable {\n-        return;\n-    }\n-\n-    if sess.target.target.options.position_independent_executables {\n-        let attr_link_args = &*codegen_results.crate_info.link_args;\n-        let mut user_defined_link_args = sess.opts.cg.link_args.iter().chain(attr_link_args);\n-        if sess.relocation_model() == RelocModel::Pic\n-            && !sess.crt_static(Some(crate_type))\n-            && !user_defined_link_args.any(|x| x == \"-static\")\n-        {\n-            cmd.position_independent_executable();\n-            return;\n-        }\n-    }\n-\n-    // Recent versions of gcc can be configured to generate position\n-    // independent executables by default. We have to pass -no-pie to\n-    // explicitly turn that off. Not applicable to ld.\n-    if sess.target.target.options.linker_is_gnu && flavor != LinkerFlavor::Ld {\n-        cmd.no_position_independent_executable();\n-    }\n-}\n-\n /// Add options making relocation sections in the produced ELF files read-only\n /// and suppressing lazy binding.\n fn add_relro_args(cmd: &mut dyn Linker, sess: &Session) {\n@@ -1417,6 +1424,8 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // to the linker args construction.\n     assert!(base_cmd.get_args().is_empty() || sess.target.target.target_vendor == \"uwp\");\n     let cmd = &mut *codegen_results.linker_info.to_linker(base_cmd, &sess, flavor, target_cpu);\n+    let link_output_kind = link_output_kind(sess, crate_type);\n+    let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_pre_link_args(cmd, sess, flavor, crate_type);\n@@ -1430,8 +1439,13 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n     }\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO\n+    if crt_objects_fallback {\n+        cmd.no_crt_objects();\n+    }\n+\n     // NO-OPT-OUT, OBJECT-FILES-YES\n-    add_pre_link_objects(cmd, sess, crate_type);\n+    add_pre_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.target.target.options.is_like_emscripten {\n@@ -1490,7 +1504,16 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    add_position_independent_executable_args(cmd, sess, flavor, crate_type, codegen_results);\n+    // FIXME: Support `StaticPicExe` correctly.\n+    match link_output_kind {\n+        LinkOutputKind::DynamicPicExe | LinkOutputKind::StaticPicExe => {\n+            cmd.position_independent_executable()\n+        }\n+        LinkOutputKind::DynamicNoPicExe | LinkOutputKind::StaticNoPicExe => {\n+            cmd.no_position_independent_executable()\n+        }\n+        _ => {}\n+    }\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n@@ -1520,12 +1543,14 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     );\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // Tell the linker what we're doing.\n-    if crate_type != CrateType::Executable {\n-        cmd.build_dylib(out_filename);\n-    }\n-    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n-        cmd.build_static_executable();\n+    // FIXME: Merge with the previous `link_output_kind` match,\n+    // and support `StaticPicExe` and `StaticDylib` correctly.\n+    match link_output_kind {\n+        LinkOutputKind::StaticNoPicExe | LinkOutputKind::StaticPicExe => {\n+            cmd.build_static_executable()\n+        }\n+        LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => cmd.build_dylib(out_filename),\n+        _ => {}\n     }\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n@@ -1551,7 +1576,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     add_late_link_args(cmd, sess, flavor, crate_type, codegen_results);\n \n     // NO-OPT-OUT, OBJECT-FILES-YES\n-    add_post_link_objects(cmd, sess, crate_type);\n+    add_post_link_objects(cmd, sess, link_output_kind, crt_objects_fallback);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n     add_post_link_args(cmd, sess, flavor);"}, {"sha": "ee5bcf4b9f58bed375d65ebcbe763f3d2bee813a", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -123,6 +123,7 @@ pub trait Linker {\n     fn pgo_gen(&mut self);\n     fn control_flow_guard(&mut self);\n     fn debuginfo(&mut self, strip: Strip);\n+    fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n     fn build_static_executable(&mut self);\n@@ -266,7 +267,9 @@ impl<'a> Linker for GccLinker<'a> {\n         self.cmd.arg(\"-pie\");\n     }\n     fn no_position_independent_executable(&mut self) {\n-        self.cmd.arg(\"-no-pie\");\n+        if !self.is_ld {\n+            self.cmd.arg(\"-no-pie\");\n+        }\n     }\n     fn full_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n@@ -404,6 +407,12 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n+    fn no_crt_objects(&mut self) {\n+        if !self.is_ld {\n+            self.cmd.arg(\"-nostartfiles\");\n+        }\n+    }\n+\n     fn no_default_libraries(&mut self) {\n         if !self.is_ld {\n             self.cmd.arg(\"-nodefaultlibs\");\n@@ -644,6 +653,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // noop\n     }\n \n+    fn no_crt_objects(&mut self) {\n+        // noop\n+    }\n+\n     fn no_default_libraries(&mut self) {\n         self.cmd.arg(\"/NODEFAULTLIB\");\n     }\n@@ -907,6 +920,8 @@ impl<'a> Linker for EmLinker<'a> {\n         });\n     }\n \n+    fn no_crt_objects(&mut self) {}\n+\n     fn no_default_libraries(&mut self) {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n@@ -1106,6 +1121,8 @@ impl<'a> Linker for WasmLd<'a> {\n         self.sess.warn(\"Windows Control Flow Guard is not supported by this linker.\");\n     }\n \n+    fn no_crt_objects(&mut self) {}\n+\n     fn no_default_libraries(&mut self) {}\n \n     fn build_dylib(&mut self, _out_filename: &Path) {\n@@ -1271,6 +1288,8 @@ impl<'a> Linker for PtxLinker<'a> {\n \n     fn pgo_gen(&mut self) {}\n \n+    fn no_crt_objects(&mut self) {}\n+\n     fn no_default_libraries(&mut self) {}\n \n     fn control_flow_guard(&mut self) {"}, {"sha": "8991691a9a30c63b4f3f22d071bb2f9bc1496ea9", "filename": "src/librustc_target/spec/crt_objects.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fcrt_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fcrt_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fcrt_objects.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -0,0 +1,145 @@\n+//! Object files providing support for basic runtime facilities and added to the produced binaries\n+//! at the start and at the end of linking.\n+//!\n+//! Table of CRT objects for popular toolchains.\n+//! The `crtx` ones are generally distributed with libc and the `begin/end` ones with gcc.\n+//! See https://dev.gentoo.org/~vapier/crt.txt for some more details.\n+//!\n+//! | Pre-link CRT objects | glibc                  | musl                   | bionic           | mingw             | wasi |\n+//! |----------------------|------------------------|------------------------|------------------|-------------------|------|\n+//! | dynamic-nopic-exe    | crt1, crti, crtbegin   | crt1, crti, crtbegin   | crtbegin_dynamic | crt2, crtbegin    | crt1 |\n+//! | dynamic-pic-exe      | Scrt1, crti, crtbeginS | Scrt1, crti, crtbeginS | crtbegin_dynamic | crt2, crtbegin    | crt1 |\n+//! | static-nopic-exe     | crt1, crti, crtbeginT  | crt1, crti, crtbegin   | crtbegin_static  | crt2, crtbegin    | crt1 |\n+//! | static-pic-exe       | rcrt1, crti, crtbeginS | rcrt1, crti, crtbeginS | crtbegin_dynamic | crt2, crtbegin    | crt1 |\n+//! | dynamic-dylib        | crti, crtbeginS        | crti, crtbeginS        | crtbegin_so      | dllcrt2, crtbegin | -    |\n+//! | static-dylib (gcc)   | crti, crtbeginT        | crti, crtbeginS        | crtbegin_so      | dllcrt2, crtbegin | -    |\n+//! | static-dylib (clang) | crti, crtbeginT        | N/A                    | crtbegin_static  | dllcrt2, crtbegin | -    |\n+//!\n+//! | Post-link CRT objects | glibc         | musl          | bionic         | mingw  | wasi |\n+//! |-----------------------|---------------|---------------|----------------|--------|------|\n+//! | dynamic-nopic-exe     | crtend, crtn  | crtend, crtn  | crtend_android | crtend | -    |\n+//! | dynamic-pic-exe       | crtendS, crtn | crtendS, crtn | crtend_android | crtend | -    |\n+//! | static-nopic-exe      | crtend, crtn  | crtend, crtn  | crtend_android | crtend | -    |\n+//! | static-pic-exe        | crtendS, crtn | crtendS, crtn | crtend_android | crtend | -    |\n+//! | dynamic-dylib         | crtendS, crtn | crtendS, crtn | crtend_so      | crtend | -    |\n+//! | static-dylib (gcc)    | crtend, crtn  | crtendS, crtn | crtend_so      | crtend | -    |\n+//! | static-dylib (clang)  | crtendS, crtn | N/A           | crtend_so      | crtend | -    |\n+//!\n+//! Use cases for rustc linking the CRT objects explicitly:\n+//!     - rustc needs to add its own Rust-specific objects (mingw is the example)\n+//!     - gcc wrapper cannot be used for some reason and linker like ld or lld is used directly.\n+//!     - gcc wrapper pulls wrong CRT objects (e.g. from glibc when we are targeting musl).\n+//!\n+//! In general it is preferable to rely on the target's native toolchain to pull the objects.\n+//! However, for some targets (musl, mingw) rustc historically provides a more self-contained\n+//! installation not requiring users to install the native target's toolchain.\n+//! In that case rustc distributes the objects as a part of the target's Rust toolchain\n+//! and falls back to linking with them manually.\n+//! Unlike native toolchains, rustc only currently adds the libc's objects during linking,\n+//! but not gcc's. As a result rustc cannot link with C++ static libraries (#36710)\n+//! when linking in self-contained mode.\n+\n+use crate::spec::LinkOutputKind;\n+use rustc_serialize::json::{Json, ToJson};\n+use std::collections::BTreeMap;\n+use std::str::FromStr;\n+\n+pub type CrtObjects = BTreeMap<LinkOutputKind, Vec<String>>;\n+\n+pub(super) fn new(obj_table: &[(LinkOutputKind, &[&str])]) -> CrtObjects {\n+    obj_table.iter().map(|(z, k)| (*z, k.iter().map(|b| b.to_string()).collect())).collect()\n+}\n+\n+pub(super) fn all(obj: &str) -> CrtObjects {\n+    new(&[\n+        (LinkOutputKind::DynamicNoPicExe, &[obj]),\n+        (LinkOutputKind::DynamicPicExe, &[obj]),\n+        (LinkOutputKind::StaticNoPicExe, &[obj]),\n+        (LinkOutputKind::StaticPicExe, &[obj]),\n+        (LinkOutputKind::DynamicDylib, &[obj]),\n+        (LinkOutputKind::StaticDylib, &[obj]),\n+    ])\n+}\n+\n+pub(super) fn pre_musl_fallback() -> CrtObjects {\n+    new(&[\n+        (LinkOutputKind::DynamicNoPicExe, &[\"crt1.o\", \"crti.o\"]),\n+        (LinkOutputKind::DynamicPicExe, &[\"Scrt1.o\", \"crti.o\"]),\n+        (LinkOutputKind::StaticNoPicExe, &[\"crt1.o\", \"crti.o\"]),\n+        (LinkOutputKind::StaticPicExe, &[\"rcrt1.o\", \"crti.o\"]),\n+        (LinkOutputKind::DynamicDylib, &[\"crti.o\"]),\n+        (LinkOutputKind::StaticDylib, &[\"crti.o\"]),\n+    ])\n+}\n+\n+pub(super) fn post_musl_fallback() -> CrtObjects {\n+    all(\"crtn.o\")\n+}\n+\n+pub(super) fn pre_mingw_fallback() -> CrtObjects {\n+    new(&[\n+        (LinkOutputKind::DynamicNoPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n+        (LinkOutputKind::DynamicPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n+        (LinkOutputKind::StaticNoPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n+        (LinkOutputKind::StaticPicExe, &[\"crt2.o\", \"rsbegin.o\"]),\n+        (LinkOutputKind::DynamicDylib, &[\"dllcrt2.o\", \"rsbegin.o\"]),\n+        (LinkOutputKind::StaticDylib, &[\"dllcrt2.o\", \"rsbegin.o\"]),\n+    ])\n+}\n+\n+pub(super) fn post_mingw_fallback() -> CrtObjects {\n+    all(\"rsend.o\")\n+}\n+\n+pub(super) fn pre_mingw() -> CrtObjects {\n+    all(\"rsbegin.o\")\n+}\n+\n+pub(super) fn post_mingw() -> CrtObjects {\n+    all(\"rsend.o\")\n+}\n+\n+pub(super) fn pre_wasi_fallback() -> CrtObjects {\n+    new(&[\n+        (LinkOutputKind::DynamicNoPicExe, &[\"crt1.o\"]),\n+        (LinkOutputKind::DynamicPicExe, &[\"crt1.o\"]),\n+        (LinkOutputKind::StaticNoPicExe, &[\"crt1.o\"]),\n+        (LinkOutputKind::StaticPicExe, &[\"crt1.o\"]),\n+    ])\n+}\n+\n+pub(super) fn post_wasi_fallback() -> CrtObjects {\n+    new(&[])\n+}\n+\n+/// Which logic to use to determine whether to fall back to the \"self-contained\" mode or not.\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum CrtObjectsFallback {\n+    Musl,\n+    Mingw,\n+    Wasm,\n+}\n+\n+impl FromStr for CrtObjectsFallback {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<CrtObjectsFallback, ()> {\n+        Ok(match s {\n+            \"musl\" => CrtObjectsFallback::Musl,\n+            \"mingw\" => CrtObjectsFallback::Mingw,\n+            \"wasm\" => CrtObjectsFallback::Wasm,\n+            _ => return Err(()),\n+        })\n+    }\n+}\n+\n+impl ToJson for CrtObjectsFallback {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+            CrtObjectsFallback::Musl => \"musl\",\n+            CrtObjectsFallback::Mingw => \"mingw\",\n+            CrtObjectsFallback::Wasm => \"wasm\",\n+        }\n+        .to_json()\n+    }\n+}"}, {"sha": "96b5328e1ee4672cb9379b3da4ec05753eb02531", "filename": "src/librustc_target/spec/fuchsia_base.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -1,4 +1,4 @@\n-use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, TargetOptions};\n+use crate::spec::{crt_objects, LinkArgs, LinkOutputKind, LinkerFlavor, LldFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n     let mut pre_link_args = LinkArgs::new();\n@@ -23,7 +23,12 @@ pub fn opts() -> TargetOptions {\n         linker_is_gnu: true,\n         has_rpath: false,\n         pre_link_args,\n-        pre_link_objects_exe: vec![\"Scrt1.o\".to_string()],\n+        pre_link_objects: crt_objects::new(&[\n+            (LinkOutputKind::DynamicNoPicExe, &[\"Scrt1.o\"]),\n+            (LinkOutputKind::DynamicPicExe, &[\"Scrt1.o\"]),\n+            (LinkOutputKind::StaticNoPicExe, &[\"Scrt1.o\"]),\n+            (LinkOutputKind::StaticPicExe, &[\"Scrt1.o\"]),\n+        ]),\n         position_independent_executables: true,\n         has_elf_tls: true,\n         ..Default::default()"}, {"sha": "0fdd8760806773a716ffc55dca7e2c9c9e1663b6", "filename": "src/librustc_target/spec/linux_musl_base.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -1,29 +1,18 @@\n+use crate::spec::crt_objects::{self, CrtObjectsFallback};\n use crate::spec::{LinkerFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n     let mut base = super::linux_base::opts();\n \n-    // Make sure that the linker/gcc really don't pull in anything, including\n-    // default objects, libs, etc.\n-    base.pre_link_args_crt.insert(LinkerFlavor::Gcc, Vec::new());\n-    base.pre_link_args_crt.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-nostdlib\".to_string());\n-\n     // At least when this was tested, the linker would not add the\n     // `GNU_EH_FRAME` program header to executables generated, which is required\n     // when unwinding to locate the unwinding information. I'm not sure why this\n     // argument is *not* necessary for normal builds, but it can't hurt!\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-Wl,--eh-frame-hdr\".to_string());\n \n-    // When generating a statically linked executable there's generally some\n-    // small setup needed which is listed in these files. These are provided by\n-    // a musl toolchain and are linked by default by the `musl-gcc` script. Note\n-    // that `gcc` also does this by default, it just uses some different files.\n-    //\n-    // Each target directory for musl has these object files included in it so\n-    // they'll be included from there.\n-    base.pre_link_objects_exe_crt.push(\"crt1.o\".to_string());\n-    base.pre_link_objects_exe_crt.push(\"crti.o\".to_string());\n-    base.post_link_objects_crt.push(\"crtn.o\".to_string());\n+    base.pre_link_objects_fallback = crt_objects::pre_musl_fallback();\n+    base.post_link_objects_fallback = crt_objects::post_musl_fallback();\n+    base.crt_objects_fallback = Some(CrtObjectsFallback::Musl);\n \n     // These targets statically link libc by default\n     base.crt_static_default = true;"}, {"sha": "d39ab55fd97b79c2650e42c6e9c3d9db91d117cf", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 117, "deletions": 25, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -35,6 +35,7 @@\n //! to the list specified by the target, rather than replace.\n \n use crate::spec::abi::{lookup as lookup_abi, Abi};\n+use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_serialize::json::{Json, ToJson};\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n@@ -44,6 +45,8 @@ use std::{fmt, io};\n use rustc_macros::HashStable_Generic;\n \n pub mod abi;\n+pub mod crt_objects;\n+\n mod android_base;\n mod apple_base;\n mod apple_sdk_base;\n@@ -341,6 +344,54 @@ impl ToJson for TlsModel {\n     }\n }\n \n+/// Everything is flattened to a single enum to make the json encoding/decoding less annoying.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub enum LinkOutputKind {\n+    /// Dynamically linked non position-independent executable.\n+    DynamicNoPicExe,\n+    /// Dynamically linked position-independent executable.\n+    DynamicPicExe,\n+    /// Statically linked non position-independent executable.\n+    StaticNoPicExe,\n+    /// Statically linked position-independent executable.\n+    StaticPicExe,\n+    /// Regular dynamic library (\"dynamically linked\").\n+    DynamicDylib,\n+    /// Dynamic library with bundled libc (\"statically linked\").\n+    StaticDylib,\n+}\n+\n+impl LinkOutputKind {\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            LinkOutputKind::DynamicNoPicExe => \"dynamic-nopic-exe\",\n+            LinkOutputKind::DynamicPicExe => \"dynamic-pic-exe\",\n+            LinkOutputKind::StaticNoPicExe => \"static-nopic-exe\",\n+            LinkOutputKind::StaticPicExe => \"static-pic-exe\",\n+            LinkOutputKind::DynamicDylib => \"dynamic-dylib\",\n+            LinkOutputKind::StaticDylib => \"static-dylib\",\n+        }\n+    }\n+\n+    pub(super) fn from_str(s: &str) -> Option<LinkOutputKind> {\n+        Some(match s {\n+            \"dynamic-nopic-exe\" => LinkOutputKind::DynamicNoPicExe,\n+            \"dynamic-pic-exe\" => LinkOutputKind::DynamicPicExe,\n+            \"static-nopic-exe\" => LinkOutputKind::StaticNoPicExe,\n+            \"static-pic-exe\" => LinkOutputKind::StaticPicExe,\n+            \"dynamic-dylib\" => LinkOutputKind::DynamicDylib,\n+            \"static-dylib\" => LinkOutputKind::StaticDylib,\n+            _ => return None,\n+        })\n+    }\n+}\n+\n+impl fmt::Display for LinkOutputKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n pub enum LoadTargetError {\n     BuiltinTargetNotFound(String),\n     Other(String),\n@@ -644,13 +695,19 @@ pub struct TargetOptions {\n     /// Linker arguments that are passed *before* any user-defined libraries.\n     pub pre_link_args: LinkArgs, // ... unconditionally\n     pub pre_link_args_crt: LinkArgs, // ... when linking with a bundled crt\n-    /// Objects to link before all others, always found within the\n-    /// sysroot folder.\n-    pub pre_link_objects_exe: Vec<String>, // ... when linking an executable, unconditionally\n-    pub pre_link_objects_exe_crt: Vec<String>, // ... when linking an executable with a bundled crt\n-    pub pre_link_objects_dll: Vec<String>, // ... when linking a dylib\n+    /// Objects to link before and after all other object code.\n+    pub pre_link_objects: CrtObjects,\n+    pub post_link_objects: CrtObjects,\n+    /// Same as `(pre|post)_link_objects`, but when we fail to pull the objects with help of the\n+    /// target's native gcc and fall back to the \"self-contained\" mode and pull them manually.\n+    /// See `crt_objects.rs` for some more detailed documentation.\n+    pub pre_link_objects_fallback: CrtObjects,\n+    pub post_link_objects_fallback: CrtObjects,\n+    /// Which logic to use to determine whether to fall back to the \"self-contained\" mode or not.\n+    pub crt_objects_fallback: Option<CrtObjectsFallback>,\n+\n     /// Linker arguments that are unconditionally passed after any\n-    /// user-defined but before post_link_objects. Standard platform\n+    /// user-defined but before post-link objects. Standard platform\n     /// libraries that should be always be linked to, usually go here.\n     pub late_link_args: LinkArgs,\n     /// Linker arguments used in addition to `late_link_args` if at least one\n@@ -659,10 +716,6 @@ pub struct TargetOptions {\n     /// Linker arguments used in addition to `late_link_args` if aall Rust\n     /// dependencies are statically linked.\n     pub late_link_args_static: LinkArgs,\n-    /// Objects to link after all others, always found within the\n-    /// sysroot folder.\n-    pub post_link_objects: Vec<String>, // ... unconditionally\n-    pub post_link_objects_crt: Vec<String>, // ... when linking with a bundled crt\n     /// Linker arguments that are unconditionally passed *after* any\n     /// user-defined libraries.\n     pub post_link_args: LinkArgs,\n@@ -932,11 +985,11 @@ impl Default for TargetOptions {\n             position_independent_executables: false,\n             needs_plt: false,\n             relro_level: RelroLevel::None,\n-            pre_link_objects_exe: Vec::new(),\n-            pre_link_objects_exe_crt: Vec::new(),\n-            pre_link_objects_dll: Vec::new(),\n-            post_link_objects: Vec::new(),\n-            post_link_objects_crt: Vec::new(),\n+            pre_link_objects: Default::default(),\n+            post_link_objects: Default::default(),\n+            pre_link_objects_fallback: Default::default(),\n+            post_link_objects_fallback: Default::default(),\n+            crt_objects_fallback: None,\n             late_link_args: LinkArgs::new(),\n             late_link_args_dynamic: LinkArgs::new(),\n             late_link_args_static: LinkArgs::new(),\n@@ -1191,6 +1244,45 @@ impl Target {\n                     })\n                 })).unwrap_or(Ok(()))\n             } );\n+            ($key_name:ident, crt_objects_fallback) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                obj.find(&name[..]).and_then(|o| o.as_string().and_then(|s| {\n+                    match s.parse::<CrtObjectsFallback>() {\n+                        Ok(fallback) => base.options.$key_name = Some(fallback),\n+                        _ => return Some(Err(format!(\"'{}' is not a valid CRT objects fallback. \\\n+                                                      Use 'musl', 'mingw' or 'wasm'\", s))),\n+                    }\n+                    Some(Ok(()))\n+                })).unwrap_or(Ok(()))\n+            } );\n+            ($key_name:ident, link_objects) => ( {\n+                let name = (stringify!($key_name)).replace(\"_\", \"-\");\n+                if let Some(val) = obj.find(&name[..]) {\n+                    let obj = val.as_object().ok_or_else(|| format!(\"{}: expected a \\\n+                        JSON object with fields per CRT object kind.\", name))?;\n+                    let mut args = CrtObjects::new();\n+                    for (k, v) in obj {\n+                        let kind = LinkOutputKind::from_str(&k).ok_or_else(|| {\n+                            format!(\"{}: '{}' is not a valid value for CRT object kind. \\\n+                                     Use '(dynamic,static)-(nopic,pic)-exe' or \\\n+                                     '(dynamic,static)-dylib'\", name, k)\n+                        })?;\n+\n+                        let v = v.as_array().ok_or_else(||\n+                            format!(\"{}.{}: expected a JSON array\", name, k)\n+                        )?.iter().enumerate()\n+                            .map(|(i,s)| {\n+                                let s = s.as_string().ok_or_else(||\n+                                    format!(\"{}.{}[{}]: expected a JSON string\", name, k, i))?;\n+                                Ok(s.to_owned())\n+                            })\n+                            .collect::<Result<Vec<_>, String>>()?;\n+\n+                        args.insert(kind, v);\n+                    }\n+                    base.options.$key_name = args;\n+                }\n+            } );\n             ($key_name:ident, link_args) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 if let Some(val) = obj.find(&name[..]) {\n@@ -1238,16 +1330,16 @@ impl Target {\n         key!(is_builtin, bool);\n         key!(linker, optional);\n         key!(lld_flavor, LldFlavor)?;\n+        key!(pre_link_objects, link_objects);\n+        key!(post_link_objects, link_objects);\n+        key!(pre_link_objects_fallback, link_objects);\n+        key!(post_link_objects_fallback, link_objects);\n+        key!(crt_objects_fallback, crt_objects_fallback)?;\n         key!(pre_link_args, link_args);\n         key!(pre_link_args_crt, link_args);\n-        key!(pre_link_objects_exe, list);\n-        key!(pre_link_objects_exe_crt, list);\n-        key!(pre_link_objects_dll, list);\n         key!(late_link_args, link_args);\n         key!(late_link_args_dynamic, link_args);\n         key!(late_link_args_static, link_args);\n-        key!(post_link_objects, list);\n-        key!(post_link_objects_crt, list);\n         key!(post_link_args, link_args);\n         key!(link_env, env);\n         key!(link_env_remove, list);\n@@ -1468,16 +1560,16 @@ impl ToJson for Target {\n         target_option_val!(is_builtin);\n         target_option_val!(linker);\n         target_option_val!(lld_flavor);\n+        target_option_val!(pre_link_objects);\n+        target_option_val!(post_link_objects);\n+        target_option_val!(pre_link_objects_fallback);\n+        target_option_val!(post_link_objects_fallback);\n+        target_option_val!(crt_objects_fallback);\n         target_option_val!(link_args - pre_link_args);\n         target_option_val!(link_args - pre_link_args_crt);\n-        target_option_val!(pre_link_objects_exe);\n-        target_option_val!(pre_link_objects_exe_crt);\n-        target_option_val!(pre_link_objects_dll);\n         target_option_val!(link_args - late_link_args);\n         target_option_val!(link_args - late_link_args_dynamic);\n         target_option_val!(link_args - late_link_args_static);\n-        target_option_val!(post_link_objects);\n-        target_option_val!(post_link_objects_crt);\n         target_option_val!(link_args - post_link_args);\n         target_option_val!(env - link_env);\n         target_option_val!(link_env_remove);"}, {"sha": "d4a65aa1a2574eaf619d68ee0c9fc609c7dd835a", "filename": "src/librustc_target/spec/wasm32_base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_base.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -1,3 +1,4 @@\n+use super::crt_objects::CrtObjectsFallback;\n use super::{LinkerFlavor, LldFlavor, PanicStrategy, RelocModel, TargetOptions, TlsModel};\n use std::collections::BTreeMap;\n \n@@ -123,6 +124,8 @@ pub fn options() -> TargetOptions {\n \n         pre_link_args,\n \n+        crt_objects_fallback: Some(CrtObjectsFallback::Wasm),\n+\n         // This has no effect in LLVM 8 or prior, but in LLVM 9 and later when\n         // PIC code is implemented this has quite a drastric effect if it stays\n         // at the default, `pic`. In an effort to keep wasm binaries as minimal"}, {"sha": "ded95a34d55d4c20f6e76be0ffe9ac154b48236c", "filename": "src/librustc_target/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -21,10 +21,6 @@ pub fn target() -> Result<Target, String> {\n     // otherwise\n     clang_args.push(\"--target=wasm32-unknown-unknown\".to_string());\n \n-    // Disable attempting to link crt1.o since it typically isn't present and\n-    // isn't needed currently.\n-    clang_args.push(\"-nostdlib\".to_string());\n-\n     // For now this target just never has an entry symbol no matter the output\n     // type, so unconditionally pass this.\n     clang_args.push(\"-Wl,--no-entry\".to_string());"}, {"sha": "0bba7bdd4735cbc53f62b65ef3a624fb89e2a62f", "filename": "src/librustc_target/spec/wasm32_wasi.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_wasi.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -73,7 +73,7 @@\n //! you know what you're getting in to!\n \n use super::wasm32_base;\n-use super::{LinkerFlavor, LldFlavor, Target};\n+use super::{crt_objects, LinkerFlavor, LldFlavor, Target};\n \n pub fn target() -> Result<Target, String> {\n     let mut options = wasm32_base::options();\n@@ -84,9 +84,8 @@ pub fn target() -> Result<Target, String> {\n         .or_insert(Vec::new())\n         .push(\"--target=wasm32-wasi\".to_string());\n \n-    // When generating an executable be sure to put the startup object at the\n-    // front so the main function is correctly hooked up.\n-    options.pre_link_objects_exe_crt.push(\"crt1.o\".to_string());\n+    options.pre_link_objects_fallback = crt_objects::pre_wasi_fallback();\n+    options.post_link_objects_fallback = crt_objects::post_wasi_fallback();\n \n     // Right now this is a bit of a workaround but we're currently saying that\n     // the target by default has a static crt which we're taking as a signal"}, {"sha": "f556bf03f02a0efacf99c8d0d43577af840253bb", "filename": "src/librustc_target/spec/windows_gnu_base.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -1,3 +1,4 @@\n+use crate::spec::crt_objects::{self, CrtObjectsFallback};\n use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n@@ -10,8 +11,6 @@ pub fn opts() -> TargetOptions {\n             \"-fno-use-linker-plugin\".to_string(),\n             // Always enable DEP (NX bit) when it is available\n             \"-Wl,--nxcompat\".to_string(),\n-            // Do not use the standard system startup files or libraries when linking\n-            \"-nostdlib\".to_string(),\n         ],\n     );\n \n@@ -80,18 +79,14 @@ pub fn opts() -> TargetOptions {\n         is_like_windows: true,\n         allows_weak_linkage: false,\n         pre_link_args,\n-        pre_link_objects_exe: vec![\n-            \"crt2.o\".to_string(),    // mingw C runtime initialization for executables\n-            \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n-        ],\n-        pre_link_objects_dll: vec![\n-            \"dllcrt2.o\".to_string(), // mingw C runtime initialization for dlls\n-            \"rsbegin.o\".to_string(),\n-        ],\n+        pre_link_objects: crt_objects::pre_mingw(),\n+        post_link_objects: crt_objects::post_mingw(),\n+        pre_link_objects_fallback: crt_objects::pre_mingw_fallback(),\n+        post_link_objects_fallback: crt_objects::post_mingw_fallback(),\n+        crt_objects_fallback: Some(CrtObjectsFallback::Mingw),\n         late_link_args,\n         late_link_args_dynamic,\n         late_link_args_static,\n-        post_link_objects: vec![\"rsend.o\".to_string()],\n         abi_return_struct_as_int: true,\n         emit_debug_gdb_scripts: false,\n         requires_uwtable: true,"}, {"sha": "e12a37144da5edf3a830980795a61036b2bb143c", "filename": "src/librustc_target/spec/windows_uwp_gnu_base.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_uwp_gnu_base.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -3,20 +3,8 @@ use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n pub fn opts() -> TargetOptions {\n     let base = super::windows_gnu_base::opts();\n \n-    // FIXME: Consider adding `-nostdlib` and inheriting from `windows_gnu_base`.\n-    let mut pre_link_args = LinkArgs::new();\n-    pre_link_args.insert(\n-        LinkerFlavor::Gcc,\n-        vec![\n-            // Tell GCC to avoid linker plugins, because we are not bundling\n-            // them with Windows installer, and Rust does its own LTO anyways.\n-            \"-fno-use-linker-plugin\".to_string(),\n-            // Always enable DEP (NX bit) when it is available\n-            \"-Wl,--nxcompat\".to_string(),\n-        ],\n-    );\n-\n-    // FIXME: This should be updated for the exception machinery changes from #67502.\n+    // FIXME: This should be updated for the exception machinery changes from #67502\n+    // and inherit from `windows_gnu_base`, at least partially.\n     let mut late_link_args = LinkArgs::new();\n     let late_link_args_dynamic = LinkArgs::new();\n     let late_link_args_static = LinkArgs::new();\n@@ -40,11 +28,6 @@ pub fn opts() -> TargetOptions {\n     TargetOptions {\n         executables: false,\n         limit_rdylib_exports: false,\n-        pre_link_args,\n-        // FIXME: Consider adding `-nostdlib` and inheriting from `windows_gnu_base`.\n-        pre_link_objects_exe: vec![\"rsbegin.o\".to_string()],\n-        // FIXME: Consider adding `-nostdlib` and inheriting from `windows_gnu_base`.\n-        pre_link_objects_dll: vec![\"rsbegin.o\".to_string()],\n         late_link_args,\n         late_link_args_dynamic,\n         late_link_args_static,"}, {"sha": "d26efc0985952cb4f0a8a342f8212b5143976251", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -1,6 +1,6 @@\n use std::iter;\n \n-use super::{LinkerFlavor, LldFlavor, PanicStrategy, Target, TargetOptions};\n+use super::{crt_objects, LinkerFlavor, LldFlavor, PanicStrategy, Target, TargetOptions};\n \n pub fn target() -> Result<Target, String> {\n     const PRE_LINK_ARGS: &[&str] = &[\n@@ -68,7 +68,8 @@ pub fn target() -> Result<Target, String> {\n             PRE_LINK_ARGS.iter().cloned().map(String::from).collect(),\n         ))\n         .collect(),\n-        post_link_objects: vec![\"libunwind.a\".into()],\n+        // FIXME: libunwind is certainly not a CRT object, use some other option instead.\n+        post_link_objects: crt_objects::all(\"libunwind.a\"),\n         override_export_symbols: Some(EXPORT_SYMBOLS.iter().cloned().map(String::from).collect()),\n         relax_elf_relocations: true,\n         ..Default::default()"}, {"sha": "2d4e953ac51656aae452b45be60e9eb4dd74d8d9", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=49eb35c05e8bff6197ed0ea7437e0c0fb03c62c5", "patch": "@@ -2684,11 +2684,11 @@ impl<A: ToJson> ToJson for Vec<A> {\n     }\n }\n \n-impl<A: ToJson> ToJson for BTreeMap<string::String, A> {\n+impl<T: ToString, A: ToJson> ToJson for BTreeMap<T, A> {\n     fn to_json(&self) -> Json {\n         let mut d = BTreeMap::new();\n         for (key, value) in self {\n-            d.insert((*key).clone(), value.to_json());\n+            d.insert(key.to_string(), value.to_json());\n         }\n         Json::Object(d)\n     }"}]}