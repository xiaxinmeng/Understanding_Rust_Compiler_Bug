{"sha": "4212d28727fca0de8c3f5d4504025c3028425386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMTJkMjg3MjdmY2EwZGU4YzNmNWQ0NTA0MDI1YzMwMjg0MjUzODY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-01-28T11:34:32Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-01-28T11:34:32Z"}, "message": "Merge #25\n\n25: Drop curly_block r=matklad a=matklad\n\ncloses #13", "tree": {"sha": "044832f0c569f54ca92bdf618c6cc4b3b68940e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/044832f0c569f54ca92bdf618c6cc4b3b68940e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4212d28727fca0de8c3f5d4504025c3028425386", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4212d28727fca0de8c3f5d4504025c3028425386", "html_url": "https://github.com/rust-lang/rust/commit/4212d28727fca0de8c3f5d4504025c3028425386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4212d28727fca0de8c3f5d4504025c3028425386/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "7a6fa6504c5458dcc32e24327ba0ec597222fc63", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6fa6504c5458dcc32e24327ba0ec597222fc63", "html_url": "https://github.com/rust-lang/rust/commit/7a6fa6504c5458dcc32e24327ba0ec597222fc63"}, {"sha": "2141888782a74de4a655fee585c99163a3e75e5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2141888782a74de4a655fee585c99163a3e75e5c", "html_url": "https://github.com/rust-lang/rust/commit/2141888782a74de4a655fee585c99163a3e75e5c"}], "stats": {"total": 104, "additions": 30, "deletions": 74}, "files": [{"sha": "7fed5e83b09948dc90da216ef872fc29b1da46d3", "filename": "src/parser/event_parser/grammar/items.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs?ref=4212d28727fca0de8c3f5d4504025c3028425386", "patch": "@@ -14,7 +14,7 @@ fn item(p: &mut Parser) {\n     let item = p.start();\n     attributes::outer_attributes(p);\n     visibility(p);\n-    let la = p.raw_lookahead(1);\n+    let la = p.nth(1);\n     let item_kind = match p.current() {\n         EXTERN_KW if la == CRATE_KW => {\n             extern_crate_item(p);\n@@ -171,7 +171,7 @@ fn use_item(p: &mut Parser) {\n     p.expect(SEMI);\n \n     fn use_tree(p: &mut Parser) {\n-        let la = p.raw_lookahead(1);\n+        let la = p.nth(1);\n         let m = p.start();\n         match (p.current(), la) {\n             (STAR, _) => {\n@@ -235,5 +235,21 @@ fn fn_item(p: &mut Parser) {\n     assert!(p.at(FN_KW));\n     p.bump();\n \n-    p.expect(IDENT) && p.expect(L_PAREN) && p.expect(R_PAREN) && p.curly_block(|_| ());\n+    p.expect(IDENT);\n+    if p.at(L_PAREN) {\n+        fn_value_parameters(p);\n+    } else {\n+        p.error().message(\"expected function arguments\").emit();\n+    }\n+\n+    if p.at(L_CURLY) {\n+        p.expect(L_CURLY);\n+        p.expect(R_CURLY);\n+    }\n+\n+    fn fn_value_parameters(p: &mut Parser) {\n+        assert!(p.at(L_PAREN));\n+        p.bump();\n+        p.expect(R_PAREN);\n+    }\n }"}, {"sha": "931193b5fd8497ae21c6ea966a6ea220a9b71e26", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=4212d28727fca0de8c3f5d4504025c3028425386", "patch": "@@ -20,7 +20,7 @@ fn visibility(p: &mut Parser) {\n         let vis = p.start();\n         p.bump();\n         if p.at(L_PAREN) {\n-            match p.raw_lookahead(1) {\n+            match p.nth(1) {\n                 CRATE_KW | SELF_KW | SUPER_KW | IN_KW => {\n                     p.bump();\n                     if p.bump() == IN_KW {\n@@ -57,7 +57,7 @@ impl<'p> Parser<'p> {\n         err.complete(self, ERROR);\n     }\n \n-    pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n+    fn expect(&mut self, kind: SyntaxKind) -> bool {\n         if self.at(kind) {\n             self.bump();\n             true\n@@ -77,39 +77,23 @@ impl<'p> Parser<'p> {\n \n trait Lookahead: Copy {\n     fn is_ahead(self, p: &Parser) -> bool;\n-    fn consume(p: &mut Parser);\n }\n \n impl Lookahead for SyntaxKind {\n     fn is_ahead(self, p: &Parser) -> bool {\n         p.current() == self\n     }\n-\n-    fn consume(p: &mut Parser) {\n-        p.bump();\n-    }\n }\n \n impl Lookahead for [SyntaxKind; 2] {\n     fn is_ahead(self, p: &Parser) -> bool {\n-        p.current() == self[0] && p.raw_lookahead(1) == self[1]\n-    }\n-\n-    fn consume(p: &mut Parser) {\n-        p.bump();\n-        p.bump();\n+        p.current() == self[0] && p.nth(1) == self[1]\n     }\n }\n \n impl Lookahead for [SyntaxKind; 3] {\n     fn is_ahead(self, p: &Parser) -> bool {\n-        p.current() == self[0] && p.raw_lookahead(1) == self[1] && p.raw_lookahead(2) == self[2]\n-    }\n-\n-    fn consume(p: &mut Parser) {\n-        p.bump();\n-        p.bump();\n-        p.bump();\n+        p.current() == self[0] && p.nth(1) == self[1] && p.nth(2) == self[2]\n     }\n }\n \n@@ -121,8 +105,4 @@ impl<'a> Lookahead for AnyOf<'a> {\n         let curr = p.current();\n         self.0.iter().any(|&k| k == curr)\n     }\n-\n-    fn consume(p: &mut Parser) {\n-        p.bump();\n-    }\n }"}, {"sha": "6c8a89f6c6f55db41e61dfd3593fb026381522b1", "filename": "src/parser/event_parser/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs?ref=4212d28727fca0de8c3f5d4504025c3028425386", "patch": "@@ -12,7 +12,7 @@ pub(crate) fn use_path(p: &mut Parser) {\n     path_segment(p, true);\n     let mut qual = path.complete(p, PATH);\n     loop {\n-        if p.at(COLONCOLON) && !items::is_use_tree_start(p.raw_lookahead(1)) {\n+        if p.at(COLONCOLON) && !items::is_use_tree_start(p.nth(1)) {\n             let path = qual.precede(p);\n             p.bump();\n             path_segment(p, false);"}, {"sha": "a15d0b6335d2a562c2ebdff9faed7134bd1436c9", "filename": "src/parser/event_parser/parser.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4212d28727fca0de8c3f5d4504025c3028425386/src%2Fparser%2Fevent_parser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fparser.rs?ref=4212d28727fca0de8c3f5d4504025c3028425386", "patch": "@@ -1,7 +1,7 @@\n use {SyntaxKind, TextUnit, Token};\n use super::Event;\n use super::super::is_insignificant;\n-use SyntaxKind::{EOF, ERROR, L_CURLY, R_CURLY, TOMBSTONE};\n+use SyntaxKind::{EOF, TOMBSTONE};\n \n pub(crate) struct Marker {\n     pos: u32,\n@@ -106,9 +106,6 @@ pub(crate) struct Parser<'t> {\n \n     pos: usize,\n     events: Vec<Event>,\n-\n-    curly_level: i32,\n-    curly_limit: Option<i32>,\n }\n \n impl<'t> Parser<'t> {\n@@ -131,30 +128,14 @@ impl<'t> Parser<'t> {\n \n             pos: 0,\n             events: Vec::new(),\n-            curly_level: 0,\n-            curly_limit: None,\n         }\n     }\n \n     pub(crate) fn into_events(self) -> Vec<Event> {\n-        assert!(self.curly_limit.is_none());\n         assert_eq!(self.current(), EOF);\n         self.events\n     }\n \n-    pub(crate) fn current(&self) -> SyntaxKind {\n-        if self.pos == self.tokens.len() {\n-            return EOF;\n-        }\n-        let token = self.tokens[self.pos];\n-        if let Some(limit) = self.curly_limit {\n-            if limit == self.curly_level && token.kind == R_CURLY {\n-                return EOF;\n-            }\n-        }\n-        token.kind\n-    }\n-\n     pub(crate) fn start(&mut self) -> Marker {\n         let m = Marker {\n             pos: self.events.len() as u32,\n@@ -172,11 +153,8 @@ impl<'t> Parser<'t> {\n \n     pub(crate) fn bump(&mut self) -> SyntaxKind {\n         let kind = self.current();\n-        match kind {\n-            L_CURLY => self.curly_level += 1,\n-            R_CURLY => self.curly_level -= 1,\n-            EOF => return EOF,\n-            _ => (),\n+        if kind == EOF {\n+            return EOF;\n         }\n         self.pos += 1;\n         self.event(Event::Token {\n@@ -186,30 +164,12 @@ impl<'t> Parser<'t> {\n         kind\n     }\n \n-    pub(crate) fn raw_lookahead(&self, n: usize) -> SyntaxKind {\n+    pub(crate) fn nth(&self, n: usize) -> SyntaxKind {\n         self.tokens.get(self.pos + n).map(|t| t.kind).unwrap_or(EOF)\n     }\n \n-    pub(crate) fn curly_block<F: FnOnce(&mut Parser)>(&mut self, f: F) -> bool {\n-        let old_level = self.curly_level;\n-        let old_limit = self.curly_limit;\n-        if !self.expect(L_CURLY) {\n-            return false;\n-        }\n-        self.curly_limit = Some(self.curly_level);\n-        f(self);\n-        assert!(self.curly_level > old_level);\n-        self.curly_limit = old_limit;\n-        if !self.expect(R_CURLY) {\n-            let err = self.start();\n-            while self.curly_level > old_level {\n-                if self.bump() == EOF {\n-                    break;\n-                }\n-            }\n-            err.complete(self, ERROR);\n-        }\n-        true\n+    pub(crate) fn current(&self) -> SyntaxKind {\n+        self.nth(0)\n     }\n \n     fn event(&mut self, event: Event) {"}]}