{"sha": "0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZjhlODcyZWE1YWM3N2VmZmE1OWY4ZDNmODc5NGYxMmNiODg2NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-30T12:15:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-30T12:15:14Z"}, "message": "Auto merge of #59722 - Zoxc:query-cache, r=eddyb\n\nClean up query cache code\n\nThere are a couple of queries for which we do not promote saved results, which have been removed from caching here. This was likely the cause of the regression in https://github.com/rust-lang/rust/pull/57293#issuecomment-476421298.\n\nr? @michaelwoerister", "tree": {"sha": "5bdc88df7bd989d7d9e221757403d1f7d8b42289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bdc88df7bd989d7d9e221757403d1f7d8b42289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "html_url": "https://github.com/rust-lang/rust/commit/0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06f80a3c6988d28db43f0cff3f35d9a005c3ad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06f80a3c6988d28db43f0cff3f35d9a005c3ad5", "html_url": "https://github.com/rust-lang/rust/commit/c06f80a3c6988d28db43f0cff3f35d9a005c3ad5"}, {"sha": "ede41ab4d6dbd56f62021c4951fea8f3278e5030", "url": "https://api.github.com/repos/rust-lang/rust/commits/ede41ab4d6dbd56f62021c4951fea8f3278e5030", "html_url": "https://github.com/rust-lang/rust/commit/ede41ab4d6dbd56f62021c4951fea8f3278e5030"}], "stats": {"total": 317, "additions": 133, "deletions": 184}, "files": [{"sha": "93c22c3e713c0a8e8a0cab7df467f9a3be322f62", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -842,31 +842,20 @@ impl DepGraph {\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n     pub fn exec_cache_promotions<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n-        let green_nodes: Vec<DepNode> = {\n-            let data = self.data.as_ref().unwrap();\n-            data.colors.values.indices().filter_map(|prev_index| {\n-                match data.colors.get(prev_index) {\n-                    Some(DepNodeColor::Green(_)) => {\n-                        let dep_node = data.previous.index_to_node(prev_index);\n-                        if dep_node.cache_on_disk(tcx) {\n-                            Some(dep_node)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    None |\n-                    Some(DepNodeColor::Red) => {\n-                        // We can skip red nodes because a node can only be marked\n-                        // as red if the query result was recomputed and thus is\n-                        // already in memory.\n-                        None\n-                    }\n+        let data = self.data.as_ref().unwrap();\n+        for prev_index in data.colors.values.indices() {\n+            match data.colors.get(prev_index) {\n+                Some(DepNodeColor::Green(_)) => {\n+                    let dep_node = data.previous.index_to_node(prev_index);\n+                    dep_node.try_load_from_on_disk_cache(tcx);\n                 }\n-            }).collect()\n-        };\n-\n-        for dep_node in green_nodes {\n-            dep_node.load_from_on_disk_cache(tcx);\n+                None |\n+                Some(DepNodeColor::Red) => {\n+                    // We can skip red nodes because a node can only be marked\n+                    // as red if the query result was recomputed and thus is\n+                    // already in memory.\n+                }\n+            }\n         }\n     }\n "}, {"sha": "256b3f1015093f2038938c3e4a90a4a23ff31c1c", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -18,7 +18,7 @@ use errors::DiagnosticBuilder;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n     Reported,"}, {"sha": "d2082ab87e738c6acd1ebdbbd27ed17b6781a970", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -2,7 +2,7 @@ use crate::ty::query::QueryDescription;\n use crate::ty::query::queries;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n-use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::dep_graph::{RecoverKey,DepKind, DepNode, SerializedDepNodeIndex};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n use crate::mir;\n use crate::mir::interpret::GlobalId;\n@@ -33,13 +33,13 @@ rustc_queries! {\n     Other {\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n         }\n \n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> &'tcx ty::Generics {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let generics: Option<ty::Generics> = tcx.queries.on_disk_cache\n                                                         .try_load_query_result(tcx, id);\n@@ -62,7 +62,9 @@ rustc_queries! {\n         /// predicate gets in the way of some checks, which are intended\n         /// to operate over only the actual where-clauses written by the\n         /// user.)\n-        query predicates_of(_: DefId) -> &'tcx ty::GenericPredicates<'tcx> {}\n+        query predicates_of(key: DefId) -> &'tcx ty::GenericPredicates<'tcx> {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLibrary>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n@@ -93,7 +95,7 @@ rustc_queries! {\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n         query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n         }\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n@@ -115,7 +117,7 @@ rustc_queries! {\n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n         query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n                                                             .try_load_query_result(tcx, id);\n@@ -285,7 +287,9 @@ rustc_queries! {\n \n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n-        query unsafety_check_result(_: DefId) -> mir::UnsafetyCheckResult {}\n+        query unsafety_check_result(key: DefId) -> mir::UnsafetyCheckResult {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n         query unsafe_derive_on_repr_packed(_: DefId) -> () {}\n@@ -348,7 +352,7 @@ rustc_queries! {\n         }\n \n         query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n-            cache { key.is_local() }\n+            cache_on_disk_if { key.is_local() }\n             load_cached(tcx, id) {\n                 let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n                     .queries.on_disk_cache\n@@ -360,7 +364,9 @@ rustc_queries! {\n     }\n \n     Other {\n-        query used_trait_imports(_: DefId) -> &'tcx DefIdSet {}\n+        query used_trait_imports(key: DefId) -> &'tcx DefIdSet {\n+            cache_on_disk_if { key.is_local() }\n+        }\n     }\n \n     TypeChecking {\n@@ -372,11 +378,15 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        query borrowck(_: DefId) -> &'tcx BorrowCheckResult {}\n+        query borrowck(key: DefId) -> &'tcx BorrowCheckResult {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(_: DefId) -> mir::BorrowCheckResult<'tcx> {}\n+        query mir_borrowck(key: DefId) -> mir::BorrowCheckResult<'tcx> {\n+            cache_on_disk_if(tcx, _) { key.is_local() && tcx.is_closure(key) }\n+        }\n     }\n \n     TypeChecking {\n@@ -412,9 +422,10 @@ rustc_queries! {\n                 \"const-evaluating `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n             }\n-            cache { true }\n-            load_cached(tcx, id) {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            cache_on_disk_if(_, opt_result) {\n+                // Only store results without errors\n+                // FIXME: We never store these\n+                opt_result.map_or(true, |r| r.is_ok())\n             }\n         }\n \n@@ -427,9 +438,9 @@ rustc_queries! {\n                 \"const-evaluating + checking `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n             }\n-            cache { true }\n-            load_cached(tcx, id) {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id).map(Ok)\n+            cache_on_disk_if(_, opt_result) {\n+                // Only store results without errors\n+                opt_result.map_or(true, |r| r.is_ok())\n             }\n         }\n \n@@ -453,7 +464,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        query check_match(_: DefId) -> () {}\n+        query check_match(key: DefId) -> () {\n+            cache_on_disk_if { key.is_local() }\n+        }\n \n         /// Performs part of the privacy check and computes \"access levels\".\n         query privacy_access_levels(_: CrateNum) -> &'tcx AccessLevels {\n@@ -483,7 +496,7 @@ rustc_queries! {\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n             no_force\n             desc { \"computing the symbol for `{}`\", key }\n-            cache { true }\n+            cache_on_disk_if { true }\n         }\n \n         query def_kind(_: DefId) -> Option<DefKind> {}\n@@ -501,7 +514,9 @@ rustc_queries! {\n     }\n \n     Codegen {\n-        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {}\n+        query codegen_fn_attrs(_: DefId) -> CodegenFnAttrs {\n+            cache_on_disk_if { true }\n+        }\n     }\n \n     Other {\n@@ -519,7 +534,7 @@ rustc_queries! {\n                 \"const checking if rvalue is promotable to static `{}`\",\n                 tcx.def_path_str(key)\n             }\n-            cache { true }\n+            cache_on_disk_if { true }\n         }\n         query rvalue_promotable_map(key: DefId) -> &'tcx ItemLocalSet {\n             desc { |tcx|\n@@ -548,7 +563,7 @@ rustc_queries! {\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Vtable<'tcx, ()> {\n             no_force\n-            cache { true }\n+            cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n                 tcx.def_path_str(key.1.def_id())\n@@ -560,7 +575,9 @@ rustc_queries! {\n         query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {}\n+        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {\n+            cache_on_disk_if { true }\n+        }\n         query is_object_safe(key: DefId) -> bool {\n             desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(key) }\n         }"}, {"sha": "b921272856e28b6de951dcfcf8416ac33af6776c", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -55,7 +55,7 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     fn describe(tcx: TyCtxt<'_>, key: Self::Key) -> Cow<'static, str>;\n \n     #[inline]\n-    fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key) -> bool {\n+    fn cache_on_disk(_: TyCtxt<'tcx>, _: Self::Key, _: Option<&Self::Value>) -> bool {\n         false\n     }\n \n@@ -80,33 +80,3 @@ impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n         \"running analysis passes on this crate\".into()\n     }\n }\n-\n-macro_rules! impl_disk_cacheable_query(\n-    ($query_name:ident, |$tcx:tt, $key:tt| $cond:expr) => {\n-        impl<'tcx> QueryDescription<'tcx> for queries::$query_name<'tcx> {\n-            #[inline]\n-            fn cache_on_disk($tcx: TyCtxt<'tcx>, $key: Self::Key) -> bool {\n-                $cond\n-            }\n-\n-            #[inline]\n-            fn try_load_from_disk(tcx: TyCtxt<'tcx>,\n-                                      id: SerializedDepNodeIndex)\n-                                      -> Option<Self::Value> {\n-                tcx.queries.on_disk_cache.try_load_query_result(tcx, id)\n-            }\n-        }\n-    }\n-);\n-\n-impl_disk_cacheable_query!(mir_borrowck, |tcx, def_id| {\n-    def_id.is_local() && tcx.is_closure(def_id)\n-});\n-\n-impl_disk_cacheable_query!(unsafety_check_result, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(borrowck, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(check_match, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(predicates_of, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(used_trait_imports, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(codegen_fn_attrs, |_, _| true);\n-impl_disk_cacheable_query!(specialization_graph_of, |_, _| true);"}, {"sha": "8b2183c42efd46cb6ee636df61f4af43bcc419a0", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -221,26 +221,8 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<check_match<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<codegen_fn_attrs<'_>, _>(tcx, enc, qri)?;\n                 encode_query_results::<specialization_graph_of<'_>, _>(tcx, enc, qri)?;\n-\n-                // const eval is special, it only encodes successfully evaluated constants\n-                use crate::ty::query::QueryAccessors;\n-                let cache = const_eval::query_cache(tcx).borrow();\n-                assert!(cache.active.is_empty());\n-                for (key, entry) in cache.results.iter() {\n-                    use crate::ty::query::config::QueryDescription;\n-                    if const_eval::cache_on_disk(tcx, key.clone()) {\n-                        if let Ok(ref value) = entry.value {\n-                            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n-\n-                            // Record position of the cache entry\n-                            qri.push((dep_node, AbsoluteBytePos::new(enc.position())));\n-\n-                            // Encode the type check tables with the SerializedDepNodeIndex\n-                            // as tag.\n-                            enc.encode_tagged(dep_node, value)?;\n-                        }\n-                    }\n-                }\n+                encode_query_results::<const_eval<'_>, _>(tcx, enc, qri)?;\n+                // FIXME: Include const_eval_raw?\n \n                 Ok(())\n             })?;\n@@ -1090,7 +1072,7 @@ where\n         let map = Q::query_cache(tcx).borrow();\n         assert!(map.active.is_empty());\n         for (key, entry) in map.results.iter() {\n-            if Q::cache_on_disk(tcx, key.clone()) {\n+            if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n                 // Record position of the cache entry"}, {"sha": "5a7d106700af282d5b331723e48a2da753a9b2e5", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 64, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -444,7 +444,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n         // First we try to load the result from the on-disk cache\n-        let result = if Q::cache_on_disk(self.global_tcx(), key.clone()) &&\n+        let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n@@ -1243,66 +1243,3 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n \n     true\n }\n-\n-\n-// FIXME(#45015): Another piece of boilerplate code that could be generated in\n-//                a combined define_dep_nodes!()/define_queries!() macro.\n-macro_rules! impl_load_from_cache {\n-    ($($dep_kind:ident => $query_name:ident,)*) => {\n-        impl DepNode {\n-            // Check whether the query invocation corresponding to the given\n-            // DepNode is eligible for on-disk-caching.\n-            pub fn cache_on_disk(&self, tcx: TyCtxt<'_>) -> bool {\n-                use crate::ty::query::queries;\n-                use crate::ty::query::QueryDescription;\n-\n-                match self.kind {\n-                    $(DepKind::$dep_kind => {\n-                        let def_id = self.extract_def_id(tcx).unwrap();\n-                        queries::$query_name::cache_on_disk(tcx.global_tcx(), def_id)\n-                    })*\n-                    _ => false\n-                }\n-            }\n-\n-            // This is method will execute the query corresponding to the given\n-            // DepNode. It is only expected to work for DepNodes where the\n-            // above `cache_on_disk` methods returns true.\n-            // Also, as a sanity check, it expects that the corresponding query\n-            // invocation has been marked as green already.\n-            pub fn load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n-                match self.kind {\n-                    $(DepKind::$dep_kind => {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(self)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let def_id = self.extract_def_id(tcx).unwrap();\n-                        let _ = tcx.$query_name(def_id);\n-                    })*\n-                    _ => {\n-                        bug!()\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_load_from_cache!(\n-    typeck_tables_of => typeck_tables_of,\n-    optimized_mir => optimized_mir,\n-    unsafety_check_result => unsafety_check_result,\n-    borrowck => borrowck,\n-    mir_borrowck => mir_borrowck,\n-    mir_const_qualif => mir_const_qualif,\n-    const_is_rvalue_promotable_to_static => const_is_rvalue_promotable_to_static,\n-    check_match => check_match,\n-    type_of => type_of,\n-    generics_of => generics_of,\n-    predicates_of => predicates_of,\n-    used_trait_imports => used_trait_imports,\n-    codegen_fn_attrs => codegen_fn_attrs,\n-    specialization_graph_of => specialization_graph_of,\n-);"}, {"sha": "e9cf7bca25c4bb27c20b0e945508c684357d8ffa", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -1,6 +1,8 @@\n #![feature(proc_macro_hygiene)]\n #![deny(rust_2018_idioms)]\n \n+#![recursion_limit=\"128\"]\n+\n extern crate proc_macro;\n \n use synstructure::decl_derive;"}, {"sha": "d47bd0580d6cab8c5c5db56428e661e401ecccf5", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 72, "deletions": 20, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af8e872ea5ac77effa59f8d3f8794f12cb8865c/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=0af8e872ea5ac77effa59f8d3f8794f12cb8865c", "patch": "@@ -1,4 +1,5 @@\n use proc_macro::TokenStream;\n+use proc_macro2::{TokenTree, Delimiter};\n use syn::{\n     Token, Ident, Type, Attribute, ReturnType, Expr, Block, Error,\n     braced, parenthesized, parse_macro_input,\n@@ -35,7 +36,7 @@ enum QueryModifier {\n     Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Cache the query to disk if the `Expr` returns true.\n-    Cache(Option<Ident>, Expr),\n+    Cache(Option<(IdentOrWild, IdentOrWild)>, Block),\n \n     /// Custom code to load the query from disk.\n     LoadCached(Ident, Ident, Block),\n@@ -77,21 +78,26 @@ impl Parse for QueryModifier {\n             };\n             let desc = attr_content.parse_terminated(Expr::parse)?;\n             Ok(QueryModifier::Desc(tcx, desc))\n-        } else if modifier == \"cache\" {\n+        } else if modifier == \"cache_on_disk_if\" {\n             // Parse a cache modifier like:\n-            // `cache { |tcx| key.is_local() }`\n-            let attr_content;\n-            braced!(attr_content in input);\n-            let tcx = if attr_content.peek(Token![|]) {\n-                attr_content.parse::<Token![|]>()?;\n-                let tcx = attr_content.parse()?;\n-                attr_content.parse::<Token![|]>()?;\n-                Some(tcx)\n+            // `cache(tcx, value) { |tcx| key.is_local() }`\n+            let has_args = if let TokenTree::Group(group) = input.fork().parse()? {\n+                group.delimiter() == Delimiter::Parenthesis\n+            } else {\n+                false\n+            };\n+            let args = if has_args {\n+                let args;\n+                parenthesized!(args in input);\n+                let tcx = args.parse()?;\n+                args.parse::<Token![,]>()?;\n+                let value = args.parse()?;\n+                Some((tcx, value))\n             } else {\n                 None\n             };\n-            let expr = attr_content.parse()?;\n-            Ok(QueryModifier::Cache(tcx, expr))\n+            let block = input.parse()?;\n+            Ok(QueryModifier::Cache(args, block))\n         } else if modifier == \"load_cached\" {\n             // Parse a load_cached modifier like:\n             // `load_cached(tcx, id) { tcx.queries.on_disk_cache.try_load_query_result(tcx, id) }`\n@@ -203,8 +209,8 @@ struct QueryModifiers {\n     /// The description of the query.\n     desc: Option<(Option<Ident>, Punctuated<Expr, Token![,]>)>,\n \n-    /// Cache the query to disk if the `Expr` returns true.\n-    cache: Option<(Option<Ident>, Expr)>,\n+    /// Cache the query to disk if the `Block` returns true.\n+    cache: Option<(Option<(IdentOrWild, IdentOrWild)>, Block)>,\n \n     /// Custom code to load the query from disk.\n     load_cached: Option<(Ident, Ident, Block)>,\n@@ -247,11 +253,11 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 load_cached = Some((tcx, id, block));\n             }\n-            QueryModifier::Cache(tcx, expr) => {\n+            QueryModifier::Cache(args, expr) => {\n                 if cache.is_some() {\n                     panic!(\"duplicate modifier `cache` for query `{}`\", query.name);\n                 }\n-                cache = Some((tcx, expr));\n+                cache = Some((args, expr));\n             }\n             QueryModifier::Desc(tcx, list) => {\n                 if desc.is_some() {\n@@ -321,7 +327,7 @@ fn add_query_description_impl(\n     let key = &query.key.0;\n \n     // Find out if we should cache the query on disk\n-    let cache = modifiers.cache.as_ref().map(|(tcx, expr)| {\n+    let cache = modifiers.cache.as_ref().map(|(args, expr)| {\n         let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n             // Use custom code to load the query from disk\n             quote! {\n@@ -346,11 +352,22 @@ fn add_query_description_impl(\n             }\n         };\n \n-        let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n+        let tcx = args.as_ref().map(|t| {\n+            let t = &(t.0).0;\n+            quote! { #t }\n+        }).unwrap_or(quote! { _ });\n+        let value = args.as_ref().map(|t| {\n+            let t = &(t.1).0;\n+            quote! { #t }\n+        }).unwrap_or(quote! { _ });\n         quote! {\n             #[inline]\n             #[allow(unused_variables)]\n-            fn cache_on_disk(#tcx: TyCtxt<'tcx>, #key: Self::Key) -> bool {\n+            fn cache_on_disk(\n+                #tcx: TyCtxt<'tcx>,\n+                #key: Self::Key,\n+                #value: Option<&Self::Value>\n+            ) -> bool {\n                 #expr\n             }\n \n@@ -395,6 +412,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n+    let mut try_load_from_on_disk_cache_stream = quote! {};\n     let mut no_force_queries = Vec::new();\n \n     for group in groups.0 {\n@@ -409,6 +427,22 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 _ => quote! { #result_full },\n             };\n \n+            if modifiers.cache.is_some() && !modifiers.no_force {\n+                try_load_from_on_disk_cache_stream.extend(quote! {\n+                    DepKind::#name => {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(self)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let key = RecoverKey::recover(tcx.global_tcx(), self).unwrap();\n+                        if queries::#name::cache_on_disk(tcx.global_tcx(), key, None) {\n+                            let _ = tcx.#name(key);\n+                        }\n+                    }\n+                });\n+            }\n+\n             let mut attributes = Vec::new();\n \n             // Pass on the fatal_cycle modifier\n@@ -462,7 +496,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 });\n             }\n \n-            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n+            add_query_description_impl(\n+                &query,\n+                modifiers,\n+                &mut query_description_stream,\n+            );\n         }\n         let name = &group.name;\n         query_stream.extend(quote! {\n@@ -512,5 +550,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             }\n         }\n         #query_description_stream\n+\n+        impl DepNode {\n+            /// Check whether the query invocation corresponding to the given\n+            /// DepNode is eligible for on-disk-caching. If so, this is method\n+            /// will execute the query corresponding to the given DepNode.\n+            /// Also, as a sanity check, it expects that the corresponding query\n+            /// invocation has been marked as green already.\n+            pub fn try_load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n+                match self.kind {\n+                    #try_load_from_on_disk_cache_stream\n+                    _ => (),\n+                }\n+            }\n+        }\n     })\n }"}]}