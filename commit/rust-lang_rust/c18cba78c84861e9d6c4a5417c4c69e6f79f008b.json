{"sha": "c18cba78c84861e9d6c4a5417c4c69e6f79f008b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOGNiYTc4Yzg0ODYxZTlkNmM0YTU0MTdjNGM2OWU2Zjc5ZjAwOGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-15T15:54:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-15T15:54:55Z"}, "message": "Merge #9605\n\n9605: internal: Folding ranges respect item visibilities r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "43a7b32c955f663be55287f5c49191968c70304c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43a7b32c955f663be55287f5c49191968c70304c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c18cba78c84861e9d6c4a5417c4c69e6f79f008b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8FpPCRBK7hj4Ov3rIwAAxsQIAH9fC1N6Qass20f4qJaOoFEm\nE/6PCD14c6xCqk/YxrMKPYYcGMX2Ym32X5qkCSIXKntgNruG9cy64l5U5VWVpgn6\ngXn/hk4ZU1DbyMlBCpSfQDWuMeCnsBYiSmWHPdqef1hZEQF4rWugW35FbsUcd0M1\nqrlmGJZIfvj5XYSoo//nKVOrKw/d/oEP23NgDYqlzhonI9ZAxnToY3a26Q4nfXNf\nSbkZiev2WsHV8s4t96dLGZPTQDN4+RfChFSCAzKwuLnQFbsvFcykTXPMLChiV0Eu\niefuiF7qNPuI/Ipj7nRtiJYbIf4kTyB//apk4clQmoFC15OIF04Cn/usbTWuaLg=\n=YmFV\n-----END PGP SIGNATURE-----\n", "payload": "tree 43a7b32c955f663be55287f5c49191968c70304c\nparent e67cd766f750ddf377ad13552c68465861b09715\nparent ed734609719b0b18906c500c8ce91fc14a61cb19\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626364495 +0000\ncommitter GitHub <noreply@github.com> 1626364495 +0000\n\nMerge #9605\n\n9605: internal: Folding ranges respect item visibilities r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c18cba78c84861e9d6c4a5417c4c69e6f79f008b", "html_url": "https://github.com/rust-lang/rust/commit/c18cba78c84861e9d6c4a5417c4c69e6f79f008b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c18cba78c84861e9d6c4a5417c4c69e6f79f008b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e67cd766f750ddf377ad13552c68465861b09715", "url": "https://api.github.com/repos/rust-lang/rust/commits/e67cd766f750ddf377ad13552c68465861b09715", "html_url": "https://github.com/rust-lang/rust/commit/e67cd766f750ddf377ad13552c68465861b09715"}, {"sha": "ed734609719b0b18906c500c8ce91fc14a61cb19", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed734609719b0b18906c500c8ce91fc14a61cb19", "html_url": "https://github.com/rust-lang/rust/commit/ed734609719b0b18906c500c8ce91fc14a61cb19"}], "stats": {"total": 220, "additions": 107, "deletions": 113}, "files": [{"sha": "bfb4ce711cb7519b394efbf6fbdceb93a2f99654", "filename": "crates/ide/src/folding_ranges.rs", "status": "modified", "additions": 107, "deletions": 113, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/c18cba78c84861e9d6c4a5417c4c69e6f79f008b/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18cba78c84861e9d6c4a5417c4c69e6f79f008b/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffolding_ranges.rs?ref=c18cba78c84861e9d6c4a5417c4c69e6f79f008b", "patch": "@@ -1,12 +1,17 @@\n use rustc_hash::FxHashSet;\n \n use syntax::{\n-    ast::{self, AstNode, AstToken, VisibilityOwner},\n-    Direction, NodeOrToken, SourceFile,\n+    ast::{self, AstNode, AstToken},\n+    match_ast, Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, *},\n-    SyntaxNode, TextRange, TextSize,\n+    TextRange, TextSize,\n };\n \n+use std::hash::Hash;\n+\n+const REGION_START: &str = \"// region:\";\n+const REGION_END: &str = \"// endregion\";\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum FoldKind {\n     Comment,\n@@ -30,17 +35,18 @@ pub struct Fold {\n \n // Feature: Folding\n //\n-// Defines folding regions for curly braced blocks, runs of consecutive import\n-// statements, and `region` / `endregion` comment markers.\n+// Defines folding regions for curly braced blocks, runs of consecutive use, mod, const or static\n+// items, and `region` / `endregion` comment markers.\n pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n     let mut res = vec![];\n     let mut visited_comments = FxHashSet::default();\n     let mut visited_imports = FxHashSet::default();\n     let mut visited_mods = FxHashSet::default();\n     let mut visited_consts = FxHashSet::default();\n     let mut visited_statics = FxHashSet::default();\n+\n     // regions can be nested, here is a LIFO buffer\n-    let mut regions_starts: Vec<TextSize> = vec![];\n+    let mut region_starts: Vec<TextSize> = vec![];\n \n     for element in file.syntax().descendants_with_tokens() {\n         // Fold items that span multiple lines\n@@ -59,71 +65,60 @@ pub(crate) fn folding_ranges(file: &SourceFile) -> Vec<Fold> {\n             NodeOrToken::Token(token) => {\n                 // Fold groups of comments\n                 if let Some(comment) = ast::Comment::cast(token) {\n-                    if !visited_comments.contains(&comment) {\n-                        // regions are not real comments\n-                        if comment.text().trim().starts_with(\"// region:\") {\n-                            regions_starts.push(comment.syntax().text_range().start());\n-                        } else if comment.text().trim().starts_with(\"// endregion\") {\n-                            if let Some(region) = regions_starts.pop() {\n-                                res.push(Fold {\n-                                    range: TextRange::new(\n-                                        region,\n-                                        comment.syntax().text_range().end(),\n-                                    ),\n-                                    kind: FoldKind::Region,\n-                                })\n-                            }\n-                        } else {\n-                            if let Some(range) =\n-                                contiguous_range_for_comment(comment, &mut visited_comments)\n-                            {\n-                                res.push(Fold { range, kind: FoldKind::Comment })\n-                            }\n+                    if visited_comments.contains(&comment) {\n+                        continue;\n+                    }\n+                    let text = comment.text().trim_start();\n+                    if text.starts_with(REGION_START) {\n+                        region_starts.push(comment.syntax().text_range().start());\n+                    } else if text.starts_with(REGION_END) {\n+                        if let Some(region) = region_starts.pop() {\n+                            res.push(Fold {\n+                                range: TextRange::new(region, comment.syntax().text_range().end()),\n+                                kind: FoldKind::Region,\n+                            })\n                         }\n+                    } else if let Some(range) =\n+                        contiguous_range_for_comment(comment, &mut visited_comments)\n+                    {\n+                        res.push(Fold { range, kind: FoldKind::Comment })\n                     }\n                 }\n             }\n             NodeOrToken::Node(node) => {\n-                // Fold groups of imports\n-                if node.kind() == USE && !visited_imports.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_imports) {\n-                        res.push(Fold { range, kind: FoldKind::Imports })\n-                    }\n-                }\n-\n-                // Fold groups of mods\n-                if let Some(module) = ast::Module::cast(node.clone()) {\n-                    if !has_visibility(&node)\n-                        && !visited_mods.contains(&node)\n-                        && module.item_list().is_none()\n-                    {\n-                        if let Some(range) = contiguous_range_for_group_unless(\n-                            &node,\n-                            has_visibility,\n-                            &mut visited_mods,\n-                        ) {\n-                            res.push(Fold { range, kind: FoldKind::Mods })\n-                        }\n-                    }\n-                }\n-\n-                // Fold groups of consts\n-                if node.kind() == CONST && !visited_consts.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_consts) {\n-                        res.push(Fold { range, kind: FoldKind::Consts })\n-                    }\n-                }\n-                // Fold groups of consts\n-                if node.kind() == STATIC && !visited_statics.contains(&node) {\n-                    if let Some(range) = contiguous_range_for_group(&node, &mut visited_statics) {\n-                        res.push(Fold { range, kind: FoldKind::Statics })\n-                    }\n-                }\n-\n-                // Fold where clause\n-                if node.kind() == WHERE_CLAUSE {\n-                    if let Some(range) = fold_range_for_where_clause(&node) {\n-                        res.push(Fold { range, kind: FoldKind::WhereClause })\n+                match_ast! {\n+                    match node {\n+                        ast::Module(module) => {\n+                            if module.item_list().is_none() {\n+                                if let Some(range) = contiguous_range_for_item_group(\n+                                    module,\n+                                    &mut visited_mods,\n+                                ) {\n+                                    res.push(Fold { range, kind: FoldKind::Mods })\n+                                }\n+                            }\n+                        },\n+                        ast::Use(use_) => {\n+                            if let Some(range) = contiguous_range_for_item_group(use_, &mut visited_imports) {\n+                                res.push(Fold { range, kind: FoldKind::Imports })\n+                            }\n+                        },\n+                        ast::Const(konst) => {\n+                            if let Some(range) = contiguous_range_for_item_group(konst, &mut visited_consts) {\n+                                res.push(Fold { range, kind: FoldKind::Consts })\n+                            }\n+                        },\n+                        ast::Static(statik) => {\n+                            if let Some(range) = contiguous_range_for_item_group(statik, &mut visited_statics) {\n+                                res.push(Fold { range, kind: FoldKind::Statics })\n+                            }\n+                        },\n+                        ast::WhereClause(where_clause) => {\n+                            if let Some(range) = fold_range_for_where_clause(where_clause) {\n+                                res.push(Fold { range, kind: FoldKind::WhereClause })\n+                            }\n+                        },\n+                        _ => (),\n                     }\n                 }\n             }\n@@ -154,26 +149,16 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     }\n }\n \n-fn has_visibility(node: &SyntaxNode) -> bool {\n-    ast::Module::cast(node.clone()).and_then(|m| m.visibility()).is_some()\n-}\n-\n-fn contiguous_range_for_group(\n-    first: &SyntaxNode,\n-    visited: &mut FxHashSet<SyntaxNode>,\n-) -> Option<TextRange> {\n-    contiguous_range_for_group_unless(first, |_| false, visited)\n-}\n-\n-fn contiguous_range_for_group_unless(\n-    first: &SyntaxNode,\n-    unless: impl Fn(&SyntaxNode) -> bool,\n-    visited: &mut FxHashSet<SyntaxNode>,\n-) -> Option<TextRange> {\n-    visited.insert(first.clone());\n+fn contiguous_range_for_item_group<N>(first: N, visited: &mut FxHashSet<N>) -> Option<TextRange>\n+where\n+    N: ast::VisibilityOwner + Clone + Hash + Eq,\n+{\n+    if !visited.insert(first.clone()) {\n+        return None;\n+    }\n \n-    let mut last = first.clone();\n-    for element in first.siblings_with_tokens(Direction::Next) {\n+    let (mut last, mut last_vis) = (first.clone(), first.visibility());\n+    for element in first.syntax().siblings_with_tokens(Direction::Next) {\n         let node = match element {\n             NodeOrToken::Token(token) => {\n                 if let Some(ws) = ast::Whitespace::cast(token) {\n@@ -189,23 +174,35 @@ fn contiguous_range_for_group_unless(\n             NodeOrToken::Node(node) => node,\n         };\n \n-        // Stop if we find a node that doesn't belong to the group\n-        if node.kind() != first.kind() || unless(&node) {\n-            break;\n+        if let Some(next) = N::cast(node) {\n+            let next_vis = next.visibility();\n+            if eq_visibility(next_vis.clone(), last_vis) {\n+                visited.insert(next.clone());\n+                last_vis = next_vis;\n+                last = next;\n+                continue;\n+            }\n         }\n-\n-        visited.insert(node.clone());\n-        last = node;\n+        // Stop if we find an item of a different kind or with a different visibility.\n+        break;\n     }\n \n-    if first != &last {\n-        Some(TextRange::new(first.text_range().start(), last.text_range().end()))\n+    if first != last {\n+        Some(TextRange::new(first.syntax().text_range().start(), last.syntax().text_range().end()))\n     } else {\n         // The group consists of only one element, therefore it cannot be folded\n         None\n     }\n }\n \n+fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n+    match (vis0, vis1) {\n+        (None, None) => true,\n+        (Some(vis0), Some(vis1)) => vis0.is_eq_to(&vis1),\n+        _ => false,\n+    }\n+}\n+\n fn contiguous_range_for_comment(\n     first: ast::Comment,\n     visited: &mut FxHashSet<ast::Comment>,\n@@ -230,12 +227,9 @@ fn contiguous_range_for_comment(\n                 }\n                 if let Some(c) = ast::Comment::cast(token) {\n                     if c.kind() == group_kind {\n+                        let text = c.text().trim_start();\n                         // regions are not real comments\n-                        if c.text().trim().starts_with(\"// region:\")\n-                            || c.text().trim().starts_with(\"// endregion\")\n-                        {\n-                            break;\n-                        } else {\n+                        if !(text.starts_with(REGION_START) || text.starts_with(REGION_END)) {\n                             visited.insert(c.clone());\n                             last = c;\n                             continue;\n@@ -259,19 +253,14 @@ fn contiguous_range_for_comment(\n     }\n }\n \n-fn fold_range_for_where_clause(node: &SyntaxNode) -> Option<TextRange> {\n-    let first_where_pred = node.first_child();\n-    let last_where_pred = node.last_child();\n+fn fold_range_for_where_clause(where_clause: ast::WhereClause) -> Option<TextRange> {\n+    let first_where_pred = where_clause.predicates().next();\n+    let last_where_pred = where_clause.predicates().last();\n \n     if first_where_pred != last_where_pred {\n-        let mut it = node.descendants_with_tokens();\n-        if let (Some(_where_clause), Some(where_kw), Some(last_comma)) =\n-            (it.next(), it.next(), it.last())\n-        {\n-            let start = where_kw.text_range().end();\n-            let end = last_comma.text_range().end();\n-            return Some(TextRange::new(start, end));\n-        }\n+        let start = where_clause.where_token()?.text_range().end();\n+        let end = where_clause.syntax().text_range().end();\n+        return Some(TextRange::new(start, end));\n     }\n     None\n }\n@@ -286,16 +275,18 @@ mod tests {\n         let (ranges, text) = extract_tags(ra_fixture, \"fold\");\n \n         let parse = SourceFile::parse(&text);\n-        let folds = folding_ranges(&parse.tree());\n+        let mut folds = folding_ranges(&parse.tree());\n+        folds.sort_by_key(|fold| (fold.range.start(), fold.range.end()));\n+\n         assert_eq!(\n             folds.len(),\n             ranges.len(),\n             \"The amount of folds is different than the expected amount\"\n         );\n \n         for (fold, (range, attr)) in folds.iter().zip(ranges.into_iter()) {\n-            assert_eq!(fold.range.start(), range.start());\n-            assert_eq!(fold.range.end(), range.end());\n+            assert_eq!(fold.range.start(), range.start(), \"mismatched start of folding ranges\");\n+            assert_eq!(fold.range.end(), range.end(), \"mismatched end of folding ranges\");\n \n             let kind = match fold.kind {\n                 FoldKind::Comment => \"comment\",\n@@ -525,7 +516,10 @@ const FOO: [usize; 4] = <fold array>[\n // 1. some normal comment\n <fold region>// region: test\n // 2. some normal comment\n-calling_function(x,y);\n+<fold region>// region: inner\n+fn f() {}\n+// endregion</fold>\n+fn f2() {}\n // endregion: test</fold>\n \"#,\n         )"}]}