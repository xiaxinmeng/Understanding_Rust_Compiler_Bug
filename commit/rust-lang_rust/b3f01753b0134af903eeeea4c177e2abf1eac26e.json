{"sha": "b3f01753b0134af903eeeea4c177e2abf1eac26e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZjAxNzUzYjAxMzRhZjkwM2VlZWVhNGMxNzdlMmFiZjFlYWMyNmU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-12T20:43:26Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-27T00:30:10Z"}, "message": "Inline recurse into only callsite", "tree": {"sha": "d07a3780ea11481b4f65bd0f9edf9876c3d84335", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d07a3780ea11481b4f65bd0f9edf9876c3d84335"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3f01753b0134af903eeeea4c177e2abf1eac26e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f01753b0134af903eeeea4c177e2abf1eac26e", "html_url": "https://github.com/rust-lang/rust/commit/b3f01753b0134af903eeeea4c177e2abf1eac26e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3f01753b0134af903eeeea4c177e2abf1eac26e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edfd5556f1ddc44a9cf5a53db417330661d47053", "url": "https://api.github.com/repos/rust-lang/rust/commits/edfd5556f1ddc44a9cf5a53db417330661d47053", "html_url": "https://github.com/rust-lang/rust/commit/edfd5556f1ddc44a9cf5a53db417330661d47053"}], "stats": {"total": 97, "additions": 40, "deletions": 57}, "files": [{"sha": "faf4f46ca54956dd268245fe85adabe36e41e033", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 40, "deletions": 57, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/b3f01753b0134af903eeeea4c177e2abf1eac26e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f01753b0134af903eeeea4c177e2abf1eac26e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b3f01753b0134af903eeeea4c177e2abf1eac26e", "patch": "@@ -1885,31 +1885,6 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Recurse in the directory structure and change the \"root path\" to make\n-    /// sure it always points to the top (relatively).\n-    fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n-        F: FnOnce(&mut Context) -> T,\n-    {\n-        if s.is_empty() {\n-            panic!(\"Unexpected empty destination: {:?}\", self.current);\n-        }\n-        let prev = self.dst.clone();\n-        self.dst.push(&s);\n-        self.current.push(s);\n-\n-        info!(\"Recursing into {}\", self.dst.display());\n-\n-        let ret = f(self);\n-\n-        info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-        // Go back to where we were at\n-        self.dst = prev;\n-        self.current.pop().unwrap();\n-\n-        ret\n-    }\n-\n     /// Main method for rendering a crate.\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n@@ -2090,42 +2065,50 @@ impl Context {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             let name = item.name.as_ref().unwrap().to_string();\n-            let mut item = Some(item);\n-            let scx = self.shared.clone();\n-            self.recurse(name, |this| {\n-                let item = item.take().unwrap();\n-\n-                let mut buf = Vec::new();\n-                this.render_item(&mut buf, &item, false).unwrap();\n-                // buf will be empty if the module is stripped and there is no redirect for it\n-                if !buf.is_empty() {\n-                    this.shared.ensure_dir(&this.dst)?;\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    scx.fs.write(&joint_dst, buf)?;\n-                }\n+            let scx = &self.shared;\n+            if name.is_empty() {\n+                panic!(\"Unexpected empty destination: {:?}\", self.current);\n+            }\n+            let prev = self.dst.clone();\n+            self.dst.push(&name);\n+            self.current.push(name);\n \n-                let m = match item.inner {\n-                    clean::StrippedItem(box clean::ModuleItem(m)) |\n-                    clean::ModuleItem(m) => m,\n-                    _ => unreachable!()\n-                };\n+            info!(\"Recursing into {}\", self.dst.display());\n \n-                // Render sidebar-items.js used throughout this module.\n-                if !this.render_redirect_pages {\n-                    let items = this.build_sidebar_items(&m);\n-                    let js_dst = this.dst.join(\"sidebar-items.js\");\n-                    let mut v = Vec::new();\n-                    try_err!(write!(&mut v, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    scx.fs.write(&js_dst, &v)?;\n-                }\n+            let mut buf = Vec::new();\n+            self.render_item(&mut buf, &item, false).unwrap();\n+            // buf will be empty if the module is stripped and there is no redirect for it\n+            if !buf.is_empty() {\n+                self.shared.ensure_dir(&self.dst)?;\n+                let joint_dst = self.dst.join(\"index.html\");\n+                scx.fs.write(&joint_dst, buf)?;\n+            }\n \n-                for item in m.items {\n-                    f(this, item);\n-                }\n+            let m = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) |\n+                clean::ModuleItem(m) => m,\n+                _ => unreachable!()\n+            };\n+\n+            // Render sidebar-items.js used throughout this module.\n+            if !self.render_redirect_pages {\n+                let items = self.build_sidebar_items(&m);\n+                let js_dst = self.dst.join(\"sidebar-items.js\");\n+                let mut v = Vec::new();\n+                try_err!(write!(&mut v, \"initSidebarItems({});\",\n+                                as_json(&items)), &js_dst);\n+                scx.fs.write(&js_dst, &v)?;\n+            }\n+\n+            for item in m.items {\n+                f(self, item);\n+            }\n+\n+            info!(\"Recursed; leaving {}\", self.dst.display());\n \n-                Ok(())\n-            })?;\n+            // Go back to where we were at\n+            self.dst = prev;\n+            self.current.pop().unwrap();\n         } else if item.name.is_some() {\n             let mut buf = Vec::new();\n             self.render_item(&mut buf, &item, true).unwrap();"}]}