{"sha": "42450d2511f8f174dc7448d0e9839d4b76d64482", "node_id": "C_kwDOAAsO6NoAKDQyNDUwZDI1MTFmOGYxNzRkYzc0NDhkMGU5ODM5ZDRiNzZkNjQ0ODI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T05:45:55Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T05:45:55Z"}, "message": "Add signature help for tuple patterns and expressions", "tree": {"sha": "979647d5955036d5da8a267449491545f6129e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/979647d5955036d5da8a267449491545f6129e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42450d2511f8f174dc7448d0e9839d4b76d64482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42450d2511f8f174dc7448d0e9839d4b76d64482", "html_url": "https://github.com/rust-lang/rust/commit/42450d2511f8f174dc7448d0e9839d4b76d64482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42450d2511f8f174dc7448d0e9839d4b76d64482/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecb8616870aa9ef0c7159e56f563dc0ad78b32f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb8616870aa9ef0c7159e56f563dc0ad78b32f7", "html_url": "https://github.com/rust-lang/rust/commit/ecb8616870aa9ef0c7159e56f563dc0ad78b32f7"}], "stats": {"total": 418, "additions": 390, "deletions": 28}, "files": [{"sha": "455b519f80b0b4e577f9c85ab194ca1a2d823bc9", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 390, "deletions": 28, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/42450d2511f8f174dc7448d0e9839d4b76d64482/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42450d2511f8f174dc7448d0e9839d4b76d64482/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=42450d2511f8f174dc7448d0e9839d4b76d64482", "patch": "@@ -15,8 +15,9 @@ use ide_db::{\n use stdx::format_to;\n use syntax::{\n     algo,\n-    ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxElementChildren, SyntaxToken, TextRange, TextSize,\n+    ast::{self, AstChildren, HasArgList},\n+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken,\n+    TextRange, TextSize, T,\n };\n \n use crate::RootDatabase;\n@@ -116,6 +117,20 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n                 },\n+                ast::TuplePat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_pat(&sema, tuple_pat, token);\n+                },\n+                ast::TupleExpr(tuple_expr) => {\n+                    let cursor_outside = tuple_expr.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_expr(&sema, tuple_expr, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -395,19 +410,16 @@ fn signature_help_for_tuple_struct_pat(\n     pat: ast::TupleStructPat,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n-    let is_left_of_rest_pat =\n-        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n-\n+    let path = pat.path()?;\n+    let path_res = sema.resolve_path(&path)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n         parameters: vec![],\n         active_parameter: None,\n     };\n-\n     let db = sema.db;\n-    let path_res = sema.resolve_path(&pat.path()?)?;\n+\n     let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n         let en = variant.parent_enum(db);\n \n@@ -435,30 +447,72 @@ fn signature_help_for_tuple_struct_pat(\n             _ => return None,\n         }\n     };\n-    let commas = pat\n-        .syntax()\n-        .children_with_tokens()\n-        .filter_map(syntax::NodeOrToken::into_token)\n-        .filter(|t| t.kind() == syntax::T![,]);\n-    res.active_parameter = Some(if is_left_of_rest_pat {\n-        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n-    } else {\n-        let n_commas = commas\n-            .collect::<Vec<_>>()\n-            .into_iter()\n-            .rev()\n-            .take_while(|t| t.text_range().start() > token.text_range().start())\n-            .count();\n-        fields.len().saturating_sub(1).saturating_sub(n_commas)\n-    });\n+    Some(signature_help_for_tuple_pat_ish(\n+        db,\n+        res,\n+        pat.syntax(),\n+        token,\n+        pat.fields(),\n+        fields.into_iter().map(|it| it.ty(db)),\n+    ))\n+}\n+\n+fn signature_help_for_tuple_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TuplePat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let db = sema.db;\n+    let field_pats = pat.fields();\n+    let pat = pat.into();\n+    let ty = sema.type_of_pat(&pat)?;\n+    let fields = ty.original.tuple_fields(db);\n+\n+    Some(signature_help_for_tuple_pat_ish(\n+        db,\n+        SignatureHelp {\n+            doc: None,\n+            signature: String::from('('),\n+            parameters: vec![],\n+            active_parameter: None,\n+        },\n+        pat.syntax(),\n+        token,\n+        field_pats,\n+        fields.into_iter(),\n+    ))\n+}\n+\n+fn signature_help_for_tuple_expr(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: ast::TupleExpr,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let active_parameter = Some(\n+        expr.syntax()\n+            .children_with_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .filter(|t| t.kind() == T![,])\n+            .take_while(|t| t.text_range().start() <= token.text_range().start())\n+            .count(),\n+    );\n \n+    let db = sema.db;\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::from('('),\n+        parameters: vec![],\n+        active_parameter,\n+    };\n+    let expr = sema.type_of_expr(&expr.into())?;\n+    let fields = expr.original.tuple_fields(db);\n     let mut buf = String::new();\n-    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+    for ty in fields {\n         format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n         res.push_call_param(&buf);\n         buf.clear();\n     }\n-    res.signature.push_str(\")\");\n+    res.signature.push(')');\n     Some(res)\n }\n \n@@ -470,8 +524,8 @@ fn signature_help_for_record_(\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     let active_parameter = field_list_children\n-        .filter_map(syntax::NodeOrToken::into_token)\n-        .filter(|t| t.kind() == syntax::T![,])\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n         .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n@@ -542,6 +596,46 @@ fn signature_help_for_record_(\n     Some(res)\n }\n \n+fn signature_help_for_tuple_pat_ish(\n+    db: &RootDatabase,\n+    mut res: SignatureHelp,\n+    pat: &SyntaxNode,\n+    token: SyntaxToken,\n+    mut field_pats: AstChildren<ast::Pat>,\n+    fields: impl ExactSizeIterator<Item = hir::Type>,\n+) -> SignatureHelp {\n+    let rest_pat = field_pats.find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let commas = pat\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,]);\n+\n+    res.active_parameter = {\n+        Some(if is_left_of_rest_pat {\n+            commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+        } else {\n+            let n_commas = commas\n+                .collect::<Vec<_>>()\n+                .into_iter()\n+                .rev()\n+                .take_while(|t| t.text_range().start() > token.text_range().start())\n+                .count();\n+            fields.len().saturating_sub(1).saturating_sub(n_commas)\n+        })\n+    };\n+\n+    let mut buf = String::new();\n+    for ty in fields {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    res\n+}\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -1851,4 +1945,272 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_tuple_expr_free() {\n+        check(\n+            r#\"\n+fn main() {\n+    (0$0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    ($0 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    (1, 3 $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    (1, 3 $0,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_expr_expected() {\n+        // FIXME: Seems like we discard valuable results in typeck here\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32)= ($0, 1, 3);\n+}\n+\"#,\n+            expect![\"\"],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32, u32)= ($0, 1, 3);\n+}\n+\"#,\n+            expect![\"\"],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32)= ($0, 1, 3, 5);\n+}\n+\"#,\n+            expect![\"\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_pat_free() {\n+        // FIXME: Seems like we discard valuable results in typeck here\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0);\n+}\n+\"#,\n+            // FIXME: This is wrong, this should not mark the last as active\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_pat_expected() {\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3): (i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0 1, 3): (i32, i32, i32);\n+}\n+\"#,\n+            // FIXME: tuple pat should be of size 3 ideally\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0): (i32,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..): (i32, i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32, i32)\n+                 ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0): (i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ---  ---  ^^^\n+            \"#]],\n+        );\n+    }\n+    #[test]\n+    fn test_tuple_pat_expected_inferred() {\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3) = (1, 2 ,3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0 1, 3) = (1, 2, 3);\n+}\n+\"#,\n+            // FIXME: tuple pat should be of size 3 ideally\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0) = (1,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..) = (1, 2, 3, 4);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32, i32)\n+                 ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0) = (1, 2, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ---  ---  ^^^\n+            \"#]],\n+        );\n+    }\n }"}]}