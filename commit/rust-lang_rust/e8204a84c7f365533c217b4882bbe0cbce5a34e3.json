{"sha": "e8204a84c7f365533c217b4882bbe0cbce5a34e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjA0YTg0YzdmMzY1NTMzYzIxN2I0ODgyYmJlMGNiY2U1YTM0ZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-12T05:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-12T05:11:18Z"}, "message": "auto merge of #16195 : P1start/rust/more-index, r=aturon\n\nImplement `Index` for `RingBuf`, `HashMap`, `TreeMap`, `SmallIntMap`, and `TrieMap`.\r\n\r\nIf there\u2019s anything that I missed or should be removed, let me know.", "tree": {"sha": "467838df5fcdd90f3fb47dcb95cf766ef4df3347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467838df5fcdd90f3fb47dcb95cf766ef4df3347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8204a84c7f365533c217b4882bbe0cbce5a34e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8204a84c7f365533c217b4882bbe0cbce5a34e3", "html_url": "https://github.com/rust-lang/rust/commit/e8204a84c7f365533c217b4882bbe0cbce5a34e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8204a84c7f365533c217b4882bbe0cbce5a34e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49a970f2449a78f28b6c301e542d38593094ca77", "url": "https://api.github.com/repos/rust-lang/rust/commits/49a970f2449a78f28b6c301e542d38593094ca77", "html_url": "https://github.com/rust-lang/rust/commit/49a970f2449a78f28b6c301e542d38593094ca77"}, {"sha": "8f71cb06bc019af707f119b5dda3d96a5ca1330c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f71cb06bc019af707f119b5dda3d96a5ca1330c", "html_url": "https://github.com/rust-lang/rust/commit/8f71cb06bc019af707f119b5dda3d96a5ca1330c"}], "stats": {"total": 238, "additions": 216, "deletions": 22}, "files": [{"sha": "736861a54a43410bef87b0fdc97197f95e3baca9", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -139,6 +139,8 @@ impl<T> RingBuf<T> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// #![allow(deprecated)]\n+    ///\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::new();\n@@ -147,6 +149,7 @@ impl<T> RingBuf<T> {\n     /// buf.push(5);\n     /// assert_eq!(buf.get(1), &4);\n     /// ```\n+    #[deprecated = \"prefer using indexing, e.g., ringbuf[0]\"]\n     pub fn get<'a>(&'a self, i: uint) -> &'a T {\n         let idx = self.raw_index(i);\n         match *self.elts.get(idx) {\n@@ -169,7 +172,7 @@ impl<T> RingBuf<T> {\n     /// buf.push(4);\n     /// buf.push(5);\n     /// *buf.get_mut(1) = 7;\n-    /// assert_eq!(buf.get(1), &7);\n+    /// assert_eq!(buf[1], 7);\n     /// ```\n     pub fn get_mut<'a>(&'a mut self, i: uint) -> &'a mut T {\n         let idx = self.raw_index(i);\n@@ -195,8 +198,8 @@ impl<T> RingBuf<T> {\n     /// buf.push(4);\n     /// buf.push(5);\n     /// buf.swap(0, 2);\n-    /// assert_eq!(buf.get(0), &5);\n-    /// assert_eq!(buf.get(2), &3);\n+    /// assert_eq!(buf[0], 5);\n+    /// assert_eq!(buf[2], 3);\n     /// ```\n     pub fn swap(&mut self, i: uint, j: uint) {\n         assert!(i < self.len());\n@@ -476,6 +479,21 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n+impl<A> Index<uint, A> for RingBuf<A> {\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a A {\n+        self.get(*i)\n+    }\n+}\n+\n+// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n+/*impl<A> IndexMut<uint, A> for RingBuf<A> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut A {\n+        self.get_mut(*index)\n+    }\n+}*/\n+\n impl<A> FromIterator<A> for RingBuf<A> {\n     fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n@@ -653,6 +671,25 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_index() {\n+        let mut deq = RingBuf::new();\n+        for i in range(1u, 4) {\n+            deq.push_front(i);\n+        }\n+        assert_eq!(deq[1], 2);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_out_of_bounds() {\n+        let mut deq = RingBuf::new();\n+        for i in range(1u, 4) {\n+            deq.push_front(i);\n+        }\n+        deq[3];\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut test::Bencher) {\n         b.iter(|| {"}, {"sha": "39244c7cd5fa60a7dc2c4e3581a97072acb95d8f", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -209,12 +209,15 @@ impl<V> SmallIntMap<V> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n+    ///\n     /// use std::collections::SmallIntMap;\n     ///\n     /// let mut map = SmallIntMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.get(&1), &\"a\");\n     /// ```\n+    #[deprecated = \"prefer using indexing, e.g., map[0]\"]\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n@@ -330,11 +333,11 @@ impl<V:Clone> SmallIntMap<V> {\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update(1, vec![1i, 2], |old, new| old.append(new.as_slice())));\n-    /// assert_eq!(map.get(&1), &vec![1i, 2]);\n+    /// assert_eq!(map[1], vec![1i, 2]);\n     ///\n     /// // Key exists, update the value\n     /// assert!(!map.update(1, vec![3i, 4], |old, new| old.append(new.as_slice())));\n-    /// assert_eq!(map.get(&1), &vec![1i, 2, 3, 4]);\n+    /// assert_eq!(map[1], vec![1i, 2, 3, 4]);\n     /// ```\n     pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n@@ -354,11 +357,11 @@ impl<V:Clone> SmallIntMap<V> {\n     ///\n     /// // Key does not exist, will do a simple insert\n     /// assert!(map.update_with_key(7, 10, |key, old, new| (old + new) % key));\n-    /// assert_eq!(map.get(&7), &10);\n+    /// assert_eq!(map[7], 10);\n     ///\n     /// // Key exists, update the value\n     /// assert!(!map.update_with_key(7, 20, |key, old, new| (old + new) % key));\n-    /// assert_eq!(map.get(&7), &2);\n+    /// assert_eq!(map[7], 2);\n     /// ```\n     pub fn update_with_key(&mut self,\n                            key: uint,\n@@ -416,6 +419,21 @@ impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n     }\n }\n \n+impl<V> Index<uint, V> for SmallIntMap<V> {\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a V {\n+        self.get(i)\n+    }\n+}\n+\n+// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n+/*impl<V> IndexMut<uint, V> for SmallIntMap<V> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n+        self.find_mut(i).expect(\"key not present\")\n+    }\n+}*/\n+\n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $getter:ident) => {\n         impl<'a, T> Iterator<$elem> for $name<'a, T> {\n@@ -843,6 +861,29 @@ mod test_map {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n+\n+    #[test]\n+    fn test_index() {\n+        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        assert_eq!(map[3], 4);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_nonexistent() {\n+        let mut map: SmallIntMap<int> = SmallIntMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        map[4];\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ae87411133f4f72df730e2a7b2f9fbc941931173", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -246,6 +246,20 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n }\n \n+impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n+    #[inline]\n+    fn index<'a>(&'a self, i: &K) -> &'a V {\n+        self.find(i).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/*impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n+        self.find_mut(i).expect(\"no entry found for key\")\n+    }\n+}*/\n+\n impl<K: Ord, V> TreeMap<K, V> {\n     /// Create an empty `TreeMap`.\n     ///\n@@ -2149,6 +2163,28 @@ mod test_treemap {\n         }\n     }\n \n+    #[test]\n+    fn test_index() {\n+        let mut map: TreeMap<int, int> = TreeMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        assert_eq!(map[2], 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_nonexistent() {\n+        let mut map: TreeMap<int, int> = TreeMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        map[4];\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "c3dcebfc815b1fd4cddbe1715e4d733a30ff7139", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -502,6 +502,21 @@ impl<S: Writer, T: Hash<S>> Hash<S> for TrieMap<T> {\n     }\n }\n \n+impl<T> Index<uint, T> for TrieMap<T> {\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a T {\n+        self.find(i).expect(\"key not present\")\n+    }\n+}\n+\n+// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n+/*impl<T> IndexMut<uint, T> for TrieMap<T> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut T {\n+        self.find_mut(i).expect(\"key not present\")\n+    }\n+}*/\n+\n /// A set implemented as a radix trie.\n ///\n /// # Example\n@@ -1391,6 +1406,29 @@ mod test_map {\n         assert!(map_str == \"{1: a, 2: b}\".to_string());\n         assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n     }\n+\n+    #[test]\n+    fn test_index() {\n+        let mut map = TrieMap::new();\n+\n+        map.insert(1, 2i);\n+        map.insert(2, 1i);\n+        map.insert(3, 4i);\n+\n+        assert_eq!(map[2], 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_nonexistent() {\n+        let mut map = TrieMap::new();\n+\n+        map.insert(1, 2i);\n+        map.insert(2, 1i);\n+        map.insert(3, 4i);\n+\n+        map[4];\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "a1dd49bbf898d97efbd00cd950a69f5b8cd9b876", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -166,7 +166,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             if ast_util::is_local(did) || cache.inlined.contains(&did) {\n                 Some((\"../\".repeat(loc.len())).to_string())\n             } else {\n-                match *cache.extern_locations.get(&did.krate) {\n+                match cache.extern_locations[did.krate] {\n                     render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n                         Some((\"../\".repeat(loc.len())).to_string())\n@@ -291,11 +291,11 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = m.paths.get(&ast::DefId {\n+            let path = &m.paths[ast::DefId {\n                 krate: cnum,\n                 node: ast::CRATE_NODE_ID,\n-            });\n-            let loc = match *m.extern_locations.get(&cnum) {\n+            }];\n+            let loc = match m.extern_locations[cnum] {\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n                     let loc = current_location_key.get().unwrap();\n@@ -343,11 +343,11 @@ impl fmt::Show for clean::Type {\n         match *self {\n             clean::TyParamBinder(id) => {\n                 let m = cache_key.get().unwrap();\n-                f.write(m.typarams.get(&ast_util::local_def(id)).as_bytes())\n+                f.write(m.typarams[ast_util::local_def(id)].as_bytes())\n             }\n             clean::Generic(did) => {\n                 let m = cache_key.get().unwrap();\n-                f.write(m.typarams.get(&did).as_bytes())\n+                f.write(m.typarams[did].as_bytes())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));"}, {"sha": "4f511e390ff98650100a3ae13a56c833fda05f49", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -1274,8 +1274,8 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache_key.get().unwrap();\n-            let path = cache.external_paths.get(&self.item.def_id);\n-            let root = match *cache.extern_locations.get(&self.item.def_id.krate) {\n+            let path = &cache.external_paths[self.item.def_id];\n+            let root = match cache.extern_locations[self.item.def_id.krate] {\n                 Remote(ref s) => s.to_string(),\n                 Local => self.cx.root_path.clone(),\n                 Unknown => return None,"}, {"sha": "5b2a542ca9664b308ab707eef25c843438e36c7f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -229,7 +229,7 @@ impl<'a> RustdocVisitor<'a> {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return false\n         };\n-        let def = tcx.def_map.borrow().get(&id).def_id();\n+        let def = (*tcx.def_map.borrow())[id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "2de9db1cc93e33ddee3bfd9f5b3f64cc2af27847", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 48, "deletions": 6, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8204a84c7f365533c217b4882bbe0cbce5a34e3/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=e8204a84c7f365533c217b4882bbe0cbce5a34e3", "patch": "@@ -26,6 +26,7 @@ use mem::replace;\n use num;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n+use ops::Index;\n \n mod table {\n     use clone::Clone;\n@@ -1341,7 +1342,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// // Update and return the existing value\n     /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n-    /// assert_eq!(map.get(&\"a\"), &7);\n+    /// assert_eq!(map[\"a\"], 7);\n     /// ```\n     pub fn insert_or_update_with<'a>(\n                                  &'a mut self,\n@@ -1392,9 +1393,9 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// }\n     ///\n     /// assert_eq!(map.len(), 3);\n-    /// assert_eq!(map.get(&\"a key\"), &vec![\"value\", \"new value\"]);\n-    /// assert_eq!(map.get(&\"b key\"), &vec![\"new value\"]);\n-    /// assert_eq!(map.get(&\"z key\"), &vec![\"new value\", \"value\"]);\n+    /// assert_eq!(map[\"a key\"], vec![\"value\", \"new value\"]);\n+    /// assert_eq!(map[\"b key\"], vec![\"new value\"]);\n+    /// assert_eq!(map[\"z key\"], vec![\"new value\", \"value\"]);\n     /// ```\n     pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n                                            k: K,\n@@ -1426,12 +1427,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// # Example\n     ///\n     /// ```\n+    /// #![allow(deprecated)]\n+    ///\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map = HashMap::new();\n     /// map.insert(\"a\", 1i);\n     /// assert_eq!(map.get(&\"a\"), &1);\n     /// ```\n+    #[deprecated = \"prefer indexing instead, e.g., map[key]\"]\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n@@ -1458,11 +1462,11 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///     let val = map.get_mut(&\"a\");\n     ///     *val = 40;\n     /// }\n-    /// assert_eq!(map.get(&\"a\"), &40);\n+    /// assert_eq!(map[\"a\"], 40);\n     ///\n     /// // A more direct way could be:\n     /// *map.get_mut(&\"a\") = -2;\n-    /// assert_eq!(map.get(&\"a\"), &-2);\n+    /// assert_eq!(map[\"a\"], -2);\n     /// ```\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n@@ -1738,6 +1742,21 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n+impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n+    #[inline]\n+    fn index<'a>(&'a self, index: &K) -> &'a V {\n+        self.get(index)\n+    }\n+}\n+\n+// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n+/*impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> ops::IndexMut<K, V> for HashMap<K, V, H> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &K) -> &'a mut V {\n+        self.get_mut(index)\n+    }\n+}*/\n+\n /// HashMap iterator\n pub type Entries<'a, K, V> = table::Entries<'a, K, V>;\n \n@@ -2694,6 +2713,29 @@ mod test_map {\n \n         assert_eq!(iter.size_hint(), (3, Some(3)));\n     }\n+\n+    #[test]\n+    fn test_index() {\n+        let mut map: HashMap<int, int> = HashMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        assert_eq!(map[2], 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_nonexistent() {\n+        let mut map: HashMap<int, int> = HashMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        map[4];\n+    }\n }\n \n #[cfg(test)]"}]}