{"sha": "1863c0c7327724479b165c0ce91dcd54663334fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjNjMGM3MzI3NzI0NDc5YjE2NWMwY2U5MWRjZDU0NjYzMzM0ZmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-17T14:41:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-17T14:41:27Z"}, "message": "Merge #6578\n\n6578: Simpify project_model r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "bafef9dba1060083eccabdad899ddcd08e28e089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bafef9dba1060083eccabdad899ddcd08e28e089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1863c0c7327724479b165c0ce91dcd54663334fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfs+EXCRBK7hj4Ov3rIwAAdHIIAIHngFAecI54QkE3ywr6iVSv\nEXagQaGQLa2C3vrjm0OguoPpDoKhFkDSHyjoOKoHC8aIAROH6lPVWyWwngFiw8I4\nQ8ZfMnS0fXDxzzCcA4CtGVu5xSlTfQpNnrQr6IaaVh+g34yDHgoBFKAanT7iPBy9\nH1wLiNHvh7yRytZC+IZkzhiL3cnfY+UwXs2qjNbnngT8n1WuDCXfs1NSqGoeGU2B\nABCebZCDPN5MW4MlUVucOjpzhLvQPP9QdOOZIBUHPj8PWnyHCSkESCRZNfAkQo3M\nsBCL8OswyWWbKFVyt5UObKy8tBVzRqk8b0/ytZN6T4o4uMFMZF+1dF0a5HjPfVk=\n=N79U\n-----END PGP SIGNATURE-----\n", "payload": "tree bafef9dba1060083eccabdad899ddcd08e28e089\nparent 66bcdcbb3615b0d1d47ca7c4abf2c3dd5ab0b73d\nparent e88b5fe916802a1c3e3bc9685971439e7ad07fa8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1605624087 +0000\ncommitter GitHub <noreply@github.com> 1605624087 +0000\n\nMerge #6578\n\n6578: Simpify project_model r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1863c0c7327724479b165c0ce91dcd54663334fd", "html_url": "https://github.com/rust-lang/rust/commit/1863c0c7327724479b165c0ce91dcd54663334fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1863c0c7327724479b165c0ce91dcd54663334fd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66bcdcbb3615b0d1d47ca7c4abf2c3dd5ab0b73d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66bcdcbb3615b0d1d47ca7c4abf2c3dd5ab0b73d", "html_url": "https://github.com/rust-lang/rust/commit/66bcdcbb3615b0d1d47ca7c4abf2c3dd5ab0b73d"}, {"sha": "e88b5fe916802a1c3e3bc9685971439e7ad07fa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88b5fe916802a1c3e3bc9685971439e7ad07fa8", "html_url": "https://github.com/rust-lang/rust/commit/e88b5fe916802a1c3e3bc9685971439e7ad07fa8"}], "stats": {"total": 483, "additions": 246, "deletions": 237}, "files": [{"sha": "d88ecf8b091796ee91bb31ef65127f89ffe8e3a8", "filename": "crates/cfg/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=1863c0c7327724479b165c0ce91dcd54663334fd", "patch": "@@ -41,12 +41,6 @@ impl CfgOptions {\n         self.enabled.insert(CfgAtom::KeyValue { key, value });\n     }\n \n-    pub fn append(&mut self, other: &CfgOptions) {\n-        for atom in &other.enabled {\n-            self.enabled.insert(atom.clone());\n-        }\n-    }\n-\n     pub fn apply_diff(&mut self, diff: CfgDiff) {\n         for atom in diff.enable {\n             self.enabled.insert(atom);"}, {"sha": "a71f96164d6287aac7a3bc567c3f64e14bb3f38d", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 241, "deletions": 230, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=1863c0c7327724479b165c0ce91dcd54663334fd", "patch": "@@ -197,269 +197,280 @@ impl ProjectWorkspace {\n         proc_macro_client: &ProcMacroClient,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n-        let mut crate_graph = CrateGraph::default();\n-        match self {\n+        let mut crate_graph = match self {\n             ProjectWorkspace::Json { project, sysroot } => {\n-                let sysroot_dps = sysroot\n-                    .as_ref()\n-                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n-\n-                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n-                let crates: FxHashMap<_, _> = project\n-                    .crates()\n-                    .filter_map(|(crate_id, krate)| {\n-                        let file_path = &krate.root_module;\n-                        let file_id = match load(&file_path) {\n-                            Some(id) => id,\n-                            None => {\n-                                log::error!(\"failed to load crate root {}\", file_path.display());\n-                                return None;\n-                            }\n-                        };\n-\n-                        let env = krate.env.clone().into_iter().collect();\n-                        let proc_macro = krate\n-                            .proc_macro_dylib_path\n-                            .clone()\n-                            .map(|it| proc_macro_client.by_dylib_path(&it));\n-\n-                        let target = krate.target.as_deref().or(target);\n-                        let target_cfgs = cfg_cache\n-                            .entry(target)\n-                            .or_insert_with(|| get_rustc_cfg_options(target));\n-\n-                        let mut cfg_options = CfgOptions::default();\n-                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n-\n-                        Some((\n-                            crate_id,\n-                            crate_graph.add_crate_root(\n-                                file_id,\n-                                krate.edition,\n-                                krate.display_name.clone(),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.unwrap_or_default(),\n-                            ),\n-                        ))\n-                    })\n-                    .collect();\n-\n-                for (from, krate) in project.crates() {\n-                    if let Some(&from) = crates.get(&from) {\n-                        if let Some((public_deps, _proc_macro)) = &sysroot_dps {\n-                            for (name, to) in public_deps.iter() {\n-                                add_dep(&mut crate_graph, from, name.clone(), *to)\n-                            }\n-                        }\n-\n-                        for dep in &krate.deps {\n-                            let to_crate_id = dep.crate_id;\n-                            if let Some(&to) = crates.get(&to_crate_id) {\n-                                add_dep(&mut crate_graph, from, dep.name.clone(), to)\n-                            }\n-                        }\n-                    }\n-                }\n+                project_json_to_crate_graph(target, proc_macro_client, load, project, sysroot)\n             }\n             ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let (public_deps, libproc_macro) =\n-                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n+                cargo_to_crate_graph(target, proc_macro_client, load, cargo, sysroot, rustc)\n+            }\n+        };\n+        if crate_graph.patch_cfg_if() {\n+            log::debug!(\"Patched std to depend on cfg-if\")\n+        } else {\n+            log::debug!(\"Did not patch std to depend on cfg-if\")\n+        }\n+        crate_graph\n+    }\n+}\n \n-                let mut cfg_options = CfgOptions::default();\n-                cfg_options.extend(get_rustc_cfg_options(target));\n+fn project_json_to_crate_graph(\n+    target: Option<&str>,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    project: &ProjectJson,\n+    sysroot: &Option<Sysroot>,\n+) -> CrateGraph {\n+    let mut crate_graph = CrateGraph::default();\n+    let sysroot_deps = sysroot\n+        .as_ref()\n+        .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n+\n+    let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n+    let crates: FxHashMap<CrateId, CrateId> = project\n+        .crates()\n+        .filter_map(|(crate_id, krate)| {\n+            let file_path = &krate.root_module;\n+            let file_id = load(&file_path)?;\n+            Some((crate_id, krate, file_id))\n+        })\n+        .map(|(crate_id, krate, file_id)| {\n+            let env = krate.env.clone().into_iter().collect();\n+            let proc_macro =\n+                krate.proc_macro_dylib_path.clone().map(|it| proc_macro_client.by_dylib_path(&it));\n+\n+            let target = krate.target.as_deref().or(target);\n+            let target_cfgs =\n+                cfg_cache.entry(target).or_insert_with(|| get_rustc_cfg_options(target));\n+\n+            let mut cfg_options = CfgOptions::default();\n+            cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n+            (\n+                crate_id,\n+                crate_graph.add_crate_root(\n+                    file_id,\n+                    krate.edition,\n+                    krate.display_name.clone(),\n+                    cfg_options,\n+                    env,\n+                    proc_macro.unwrap_or_default(),\n+                ),\n+            )\n+        })\n+        .collect();\n \n-                let mut pkg_to_lib_crate = FxHashMap::default();\n+    for (from, krate) in project.crates() {\n+        if let Some(&from) = crates.get(&from) {\n+            if let Some((public_deps, _proc_macro)) = &sysroot_deps {\n+                for (name, to) in public_deps.iter() {\n+                    add_dep(&mut crate_graph, from, name.clone(), *to)\n+                }\n+            }\n+\n+            for dep in &krate.deps {\n+                if let Some(&to) = crates.get(&dep.crate_id) {\n+                    add_dep(&mut crate_graph, from, dep.name.clone(), to)\n+                }\n+            }\n+        }\n+    }\n+    crate_graph\n+}\n \n-                // Add test cfg for non-sysroot crates\n-                cfg_options.insert_atom(\"test\".into());\n-                cfg_options.insert_atom(\"debug_assertions\".into());\n+fn cargo_to_crate_graph(\n+    target: Option<&str>,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    cargo: &CargoWorkspace,\n+    sysroot: &Sysroot,\n+    rustc: &Option<CargoWorkspace>,\n+) -> CrateGraph {\n+    let mut crate_graph = CrateGraph::default();\n+    let (public_deps, libproc_macro) =\n+        sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n \n-                let mut pkg_crates = FxHashMap::default();\n+    let mut cfg_options = CfgOptions::default();\n+    cfg_options.extend(get_rustc_cfg_options(target));\n \n-                // Next, create crates for each package, target pair\n-                for pkg in cargo.packages() {\n-                    let mut lib_tgt = None;\n-                    for &tgt in cargo[pkg].targets.iter() {\n-                        if let Some(crate_id) = add_target_crate_root(\n+    let mut pkg_to_lib_crate = FxHashMap::default();\n+\n+    // Add test cfg for non-sysroot crates\n+    cfg_options.insert_atom(\"test\".into());\n+    cfg_options.insert_atom(\"debug_assertions\".into());\n+\n+    let mut pkg_crates = FxHashMap::default();\n+\n+    // Next, create crates for each package, target pair\n+    for pkg in cargo.packages() {\n+        let mut lib_tgt = None;\n+        for &tgt in cargo[pkg].targets.iter() {\n+            if let Some(file_id) = load(&cargo[tgt].root) {\n+                let crate_id = add_target_crate_root(\n+                    &mut crate_graph,\n+                    &cargo[pkg],\n+                    &cfg_options,\n+                    proc_macro_client,\n+                    file_id,\n+                );\n+                if cargo[tgt].kind == TargetKind::Lib {\n+                    lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n+                    pkg_to_lib_crate.insert(pkg, crate_id);\n+                }\n+                if cargo[tgt].is_proc_macro {\n+                    if let Some(proc_macro) = libproc_macro {\n+                        add_dep(\n                             &mut crate_graph,\n-                            &cargo[pkg],\n-                            &cargo[tgt],\n-                            &cfg_options,\n-                            proc_macro_client,\n-                            load,\n-                        ) {\n-                            if cargo[tgt].kind == TargetKind::Lib {\n-                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                            }\n-                            if cargo[tgt].is_proc_macro {\n-                                if let Some(proc_macro) = libproc_macro {\n-                                    add_dep(\n-                                        &mut crate_graph,\n-                                        crate_id,\n-                                        CrateName::new(\"proc_macro\").unwrap(),\n-                                        proc_macro,\n-                                    );\n-                                }\n-                            }\n-\n-                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                        }\n+                            crate_id,\n+                            CrateName::new(\"proc_macro\").unwrap(),\n+                            proc_macro,\n+                        );\n                     }\n+                }\n \n-                    // Set deps to the core, std and to the lib target of the current package\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        if let Some((to, name)) = lib_tgt.clone() {\n-                            // For root projects with dashes in their name,\n-                            // cargo metadata does not do any normalization,\n-                            // so we do it ourselves currently\n-                            let name = CrateName::normalize_dashes(&name);\n-                            if to != from {\n-                                add_dep(&mut crate_graph, from, name, to);\n-                            }\n-                        }\n-                        for (name, krate) in public_deps.iter() {\n-                            add_dep(&mut crate_graph, from, name.clone(), *krate);\n-                        }\n-                    }\n+                pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+            }\n+        }\n+\n+        // Set deps to the core, std and to the lib target of the current package\n+        for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+            if let Some((to, name)) = lib_tgt.clone() {\n+                if to != from {\n+                    // For root projects with dashes in their name,\n+                    // cargo metadata does not do any normalization,\n+                    // so we do it ourselves currently\n+                    let name = CrateName::normalize_dashes(&name);\n+                    add_dep(&mut crate_graph, from, name, to);\n                 }\n+            }\n+            for (name, krate) in public_deps.iter() {\n+                add_dep(&mut crate_graph, from, name.clone(), *krate);\n+            }\n+        }\n+    }\n \n-                // Now add a dep edge from all targets of upstream to the lib\n-                // target of downstream.\n-                for pkg in cargo.packages() {\n-                    for dep in cargo[pkg].dependencies.iter() {\n-                        let name = CrateName::new(&dep.name).unwrap();\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                add_dep(&mut crate_graph, from, name.clone(), to)\n-                            }\n-                        }\n-                    }\n+    // Now add a dep edge from all targets of upstream to the lib\n+    // target of downstream.\n+    for pkg in cargo.packages() {\n+        for dep in cargo[pkg].dependencies.iter() {\n+            let name = CrateName::new(&dep.name).unwrap();\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                    add_dep(&mut crate_graph, from, name.clone(), to)\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut rustc_pkg_crates = FxHashMap::default();\n+\n+    // If the user provided a path to rustc sources, we add all the rustc_private crates\n+    // and create dependencies on them for the crates in the current workspace\n+    if let Some(rustc_workspace) = rustc {\n+        for pkg in rustc_workspace.packages() {\n+            for &tgt in rustc_workspace[pkg].targets.iter() {\n+                if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                    continue;\n+                }\n+                // Exclude alloc / core / std\n+                if rustc_workspace[tgt]\n+                    .root\n+                    .components()\n+                    .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                {\n+                    continue;\n                 }\n \n-                let mut rustc_pkg_crates = FxHashMap::default();\n-\n-                // If the user provided a path to rustc sources, we add all the rustc_private crates\n-                // and create dependencies on them for the crates in the current workspace\n-                if let Some(rustc_workspace) = rustc {\n-                    for pkg in rustc_workspace.packages() {\n-                        for &tgt in rustc_workspace[pkg].targets.iter() {\n-                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                                continue;\n-                            }\n-                            // Exclude alloc / core / std\n-                            if rustc_workspace[tgt]\n-                                .root\n-                                .components()\n-                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                            {\n-                                continue;\n-                            }\n-\n-                            if let Some(crate_id) = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                &rustc_workspace[tgt],\n-                                &cfg_options,\n-                                proc_macro_client,\n-                                load,\n-                            ) {\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                                // Add dependencies on the core / std / alloc for rustc\n-                                for (name, krate) in public_deps.iter() {\n-                                    add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n-                                }\n-                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                            }\n-                        }\n+                if let Some(file_id) = load(&rustc_workspace[tgt].root) {\n+                    let crate_id = add_target_crate_root(\n+                        &mut crate_graph,\n+                        &rustc_workspace[pkg],\n+                        &cfg_options,\n+                        proc_macro_client,\n+                        file_id,\n+                    );\n+                    pkg_to_lib_crate.insert(pkg, crate_id);\n+                    // Add dependencies on the core / std / alloc for rustc\n+                    for (name, krate) in public_deps.iter() {\n+                        add_dep(&mut crate_graph, crate_id, name.clone(), *krate);\n                     }\n-                    // Now add a dep edge from all targets of upstream to the lib\n-                    // target of downstream.\n-                    for pkg in rustc_workspace.packages() {\n-                        for dep in rustc_workspace[pkg].dependencies.iter() {\n-                            let name = CrateName::new(&dep.name).unwrap();\n-                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    add_dep(&mut crate_graph, from, name.clone(), to);\n-                                }\n-                            }\n-                        }\n+                    rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                }\n+            }\n+        }\n+        // Now add a dep edge from all targets of upstream to the lib\n+        // target of downstream.\n+        for pkg in rustc_workspace.packages() {\n+            for dep in rustc_workspace[pkg].dependencies.iter() {\n+                let name = CrateName::new(&dep.name).unwrap();\n+                if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                    for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                        add_dep(&mut crate_graph, from, name.clone(), to);\n                     }\n+                }\n+            }\n+        }\n \n-                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n-                    for dep in rustc_workspace.packages() {\n-                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                            for pkg in cargo.packages() {\n-                                if !cargo[pkg].is_member {\n-                                    continue;\n-                                }\n-                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    add_dep(&mut crate_graph, from, name.clone(), to);\n-                                }\n-                            }\n-                        }\n+        // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+        for dep in rustc_workspace.packages() {\n+            let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+            if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                for pkg in cargo.packages() {\n+                    if !cargo[pkg].is_member {\n+                        continue;\n+                    }\n+                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                        add_dep(&mut crate_graph, from, name.clone(), to);\n                     }\n                 }\n             }\n         }\n-        if crate_graph.patch_cfg_if() {\n-            log::debug!(\"Patched std to depend on cfg-if\")\n-        } else {\n-            log::debug!(\"Did not patch std to depend on cfg-if\")\n-        }\n-        crate_graph\n     }\n+    crate_graph\n }\n \n fn add_target_crate_root(\n     crate_graph: &mut CrateGraph,\n     pkg: &cargo_workspace::PackageData,\n-    tgt: &cargo_workspace::TargetData,\n     cfg_options: &CfgOptions,\n     proc_macro_client: &ProcMacroClient,\n-    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-) -> Option<CrateId> {\n-    let root = tgt.root.as_path();\n-    if let Some(file_id) = load(root) {\n-        let edition = pkg.edition;\n-        let cfg_options = {\n-            let mut opts = cfg_options.clone();\n-            for feature in pkg.features.iter() {\n-                opts.insert_key_value(\"feature\".into(), feature.into());\n-            }\n-            opts.extend(pkg.cfgs.iter().cloned());\n-            opts\n-        };\n-        let mut env = Env::default();\n-        if let Some(out_dir) = &pkg.out_dir {\n-            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                env.set(\"OUT_DIR\", out_dir);\n-            }\n+    file_id: FileId,\n+) -> CrateId {\n+    let edition = pkg.edition;\n+    let cfg_options = {\n+        let mut opts = cfg_options.clone();\n+        for feature in pkg.features.iter() {\n+            opts.insert_key_value(\"feature\".into(), feature.into());\n+        }\n+        opts.extend(pkg.cfgs.iter().cloned());\n+        opts\n+    };\n+    let mut env = Env::default();\n+    if let Some(out_dir) = &pkg.out_dir {\n+        // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+        if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+            env.set(\"OUT_DIR\", out_dir);\n         }\n-        let proc_macro = pkg\n-            .proc_macro_dylib_path\n-            .as_ref()\n-            .map(|it| proc_macro_client.by_dylib_path(&it))\n-            .unwrap_or_default();\n-\n-        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n-        let crate_id = crate_graph.add_crate_root(\n-            file_id,\n-            edition,\n-            Some(display_name),\n-            cfg_options,\n-            env,\n-            proc_macro.clone(),\n-        );\n-\n-        return Some(crate_id);\n     }\n-    None\n+    let proc_macro = pkg\n+        .proc_macro_dylib_path\n+        .as_ref()\n+        .map(|it| proc_macro_client.by_dylib_path(&it))\n+        .unwrap_or_default();\n+\n+    let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n+    let crate_id = crate_graph.add_crate_root(\n+        file_id,\n+        edition,\n+        Some(display_name),\n+        cfg_options,\n+        env,\n+        proc_macro.clone(),\n+    );\n+\n+    crate_id\n }\n+\n fn sysroot_to_crate_graph(\n     crate_graph: &mut CrateGraph,\n     sysroot: &Sysroot,"}, {"sha": "001bf59498fb453535bba7cdc130f91f28dc5b99", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1863c0c7327724479b165c0ce91dcd54663334fd/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=1863c0c7327724479b165c0ce91dcd54663334fd", "patch": "@@ -203,7 +203,11 @@ impl GlobalState {\n                     let contents = loader.handle.load_sync(path);\n                     vfs.set_file_contents(vfs_path.clone(), contents);\n                 }\n-                vfs.file_id(&vfs_path)\n+                let res = vfs.file_id(&vfs_path);\n+                if res.is_none() {\n+                    log::error!(\"failed to load {}\", path.display())\n+                }\n+                res\n             };\n             for ws in workspaces.iter() {\n                 crate_graph.extend(ws.to_crate_graph("}]}