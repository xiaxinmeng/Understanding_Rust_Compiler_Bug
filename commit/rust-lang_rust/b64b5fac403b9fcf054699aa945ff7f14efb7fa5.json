{"sha": "b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NGI1ZmFjNDAzYjlmY2YwNTQ2OTlhYTk0NWZmN2YxNGVmYjdmYTU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-16T00:10:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-16T00:10:24Z"}, "message": "Rollup merge of #77935 - ssomers:btree_cleanup_1, r=Mark-Simulacrum\n\nBTreeMap: make PartialCmp/PartialEq explicit and tested\n\nFollow-up on a topic raised in #77612\n\nr? @Mark-Simulacrum", "tree": {"sha": "3330a1b194494bf346e071d2d521e98dd5ecb751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3330a1b194494bf346e071d2d521e98dd5ecb751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfiOTwCRBK7hj4Ov3rIwAAdHIIAEQFexVIqn5NOSESnThTFF/W\n3MH1igD5TleCZ6eMTAncT6uZovXJ60z4DNT3Ts3YnP7LocEJp+DUWvfAgICTEmcV\nRIXpoA9IUHVUk1RuMOZdz4KsqLKUjiNJtYxNNpyXYK2Aq6coF0CMUIRxVkHv0lom\nubdkn2NmMYb84cXbe8ICcsUY/+tjG+uSdeaB0YL5N2zjT8NpTFb0z7vN6bqNh54+\nURX0wC40n31Q1mydebcaX14ee/4xM/mWMJpius54pl5U3SABvwRDQWGSjDRNSnWz\nAy3NBLfUcz4sSbxynYi5u3W8A96rVeHZtXPJ8MsUZGirraq1uawRPwaYC+emKx0=\n=PpjO\n-----END PGP SIGNATURE-----\n", "payload": "tree 3330a1b194494bf346e071d2d521e98dd5ecb751\nparent 9d8bf44409b5892525264f0b67179fa42e57c2f0\nparent a22cd05965fd79c756ba6890ba720dd280d314ae\nauthor Dylan DPC <dylan.dpc@gmail.com> 1602807024 +0200\ncommitter GitHub <noreply@github.com> 1602807024 +0200\n\nRollup merge of #77935 - ssomers:btree_cleanup_1, r=Mark-Simulacrum\n\nBTreeMap: make PartialCmp/PartialEq explicit and tested\n\nFollow-up on a topic raised in #77612\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "html_url": "https://github.com/rust-lang/rust/commit/b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b64b5fac403b9fcf054699aa945ff7f14efb7fa5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d8bf44409b5892525264f0b67179fa42e57c2f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d8bf44409b5892525264f0b67179fa42e57c2f0", "html_url": "https://github.com/rust-lang/rust/commit/9d8bf44409b5892525264f0b67179fa42e57c2f0"}, {"sha": "a22cd05965fd79c756ba6890ba720dd280d314ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/a22cd05965fd79c756ba6890ba720dd280d314ae", "html_url": "https://github.com/rust-lang/rust/commit/a22cd05965fd79c756ba6890ba720dd280d314ae"}], "stats": {"total": 69, "additions": 62, "deletions": 7}, "files": [{"sha": "903faf3fa969adbd5ff3def6f9459e0ff84fb6db", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b64b5fac403b9fcf054699aa945ff7f14efb7fa5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64b5fac403b9fcf054699aa945ff7f14efb7fa5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "patch": "@@ -257,8 +257,13 @@ impl<K, V> Root<K, V> {\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n pub struct NodeRef<BorrowType, K, V, Type> {\n-    /// The number of levels below the node.\n+    /// The number of levels below the node, a property of the node that cannot be\n+    /// entirely described by `Type` and that the node does not store itself either.\n+    /// Unconstrained if `Type` is `LeafOrInternal`, must be zero if `Type` is `Leaf`,\n+    /// and must be non-zero if `Type` is `Internal`.\n     height: usize,\n+    /// The pointer to the leaf or internal node. The definition of `InternalNode`\n+    /// ensures that the pointer is valid either way.\n     node: NonNull<LeafNode<K, V>>,\n     _marker: PhantomData<(BorrowType, Type)>,\n }\n@@ -315,8 +320,8 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         unsafe { usize::from((*self.as_leaf_ptr()).len) }\n     }\n \n-    /// Returns the height of this node in the whole tree. Zero height denotes the\n-    /// leaf level.\n+    /// Returns the height of this node with respect to the leaf level. Zero height means the\n+    /// node is a leaf itself.\n     pub fn height(&self) -> usize {\n         self.height\n     }\n@@ -584,9 +589,11 @@ impl<'a, K, V, Type> NodeRef<marker::ValMut<'a>, K, V, Type> {\n         // to avoid aliasing with outstanding references to other elements,\n         // in particular, those returned to the caller in earlier iterations.\n         let leaf = self.node.as_ptr();\n+        let keys = unsafe { &raw const (*leaf).keys };\n+        let vals = unsafe { &raw mut (*leaf).vals };\n         // We must coerce to unsized array pointers because of Rust issue #74679.\n-        let keys: *const [_] = unsafe { &raw const (*leaf).keys };\n-        let vals: *mut [_] = unsafe { &raw mut (*leaf).vals };\n+        let keys: *const [_] = keys;\n+        let vals: *mut [_] = vals;\n         // SAFETY: The keys and values of a node must always be initialized up to length.\n         let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };\n         let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };\n@@ -817,19 +824,34 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n+impl<BorrowType, K, V, NodeType> NodeRef<BorrowType, K, V, NodeType> {\n+    /// Could be a public implementation of PartialEq, but only used in this module.\n+    fn eq(&self, other: &Self) -> bool {\n+        let Self { node, height, _marker: _ } = self;\n+        if *node == other.node {\n+            debug_assert_eq!(*height, other.height);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn eq(&self, other: &Self) -> bool {\n-        self.node.node == other.node.node && self.idx == other.idx\n+        let Self { node, idx, _marker: _ } = self;\n+        node.eq(&other.node) && *idx == other.idx\n     }\n }\n \n impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n     for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+        let Self { node, idx, _marker: _ } = self;\n+        if node.eq(&other.node) { Some(idx.cmp(&other.idx)) } else { None }\n     }\n }\n "}, {"sha": "2ef9aad0ccdcfbf0bf1563abf51feb6111a643ec", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b64b5fac403b9fcf054699aa945ff7f14efb7fa5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b64b5fac403b9fcf054699aa945ff7f14efb7fa5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=b64b5fac403b9fcf054699aa945ff7f14efb7fa5", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use core::cmp::Ordering::*;\n \n #[test]\n fn test_splitpoint() {\n@@ -24,6 +25,38 @@ fn test_splitpoint() {\n     }\n }\n \n+#[test]\n+fn test_partial_cmp_eq() {\n+    let mut root1: Root<i32, ()> = Root::new_leaf();\n+    let mut leaf1 = unsafe { root1.leaf_node_as_mut() };\n+    leaf1.push(1, ());\n+    root1.push_internal_level();\n+    let root2: Root<i32, ()> = Root::new_leaf();\n+\n+    let leaf_edge_1a = root1.node_as_ref().first_leaf_edge().forget_node_type();\n+    let leaf_edge_1b = root1.node_as_ref().last_leaf_edge().forget_node_type();\n+    let top_edge_1 = root1.node_as_ref().first_edge();\n+    let top_edge_2 = root2.node_as_ref().first_edge();\n+\n+    assert!(leaf_edge_1a == leaf_edge_1a);\n+    assert!(leaf_edge_1a != leaf_edge_1b);\n+    assert!(leaf_edge_1a != top_edge_1);\n+    assert!(leaf_edge_1a != top_edge_2);\n+    assert!(top_edge_1 == top_edge_1);\n+    assert!(top_edge_1 != top_edge_2);\n+\n+    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1a), Some(Equal));\n+    assert_eq!(leaf_edge_1a.partial_cmp(&leaf_edge_1b), Some(Less));\n+    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_1), None);\n+    assert_eq!(leaf_edge_1a.partial_cmp(&top_edge_2), None);\n+    assert_eq!(top_edge_1.partial_cmp(&top_edge_1), Some(Equal));\n+    assert_eq!(top_edge_1.partial_cmp(&top_edge_2), None);\n+\n+    root1.pop_internal_level();\n+    unsafe { root1.into_ref().deallocate_and_ascend() };\n+    unsafe { root2.into_ref().deallocate_and_ascend() };\n+}\n+\n #[test]\n #[cfg(target_arch = \"x86_64\")]\n fn test_sizes() {"}]}