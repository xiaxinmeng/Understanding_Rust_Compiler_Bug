{"sha": "5b20da81805c70c1991f58452b8fa1b7dc5b3256", "node_id": "C_kwDOAAsO6NoAKDViMjBkYTgxODA1YzcwYzE5OTFmNTg0NTJiOGZhMWI3ZGM1YjMyNTY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-04T20:47:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-05-04T20:52:02Z"}, "message": "interpret: debug-check ScalarPair layout information", "tree": {"sha": "b3495656c096df7017e619b1032e3cd726c25b66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3495656c096df7017e619b1032e3cd726c25b66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b20da81805c70c1991f58452b8fa1b7dc5b3256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b20da81805c70c1991f58452b8fa1b7dc5b3256", "html_url": "https://github.com/rust-lang/rust/commit/5b20da81805c70c1991f58452b8fa1b7dc5b3256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b20da81805c70c1991f58452b8fa1b7dc5b3256/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f75d884046e07bb26edeaba9b8c982dc97485fd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f75d884046e07bb26edeaba9b8c982dc97485fd5", "html_url": "https://github.com/rust-lang/rust/commit/f75d884046e07bb26edeaba9b8c982dc97485fd5"}], "stats": {"total": 135, "additions": 89, "deletions": 46}, "files": [{"sha": "494ce3787e327bd277735cc8be60b76d3274e743", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=5b20da81805c70c1991f58452b8fa1b7dc5b3256", "patch": "@@ -84,14 +84,18 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Tag>, ScalarMaybeUninit<Tag>) {\n         match self {\n-            Immediate::ScalarPair(val1, val2) => Ok((val1.check_init()?, val2.check_init()?)),\n-            Immediate::Scalar(..) => {\n-                bug!(\"Got a scalar where a scalar pair was expected\")\n-            }\n+            Immediate::ScalarPair(val1, val2) => (val1, val2),\n+            Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n         }\n     }\n+\n+    #[inline]\n+    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n+        let (val1, val2) = self.to_scalar_or_uninit_pair();\n+        Ok((val1.check_init()?, val2.check_init()?))\n+    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -251,6 +255,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn try_read_immediate_from_mplace(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -271,27 +276,40 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // case where some of the bytes are initialized and others are not. So, we need an extra\n         // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n         // like a `Scalar` (or `ScalarPair`).\n-        match mplace.layout.abi {\n-            Abi::Scalar(abi::Scalar::Initialized { .. }) => {\n-                let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n-                Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }))\n-            }\n+        let scalar_layout = match mplace.layout.abi {\n+            // `if` does not work nested inside patterns, making this a bit awkward to express.\n+            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => Some(s),\n+            Abi::Scalar(s) if force => Some(s.primitive()),\n+            _ => None,\n+        };\n+        if let Some(_) = scalar_layout {\n+            let scalar = alloc.read_scalar(alloc_range(Size::ZERO, mplace.layout.size))?;\n+            return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n+        }\n+        let scalar_pair_layout = match mplace.layout.abi {\n             Abi::ScalarPair(\n                 abi::Scalar::Initialized { value: a, .. },\n                 abi::Scalar::Initialized { value: b, .. },\n-            ) => {\n-                // We checked `ptr_align` above, so all fields will have the alignment they need.\n-                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n-                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let b_offset = a_size.align_to(b.align(self).abi);\n-                assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n-                let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n-                let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n-                Ok(Some(ImmTy { imm: Immediate::ScalarPair(a_val, b_val), layout: mplace.layout }))\n-            }\n-            _ => Ok(None),\n+            ) => Some((a, b)),\n+            Abi::ScalarPair(a, b) if force => Some((a.primitive(), b.primitive())),\n+            _ => None,\n+        };\n+        if let Some((a, b)) = scalar_pair_layout {\n+            // We checked `ptr_align` above, so all fields will have the alignment they need.\n+            // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+            // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n+            let (a_size, b_size) = (a.size(self), b.size(self));\n+            let b_offset = a_size.align_to(b.align(self).abi);\n+            assert!(b_offset.bytes() > 0); // we later use the offset to tell apart the fields\n+            let a_val = alloc.read_scalar(alloc_range(Size::ZERO, a_size))?;\n+            let b_val = alloc.read_scalar(alloc_range(b_offset, b_size))?;\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::ScalarPair(a_val, b_val),\n+                layout: mplace.layout,\n+            }));\n         }\n+        // Neither a scalar nor scalar pair.\n+        return Ok(None);\n     }\n \n     /// Try returning an immediate for the operand.\n@@ -300,13 +318,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n+    ///\n+    /// If `force` is `true`, then even scalars with fields that can be ununit will be\n+    /// read. This means the load is lossy and should not be written back!\n+    /// This flag exists only for validity checking.\n     pub fn try_read_immediate(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n+        force: bool,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n-                if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n+                if let Some(val) = self.try_read_immediate_from_mplace(mplace, force)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -322,7 +345,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n-        if let Ok(imm) = self.try_read_immediate(op)? {\n+        if let Ok(imm) = self.try_read_immediate(op, /*force*/ false)? {\n             Ok(imm)\n         } else {\n             span_bug!(self.cur_span(), \"primitive read failed for type: {:?}\", op.layout.ty);"}, {"sha": "4cc4080c27aa02af7821ea1fb76e1540fd0d2a70", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=5b20da81805c70c1991f58452b8fa1b7dc5b3256", "patch": "@@ -879,7 +879,7 @@ where\n         }\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let src = match self.try_read_immediate(src)? {\n+        let src = match self.try_read_immediate(src, /*force*/ false)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly."}, {"sha": "c2782db322196d8e26b98828bb5a5c2a196388b4", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=5b20da81805c70c1991f58452b8fa1b7dc5b3256", "patch": "@@ -20,8 +20,8 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n use std::hash::Hash;\n \n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    alloc_range, CheckInAllocMsg, GlobalAlloc, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -487,6 +487,17 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         ))\n     }\n \n+    fn read_immediate_forced(\n+        &self,\n+        op: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n+        Ok(*try_validation!(\n+            self.ecx.try_read_immediate(op, /*force*/ true),\n+            self.path,\n+            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n+        ).unwrap())\n+    }\n+\n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n@@ -626,18 +637,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        op: &OpTy<'tcx, M::PointerTag>,\n+        scalar: ScalarMaybeUninit<M::PointerTag>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         // We check `is_full_range` in a slightly complicated way because *if* we are checking\n         // number validity, then we want to ensure that `Scalar::Initialized` is indeed initialized,\n         // i.e. that we go over the `check_init` below.\n+        let size = scalar_layout.size(self.ecx);\n         let is_full_range = match scalar_layout {\n             ScalarAbi::Initialized { valid_range, .. } => {\n                 if M::enforce_number_validity(self.ecx) {\n                     false // not \"full\" since uninit is not accepted\n                 } else {\n-                    valid_range.is_full_for(op.layout.size)\n+                    valid_range.is_full_for(size)\n                 }\n             }\n             ScalarAbi::Union { .. } => true,\n@@ -646,21 +658,19 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // Nothing to check\n             return Ok(());\n         }\n-        // We have something to check.\n+        // We have something to check: it must at least be initialized.\n         let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n-        let max_value = op.layout.size.unsigned_int_max();\n+        let max_value = size.unsigned_int_max();\n         assert!(end <= max_value);\n-        // Determine the allowed range\n-        let value = self.read_scalar(op)?;\n         let value = try_validation!(\n-            value.check_init(),\n+            scalar.check_init(),\n             self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", value }\n+            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", scalar }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n         );\n         let bits = match value.try_to_int() {\n-            Ok(int) => int.assert_bits(op.layout.size),\n+            Ok(int) => int.assert_bits(size),\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n@@ -678,7 +688,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     } else {\n                         return Ok(());\n                     }\n-                } else if scalar_layout.valid_range(self.ecx).is_full_for(op.layout.size) {\n+                } else if scalar_layout.valid_range(self.ecx).is_full_for(size) {\n                     // Easy. (This is reachable if `enforce_number_validity` is set.)\n                     return Ok(());\n                 } else {\n@@ -817,13 +827,23 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             Abi::Scalar(scalar_layout) => {\n-                self.visit_scalar(op, scalar_layout)?;\n+                let scalar = self.read_immediate_forced(op)?.to_scalar_or_uninit();\n+                self.visit_scalar(scalar, scalar_layout)?;\n+            }\n+            Abi::ScalarPair(a_layout, b_layout) => {\n+                // We would validate these things as we descend into the fields,\n+                // but that can miss bugs in layout computation. Layout computation\n+                // is subtle due to enums having ScalarPair layout, where one field\n+                // is the discriminant.\n+                if cfg!(debug_assertions) {\n+                    let (a, b) = self.read_immediate_forced(op)?.to_scalar_or_uninit_pair();\n+                    self.visit_scalar(a, a_layout)?;\n+                    self.visit_scalar(b, b_layout)?;\n+                }\n             }\n-            Abi::ScalarPair { .. } | Abi::Vector { .. } => {\n-                // These have fields that we already visited above, so we already checked\n-                // all their scalar-level restrictions.\n-                // There is also no equivalent to `rustc_layout_scalar_valid_range_start`\n-                // that would make skipping them here an issue.\n+            Abi::Vector { .. } => {\n+                // No checks here, we assume layout computation gets this right.\n+                // (This is harder to check since Miri does not represent these as `Immediate`.)\n             }\n             Abi::Aggregate { .. } => {\n                 // Nothing to do."}, {"sha": "3fdfa53289bf897768333c3b5fee93805f993652", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=5b20da81805c70c1991f58452b8fa1b7dc5b3256", "patch": "@@ -415,7 +415,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.try_read_immediate(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -710,7 +710,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what to do when try_read_immediate fails\n-        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value));\n+        let imm = self.use_ecx(|this| this.ecx.try_read_immediate(value, /*force*/ false));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {"}, {"sha": "2bc27873ac10b652c1cdfbf4b4ae04cc8c104c58", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b20da81805c70c1991f58452b8fa1b7dc5b3256/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=5b20da81805c70c1991f58452b8fa1b7dc5b3256", "patch": "@@ -412,7 +412,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.try_read_immediate(&op) {\n+        Some(match self.ecx.try_read_immediate(&op, /*force*/ false) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })"}]}