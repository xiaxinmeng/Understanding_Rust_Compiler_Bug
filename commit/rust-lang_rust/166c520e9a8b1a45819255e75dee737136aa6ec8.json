{"sha": "166c520e9a8b1a45819255e75dee737136aa6ec8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmM1MjBlOWE4YjFhNDU4MTkyNTVlNzVkZWU3MzcxMzZhYTZlYzg=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-07-29T23:41:12Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-08-09T13:10:00Z"}, "message": "should_impl_trait - pr comments", "tree": {"sha": "e097dd0074949a64cf149a3b80b6d5dac4618d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e097dd0074949a64cf149a3b80b6d5dac4618d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166c520e9a8b1a45819255e75dee737136aa6ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166c520e9a8b1a45819255e75dee737136aa6ec8", "html_url": "https://github.com/rust-lang/rust/commit/166c520e9a8b1a45819255e75dee737136aa6ec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166c520e9a8b1a45819255e75dee737136aa6ec8/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cc1a2ed879e45605a53b802cfa5291c9a51284c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cc1a2ed879e45605a53b802cfa5291c9a51284c", "html_url": "https://github.com/rust-lang/rust/commit/7cc1a2ed879e45605a53b802cfa5291c9a51284c"}], "stats": {"total": 1171, "additions": 670, "deletions": 501}, "files": [{"sha": "a549c3b78ef6a4ab5d5cea14baf078a38705f8d3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 101, "deletions": 49, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -1495,25 +1495,31 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             then {\n                 if cx.access_levels.is_exported(impl_item.hir_id) {\n-                // check missing trait implementations\n-                    for &(method_name, n_args, fn_header, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        let no_lifetime_params = || {\n-                            !impl_item.generics.params.iter()\n-                                .any(|p| matches!(\n-                                    p.kind,\n-                                    hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }))\n-                        };\n-                        if name == method_name &&\n-                            sig.decl.inputs.len() == n_args &&\n-                            out_type.matches(cx, &sig.decl.output) &&\n-                            self_kind.matches(cx, self_ty, first_arg_ty) &&\n-                            fn_header_equals(*fn_header, sig.header) &&\n-                            // ignore methods with lifetime params, risk of false positive\n-                            no_lifetime_params()\n+                    // check missing trait implementations\n+                    for method_config in &TRAIT_METHODS {\n+                        if name == method_config.method_name &&\n+                            sig.decl.inputs.len() == method_config.param_count &&\n+                            method_config.output_type.matches(cx, &sig.decl.output) &&\n+                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            fn_header_equals(*method_config.fn_header, sig.header) &&\n+                            method_config.lifetime_param_cond(&impl_item)\n                         {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                            span_lint_and_help(\n+                                cx,\n+                                SHOULD_IMPLEMENT_TRAIT,\n+                                impl_item.span,\n+                                &format!(\n+                                    \"method `{}` can be confused for the standard trait method `{}::{}`\",\n+                                    method_config.method_name,\n+                                    method_config.trait_name,\n+                                    method_config.method_name\n+                                ),\n+                                None,\n+                                &format!(\n+                                    \"consider implementing the trait `{}` or choosing a less ambiguous method name\",\n+                                    method_config.trait_name\n+                                )\n+                            );\n                         }\n                     }\n                 }\n@@ -3412,39 +3418,85 @@ const FN_HEADER: hir::FnHeader = hir::FnHeader {\n     abi: rustc_target::spec::abi::Abi::Rust,\n };\n \n+struct ShouldImplTraitCase {\n+    trait_name: &'static str,\n+    method_name: &'static str,\n+    param_count: usize,\n+    fn_header: &'static hir::FnHeader,\n+    // implicit self kind expected (none, self, &self, ...)\n+    self_kind: SelfKind,\n+    // checks against the output type\n+    output_type: OutType,\n+    // certain methods with explicit lifetimes can't implement the equivalent trait method\n+    lint_explicit_lifetime: bool,\n+}\n+impl ShouldImplTraitCase {\n+    const fn new(\n+        trait_name: &'static str,\n+        method_name: &'static str,\n+        param_count: usize,\n+        fn_header: &'static hir::FnHeader,\n+        self_kind: SelfKind,\n+        output_type: OutType,\n+        lint_explicit_lifetime: bool,\n+    ) -> ShouldImplTraitCase {\n+        ShouldImplTraitCase {\n+            trait_name,\n+            method_name,\n+            param_count,\n+            fn_header,\n+            self_kind,\n+            output_type,\n+            lint_explicit_lifetime,\n+        }\n+    }\n+\n+    fn lifetime_param_cond(&self, impl_item: &hir::ImplItem<'_>) -> bool {\n+        self.lint_explicit_lifetime\n+            || !impl_item.generics.params.iter().any(|p| {\n+                matches!(\n+                    p.kind,\n+                    hir::GenericParamKind::Lifetime {\n+                        kind: hir::LifetimeParamKind::Explicit\n+                    }\n+                )\n+            })\n+    }\n+}\n+\n #[rustfmt::skip]\n-const TRAIT_METHODS: [(&str, usize, &hir::FnHeader, SelfKind, OutType, &str); 30] = [\n-    (\"add\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Add\"),\n-    (\"as_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::convert::AsMut\"),\n-    (\"as_ref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::convert::AsRef\"),\n-    (\"bitand\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitAnd\"),\n-    (\"bitor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitOr\"),\n-    (\"bitxor\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::BitXor\"),\n-    (\"borrow\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::borrow::Borrow\"),\n-    (\"borrow_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::borrow::BorrowMut\"),\n-    (\"clone\", 1, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::clone::Clone\"),\n-    (\"cmp\", 2, &FN_HEADER, SelfKind::Ref, OutType::Any, \"std::cmp::Ord\"),\n+const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n+    ShouldImplTraitCase::new(\"std::ops::Add\", \"add\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsMut\", \"as_mut\",  1,  &FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::convert::AsRef\", \"as_ref\",  1,  &FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitAnd\", \"bitand\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitOr\", \"bitor\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::BitXor\", \"bitxor\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::borrow::Borrow\", \"borrow\",  1,  &FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::borrow::BorrowMut\", \"borrow_mut\",  1,  &FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::clone::Clone\", \"clone\",  1,  &FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::cmp::Ord\", \"cmp\",  2,  &FN_HEADER,  SelfKind::Ref,  OutType::Any, true),\n     // FIXME: default doesn't work\n-    (\"default\", 0, &FN_HEADER, SelfKind::No, OutType::Any, \"std::default::Default\"),\n-    (\"deref\", 1, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Deref\"),\n-    (\"deref_mut\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::DerefMut\"),\n-    (\"div\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Div\"),\n-    (\"drop\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Unit, \"std::ops::Drop\"),\n-    (\"eq\", 2, &FN_HEADER, SelfKind::Ref, OutType::Bool, \"std::cmp::PartialEq\"),\n-    (\"from_iter\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::iter::FromIterator\"),\n-    (\"from_str\", 1, &FN_HEADER, SelfKind::No, OutType::Any, \"std::str::FromStr\"),\n-    (\"hash\", 2, &FN_HEADER, SelfKind::Ref, OutType::Unit, \"std::hash::Hash\"),\n-    (\"index\", 2, &FN_HEADER, SelfKind::Ref, OutType::Ref, \"std::ops::Index\"),\n-    (\"index_mut\", 2, &FN_HEADER, SelfKind::RefMut, OutType::Ref, \"std::ops::IndexMut\"),\n-    (\"into_iter\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::iter::IntoIterator\"),\n-    (\"mul\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Mul\"),\n-    (\"neg\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Neg\"),\n-    (\"next\", 1, &FN_HEADER, SelfKind::RefMut, OutType::Any, \"std::iter::Iterator\"),\n-    (\"not\", 1, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Not\"),\n-    (\"rem\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Rem\"),\n-    (\"shl\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shl\"),\n-    (\"shr\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Shr\"),\n-    (\"sub\", 2, &FN_HEADER, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n+    ShouldImplTraitCase::new(\"std::default::Default\", \"default\",  0,  &FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Deref\", \"deref\",  1,  &FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::DerefMut\", \"deref_mut\",  1,  &FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::Div\", \"div\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Drop\", \"drop\",  1,  &FN_HEADER,  SelfKind::RefMut,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::cmp::PartialEq\", \"eq\",  2,  &FN_HEADER,  SelfKind::Ref,  OutType::Bool, true),\n+    ShouldImplTraitCase::new(\"std::iter::FromIterator\", \"from_iter\",  1,  &FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::str::FromStr\", \"from_str\",  1,  &FN_HEADER,  SelfKind::No,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::hash::Hash\", \"hash\",  2,  &FN_HEADER,  SelfKind::Ref,  OutType::Unit, true),\n+    ShouldImplTraitCase::new(\"std::ops::Index\", \"index\",  2,  &FN_HEADER,  SelfKind::Ref,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::ops::IndexMut\", \"index_mut\",  2,  &FN_HEADER,  SelfKind::RefMut,  OutType::Ref, true),\n+    ShouldImplTraitCase::new(\"std::iter::IntoIterator\", \"into_iter\",  1,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Mul\", \"mul\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Neg\", \"neg\",  1,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::iter::Iterator\", \"next\",  1,  &FN_HEADER,  SelfKind::RefMut,  OutType::Any, false),\n+    ShouldImplTraitCase::new(\"std::ops::Not\", \"not\",  1,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Rem\", \"rem\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shl\", \"shl\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Shr\", \"shr\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n+    ShouldImplTraitCase::new(\"std::ops::Sub\", \"sub\",  2,  &FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n ];\n \n #[rustfmt::skip]"}, {"sha": "80dd2f744b3a1137c06f513a4329afee18f9de9f", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 2, "deletions": 195, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -34,201 +34,6 @@ use std::sync::{self, Arc};\n \n use option_helpers::IteratorFalsePositives;\n \n-pub struct T;\n-\n-impl T {\n-    // *******************************************\n-    // complete trait method list, should lint all\n-    // *******************************************\n-    pub fn add(self, other: T) -> T {\n-        unimplemented!()\n-    }\n-\n-    pub fn as_mut(&mut self) -> &mut T {\n-        unimplemented!()\n-    }\n-\n-    pub fn as_ref(&self) -> &T {\n-        unimplemented!()\n-    }\n-\n-    pub fn bitand(self, rhs: T) -> T {\n-        unimplemented!()\n-    }\n-\n-    pub fn bitor(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn bitxor(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn borrow(&self) -> &str {\n-        unimplemented!()\n-    }\n-\n-    pub fn borrow_mut(&mut self) -> &mut str {\n-        unimplemented!()\n-    }\n-\n-    pub fn clone(&self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn cmp(&self, other: &Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn default() -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn deref(&self) -> &Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn deref_mut(&mut self) -> &mut Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn div(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn drop(&mut self) {\n-        unimplemented!()\n-    }\n-\n-    pub fn eq(&self, other: &Self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    pub fn from_iter<T>(iter: T) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn from_str(s: &str) -> Result<Self, Self> {\n-        unimplemented!()\n-    }\n-\n-    pub fn hash(&self, state: &mut T) {\n-        unimplemented!()\n-    }\n-\n-    pub fn index(&self, index: usize) -> &Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn index_mut(&mut self, index: usize) -> &mut Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn into_iter(self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn mul(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn neg(self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn next(&mut self) -> Option<Self> {\n-        unimplemented!()\n-    }\n-\n-    pub fn not(self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn rem(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn shl(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn shr(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    pub fn sub(self, rhs: Self) -> Self {\n-        unimplemented!()\n-    }\n-    // *****************\n-    // complete list end\n-    // *****************\n-}\n-\n-pub struct T1;\n-impl T1 {\n-    // corner cases: should not lint\n-\n-    // no error, not public interface\n-    pub(crate) fn drop(&mut self) {}\n-\n-    // no error, private function\n-    fn neg(self) -> Self {\n-        self\n-    }\n-\n-    // no error, private function\n-    fn eq(&self, other: Self) -> bool {\n-        true\n-    }\n-\n-    // No error; self is a ref.\n-    fn sub(&self, other: Self) -> &Self {\n-        self\n-    }\n-\n-    // No error; different number of arguments.\n-    fn div(self) -> Self {\n-        self\n-    }\n-\n-    // No error; wrong return type.\n-    fn rem(self, other: Self) {}\n-\n-    // Fine\n-    fn into_u32(self) -> u32 {\n-        0\n-    }\n-\n-    fn into_u16(&self) -> u16 {\n-        0\n-    }\n-\n-    fn to_something(self) -> u32 {\n-        0\n-    }\n-\n-    fn new(self) -> Self {\n-        unimplemented!();\n-    }\n-\n-    pub fn next<'b>(&'b mut self) -> Option<&'b mut T> {\n-        unimplemented!();\n-    }\n-}\n-\n-pub struct T2;\n-impl T2 {\n-    // Shouldn't trigger lint as it is unsafe.\n-    pub unsafe fn add(self, rhs: Self) -> Self {\n-        self\n-    }\n-\n-    // Should not trigger lint since this is an async function.\n-    pub async fn next(&mut self) -> Option<Self> {\n-        None\n-    }\n-}\n-\n struct Lt<'a> {\n     foo: &'a u32,\n }\n@@ -302,6 +107,8 @@ impl BadNew {\n     }\n }\n \n+struct T;\n+\n impl Mul<T> for T {\n     type Output = T;\n     // No error, obviously."}, {"sha": "2a0a43e83a653089158ed99ac5e80d4d729ad8f7", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 13, "deletions": 257, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -1,249 +1,5 @@\n-error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:43:5\n-   |\n-LL | /     pub fn add(self, other: T) -> T {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n-\n-error: defining a method called `as_mut` on this type; consider implementing the `std::convert::AsMut` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:47:5\n-   |\n-LL | /     pub fn as_mut(&mut self) -> &mut T {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `as_ref` on this type; consider implementing the `std::convert::AsRef` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:51:5\n-   |\n-LL | /     pub fn as_ref(&self) -> &T {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `bitand` on this type; consider implementing the `std::ops::BitAnd` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:55:5\n-   |\n-LL | /     pub fn bitand(self, rhs: T) -> T {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `bitor` on this type; consider implementing the `std::ops::BitOr` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:59:5\n-   |\n-LL | /     pub fn bitor(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `bitxor` on this type; consider implementing the `std::ops::BitXor` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:63:5\n-   |\n-LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `borrow` on this type; consider implementing the `std::borrow::Borrow` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:67:5\n-   |\n-LL | /     pub fn borrow(&self) -> &str {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `borrow_mut` on this type; consider implementing the `std::borrow::BorrowMut` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:71:5\n-   |\n-LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `clone` on this type; consider implementing the `std::clone::Clone` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:75:5\n-   |\n-LL | /     pub fn clone(&self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `cmp` on this type; consider implementing the `std::cmp::Ord` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:79:5\n-   |\n-LL | /     pub fn cmp(&self, other: &Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `deref` on this type; consider implementing the `std::ops::Deref` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:87:5\n-   |\n-LL | /     pub fn deref(&self) -> &Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `deref_mut` on this type; consider implementing the `std::ops::DerefMut` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:91:5\n-   |\n-LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `div` on this type; consider implementing the `std::ops::Div` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:95:5\n-   |\n-LL | /     pub fn div(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `drop` on this type; consider implementing the `std::ops::Drop` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:99:5\n-   |\n-LL | /     pub fn drop(&mut self) {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `eq` on this type; consider implementing the `std::cmp::PartialEq` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:103:5\n-   |\n-LL | /     pub fn eq(&self, other: &Self) -> bool {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `from_iter` on this type; consider implementing the `std::iter::FromIterator` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:107:5\n-   |\n-LL | /     pub fn from_iter<T>(iter: T) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `from_str` on this type; consider implementing the `std::str::FromStr` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:111:5\n-   |\n-LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/methods.rs:111:5\n-   |\n-LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::missing-errors-doc` implied by `-D warnings`\n-\n-error: defining a method called `hash` on this type; consider implementing the `std::hash::Hash` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:115:5\n-   |\n-LL | /     pub fn hash(&self, state: &mut T) {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `index` on this type; consider implementing the `std::ops::Index` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:119:5\n-   |\n-LL | /     pub fn index(&self, index: usize) -> &Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `index_mut` on this type; consider implementing the `std::ops::IndexMut` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:123:5\n-   |\n-LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `into_iter` on this type; consider implementing the `std::iter::IntoIterator` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:127:5\n-   |\n-LL | /     pub fn into_iter(self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `mul` on this type; consider implementing the `std::ops::Mul` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:131:5\n-   |\n-LL | /     pub fn mul(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `neg` on this type; consider implementing the `std::ops::Neg` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:135:5\n-   |\n-LL | /     pub fn neg(self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `next` on this type; consider implementing the `std::iter::Iterator` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:139:5\n-   |\n-LL | /     pub fn next(&mut self) -> Option<Self> {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `not` on this type; consider implementing the `std::ops::Not` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:143:5\n-   |\n-LL | /     pub fn not(self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `rem` on this type; consider implementing the `std::ops::Rem` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:147:5\n-   |\n-LL | /     pub fn rem(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `shl` on this type; consider implementing the `std::ops::Shl` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:151:5\n-   |\n-LL | /     pub fn shl(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `shr` on this type; consider implementing the `std::ops::Shr` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:155:5\n-   |\n-LL | /     pub fn shr(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n-error: defining a method called `sub` on this type; consider implementing the `std::ops::Sub` trait or choosing a less ambiguous name\n-  --> $DIR/methods.rs:159:5\n-   |\n-LL | /     pub fn sub(self, rhs: Self) -> Self {\n-LL | |         unimplemented!()\n-LL | |     }\n-   | |_____^\n-\n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:300:5\n+  --> $DIR/methods.rs:105:5\n    |\n LL | /     fn new() -> i32 {\n LL | |         0\n@@ -253,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:319:13\n+  --> $DIR/methods.rs:126:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -262,7 +18,7 @@ LL |     let _ = v.iter().filter(|&x| *x < 0).next();\n    = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-  --> $DIR/methods.rs:322:13\n+  --> $DIR/methods.rs:129:13\n    |\n LL |       let _ = v.iter().filter(|&x| {\n    |  _____________^\n@@ -272,33 +28,33 @@ LL | |                    ).next();\n    | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:339:22\n+  --> $DIR/methods.rs:146:22\n    |\n LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x < 0)`\n    |\n    = note: `-D clippy::search-is-some` implied by `-D warnings`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:340:20\n+  --> $DIR/methods.rs:147:20\n    |\n LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| **y == x)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:341:20\n+  --> $DIR/methods.rs:148:20\n    |\n LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:342:22\n+  --> $DIR/methods.rs:149:22\n    |\n LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|x| *x == 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:345:13\n+  --> $DIR/methods.rs:152:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -308,13 +64,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:351:22\n+  --> $DIR/methods.rs:158:22\n    |\n LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:354:13\n+  --> $DIR/methods.rs:161:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -324,13 +80,13 @@ LL | |                    ).is_some();\n    | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:360:22\n+  --> $DIR/methods.rs:167:22\n    |\n LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-  --> $DIR/methods.rs:363:13\n+  --> $DIR/methods.rs:170:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -339,5 +95,5 @@ LL | |                                }\n LL | |                    ).is_some();\n    | |______________________________^\n \n-error: aborting due to 42 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "6c5ffe6aba8b7b7c1e4923c957617f6df31ffc64", "filename": "tests/ui/should_impl_trait/corner_cases.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -0,0 +1,83 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+pub struct T1;\n+impl T1 {\n+    // corner cases: should not lint\n+\n+    // no error, not public interface\n+    pub(crate) fn drop(&mut self) {}\n+\n+    // no error, private function\n+    fn neg(self) -> Self {\n+        self\n+    }\n+\n+    // no error, private function\n+    fn eq(&self, other: Self) -> bool {\n+        true\n+    }\n+\n+    // No error; self is a ref.\n+    fn sub(&self, other: Self) -> &Self {\n+        self\n+    }\n+\n+    // No error; different number of arguments.\n+    fn div(self) -> Self {\n+        self\n+    }\n+\n+    // No error; wrong return type.\n+    fn rem(self, other: Self) {}\n+\n+    // Fine\n+    fn into_u32(self) -> u32 {\n+        0\n+    }\n+\n+    fn into_u16(&self) -> u16 {\n+        0\n+    }\n+\n+    fn to_something(self) -> u32 {\n+        0\n+    }\n+\n+    fn new(self) -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn next<'b>(&'b mut self) -> Option<&'b mut T1> {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct T2;\n+impl T2 {\n+    // Shouldn't trigger lint as it is unsafe.\n+    pub unsafe fn add(self, rhs: Self) -> Self {\n+        self\n+    }\n+\n+    // Should not trigger lint since this is an async function.\n+    pub async fn next(&mut self) -> Option<Self> {\n+        None\n+    }\n+}"}, {"sha": "f8d248fc98d82a2db4ac7ae5d106bfe10d7fe782", "filename": "tests/ui/should_impl_trait/method_list_1.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -0,0 +1,87 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 1, should lint all\n+    // *****************************************\n+    pub fn add(self, other: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_mut(&mut self) -> &mut T {\n+        unimplemented!()\n+    }\n+\n+    pub fn as_ref(&self) -> &T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitand(self, rhs: T) -> T {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn bitxor(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow(&self) -> &str {\n+        unimplemented!()\n+    }\n+\n+    pub fn borrow_mut(&mut self) -> &mut str {\n+        unimplemented!()\n+    }\n+\n+    pub fn clone(&self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn cmp(&self, other: &Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn default() -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref(&self) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn deref_mut(&mut self) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn div(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn drop(&mut self) {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 1 end\n+    // **********\n+}"}, {"sha": "2b7d4628c3fa02b703e9a58cb98b73d4a1dd6489", "filename": "tests/ui/should_impl_trait/method_list_1.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -0,0 +1,143 @@\n+error: method `add` can be confused for the standard trait method `std::ops::Add::add`\n+  --> $DIR/method_list_1.rs:25:5\n+   |\n+LL | /     pub fn add(self, other: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::ops::Add` or choosing a less ambiguous method name\n+\n+error: method `as_mut` can be confused for the standard trait method `std::convert::AsMut::as_mut`\n+  --> $DIR/method_list_1.rs:29:5\n+   |\n+LL | /     pub fn as_mut(&mut self) -> &mut T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsMut` or choosing a less ambiguous method name\n+\n+error: method `as_ref` can be confused for the standard trait method `std::convert::AsRef::as_ref`\n+  --> $DIR/method_list_1.rs:33:5\n+   |\n+LL | /     pub fn as_ref(&self) -> &T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::convert::AsRef` or choosing a less ambiguous method name\n+\n+error: method `bitand` can be confused for the standard trait method `std::ops::BitAnd::bitand`\n+  --> $DIR/method_list_1.rs:37:5\n+   |\n+LL | /     pub fn bitand(self, rhs: T) -> T {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitAnd` or choosing a less ambiguous method name\n+\n+error: method `bitor` can be confused for the standard trait method `std::ops::BitOr::bitor`\n+  --> $DIR/method_list_1.rs:41:5\n+   |\n+LL | /     pub fn bitor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitOr` or choosing a less ambiguous method name\n+\n+error: method `bitxor` can be confused for the standard trait method `std::ops::BitXor::bitxor`\n+  --> $DIR/method_list_1.rs:45:5\n+   |\n+LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::BitXor` or choosing a less ambiguous method name\n+\n+error: method `borrow` can be confused for the standard trait method `std::borrow::Borrow::borrow`\n+  --> $DIR/method_list_1.rs:49:5\n+   |\n+LL | /     pub fn borrow(&self) -> &str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::Borrow` or choosing a less ambiguous method name\n+\n+error: method `borrow_mut` can be confused for the standard trait method `std::borrow::BorrowMut::borrow_mut`\n+  --> $DIR/method_list_1.rs:53:5\n+   |\n+LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::borrow::BorrowMut` or choosing a less ambiguous method name\n+\n+error: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\n+  --> $DIR/method_list_1.rs:57:5\n+   |\n+LL | /     pub fn clone(&self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\n+\n+error: method `cmp` can be confused for the standard trait method `std::cmp::Ord::cmp`\n+  --> $DIR/method_list_1.rs:61:5\n+   |\n+LL | /     pub fn cmp(&self, other: &Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::cmp::Ord` or choosing a less ambiguous method name\n+\n+error: method `deref` can be confused for the standard trait method `std::ops::Deref::deref`\n+  --> $DIR/method_list_1.rs:69:5\n+   |\n+LL | /     pub fn deref(&self) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Deref` or choosing a less ambiguous method name\n+\n+error: method `deref_mut` can be confused for the standard trait method `std::ops::DerefMut::deref_mut`\n+  --> $DIR/method_list_1.rs:73:5\n+   |\n+LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::DerefMut` or choosing a less ambiguous method name\n+\n+error: method `div` can be confused for the standard trait method `std::ops::Div::div`\n+  --> $DIR/method_list_1.rs:77:5\n+   |\n+LL | /     pub fn div(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Div` or choosing a less ambiguous method name\n+\n+error: method `drop` can be confused for the standard trait method `std::ops::Drop::drop`\n+  --> $DIR/method_list_1.rs:81:5\n+   |\n+LL | /     pub fn drop(&mut self) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Drop` or choosing a less ambiguous method name\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "ed5e0d384bf5040c0d90135bc6cd65ab5832306d", "filename": "tests/ui/should_impl_trait/method_list_2.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -0,0 +1,88 @@\n+// edition:2018\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(\n+    clippy::missing_errors_doc,\n+    clippy::needless_pass_by_value,\n+    clippy::must_use_candidate,\n+    clippy::unused_self,\n+    clippy::needless_lifetimes,\n+    clippy::missing_safety_doc,\n+    clippy::wrong_self_convention\n+)]\n+\n+use std::ops::Mul;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+pub struct T;\n+\n+impl T {\n+    // *****************************************\n+    // trait method list part 2, should lint all\n+    // *****************************************\n+\n+    pub fn eq(&self, other: &Self) -> bool {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_iter<T>(iter: T) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn from_str(s: &str) -> Result<Self, Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn hash(&self, state: &mut T) {\n+        unimplemented!()\n+    }\n+\n+    pub fn index(&self, index: usize) -> &Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn into_iter(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn mul(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn neg(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn next(&mut self) -> Option<Self> {\n+        unimplemented!()\n+    }\n+\n+    pub fn not(self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn rem(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shl(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn shr(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+\n+    pub fn sub(self, rhs: Self) -> Self {\n+        unimplemented!()\n+    }\n+    // **********\n+    // part 2 end\n+    // **********\n+}"}, {"sha": "b6fd435695698e6ca47adee8a423824472e6b14d", "filename": "tests/ui/should_impl_trait/method_list_2.stderr", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/166c520e9a8b1a45819255e75dee737136aa6ec8/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr?ref=166c520e9a8b1a45819255e75dee737136aa6ec8", "patch": "@@ -0,0 +1,153 @@\n+error: method `eq` can be confused for the standard trait method `std::cmp::PartialEq::eq`\n+  --> $DIR/method_list_2.rs:26:5\n+   |\n+LL | /     pub fn eq(&self, other: &Self) -> bool {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::should-implement-trait` implied by `-D warnings`\n+   = help: consider implementing the trait `std::cmp::PartialEq` or choosing a less ambiguous method name\n+\n+error: method `from_iter` can be confused for the standard trait method `std::iter::FromIterator::from_iter`\n+  --> $DIR/method_list_2.rs:30:5\n+   |\n+LL | /     pub fn from_iter<T>(iter: T) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::FromIterator` or choosing a less ambiguous method name\n+\n+error: method `from_str` can be confused for the standard trait method `std::str::FromStr::from_str`\n+  --> $DIR/method_list_2.rs:34:5\n+   |\n+LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::str::FromStr` or choosing a less ambiguous method name\n+\n+error: method `hash` can be confused for the standard trait method `std::hash::Hash::hash`\n+  --> $DIR/method_list_2.rs:38:5\n+   |\n+LL | /     pub fn hash(&self, state: &mut T) {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::hash::Hash` or choosing a less ambiguous method name\n+\n+error: method `index` can be confused for the standard trait method `std::ops::Index::index`\n+  --> $DIR/method_list_2.rs:42:5\n+   |\n+LL | /     pub fn index(&self, index: usize) -> &Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Index` or choosing a less ambiguous method name\n+\n+error: method `index_mut` can be confused for the standard trait method `std::ops::IndexMut::index_mut`\n+  --> $DIR/method_list_2.rs:46:5\n+   |\n+LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::IndexMut` or choosing a less ambiguous method name\n+\n+error: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`\n+  --> $DIR/method_list_2.rs:50:5\n+   |\n+LL | /     pub fn into_iter(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name\n+\n+error: method `mul` can be confused for the standard trait method `std::ops::Mul::mul`\n+  --> $DIR/method_list_2.rs:54:5\n+   |\n+LL | /     pub fn mul(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Mul` or choosing a less ambiguous method name\n+\n+error: method `neg` can be confused for the standard trait method `std::ops::Neg::neg`\n+  --> $DIR/method_list_2.rs:58:5\n+   |\n+LL | /     pub fn neg(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Neg` or choosing a less ambiguous method name\n+\n+error: method `next` can be confused for the standard trait method `std::iter::Iterator::next`\n+  --> $DIR/method_list_2.rs:62:5\n+   |\n+LL | /     pub fn next(&mut self) -> Option<Self> {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::iter::Iterator` or choosing a less ambiguous method name\n+\n+error: method `not` can be confused for the standard trait method `std::ops::Not::not`\n+  --> $DIR/method_list_2.rs:66:5\n+   |\n+LL | /     pub fn not(self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Not` or choosing a less ambiguous method name\n+\n+error: method `rem` can be confused for the standard trait method `std::ops::Rem::rem`\n+  --> $DIR/method_list_2.rs:70:5\n+   |\n+LL | /     pub fn rem(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Rem` or choosing a less ambiguous method name\n+\n+error: method `shl` can be confused for the standard trait method `std::ops::Shl::shl`\n+  --> $DIR/method_list_2.rs:74:5\n+   |\n+LL | /     pub fn shl(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shl` or choosing a less ambiguous method name\n+\n+error: method `shr` can be confused for the standard trait method `std::ops::Shr::shr`\n+  --> $DIR/method_list_2.rs:78:5\n+   |\n+LL | /     pub fn shr(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Shr` or choosing a less ambiguous method name\n+\n+error: method `sub` can be confused for the standard trait method `std::ops::Sub::sub`\n+  --> $DIR/method_list_2.rs:82:5\n+   |\n+LL | /     pub fn sub(self, rhs: Self) -> Self {\n+LL | |         unimplemented!()\n+LL | |     }\n+   | |_____^\n+   |\n+   = help: consider implementing the trait `std::ops::Sub` or choosing a less ambiguous method name\n+\n+error: aborting due to 15 previous errors\n+"}]}