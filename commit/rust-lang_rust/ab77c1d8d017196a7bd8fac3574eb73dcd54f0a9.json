{"sha": "ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNzdjMWQ4ZDAxNzE5NmE3YmQ4ZmFjMzU3NGViNzNkY2Q1NGYwYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-07T12:23:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-07T12:23:06Z"}, "message": "Auto merge of #27551 - arielb1:adt-def, r=nikomatsakis\n\nThis ended up being a bigger refactoring than I thought, as I also cleaned a few ugly points in rustc. There are still a few areas that need improvements.\r\n\r\nPerformance numbers:\r\n```\r\nBefore:\r\n572.70user 5.52system 7:33.21elapsed 127%CPU (0avgtext+0avgdata 1173368maxresident)k\r\nllvm-time: 385.858\r\n\r\nAfter:\r\n545.27user 5.49system 7:10.22elapsed 128%CPU (0avgtext+0avgdata 1145348maxresident)k\r\nllvm-time: 387.119\r\n```\r\n\r\nA good 5% perf improvement. Note that after this patch >70% of the time is spent in LLVM - Amdahl's law is in full effect.\r\n\r\nPasses make check locally.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "dd930ec76aee1e1857d6aebcb0b80ea2ce53aaff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd930ec76aee1e1857d6aebcb0b80ea2ce53aaff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "html_url": "https://github.com/rust-lang/rust/commit/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bba7110639cbd1d51977d97106d377fdfac7cdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bba7110639cbd1d51977d97106d377fdfac7cdf", "html_url": "https://github.com/rust-lang/rust/commit/9bba7110639cbd1d51977d97106d377fdfac7cdf"}, {"sha": "eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedb1cc5765b043f31ca4316c42f2ac8d7df1919", "html_url": "https://github.com/rust-lang/rust/commit/eedb1cc5765b043f31ca4316c42f2ac8d7df1919"}], "stats": {"total": 4301, "additions": 2091, "deletions": 2210}, "files": [{"sha": "baa9750d311aa7e4bce913f0086f66a2069f2758", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -692,64 +692,6 @@ There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n \"####,\n \n-E0079: r##\"\n-Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an integer\n-literal and is therefore invalid.\n-\n-For example, in the following code,\n-\n-```\n-enum Foo {\n-    Q = \"32\"\n-}\n-```\n-\n-we try to set the representation to a string.\n-\n-There's no general fix for this; if you can work with an integer then just set\n-it to one:\n-\n-```\n-enum Foo {\n-    Q = 32\n-}\n-```\n-\n-however if you actually wanted a mapping between variants and non-integer\n-objects, it may be preferable to use a method with a match instead:\n-\n-```\n-enum Foo { Q }\n-impl Foo {\n-    fn get_str(&self) -> &'static str {\n-        match *self {\n-            Foo::Q => \"32\",\n-        }\n-    }\n-}\n-```\n-\"##,\n-\n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n-integer expression provided as an enum discriminant. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:\n@@ -1937,6 +1879,5 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0370, // discriminant overflow\n     E0400  // overloaded derefs are not allowed in constants\n }"}, {"sha": "1a15d98d53150eb6beba317c510ce40b8b54920e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -32,6 +32,7 @@\n #![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(const_fn)]\n+#![feature(core)]\n #![feature(duration)]\n #![feature(duration_span)]\n #![feature(dynamic_lib)]\n@@ -42,6 +43,7 @@\n #![feature(iter_cmp)]\n #![feature(iter_arith)]\n #![feature(libc)]\n+#![feature(nonzero)]\n #![feature(num_bits_bytes)]\n #![feature(path_ext)]\n #![feature(quote)]\n@@ -65,6 +67,7 @@\n #![allow(trivial_casts)]\n \n extern crate arena;\n+extern crate core;\n extern crate flate;\n extern crate fmt_macros;\n extern crate getopts;"}, {"sha": "efa17912a32f01afd2d963a17d8c5431680063e9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -112,13 +112,6 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n     decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n }\n \n-pub fn get_enum_variants<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n-                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n-}\n-\n /// Returns information about the given implementation.\n pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n@@ -194,11 +187,9 @@ pub fn get_item_attrs(cstore: &cstore::CStore,\n     decoder::get_item_attrs(&*cdata, def_id.node)\n }\n \n-pub fn get_struct_fields(cstore: &cstore::CStore,\n-                         def: ast::DefId)\n-                      -> Vec<ty::FieldTy> {\n+pub fn get_struct_field_names(cstore: &cstore::CStore, def: ast::DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_fields(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n }\n \n pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashMap<ast::NodeId,\n@@ -221,6 +212,12 @@ pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDe\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n+pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::AdtDefMaster<'tcx> {\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)\n+}\n+\n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n                             -> ty::GenericPredicates<'tcx>\n {"}, {"sha": "df5f798217f4b96e3dd7c061cacc18cc0e5d541d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 121, "deletions": 80, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -30,7 +30,7 @@ use middle::def;\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use util::nodemap::FnvHashMap;\n \n use std::cell::{Cell, RefCell};\n@@ -108,7 +108,7 @@ fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> rbml::Doc<'a> {\n     find_item(item_id, items)\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c\n     MutStatic,             // b\n@@ -390,6 +390,119 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     }\n }\n \n+pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n+                         cdata: Cmd,\n+                         item_id: ast::NodeId,\n+                         tcx: &ty::ctxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n+{\n+    fn get_enum_variants<'tcx>(intr: &IdentInterner,\n+                               cdata: Cmd,\n+                               doc: rbml::Doc,\n+                               tcx: &ty::ctxt<'tcx>) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n+        let mut disr_val = 0;\n+        reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n+            let did = translated_def_id(cdata, p);\n+            let item = lookup_item(did.node, cdata.data());\n+\n+            if let Some(disr) = variant_disr_val(item) {\n+                disr_val = disr;\n+            }\n+            let disr = disr_val;\n+            disr_val = disr_val.wrapping_add(1);\n+\n+            ty::VariantDefData {\n+                did: did,\n+                name: item_name(intr, item),\n+                fields: get_variant_fields(intr, cdata, item, tcx),\n+                disr_val: disr\n+            }\n+        }).collect()\n+    }\n+    fn get_variant_fields<'tcx>(intr: &IdentInterner,\n+                                cdata: Cmd,\n+                                doc: rbml::Doc,\n+                                tcx: &ty::ctxt<'tcx>) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n+        reader::tagged_docs(doc, tag_item_field).map(|f| {\n+            let ff = item_family(f);\n+            match ff {\n+                PublicField | InheritedField => {},\n+                _ => tcx.sess.bug(&format!(\"expected field, found {:?}\", ff))\n+            };\n+            ty::FieldDefData::new(item_def_id(f, cdata),\n+                                  item_name(intr, f),\n+                                  struct_field_family_to_visibility(ff))\n+        }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n+            let ff = item_family(f);\n+            ty::FieldDefData::new(item_def_id(f, cdata),\n+                                  special_idents::unnamed_field.name,\n+                                  struct_field_family_to_visibility(ff))\n+        })).collect()\n+    }\n+    fn get_struct_variant<'tcx>(intr: &IdentInterner,\n+                                cdata: Cmd,\n+                                doc: rbml::Doc,\n+                                did: ast::DefId,\n+                                tcx: &ty::ctxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n+        ty::VariantDefData {\n+            did: did,\n+            name: item_name(intr, doc),\n+            fields: get_variant_fields(intr, cdata, doc, tcx),\n+            disr_val: 0\n+        }\n+    }\n+\n+    let doc = lookup_item(item_id, cdata.data());\n+    let did = ast::DefId { krate: cdata.cnum, node: item_id };\n+    let (kind, variants) = match item_family(doc) {\n+        Enum => (ty::AdtKind::Enum,\n+                 get_enum_variants(intr, cdata, doc, tcx)),\n+        Struct => (ty::AdtKind::Struct,\n+                   vec![get_struct_variant(intr, cdata, doc, did, tcx)]),\n+        _ => tcx.sess.bug(\"get_adt_def called on a non-ADT\")\n+    };\n+\n+    let adt = tcx.intern_adt_def(did, kind, variants);\n+\n+    // this needs to be done *after* the variant is interned,\n+    // to support recursive structures\n+    for variant in &adt.variants {\n+        if variant.kind() == ty::VariantKind::Tuple &&\n+            adt.adt_kind() == ty::AdtKind::Enum {\n+            // tuple-like enum variant fields aren't real items - get the types\n+            // from the ctor.\n+            debug!(\"evaluating the ctor-type of {:?}\",\n+                   variant.name);\n+            let ctor_ty = get_type(cdata, variant.did.node, tcx).ty;\n+            debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n+                   variant.name,\n+                   ctor_ty);\n+            let field_tys = match ctor_ty.sty {\n+                ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+                    ref inputs, ..\n+                }), ..}) => {\n+                    // tuple-struct constructors don't have escaping regions\n+                    assert!(!inputs.has_escaping_regions());\n+                    inputs\n+                },\n+                _ => tcx.sess.bug(\"tuple-variant ctor is not an ADT\")\n+            };\n+            for (field, &ty) in variant.fields.iter().zip(field_tys.iter()) {\n+                field.fulfill_ty(ty);\n+            }\n+        } else {\n+            for field in &variant.fields {\n+                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                let ty = get_type(cdata, field.did.node, tcx).ty;\n+                field.fulfill_ty(ty);\n+                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n+                       variant.name, field.name, ty);\n+            }\n+        }\n+    }\n+\n+    adt\n+}\n+\n pub fn get_predicates<'tcx>(cdata: Cmd,\n                             item_id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)\n@@ -687,55 +800,6 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     }\n }\n \n-pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                               tcx: &ty::ctxt<'tcx>) -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-    let data = cdata.data();\n-    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n-    let item = find_item(id, items);\n-    let mut disr_val = 0;\n-    reader::tagged_docs(item, tag_items_data_item_variant).map(|p| {\n-        let did = translated_def_id(cdata, p);\n-        let item = find_item(did.node, items);\n-        let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n-                                item, tcx, cdata);\n-        let name = item_name(&*intr, item);\n-        let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n-            ty::TyBareFn(_, ref f) =>\n-                (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n-            _ => { // Nullary or struct enum variant.\n-                let mut arg_names = Vec::new();\n-                let arg_tys = get_struct_fields(intr.clone(), cdata, did.node)\n-                    .iter()\n-                    .map(|field_ty| {\n-                        arg_names.push(field_ty.name);\n-                        get_type(cdata, field_ty.id.node, tcx).ty\n-                    })\n-                    .collect();\n-                let arg_names = if arg_names.is_empty() { None } else { Some(arg_names) };\n-\n-                (None, arg_tys, arg_names)\n-            }\n-        };\n-        match variant_disr_val(item) {\n-            Some(val) => { disr_val = val; }\n-            _         => { /* empty */ }\n-        }\n-        let old_disr_val = disr_val;\n-        disr_val = disr_val.wrapping_add(1);\n-        Rc::new(ty::VariantInfo {\n-            args: arg_tys,\n-            arg_names: arg_names,\n-            ctor_ty: ctor_ty,\n-            name: name,\n-            // I'm not even sure if we encode visibility\n-            // for variants -- TEST -- tjc\n-            id: did,\n-            disr_val: old_disr_val,\n-            vis: ast::Inherited\n-        })\n-    }).collect()\n-}\n-\n fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n@@ -1029,37 +1093,14 @@ fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n     }\n }\n \n-pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n-    -> Vec<ty::FieldTy> {\n+pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: ast::NodeId)\n+    -> Vec<ast::Name> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    reader::tagged_docs(item, tag_item_field).filter_map(|an_item| {\n-        let f = item_family(an_item);\n-        if f == PublicField || f == InheritedField {\n-            let name = item_name(&*intr, an_item);\n-            let did = item_def_id(an_item, cdata);\n-            let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-            let origin_id =  translated_def_id(cdata, tagdoc);\n-            Some(ty::FieldTy {\n-                name: name,\n-                id: did,\n-                vis: struct_field_family_to_visibility(f),\n-                origin: origin_id,\n-            })\n-        } else {\n-            None\n-        }\n-    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|an_item| {\n-        let did = item_def_id(an_item, cdata);\n-        let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-        let f = item_family(an_item);\n-        let origin_id =  translated_def_id(cdata, tagdoc);\n-        ty::FieldTy {\n-            name: special_idents::unnamed_field.name,\n-            id: did,\n-            vis: struct_field_family_to_visibility(f),\n-            origin: origin_id,\n-        }\n+    reader::tagged_docs(item, tag_item_field).map(|an_item| {\n+        item_name(intr, an_item)\n+    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n+        special_idents::unnamed_field.name\n     })).collect()\n }\n "}, {"sha": "d5c189ff044d2ea3006479ac431d041253a9822e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -41,7 +41,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n@@ -266,17 +265,17 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        fields: &[ty::FieldTy],\n+                        variant: ty::VariantDef,\n                         origin: DefId) {\n-    for f in fields {\n+    for f in &variant.fields {\n         if f.name == special_idents::unnamed_field.name {\n             rbml_w.start_tag(tag_item_unnamed_field);\n         } else {\n             rbml_w.start_tag(tag_item_field);\n             encode_name(rbml_w, f.name);\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n-        encode_def_id(rbml_w, f.id);\n+        encode_def_id(rbml_w, f.did);\n         rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n@@ -285,57 +284,53 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             rbml_w: &mut Encoder,\n                             id: NodeId,\n-                            variants: &[P<ast::Variant>],\n+                            vis: ast::Visibility,\n                             index: &mut Vec<entry<i64>>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n-    let mut i = 0;\n-    let vi = ecx.tcx.enum_variants(local_def(id));\n-    for variant in variants {\n-        let def_id = local_def(variant.node.id);\n+    let def = ecx.tcx.lookup_adt_def(local_def(id));\n+    for variant in &def.variants {\n+        let vid = variant.did;\n+        assert!(is_local(vid));\n         index.push(entry {\n-            val: variant.node.id as i64,\n+            val: vid.node as i64,\n             pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n-        encode_def_id(rbml_w, def_id);\n-        match variant.node.kind {\n-            ast::TupleVariantKind(_) => encode_family(rbml_w, 'v'),\n-            ast::StructVariantKind(_) => encode_family(rbml_w, 'V')\n-        }\n-        encode_name(rbml_w, variant.node.name.name);\n+        encode_def_id(rbml_w, vid);\n+        encode_family(rbml_w, match variant.kind() {\n+            ty::VariantKind::Unit | ty::VariantKind::Tuple => 'v',\n+            ty::VariantKind::Dict => 'V'\n+        });\n+        encode_name(rbml_w, variant.name);\n         encode_parent_item(rbml_w, local_def(id));\n-        encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, &variant.node.attrs);\n-        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs);\n+        encode_visibility(rbml_w, vis);\n+\n+        let attrs = ecx.tcx.get_attrs(vid);\n+        encode_attributes(rbml_w, &attrs);\n+        encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n+        let stab = stability::lookup(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n \n-        match variant.node.kind {\n-            ast::TupleVariantKind(_) => {},\n-            ast::StructVariantKind(_) => {\n-                let fields = ecx.tcx.lookup_struct_fields(def_id);\n-                let idx = encode_info_for_struct(ecx,\n-                                                 rbml_w,\n-                                                 &fields[..],\n-                                                 index);\n-                encode_struct_fields(rbml_w, &fields[..], def_id);\n-                encode_index(rbml_w, idx, write_i64);\n-            }\n+        if let ty::VariantKind::Dict = variant.kind() {\n+            let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n+            encode_index(rbml_w, idx, write_i64);\n         }\n-        let specified_disr_val = vi[i].disr_val;\n+\n+        encode_struct_fields(rbml_w, variant, vid);\n+\n+        let specified_disr_val = variant.disr_val;\n         if specified_disr_val != disr_val {\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, def_id.local_id());\n+        encode_bounds_and_type_for_item(rbml_w, ecx, vid.node);\n \n-        ecx.tcx.map.with_path(variant.node.id, |path| encode_path(rbml_w, path));\n+        ecx.tcx.map.with_path(vid.node, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n         disr_val = disr_val.wrapping_add(1);\n-        i += 1;\n     }\n }\n \n@@ -630,19 +625,19 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_struct(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          fields: &[ty::FieldTy],\n-                          global_index: &mut Vec<entry<i64>>)\n-                          -> Vec<entry<i64>> {\n+fn encode_info_for_struct<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    variant: ty::VariantDef<'tcx>,\n+                                    global_index: &mut Vec<entry<i64>>)\n+                                    -> Vec<entry<i64>> {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n     let mut index = Vec::new();\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-    for field in fields {\n+    for field in &variant.fields {\n         let nm = field.name;\n-        let id = field.id.node;\n+        let id = field.did.node;\n \n         let pos = rbml_w.mark_stable_position();\n         index.push(entry {val: id as i64, pos: pos});\n@@ -658,7 +653,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, id);\n         encode_def_id(rbml_w, local_def(id));\n \n-        let stab = stability::lookup(ecx.tcx, field.id);\n+        let stab = stability::lookup(ecx.tcx, field.did);\n         encode_stability(rbml_w, stab);\n \n         rbml_w.end_tag();\n@@ -1150,20 +1145,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 &(*enum_definition).variants,\n+                                 vis,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n-        let fields = tcx.lookup_struct_fields(def_id);\n+        let def = ecx.tcx.lookup_adt_def(def_id);\n+        let variant = def.struct_variant();\n \n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_struct(ecx,\n-                                         rbml_w,\n-                                         &fields[..],\n-                                         index);\n+        let idx = encode_info_for_struct(ecx, rbml_w, variant, index);\n \n         /* Index the class*/\n         add_to_index(item, rbml_w, index);\n@@ -1185,7 +1178,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, &fields[..], def_id);\n+        encode_struct_fields(rbml_w, variant, def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n "}, {"sha": "679213874f9646da6b33f6b263dc85ffa82b89a8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -468,9 +468,10 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def_(st, NominalType, conv);\n+        let did = parse_def_(st, NominalType, conv);\n         let substs = parse_substs_(st, conv);\n         assert_eq!(next(st), ']');\n+        let def = st.tcx.lookup_adt_def(did);\n         return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n@@ -558,7 +559,8 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n           let did = parse_def_(st, NominalType, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return st.tcx.mk_struct(did, st.tcx.mk_substs(substs));\n+          let def = st.tcx.lookup_adt_def(did);\n+          return st.tcx.mk_struct(def, st.tcx.mk_substs(substs));\n       }\n       'k' => {\n           assert_eq!(next(st), '[');"}, {"sha": "88666be6c2cc2598f254861b4b50299b121a7db9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -86,7 +86,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             }\n         }\n         ty::TyEnum(def, substs) => {\n-            mywrite!(w, \"t[{}|\", (cx.ds)(def));\n+            mywrite!(w, \"t[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n@@ -138,7 +138,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n         }\n         ty::TyStruct(def, substs) => {\n-            mywrite!(w, \"a[{}|\", (cx.ds)(def));\n+            mywrite!(w, \"a[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }"}, {"sha": "8233b6b2b2b6e7a61f4a16e3f5ce45442b6814c2", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -58,15 +58,14 @@ pub enum CastKind {\n }\n \n impl<'tcx> CastTy<'tcx> {\n-    pub fn from_ty(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n-                   -> Option<CastTy<'tcx>> {\n+    pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n         match t.sty {\n             ty::TyBool => Some(CastTy::Int(IntTy::Bool)),\n             ty::TyChar => Some(CastTy::Int(IntTy::Char)),\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(..) if t.is_c_like_enum(tcx) =>\n+            ty::TyEnum(d,_) if d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),"}, {"sha": "4ee8f403e428274f9ce7d0c1ebd96b5bb6de1ca5", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -546,8 +546,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         e: &ast::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::TyStruct(did, _) |\n-        ty::TyEnum(did, _) if v.tcx.has_dtor(did) => {\n+        ty::TyStruct(def, _) |\n+        ty::TyEnum(def, _) if def.has_dtor(v.tcx) => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,"}, {"sha": "b9d8e4b842d01a607c68d22372c4558fa9194f2d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 38, "deletions": 62, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -234,12 +234,12 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n         match p.node {\n             ast::PatIdent(ast::BindByValue(ast::MutImmutable), ident, None) => {\n                 let pat_ty = cx.tcx.pat_ty(p);\n-                if let ty::TyEnum(def_id, _) = pat_ty.sty {\n+                if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if cx.tcx.enum_variants(def_id).iter().any(|variant|\n+                        if edef.variants.iter().any(|variant|\n                             variant.name == ident.node.name\n-                                && variant.args.is_empty()\n+                                && variant.kind() == VariantKind::Unit\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n@@ -501,23 +501,17 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n ///\n /// left_ty: struct X { a: (bool, &'static str), b: usize}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n+fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n+                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match left_ty.sty {\n         ty::TyTuple(_) => ast::PatTup(pats.collect()),\n \n-        ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n-            let (vid, is_structure) = match ctor {\n-                &Variant(vid) =>\n-                    (vid, cx.tcx.enum_variant_with_id(cid, vid).arg_names.is_some()),\n-                _ =>\n-                    (cid, !cx.tcx.is_tuple_struct(cid))\n-            };\n-            if is_structure {\n-                let fields = cx.tcx.lookup_struct_fields(vid);\n-                let field_pats: Vec<_> = fields.into_iter()\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n+            let v = adt.variant_of_ctor(ctor);\n+            if let VariantKind::Dict = v.kind() {\n+                let field_pats: Vec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n                     .map(|(field, pat)| Spanned {\n@@ -529,9 +523,9 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                ast::PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n+                ast::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n             } else {\n-                ast::PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n+                ast::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n             }\n         }\n \n@@ -580,6 +574,17 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n     })\n }\n \n+impl<'tcx, 'container> ty::AdtDefData<'tcx, 'container> {\n+    fn variant_of_ctor(&self,\n+                       ctor: &Constructor)\n+                       -> &VariantDefData<'tcx, 'container> {\n+        match ctor {\n+            &Variant(vid) => self.variant_with_id(vid),\n+            _ => self.struct_variant()\n+        }\n+    }\n+}\n+\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n@@ -594,7 +599,7 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n+fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n         ty::TyBool =>\n@@ -603,17 +608,11 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n             ty::TySlice(_) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n-            _ => vec!(Single)\n+            _ => vec![Single]\n         },\n \n-        ty::TyEnum(eid, _) =>\n-            cx.tcx.enum_variants(eid)\n-                .iter()\n-                .map(|va| Variant(va.id))\n-                .collect(),\n-\n-        _ =>\n-            vec!(Single)\n+        ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        _ => vec![Single]\n     }\n }\n \n@@ -804,7 +803,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n@@ -817,13 +816,9 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n             ty::TyStr => 0,\n             _ => 1\n         },\n-        ty::TyEnum(eid, _) => {\n-            match *ctor {\n-                Variant(id) => cx.tcx.enum_variant_with_id(eid, id).args.len(),\n-                _ => unreachable!()\n-            }\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n+            adt.variant_of_ctor(ctor).fields.len()\n         }\n-        ty::TyStruct(cid, _) => cx.tcx.lookup_struct_fields(cid).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }\n@@ -902,39 +897,20 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n-            // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            let class_id = match def {\n-                DefConst(..) | DefAssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n-                    Some(variant_id)\n-                } else {\n-                    None\n-                },\n-                _ => {\n-                    // Assume this is a struct.\n-                    match cx.tcx.node_id_to_type(pat_id).ty_to_def_id() {\n-                        None => {\n-                            cx.tcx.sess.span_bug(pat_span,\n-                                                 \"struct pattern wasn't of a \\\n-                                                  type with a def ID?!\")\n-                        }\n-                        Some(def_id) => Some(def_id),\n-                    }\n-                }\n-            };\n-            class_id.map(|variant_id| {\n-                let struct_fields = cx.tcx.lookup_struct_fields(variant_id);\n-                let args = struct_fields.iter().map(|sf| {\n+            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n+            let variant = adt.variant_of_ctor(constructor);\n+            let def_variant = adt.variant_of_def(def);\n+            if variant.did == def_variant.did {\n+                Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n                         _ => DUMMY_WILD_PAT\n                     }\n-                }).collect();\n-                args\n-            })\n+                }).collect())\n+            } else {\n+                None\n+            }\n         }\n \n         ast::PatTup(ref args) =>"}, {"sha": "bd8a666ffecb22236983f722479afe9f78e92bdf", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -100,51 +100,32 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(id, _) => {\n-                let fields = self.tcx.lookup_struct_fields(id);\n-                let field_id = fields.iter()\n-                    .find(|field| field.name == name).unwrap().id;\n-                self.live_symbols.insert(field_id.node);\n-            },\n-            _ => ()\n+        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n+            self.live_symbols.insert(def.struct_variant().field_named(name).did.node);\n+        } else {\n+            self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(id, _) => {\n-                let fields = self.tcx.lookup_struct_fields(id);\n-                let field_id = fields[idx].id;\n-                self.live_symbols.insert(field_id.node);\n-            },\n-            _ => ()\n+        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n+            self.live_symbols.insert(def.struct_variant().fields[idx].did.node);\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n-            def::DefVariant(_, id, _) => id,\n-            _ => {\n-                match self.tcx.node_id_to_type(lhs.id).ty_to_def_id() {\n-                    None => {\n-                        self.tcx.sess.span_bug(lhs.span,\n-                                               \"struct pattern wasn't of a \\\n-                                                type with a def ID?!\")\n-                    }\n-                    Some(def_id) => def_id,\n-                }\n-            }\n+        let def = self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def();\n+        let pat_ty = self.tcx.node_id_to_type(lhs.id);\n+        let variant = match pat_ty.sty {\n+            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n+            _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n         };\n-        let fields = self.tcx.lookup_struct_fields(id);\n         for pat in pats {\n             if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n-            let field_id = fields.iter()\n-                .find(|field| field.name == pat.node.ident.name).unwrap().id;\n-            self.live_symbols.insert(field_id.node);\n+            self.live_symbols.insert(variant.field_named(pat.node.ident.name).did.node);\n         }\n     }\n "}, {"sha": "3755b4c57c3ece41d91e456e0627e345bb7c9974", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -694,41 +694,36 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        let with_fields = match with_cmt.ty.sty {\n-            ty::TyStruct(did, substs) => {\n-                self.tcx().struct_fields(did, substs)\n-            }\n-            _ => {\n-                // the base expression should always evaluate to a\n-                // struct; however, when EUV is run during typeck, it\n-                // may not. This will generate an error earlier in typeck,\n-                // so we can just ignore it.\n-                if !self.tcx().sess.has_errors() {\n-                    self.tcx().sess.span_bug(\n-                        with_expr.span,\n-                        \"with expression doesn't evaluate to a struct\");\n+        if let ty::TyStruct(def, substs) = with_cmt.ty.sty {\n+            // Consume those fields of the with expression that are needed.\n+            for with_field in &def.struct_variant().fields {\n+                if !contains_field_named(with_field, fields) {\n+                    let cmt_field = self.mc.cat_field(\n+                        &*with_expr,\n+                        with_cmt.clone(),\n+                        with_field.name,\n+                        with_field.ty(self.tcx(), substs)\n+                    );\n+                    self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n                 }\n-                assert!(self.tcx().sess.has_errors());\n-                vec!()\n             }\n-        };\n-\n-        // Consume those fields of the with expression that are needed.\n-        for with_field in &with_fields {\n-            if !contains_field_named(with_field, fields) {\n-                let cmt_field = self.mc.cat_field(&*with_expr,\n-                                                  with_cmt.clone(),\n-                                                  with_field.name,\n-                                                  with_field.mt.ty);\n-                self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+        } else {\n+            // the base expression should always evaluate to a\n+            // struct; however, when EUV is run during typeck, it\n+            // may not. This will generate an error earlier in typeck,\n+            // so we can just ignore it.\n+            if !self.tcx().sess.has_errors() {\n+                self.tcx().sess.span_bug(\n+                    with_expr.span,\n+                    \"with expression doesn't evaluate to a struct\");\n             }\n-        }\n+        };\n \n         // walk the with expression so that complex expressions\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: &ty::Field,\n+        fn contains_field_named(field: ty::FieldDef,\n                                 fields: &Vec<ast::Field>)\n                                 -> bool\n         {\n@@ -1106,7 +1101,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                         Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n-                                if tcx.enum_is_univariant(enum_did) {\n+                                if tcx.lookup_adt_def(enum_did).is_univariant() {\n                                     cmt_pat\n                                 } else {\n                                     let cmt_pat_ty = cmt_pat.ty;"}, {"sha": "8ff81635416a4b65df7e83eda7de7bf03315d968", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -53,15 +53,15 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::TyInt(int_type) => Some(IntSimplifiedType(int_type)),\n         ty::TyUint(uint_type) => Some(UintSimplifiedType(uint_type)),\n         ty::TyFloat(float_type) => Some(FloatSimplifiedType(float_type)),\n-        ty::TyEnum(def_id, _) => Some(EnumSimplifiedType(def_id)),\n+        ty::TyEnum(def, _) => Some(EnumSimplifiedType(def.did)),\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(VecSimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n         ty::TyTrait(ref trait_info) => {\n             Some(TraitSimplifiedType(trait_info.principal_def_id()))\n         }\n-        ty::TyStruct(def_id, _) => {\n-            Some(StructSimplifiedType(def_id))\n+        ty::TyStruct(def, _) => {\n+            Some(StructSimplifiedType(def.did))\n         }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we"}, {"sha": "84fc2f7b2e5401e9ebfd6d3225174be6570d72a3", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -144,10 +144,10 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 self.accumulate_from_object_ty(ty, t.bounds.region_bound, required_region_bounds)\n             }\n \n-            ty::TyEnum(def_id, substs) |\n-            ty::TyStruct(def_id, substs) => {\n-                let item_scheme = self.tcx().lookup_item_type(def_id);\n-                self.accumulate_from_adt(ty, def_id, &item_scheme.generics, substs)\n+            ty::TyEnum(def, substs) |\n+            ty::TyStruct(def, substs) => {\n+                let item_scheme = def.type_scheme(self.tcx());\n+                self.accumulate_from_adt(ty, def.did, &item_scheme.generics, substs)\n             }\n \n             ty::TyArray(t, _) |"}, {"sha": "3ab0d4c04d73c3208ced509311338958c5ff05b5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -1216,7 +1216,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let cmt = match opt_def {\n             Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n-                if !self.tcx().enum_is_univariant(enum_did) => {\n+                if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                 }\n             _ => cmt"}, {"sha": "16f744b6887ab61051b6a68660b8b6ff6e7455da", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -415,32 +415,15 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(did, _) => {\n-                    tcx.lookup_struct_fields(did)\n-                        .iter()\n-                        .find(|f| f.name == field.node.name)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.span_bug(field.span,\n-                                              \"stability::check_expr: unknown named field access\")\n-                        })\n-                        .id\n-                }\n+                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node.name).did,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: named field access on non-struct\")\n             }\n         }\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(did, _) => {\n-                    tcx.lookup_struct_fields(did)\n-                        .get(field.node)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.span_bug(field.span,\n-                                              \"stability::check_expr: unknown unnamed field access\")\n-                        })\n-                        .id\n-                }\n+                ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n                 ty::TyTuple(..) => return,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: unnamed field access on \\\n@@ -450,20 +433,13 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprStruct(_, ref expr_fields, _) => {\n             let type_ = tcx.expr_ty(e);\n             match type_.sty {\n-                ty::TyStruct(did, _) => {\n-                    let struct_fields = tcx.lookup_struct_fields(did);\n+                ty::TyStruct(def, _) => {\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n-                        let did = struct_fields\n-                            .iter()\n-                            .find(|f| f.name == field.ident.node.name)\n-                            .unwrap_or_else(|| {\n-                                tcx.sess.span_bug(field.span,\n-                                                  \"stability::check_expr: unknown named \\\n-                                                   field access\")\n-                            })\n-                            .id;\n+                        let did = def.struct_variant()\n+                            .field_named(field.ident.node.name)\n+                            .did;\n                         maybe_do_stability_check(tcx, did, field.span, cb);\n                     }\n \n@@ -505,34 +481,26 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let did = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(did, _), .. }) => did,\n+    let v = match tcx.pat_ty_opt(pat) {\n+        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def.struct_variant(),\n         Some(_) | None => return,\n     };\n-    let struct_fields = tcx.lookup_struct_fields(did);\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {\n-            for (field, struct_field) in pat_fields.iter().zip(&struct_fields) {\n+            for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 // a .. pattern is fine, but anything positional is\n                 // not.\n                 if let ast::PatWild(ast::PatWildMulti) = field.node {\n                     continue\n                 }\n-                maybe_do_stability_check(tcx, struct_field.id, field.span, cb)\n+                maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }\n         ast::PatStruct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n-                let did = struct_fields\n-                    .iter()\n-                    .find(|f| f.name == field.node.ident.name)\n-                    .unwrap_or_else(|| {\n-                        tcx.sess.span_bug(field.span,\n-                                          \"stability::check_pat: unknown named field access\")\n-                    })\n-                    .id;\n+                let did = v.field_named(field.node.ident.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);\n             }\n         }"}, {"sha": "534a2fc054da7034c6ba0cd96fe710f27cc2d497", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -278,8 +278,8 @@ fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) =>\n-            tcx.has_attr(def_id, \"fundamental\"),\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n+            def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal_def_id(), \"fundamental\"),\n         _ =>\n@@ -316,9 +316,9 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n             infer_is_local.0\n         }\n \n-        ty::TyEnum(def_id, _) |\n-        ty::TyStruct(def_id, _) => {\n-            def_id.krate == ast::LOCAL_CRATE\n+        ty::TyEnum(def, _) |\n+        ty::TyStruct(def, _) => {\n+            def.did.krate == ast::LOCAL_CRATE\n         }\n \n         ty::TyBox(_) => { // Box<T>"}, {"sha": "0c9cf1a68b7320132a30ba1493491266ef848ee2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -1721,21 +1721,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ok_if(substs.upvar_tys.clone())\n             }\n \n-            ty::TyStruct(def_id, substs) => {\n-                let types: Vec<Ty> =\n-                    self.tcx().struct_fields(def_id, substs).iter()\n-                                                                 .map(|f| f.mt.ty)\n-                                                                 .collect();\n-                nominal(bound, types)\n-            }\n-\n-            ty::TyEnum(def_id, substs) => {\n-                let types: Vec<Ty> =\n-                    self.tcx().substd_enum_variants(def_id, substs)\n-                    .iter()\n-                    .flat_map(|variant| &variant.args)\n-                    .cloned()\n-                    .collect();\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                let types: Vec<Ty> = def.all_fields().map(|f| {\n+                    f.ty(self.tcx(), substs)\n+                }).collect();\n                 nominal(bound, types)\n             }\n \n@@ -1861,25 +1850,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n-            ty::TyStruct(def_id, substs)\n-                if Some(def_id) == self.tcx().lang_items.phantom_data() =>\n-            {\n+            ty::TyStruct(def, substs) if def.is_phantom_data() => {\n                 substs.types.get_slice(TypeSpace).to_vec()\n             }\n \n-            ty::TyStruct(def_id, substs) => {\n-                self.tcx().struct_fields(def_id, substs)\n-                          .iter()\n-                          .map(|f| f.mt.ty)\n-                          .collect()\n-            }\n-\n-            ty::TyEnum(def_id, substs) => {\n-                self.tcx().substd_enum_variants(def_id, substs)\n-                          .iter()\n-                          .flat_map(|variant| &variant.args)\n-                          .map(|&ty| ty)\n-                          .collect()\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                def.all_fields()\n+                    .map(|f| f.ty(self.tcx(), substs))\n+                    .collect()\n             }\n         }\n     }\n@@ -2523,10 +2501,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // Struct<T> -> Struct<U>.\n-            (&ty::TyStruct(def_id, substs_a), &ty::TyStruct(_, substs_b)) => {\n-                let fields = tcx.lookup_struct_fields(def_id).iter().map(|f| {\n-                    tcx.lookup_field_type_unsubstituted(def_id, f.id)\n-                }).collect::<Vec<_>>();\n+            (&ty::TyStruct(def, substs_a), &ty::TyStruct(_, substs_b)) => {\n+                let fields = def\n+                    .all_fields()\n+                    .map(|f| f.unsubst_ty())\n+                    .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n                 let field = if let Some(&field) = fields.last() {\n@@ -2572,7 +2551,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     let param_b = *substs_b.types.get(TypeSpace, i);\n                     new_substs.types.get_mut_slice(TypeSpace)[i] = param_b;\n                 }\n-                let new_struct = tcx.mk_struct(def_id, tcx.mk_substs(new_substs));\n+                let new_struct = tcx.mk_struct(def, tcx.mk_substs(new_substs));\n                 let origin = infer::Misc(obligation.cause.span);\n                 if self.infcx.sub_types(false, origin, new_struct, target).is_err() {\n                     return Err(Unimplemented);"}, {"sha": "2fe1f14d521ba3a7e881dbc36f8c9edfceba411d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 558, "deletions": 502, "changes": 1060, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -74,22 +74,24 @@ use std::cell::{Cell, RefCell, Ref};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n+use std::iter;\n+use std::marker::PhantomData;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n+use std::slice;\n use std::vec::IntoIter;\n use collections::enum_set::{self, EnumSet, CLike};\n+use core::nonzero::NonZero;\n use std::collections::{HashMap, HashSet};\n+use rustc_data_structures::ivar;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n-use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n-use syntax::ast::{StructField, UnnamedField, Visibility};\n+use syntax::ast::{MutImmutable, MutMutable, Name, NodeId, Visibility};\n use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n-use syntax::parse::token::{self, InternedString, special_idents};\n-use syntax::print::pprust;\n-use syntax::ptr::P;\n+use syntax::parse::token::{InternedString, special_idents};\n use syntax::ast;\n \n pub type Disr = u64;\n@@ -109,83 +111,6 @@ pub struct CrateAnalysis {\n     pub glob_map: Option<GlobMap>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Field<'tcx> {\n-    pub name: ast::Name,\n-    pub mt: TypeAndMut<'tcx>\n-}\n-\n-// Enum information\n-#[derive(Clone)]\n-pub struct VariantInfo<'tcx> {\n-    pub args: Vec<Ty<'tcx>>,\n-    pub arg_names: Option<Vec<ast::Name>>,\n-    pub ctor_ty: Option<Ty<'tcx>>,\n-    pub name: ast::Name,\n-    pub id: ast::DefId,\n-    pub disr_val: Disr,\n-    pub vis: Visibility\n-}\n-\n-impl<'tcx> VariantInfo<'tcx> {\n-\n-    /// Creates a new VariantInfo from the corresponding ast representation.\n-    ///\n-    /// Does not do any caching of the value in the type context.\n-    pub fn from_ast_variant(cx: &ctxt<'tcx>,\n-                            ast_variant: &ast::Variant,\n-                            discriminant: Disr) -> VariantInfo<'tcx> {\n-        let ctor_ty = cx.node_id_to_type(ast_variant.node.id);\n-\n-        match ast_variant.node.kind {\n-            ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if !args.is_empty() {\n-                    // the regions in the argument types come from the\n-                    // enum def'n, and hence will all be early bound\n-                    cx.no_late_bound_regions(&ctor_ty.fn_args()).unwrap()\n-                } else {\n-                    Vec::new()\n-                };\n-\n-                return VariantInfo {\n-                    args: arg_tys,\n-                    arg_names: None,\n-                    ctor_ty: Some(ctor_ty),\n-                    name: ast_variant.node.name.name,\n-                    id: ast_util::local_def(ast_variant.node.id),\n-                    disr_val: discriminant,\n-                    vis: ast_variant.node.vis\n-                };\n-            },\n-            ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = &struct_def.fields;\n-\n-                assert!(!fields.is_empty());\n-\n-                let arg_tys = struct_def.fields.iter()\n-                    .map(|field| cx.node_id_to_type(field.node.id)).collect();\n-                let arg_names = fields.iter().map(|field| {\n-                    match field.node.kind {\n-                        NamedField(ident, _) => ident.name,\n-                        UnnamedField(..) => cx.sess.bug(\n-                            \"enum_variants: all fields in struct must have a name\")\n-                    }\n-                }).collect();\n-\n-                return VariantInfo {\n-                    args: arg_tys,\n-                    arg_names: Some(arg_names),\n-                    ctor_ty: None,\n-                    name: ast_variant.node.name.name,\n-                    id: ast_util::local_def(ast_variant.node.id),\n-                    disr_val: discriminant,\n-                    vis: ast_variant.node.vis\n-                };\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,\n@@ -208,7 +133,7 @@ impl DtorKind {\n     }\n }\n \n-trait IntTypeExt {\n+pub trait IntTypeExt {\n     fn to_ty<'tcx>(&self, cx: &ctxt<'tcx>) -> Ty<'tcx>;\n     fn i64_to_disr(&self, val: i64) -> Option<Disr>;\n     fn u64_to_disr(&self, val: u64) -> Option<Disr>;\n@@ -492,14 +417,6 @@ pub struct TypeAndMut<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct FieldTy {\n-    pub name: Name,\n-    pub id: DefId,\n-    pub vis: ast::Visibility,\n-    pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -721,6 +638,7 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     trait_defs: TypedArena<TraitDef<'tcx>>,\n+    adt_defs: TypedArena<AdtDefData<'tcx, 'tcx>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -732,7 +650,8 @@ impl<'tcx> CtxtArenas<'tcx> {\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n \n-            trait_defs: TypedArena::new()\n+            trait_defs: TypedArena::new(),\n+            adt_defs: TypedArena::new()\n         }\n     }\n }\n@@ -847,6 +766,7 @@ pub struct ctxt<'tcx> {\n \n     pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<AdtDefMaster<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -866,13 +786,11 @@ pub struct ctxt<'tcx> {\n     pub rcache: RefCell<FnvHashMap<CReaderCacheKey, Ty<'tcx>>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n-    pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub struct_fields: RefCell<DefIdMap<Rc<Vec<FieldTy>>>>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n@@ -1017,6 +935,18 @@ impl<'tcx> ctxt<'tcx> {\n         interned\n     }\n \n+    pub fn intern_adt_def(&self,\n+                          did: DefId,\n+                          kind: AdtKind,\n+                          variants: Vec<VariantDefData<'tcx, 'tcx>>)\n+                          -> AdtDefMaster<'tcx> {\n+        let def = AdtDefData::new(self, did, kind, variants);\n+        let interned = self.arenas.adt_defs.alloc(def);\n+        // this will need a transmute when reverse-variance is removed\n+        self.adt_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n     pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n@@ -1385,6 +1315,61 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n+/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n+/// on the lifetime of the IVar. This is required because of variance\n+/// problems: the IVar needs to be variant with respect to 'tcx (so\n+/// it can be referred to from Ty) but can only be modified if its\n+/// lifetime is exactly 'tcx.\n+///\n+/// Safety invariants:\n+///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n+///     (B) no aliases to this value with a 'tcx longer than this\n+///         value's 'lt exist\n+///\n+/// NonZero is used rather than Unique because Unique isn't Copy.\n+pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n+                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n+\n+impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        // Invariant (A) satisfied because the IVar is unfulfilled\n+        // Invariant (B) because 'lt : 'tcx\n+        TyIVar(ivar::Ivar::new(), PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> Option<Ty<'tcx>> {\n+        match self.0.get() {\n+            None => None,\n+            // valid because of invariant (A)\n+            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n+        }\n+    }\n+    #[inline]\n+    pub fn unwrap(&self) -> Ty<'tcx> {\n+        self.get().unwrap()\n+    }\n+\n+    pub fn fulfill(&self, value: Ty<'lt>) {\n+        // Invariant (A) is fulfilled, because by (B), every alias\n+        // of this has a 'tcx longer than 'lt.\n+        let value: *const TyS<'lt> = value;\n+        // FIXME(27214): unneeded [as *const ()]\n+        let value = value as *const () as *const TyS<'static>;\n+        self.0.fulfill(unsafe { NonZero::new(value) })\n+    }\n+}\n+\n+impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            Some(val) => write!(f, \"TyIVar({:?})\", val),\n+            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n+        }\n+    }\n+}\n+\n /// An entry in the type interner.\n pub struct InternedTy<'tcx> {\n     ty: Ty<'tcx>\n@@ -1761,12 +1746,12 @@ pub enum TypeVariants<'tcx> {\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n     /// well.\n-    TyEnum(DefId, &'tcx Substs<'tcx>),\n+    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// A structure type, defined with `struct`.\n     ///\n     /// See warning about substitutions for enumerated types.\n-    TyStruct(DefId, &'tcx Substs<'tcx>),\n+    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -2121,7 +2106,7 @@ pub struct ExistentialBounds<'tcx> {\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n impl BuiltinBounds {\n-       pub fn empty() -> BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n         BuiltinBounds(EnumSet::new())\n     }\n \n@@ -2984,33 +2969,31 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         // FIXME: (@jroesch) float this code up\n         let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n \n-        let did = match self_type.sty {\n-            ty::TyStruct(struct_did, substs) => {\n-                let fields = tcx.struct_fields(struct_did, substs);\n-                for field in &fields {\n-                    if infcx.type_moves_by_default(field.mt.ty, span) {\n+        let adt = match self_type.sty {\n+            ty::TyStruct(struct_def, substs) => {\n+                for field in struct_def.all_fields() {\n+                    let field_ty = field.ty(tcx, substs);\n+                    if infcx.type_moves_by_default(field_ty, span) {\n                         return Err(FieldDoesNotImplementCopy(field.name))\n                     }\n                 }\n-                struct_did\n-            }\n-            ty::TyEnum(enum_did, substs) => {\n-                let enum_variants = tcx.enum_variants(enum_did);\n-                for variant in enum_variants.iter() {\n-                    for variant_arg_type in &variant.args {\n-                        let substd_arg_type =\n-                            variant_arg_type.subst(tcx, substs);\n-                        if infcx.type_moves_by_default(substd_arg_type, span) {\n+                struct_def\n+            }\n+            ty::TyEnum(enum_def, substs) => {\n+                for variant in &enum_def.variants {\n+                    for field in &variant.fields {\n+                        let field_ty = field.ty(tcx, substs);\n+                        if infcx.type_moves_by_default(field_ty, span) {\n                             return Err(VariantDoesNotImplementCopy(variant.name))\n                         }\n                     }\n                 }\n-                enum_did\n+                enum_def\n             }\n             _ => return Err(TypeIsStructural),\n         };\n \n-        if tcx.has_dtor(did) {\n+        if adt.has_dtor(tcx) {\n             return Err(TypeHasDestructor)\n         }\n \n@@ -3193,6 +3176,286 @@ impl<'tcx> TraitDef<'tcx> {\n \n }\n \n+bitflags! {\n+    flags AdtFlags: u32 {\n+        const NO_ADT_FLAGS        = 0,\n+        const IS_ENUM             = 1 << 0,\n+        const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n+        const IS_DTORCK_VALID     = 1 << 2,\n+        const IS_PHANTOM_DATA     = 1 << 3,\n+        const IS_SIMD             = 1 << 4,\n+        const IS_FUNDAMENTAL      = 1 << 5,\n+    }\n+}\n+\n+pub type AdtDef<'tcx> = &'tcx AdtDefData<'tcx, 'static>;\n+pub type VariantDef<'tcx> = &'tcx VariantDefData<'tcx, 'static>;\n+pub type FieldDef<'tcx> = &'tcx FieldDefData<'tcx, 'static>;\n+\n+// See comment on AdtDefData for explanation\n+pub type AdtDefMaster<'tcx> = &'tcx AdtDefData<'tcx, 'tcx>;\n+pub type VariantDefMaster<'tcx> = &'tcx VariantDefData<'tcx, 'tcx>;\n+pub type FieldDefMaster<'tcx> = &'tcx FieldDefData<'tcx, 'tcx>;\n+\n+pub struct VariantDefData<'tcx, 'container: 'tcx> {\n+    pub did: DefId,\n+    pub name: Name, // struct's name if this is a struct\n+    pub disr_val: Disr,\n+    pub fields: Vec<FieldDefData<'tcx, 'container>>\n+}\n+\n+pub struct FieldDefData<'tcx, 'container: 'tcx> {\n+    /// The field's DefId. NOTE: the fields of tuple-like enum variants\n+    /// are not real items, and don't have entries in tcache etc.\n+    pub did: DefId,\n+    /// special_idents::unnamed_field.name\n+    /// if this is a tuple-like field\n+    pub name: Name,\n+    pub vis: ast::Visibility,\n+    /// TyIVar is used here to allow for variance (see the doc at\n+    /// AdtDefData).\n+    ty: TyIVar<'tcx, 'container>\n+}\n+\n+/// The definition of an abstract data type - a struct or enum.\n+///\n+/// These are all interned (by intern_adt_def) into the adt_defs\n+/// table.\n+///\n+/// Because of the possibility of nested tcx-s, this type\n+/// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n+/// bounding the lifetime of the inner types is of course necessary.\n+/// However, it is not sufficient - types from a child tcx must\n+/// not be leaked into the master tcx by being stored in an AdtDefData.\n+///\n+/// The 'container lifetime ensures that by outliving the container\n+/// tcx and preventing shorter-lived types from being inserted. When\n+/// write access is not needed, the 'container lifetime can be\n+/// erased to 'static, which can be done by the AdtDef wrapper.\n+pub struct AdtDefData<'tcx, 'container: 'tcx> {\n+    pub did: DefId,\n+    pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    flags: Cell<AdtFlags>,\n+}\n+\n+impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n+    // AdtDefData are always interned and this is part of TyS equality\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n+}\n+\n+impl<'tcx, 'container> Eq for AdtDefData<'tcx, 'container> {}\n+\n+impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const AdtDefData).hash(s)\n+    }\n+}\n+\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum AdtKind { Struct, Enum }\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum VariantKind { Dict, Tuple, Unit }\n+\n+impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n+    fn new(tcx: &ctxt<'tcx>,\n+           did: DefId,\n+           kind: AdtKind,\n+           variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n+        let mut flags = AdtFlags::NO_ADT_FLAGS;\n+        let attrs = tcx.get_attrs(did);\n+        if attrs.iter().any(|item| item.check_name(\"fundamental\")) {\n+            flags = flags | AdtFlags::IS_FUNDAMENTAL;\n+        }\n+        if attrs.iter().any(|item| item.check_name(\"simd\")) {\n+            flags = flags | AdtFlags::IS_SIMD;\n+        }\n+        if Some(did) == tcx.lang_items.phantom_data() {\n+            flags = flags | AdtFlags::IS_PHANTOM_DATA;\n+        }\n+        if let AdtKind::Enum = kind {\n+            flags = flags | AdtFlags::IS_ENUM;\n+        }\n+        AdtDefData {\n+            did: did,\n+            variants: variants,\n+            flags: Cell::new(flags),\n+        }\n+    }\n+\n+    fn calculate_dtorck(&'tcx self, tcx: &ctxt<'tcx>) {\n+        if tcx.is_adt_dtorck(self) {\n+            self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n+        }\n+        self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n+    }\n+\n+    /// Returns the kind of the ADT - Struct or Enum.\n+    #[inline]\n+    pub fn adt_kind(&self) -> AdtKind {\n+        if self.flags.get().intersects(AdtFlags::IS_ENUM) {\n+            AdtKind::Enum\n+        } else {\n+            AdtKind::Struct\n+        }\n+    }\n+\n+    /// Returns whether this is a dtorck type. If this returns\n+    /// true, this type being safe for destruction requires it to be\n+    /// alive; Otherwise, only the contents are required to be.\n+    #[inline]\n+    pub fn is_dtorck(&'tcx self, tcx: &ctxt<'tcx>) -> bool {\n+        if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n+            self.calculate_dtorck(tcx)\n+        }\n+        self.flags.get().intersects(AdtFlags::IS_DTORCK)\n+    }\n+\n+    /// Returns whether this type is #[fundamental] for the purposes\n+    /// of coherence checking.\n+    #[inline]\n+    pub fn is_fundamental(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_FUNDAMENTAL)\n+    }\n+\n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_SIMD)\n+    }\n+\n+    /// Returns true if this is PhantomData<T>.\n+    #[inline]\n+    pub fn is_phantom_data(&self) -> bool {\n+        self.flags.get().intersects(AdtFlags::IS_PHANTOM_DATA)\n+    }\n+\n+    /// Returns whether this type has a destructor.\n+    pub fn has_dtor(&self, tcx: &ctxt<'tcx>) -> bool {\n+        tcx.destructor_for_type.borrow().contains_key(&self.did)\n+    }\n+\n+    /// Asserts this is a struct and returns the struct's unique\n+    /// variant.\n+    pub fn struct_variant(&self) -> &VariantDefData<'tcx, 'container> {\n+        assert!(self.adt_kind() == AdtKind::Struct);\n+        &self.variants[0]\n+    }\n+\n+    #[inline]\n+    pub fn type_scheme(&self, tcx: &ctxt<'tcx>) -> TypeScheme<'tcx> {\n+        tcx.lookup_item_type(self.did)\n+    }\n+\n+    #[inline]\n+    pub fn predicates(&self, tcx: &ctxt<'tcx>) -> GenericPredicates<'tcx> {\n+        tcx.lookup_predicates(self.did)\n+    }\n+\n+    /// Returns an iterator over all fields contained\n+    /// by this ADT.\n+    #[inline]\n+    pub fn all_fields(&self) ->\n+            iter::FlatMap<\n+                slice::Iter<VariantDefData<'tcx, 'container>>,\n+                slice::Iter<FieldDefData<'tcx, 'container>>,\n+                for<'s> fn(&'s VariantDefData<'tcx, 'container>)\n+                    -> slice::Iter<'s, FieldDefData<'tcx, 'container>>\n+            > {\n+        self.variants.iter().flat_map(VariantDefData::fields_iter)\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.variants.is_empty()\n+    }\n+\n+    #[inline]\n+    pub fn is_univariant(&self) -> bool {\n+        self.variants.len() == 1\n+    }\n+\n+    pub fn is_payloadfree(&self) -> bool {\n+        !self.variants.is_empty() &&\n+            self.variants.iter().all(|v| v.fields.is_empty())\n+    }\n+\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'tcx, 'container> {\n+        self.variants\n+            .iter()\n+            .find(|v| v.did == vid)\n+            .expect(\"variant_with_id: unknown variant\")\n+    }\n+\n+    pub fn variant_of_def(&self, def: def::Def) -> &VariantDefData<'tcx, 'container> {\n+        match def {\n+            def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n+            def::DefStruct(..) | def::DefTy(..) => self.struct_variant(),\n+            _ => panic!(\"unexpected def {:?} in variant_of_def\", def)\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n+    #[inline]\n+    fn fields_iter(&self) -> slice::Iter<FieldDefData<'tcx, 'container>> {\n+        self.fields.iter()\n+    }\n+\n+    pub fn kind(&self) -> VariantKind {\n+        match self.fields.get(0) {\n+            None => VariantKind::Unit,\n+            Some(&FieldDefData { name, .. }) if name == special_idents::unnamed_field.name => {\n+                VariantKind::Tuple\n+            }\n+            Some(_) => VariantKind::Dict\n+        }\n+    }\n+\n+    pub fn is_tuple_struct(&self) -> bool {\n+        self.kind() == VariantKind::Tuple\n+    }\n+\n+    #[inline]\n+    pub fn find_field_named(&self,\n+                            name: ast::Name)\n+                            -> Option<&FieldDefData<'tcx, 'container>> {\n+        self.fields.iter().find(|f| f.name == name)\n+    }\n+\n+    #[inline]\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n+        self.find_field_named(name).unwrap()\n+    }\n+}\n+\n+impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n+    pub fn new(did: DefId,\n+               name: Name,\n+               vis: ast::Visibility) -> Self {\n+        FieldDefData {\n+            did: did,\n+            name: name,\n+            vis: vis,\n+            ty: TyIVar::new()\n+        }\n+    }\n+\n+    pub fn ty(&self, tcx: &ctxt<'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+        self.unsubst_ty().subst(tcx, subst)\n+    }\n+\n+    pub fn unsubst_ty(&self) -> Ty<'tcx> {\n+        self.ty.unwrap()\n+    }\n+\n+    pub fn fulfill_ty(&self, ty: Ty<'container>) {\n+        self.ty.fulfill(ty);\n+    }\n+}\n+\n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n #[derive(Clone)]\n@@ -3498,6 +3761,7 @@ impl<'tcx> ctxt<'tcx> {\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DefIdMap()),\n             trait_defs: RefCell::new(DefIdMap()),\n+            adt_defs: RefCell::new(DefIdMap()),\n             predicates: RefCell::new(DefIdMap()),\n             super_predicates: RefCell::new(DefIdMap()),\n             fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n@@ -3507,15 +3771,13 @@ impl<'tcx> ctxt<'tcx> {\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-            enum_var_cache: RefCell::new(DefIdMap()),\n             impl_or_trait_items: RefCell::new(DefIdMap()),\n             trait_item_def_ids: RefCell::new(DefIdMap()),\n             trait_items_cache: RefCell::new(DefIdMap()),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n             provided_method_sources: RefCell::new(DefIdMap()),\n-            struct_fields: RefCell::new(DefIdMap()),\n             destructor_for_type: RefCell::new(DefIdMap()),\n             destructors: RefCell::new(DefIdSet()),\n             inherent_impls: RefCell::new(DefIdMap()),\n@@ -3679,9 +3941,9 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(&self, did: ast::DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyEnum(did, substs))\n+        self.mk_ty(TyEnum(def, substs))\n     }\n \n     pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -3781,10 +4043,9 @@ impl<'tcx> ctxt<'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(&self, struct_id: ast::DefId,\n-                     substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n-        self.mk_ty(TyStruct(struct_id, substs))\n+        self.mk_ty(TyStruct(def, substs))\n     }\n \n     pub fn mk_closure(&self,\n@@ -3944,9 +4205,10 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, cx: &ctxt) -> bool {\n+    pub fn is_empty(&self, _cx: &ctxt) -> bool {\n+        // FIXME(#24885): be smarter here\n         match self.sty {\n-            TyEnum(did, _) => cx.enum_variants(did).is_empty(),\n+            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n             _ => false\n         }\n     }\n@@ -3985,9 +4247,10 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_simd(&self, cx: &ctxt) -> bool {\n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyStruct(did, _) => cx.lookup_simd(did),\n+            TyStruct(def, _) => def.is_simd(),\n             _ => false\n         }\n     }\n@@ -4003,19 +4266,16 @@ impl<'tcx> TyS<'tcx> {\n \n     pub fn simd_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n-            TyStruct(did, substs) => {\n-                let fields = cx.lookup_struct_fields(did);\n-                cx.lookup_field_type(did, fields[0].id, substs)\n+            TyStruct(def, substs) => {\n+                def.struct_variant().fields[0].ty(cx, substs)\n             }\n             _ => panic!(\"simd_type called on invalid type\")\n         }\n     }\n \n-    pub fn simd_size(&self, cx: &ctxt) -> usize {\n+    pub fn simd_size(&self, _cx: &ctxt) -> usize {\n         match self.sty {\n-            TyStruct(did, _) => {\n-                cx.lookup_struct_fields(did).len()\n-            }\n+            TyStruct(def, _) => def.struct_variant().fields.len(),\n             _ => panic!(\"simd_size called on invalid type\")\n         }\n     }\n@@ -4067,12 +4327,19 @@ impl<'tcx> TyS<'tcx> {\n     pub fn ty_to_def_id(&self) -> Option<ast::DefId> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal_def_id()),\n-            TyStruct(id, _) |\n-            TyEnum(id, _) |\n+            TyStruct(def, _) |\n+            TyEnum(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n         }\n     }\n+\n+    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+        match self.sty {\n+            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            _ => None\n+        }\n+    }\n }\n \n /// Type contents is how the type checker reasons about kinds.\n@@ -4275,18 +4542,6 @@ impl<'tcx> TyS<'tcx> {\n                 }\n                 TyStr => TC::None,\n \n-                TyStruct(did, substs) => {\n-                    let flds = cx.struct_fields(did, substs);\n-                    let mut res =\n-                        TypeContents::union(&flds[..],\n-                                            |f| tc_ty(cx, f.mt.ty, cache));\n-\n-                    if cx.has_dtor(did) {\n-                        res = res | TC::OwnsDtor;\n-                    }\n-                    apply_lang_items(cx, did, res)\n-                }\n-\n                 TyClosure(_, ref substs) => {\n                     TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n                 }\n@@ -4296,21 +4551,19 @@ impl<'tcx> TyS<'tcx> {\n                                         |ty| tc_ty(cx, *ty, cache))\n                 }\n \n-                TyEnum(did, substs) => {\n-                    let variants = cx.substd_enum_variants(did, substs);\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n                     let mut res =\n-                        TypeContents::union(&variants[..], |variant| {\n-                            TypeContents::union(&variant.args,\n-                                                |arg_ty| {\n-                                tc_ty(cx, *arg_ty, cache)\n+                        TypeContents::union(&def.variants, |v| {\n+                            TypeContents::union(&v.fields, |f| {\n+                                tc_ty(cx, f.ty(cx, substs), cache)\n                             })\n                         });\n \n-                    if cx.has_dtor(did) {\n+                    if def.has_dtor(cx) {\n                         res = res | TC::OwnsDtor;\n                     }\n \n-                    apply_lang_items(cx, did, res)\n+                    apply_lang_items(cx, def.did, res)\n                 }\n \n                 TyProjection(..) |\n@@ -4431,7 +4684,7 @@ impl<'tcx> TyS<'tcx> {\n \n     // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n     pub fn is_instantiable(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n-        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n                                r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"type_requires({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4443,7 +4696,7 @@ impl<'tcx> TyS<'tcx> {\n             return r;\n         }\n \n-        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n                                   r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n             debug!(\"subtypes_require({:?}, {:?})?\",\n                    r_ty, ty);\n@@ -4482,16 +4735,22 @@ impl<'tcx> TyS<'tcx> {\n                     false\n                 }\n \n-                TyStruct(ref did, _) if seen.contains(did) => {\n-                    false\n-                }\n-\n-                TyStruct(did, substs) => {\n-                    seen.push(did);\n-                    let fields = cx.struct_fields(did, substs);\n-                    let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n-                    seen.pop().unwrap();\n-                    r\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    if seen.contains(&def) {\n+                        // FIXME(#27497) ???\n+                        false\n+                    } else if def.is_empty() {\n+                        // HACK: required for empty types to work. This\n+                        // check is basically a lint anyway.\n+                        false\n+                    } else {\n+                        seen.push(def);\n+                        let r = def.variants.iter().all(|v| v.fields.iter().any(|f| {\n+                            type_requires(cx, seen, r_ty, f.ty(cx, substs))\n+                        }));\n+                        seen.pop().unwrap();\n+                        r\n+                    }\n                 }\n \n                 TyError |\n@@ -4505,23 +4764,6 @@ impl<'tcx> TyS<'tcx> {\n                 TyTuple(ref ts) => {\n                     ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n                 }\n-\n-                TyEnum(ref did, _) if seen.contains(did) => {\n-                    false\n-                }\n-\n-                TyEnum(did, substs) => {\n-                    seen.push(did);\n-                    let vs = cx.enum_variants(did);\n-                    let r = !vs.is_empty() && vs.iter().all(|variant| {\n-                        variant.args.iter().any(|aty| {\n-                            let sty = aty.subst(cx, substs);\n-                            type_requires(cx, seen, r_ty, sty)\n-                        })\n-                    });\n-                    seen.pop().unwrap();\n-                    r\n-                }\n             };\n \n             debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n@@ -4576,17 +4818,11 @@ impl<'tcx> TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(cx, sp, seen, ty)\n                 }\n-                TyStruct(did, substs) => {\n-                    let fields = cx.struct_fields(did, substs);\n-                    find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n-                }\n-                TyEnum(did, substs) => {\n-                    let vs = cx.enum_variants(did);\n-                    let iter = vs.iter()\n-                        .flat_map(|variant| &variant.args)\n-                        .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n-\n-                    find_nonrepresentable(cx, sp, seen, iter)\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    find_nonrepresentable(cx,\n+                                          sp,\n+                                          seen,\n+                                          def.all_fields().map(|f| f.ty(cx, substs)))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -4597,10 +4833,10 @@ impl<'tcx> TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum_def_id(ty: Ty, did: DefId) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: AdtDef<'tcx>) -> bool {\n             match ty.sty {\n-                TyStruct(ty_did, _) | TyEnum(ty_did, _) => {\n-                     ty_did == did\n+                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                     ty_def == def\n                 }\n                 _ => false\n             }\n@@ -4635,7 +4871,7 @@ impl<'tcx> TyS<'tcx> {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n-                TyStruct(did, _) | TyEnum(did, _) => {\n+                TyStruct(def, _) | TyEnum(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();\n@@ -4650,7 +4886,7 @@ impl<'tcx> TyS<'tcx> {\n \n                         match iter.next() {\n                             Some(&seen_type) => {\n-                                if same_struct_or_enum_def_id(seen_type, did) {\n+                                if same_struct_or_enum(seen_type, def) {\n                                     debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                            seen_type,\n                                            ty);\n@@ -4782,22 +5018,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Whether a type is enum like, that is an enum type with only nullary\n-    // constructors\n-    pub fn is_c_like_enum(&self, cx: &ctxt) -> bool {\n-        match self.sty {\n-            TyEnum(did, _) => {\n-                let variants = cx.enum_variants(did);\n-                if variants.is_empty() {\n-                    false\n-                } else {\n-                    variants.iter().all(|v| v.args.is_empty())\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     // Returns the type and mutability of *ty.\n     //\n     // The parameter `explicit` indicates if this is an *explicit* dereference.\n@@ -4959,7 +5179,7 @@ impl<'tcx> TyS<'tcx> {\n             TyUint(_) | TyFloat(_) | TyStr => self.to_string(),\n             TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            TyEnum(id, _) => format!(\"enum `{}`\", cx.item_path_str(id)),\n+            TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n             TyBox(_) => \"box\".to_string(),\n             TyArray(_, n) => format!(\"array of {} elements\", n),\n             TySlice(_) => \"slice\".to_string(),\n@@ -4970,8 +5190,8 @@ impl<'tcx> TyS<'tcx> {\n             TyTrait(ref inner) => {\n                 format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n             }\n-            TyStruct(id, _) => {\n-                format!(\"struct `{}`\", cx.item_path_str(id))\n+            TyStruct(def, _) => {\n+                format!(\"struct `{}`\", cx.item_path_str(def.did))\n             }\n             TyClosure(..) => \"closure\".to_string(),\n             TyTuple(_) => \"tuple\".to_string(),\n@@ -5196,27 +5416,18 @@ impl<'tcx> ctxt<'tcx> {\n                                  ty: Ty<'tcx>,\n                                  i: usize,\n                                  variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n-\n         match (&ty.sty, variant) {\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n-\n-\n-            (&TyStruct(def_id, substs), None) => self.lookup_struct_fields(def_id)\n-                .get(i)\n-                .map(|&t| self.lookup_item_type(t.id).ty.subst(self, substs)),\n-\n-            (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def_id, variant_def_id);\n-                variant_info.args.get(i).map(|t|t.subst(self, substs))\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n             }\n-\n-            (&TyEnum(def_id, substs), None) => {\n-                assert!(self.enum_is_univariant(def_id));\n-                let enum_variants = self.enum_variants(def_id);\n-                let variant_info = &enum_variants[0];\n-                variant_info.args.get(i).map(|t|t.subst(self, substs))\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n             }\n-\n+            (&TyEnum(def, substs), None) => {\n+                assert!(def.is_univariant());\n+                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyTuple(ref v), None) => v.get(i).cloned(),\n             _ => None\n         }\n     }\n@@ -5227,22 +5438,14 @@ impl<'tcx> ctxt<'tcx> {\n                             ty: Ty<'tcx>,\n                             n: ast::Name,\n                             variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n-\n         match (&ty.sty, variant) {\n-            (&TyStruct(def_id, substs), None) => {\n-                let r = self.lookup_struct_fields(def_id);\n-                r.iter().find(|f| f.name == n)\n-                    .map(|&f| self.lookup_field_type(def_id, f.id, substs))\n-            }\n-            (&TyEnum(def_id, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def_id, variant_def_id);\n-                variant_info.arg_names.as_ref()\n-                    .expect(\"must have struct enum variant if accessing a named fields\")\n-                    .iter().zip(&variant_info.args)\n-                    .find(|&(&name, _)| name == n)\n-                    .map(|(_name, arg_t)| arg_t.subst(self, substs))\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n             }\n-            _ => None\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            _ => return None\n         }\n     }\n \n@@ -5423,18 +5626,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn field_idx_strict(&self, name: ast::Name, fields: &[Field<'tcx>])\n-                            -> usize {\n-        let mut i = 0;\n-        for f in fields { if f.name == name { return i; } i += 1; }\n-        self.sess.bug(&format!(\n-            \"no field named `{}` found in the list of fields `{:?}`\",\n-            name,\n-            fields.iter()\n-                  .map(|f| f.name.to_string())\n-                  .collect::<Vec<String>>()));\n-    }\n-\n     pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n         use self::TypeError::*;\n \n@@ -5710,24 +5901,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn substd_enum_variants(&self,\n-                                id: ast::DefId,\n-                                substs: &Substs<'tcx>)\n-                                -> Vec<Rc<VariantInfo<'tcx>>> {\n-        self.enum_variants(id).iter().map(|variant_info| {\n-            let substd_args = variant_info.args.iter()\n-                .map(|aty| aty.subst(self, substs)).collect::<Vec<_>>();\n-\n-            let substd_ctor_ty = variant_info.ctor_ty.subst(self, substs);\n-\n-            Rc::new(VariantInfo {\n-                args: substd_args,\n-                ctor_ty: substd_ctor_ty,\n-                ..(**variant_info).clone()\n-            })\n-        }).collect()\n-    }\n-\n     pub fn item_path_str(&self, id: ast::DefId) -> String {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n@@ -5744,10 +5917,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn has_dtor(&self, struct_id: DefId) -> bool {\n-        self.destructor_for_type.borrow().contains_key(&struct_id)\n-    }\n-\n     pub fn with_path<T, F>(&self, id: ast::DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n@@ -5758,10 +5927,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn enum_is_univariant(&self, id: ast::DefId) -> bool {\n-        self.enum_variants(id).len() == 1\n-    }\n-\n     /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n     /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n     /// and `ty` is the original type (i.e. may include `isize` or\n@@ -5790,133 +5955,6 @@ impl<'tcx> ctxt<'tcx> {\n         (repr_type, repr_type_ty)\n     }\n \n-    fn report_discrim_overflow(&self,\n-                               variant_span: Span,\n-                               variant_name: &str,\n-                               repr_type: attr::IntType,\n-                               prev_val: Disr) {\n-        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n-        let computed_value = repr_type.disr_string(computed_value);\n-        let prev_val = repr_type.disr_string(prev_val);\n-        let repr_type = repr_type.to_ty(self);\n-        span_err!(self.sess, variant_span, E0370,\n-                  \"enum discriminant overflowed on value after {}: {}; \\\n-                   set explicitly via {} = {} if that is desired outcome\",\n-                  prev_val, repr_type, variant_name, computed_value);\n-    }\n-\n-    // This computes the discriminant values for the sequence of Variants\n-    // attached to a particular enum, taking into account the #[repr] (if\n-    // any) provided via the `opt_hint`.\n-    fn compute_enum_variants(&self,\n-                             vs: &'tcx [P<ast::Variant>],\n-                             opt_hint: Option<&attr::ReprAttr>)\n-                             -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n-        let mut prev_disr_val: Option<ty::Disr> = None;\n-\n-        let (repr_type, repr_type_ty) = self.enum_repr_type(opt_hint);\n-\n-        for v in vs {\n-            // If the discriminant value is specified explicitly in the\n-            // enum, check whether the initialization expression is valid,\n-            // otherwise use the last value plus one.\n-            let current_disr_val;\n-\n-            // This closure marks cases where, when an error occurs during\n-            // the computation, attempt to assign a (hopefully) fresh\n-            // value to avoid spurious error reports downstream.\n-            let attempt_fresh_value = move || -> Disr {\n-                repr_type.disr_wrap_incr(prev_disr_val)\n-            };\n-\n-            match v.node.disr_expr {\n-                Some(ref e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n-\n-                    let hint = UncheckedExprHint(repr_type_ty);\n-                    match const_eval::eval_const_expr_partial(self, &**e, hint) {\n-                        Ok(ConstVal::Int(val)) => current_disr_val = val as Disr,\n-                        Ok(ConstVal::Uint(val)) => current_disr_val = val as Disr,\n-                        Ok(_) => {\n-                            let sign_desc = if repr_type.is_signed() {\n-                                \"signed\"\n-                            } else {\n-                                \"unsigned\"\n-                            };\n-                            span_err!(self.sess, e.span, E0079,\n-                                      \"expected {} integer constant\",\n-                                      sign_desc);\n-                            current_disr_val = attempt_fresh_value();\n-                        },\n-                        Err(ref err) => {\n-                            span_err!(self.sess, err.span, E0080,\n-                                      \"constant evaluation error: {}\",\n-                                      err.description());\n-                            current_disr_val = attempt_fresh_value();\n-                        },\n-                    }\n-                },\n-                None => {\n-                    current_disr_val = match prev_disr_val {\n-                        Some(prev_disr_val) => {\n-                            if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n-                                v\n-                            } else {\n-                                self.report_discrim_overflow(v.span, &v.node.name.name.as_str(),\n-                                                             repr_type, prev_disr_val);\n-                                attempt_fresh_value()\n-                            }\n-                        }\n-                        None => ty::INITIAL_DISCRIMINANT_VALUE,\n-                    }\n-                },\n-            }\n-\n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(self, &**v, current_disr_val));\n-            prev_disr_val = Some(current_disr_val);\n-\n-            variants.push(variant_info);\n-        }\n-\n-        variants\n-    }\n-\n-    pub fn enum_variants(&self, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n-        memoized(&self.enum_var_cache, id, |id: ast::DefId| {\n-            if ast::LOCAL_CRATE != id.krate {\n-                Rc::new(csearch::get_enum_variants(self, id))\n-            } else {\n-                match self.map.get(id.node) {\n-                    ast_map::NodeItem(ref item) => {\n-                        match item.node {\n-                            ast::ItemEnum(ref enum_definition, _) => {\n-                                Rc::new(self.compute_enum_variants(\n-                                    &enum_definition.variants,\n-                                    self.lookup_repr_hints(id).get(0)))\n-                            }\n-                            _ => {\n-                                self.sess.bug(\"enum_variants: id not bound to an enum\")\n-                            }\n-                        }\n-                    }\n-                    _ => self.sess.bug(\"enum_variants: id not bound to an enum\")\n-                }\n-            }\n-        })\n-    }\n-\n-    // Returns information about the enum variant with the given ID:\n-    pub fn enum_variant_with_id(&self,\n-                                enum_id: ast::DefId,\n-                                variant_id: ast::DefId)\n-                                -> Rc<VariantInfo<'tcx>> {\n-        self.enum_variants(enum_id).iter()\n-                                   .find(|variant| variant.id == variant_id)\n-                                   .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n-                                   .clone()\n-    }\n-\n     // Register a given item type\n     pub fn register_item_type(&self, did: ast::DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n@@ -5938,6 +5976,23 @@ impl<'tcx> ctxt<'tcx> {\n         )\n     }\n \n+    /// Given the did of an ADT, return a master reference to its\n+    /// definition. Unless you are planning on fulfilling the ADT's fields,\n+    /// use lookup_adt_def instead.\n+    pub fn lookup_adt_def_master(&self, did: ast::DefId) -> AdtDefMaster<'tcx> {\n+        lookup_locally_or_in_crate_store(\n+            \"adt_defs\", did, &self.adt_defs,\n+            || csearch::get_adt_def(self, did)\n+        )\n+    }\n+\n+    /// Given the did of an ADT, return a reference to its definition.\n+    pub fn lookup_adt_def(&self, did: ast::DefId) -> AdtDef<'tcx> {\n+        // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n+        // woud be needed here.\n+        self.lookup_adt_def_master(did)\n+    }\n+\n     /// Given the did of an item, returns its full set of predicates.\n     pub fn lookup_predicates(&self, did: ast::DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n@@ -5989,75 +6044,13 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n-    // Look up a field ID, whether or not it's local\n-    pub fn lookup_field_type_unsubstituted(&self,\n-                                           struct_id: DefId,\n-                                           id: DefId)\n-                                           -> Ty<'tcx> {\n-        if id.krate == ast::LOCAL_CRATE {\n-            self.node_id_to_type(id.node)\n-        } else {\n-            memoized(&self.tcache, id,\n-                     |id| csearch::get_field_type(self, struct_id, id)).ty\n-        }\n-    }\n-\n-\n-    // Look up a field ID, whether or not it's local\n-    // Takes a list of type substs in case the struct is generic\n-    pub fn lookup_field_type(&self,\n-                             struct_id: DefId,\n-                             id: DefId,\n-                             substs: &Substs<'tcx>)\n-                             -> Ty<'tcx> {\n-        self.lookup_field_type_unsubstituted(struct_id, id).subst(self, substs)\n-    }\n-\n-    // Look up the list of field names and IDs for a given struct.\n-    // Panics if the id is not bound to a struct.\n-    pub fn lookup_struct_fields(&self, did: ast::DefId) -> Vec<FieldTy> {\n-        if did.krate == ast::LOCAL_CRATE {\n-            let struct_fields = self.struct_fields.borrow();\n-            match struct_fields.get(&did) {\n-                Some(fields) => (**fields).clone(),\n-                _ => {\n-                    self.sess.bug(\n-                        &format!(\"ID not mapped to struct fields: {}\",\n-                                self.map.node_to_string(did.node)));\n-                }\n-            }\n-        } else {\n-            csearch::get_struct_fields(&self.sess.cstore, did)\n-        }\n-    }\n-\n-    pub fn is_tuple_struct(&self, did: ast::DefId) -> bool {\n-        let fields = self.lookup_struct_fields(did);\n-        !fields.is_empty() && fields.iter().all(|f| f.name == token::special_names::unnamed_field)\n-    }\n-\n-    // Returns a list of fields corresponding to the struct's items. trans uses\n-    // this. Takes a list of substs with which to instantiate field types.\n-    pub fn struct_fields(&self, did: ast::DefId, substs: &Substs<'tcx>)\n-                         -> Vec<Field<'tcx>> {\n-        self.lookup_struct_fields(did).iter().map(|f| {\n-           Field {\n-                name: f.name,\n-                mt: TypeAndMut {\n-                    ty: self.lookup_field_type(did, f.id, substs),\n-                    mutbl: MutImmutable\n-                }\n-            }\n-        }).collect()\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        while let TyStruct(def_id, substs) = ty.sty {\n-            match self.struct_fields(def_id, substs).last() {\n-                Some(f) => ty = f.mt.ty,\n+        while let TyStruct(def, substs) = ty.sty {\n+            match def.struct_variant().fields.last() {\n+                Some(f) => ty = f.ty(self, substs),\n                 None => break\n             }\n         }\n@@ -6074,17 +6067,13 @@ impl<'tcx> ctxt<'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyStruct(a_did, a_substs), &TyStruct(b_did, b_substs)) = (&a.sty, &b.sty) {\n-            if a_did != b_did {\n+        while let (&TyStruct(a_def, a_substs), &TyStruct(b_def, b_substs)) = (&a.sty, &b.sty) {\n+            if a_def != b_def {\n                 break;\n             }\n-            if let Some(a_f) = self.struct_fields(a_did, a_substs).last() {\n-                if let Some(b_f) = self.struct_fields(b_did, b_substs).last() {\n-                    a = a_f.mt.ty;\n-                    b = b_f.mt.ty;\n-                } else {\n-                    break;\n-                }\n+            if let Some(f) = a_def.struct_variant().fields.last() {\n+                a = f.ty(self, a_substs);\n+                b = f.ty(self, b_substs);\n             } else {\n                 break;\n             }\n@@ -6452,7 +6441,7 @@ impl<'tcx> ctxt<'tcx> {\n                     }\n                     TyEnum(d, _) => {\n                         byte!(8);\n-                        did(state, d);\n+                        did(state, d.did);\n                     }\n                     TyBox(_) => {\n                         byte!(9);\n@@ -6495,7 +6484,7 @@ impl<'tcx> ctxt<'tcx> {\n                     }\n                     TyStruct(d, _) => {\n                         byte!(18);\n-                        did(state, d);\n+                        did(state, d.did);\n                     }\n                     TyTuple(ref inner) => {\n                         byte!(19);\n@@ -6633,6 +6622,85 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n+\n+\n+    /// Returns true if this ADT is a dtorck type, i.e. whether it being\n+    /// safe for destruction requires it to be alive\n+    fn is_adt_dtorck(&self, adt: AdtDef<'tcx>) -> bool {\n+        let dtor_method = match self.destructor_for_type.borrow().get(&adt.did) {\n+            Some(dtor) => *dtor,\n+            None => return false\n+        };\n+        let impl_did = self.impl_of_method(dtor_method).unwrap_or_else(|| {\n+            self.sess.bug(&format!(\"no Drop impl for the dtor of `{:?}`\", adt))\n+        });\n+        let generics = adt.type_scheme(self).generics;\n+\n+        // In `impl<'a> Drop ...`, we automatically assume\n+        // `'a` is meaningful and thus represents a bound\n+        // through which we could reach borrowed data.\n+        //\n+        // FIXME (pnkfelix): In the future it would be good to\n+        // extend the language to allow the user to express,\n+        // in the impl signature, that a lifetime is not\n+        // actually used (something like `where 'a: ?Live`).\n+        if generics.has_region_params(subst::TypeSpace) {\n+            debug!(\"typ: {:?} has interesting dtor due to region params\",\n+                   adt);\n+            return true;\n+        }\n+\n+        let mut seen_items = Vec::new();\n+        let mut items_to_inspect = vec![impl_did];\n+        while let Some(item_def_id) = items_to_inspect.pop() {\n+            if seen_items.contains(&item_def_id) {\n+                continue;\n+            }\n+\n+            for pred in self.lookup_predicates(item_def_id).predicates {\n+                let result = match pred {\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        // For now, assume all these where-clauses\n+                        // may give drop implementation capabilty\n+                        // to access borrowed data.\n+                        true\n+                    }\n+\n+                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                        let def_id = t_pred.trait_ref.def_id;\n+                        if self.trait_items(def_id).len() != 0 {\n+                            // If trait has items, assume it adds\n+                            // capability to access borrowed data.\n+                            true\n+                        } else {\n+                            // Trait without items is itself\n+                            // uninteresting from POV of dropck.\n+                            //\n+                            // However, may have parent w/ items;\n+                            // so schedule checking of predicates,\n+                            items_to_inspect.push(def_id);\n+                            // and say \"no capability found\" for now.\n+                            false\n+                        }\n+                    }\n+                };\n+\n+                if result {\n+                    debug!(\"typ: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n+                           adt, pred);\n+                    return true;\n+                }\n+            }\n+\n+            seen_items.push(item_def_id);\n+        }\n+\n+        debug!(\"typ: {:?} is dtorck-safe\", adt);\n+        false\n+    }\n }\n \n /// The category of explicit self.\n@@ -7228,12 +7296,6 @@ impl<'tcx> HasTypeFlags for FnSig<'tcx> {\n     }\n }\n \n-impl<'tcx> HasTypeFlags for Field<'tcx> {\n-    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.mt.ty.has_type_flags(flags)\n-    }\n-}\n-\n impl<'tcx> HasTypeFlags for BareFnTy<'tcx> {\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.sig.has_type_flags(flags)\n@@ -7264,12 +7326,6 @@ impl<'tcx> fmt::Debug for ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for Field<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"field({},{})\", self.name, self.mt)\n-    }\n-}\n-\n impl<'a, 'tcx> fmt::Debug for ParameterEnvironment<'a, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ParameterEnvironment(\\"}, {"sha": "cc1efeaea080f39e1e633bb4bad2e684b56b1381", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -275,15 +275,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Field<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Field<'tcx> {\n-        ty::Field {\n-            name: self.name,\n-            mt: self.mt.fold_with(folder),\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)"}, {"sha": "05b08b356efdf12ef198f1faf5a1fc16bdd5389a", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -485,11 +485,11 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(a)\n         }\n \n-        (&ty::TyEnum(a_id, a_substs), &ty::TyEnum(b_id, b_substs))\n-            if a_id == b_id =>\n+        (&ty::TyEnum(a_def, a_substs), &ty::TyEnum(b_def, b_substs))\n+            if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(tcx.mk_enum(a_id, tcx.mk_substs(substs)))\n+            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            Ok(tcx.mk_enum(a_def, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n@@ -499,11 +499,11 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(tcx.mk_trait(principal, bounds))\n         }\n \n-        (&ty::TyStruct(a_id, a_substs), &ty::TyStruct(b_id, b_substs))\n-            if a_id == b_id =>\n+        (&ty::TyStruct(a_def, a_substs), &ty::TyStruct(b_def, b_substs))\n+            if a_def == b_def =>\n         {\n-            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n-            Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n+            let substs = try!(relate_item_substs(relation, a_def.did, a_substs, b_substs));\n+            Ok(tcx.mk_struct(a_def, tcx.mk_substs(substs)))\n         }\n \n         (&ty::TyClosure(a_id, ref a_substs),"}, {"sha": "da20f730babab3bef80cae4c11de67fb4ab75ee5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -366,6 +366,14 @@ impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n     }\n }\n \n+impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            write!(f, \"{}\", tcx.item_path_str(self.did))\n+        })\n+    }\n+}\n+\n impl fmt::Display for ty::BoundRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -648,14 +656,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyEnum(did, substs) | TyStruct(did, substs) => {\n+            TyEnum(def, substs) | TyStruct(def, substs) => {\n                 ty::tls::with(|tcx| {\n-                    if did.krate == ast::LOCAL_CRATE &&\n-                          !tcx.tcache.borrow().contains_key(&did) {\n-                        write!(f, \"{}<..>\", tcx.item_path_str(did))\n+                    if def.did.krate == ast::LOCAL_CRATE &&\n+                          !tcx.tcache.borrow().contains_key(&def.did) {\n+                        write!(f, \"{}<..>\", tcx.item_path_str(def.did))\n                     } else {\n-                        parameterized(f, substs, did, &[],\n-                                      |tcx| tcx.lookup_item_type(did).generics)\n+                        parameterized(f, substs, def.did, &[],\n+                                      |tcx| tcx.lookup_item_type(def.did).generics)\n                     }\n                 })\n             }"}, {"sha": "62cb1f73cf8536d98ebf001e743b39b0969c76eb", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -746,24 +746,22 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def_id, _) | ty::TyEnum(def_id, _) => {\n-                        if self.tcx().has_dtor(def_id) {\n-                            // In the case where the owner implements drop, then\n-                            // the path must be initialized to prevent a case of\n-                            // partial reinitialization\n-                            //\n-                            // FIXME (22079): could refactor via hypothetical\n-                            // generalized check_if_path_is_moved\n-                            let loan_path = owned_ptr_base_path_rc(lp_base);\n-                            self.move_data.each_move_of(id, &loan_path, |_, _| {\n-                                self.bccx\n-                                    .report_partial_reinitialization_of_uninitialized_structure(\n-                                        span,\n-                                        &*loan_path);\n-                                false\n-                            });\n-                            return;\n-                        }\n+                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor(self.tcx()) => {\n+                        // In the case where the owner implements drop, then\n+                        // the path must be initialized to prevent a case of\n+                        // partial reinitialization\n+                        //\n+                        // FIXME (22079): could refactor via hypothetical\n+                        // generalized check_if_path_is_moved\n+                        let loan_path = owned_ptr_base_path_rc(lp_base);\n+                        self.move_data.each_move_of(id, &loan_path, |_, _| {\n+                            self.bccx\n+                                .report_partial_reinitialization_of_uninitialized_structure(\n+                                    span,\n+                                    &*loan_path);\n+                            false\n+                        });\n+                        return;\n                     },\n                     _ => {},\n                 }"}, {"sha": "e30b85919e281ebeeb1cba87f4ee34cf5997c5fa", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -438,11 +438,10 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(def_id, ref _substs), None) => {\n-            let fields = tcx.lookup_struct_fields(def_id);\n+        (&ty::TyStruct(def, _), None) => {\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    for f in &fields {\n+                    for f in &def.struct_variant().fields {\n                         if f.name == ast_name {\n                             continue;\n                         }\n@@ -451,7 +450,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                     }\n                 }\n                 mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in fields.iter().enumerate() {\n+                    for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n                         if i == tuple_idx {\n                             continue\n                         }\n@@ -462,35 +461,26 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyEnum(enum_def_id, substs), ref enum_variant_info) => {\n-            let variant_info = {\n-                let mut variants = tcx.substd_enum_variants(enum_def_id, substs);\n-                match *enum_variant_info {\n-                    Some((variant_def_id, ref _lp2)) =>\n-                        variants.iter()\n-                        .find(|variant| variant.id == variant_def_id)\n-                        .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n-                        .clone(),\n-                    None => {\n-                        assert_eq!(variants.len(), 1);\n-                        variants.pop().unwrap()\n-                    }\n+        (&ty::TyEnum(def, _), ref enum_variant_info) => {\n+            let variant = match *enum_variant_info {\n+                Some((vid, ref _lp2)) => def.variant_with_id(vid),\n+                None => {\n+                    assert!(def.is_univariant());\n+                    &def.variants[0]\n                 }\n             };\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n-                    for &variant_arg_name in variant_arg_names {\n-                        if variant_arg_name == ast_name {\n+                    for field in &variant.fields {\n+                        if field.name == ast_name {\n                             continue;\n                         }\n-                        let field_name = mc::NamedField(variant_arg_name);\n-                        add_fragment_sibling_local(field_name, Some(variant_info.id));\n+                        let field_name = mc::NamedField(field.name);\n+                        add_fragment_sibling_local(field_name, Some(variant.did));\n                     }\n                 }\n                 mc::PositionalField(tuple_idx) => {\n-                    let variant_arg_types = &variant_info.args;\n-                    for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {\n+                    for (i, _f) in variant.fields.iter().enumerate() {\n                         if tuple_idx == i {\n                             continue;\n                         }"}, {"sha": "308ae42c16f07ec858af34bd18226bebee456f5e", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -179,8 +179,8 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_interior(ref b, mc::InteriorField(_)) |\n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::TyStruct(did, _) | ty::TyEnum(did, _) => {\n-                    if bccx.tcx.has_dtor(did) {\n+                ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                    if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "1246449327d963db147a34ab73683eecc5c3a5a1", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -136,8 +136,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_downcast(ref b, _) |\n         mc::cat_interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyStruct(did, _) |\n-                ty::TyEnum(did, _) if bccx.tcx.has_dtor(did) => {\n+                ty::TyStruct(def, _) |\n+                ty::TyEnum(def, _) if def.has_dtor(bccx.tcx) => {\n                     bccx.span_err(\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\"}, {"sha": "dabe1b984df2a57fad9550d67be17c411f5b63ce", "filename": "src/librustc_data_structures/ivar.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use std::cell::Cell;\n+\n+/// A write-once variable. When constructed, it is empty, and\n+/// can only be set once.\n+///\n+/// Ivars ensure that data that can only be initialised once. A full\n+/// implementation is used for concurrency and blocks on a read of an\n+/// unfulfilled value. This implementation is more minimal and panics\n+/// if you attempt to read the value before it has been set. It is also\n+/// not `Sync`, but may be extended in the future to be usable as a true\n+/// concurrency type.\n+///\n+/// The `T: Copy` bound is not strictly needed, but it is required by\n+/// Cell (so removing it would require using UnsafeCell), and it\n+/// suffices for the current purposes.\n+#[derive(PartialEq)]\n+pub struct Ivar<T: Copy> {\n+    data: Cell<Option<T>>\n+}\n+\n+impl<T: Copy> Ivar<T> {\n+    pub fn new() -> Ivar<T> {\n+        Ivar {\n+            data: Cell::new(None)\n+        }\n+    }\n+\n+    pub fn get(&self) -> Option<T> {\n+        self.data.get()\n+    }\n+\n+    pub fn fulfill(&self, value: T) {\n+        assert!(self.data.get().is_none(),\n+                \"Value already set!\");\n+        self.data.set(Some(value));\n+    }\n+\n+    pub fn is_fulfilled(&self) -> bool {\n+        self.data.get().is_some()\n+    }\n+\n+    pub fn unwrap(&self) -> T {\n+        self.get().unwrap()\n+    }\n+}\n+\n+impl<T: Copy+fmt::Debug> fmt::Debug for Ivar<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            Some(val) => write!(f, \"Ivar({:?})\", val),\n+            None => f.write_str(\"Ivar(<unfulfilled>)\")\n+        }\n+    }\n+}\n+\n+impl<T: Copy> Clone for Ivar<T> {\n+    fn clone(&self) -> Ivar<T> {\n+        match self.get() {\n+            Some(val) => Ivar { data: Cell::new(Some(val)) },\n+            None => Ivar::new()\n+        }\n+    }\n+}"}, {"sha": "558d15610dff25f60184bafd6612300b34a071db", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -36,4 +36,5 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod snapshot_vec;\n pub mod graph;\n pub mod bitvec;\n+pub mod ivar;\n pub mod unify;"}, {"sha": "8f5519faf7a02a37b23ee738924bbf9bfb158d11", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -45,7 +45,6 @@ use std::collections::{HashSet, BitSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-use std::rc::Rc;\n \n use syntax::{abi, ast};\n use syntax::ast_util::{self, is_shift_binop, local_def};\n@@ -413,18 +412,23 @@ enum FfiResult {\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'tcx>(variants: &Vec<Rc<ty::VariantInfo<'tcx>>>) -> bool {\n-    if variants.len() == 2 {\n-        let mut data_idx = 0;\n-\n-        if variants[0].args.is_empty() {\n+fn is_repr_nullable_ptr<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              def: ty::AdtDef<'tcx>,\n+                              substs: &Substs<'tcx>)\n+                              -> bool {\n+    if def.variants.len() == 2 {\n+        let data_idx;\n+\n+        if def.variants[0].fields.is_empty() {\n             data_idx = 1;\n-        } else if !variants[1].args.is_empty() {\n+        } else if def.variants[1].fields.is_empty() {\n+            data_idx = 0;\n+        } else {\n             return false;\n         }\n \n-        if variants[data_idx].args.len() == 1 {\n-            match variants[data_idx].args[0].sty {\n+        if def.variants[data_idx].fields.len() == 1 {\n+            match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n                 ty::TyBareFn(None, _) => { return true; }\n                 ty::TyRef(..) => { return true; }\n                 _ => { }\n@@ -463,8 +467,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyStruct(did, substs) => {\n-                if !cx.lookup_repr_hints(did).contains(&attr::ReprExtern) {\n+            ty::TyStruct(def, substs) => {\n+                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n                     return FfiUnsafe(\n                         \"found struct without foreign-function-safe \\\n                          representation annotation in foreign module, \\\n@@ -474,39 +478,36 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                 // We can't completely trust repr(C) markings; make sure the\n                 // fields are actually safe.\n-                let fields = cx.struct_fields(did, substs);\n-\n-                if fields.is_empty() {\n+                if def.struct_variant().fields.is_empty() {\n                     return FfiUnsafe(\n                         \"found zero-size struct in foreign module, consider \\\n                          adding a member to this struct\");\n                 }\n \n-                for field in fields {\n-                    let field_ty = infer::normalize_associated_type(cx, &field.mt.ty);\n+                for field in &def.struct_variant().fields {\n+                    let field_ty = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n                     let r = self.check_type_for_ffi(cache, field_ty);\n                     match r {\n                         FfiSafe => {}\n                         FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                        FfiUnsafe(s) => { return FfiBadStruct(did, s); }\n+                        FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n                     }\n                 }\n                 FfiSafe\n             }\n-            ty::TyEnum(did, substs) => {\n-                let variants = cx.substd_enum_variants(did, substs);\n-                if variants.is_empty() {\n+            ty::TyEnum(def, substs) => {\n+                if def.variants.is_empty() {\n                     // Empty enums are okay... although sort of useless.\n                     return FfiSafe\n                 }\n \n                 // Check for a repr() attribute to specify the size of the\n                 // discriminant.\n-                let repr_hints = cx.lookup_repr_hints(did);\n+                let repr_hints = cx.lookup_repr_hints(def.did);\n                 match &**repr_hints {\n                     [] => {\n                         // Special-case types like `Option<extern fn()>`.\n-                        if !is_repr_nullable_ptr(&variants) {\n+                        if !is_repr_nullable_ptr(cx, def, substs) {\n                             return FfiUnsafe(\n                                 \"found enum without foreign-function-safe \\\n                                  representation annotation in foreign module, \\\n@@ -537,14 +538,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 // Check the contained variants.\n-                for variant in variants {\n-                    for arg in &variant.args {\n-                        let arg = infer::normalize_associated_type(cx, arg);\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        let arg = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n                         let r = self.check_type_for_ffi(cache, arg);\n                         match r {\n                             FfiSafe => {}\n                             FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadEnum(did, s); }\n+                            FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n                         }\n                     }\n                 }\n@@ -842,8 +843,8 @@ impl LintPass for RawPointerDerive {\n                 }\n \n                 match cx.tcx.node_id_to_type(item.id).sty {\n-                    ty::TyEnum(did, _) => did,\n-                    ty::TyStruct(did, _) => did,\n+                    ty::TyEnum(def, _) => def.did,\n+                    ty::TyStruct(def, _) => def.did,\n                     _ => return,\n                 }\n             }\n@@ -989,16 +990,16 @@ impl LintPass for UnusedResults {\n         let warned = match t.sty {\n             ty::TyTuple(ref tys) if tys.is_empty() => return,\n             ty::TyBool => return,\n-            ty::TyStruct(did, _) |\n-            ty::TyEnum(did, _) => {\n-                if ast_util::is_local(did) {\n-                    if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n+            ty::TyStruct(def, _) |\n+            ty::TyEnum(def, _) => {\n+                if ast_util::is_local(def.did) {\n+                    if let ast_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n                         false\n                     }\n                 } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n+                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n                     check_must_use(cx, &attrs[..], s.span)\n                 }\n             }\n@@ -1956,14 +1957,14 @@ impl LintPass for MissingCopyImplementations {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_struct(local_def(item.id),\n+                cx.tcx.mk_struct(cx.tcx.lookup_adt_def(local_def(item.id)),\n                                  cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n                 }\n-                cx.tcx.mk_enum(local_def(item.id),\n+                cx.tcx.mk_enum(cx.tcx.lookup_adt_def(local_def(item.id)),\n                                cx.tcx.mk_substs(Substs::empty()))\n             }\n             _ => return,\n@@ -2575,9 +2576,9 @@ impl LintPass for DropWithReprExtern {\n                 };\n \n             match dtor_self_type.sty {\n-                ty::TyEnum(self_type_did, _) |\n-                ty::TyStruct(self_type_did, _) |\n-                ty::TyClosure(self_type_did, _) => {\n+                ty::TyEnum(self_type_def, _) |\n+                ty::TyStruct(self_type_def, _) => {\n+                    let self_type_did = self_type_def.did;\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {"}, {"sha": "d10dc2e05ffd04e0b93f9ba3d0a2d7d3feeffe36", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 54, "deletions": 98, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -34,7 +34,6 @@ use self::FieldName::*;\n use std::mem::replace;\n \n use rustc::ast_map;\n-use rustc::metadata::csearch;\n use rustc::middle::def;\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n@@ -688,28 +687,26 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is in scope.\n     fn check_field(&mut self,\n                    span: Span,\n-                   id: ast::DefId,\n+                   def: ty::AdtDef<'tcx>,\n+                   v: ty::VariantDef<'tcx>,\n                    name: FieldName) {\n-        let fields = self.tcx.lookup_struct_fields(id);\n         let field = match name {\n             NamedField(f_name) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", f_name, id);\n-                fields.iter().find(|f| f.name == f_name).unwrap()\n+                debug!(\"privacy - check named field {} in struct {:?}\", f_name, def);\n+                v.field_named(f_name)\n             }\n-            UnnamedField(idx) => &fields[idx]\n+            UnnamedField(idx) => &v.fields[idx]\n         };\n         if field.vis == ast::Public ||\n-            (is_local(field.id) && self.private_accessible(field.id.node)) {\n+            (is_local(field.did) && self.private_accessible(field.did.node)) {\n             return\n         }\n \n-        let struct_type = self.tcx.lookup_item_type(id).ty;\n-        let struct_desc = match struct_type.sty {\n-            ty::TyStruct(_, _) =>\n-                format!(\"struct `{}`\", self.tcx.item_path_str(id)),\n+        let struct_desc = match def.adt_kind() {\n+            ty::AdtKind::Struct =>\n+                format!(\"struct `{}`\", self.tcx.item_path_str(def.did)),\n             // struct variant fields have inherited visibility\n-            ty::TyEnum(..) => return,\n-            _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n+            ty::AdtKind::Enum => return\n         };\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\",\n@@ -883,13 +880,19 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n-                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, id, NamedField(ident.node.name));\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                    self.check_field(expr.span,\n+                                     def,\n+                                     def.struct_variant(),\n+                                     NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(id, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, id, UnnamedField(idx.node));\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                    self.check_field(expr.span,\n+                                     def,\n+                                     def.struct_variant(),\n+                                     UnnamedField(idx.node));\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n@@ -898,67 +901,36 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 debug!(\"(privacy checking) checking impl method\");\n                 self.check_method(expr.span, method.def_id, ident.node.name);\n             }\n-            ast::ExprStruct(_, ref fields, _) => {\n-                match self.tcx.expr_ty(expr).sty {\n-                    ty::TyStruct(ctor_id, _) => {\n-                        // RFC 736: ensure all unmentioned fields are visible.\n-                        // Rather than computing the set of unmentioned fields\n-                        // (i.e. `all_fields - fields`), just check them all.\n-                        let all_fields = self.tcx.lookup_struct_fields(ctor_id);\n-                        for field in all_fields {\n-                            self.check_field(expr.span, ctor_id,\n-                                             NamedField(field.name));\n-                        }\n-                    }\n-                    ty::TyEnum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n-                            def::DefVariant(_, variant_id, _) => {\n-                                for field in fields {\n-                                    self.check_field(expr.span, variant_id,\n-                                                     NamedField(field.ident.node.name));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(expr.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         constructor to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                            didn't have \\\n-                                                            struct type?!\"),\n+            ast::ExprStruct(..) => {\n+                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let variant = adt.variant_of_def(self.tcx.resolve_expr(expr));\n+                // RFC 736: ensure all unmentioned fields are visible.\n+                // Rather than computing the set of unmentioned fields\n+                // (i.e. `all_fields - fields`), just check them all.\n+                for field in &variant.fields {\n+                    self.check_field(expr.span, adt, variant, NamedField(field.name));\n                 }\n             }\n             ast::ExprPath(..) => {\n-                let guard = |did: ast::DefId| {\n-                    let fields = self.tcx.lookup_struct_fields(did);\n-                    let any_priv = fields.iter().any(|f| {\n+\n+                if let def::DefStruct(_) = self.tcx.resolve_expr(expr) {\n+                    let expr_ty = self.tcx.expr_ty(expr);\n+                    let def = match expr_ty.sty {\n+                        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+                            output: ty::FnConverging(ty), ..\n+                        }), ..}) => ty,\n+                        _ => expr_ty\n+                    }.ty_adt_def().unwrap();\n+                    let any_priv = def.struct_variant().fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n-                            !is_local(f.id) ||\n-                            !self.private_accessible(f.id.node))\n-                    });\n+                            !is_local(f.did) ||\n+                                    !self.private_accessible(f.did.node))\n+                        });\n                     if any_priv {\n                         self.tcx.sess.span_err(expr.span,\n-                            \"cannot invoke tuple struct constructor \\\n-                             with private fields\");\n-                    }\n-                };\n-                match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-                    Some(def::DefStruct(did)) => {\n-                        guard(if is_local(did) {\n-                            local_def(self.tcx.map.get_parent(did.node))\n-                        } else {\n-                            // \"tuple structs\" with zero fields (such as\n-                            // `pub struct Foo;`) don't have a ctor_id, hence\n-                            // the unwrap_or to the same struct id.\n-                            let maybe_did =\n-                                csearch::get_tuple_struct_definition_if_ctor(\n-                                    &self.tcx.sess.cstore, did);\n-                            maybe_did.unwrap_or(did)\n-                        })\n+                                               \"cannot invoke tuple struct constructor \\\n+                                                with private fields\");\n                     }\n-                    _ => {}\n                 }\n             }\n             _ => {}\n@@ -976,44 +948,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(id, _) => {\n-                        for field in fields {\n-                            self.check_field(pattern.span, id,\n-                                             NamedField(field.node.ident.name));\n-                        }\n-                    }\n-                    ty::TyEnum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&pattern.id).map(|d| d.full_def()) {\n-                            Some(def::DefVariant(_, variant_id, _)) => {\n-                                for field in fields {\n-                                    self.check_field(pattern.span, variant_id,\n-                                                     NamedField(field.node.ident.name));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(pattern.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         pattern to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(pattern.span,\n-                                                \"struct pattern didn't have \\\n-                                                 struct type?!\"),\n+                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n+                let variant = adt.variant_of_def(def);\n+                for field in fields {\n+                    self.check_field(pattern.span, adt, variant,\n+                                     NamedField(field.node.ident.name));\n                 }\n             }\n \n             // Patterns which bind no fields are allowable (the path is check\n             // elsewhere).\n             ast::PatEnum(_, Some(ref fields)) => {\n                 match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(id, _) => {\n+                    ty::TyStruct(def, _) => {\n                         for (i, field) in fields.iter().enumerate() {\n                             if let ast::PatWild(..) = field.node {\n                                 continue\n                             }\n-                            self.check_field(field.span, id, UnnamedField(i));\n+                            self.check_field(field.span,\n+                                             def,\n+                                             def.struct_variant(),\n+                                             UnnamedField(i));\n                         }\n                     }\n                     ty::TyEnum(..) => {"}, {"sha": "190e217aac15dc2be9269d098748325be7f64886", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -791,9 +791,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-            let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n-                f.name\n-            }).collect::<Vec<_>>();\n+            let fields = csearch::get_struct_field_names(&self.session.cstore, def_id);\n \n             if fields.is_empty() {\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);"}, {"sha": "707d4c4a844856bf925434cddf8fc87602b74cad", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 32, "deletions": 50, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -742,6 +742,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n+                          variant: ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n         if generated_code(path.span) {\n             return\n@@ -756,7 +757,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                              Some(struct_lit_data.span),\n                              struct_lit_data.ref_id,\n                              struct_lit_data.scope);\n-            let struct_def = struct_lit_data.ref_id;\n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n \n             for field in fields {\n@@ -765,7 +765,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 }\n \n                 let field_data = self.save_ctxt.get_field_ref_data(field,\n-                                                                   struct_def,\n+                                                                   variant,\n                                                                    scope);\n                 self.fmt.ref_str(recorder::VarRef,\n                                  field.ident.span,\n@@ -804,43 +804,24 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         match p.node {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n+                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let def = self.tcx.def_map.borrow()[&p.id].full_def();\n+                let variant = adt.variant_of_def(def);\n \n-                let def = self.tcx.def_map.borrow().get(&p.id).unwrap().full_def();\n-                let struct_def = match def {\n-                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n-                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n-                    _ => {\n-                        match self.tcx.node_id_to_type(p.id).ty_to_def_id() {\n-                            None => {\n-                                self.sess.span_bug(p.span,\n-                                                   &format!(\"Could not find struct_def for `{}`\",\n-                                                            self.span.snippet(p.span)));\n-                            }\n-                            Some(def_id) => Some(def_id),\n-                        }\n+                for &Spanned { node: ref field, span } in fields {\n+                    if generated_code(span) {\n+                        continue;\n                     }\n-                };\n \n-                if let Some(struct_def) = struct_def {\n-                    let struct_fields = self.tcx.lookup_struct_fields(struct_def);\n-                    for &Spanned { node: ref field, span } in fields {\n-                        if generated_code(span) {\n-                            continue;\n-                        }\n-\n-                        let sub_span = self.span.span_for_first_ident(span);\n-                        for f in &struct_fields {\n-                            if f.name == field.ident.name {\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                        self.visit_pat(&field.pat);\n+                    let sub_span = self.span.span_for_first_ident(span);\n+                    if let Some(f) = variant.find_field_named(field.ident.name) {\n+                        self.fmt.ref_str(recorder::VarRef,\n+                                         span,\n+                                         sub_span,\n+                                         f.did,\n+                                         self.cur_scope);\n                     }\n+                    self.visit_pat(&field.pat);\n                 }\n             }\n             _ => visit::walk_pat(self, p)\n@@ -1091,8 +1072,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_path(ex.id, path, None);\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprStruct(ref path, ref fields, ref base) =>\n-                self.process_struct_lit(ex, path, fields, base),\n+            ast::ExprStruct(ref path, ref fields, ref base) => {\n+                let adt = self.tcx.expr_ty(ex).ty_adt_def().unwrap();\n+                let def = self.tcx.resolve_expr(ex);\n+                self.process_struct_lit(ex,\n+                                        path,\n+                                        fields,\n+                                        adt.variant_of_def(def),\n+                                        base)\n+            }\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n             ast::ExprField(ref sub_ex, _) => {\n                 if generated_code(sub_ex.span) {\n@@ -1119,19 +1107,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def_id);\n-                        for (i, f) in fields.iter().enumerate() {\n-                            if i == idx.node {\n-                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n+                    ty::TyStruct(def, _) => {\n+                        let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n+                        self.fmt.ref_str(recorder::VarRef,\n+                                         ex.span,\n+                                         sub_span,\n+                                         def.struct_variant().fields[idx.node].did,\n+                                         self.cur_scope);\n                     }\n                     ty::TyTuple(_) => {}\n                     _ => self.sess.span_bug(ex.span,"}, {"sha": "5bbd8ce154904ad55b7d752aa172c154bc845c7d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 20, "deletions": 36, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -447,23 +447,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprField(ref sub_ex, ident) => {\n                 let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def_id);\n-                        for f in &fields {\n-                            if f.name == ident.node.name {\n-                                let sub_span = self.span_utils.span_for_last_ident(expr.span);\n-                                return Some(Data::VariableRefData(VariableRefData {\n-                                    name: ident.node.to_string(),\n-                                    span: sub_span.unwrap(),\n-                                    scope: self.enclosing_scope(expr.id),\n-                                    ref_id: f.id,\n-                                }));\n-                            }\n-                        }\n-\n-                        self.tcx.sess.span_bug(expr.span,\n-                                               &format!(\"Couldn't find field {} on {:?}\",\n-                                                        ident.node, ty))\n+                    ty::TyStruct(def, _) => {\n+                        let f = def.struct_variant().field_named(ident.node.name);\n+                        let sub_span = self.span_utils.span_for_last_ident(expr.span);\n+                        return Some(Data::VariableRefData(VariableRefData {\n+                            name: ident.node.to_string(),\n+                            span: sub_span.unwrap(),\n+                            scope: self.enclosing_scope(expr.id),\n+                            ref_id: f.did,\n+                        }));\n                     }\n                     _ => {\n                         debug!(\"Expected struct type, found {:?}\", ty);\n@@ -474,12 +466,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             ast::ExprStruct(ref path, _, _) => {\n                 let ty = &self.tcx.expr_ty_adjusted(expr).sty;\n                 match *ty {\n-                    ty::TyStruct(def_id, _) => {\n+                    ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n                             scope: self.enclosing_scope(expr.id),\n-                            ref_id: def_id,\n+                            ref_id: def.did,\n                         }))\n                     }\n                     _ => {\n@@ -621,26 +613,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              struct_id: DefId,\n+                              variant: ty::VariantDef,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = self.tcx.lookup_struct_fields(struct_id);\n-        let field_name = field_ref.ident.node.to_string();\n-        for f in &fields {\n-            if f.name == field_ref.ident.node.name {\n-                // We don't really need a sub-span here, but no harm done\n-                let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n-                return VariableRefData {\n-                    name: field_name,\n-                    span: sub_span.unwrap(),\n-                    scope: parent,\n-                    ref_id: f.id,\n-                };\n-            }\n+        let f = variant.field_named(field_ref.ident.node.name);\n+        // We don't really need a sub-span here, but no harm done\n+        let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n+        VariableRefData {\n+            name: field_ref.ident.node.to_string(),\n+            span: sub_span.unwrap(),\n+            scope: parent,\n+            ref_id: f.did,\n         }\n-\n-        self.tcx.sess.span_bug(field_ref.span,\n-                               &format!(\"Couldn't find field {}\", field_name));\n     }\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {"}, {"sha": "bd7c67fa8bb8d4762f3bad8042bbf620230e9952", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -656,7 +656,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = tcx.enum_variant_with_id(enum_id, var_id);\n+                        let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n                         Variant(variant.disr_val,\n                                 adt::represent_node(bcx, cur.id),\n                                 var_id,\n@@ -1186,14 +1186,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         ).collect();\n \n         match left_ty.sty {\n-            ty::TyStruct(def_id, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n+            ty::TyStruct(def, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n-                let fields = bcx.tcx().lookup_struct_fields(def_id);\n-                let unsized_ty = fields.iter().last().map(|field| {\n-                    let fty = bcx.tcx().lookup_field_type(def_id, field.id, substs);\n-                    monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n+                let unsized_ty = def.struct_variant().fields.last().map(|field| {\n+                    monomorphize::field_ty(bcx.tcx(), substs, field)\n                 }).unwrap();\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n                 let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n@@ -1833,7 +1831,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ccx.tcx().enum_variant_with_id(enum_id, var_id);\n+                    let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n@@ -1877,21 +1875,20 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n-                for f in fields {\n-                    let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(\n-                        bcx,\n-                        &*pat_repr,\n-                        val.val,\n-                        discr,\n-                        ix);\n-                    bcx = bind_irrefutable_pat(bcx,\n-                                               &*f.node.pat,\n-                                               MatchInput::from_val(fldptr),\n-                                               cleanup_scope);\n-                }\n-            })\n+            let pat_v = VariantInfo::of_node(tcx, pat_ty, pat.id);\n+            for f in fields {\n+                let name = f.node.ident.name;\n+                let fldptr = adt::trans_field_ptr(\n+                    bcx,\n+                    &*pat_repr,\n+                    val.val,\n+                    pat_v.discr,\n+                    pat_v.field_index(name));\n+                bcx = bind_irrefutable_pat(bcx,\n+                                           &*f.node.pat,\n+                                           MatchInput::from_val(fldptr),\n+                                           cleanup_scope);\n+            }\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "326d1e2361e6d3ad631a626a5ba5a8fc598130e4", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -245,14 +245,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elems) => {\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = cx.tcx().lookup_struct_fields(def_id);\n-            let mut ftys = fields.iter().map(|field| {\n-                let fty = cx.tcx().lookup_field_type(def_id, field.id, substs);\n-                monomorphize::normalize_associated_type(cx.tcx(), &fty)\n+        ty::TyStruct(def, substs) => {\n+            let mut ftys = def.struct_variant().fields.iter().map(|field| {\n+                monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n-            let packed = cx.tcx().lookup_packed(def_id);\n-            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n+            let packed = cx.tcx().lookup_packed(def.did);\n+            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n             if dtor {\n                 ftys.push(cx.tcx().dtor_type());\n             }\n@@ -262,12 +260,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n         }\n-        ty::TyEnum(def_id, substs) => {\n-            let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *cx.tcx().lookup_repr_hints(def_id).get(0)\n+        ty::TyEnum(def, substs) => {\n+            let cases = get_cases(cx.tcx(), def, substs);\n+            let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n-            let dtor = cx.tcx().ty_dtor(def_id).has_drop_flag();\n+            let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n \n             if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n@@ -296,7 +294,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                         discriminants\",\n-                                       cx.tcx().item_path_str(def_id)));\n+                                       cx.tcx().item_path_str(def.did)));\n             }\n \n             if cases.len() == 1 {\n@@ -443,11 +441,11 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         ty::TyBareFn(..) => Some(path),\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n-        ty::TyStruct(did, substs) if Some(did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = tcx.lookup_struct_fields(did);\n+        ty::TyStruct(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n+            let nonzero_fields = &def.struct_variant().fields;\n             assert_eq!(nonzero_fields.len(), 1);\n-            let nonzero_field = tcx.lookup_field_type(did, nonzero_fields[0].id, substs);\n-            match nonzero_field.sty {\n+            let field_ty = monomorphize::field_ty(tcx, substs, &nonzero_fields[0]);\n+            match field_ty.sty {\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n                     Some(path)\n@@ -462,10 +460,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = tcx.lookup_struct_fields(def_id);\n-            for (j, field) in fields.iter().enumerate() {\n-                let field_ty = tcx.lookup_field_type(def_id, field.id, substs);\n+        ty::TyStruct(def, substs) => {\n+            for (j, field) in def.struct_variant().fields.iter().enumerate() {\n+                let field_ty = monomorphize::field_ty(tcx, substs, field);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);\n@@ -530,14 +527,14 @@ impl<'tcx> Case<'tcx> {\n }\n \n fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                   def_id: ast::DefId,\n+                   adt: ty::AdtDef<'tcx>,\n                    substs: &subst::Substs<'tcx>)\n                    -> Vec<Case<'tcx>> {\n-    tcx.enum_variants(def_id).iter().map(|vi| {\n-        let arg_tys = vi.args.iter().map(|&raw_ty| {\n-            monomorphize::apply_param_substs(tcx, substs, &raw_ty)\n+    adt.variants.iter().map(|vi| {\n+        let field_tys = vi.fields.iter().map(|field| {\n+            monomorphize::field_ty(tcx, substs, field)\n         }).collect();\n-        Case { discr: vi.disr_val, tys: arg_tys }\n+        Case { discr: vi.disr_val, tys: field_tys }\n     }).collect()\n }\n "}, {"sha": "d59cc4f4298e9cec71cf413877a8aadd3f854179", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -55,8 +55,8 @@ use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use trans::common::{CrateContext, DropFlagHintsMap, FunctionContext};\n-use trans::common::{Result, NodeIdAndSpan};\n+use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n+use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n@@ -386,7 +386,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n                                    av: ValueRef,\n-                                   variant: &ty::VariantInfo<'tcx>,\n+                                   variant: ty::VariantDef<'tcx>,\n                                    substs: &Substs<'tcx>,\n                                    f: &mut F)\n                                    -> Block<'blk, 'tcx> where\n@@ -396,8 +396,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n-        for (i, &arg) in variant.args.iter().enumerate() {\n-            let arg = monomorphize::apply_param_substs(tcx, substs, &arg);\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            let arg = monomorphize::field_ty(tcx, substs, field);\n             cx = f(cx, adt::trans_field_ptr(cx, repr, av, variant.disr_val, i), arg);\n         }\n         return cx;\n@@ -415,22 +415,20 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     match t.sty {\n       ty::TyStruct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n-              for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let field_ty = field_ty.mt.ty;\n-                  let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n-\n-                  let val = if common::type_is_sized(cx.tcx(), field_ty) {\n-                      llfld_a\n-                  } else {\n-                      let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n-                      Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-                      scratch.val\n-                  };\n-                  cx = f(cx, val, field_ty);\n-              }\n-          })\n+          let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+          for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+\n+              let val = if common::type_is_sized(cx.tcx(), field_ty) {\n+                  llfld_a\n+              } else {\n+                  let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n+                  Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n+                  Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n+                  scratch.val\n+              };\n+              cx = f(cx, val, field_ty);\n+          }\n       }\n       ty::TyClosure(_, ref substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n@@ -455,13 +453,12 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               cx = f(cx, llfld_a, *arg);\n           }\n       }\n-      ty::TyEnum(tid, substs) => {\n+      ty::TyEnum(en, substs) => {\n           let fcx = cx.fcx;\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ccx.tcx().enum_variants(tid);\n-          let n_variants = (*variants).len();\n+          let n_variants = en.variants.len();\n \n           // NB: we must hit the discriminant first so that structural\n           // comparison know not to proceed when the discriminants differ.\n@@ -470,7 +467,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               (_match::Single, None) => {\n                   if n_variants != 0 {\n                       assert!(n_variants == 1);\n-                      cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n+                      cx = iter_variant(cx, &*repr, av, &en.variants[0],\n                                         substs, &mut f);\n                   }\n               }\n@@ -496,7 +493,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                         n_variants);\n                   let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n \n-                  for variant in &(*variants) {\n+                  for variant in &en.variants {\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n@@ -513,7 +510,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                           iter_variant(variant_cx,\n                                        &*repr,\n                                        data_ptr,\n-                                       &**variant,\n+                                       variant,\n                                        substs,\n                                        &mut f);\n                       Br(variant_cx, next_cx.llbb, DebugLoc::None);\n@@ -624,7 +621,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0, false);\n             (ICmp(cx, llvm::IntEQ, rhs, zero, debug_loc), false)\n         }\n-        ty::TyStruct(_, _) if rhs_t.is_simd(cx.tcx()) => {\n+        ty::TyStruct(def, _) if def.is_simd() => {\n             let mut res = C_bool(cx.ccx(), false);\n             for i in 0 .. rhs_t.simd_size(cx.tcx()) {\n                 res = Or(cx, res,\n@@ -1693,17 +1690,15 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    _enum_id: ast::NodeId,\n-                                    variant: &ast::Variant,\n-                                    _args: &[ast::VariantArg],\n+                                    ctor_id: ast::NodeId,\n                                     disr: ty::Disr,\n                                     param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n     trans_enum_variant_or_tuple_like_struct(\n         ccx,\n-        variant.node.id,\n+        ctor_id,\n         disr,\n         param_substs,\n         llfndecl);\n@@ -1775,7 +1770,6 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    _fields: &[ast::StructField],\n                                     ctor_id: ast::NodeId,\n                                     param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {"}, {"sha": "d0d5b46ab2839087971ec28f57fed6d2d002ee21", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -182,10 +182,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 fn_callee(bcx, fn_datum)\n             }\n             def::DefVariant(tid, vid, _) => {\n-                let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n-\n-                // Nullary variants are not callable\n-                assert!(!vinfo.args.is_empty());\n+                let vinfo = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+                assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n \n                 Callee {\n                     bcx: bcx,"}, {"sha": "f57612789b53fc8ab6377baece70f92c44a65c03", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 89, "deletions": 6, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -49,6 +49,7 @@ use std::cell::{Cell, RefCell};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n+use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -173,12 +174,10 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n \n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyStruct(def_id, substs) => {\n-            let fields = ccx.tcx().lookup_struct_fields(def_id);\n+        ty::TyStruct(def, substs) => {\n+            let fields = &def.struct_variant().fields;\n             fields.len() == 1 && {\n-                let ty = ccx.tcx().lookup_field_type(def_id, fields[0].id, substs);\n-                let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n-                type_is_immediate(ccx, ty)\n+                type_is_immediate(ccx, monomorphize::field_ty(ccx.tcx(), substs, &fields[0]))\n             }\n         }\n         _ => false\n@@ -193,7 +192,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     let simple = ty.is_scalar() ||\n         ty.is_unique() || ty.is_region_ptr() ||\n         type_is_newtype_immediate(ccx, ty) ||\n-        ty.is_simd(tcx);\n+        ty.is_simd();\n     if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n@@ -271,6 +270,67 @@ pub fn expr_info(expr: &ast::Expr) -> NodeIdAndSpan {\n     NodeIdAndSpan { id: expr.id, span: expr.span }\n }\n \n+/// The concrete version of ty::FieldDef. The name is the field index if\n+/// the field is numeric.\n+pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n+\n+/// The concrete version of ty::VariantDef\n+pub struct VariantInfo<'tcx> {\n+    pub discr: ty::Disr,\n+    pub fields: Vec<Field<'tcx>>\n+}\n+\n+impl<'tcx> VariantInfo<'tcx> {\n+    pub fn from_ty(tcx: &ty::ctxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   opt_def: Option<def::Def>)\n+                   -> Self\n+    {\n+        match ty.sty {\n+            ty::TyStruct(adt, substs) | ty::TyEnum(adt, substs) => {\n+                let variant = match opt_def {\n+                    None => adt.struct_variant(),\n+                    Some(def) => adt.variant_of_def(def)\n+                };\n+\n+                VariantInfo {\n+                    discr: variant.disr_val,\n+                    fields: variant.fields.iter().map(|f| {\n+                        Field(f.name, monomorphize::field_ty(tcx, substs, f))\n+                    }).collect()\n+                }\n+            }\n+\n+            ty::TyTuple(ref v) => {\n+                VariantInfo {\n+                    discr: 0,\n+                    fields: v.iter().enumerate().map(|(i, &t)| {\n+                        Field(token::intern(&i.to_string()), t)\n+                    }).collect()\n+                }\n+            }\n+\n+            _ => {\n+                tcx.sess.bug(&format!(\n+                    \"cannot get field types from the type {:?}\",\n+                    ty));\n+            }\n+        }\n+    }\n+\n+    /// Return the variant corresponding to a given node (e.g. expr)\n+    pub fn of_node(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n+        let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n+        Self::from_ty(tcx, ty, node_def)\n+    }\n+\n+    pub fn field_index(&self, name: ast::Name) -> usize {\n+        self.fields.iter().position(|&Field(n,_)| n == name).unwrap_or_else(|| {\n+            panic!(\"unknown field `{}`\", name)\n+        })\n+    }\n+}\n+\n pub struct BuilderRef_res {\n     pub b: BuilderRef,\n }\n@@ -1178,3 +1238,26 @@ pub fn langcall(bcx: Block,\n         }\n     }\n }\n+\n+/// Return the VariantDef corresponding to an inlined variant node\n+pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     inlined_vid: ast::NodeId)\n+                                     -> ty::VariantDef<'tcx>\n+{\n+\n+    let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n+    debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n+           inlined_vid);\n+    let adt_def = match ctor_ty.sty {\n+        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+            output: ty::FnConverging(ty), ..\n+        }), ..}) => ty,\n+        _ => ctor_ty\n+    }.ty_adt_def().unwrap();\n+    adt_def.variants.iter().find(|v| {\n+        local_def(inlined_vid) == v.did ||\n+            ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n+    }).unwrap_or_else(|| {\n+        ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n+    })\n+}"}, {"sha": "7aaed035f21270e0c41b098d7cd03c5af52dd331", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -500,7 +500,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n-            let is_simd = ty.is_simd(cx.tcx());\n+            let is_simd = ty.is_simd();\n             let intype = if is_simd {\n                 ty.simd_type(cx.tcx())\n             } else {\n@@ -579,17 +579,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast::ExprField(ref base, field) => {\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n-            expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n-                adt::const_get_field(cx, &*brepr, bv, discr, ix)\n-            })\n+            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n+            let ix = vinfo.field_index(field.node.name);\n+            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n         },\n         ast::ExprTupField(ref base, idx) => {\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n-            expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n-                adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n-            })\n+            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n+            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n         },\n \n         ast::ExprIndex(ref base, ref index) => {\n@@ -664,8 +662,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n             unsafe { match (\n-                CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n-                CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\"),\n+                CastTy::from_ty(t_expr).expect(\"bad input type for cast\"),\n+                CastTy::from_ty(t_cast).expect(\"bad output type for cast\"),\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n@@ -748,21 +746,19 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => None\n             };\n \n-            expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n-                let cs = field_tys.iter().enumerate()\n-                                  .map(|(ix, &field_ty)| {\n-                    match (fs.iter().find(|f| field_ty.name == f.ident.node.name), base_val) {\n-                        (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n-                        (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n-                        (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n-                    }\n-                }).collect::<Vec<_>>();\n-                if ety.is_simd(cx.tcx()) {\n-                    C_vector(&cs[..])\n-                } else {\n-                    adt::trans_const(cx, &*repr, discr, &cs[..])\n+            let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n+            let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n+                match (fs.iter().find(|f| f_name == f.ident.node.name), base_val) {\n+                    (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n+                    (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n+                    (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n-            })\n+            }).collect::<Vec<_>>();\n+            if ety.is_simd() {\n+                C_vector(&cs[..])\n+            } else {\n+                adt::trans_const(cx, &*repr, discr, &cs[..])\n+            }\n         },\n         ast::ExprVec(ref es) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n@@ -806,14 +802,18 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n-                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n-                    if !vinfo.args.is_empty() {\n-                        // N-ary variant.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                    } else {\n-                        // Nullary variant.\n-                        let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n+                    match vinfo.kind() {\n+                        ty::VariantKind::Unit => {\n+                            let repr = adt::represent_type(cx, ety);\n+                            adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                        }\n+                        ty::VariantKind::Tuple => {\n+                            expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n+                        }\n+                        ty::VariantKind::Dict => {\n+                            cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n+                        }\n                     }\n                 }\n                 def::DefStruct(_) => {\n@@ -850,7 +850,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n                 }\n                 def::DefStruct(_) => {\n-                    if ety.is_simd(cx.tcx()) {\n+                    if ety.is_simd() {\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n@@ -859,7 +859,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let repr = adt::represent_type(cx, ety);\n-                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n+                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,\n                                      &*repr,\n                                      vinfo.disr_val,"}, {"sha": "0be155b7727382ad5050e10d84c5f85aa206a11b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n use syntax::{ast, codemap, ast_util};\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token;\n \n \n const DW_LANG_RUST: c_uint = 0x9000;\n@@ -178,13 +178,13 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::TyFloat(_) => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n-            ty::TyEnum(def_id, substs) => {\n+            ty::TyEnum(def, substs) => {\n                 unique_type_id.push_str(\"enum \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n-            ty::TyStruct(def_id, substs) => {\n+            ty::TyStruct(def, substs) => {\n                 unique_type_id.push_str(\"struct \");\n-                from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n+                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n             ty::TyTuple(ref component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n@@ -710,8 +710,12 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyTuple(ref elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::TyEnum(def_id, _) => {\n-            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span).finalize(cx)\n+        ty::TyEnum(def, _) => {\n+            prepare_enum_metadata(cx,\n+                                  t,\n+                                  def.did,\n+                                  unique_type_id,\n+                                  usage_site_span).finalize(cx)\n         }\n         ty::TyArray(typ, len) => {\n             fixed_vec_metadata(cx, unique_type_id, typ, Some(len as u64), usage_site_span)\n@@ -780,11 +784,9 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyStruct(def_id, substs) => {\n+        ty::TyStruct(..) => {\n             prepare_struct_metadata(cx,\n                                     t,\n-                                    def_id,\n-                                    substs,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)\n         }\n@@ -1092,42 +1094,49 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    fields: Vec<ty::Field<'tcx>>,\n+    variant: ty::VariantDef<'tcx>,\n+    substs: &'tcx subst::Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if self.fields.is_empty() {\n+        if let ty::VariantKind::Unit = self.variant.kind() {\n             return Vec::new();\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n+            let fty = monomorphize::field_ty(cx.tcx(),\n+                                             self.substs,\n+                                             &self.variant.fields[0]);\n+            Some(machine::llsize_of_alloc(\n+                cx,\n+                type_of::type_of(cx, fty)\n+            ) as usize)\n         } else {\n-            0xdeadbeef\n+            None\n         };\n \n-        self.fields.iter().enumerate().map(|(i, field)| {\n-            let name = if field.name == special_idents::unnamed_field.name {\n+        self.variant.fields.iter().enumerate().map(|(i, f)| {\n+            let name = if let ty::VariantKind::Tuple = self.variant.kind() {\n                 format!(\"__{}\", i)\n             } else {\n-                field.name.to_string()\n+                f.name.to_string()\n             };\n+            let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n \n             let offset = if self.is_simd {\n-                assert!(field_size != 0xdeadbeef);\n-                FixedMemberOffset { bytes: i * field_size }\n+                FixedMemberOffset { bytes: i * field_size.unwrap() }\n             } else {\n                 ComputedMemberOffset\n             };\n \n             MemberDescription {\n                 name: name,\n-                llvm_type: type_of::type_of(cx, field.mt.ty),\n-                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                llvm_type: type_of::type_of(cx, fty),\n+                type_metadata: type_metadata(cx, fty, self.span),\n                 offset: offset,\n                 flags: FLAGS_NONE,\n             }\n@@ -1138,39 +1147,35 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n \n fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      struct_type: Ty<'tcx>,\n-                                     def_id: ast::DefId,\n-                                     substs: &subst::Substs<'tcx>,\n                                      unique_type_id: UniqueTypeId,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n     let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n+    let (variant, substs) = match struct_type.sty {\n+        ty::TyStruct(def, substs) => (def.struct_variant(), substs),\n+        _ => cx.tcx().sess.bug(\"prepare_struct_metadata on a non-struct\")\n+    };\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, variant.did);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let mut fields = cx.tcx().struct_fields(def_id, substs);\n-\n-    // The `Ty` values returned by `ty::struct_fields` can still contain\n-    // `TyProjection` variants, so normalize those away.\n-    for field in &mut fields {\n-        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n-    }\n-\n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n-            fields: fields,\n-            is_simd: struct_type.is_simd(cx.tcx()),\n+            variant: variant,\n+            substs: substs,\n+            is_simd: struct_type.is_simd(),\n             span: span,\n         })\n     )\n@@ -1244,7 +1249,6 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n     type_rep: Rc<adt::Repr<'tcx>>,\n-    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1254,11 +1258,11 @@ struct EnumMemberDescriptionFactory<'tcx> {\n impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n+        let adt = &self.enum_type.ty_adt_def().unwrap();\n         match *self.type_rep {\n             adt::General(_, ref struct_defs, _) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n-\n                 struct_defs\n                     .iter()\n                     .enumerate()\n@@ -1269,7 +1273,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n-                                                  &*self.variants[i],\n+                                                  &adt.variants[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n                                                   self.span);\n@@ -1291,9 +1295,9 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }).collect()\n             },\n             adt::Univariant(ref struct_def, _) => {\n-                assert!(self.variants.len() <= 1);\n+                assert!(adt.variants.len() <= 1);\n \n-                if self.variants.is_empty() {\n+                if adt.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata,\n@@ -1302,7 +1306,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n-                                              &*self.variants[0],\n+                                              &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -1331,7 +1335,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &self.variants[non_null_variant_index as usize];\n+                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n@@ -1346,9 +1350,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.arg_names {\n-                        Some(ref names) => names[0].to_string(),\n-                        None => \"__0\".to_string()\n+                    name: match non_null_variant.kind() {\n+                        ty::VariantKind::Tuple => \"__0\".to_string(),\n+                        ty::VariantKind::Dict => {\n+                            non_null_variant.fields[0].name.to_string()\n+                        }\n+                        ty::VariantKind::Unit => unreachable!()\n                     },\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n@@ -1377,7 +1384,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = self.variants[null_variant_index].name;\n+                let null_variant_name = adt.variants[null_variant_index].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n                                                 null_variant_name);\n@@ -1402,7 +1409,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &*self.variants[nndiscr as usize],\n+                                          &adt.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1418,7 +1425,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = self.variants[null_variant_index].name;\n+                let null_variant_name = adt.variants[null_variant_index].name;\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n@@ -1482,7 +1489,7 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &adt::Struct<'tcx>,\n-                                   variant_info: &ty::VariantInfo<'tcx>,\n+                                   variant: ty::VariantDef<'tcx>,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n@@ -1496,7 +1503,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n-    let variant_name = variant_info.name.as_str();\n+    let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n@@ -1511,18 +1518,20 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant_info.arg_names {\n-        Some(ref names) => {\n-            names.iter()\n-                 .map(|name| name.to_string())\n-                 .collect()\n+    let mut arg_names: Vec<_> = match variant.kind() {\n+        ty::VariantKind::Unit => vec![],\n+        ty::VariantKind::Tuple => {\n+            variant.fields\n+                   .iter()\n+                   .enumerate()\n+                   .map(|(i, _)| format!(\"__{}\", i))\n+                   .collect()\n         }\n-        None => {\n-            variant_info.args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, _)| format!(\"__{}\", i))\n-                        .collect()\n+        ty::VariantKind::Dict => {\n+            variant.fields\n+                   .iter()\n+                   .map(|f| f.name.to_string())\n+                   .collect()\n         }\n     };\n \n@@ -1565,7 +1574,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n-    let variants = cx.tcx().enum_variants(enum_def_id);\n+    let variants = &enum_type.ty_adt_def().unwrap().variants;\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1667,7 +1676,6 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n             type_rep: type_rep.clone(),\n-            variants: variants,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,"}, {"sha": "120134800b000852e2ff74fac34d16a2b84a28f5", "filename": "src/librustc_trans/trans/debuginfo/type_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftype_names.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -54,9 +54,9 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyUint(ast::TyU64)  => output.push_str(\"u64\"),\n         ty::TyFloat(ast::TyF32) => output.push_str(\"f32\"),\n         ty::TyFloat(ast::TyF64) => output.push_str(\"f64\"),\n-        ty::TyStruct(def_id, substs) |\n-        ty::TyEnum(def_id, substs) => {\n-            push_item_name(cx, def_id, qualified, output);\n+        ty::TyStruct(def, substs) |\n+        ty::TyEnum(def, substs) => {\n+            push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);\n         },\n         ty::TyTuple(ref component_types) => {"}, {"sha": "c5043f867ded09d3e939e697eb9c1ddd84760d7c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 63, "deletions": 140, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -68,7 +68,6 @@ use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::glue;\n use trans::machine;\n use trans::meth;\n-use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::cast::{CastKind, CastTy};\n@@ -708,43 +707,42 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &ast::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::Field<'tcx>]) -> usize,\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &VariantInfo<'tcx>) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n     let bare_ty = base_datum.ty;\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n-    with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n-        let ix = get_idx(bcx.tcx(), field_tys);\n-        let d = base_datum.get_element(\n-            bcx,\n-            field_tys[ix].mt.ty,\n-            |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n-\n-        if type_is_sized(bcx.tcx(), d.ty) {\n-            DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n-        } else {\n-            let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n-            Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n-            let info = Load(bcx, get_len(bcx, base_datum.val));\n-            Store(bcx, info, get_len(bcx, scratch.val));\n+    let vinfo = VariantInfo::from_ty(bcx.tcx(), bare_ty, None);\n \n-            // Always generate an lvalue datum, because this pointer doesn't own\n-            // the data and cleanup is scheduled elsewhere.\n-            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n-        }\n-    })\n+    let ix = get_idx(bcx.tcx(), &vinfo);\n+    let d = base_datum.get_element(\n+        bcx,\n+        vinfo.fields[ix].1,\n+        |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix));\n \n+    if type_is_sized(bcx.tcx(), d.ty) {\n+        DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n+    } else {\n+        let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n+        Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n+        let info = Load(bcx, get_len(bcx, base_datum.val));\n+        Store(bcx, info, get_len(bcx, scratch.val));\n+\n+        // Always generate an lvalue datum, because this pointer doesn't own\n+        // the data and cleanup is scheduled elsewhere.\n+        DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n+    }\n }\n \n /// Translates `base.field`.\n fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                base: &ast::Expr,\n                                field: ast::Name)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |tcx, field_tys| tcx.field_idx_strict(field, field_tys))\n+    trans_field(bcx, base, |_, vinfo| vinfo.field_index(field))\n }\n \n /// Translates `base.<idx>`.\n@@ -1125,7 +1123,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              None,\n                              expr.span,\n                              expr.id,\n-                             tcx.mk_struct(did, tcx.mk_substs(substs)),\n+                             tcx.mk_struct(tcx.lookup_adt_def(did),\n+                                           tcx.mk_substs(substs)),\n                              dest)\n             } else {\n                 tcx.sess.span_bug(expr.span,\n@@ -1248,8 +1247,8 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match def {\n         def::DefVariant(tid, vid, _) => {\n-            let variant_info = bcx.tcx().enum_variant_with_id(tid, vid);\n-            if !variant_info.args.is_empty() {\n+            let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+            if let ty::VariantKind::Tuple = variant.kind() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n                                                 ExprId(ref_expr.id),\n@@ -1260,15 +1259,14 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &*repr, lldest,\n-                                     variant_info.disr_val);\n+                adt::trans_set_discr(bcx, &*repr, lldest, variant.disr_val);\n                 return bcx;\n             }\n         }\n         def::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n-                ty::TyStruct(did, _) if bcx.tcx().has_dtor(did) => {\n+                ty::TyStruct(def, _) if def.has_dtor(bcx.tcx()) => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_set_discr(bcx, &*repr, lldest, 0);\n                 }\n@@ -1361,71 +1359,6 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Helper for enumerating the field types of structs, enums, or records. The optional node ID here\n-/// is the node ID of the path identifying the enum variant in use. If none, this cannot possibly\n-/// an enum variant (so, if it is and `node_id_opt` is none, this function panics).\n-pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  node_id_opt: Option<ast::NodeId>,\n-                                  op: F)\n-                                  -> R where\n-    F: FnOnce(ty::Disr, &[ty::Field<'tcx>]) -> R,\n-{\n-    match ty.sty {\n-        ty::TyStruct(did, substs) => {\n-            let fields = tcx.struct_fields(did, substs);\n-            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-            op(0, &fields[..])\n-        }\n-\n-        ty::TyTuple(ref v) => {\n-            let fields: Vec<_> = v.iter().enumerate().map(|(i, &f)| {\n-                ty::Field {\n-                    name: token::intern(&i.to_string()),\n-                    mt: ty::TypeAndMut {\n-                        ty: f,\n-                        mutbl: ast::MutImmutable\n-                    }\n-                }\n-            }).collect();\n-            op(0, &fields)\n-        }\n-\n-        ty::TyEnum(_, substs) => {\n-            // We want the *variant* ID here, not the enum ID.\n-            match node_id_opt {\n-                None => {\n-                    tcx.sess.bug(&format!(\n-                        \"cannot get field types from the enum type {:?} \\\n-                         without a node ID\",\n-                        ty));\n-                }\n-                Some(node_id) => {\n-                    let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n-                    match def {\n-                        def::DefVariant(enum_id, variant_id, _) => {\n-                            let variant_info = tcx.enum_variant_with_id(enum_id, variant_id);\n-                            let fields = tcx.struct_fields(variant_id, substs);\n-                            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-                            op(variant_info.disr_val, &fields[..])\n-                        }\n-                        _ => {\n-                            tcx.sess.bug(\"resolve didn't map this expr to a \\\n-                                          variant ID\")\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        _ => {\n-            tcx.sess.bug(&format!(\n-                \"cannot get field types from the type {:?}\",\n-                ty));\n-        }\n-    }\n-}\n-\n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[ast::Field],\n                             base: Option<&ast::Expr>,\n@@ -1436,52 +1369,42 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rec\");\n \n     let tcx = bcx.tcx();\n-    with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base = vec![true; field_tys.len()];\n-\n-        let numbered_fields = fields.iter().map(|field| {\n-            let opt_pos =\n-                field_tys.iter().position(|field_ty|\n-                                          field_ty.name == field.ident.node.name);\n-            let result = match opt_pos {\n-                Some(i) => {\n-                    need_base[i] = false;\n-                    (i, &*field.expr)\n-                }\n-                None => {\n-                    tcx.sess.span_bug(field.span,\n-                                      \"Couldn't find field in struct type\")\n+    let vinfo = VariantInfo::of_node(tcx, ty, expr_id);\n+\n+    let mut need_base = vec![true; vinfo.fields.len()];\n+\n+    let numbered_fields = fields.iter().map(|field| {\n+        let pos = vinfo.field_index(field.ident.node.name);\n+        need_base[pos] = false;\n+        (pos, &*field.expr)\n+    }).collect::<Vec<_>>();\n+\n+    let optbase = match base {\n+        Some(base_expr) => {\n+            let mut leftovers = Vec::new();\n+            for (i, b) in need_base.iter().enumerate() {\n+                if *b {\n+                    leftovers.push((i, vinfo.fields[i].1));\n                 }\n-            };\n-            result\n-        }).collect::<Vec<_>>();\n-        let optbase = match base {\n-            Some(base_expr) => {\n-                let mut leftovers = Vec::new();\n-                for (i, b) in need_base.iter().enumerate() {\n-                    if *b {\n-                        leftovers.push((i, field_tys[i].mt.ty));\n-                    }\n-                }\n-                Some(StructBaseInfo {expr: base_expr,\n-                                     fields: leftovers })\n             }\n-            None => {\n-                if need_base.iter().any(|b| *b) {\n-                    tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n-                }\n-                None\n+            Some(StructBaseInfo {expr: base_expr,\n+                                 fields: leftovers })\n+        }\n+        None => {\n+            if need_base.iter().any(|b| *b) {\n+                tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n             }\n-        };\n+            None\n+        }\n+    };\n \n-        trans_adt(bcx,\n-                  ty,\n-                  discr,\n-                  &numbered_fields,\n-                  optbase,\n-                  dest,\n-                  DebugLoc::At(expr_id, expr_span))\n-    })\n+    trans_adt(bcx,\n+              ty,\n+              vinfo.discr,\n+              &numbered_fields,\n+              optbase,\n+              dest,\n+              DebugLoc::At(expr_id, expr_span))\n }\n \n /// Information that `trans_adt` needs in order to fill in the fields\n@@ -1530,7 +1453,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // panic occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n-    if ty.is_simd(bcx.tcx()) {\n+    if ty.is_simd() {\n         // Issue 23112: The original logic appeared vulnerable to same\n         // order-of-eval bug. But, SIMD values are tuple-structs;\n         // i.e. functional record update (FRU) syntax is unavailable.\n@@ -1774,7 +1697,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_eager_binop\");\n \n     let tcx = bcx.tcx();\n-    let is_simd = lhs_t.is_simd(tcx);\n+    let is_simd = lhs_t.is_simd();\n     let intype = if is_simd {\n         lhs_t.simd_type(tcx)\n     } else {\n@@ -2125,8 +2048,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let r_t_in = CastTy::from_ty(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n-    let r_t_out = CastTy::from_ty(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n+    let r_t_in = CastTy::from_ty(t_in).expect(\"bad input type for cast\");\n+    let r_t_out = CastTy::from_ty(t_out).expect(\"bad output type for cast\");\n \n     let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n         let repr = adt::represent_type(ccx, t_in);\n@@ -2579,7 +2502,7 @@ fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n     let tcx = bcx.tcx();\n-    let is_simd = lhs_t.is_simd(tcx);\n+    let is_simd = lhs_t.is_simd();\n     let intype = if is_simd {\n         lhs_t.simd_type(tcx)\n     } else {"}, {"sha": "225ff52a63c5915c99c08abfef507698f8f18e98", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -449,7 +449,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n     if !tcx.sess.features.borrow().simd_ffi {\n         let check = |ast_ty: &ast::Ty, ty: ty::Ty| {\n-            if ty.is_simd(tcx) {\n+            if ty.is_simd() {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\","}, {"sha": "cf3cde8907f7f3e2b4a72190295e38eb6b64b918", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -415,11 +415,11 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n         return (size, align);\n     }\n     match t.sty {\n-        ty::TyStruct(id, substs) => {\n+        ty::TyStruct(def, substs) => {\n             let ccx = bcx.ccx();\n             // First get the size of all statically known fields.\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n-            assert!(!t.is_simd(bcx.tcx()));\n+            assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n             let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n             debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n@@ -432,9 +432,8 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let fields = bcx.tcx().struct_fields(id, substs);\n-            let last_field = fields[fields.len()-1];\n-            let field_ty = last_field.mt.ty;\n+            let last_field = def.struct_variant().fields.last().unwrap();\n+            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             let dbloc = DebugLoc::None;\n@@ -562,27 +561,27 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 })\n             }\n         }\n-        ty::TyStruct(did, substs) | ty::TyEnum(did, substs) => {\n+        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n             let tcx = bcx.tcx();\n-            match (tcx.ty_dtor(did), skip_dtor) {\n+            match (tcx.ty_dtor(def.did), skip_dtor) {\n                 (ty::TraitDtor(dtor, true), false) => {\n                     // FIXME(16758) Since the struct is unsized, it is hard to\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n                     if type_is_sized(bcx.tcx(), t) {\n-                        trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n+                        trans_struct_drop_flag(bcx, t, v0, dtor, def.did, substs)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\", t));\n-                        trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                        trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n                     }\n                 }\n                 (ty::TraitDtor(dtor, false), false) => {\n-                    trans_struct_drop(bcx, t, v0, dtor, did, substs)\n+                    trans_struct_drop(bcx, t, v0, dtor, def.did, substs)\n                 }\n                 (ty::NoDtor, _) | (_, true) => {\n                     // No dtor? Just the default case"}, {"sha": "01bfc51a5c0de20134551b7e5fd11498ef908f81", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -100,30 +100,32 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n-          let mut my_id = 0;\n-          match item.node {\n-            ast::ItemEnum(_, _) => {\n-              let vs_here = ccx.tcx().enum_variants(local_def(item.id));\n-              let vs_there = ccx.tcx().enum_variants(parent_id);\n-              for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n-                  if there.id == fn_id { my_id = here.id.node; }\n-                  ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n-              }\n-            }\n-            ast::ItemStruct(ref struct_def, _) => {\n-              match struct_def.ctor_id {\n-                None => {}\n-                Some(ctor_id) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n-                    my_id = ctor_id;\n+            let mut my_id = 0;\n+            match item.node {\n+                ast::ItemEnum(ref ast_def, _) => {\n+                    let ast_vs = &ast_def.variants;\n+                    let ty_vs = &ccx.tcx().lookup_adt_def(parent_id).variants;\n+                    assert_eq!(ast_vs.len(), ty_vs.len());\n+                    for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n+                        if ty_v.did == fn_id { my_id = ast_v.node.id; }\n+                        ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.id));\n+                    }\n                 }\n-              }\n-            }\n-            _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n+                ast::ItemStruct(ref struct_def, _) => {\n+                    match struct_def.ctor_id {\n+                        None => ccx.sess().bug(\"instantiate_inline: called on a \\\n+                                                non-tuple struct\"),\n+                        Some(ctor_id) => {\n+                            ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n+                            my_id = ctor_id;\n+                        }\n+                    }\n+                }\n+                _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n-          }\n-          trans_item(ccx, &**item);\n-          my_id\n+            }\n+            trans_item(ccx, &**item);\n+            my_id\n         }\n         csearch::FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\"}, {"sha": "c2d1d19935a034208efeb4ba351ccecd9c69e838", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -29,7 +29,6 @@ use middle::ty::{self, HasTypeFlags, Ty};\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n@@ -192,24 +191,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         ast_map::NodeVariant(v) => {\n-            let parent = ccx.tcx().map.get_parent(fn_id.node);\n-            let tvs = ccx.tcx().enum_variants(local_def(parent));\n-            let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n+            let variant = inlined_variant_def(ccx, fn_id.node);\n+            assert_eq!(v.node.name.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            match v.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    trans_enum_variant(ccx,\n-                                       parent,\n-                                       &*v,\n-                                       &args[..],\n-                                       this_tv.disr_val,\n-                                       psubsts,\n-                                       d);\n-                }\n-                ast::StructVariantKind(_) =>\n-                    ccx.sess().bug(\"can't monomorphize struct variants\"),\n-            }\n+            trans_enum_variant(ccx, fn_id.node, variant.disr_val, psubsts, d);\n             d\n         }\n         ast_map::NodeImplItem(impl_item) => {\n@@ -255,7 +241,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n             base::trans_tuple_struct(ccx,\n-                                     &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -302,6 +287,16 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n     normalize_associated_type(tcx, &substituted)\n }\n \n+\n+/// Returns the normalized type of a struct field\n+pub fn field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      param_substs: &Substs<'tcx>,\n+                      f: ty::FieldDef<'tcx>)\n+                      -> Ty<'tcx>\n+{\n+    normalize_associated_type(tcx, &f.ty(tcx, param_substs))\n+}\n+\n /// Removes associated types, if any. Since this during\n /// monomorphization, we know that only concrete types are involved,\n /// and hence we can be sure that all associated types will be"}, {"sha": "0b969360f537e04aff52cdfc9b3dcb32c0650c27", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -222,7 +222,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::TyStruct(..) => {\n-            if t.is_simd(cx.tcx()) {\n+            if t.is_simd() {\n                 let llet = type_of(cx, t.simd_type(cx.tcx()));\n                 let n = t.simd_size(cx.tcx()) as u64;\n                 ensure_array_fits_in_address_space(cx, llet, n, t);\n@@ -333,14 +333,14 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyInt(t) => Type::int_from_ty(cx, t),\n       ty::TyUint(t) => Type::uint_from_ty(cx, t),\n       ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-      ty::TyEnum(did, ref substs) => {\n+      ty::TyEnum(def, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache. This\n           // avoids creating more than one copy of the enum when one\n           // of the enum's variants refers to the enum itself.\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n-          let name = llvm_type_name(cx, did, tps);\n+          let name = llvm_type_name(cx, def.did, tps);\n           adt::incomplete_type_of(cx, &*repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n@@ -403,8 +403,8 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)\n       }\n-      ty::TyStruct(did, ref substs) => {\n-          if t.is_simd(cx.tcx()) {\n+      ty::TyStruct(def, ref substs) => {\n+          if t.is_simd() {\n               let llet = in_memory_type_of(cx, t.simd_type(cx.tcx()));\n               let n = t.simd_size(cx.tcx()) as u64;\n               ensure_array_fits_in_address_space(cx, llet, n, t);\n@@ -415,7 +415,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n-              let name = llvm_type_name(cx, did, tps);\n+              let name = llvm_type_name(cx, def.did, tps);\n               adt::incomplete_type_of(cx, &*repr, &name[..])\n           }\n       }\n@@ -436,7 +436,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n-                if !t.is_simd(cx.tcx()) => {\n+                if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &*repr, &mut llty);\n         }"}, {"sha": "883e3659720a6c80a222082d2f6c635b2667dcb3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -528,7 +528,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let (enum_def_id, variant_def_id) = match def {\n+    let (adt_def, variant) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0168,\n@@ -543,11 +543,11 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         _ => {\n             let def_type = tcx.lookup_item_type(def.def_id());\n             match def_type.ty.sty {\n-                ty::TyStruct(struct_def_id, _) =>\n-                    (struct_def_id, struct_def_id),\n-                ty::TyEnum(enum_def_id, _)\n-                    if def == def::DefVariant(enum_def_id, def.def_id(), true) =>\n-                    (enum_def_id, def.def_id()),\n+                ty::TyStruct(struct_def, _) =>\n+                    (struct_def, struct_def.struct_variant()),\n+                ty::TyEnum(enum_def, _)\n+                    if def == def::DefVariant(enum_def.did, def.def_id(), true) =>\n+                    (enum_def, enum_def.variant_of_def(def)),\n                 _ => {\n                     let name = pprust::path_to_string(path);\n                     span_err!(tcx.sess, pat.span, E0163,\n@@ -565,8 +565,8 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n \n     instantiate_path(pcx.fcx,\n                      &path.segments,\n-                     tcx.lookup_item_type(enum_def_id),\n-                     &tcx.lookup_predicates(enum_def_id),\n+                     adt_def.type_scheme(tcx),\n+                     &adt_def.predicates(tcx),\n                      None,\n                      def,\n                      pat.span,\n@@ -581,9 +581,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n \n-    let struct_fields = tcx.struct_fields(variant_def_id, &item_substs);\n-    check_struct_pat_fields(pcx, pat.span, fields, &struct_fields,\n-                            variant_def_id, etc);\n+    check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);\n }\n \n pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n@@ -647,22 +645,26 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n-        ty::TyEnum(enum_def_id, expected_substs)\n-            if def == def::DefVariant(enum_def_id, def.def_id(), false) =>\n+        ty::TyEnum(enum_def, expected_substs)\n+            if def == def::DefVariant(enum_def.did, def.def_id(), false) =>\n         {\n-            let variant = tcx.enum_variant_with_id(enum_def_id, def.def_id());\n-            (variant.args.iter()\n-                         .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n-                         .collect(),\n+            let variant = enum_def.variant_of_def(def);\n+            (variant.fields\n+                    .iter()\n+                    .map(|f| fcx.instantiate_type_scheme(pat.span,\n+                                                         expected_substs,\n+                                                         &f.unsubst_ty()))\n+                    .collect(),\n              \"variant\")\n         }\n-        ty::TyStruct(struct_def_id, expected_substs) => {\n-            let struct_fields = tcx.struct_fields(struct_def_id, expected_substs);\n-            (struct_fields.iter()\n-                          .map(|field| fcx.instantiate_type_scheme(pat.span,\n-                                                                   expected_substs,\n-                                                                   &field.mt.ty))\n-                          .collect(),\n+        ty::TyStruct(struct_def, expected_substs) => {\n+            (struct_def.struct_variant()\n+                       .fields\n+                       .iter()\n+                       .map(|f| fcx.instantiate_type_scheme(pat.span,\n+                                                            expected_substs,\n+                                                            &f.unsubst_ty()))\n+                       .collect(),\n              \"struct\")\n         }\n         _ => {\n@@ -715,23 +717,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n                                          fields: &'tcx [Spanned<ast::FieldPat>],\n-                                         struct_fields: &[ty::Field<'tcx>],\n-                                         struct_id: ast::DefId,\n+                                         variant: ty::VariantDef<'tcx>,\n+                                         substs: &Substs<'tcx>,\n                                          etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the struct fields' types.\n-    let field_type_map = struct_fields\n+    let field_map = variant.fields\n         .iter()\n-        .map(|field| (field.name, field.mt.ty))\n+        .map(|field| (field.name, field))\n         .collect::<FnvHashMap<_, _>>();\n \n     // Keep track of which fields have already appeared in the pattern.\n     let mut used_fields = FnvHashMap();\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields {\n-        let field_type = match used_fields.entry(field.ident.name) {\n+        let field_ty = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\",\n@@ -743,25 +745,24 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n             Vacant(vacant) => {\n                 vacant.insert(span);\n-                field_type_map.get(&field.ident.name).cloned()\n+                field_map.get(&field.ident.name)\n+                    .map(|f| pcx.fcx.field_ty(span, f, substs))\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n-                            tcx.item_path_str(struct_id),\n+                            tcx.item_path_str(variant.did),\n                             field.ident);\n                         tcx.types.err\n                     })\n             }\n         };\n \n-        let field_type = pcx.fcx.normalize_associated_types_in(span, &field_type);\n-\n-        check_pat(pcx, &*field.pat, field_type);\n+        check_pat(pcx, &*field.pat, field_ty);\n     }\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        for field in struct_fields\n+        for field in variant.fields\n             .iter()\n             .filter(|field| !used_fields.contains_key(&field.name)) {\n             span_err!(tcx.sess, span, E0027,"}, {"sha": "b6ba62e4f09658e89f0ab6ef7bd6cc4fe679f5fd", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -79,10 +79,11 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match t.sty {\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n-        ty::TyStruct(did, substs) => {\n-            match fcx.tcx().struct_fields(did, substs).pop() {\n+        ty::TyStruct(def, substs) => {\n+            // FIXME(arielb1): do some kind of normalization\n+            match def.struct_variant().fields.last() {\n                 None => None,\n-                Some(f) => unsize_kind(fcx, f.mt.ty)\n+                Some(f) => unsize_kind(fcx, f.ty(fcx.tcx(), substs))\n             }\n         }\n         // We should really try to normalize here.\n@@ -223,8 +224,8 @@ impl<'tcx> CastCheck<'tcx> {\n         use middle::cast::IntTy::*;\n         use middle::cast::CastTy::*;\n \n-        let (t_from, t_cast) = match (CastTy::from_ty(fcx.tcx(), self.expr_ty),\n-                                      CastTy::from_ty(fcx.tcx(), self.cast_ty)) {\n+        let (t_from, t_cast) = match (CastTy::from_ty(self.expr_ty),\n+                                      CastTy::from_ty(self.cast_ty)) {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             _ => {\n                 return Err(CastError::NonScalar)"}, {"sha": "39e67beab583d18c8d77e88dcd302efa02a1b23c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 39, "deletions": 150, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -18,6 +18,7 @@ use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n use syntax::codemap::{self, Span};\n+use syntax::parse::token::special_idents;\n \n /// check_drop_impl confirms that the Drop implementation identfied by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -41,18 +42,18 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n                          ty: dtor_self_type } = tcx.lookup_item_type(drop_impl_did);\n     let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n-        ty::TyEnum(self_type_did, self_to_impl_substs) |\n-        ty::TyStruct(self_type_did, self_to_impl_substs) => {\n+        ty::TyEnum(adt_def, self_to_impl_substs) |\n+        ty::TyStruct(adt_def, self_to_impl_substs) => {\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,\n                                                                &dtor_self_type,\n-                                                               self_type_did));\n+                                                               adt_def.did));\n \n             ensure_drop_predicates_are_implied_by_item_defn(tcx,\n                                                             drop_impl_did,\n                                                             &dtor_predicates,\n-                                                            self_type_did,\n+                                                            adt_def.did,\n                                                             self_to_impl_substs)\n         }\n         _ => {\n@@ -285,25 +286,26 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                     // no need for an additional note if the overflow\n                     // was somehow on the root.\n                 }\n-                TypeContext::EnumVariant { def_id, variant, arg_index } => {\n-                    // FIXME (pnkfelix): eventually lookup arg_name\n-                    // for the given index on struct variants.\n-                    span_note!(\n-                        rcx.tcx().sess,\n-                        span,\n-                        \"overflowed on enum {} variant {} argument {} type: {}\",\n-                        tcx.item_path_str(def_id),\n-                        variant,\n-                        arg_index,\n-                        detected_on_typ);\n-                }\n-                TypeContext::Struct { def_id, field } => {\n+                TypeContext::ADT { def_id, variant, field, field_index } => {\n+                    let adt = tcx.lookup_adt_def(def_id);\n+                    let variant_name = match adt.adt_kind() {\n+                        ty::AdtKind::Enum => format!(\"enum {} variant {}\",\n+                                                     tcx.item_path_str(def_id),\n+                                                     variant),\n+                        ty::AdtKind::Struct => format!(\"struct {}\",\n+                                                       tcx.item_path_str(def_id))\n+                    };\n+                    let field_name = if field == special_idents::unnamed_field.name {\n+                        format!(\"#{}\", field_index)\n+                    } else {\n+                        format!(\"`{}`\", field)\n+                    };\n                     span_note!(\n                         rcx.tcx().sess,\n                         span,\n-                        \"overflowed on struct {} field {} type: {}\",\n-                        tcx.item_path_str(def_id),\n-                        field,\n+                        \"overflowed on {} field {} type: {}\",\n+                        variant_name,\n+                        field_name,\n                         detected_on_typ);\n                 }\n             }\n@@ -318,14 +320,11 @@ enum Error<'tcx> {\n #[derive(Copy, Clone)]\n enum TypeContext {\n     Root,\n-    EnumVariant {\n+    ADT {\n         def_id: ast::DefId,\n         variant: ast::Name,\n-        arg_index: usize,\n-    },\n-    Struct {\n-        def_id: ast::DefId,\n         field: ast::Name,\n+        field_index: usize\n     }\n }\n \n@@ -357,8 +356,6 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n         return Err(Error::Overflow(context, ty))\n     }\n \n-    let opt_phantom_data_def_id = tcx.lang_items.phantom_data();\n-\n     if !cx.breadcrumbs.insert(ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                {}ty: {} scope: {:?} - cached\",\n@@ -399,7 +396,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     // type parameters are unbounded.  If both conditions hold, we\n     // simply skip the `type_must_outlive` call entirely (but\n     // resume the recursive checking of the type-substructure).\n-    if has_dtor_of_interest(tcx, ty, cx.span) {\n+    if has_dtor_of_interest(tcx, ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n                 {}ty: {} - is a dtorck type!\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n@@ -432,46 +429,30 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(did, substs) if Some(did) == opt_phantom_data_def_id => {\n+        ty::TyStruct(def, substs) if def.is_phantom_data() => {\n             // PhantomData<T> - behaves identically to T\n             let ity = *substs.types.get(subst::TypeSpace, 0);\n             iterate_over_potentially_unsafe_regions_in_type(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(did, substs) => {\n-            let fields = tcx.lookup_struct_fields(did);\n-            for field in &fields {\n-                let fty = tcx.lookup_field_type(did, field.id, substs);\n-                let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n-                    cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n-                try!(iterate_over_potentially_unsafe_regions_in_type(\n-                    cx,\n-                    TypeContext::Struct {\n-                        def_id: did,\n-                        field: field.name,\n-                    },\n-                    fty,\n-                    depth+1))\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyEnum(did, substs) => {\n-            let all_variant_info = tcx.substd_enum_variants(did, substs);\n-            for variant_info in &all_variant_info {\n-                for (i, fty) in variant_info.args.iter().enumerate() {\n+        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            let did = def.did;\n+            for variant in &def.variants {\n+                for (i, field) in variant.fields.iter().enumerate() {\n+                    let fty = field.ty(tcx, substs);\n                     let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n                         cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n                     try!(iterate_over_potentially_unsafe_regions_in_type(\n                         cx,\n-                        TypeContext::EnumVariant {\n+                        TypeContext::ADT {\n                             def_id: did,\n-                            variant: variant_info.name,\n-                            arg_index: i,\n+                            field: field.name,\n+                            variant: variant.name,\n+                            field_index: i\n                         },\n                         fty,\n-                        depth+1));\n+                        depth+1))\n                 }\n             }\n             Ok(())\n@@ -510,102 +491,10 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n }\n \n fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              ty: ty::Ty<'tcx>,\n-                              span: Span) -> bool {\n+                              ty: ty::Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyEnum(def_id, _) | ty::TyStruct(def_id, _) => {\n-            let dtor_method_did = match tcx.destructor_for_type.borrow().get(&def_id) {\n-                Some(def_id) => *def_id,\n-                None => {\n-                    debug!(\"ty: {:?} has no dtor, and thus isn't a dropck type\", ty);\n-                    return false;\n-                }\n-            };\n-            let impl_did = tcx.impl_of_method(dtor_method_did)\n-                .unwrap_or_else(|| {\n-                    tcx.sess.span_bug(\n-                        span, \"no Drop impl found for drop method\")\n-                });\n-\n-            let dtor_typescheme = tcx.lookup_item_type(impl_did);\n-            let dtor_generics = dtor_typescheme.generics;\n-\n-            let mut has_pred_of_interest = false;\n-\n-            let mut seen_items = Vec::new();\n-            let mut items_to_inspect = vec![impl_did];\n-            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n-                if seen_items.contains(&item_def_id) {\n-                    continue;\n-                }\n-\n-                for pred in tcx.lookup_predicates(item_def_id).predicates {\n-                    let result = match pred {\n-                        ty::Predicate::Equate(..) |\n-                        ty::Predicate::RegionOutlives(..) |\n-                        ty::Predicate::TypeOutlives(..) |\n-                        ty::Predicate::Projection(..) => {\n-                            // For now, assume all these where-clauses\n-                            // may give drop implementation capabilty\n-                            // to access borrowed data.\n-                            true\n-                        }\n-\n-                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                            let def_id = t_pred.trait_ref.def_id;\n-                            if tcx.trait_items(def_id).len() != 0 {\n-                                // If trait has items, assume it adds\n-                                // capability to access borrowed data.\n-                                true\n-                            } else {\n-                                // Trait without items is itself\n-                                // uninteresting from POV of dropck.\n-                                //\n-                                // However, may have parent w/ items;\n-                                // so schedule checking of predicates,\n-                                items_to_inspect.push(def_id);\n-                                // and say \"no capability found\" for now.\n-                                false\n-                            }\n-                        }\n-                    };\n-\n-                    if result {\n-                        has_pred_of_interest = true;\n-                        debug!(\"ty: {:?} has interesting dtor due to generic preds, e.g. {:?}\",\n-                               ty, pred);\n-                        break 'items;\n-                    }\n-                }\n-\n-                seen_items.push(item_def_id);\n-            }\n-\n-            // In `impl<'a> Drop ...`, we automatically assume\n-            // `'a` is meaningful and thus represents a bound\n-            // through which we could reach borrowed data.\n-            //\n-            // FIXME (pnkfelix): In the future it would be good to\n-            // extend the language to allow the user to express,\n-            // in the impl signature, that a lifetime is not\n-            // actually used (something like `where 'a: ?Live`).\n-            let has_region_param_of_interest =\n-                dtor_generics.has_region_params(subst::TypeSpace);\n-\n-            let has_dtor_of_interest =\n-                has_region_param_of_interest ||\n-                has_pred_of_interest;\n-\n-            if has_dtor_of_interest {\n-                debug!(\"ty: {:?} has interesting dtor, due to \\\n-                        region params: {} or pred: {}\",\n-                       ty,\n-                       has_region_param_of_interest,\n-                       has_pred_of_interest);\n-            } else {\n-                debug!(\"ty: {:?} has dtor, but it is uninteresting\", ty);\n-            }\n-            has_dtor_of_interest\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n+            def.is_dtorck(tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);"}, {"sha": "2ff40b3590d29fe39e3fd2c134d1b4a0e8af5d42", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -286,10 +286,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 self.assemble_inherent_candidates_from_object(self_ty, data);\n                 self.assemble_inherent_impl_candidates_for_type(data.principal_def_id());\n             }\n-            ty::TyEnum(did, _) |\n-            ty::TyStruct(did, _) |\n-            ty::TyClosure(did, _) => {\n-                self.assemble_inherent_impl_candidates_for_type(did);\n+            ty::TyEnum(def, _) |\n+            ty::TyStruct(def, _) => {\n+                self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyBox(_) => {\n                 if let Some(box_did) = self.tcx().lang_items.owned_box() {"}, {"sha": "15cc5ee6eb801730a815efed48220e0bbe3ce677", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -65,10 +65,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 None);\n \n             // If the item has the name of a field, give a help note\n-            if let (&ty::TyStruct(did, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                let fields = cx.lookup_struct_fields(did);\n-\n-                if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n+            if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n+                if let Some(field) = def.struct_variant().find_field_named(item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n                         Ok(expr_string) => expr_string,\n                         _ => \"s\".into() // Default to a generic placeholder for the\n@@ -89,7 +87,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     // Determine if the field can be used as a function in some way\n-                    let field_ty = cx.lookup_field_type(did, field.id, substs);\n+                    let field_ty = field.ty(cx, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n                         let infcx = fcx.infcx();\n                         infcx.probe(|_| {\n@@ -303,7 +301,7 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rcvr_expr: Option<&ast::Expr>) -> bool {\n     fn is_local(ty: Ty) -> bool {\n         match ty.sty {\n-            ty::TyEnum(did, _) | ty::TyStruct(did, _) => ast_util::is_local(did),\n+            ty::TyEnum(def, _) | ty::TyStruct(def, _) => ast_util::is_local(def.did),\n \n             ty::TyTrait(ref tr) => ast_util::is_local(tr.principal_def_id()),\n "}, {"sha": "6221134afd38a490b737f0deecbf0f95f9df6c7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 114, "deletions": 167, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -1674,34 +1674,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Only for fields! Returns <none> for methods>\n-    // Indifferent to privacy flags\n-    pub fn lookup_field_ty(&self,\n-                           span: Span,\n-                           class_id: ast::DefId,\n-                           items: &[ty::FieldTy],\n-                           fieldname: ast::Name,\n-                           substs: &subst::Substs<'tcx>)\n-                           -> Option<Ty<'tcx>>\n-    {\n-        let o_field = items.iter().find(|f| f.name == fieldname);\n-        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n-               .map(|t| self.normalize_associated_types_in(span, &t))\n-    }\n-\n-    pub fn lookup_tup_field_ty(&self,\n-                               span: Span,\n-                               class_id: ast::DefId,\n-                               items: &[ty::FieldTy],\n-                               idx: usize,\n-                               substs: &subst::Substs<'tcx>)\n-                               -> Option<Ty<'tcx>>\n+    // FIXME(arielb1): use this instead of field.ty everywhere\n+    pub fn field_ty(&self,\n+                    span: Span,\n+                    field: ty::FieldDef<'tcx>,\n+                    substs: &Substs<'tcx>)\n+                    -> Ty<'tcx>\n     {\n-        let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n-        o_field.map(|f| self.tcx().lookup_field_type(class_id, f.id, substs))\n-               .map(|t| self.normalize_associated_types_in(span, &t))\n+        self.normalize_associated_types_in(span,\n+                                           &field.ty(self.tcx(), substs))\n     }\n \n+    // Only for fields! Returns <none> for methods>\n+    // Indifferent to privacy flags\n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n         for cast in deferred_cast_checks.drain(..) {\n@@ -2878,11 +2863,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::TyStruct(base_id, substs) => {\n+                    ty::TyStruct(base_def, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n-                        let fields = tcx.lookup_struct_fields(base_id);\n-                        fcx.lookup_field_ty(expr.span, base_id, &fields[..],\n-                                            field.node.name, &(*substs))\n+                        base_def.struct_variant()\n+                                .find_field_named(field.node.name)\n+                                .map(|f| fcx.field_ty(expr.span, f, substs))\n                     }\n                     _ => None\n                 }\n@@ -2919,32 +2904,31 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             actual)\n                 },\n                 expr_t, None);\n-            if let ty::TyStruct(did, _) = expr_t.sty {\n-                suggest_field_names(did, field, tcx, vec![]);\n+            if let ty::TyStruct(def, _) = expr_t.sty {\n+                suggest_field_names(def.struct_variant(), field, tcx, vec![]);\n             }\n         }\n \n         fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n-    fn suggest_field_names<'tcx>(id : DefId,\n-                                 field : &ast::SpannedIdent,\n-                                 tcx : &ty::ctxt<'tcx>,\n+    fn suggest_field_names<'tcx>(variant: ty::VariantDef<'tcx>,\n+                                 field: &ast::SpannedIdent,\n+                                 tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n         let name = field.node.name.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let fields = tcx.lookup_struct_fields(id);\n         let mut best = None;\n-        for elem in &fields {\n+        for elem in &variant.fields {\n             let n = elem.name.as_str();\n             // ignore already set fields\n             if skip.iter().any(|x| *x == n) {\n                 continue;\n             }\n             // ignore private fields from non-local crates\n-            if id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n+            if variant.did.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n                 continue;\n             }\n             let dist = lev_distance(&n, &name);\n@@ -2965,7 +2949,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 lvalue_pref: LvaluePreference,\n                                 base: &'tcx ast::Expr,\n                                 idx: codemap::Spanned<usize>) {\n-        let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n@@ -2979,13 +2962,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n                 match base_t.sty {\n-                    ty::TyStruct(base_id, substs) => {\n-                        tuple_like = tcx.is_tuple_struct(base_id);\n+                    ty::TyStruct(base_def, substs) => {\n+                        tuple_like = base_def.struct_variant().is_tuple_struct();\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n-                            let fields = tcx.lookup_struct_fields(base_id);\n-                            fcx.lookup_tup_field_ty(expr.span, base_id, &fields[..],\n-                                                    idx.node, &(*substs))\n+                            base_def.struct_variant()\n+                                    .fields\n+                                    .get(idx.node)\n+                                    .map(|f| fcx.field_ty(expr.span, f, substs))\n                         } else {\n                             None\n                         }\n@@ -3025,75 +3009,63 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_error(expr.id);\n     }\n \n+    fn report_unknown_field<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      variant: ty::VariantDef<'tcx>,\n+                                      field: &ast::Field,\n+                                      skip_fields: &[ast::Field]) {\n+        fcx.type_error_message(\n+            field.ident.span,\n+            |actual| if let ty::TyEnum(..) = ty.sty {\n+                format!(\"struct variant `{}::{}` has no field named `{}`\",\n+                        actual, variant.name.as_str(), field.ident.node)\n+            } else {\n+                format!(\"structure `{}` has no field named `{}`\",\n+                        actual, field.ident.node)\n+            },\n+            ty,\n+            None);\n+        // prevent all specified fields from being suggested\n+        let skip_fields = skip_fields.iter().map(|ref x| x.ident.node.name.as_str());\n+        suggest_field_names(variant, &field.ident, fcx.tcx(), skip_fields.collect());\n+    }\n+\n+\n     fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                struct_ty: Ty<'tcx>,\n+                                                adt_ty: Ty<'tcx>,\n                                                 span: Span,\n-                                                class_id: ast::DefId,\n-                                                node_id: ast::NodeId,\n-                                                substitutions: &'tcx subst::Substs<'tcx>,\n-                                                field_types: &[ty::FieldTy],\n+                                                variant_id: ast::DefId,\n                                                 ast_fields: &'tcx [ast::Field],\n-                                                check_completeness: bool,\n-                                                enum_id_opt: Option<ast::DefId>)  {\n+                                                check_completeness: bool) -> Result<(),()> {\n         let tcx = fcx.ccx.tcx;\n+        let (adt_def, substs) = match adt_ty.sty {\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => (def, substs),\n+            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_struct_or_variant_fields\")\n+        };\n+        let variant = adt_def.variant_with_id(variant_id);\n \n-        let mut class_field_map = FnvHashMap();\n-        let mut fields_found = 0;\n-        for field in field_types {\n-            class_field_map.insert(field.name, (field.id, false));\n+        let mut remaining_fields = FnvHashMap();\n+        for field in &variant.fields {\n+            remaining_fields.insert(field.name, field);\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let mut expected_field_type = tcx.types.err;\n-\n-            let pair = class_field_map.get(&field.ident.node.name).cloned();\n-            match pair {\n-                None => {\n-                    fcx.type_error_message(\n-                        field.ident.span,\n-                        |actual| match enum_id_opt {\n-                            Some(enum_id) => {\n-                                let variant_type = tcx.enum_variant_with_id(enum_id,\n-                                                                            class_id);\n-                                format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                                        actual, variant_type.name.as_str(),\n-                                        field.ident.node)\n-                            }\n-                            None => {\n-                                format!(\"structure `{}` has no field named `{}`\",\n-                                        actual,\n-                                        field.ident.node)\n-                            }\n-                        },\n-                        struct_ty,\n-                        None);\n-                    // prevent all specified fields from being suggested\n-                    let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n-                    let actual_id = match enum_id_opt {\n-                        Some(_) => class_id,\n-                        None => struct_ty.ty_to_def_id().unwrap()\n-                    };\n-                    suggest_field_names(actual_id, &field.ident, tcx, skip_fields.collect());\n-                    error_happened = true;\n-                }\n-                Some((_, true)) => {\n+            let expected_field_type;\n+\n+            if let Some(v_field) = remaining_fields.remove(&field.ident.node.name) {\n+                expected_field_type = fcx.field_ty(field.span, v_field, substs);\n+            } else {\n+                error_happened = true;\n+                expected_field_type = tcx.types.err;\n+                if let Some(_) = variant.find_field_named(field.ident.node.name) {\n                     span_err!(fcx.tcx().sess, field.ident.span, E0062,\n                         \"field `{}` specified more than once\",\n                         field.ident.node);\n-                    error_happened = true;\n-                }\n-                Some((field_id, false)) => {\n-                    expected_field_type =\n-                        tcx.lookup_field_type(class_id, field_id, substitutions);\n-                    expected_field_type =\n-                        fcx.normalize_associated_types_in(\n-                            field.span, &expected_field_type);\n-                    class_field_map.insert(\n-                        field.ident.node.name, (field_id, true));\n-                    fields_found += 1;\n+                } else {\n+                    report_unknown_field(fcx, adt_ty, variant, field, ast_fields);\n                 }\n             }\n \n@@ -3102,63 +3074,46 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n         }\n \n-        if error_happened {\n-            fcx.write_error(node_id);\n-        }\n-\n-        if check_completeness && !error_happened {\n             // Make sure the programmer specified all the fields.\n-            assert!(fields_found <= field_types.len());\n-            if fields_found < field_types.len() {\n-                let mut missing_fields = Vec::new();\n-                for class_field in field_types {\n-                    let name = class_field.name;\n-                    let (_, seen) = *class_field_map.get(&name).unwrap();\n-                    if !seen {\n-                        missing_fields.push(\n-                            format!(\"`{}`\", name))\n-                    }\n-                }\n-\n-                span_err!(tcx.sess, span, E0063,\n-                    \"missing field{}: {}\",\n-                    if missing_fields.len() == 1 {\"\"} else {\"s\"},\n-                    missing_fields.join(\", \"));\n-             }\n+        if check_completeness &&\n+            !error_happened &&\n+            !remaining_fields.is_empty()\n+        {\n+            error_happened = true;\n+            span_err!(tcx.sess, span, E0063,\n+                      \"missing field{}: {}\",\n+                      if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n+                      remaining_fields.keys()\n+                                      .map(|n| format!(\"`{}`\", n))\n+                                      .collect::<Vec<_>>()\n+                                      .join(\", \"));\n         }\n \n-        if !error_happened {\n-            fcx.write_ty(node_id, fcx.ccx.tcx.mk_struct(class_id, substitutions));\n-        }\n+        if error_happened { Err(()) } else { Ok(()) }\n     }\n \n     fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                          id: ast::NodeId,\n                                          span: codemap::Span,\n-                                         class_id: ast::DefId,\n+                                         struct_def: ty::AdtDef<'tcx>,\n                                          fields: &'tcx [ast::Field],\n                                          base_expr: Option<&'tcx ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Generate the struct type.\n         let TypeAndSubsts {\n             ty: mut struct_type,\n-            substs: struct_substs\n-        } = fcx.instantiate_type(span, class_id);\n+            substs: _\n+        } = fcx.instantiate_type(span, struct_def.did);\n \n         // Look up and check the fields.\n-        let class_fields = tcx.lookup_struct_fields(class_id);\n-        check_struct_or_variant_fields(fcx,\n-                                       struct_type,\n-                                       span,\n-                                       class_id,\n-                                       id,\n-                                       fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       &class_fields[..],\n-                                       fields,\n-                                       base_expr.is_none(),\n-                                       None);\n-        if fcx.node_ty(id).references_error() {\n+        let res = check_struct_or_variant_fields(fcx,\n+                                                 struct_type,\n+                                                 span,\n+                                                 struct_def.did,\n+                                                 fields,\n+                                                 base_expr.is_none());\n+        if res.is_err() {\n             struct_type = tcx.types.err;\n         }\n \n@@ -3180,27 +3135,20 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                           enum_id: ast::DefId,\n                                           variant_id: ast::DefId,\n                                           fields: &'tcx [ast::Field]) {\n-        let tcx = fcx.ccx.tcx;\n-\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n         let TypeAndSubsts {\n             ty: enum_type,\n-            substs: substitutions\n+            substs: _\n         } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n-        let variant_fields = tcx.lookup_struct_fields(variant_id);\n-        check_struct_or_variant_fields(fcx,\n-                                       enum_type,\n-                                       span,\n-                                       variant_id,\n-                                       id,\n-                                       fcx.ccx.tcx.mk_substs(substitutions),\n-                                       &variant_fields[..],\n-                                       fields,\n-                                       true,\n-                                       Some(enum_id));\n+        let _ = check_struct_or_variant_fields(fcx,\n+                                               enum_type,\n+                                               span,\n+                                               variant_id,\n+                                               fields,\n+                                               true);\n         fcx.write_ty(id, enum_type);\n     }\n \n@@ -3695,11 +3643,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Verify that this was actually a struct.\n                 let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n                 match typ.ty.sty {\n-                    ty::TyStruct(struct_did, _) => {\n+                    ty::TyStruct(struct_def, _) => {\n                         check_struct_constructor(fcx,\n                                                  id,\n                                                  expr.span,\n-                                                 struct_did,\n+                                                 struct_def,\n                                                  &fields[..],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n@@ -3835,6 +3783,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n+                    let def = tcx.lookup_adt_def(did);\n                     let predicates = tcx.lookup_predicates(did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n                     let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n@@ -3844,7 +3793,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                      traits::ItemObligation(did)),\n                         &bounds);\n \n-                    tcx.mk_struct(did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(def, tcx.mk_substs(substs))\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -3853,8 +3802,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {\n                 // Neither start nor end => RangeFull\n                 if let Some(did) = tcx.lang_items.range_full_struct() {\n-                    let substs = Substs::new_type(vec![], vec![]);\n-                    tcx.mk_struct(did, tcx.mk_substs(substs))\n+                    tcx.mk_struct(\n+                        tcx.lookup_adt_def(did),\n+                        tcx.mk_substs(Substs::empty())\n+                    )\n                 } else {\n                     span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n@@ -4305,15 +4256,14 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n         return;\n     }\n     match t.sty {\n-        ty::TyStruct(did, substs) => {\n-            let fields = tcx.lookup_struct_fields(did);\n+        ty::TyStruct(def, substs) => {\n+            let fields = &def.struct_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = tcx.lookup_field_type(did, fields[0].id, substs);\n-            if !fields.iter().all(\n-                         |f| tcx.lookup_field_type(did, f.id, substs) == e) {\n+            let e = fields[0].ty(tcx, substs);\n+            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n@@ -4381,10 +4331,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         let def_id = local_def(id);\n \n-        // ty::enum_variants guards against discriminant overflows, so\n-        // we need not check for that.\n-        let variants = ccx.tcx.enum_variants(def_id);\n-\n+        let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n         for (v, variant) in vs.iter().zip(variants.iter()) {\n             let current_disr_val = variant.disr_val;\n \n@@ -4393,7 +4340,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].id.node),\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].did.node),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}"}, {"sha": "b139cb45bf207519229e1326f7e83d4759773789", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -21,7 +21,7 @@ use super::{\n     structurally_resolved_type,\n };\n use middle::traits;\n-use middle::ty::{self, Ty, HasTypeFlags};\n+use middle::ty::{Ty, HasTypeFlags};\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n@@ -41,7 +41,7 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let lhs_ty = structurally_resolved_type(fcx, lhs_expr.span, fcx.expr_ty(lhs_expr));\n     let rhs_ty = structurally_resolved_type(fcx, rhs_expr.span, fcx.expr_ty(rhs_expr));\n \n-    if is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op) {\n+    if is_builtin_binop(lhs_ty, rhs_ty, op) {\n         enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n         fcx.write_nil(expr.id);\n     } else {\n@@ -86,7 +86,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // traits, because their return type is not bool. Perhaps this\n     // should change, but for now if LHS is SIMD we go down a\n     // different path that bypassess all traits.\n-    if lhs_ty.is_simd(fcx.tcx()) {\n+    if lhs_ty.is_simd() {\n         check_expr_coercable_to_type(fcx, rhs_expr, lhs_ty);\n         let rhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n         let return_ty = enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -123,7 +123,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n             if\n                 !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n-                is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op)\n+                is_builtin_binop(lhs_ty, rhs_ty, op)\n             {\n                 let builtin_return_ty =\n                     enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -143,7 +143,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          op: ast::BinOp)\n                                          -> Ty<'tcx>\n {\n-    debug_assert!(is_builtin_binop(fcx.tcx(), lhs_ty, rhs_ty, op));\n+    debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n     let tcx = fcx.tcx();\n     match BinOpCategory::from(op) {\n@@ -156,7 +156,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         BinOpCategory::Shift => {\n             // For integers, the shift amount can be of any integral\n             // type. For simd, the type must match exactly.\n-            if lhs_ty.is_simd(tcx) {\n+            if lhs_ty.is_simd() {\n                 demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n             }\n \n@@ -176,7 +176,7 @@ fn enforce_builtin_binop_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, rhs_expr.span, lhs_ty, rhs_ty);\n \n             // if this is simd, result is same as lhs, else bool\n-            if lhs_ty.is_simd(tcx) {\n+            if lhs_ty.is_simd() {\n                 let unit_ty = lhs_ty.simd_type(tcx);\n                 debug!(\"enforce_builtin_binop_types: lhs_ty={:?} unit_ty={:?}\",\n                        lhs_ty,\n@@ -415,8 +415,7 @@ impl BinOpCategory {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/trans after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n-                          lhs: Ty<'tcx>,\n+fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>,\n                           rhs: Ty<'tcx>,\n                           op: ast::BinOp)\n                           -> bool\n@@ -429,28 +428,28 @@ fn is_builtin_binop<'tcx>(cx: &ty::ctxt<'tcx>,\n         BinOpCategory::Shift => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n \n         BinOpCategory::Math => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n                 lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n \n         BinOpCategory::Bitwise => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_integral() && rhs.is_integral() ||\n                 lhs.is_floating_point() && rhs.is_floating_point() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx) ||\n+                lhs.is_simd() && rhs.is_simd() ||\n                 lhs.is_bool() && rhs.is_bool()\n         }\n \n         BinOpCategory::Comparison => {\n             lhs.references_error() || rhs.references_error() ||\n                 lhs.is_scalar() && rhs.is_scalar() ||\n-                lhs.is_simd(cx) && rhs.is_simd(cx)\n+                lhs.is_simd() && rhs.is_simd()\n         }\n     }\n }"}, {"sha": "7790a29db12f78176309f34289bfd138bc20b81a", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -571,17 +571,17 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         }\n \n         match t.sty{\n-            ty::TyStruct(type_id, substs) |\n-            ty::TyEnum(type_id, substs) => {\n-                let type_predicates = self.fcx.tcx().lookup_predicates(type_id);\n+            ty::TyStruct(def, substs) |\n+            ty::TyEnum(def, substs) => {\n+                let type_predicates = def.predicates(self.fcx.tcx());\n                 let bounds = self.fcx.instantiate_bounds(self.span, substs,\n                                                          &type_predicates);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n-                                                     traits::ItemObligation(type_id)),\n+                                                     traits::ItemObligation(def.did)),\n                         &bounds);\n                 } else {\n                     // There are two circumstances in which we ignore\n@@ -610,7 +610,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                     self.fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(self.span,\n                                                      self.fcx.body_id,\n-                                                     traits::ItemObligation(type_id)),\n+                                                     traits::ItemObligation(def.did)),\n                         &bounds);\n                 }\n "}, {"sha": "7ab8d327a8097b9604be12257b15e25b7e1c90fc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -55,9 +55,9 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n                                   ty: Ty<'tcx>)\n                                   -> Option<DefId> {\n     match ty.sty {\n-        TyEnum(def_id, _) |\n-        TyStruct(def_id, _) => {\n-            Some(def_id)\n+        TyEnum(def, _) |\n+        TyStruct(def, _) => {\n+            Some(def.did)\n         }\n \n         TyTrait(ref t) => {\n@@ -310,12 +310,11 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n-                ty::TyEnum(type_def_id, _) |\n-                ty::TyStruct(type_def_id, _) |\n-                ty::TyClosure(type_def_id, _) => {\n+                ty::TyEnum(type_def, _) |\n+                ty::TyStruct(type_def, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n-                       .insert(type_def_id, method_def_id.def_id());\n+                       .insert(type_def.did, method_def_id.def_id());\n                     tcx.destructors\n                        .borrow_mut()\n                        .insert(method_def_id.def_id());\n@@ -471,10 +470,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n                 }\n \n-                (&ty::TyStruct(def_id_a, substs_a), &ty::TyStruct(def_id_b, substs_b)) => {\n-                    if def_id_a != def_id_b {\n-                        let source_path = tcx.item_path_str(def_id_a);\n-                        let target_path = tcx.item_path_str(def_id_b);\n+                (&ty::TyStruct(def_a, substs_a), &ty::TyStruct(def_b, substs_b)) => {\n+                    if def_a != def_b {\n+                        let source_path = tcx.item_path_str(def_a.did);\n+                        let target_path = tcx.item_path_str(def_b.did);\n                         span_err!(tcx.sess, span, E0377,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with the same \\\n@@ -484,10 +483,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let origin = infer::Misc(span);\n-                    let fields = tcx.lookup_struct_fields(def_id_a);\n+                    let fields = &def_a.struct_variant().fields;\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let ty = tcx.lookup_field_type_unsubstituted(def_id_a, f.id);\n-                        let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n                         if infcx.sub_types(false, origin, b, a).is_ok() {\n                             None\n                         } else {"}, {"sha": "8076e63cc55c5529399571a783c9efe62d1a42b7", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.map.node_to_string(item.id));\n                 let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n-                    ty::TyEnum(def_id, _) |\n-                    ty::TyStruct(def_id, _) => {\n-                        self.check_def_id(item, def_id);\n+                    ty::TyEnum(def, _) |\n+                    ty::TyStruct(def, _) => {\n+                        self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n                         self.check_def_id(item, data.principal_def_id());\n@@ -279,8 +279,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyStruct(self_def_id, _) | ty::TyEnum(self_def_id, _) =>\n-                            Some(self_def_id),\n+                        ty::TyStruct(self_def, _) | ty::TyEnum(self_def, _) =>\n+                            Some(self_def.did),\n                         ty::TyBox(..) =>\n                             self.tcx.lang_items.owned_box(),\n                         _ =>"}, {"sha": "dabc09db68d8e80faa2bb9446f77d82aaf0efb5b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 235, "deletions": 131, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -71,9 +71,12 @@ use middle::lang_items::SizedTraitLangItem;\n use middle::free_region::FreeRegionMap;\n use middle::region;\n use middle::resolve_lifetime;\n+use middle::const_eval::{self, ConstVal};\n+use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme, IntTypeExt};\n+use middle::ty::{VariantKind};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n@@ -89,8 +92,10 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util::local_def;\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit;\n \n@@ -563,48 +568,6 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                    enum_scheme: ty::TypeScheme<'tcx>,\n-                                    enum_predicates: ty::GenericPredicates<'tcx>,\n-                                    variants: &[P<ast::Variant>]) {\n-    let tcx = ccx.tcx;\n-    let icx = ccx.icx(&enum_predicates);\n-\n-    // Create a set of parameter types shared among all the variants.\n-    for variant in variants {\n-        let variant_def_id = local_def(variant.node.id);\n-\n-        // Nullary enum constructors get turned into constants; n-ary enum\n-        // constructors get turned into functions.\n-        let result_ty = match variant.node.kind {\n-            ast::TupleVariantKind(ref args) if !args.is_empty() => {\n-                let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n-                tcx.mk_ctor_fn(variant_def_id, &input_tys, enum_scheme.ty)\n-            }\n-\n-            ast::TupleVariantKind(_) => {\n-                enum_scheme.ty\n-            }\n-\n-            ast::StructVariantKind(ref struct_def) => {\n-                convert_struct(ccx, &**struct_def, enum_scheme.clone(),\n-                               enum_predicates.clone(), variant.node.id);\n-                enum_scheme.ty\n-            }\n-        };\n-\n-        let variant_scheme = TypeScheme {\n-            generics: enum_scheme.generics.clone(),\n-            ty: result_ty\n-        };\n-\n-        tcx.register_item_type(variant_def_id, variant_scheme.clone());\n-        tcx.predicates.borrow_mut().insert(variant_def_id, enum_predicates.clone());\n-        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n-    }\n-}\n-\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             sig: &ast::MethodSig,\n@@ -657,10 +620,10 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            v: &ast::StructField,\n-                           origin: ast::DefId)\n-                           -> ty::FieldTy\n+                           ty_f: ty::FieldDefMaster<'tcx>)\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n+    ty_f.fulfill_ty(tt);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n@@ -671,25 +634,6 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                });\n     ccx.tcx.predicates.borrow_mut().insert(local_def(v.node.id),\n                                            struct_predicates.clone());\n-\n-    match v.node.kind {\n-        ast::NamedField(ident, visibility) => {\n-            ty::FieldTy {\n-                name: ident.name,\n-                id: local_def(v.node.id),\n-                vis: visibility,\n-                origin: origin,\n-            }\n-        }\n-        ast::UnnamedField(visibility) => {\n-            ty::FieldTy {\n-                name: special_idents::unnamed_field.name,\n-                id: local_def(v.node.id),\n-                vis: visibility,\n-                origin: origin,\n-            }\n-        }\n-    }\n }\n \n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -803,10 +747,11 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n         ast::ItemEnum(ref enum_definition, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-            get_enum_variant_types(ccx,\n-                                   scheme,\n-                                   predicates,\n-                                   &enum_definition.variants);\n+            convert_enum_variant_types(ccx,\n+                                       tcx.lookup_adt_def_master(local_def(it.id)),\n+                                       scheme,\n+                                       predicates,\n+                                       &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n             let trait_ref =\n@@ -1048,10 +993,18 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n-            // Write the class type.\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, scheme.ty);\n-            convert_struct(ccx, &**struct_def, scheme, predicates, it.id);\n+\n+            let variant = tcx.lookup_adt_def_master(local_def(it.id)).struct_variant();\n+\n+            for (f, ty_f) in struct_def.fields.iter().zip(variant.fields.iter()) {\n+                convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+            }\n+\n+            if let Some(ctor_id) = struct_def.ctor_id {\n+                convert_variant_ctor(tcx, ctor_id, variant, scheme, predicates);\n+            }\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -1068,76 +1021,226 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            struct_def: &ast::StructDef,\n-                            scheme: ty::TypeScheme<'tcx>,\n-                            predicates: ty::GenericPredicates<'tcx>,\n-                            id: ast::NodeId) {\n+fn convert_variant_ctor<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  ctor_id: ast::NodeId,\n+                                  variant: ty::VariantDef<'tcx>,\n+                                  scheme: ty::TypeScheme<'tcx>,\n+                                  predicates: ty::GenericPredicates<'tcx>) {\n+    let ctor_ty = match variant.kind() {\n+        VariantKind::Unit | VariantKind::Dict => scheme.ty,\n+        VariantKind::Tuple => {\n+            let inputs: Vec<_> =\n+                variant.fields\n+                .iter()\n+                .map(|field| field.unsubst_ty())\n+                .collect();\n+            tcx.mk_ctor_fn(local_def(ctor_id),\n+                           &inputs[..],\n+                           scheme.ty)\n+        }\n+    };\n+    write_ty_to_tcx(tcx, ctor_id, ctor_ty);\n+    tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n+    tcx.register_item_type(local_def(ctor_id),\n+                           TypeScheme {\n+                               generics: scheme.generics,\n+                               ty: ctor_ty\n+                           });\n+}\n+\n+fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        def: ty::AdtDefMaster<'tcx>,\n+                                        scheme: ty::TypeScheme<'tcx>,\n+                                        predicates: ty::GenericPredicates<'tcx>,\n+                                        variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n+    let icx = ccx.icx(&predicates);\n \n-    // Write the type of each of the members and check for duplicate fields.\n-    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n-    let field_tys = struct_def.fields.iter().map(|f| {\n-        let result = convert_field(ccx, &scheme.generics, &predicates, f, local_def(id));\n+    // fill the field types\n+    for (variant, ty_variant) in variants.iter().zip(def.variants.iter()) {\n+        match variant.node.kind {\n+            ast::TupleVariantKind(ref args) => {\n+                let rs = ExplicitRscope;\n+                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n+                for (field, &ty) in ty_variant.fields.iter().zip(input_tys.iter()) {\n+                    field.fulfill_ty(ty);\n+                }\n+            }\n \n-        if result.name != special_idents::unnamed_field.name {\n-            let dup = match seen_fields.get(&result.name) {\n-                Some(prev_span) => {\n+            ast::StructVariantKind(ref struct_def) => {\n+                for (f, ty_f) in struct_def.fields.iter().zip(ty_variant.fields.iter()) {\n+                    convert_field(ccx, &scheme.generics, &predicates, f, ty_f)\n+                }\n+            }\n+        };\n+\n+        // Convert the ctor, if any. This also registers the variant as\n+        // an item.\n+        convert_variant_ctor(\n+            tcx,\n+            variant.node.id,\n+            ty_variant,\n+            scheme.clone(),\n+            predicates.clone()\n+        );\n+    }\n+}\n+\n+fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                did: ast::DefId,\n+                                name: ast::Name,\n+                                disr_val: ty::Disr,\n+                                def: &ast::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n+    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let fields = def.fields.iter().map(|f| {\n+        let fid = local_def(f.node.id);\n+        match f.node.kind {\n+            ast::NamedField(ident, vis) => {\n+                let dup_span = seen_fields.get(&ident.name).cloned();\n+                if let Some(prev_span) = dup_span {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n-                              result.name);\n-                    span_note!(tcx.sess, *prev_span, \"previously declared here\");\n-                    true\n-                },\n-                None => false,\n-            };\n-            // FIXME(#6393) this whole dup thing is just to satisfy\n-            // the borrow checker :-(\n-            if !dup {\n-                seen_fields.insert(result.name, f.span);\n+                              ident.name);\n+                    span_note!(tcx.sess, prev_span, \"previously declared here\");\n+                } else {\n+                    seen_fields.insert(ident.name, f.span);\n+                }\n+\n+                ty::FieldDefData::new(fid, ident.name, vis)\n+            },\n+            ast::UnnamedField(vis) => {\n+                ty::FieldDefData::new(fid, special_idents::unnamed_field.name, vis)\n             }\n         }\n-\n-        result\n     }).collect();\n+    ty::VariantDefData {\n+        did: did,\n+        name: name,\n+        disr_val: disr_val,\n+        fields: fields\n+    }\n+}\n \n-    tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n+fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            it: &ast::Item,\n+                            def: &ast::StructDef)\n+                            -> ty::AdtDefMaster<'tcx>\n+{\n \n-    let substs = mk_item_substs(ccx, &scheme.generics);\n-    let selfty = tcx.mk_struct(local_def(id), tcx.mk_substs(substs));\n+    let did = local_def(it.id);\n+    tcx.intern_adt_def(\n+        did,\n+        ty::AdtKind::Struct,\n+        vec![convert_struct_variant(tcx, did, it.ident.name, 0, def)]\n+    )\n+}\n \n-    // If this struct is enum-like or tuple-like, create the type of its\n-    // constructor.\n-    match struct_def.ctor_id {\n-        None => {}\n-        Some(ctor_id) => {\n-            if struct_def.fields.is_empty() {\n-                // Enum-like.\n-                write_ty_to_tcx(tcx, ctor_id, selfty);\n-\n-                tcx.register_item_type(local_def(ctor_id), scheme);\n-                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n-            } else if struct_def.fields[0].node.kind.is_unnamed() {\n-                // Tuple-like.\n-                let inputs: Vec<_> =\n-                    struct_def.fields\n-                              .iter()\n-                              .map(|field| tcx.lookup_item_type(\n-                                  local_def(field.node.id)).ty)\n-                              .collect();\n-                let ctor_fn_ty = tcx.mk_ctor_fn(local_def(ctor_id),\n-                                                &inputs[..],\n-                                                selfty);\n-                write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n-                tcx.register_item_type(local_def(ctor_id),\n-                                       TypeScheme {\n-                                           generics: scheme.generics,\n-                                           ty: ctor_fn_ty\n-                                       });\n-                tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n+fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          it: &ast::Item,\n+                          def: &ast::EnumDef)\n+                          -> ty::AdtDefMaster<'tcx>\n+{\n+    fn evaluate_disr_expr<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                repr_ty: Ty<'tcx>,\n+                                e: &ast::Expr) -> Option<ty::Disr> {\n+        debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n+\n+        let hint = UncheckedExprHint(repr_ty);\n+        match const_eval::eval_const_expr_partial(tcx, e, hint) {\n+            Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n+            Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n+            Ok(_) => {\n+                let sign_desc = if repr_ty.is_signed() {\n+                    \"signed\"\n+                } else {\n+                    \"unsigned\"\n+                };\n+                span_err!(tcx.sess, e.span, E0079,\n+                          \"expected {} integer constant\",\n+                          sign_desc);\n+                None\n+            },\n+            Err(err) => {\n+              span_err!(tcx.sess, err.span, E0080,\n+                        \"constant evaluation error: {}\",\n+                        err.description());\n+                None\n+            }\n+        }\n+    }\n+\n+    fn report_discrim_overflow(tcx: &ty::ctxt,\n+                               variant_span: Span,\n+                               variant_name: &str,\n+                               repr_type: attr::IntType,\n+                               prev_val: ty::Disr) {\n+        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n+        let computed_value = repr_type.disr_string(computed_value);\n+        let prev_val = repr_type.disr_string(prev_val);\n+        let repr_type = repr_type.to_ty(tcx);\n+        span_err!(tcx.sess, variant_span, E0370,\n+                  \"enum discriminant overflowed on value after {}: {}; \\\n+                   set explicitly via {} = {} if that is desired outcome\",\n+                  prev_val, repr_type, variant_name, computed_value);\n+    }\n+\n+    fn next_disr(tcx: &ty::ctxt,\n+                 v: &ast::Variant,\n+                 repr_type: attr::IntType,\n+                 prev_disr_val: Option<ty::Disr>) -> Option<ty::Disr> {\n+        if let Some(prev_disr_val) = prev_disr_val {\n+            let result = repr_type.disr_incr(prev_disr_val);\n+            if let None = result {\n+                report_discrim_overflow(tcx, v.span, &v.node.name.name.as_str(),\n+                                             repr_type, prev_disr_val);\n             }\n+            result\n+        } else {\n+            Some(ty::INITIAL_DISCRIMINANT_VALUE)\n         }\n     }\n+    fn convert_enum_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  v: &ast::Variant,\n+                                  disr: ty::Disr)\n+                                  -> ty::VariantDefData<'tcx, 'tcx>\n+    {\n+        let did = local_def(v.node.id);\n+        let name = v.node.name.name;\n+        match v.node.kind {\n+            ast::TupleVariantKind(ref va) => {\n+                ty::VariantDefData {\n+                    did: did,\n+                    name: name,\n+                    disr_val: disr,\n+                    fields: va.iter().map(|&ast::VariantArg { id, .. }| {\n+                        ty::FieldDefData::new(\n+                            local_def(id),\n+                            special_idents::unnamed_field.name,\n+                            ast::Visibility::Public\n+                        )\n+                    }).collect()\n+                }\n+            }\n+            ast::StructVariantKind(ref def) => {\n+                convert_struct_variant(tcx, did, name, disr, &def)\n+            }\n+        }\n+    }\n+    let did = local_def(it.id);\n+    let repr_hints = tcx.lookup_repr_hints(did);\n+    let (repr_type, repr_type_ty) = tcx.enum_repr_type(repr_hints.get(0));\n+    let mut prev_disr = None;\n+    let variants = def.variants.iter().map(|v| {\n+        let disr = match v.node.disr_expr {\n+            Some(ref e) => evaluate_disr_expr(tcx, repr_type_ty, e),\n+            None => next_disr(tcx, v, repr_type, prev_disr)\n+        }.unwrap_or(repr_type.disr_wrap_incr(prev_disr));\n+\n+        let v = convert_enum_variant(tcx, v, disr);\n+        prev_disr = Some(disr);\n+        v\n+    }).collect();\n+    tcx.intern_adt_def(local_def(it.id), ty::AdtKind::Enum, variants)\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1471,17 +1574,18 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n-        ast::ItemEnum(_, ref generics) => {\n-            // Create a new generic polytype.\n+        ast::ItemEnum(ref ei, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_enum(local_def(it.id), tcx.mk_substs(substs));\n+            let def = convert_enum_def(tcx, it, ei);\n+            let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n-        ast::ItemStruct(_, ref generics) => {\n+        ast::ItemStruct(ref si, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let t = tcx.mk_struct(local_def(it.id), tcx.mk_substs(substs));\n+            let def = convert_struct_def(tcx, it, si);\n+            let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemDefaultImpl(..) |"}, {"sha": "4660adaffaec066d0c54bce18d9a43cc4140c58f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -883,6 +883,64 @@ struct Good(u32, u32, u32); // This will not\n ```\n \"##,\n \n+E0079: r##\"\n+Enum variants which contain no data can be given a custom integer\n+representation. This error indicates that the value provided is not an integer\n+literal and is therefore invalid.\n+\n+For example, in the following code,\n+\n+```\n+enum Foo {\n+    Q = \"32\"\n+}\n+```\n+\n+we try to set the representation to a string.\n+\n+There's no general fix for this; if you can work with an integer then just set\n+it to one:\n+\n+```\n+enum Foo {\n+    Q = 32\n+}\n+```\n+\n+however if you actually wanted a mapping between variants and non-integer\n+objects, it may be preferable to use a method with a match instead:\n+\n+```\n+enum Foo { Q }\n+impl Foo {\n+    fn get_str(&self) -> &'static str {\n+        match *self {\n+            Foo::Q => \"32\",\n+        }\n+    }\n+}\n+```\n+\"##,\n+\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+integer expression provided as an enum discriminant. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -2510,6 +2568,7 @@ register_diagnostics! {\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0369, // binary operation `<op>` cannot be applied to types\n+    E0370, // discriminant overflow\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "69e2141b17b07807c2907eb3660b2001418b6fae", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -602,7 +602,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n         match item.node {\n-            ast::ItemEnum(ref enum_definition, _) => {\n+            ast::ItemEnum(..) | ast::ItemStruct(..) => {\n                 let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n@@ -611,44 +611,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 //\n                 // self.add_constraints_from_generics(&scheme.generics);\n \n-                // Hack: If we directly call `ty::enum_variants`, it\n-                // annoyingly takes it upon itself to run off and\n-                // evaluate the discriminants eagerly (*grumpy* that's\n-                // not the typical pattern). This results in double\n-                // error messages because typeck goes off and does\n-                // this at a later time. All we really care about is\n-                // the types of the variant arguments, so we just call\n-                // `ty::VariantInfo::from_ast_variant()` ourselves\n-                // here, mainly so as to mask the differences between\n-                // struct-like enums and so forth.\n-                for ast_variant in &enum_definition.variants {\n-                    let variant =\n-                        ty::VariantInfo::from_ast_variant(tcx,\n-                                                          &**ast_variant,\n-                                                          /*discriminant*/ 0);\n-                    for arg_ty in &variant.args {\n-                        self.add_constraints_from_ty(&scheme.generics, *arg_ty, self.covariant);\n-                    }\n+                for field in tcx.lookup_adt_def(did).all_fields() {\n+                    self.add_constraints_from_ty(&scheme.generics,\n+                                                 field.unsubst_ty(),\n+                                                 self.covariant);\n                 }\n             }\n-\n-            ast::ItemStruct(..) => {\n-                let scheme = tcx.lookup_item_type(did);\n-\n-                // Not entirely obvious: constraints on structs/enums do not\n-                // affect the variance of their type parameters. See discussion\n-                // in comment at top of module.\n-                //\n-                // self.add_constraints_from_generics(&scheme.generics);\n-\n-                let struct_fields = tcx.lookup_struct_fields(did);\n-                for field_info in &struct_fields {\n-                    assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n-                    let field_ty = tcx.node_id_to_type(field_info.id.node);\n-                    self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n-                }\n-            }\n-\n             ast::ItemTrait(..) => {\n                 let trait_def = tcx.lookup_trait_def(did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,\n@@ -902,9 +870,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::TyEnum(def_id, substs) |\n-            ty::TyStruct(def_id, substs) => {\n-                let item_type = self.tcx().lookup_item_type(def_id);\n+            ty::TyEnum(def, substs) |\n+            ty::TyStruct(def, substs) => {\n+                let item_type = self.tcx().lookup_item_type(def.did);\n \n                 // All type parameters on enums and structs should be\n                 // in the TypeSpace.\n@@ -915,7 +883,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(\n                     generics,\n-                    def_id,\n+                    def.did,\n                     item_type.generics.types.get_slice(subst::TypeSpace),\n                     item_type.generics.regions.get_slice(subst::TypeSpace),\n                     substs,"}, {"sha": "7fd1555d06654558b2afbe62e18baffd472b5924", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -185,17 +185,17 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n \n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n-    let fields = tcx.lookup_struct_fields(did);\n+    let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match &*fields {\n+        struct_type: match &*variant.fields {\n             [] => doctree::Unit,\n             [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n         generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n-        fields: fields.clean(cx),\n+        fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n@@ -204,11 +204,11 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n-        ty::TyEnum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n+        ty::TyEnum(edef, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: tcx.enum_variants(edid).clean(cx),\n+                variants: edef.variants.clean(cx),\n             })\n         }\n         _ => {}"}, {"sha": "819457e5239ccdcddab84749e5a1f552576c83fb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -1661,8 +1661,9 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 decl: (ast_util::local_def(0), &fty.sig).clean(cx),\n                 abi: fty.abi.to_string(),\n             }),\n-            ty::TyStruct(did, substs) |\n-            ty::TyEnum(did, substs) => {\n+            ty::TyStruct(def, substs) |\n+            ty::TyEnum(def, substs) => {\n+                let did = def.did;\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<_> = fqn.into_iter().map(|i| i.to_string()).collect();\n                 let kind = match self.sty {\n@@ -1732,29 +1733,27 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n-impl Clean<Item> for ty::FieldTy {\n+impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;\n \n-        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.id);\n+        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.did);\n \n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.did.node).unwrap()))\n         };\n \n-        let ty = cx.tcx().lookup_item_type(self.id);\n-\n         Item {\n             name: name.clean(cx),\n             attrs: attrs.unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n-            stability: get_stability(cx, self.id),\n-            def_id: self.id,\n-            inner: StructFieldItem(TypedStructField(ty.ty.clean(cx))),\n+            stability: get_stability(cx, self.did),\n+            def_id: self.did,\n+            inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n         }\n     }\n }\n@@ -1860,22 +1859,24 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n+impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let kind = match self.arg_names.as_ref().map(|s| &**s) {\n-            None | Some([]) if self.args.is_empty() => CLikeVariant,\n-            None | Some([]) => {\n-                TupleVariant(self.args.clean(cx))\n+        let kind = match self.kind() {\n+            ty::VariantKind::Unit => CLikeVariant,\n+            ty::VariantKind::Tuple => {\n+                TupleVariant(\n+                    self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n+                )\n             }\n-            Some(s) => {\n+            ty::VariantKind::Dict => {\n                 StructVariant(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,\n-                    fields: s.iter().zip(&self.args).map(|(name, ty)| {\n+                    fields: self.fields.iter().map(|field| {\n                         Item {\n                             source: Span::empty(),\n-                            name: Some(name.clean(cx)),\n+                            name: Some(field.name.clean(cx)),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n                             // FIXME: this is not accurate, we need an id for\n@@ -1885,10 +1886,10 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n                             //        Struct variants are experimental and need\n                             //        more infrastructure work before we can get\n                             //        at the needed information here.\n-                            def_id: self.id,\n-                            stability: get_stability(cx, self.id),\n+                            def_id: self.did,\n+                            stability: get_stability(cx, self.did),\n                             inner: StructFieldItem(\n-                                TypedStructField(ty.clean(cx))\n+                                TypedStructField(field.unsubst_ty().clean(cx))\n                             )\n                         }\n                     }).collect()\n@@ -1897,12 +1898,12 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n         };\n         Item {\n             name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.id),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n-            def_id: self.id,\n+            def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),\n-            stability: get_stability(cx, self.id),\n+            stability: get_stability(cx, self.did),\n         }\n     }\n }"}, {"sha": "e296aff2782c53a1480e30b6c4ef625d321dc271", "filename": "src/test/run-pass/enum-null-pointer-opt.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-null-pointer-opt.rs?ref=ab77c1d8d017196a7bd8fac3574eb73dcd54f0a9", "patch": "@@ -18,6 +18,10 @@ use std::rc::Rc;\n use std::sync::Arc;\n \n trait Trait { fn dummy(&self) { } }\n+trait Mirror { type Image; }\n+impl<T> Mirror for T { type Image = T; }\n+struct ParamTypeStruct<T>(T);\n+struct AssocTypeStruct<T>(<T as Mirror>::Image);\n \n fn main() {\n     // Functions\n@@ -66,4 +70,7 @@ fn main() {\n     // Should apply to types that have NonZero transitively\n     assert_eq!(size_of::<String>(), size_of::<Option<String>>());\n \n+    // Should apply to types where the pointer is substituted\n+    assert_eq!(size_of::<&u8>(), size_of::<Option<ParamTypeStruct<&u8>>>());\n+    assert_eq!(size_of::<&u8>(), size_of::<Option<AssocTypeStruct<&u8>>>());\n }"}]}