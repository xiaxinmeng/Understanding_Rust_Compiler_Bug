{"sha": "29584cc5ac9369a18d1082d3d2c95eb0471a64db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NTg0Y2M1YWM5MzY5YTE4ZDEwODJkM2QyYzk1ZWIwNDcxYTY0ZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-06T23:42:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-12T21:26:47Z"}, "message": "Extend the unchecked block stuff to allow unsafe blocks as well.", "tree": {"sha": "1d14dc2e6801290d59c60d0d9042b79283d2426c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d14dc2e6801290d59c60d0d9042b79283d2426c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29584cc5ac9369a18d1082d3d2c95eb0471a64db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29584cc5ac9369a18d1082d3d2c95eb0471a64db", "html_url": "https://github.com/rust-lang/rust/commit/29584cc5ac9369a18d1082d3d2c95eb0471a64db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29584cc5ac9369a18d1082d3d2c95eb0471a64db/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b8e88356187b8631f24fa787c0dfefcb6a1970", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b8e88356187b8631f24fa787c0dfefcb6a1970", "html_url": "https://github.com/rust-lang/rust/commit/58b8e88356187b8631f24fa787c0dfefcb6a1970"}], "stats": {"total": 149, "additions": 114, "deletions": 35}, "files": [{"sha": "fcef6e551f122c4a1225f45082801cdeee6e6e26", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -184,7 +184,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let test_descs = mk_test_desc_vec(cx);\n \n     let body_: ast::blk_ =\n-        checked_blk([], option::some(test_descs), cx.next_node_id());\n+        checked_block([], option::some(test_descs), cx.next_node_id());\n     let body = nospan(body_);\n \n     let fn_ = {decl: decl, proto: proto, body: body};\n@@ -303,7 +303,8 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let test_main_call_expr = mk_test_main_call(cx);\n \n     let body_: ast::blk_ =\n-        checked_blk([], option::some(test_main_call_expr), cx.next_node_id());\n+        checked_block([], option::some(test_main_call_expr),\n+                      cx.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n     let fn_ = {decl: decl, proto: proto, body: body};"}, {"sha": "d62a9572ecc466e9e49acc84e5169da23846e170", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -175,6 +175,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     let def =\n         alt fam_ch as char {\n           'c' { ast::def_const(did) }\n+          'u' { ast::def_fn(did, ast::unsafe_fn) }\n           'f' { ast::def_fn(did, ast::impure_fn) }\n           'p' { ast::def_fn(did, ast::pure_fn) }\n           'F' { ast::def_native_fn(did) }"}, {"sha": "b67114d3d9a3ddb1e60668f336a25635a6924411", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -252,6 +252,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w,\n                       alt fd.decl.purity {\n+                        unsafe_fn. { 'u' }\n                         pure_fn. { 'p' }\n                         impure_fn. { 'f' }\n                       } as u8);"}, {"sha": "4199c81123d5b3fdada58c06ef35f7ca94b695d1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -4380,11 +4380,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert dest == ignore;\n         ret trans_check_expr(bcx, a, \"Assertion\");\n       }\n-      ast::expr_check(ast::checked., a) {\n+      ast::expr_check(ast::checked_expr., a) {\n         assert dest == ignore;\n         ret trans_check_expr(bcx, a, \"Predicate\");\n       }\n-      ast::expr_check(ast::unchecked., a) {\n+      ast::expr_check(ast::claimed_expr., a) {\n         assert dest == ignore;\n         /* Claims are turned on and off by a global variable\n            that the RTS sets. This case generates code to"}, {"sha": "411a8ed213f9a978fdcc6531c8e630d0aa065343", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -1523,6 +1523,15 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n     }\n }\n \n+fn require_unsafe(sess: session::session, f_purity: ast::purity, sp: span) {\n+    alt f_purity {\n+      ast::unsafe_fn. { ret; }\n+      _ {\n+        sess.span_fatal(sp, \"Found unsafe expression in safe function decl\");\n+      }\n+    }\n+}\n+\n fn require_impure(sess: session::session, f_purity: ast::purity, sp: span) {\n     alt f_purity {\n       ast::unsafe_fn. { ret; }\n@@ -1536,7 +1545,22 @@ fn require_impure(sess: session::session, f_purity: ast::purity, sp: span) {\n fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n                      callee: @ast::expr, sp: span) {\n     alt caller_purity {\n-      ast::impure_fn. { ret; }\n+      ast::unsafe_fn. { ret; }\n+      ast::impure_fn. {\n+        alt ccx.tcx.def_map.find(callee.id) {\n+          some(ast::def_fn(_, ast::unsafe_fn.)) {\n+            ccx.tcx.sess.span_fatal\n+                (sp, \"safe function calls function marked unsafe\");\n+          }\n+          //some(ast::def_native_fn(_)) {\n+          //  ccx.tcx.sess.span_fatal\n+          //  (sp, \"native functions can only be invoked from unsafe code\");\n+          //}\n+          _ {\n+          }\n+        }\n+        ret;\n+      }\n       ast::pure_fn. {\n         alt ccx.tcx.def_map.find(callee.id) {\n           some(ast::def_fn(_, ast::pure_fn.)) { ret; }\n@@ -2066,8 +2090,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // If this is an unchecked block, turn off purity-checking\n         let fcx_for_block =\n             alt b.node.rules {\n-              ast::unchecked. { @{purity: ast::impure_fn with *fcx} }\n-              _ { fcx }\n+              ast::unchecked_blk. { @{purity: ast::impure_fn with *fcx} }\n+              ast::unsafe_blk. { @{purity: ast::unsafe_fn with *fcx} }\n+              ast::checked_blk. { fcx }\n             };\n         bot = check_block(fcx_for_block, b);\n         let typ ="}, {"sha": "6b72a4b67c375e6e09ed2557c57d1abaed7bf54b", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -78,7 +78,8 @@ tag meta_item_ {\n type blk = spanned<blk_>;\n \n type blk_ =\n-    {stmts: [@stmt], expr: option::t<@expr>, id: node_id, rules: check_mode};\n+    {stmts: [@stmt], expr: option::t<@expr>, id: node_id,\n+     rules: blk_check_mode};\n \n type pat = {id: node_id, node: pat_, span: span};\n \n@@ -173,7 +174,9 @@ type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n-tag check_mode { checked; unchecked; }\n+tag blk_check_mode { checked_blk; unchecked_blk; unsafe_blk; }\n+\n+tag expr_check_mode { claimed_expr; checked_expr; }\n \n type expr = {id: node_id, node: expr_, span: span};\n \n@@ -222,7 +225,7 @@ tag expr_ {\n     expr_assert(@expr);\n \n     /* preds that typestate is aware of */\n-    expr_check(check_mode, @expr);\n+    expr_check(expr_check_mode, @expr);\n \n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */"}, {"sha": "5d2a143a946a886521eef214c2246644a6b58e55", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -185,13 +185,13 @@ fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n fn hash_ty(&&t: @ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n-    let blk_ = checked_blk([], option::some::<@expr>(e), e.id);\n+    let blk_ = checked_block([], option::some::<@expr>(e), e.id);\n     ret {node: blk_, span: e.span};\n }\n \n-fn checked_blk(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n+fn checked_block(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n    blk_ {\n-    ret {stmts: stmts1, expr: expr1, id: id1, rules: checked};\n+    ret {stmts: stmts1, expr: expr1, id: id1, rules: checked_blk};\n }\n \n fn obj_field_from_anon_obj_field(f: anon_obj_field) -> obj_field {"}, {"sha": "25344a8b2cffed5ff778f9d5a660577cf0505ada", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -828,7 +828,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n                       p.peek() == token::OROR {\n             ret parse_fn_block_expr(p);\n         } else {\n-            let blk = parse_block_tail(p, lo, ast::checked);\n+            let blk = parse_block_tail(p, lo, ast::checked_blk);\n             ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n         }\n     } else if eat_word(p, \"if\") {\n@@ -853,9 +853,9 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n     } else if eat_word(p, \"lambda\") {\n         ret parse_fn_expr(p, ast::proto_closure);\n     } else if eat_word(p, \"unchecked\") {\n-        expect(p, token::LBRACE);\n-        let blk = parse_block_tail(p, lo, ast::unchecked);\n-        ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+        ret parse_block_expr(p, lo, ast::unchecked_blk);\n+    } else if eat_word(p, \"unsafe\") {\n+        ret parse_block_expr(p, lo, ast::unsafe_blk);\n     } else if p.peek() == token::LBRACKET {\n         p.bump();\n         let mut = parse_mutability(p);\n@@ -872,7 +872,8 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_embed_type(ty));\n     } else if p.peek() == token::POUND_LBRACE {\n         p.bump();\n-        let blk = ast::mac_embed_block(parse_block_tail(p, lo, ast::checked));\n+        let blk = ast::mac_embed_block(\n+            parse_block_tail(p, lo, ast::checked_blk));\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n     } else if p.peek() == token::ELLIPSIS {\n         p.bump();\n@@ -948,15 +949,15 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n-        ex = ast::expr_check(ast::checked, e);\n+        ex = ast::expr_check(ast::checked_expr, e);\n     } else if eat_word(p, \"claim\") {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n \n         let e = parse_expr(p);\n         hi = e.span.hi;\n-        ex = ast::expr_check(ast::unchecked, e);\n+        ex = ast::expr_check(ast::claimed_expr, e);\n     } else if eat_word(p, \"ret\") {\n         if can_begin_expr(p.peek()) {\n             let e = parse_expr(p);\n@@ -1014,6 +1015,14 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ex);\n }\n \n+fn parse_block_expr(p: parser,\n+                    lo: uint,\n+                    blk_mode: ast::blk_check_mode) -> @ast::expr {\n+    expect(p, token::LBRACE);\n+    let blk = parse_block_tail(p, lo, blk_mode);\n+    ret mk_expr(p, blk.span.lo, blk.span.hi, ast::expr_block(blk));\n+}\n+\n fn parse_syntax_ext(p: parser) -> @ast::expr {\n     let lo = p.get_lo_pos();\n     expect(p, token::POUND);\n@@ -1311,7 +1320,7 @@ fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n fn parse_fn_block_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_block_decl(p);\n-    let body = parse_block_tail(p, lo, ast::checked);\n+    let body = parse_block_tail(p, lo, ast::checked_blk);\n     let _fn = {decl: decl, proto: ast::proto_block, body: body};\n     ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n }\n@@ -1675,10 +1684,12 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n fn parse_block(p: parser) -> ast::blk {\n     let lo = p.get_lo_pos();\n     if eat_word(p, \"unchecked\") {\n-        be parse_block_tail(p, lo, ast::unchecked);\n+        be parse_block_tail(p, lo, ast::unchecked_blk);\n+    } else if eat_word(p, \"unsafe\") {\n+        be parse_block_tail(p, lo, ast::unsafe_blk);\n     } else {\n         expect(p, token::LBRACE);\n-        be parse_block_tail(p, lo, ast::checked);\n+        be parse_block_tail(p, lo, ast::checked_blk);\n     }\n }\n \n@@ -1695,7 +1706,7 @@ fn parse_block_no_value(p: parser) -> ast::blk {\n // I guess that also means \"already parsed the 'impure'\" if\n // necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n-fn parse_block_tail(p: parser, lo: uint, s: ast::check_mode) -> ast::blk {\n+fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n     let stmts: [@ast::stmt] = [];\n     let expr: option::t<@ast::expr> = none;\n     while p.peek() != token::RBRACE {"}, {"sha": "10b5db1e12900202b886568c622c791abb22bbf2", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -572,7 +572,11 @@ tag embed_type { block_macro; block_block_fn; block_normal; }\n \n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {\n-    alt blk.node.rules { ast::unchecked. { word(s.s, \"unchecked\"); } _ { } }\n+    alt blk.node.rules {\n+      ast::unchecked_blk. { word(s.s, \"unchecked\"); }\n+      ast::unsafe_blk. { word(s.s, \"unsafe\"); }\n+      ast::checked_blk. { }\n+    }\n \n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n@@ -934,8 +938,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_check(m, expr) {\n         alt m {\n-          ast::unchecked. { word_nbsp(s, \"claim\"); }\n-          ast::checked. { word_nbsp(s, \"check\"); }\n+          ast::claimed_expr. { word_nbsp(s, \"claim\"); }\n+          ast::checked_expr. { word_nbsp(s, \"check\"); }\n         }\n         popen(s);\n         print_expr(s, expr);"}, {"sha": "c2ee7ff53ca5c65416f0fca705a5b224cb6e4ac0", "filename": "src/lib/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -263,7 +263,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n             let nout = os::libc::write(fd, vbuf, len);\n             if nout < 0 {\n                 log_err \"error dumping buffer\";\n-                log_err sys::rustrt::last_os_error();\n+                log_err sys::last_os_error();\n                 fail;\n             }\n             count += nout as uint;\n@@ -299,7 +299,7 @@ fn file_buf_writer(path: str, flags: [fileflag]) -> buf_writer {\n                     });\n     if fd < 0 {\n         log_err \"error opening file for writing\";\n-        log_err sys::rustrt::last_os_error();\n+        log_err sys::last_os_error();\n         fail;\n     }\n     ret fd_buf_writer(fd, option::some(@fd_res(fd)));"}, {"sha": "c366e7c4ce52c57607aa6abb91249fcc273be9c3", "filename": "src/lib/sys.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -1,11 +1,8 @@\n \n-import rustrt::size_of;\n-\n-export rustrt;\n-export size_of;\n+//export rustrt;\n+//export size_of;\n \n native \"rust\" mod rustrt {\n-\n     // Explicitly re-export native stuff we want to be made\n     // available outside this crate. Otherwise it's\n     // visible-in-crate, but not re-exported.\n@@ -17,6 +14,42 @@ native \"rust\" mod rustrt {\n     fn unsupervise();\n }\n \n+fn last_os_error() -> str {\n+    //unsafe {\n+        ret rustrt::last_os_error();\n+    //}\n+}\n+\n+fn size_of<T>() -> uint {\n+    //unsafe {\n+        ret rustrt::size_of::<T>();\n+    //}\n+}\n+\n+fn align_of<T>() -> uint {\n+    //unsafe {\n+        ret rustrt::align_of::<T>();\n+    //}\n+}\n+\n+fn refcount<T>(t: @T) -> uint {\n+    //unsafe {\n+        ret rustrt::refcount::<T>(t);\n+    //}\n+}\n+\n+fn do_gc() -> () {\n+    //unsafe {\n+        ret rustrt::do_gc();\n+    //}\n+}\n+\n+fn unsupervise() -> () {\n+    //unsafe {\n+        ret rustrt::unsupervise();\n+    //}\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "12a512e1de8292ff972a24b8b1126a0e86bdb8a6", "filename": "src/lib/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29584cc5ac9369a18d1082d3d2c95eb0471a64db/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=29584cc5ac9369a18d1082d3d2c95eb0471a64db", "patch": "@@ -32,7 +32,7 @@ iter range(lo: uint, hi: uint) -> uint {\n }\n \n fn next_power_of_two(n: uint) -> uint {\n-    let halfbits: uint = sys::rustrt::size_of::<uint>() * 4u;\n+    let halfbits: uint = sys::size_of::<uint>() * 4u;\n     let tmp: uint = n - 1u;\n     let shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }"}]}