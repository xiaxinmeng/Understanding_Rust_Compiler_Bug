{"sha": "ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMWJhMTUwYTI4MGViZTQyOGM3NjBmYmJiZDU4YWU3NThiYTllYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T13:32:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-29T13:32:13Z"}, "message": "Auto merge of #57948 - Zoxc:parallel, r=michaelwoerister\n\nUse multiple threads by default. Limits tests to one thread. Do some renaming.\n\nr? @michaelwoerister", "tree": {"sha": "1619af8b402c5af211cbea3e7f1a41c52be6c605", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1619af8b402c5af211cbea3e7f1a41c52be6c605"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "html_url": "https://github.com/rust-lang/rust/commit/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "106b3e9fa4d53efc4e8eab47d1043789c88f99a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/106b3e9fa4d53efc4e8eab47d1043789c88f99a5", "html_url": "https://github.com/rust-lang/rust/commit/106b3e9fa4d53efc4e8eab47d1043789c88f99a5"}, {"sha": "fd9d9ee3a293bab88fd4dfb69f28d5ccb92e292c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9d9ee3a293bab88fd4dfb69f28d5ccb92e292c", "html_url": "https://github.com/rust-lang/rust/commit/fd9d9ee3a293bab88fd4dfb69f28d5ccb92e292c"}], "stats": {"total": 184, "additions": 95, "deletions": 89}, "files": [{"sha": "18f05658a17baa8c7a20eb3e57cca53c44f16b0f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -2234,6 +2234,7 @@ dependencies = [\n  \"jobserver 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"polonius-engine 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "69a38ec8773815f44c39ca3dd27b8ace1f3bf2e0", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -317,8 +317,8 @@\n # Whether to always use incremental compilation when building rustc\n #incremental = false\n \n-# Build rustc with experimental parallelization\n-#experimental-parallel-queries = false\n+# Build a multi-threaded rustc\n+#parallel-compiler = false\n \n # The default linker that will be hard-coded into the generated compiler for\n # targets that don't specify linker explicitly in their target specifications."}, {"sha": "7a765973e20f8218682d7389e5e455655d353351", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -284,8 +284,8 @@ fn main() {\n         }\n     }\n \n-    if env::var_os(\"RUSTC_PARALLEL_QUERIES\").is_some() {\n-        cmd.arg(\"--cfg\").arg(\"parallel_queries\");\n+    if env::var_os(\"RUSTC_PARALLEL_COMPILER\").is_some() {\n+        cmd.arg(\"--cfg\").arg(\"parallel_compiler\");\n     }\n \n     if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()"}, {"sha": "ddae3cb0d60ce720639cf65d99d9d7b19c839e43", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -554,8 +554,8 @@ pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n     if let Some(ref s) = builder.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if builder.config.rustc_parallel_queries {\n-        cargo.env(\"RUSTC_PARALLEL_QUERIES\", \"1\");\n+    if builder.config.rustc_parallel {\n+        cargo.env(\"RUSTC_PARALLEL_COMPILER\", \"1\");\n     }\n     if builder.config.rust_verify_llvm_ir {\n         cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");"}, {"sha": "ba339c50fc30418d95692f3b79fa3d9f6de5a926", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -97,7 +97,7 @@ pub struct Config {\n     pub rust_debuginfo_only_std: bool,\n     pub rust_debuginfo_tools: bool,\n     pub rust_rpath: bool,\n-    pub rustc_parallel_queries: bool,\n+    pub rustc_parallel: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n@@ -298,7 +298,7 @@ struct Rust {\n     debuginfo_lines: Option<bool>,\n     debuginfo_only_std: Option<bool>,\n     debuginfo_tools: Option<bool>,\n-    experimental_parallel_queries: Option<bool>,\n+    parallel_compiler: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n     channel: Option<String>,\n@@ -557,7 +557,7 @@ impl Config {\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n-            config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n+            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);"}, {"sha": "b2d8f2d8ebfcf65d7bea6b5508c52037407fa214", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -35,7 +35,7 @@ def v(*args):\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n-o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n+o(\"parallel-compiler\", \"rust.parallel-compiler\", \"build a multi-threaded rustc\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"verbose-tests\", \"rust.verbose-tests\", \"enable verbose output when running tests\")"}, {"sha": "42d0d7db5964ca59a2e444e1aed0dc80ab43f795", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -82,7 +82,7 @@ fi\n SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n-  $SRC/configure --enable-experimental-parallel-queries\n+  $SRC/configure --enable-parallel-compiler\n   CARGO_INCREMENTAL=0 python2.7 ../x.py check\n   rm -f config.toml\n   rm -rf build"}, {"sha": "a5521effc7d8d2826d5a5230b1eaa0b96d94f677", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -15,6 +15,7 @@ fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n lazy_static = \"1.0.0\"\n+num_cpus = \"1.0\"\n scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n polonius-engine = \"0.6.2\""}, {"sha": "c9353a451e2cd554d86d28c566926ffaf1b5baa4", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -580,7 +580,7 @@ impl DepGraph {\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n-        #[cfg(not(parallel_queries))]\n+        #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n@@ -743,7 +743,7 @@ impl DepGraph {\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n-        #[cfg(not(parallel_queries))]\n+        #[cfg(not(parallel_compiler))]\n         debug_assert!(data.colors.get(prev_dep_node_index).is_none(),\n                       \"DepGraph::try_mark_previous_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n@@ -766,7 +766,7 @@ impl DepGraph {\n         did_allocation: bool,\n         diagnostics: Vec<Diagnostic>,\n     ) {\n-        if did_allocation || !cfg!(parallel_queries) {\n+        if did_allocation || !cfg!(parallel_compiler) {\n             // Only the thread which did the allocation emits the error messages\n             let handle = tcx.sess.diagnostic();\n \n@@ -778,7 +778,7 @@ impl DepGraph {\n                 DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n             }\n \n-            #[cfg(parallel_queries)]\n+            #[cfg(parallel_compiler)]\n             {\n                 // Mark the diagnostics and emitted and wake up waiters\n                 data.emitted_diagnostics.lock().insert(dep_node_index);"}, {"sha": "f886e50246ac016930e89b094e6069d69247167f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -70,6 +70,7 @@ extern crate core;\n extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n+extern crate num_cpus;\n #[macro_use] extern crate lazy_static;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]"}, {"sha": "4b1aefb2216fb40616d9d519170432368ef518c9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -1194,8 +1194,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"prints the llvm optimization passes being run\"),\n     ast_json: bool = (false, parse_bool, [UNTRACKED],\n         \"print the AST as JSON and halt\"),\n-    query_threads: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n-        \"execute queries on a thread pool with N threads\"),\n+    threads: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"use a thread pool with N threads\"),\n     ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n         \"print the pre-expansion AST as JSON and halt\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n@@ -1986,17 +1986,17 @@ pub fn build_session_options_and_crate_config(\n         }\n     }\n \n-    if debugging_opts.query_threads == Some(0) {\n+    if debugging_opts.threads == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for query threads must be a positive nonzero integer\",\n+            \"Value for threads must be a positive nonzero integer\",\n         );\n     }\n \n-    if debugging_opts.query_threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n+    if debugging_opts.threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"Optimization fuel is incompatible with multiple query threads\",\n+            \"Optimization fuel is incompatible with multiple threads\",\n         );\n     }\n "}, {"sha": "c5034415d6ffba3e18a0c05918ac9390ba0b90e8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -877,7 +877,7 @@ impl Session {\n         let mut ret = true;\n         if let Some(ref c) = self.optimization_fuel_crate {\n             if c == crate_name {\n-                assert_eq!(self.query_threads(), 1);\n+                assert_eq!(self.threads(), 1);\n                 let mut fuel = self.optimization_fuel.lock();\n                 ret = fuel.remaining != 0;\n                 if fuel.remaining == 0 && !fuel.out_of_fuel {\n@@ -890,7 +890,7 @@ impl Session {\n         }\n         if let Some(ref c) = self.print_fuel_crate {\n             if c == crate_name {\n-                assert_eq!(self.query_threads(), 1);\n+                assert_eq!(self.threads(), 1);\n                 self.print_fuel.fetch_add(1, SeqCst);\n             }\n         }\n@@ -899,14 +899,14 @@ impl Session {\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n-    pub fn query_threads_from_opts(opts: &config::Options) -> usize {\n-        opts.debugging_opts.query_threads.unwrap_or(1)\n+    pub fn threads_from_opts(opts: &config::Options) -> usize {\n+        opts.debugging_opts.threads.unwrap_or(::num_cpus::get())\n     }\n \n     /// Returns the number of query threads that should be used for this\n     /// compilation\n-    pub fn query_threads(&self) -> usize {\n-        Self::query_threads_from_opts(&self.opts)\n+    pub fn threads(&self) -> usize {\n+        Self::threads_from_opts(&self.opts)\n     }\n \n     /// Returns the number of codegen units that should be used for this"}, {"sha": "881c0d4e6d23938fc2a982be712b2c9f07953763", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -1823,10 +1823,10 @@ pub mod tls {\n     use rustc_data_structures::thin_vec::ThinVec;\n     use dep_graph::TaskDeps;\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     use std::cell::Cell;\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     use rayon_core;\n \n     /// This is the implicit state of rustc. It contains the current\n@@ -1859,28 +1859,28 @@ pub mod tls {\n     /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n     /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n     /// This is used to get the pointer to the current ImplicitCtxt.\n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline]\n     fn get_tlv() -> usize {\n         rayon_core::tlv::get()\n     }\n \n     /// A thread local variable which stores a pointer to the current ImplicitCtxt\n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n     /// This is used to set the pointer to the new ImplicitCtxt.\n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n@@ -1890,7 +1890,7 @@ pub mod tls {\n     }\n \n     /// This is used to get the pointer to the current ImplicitCtxt.\n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }"}, {"sha": "abbf74a7761effe2f353b31b6df41ec07c06df33", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -8,7 +8,7 @@ use syntax_pos::Span;\n use ty::tls;\n use ty::query::Query;\n use ty::query::plumbing::CycleError;\n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n use ty::query::{\n     plumbing::TryGetJob,\n     config::QueryDescription,\n@@ -17,7 +17,7 @@ use ty::context::TyCtxt;\n use std::process;\n use std::{fmt, ptr};\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n use {\n     rayon_core,\n     parking_lot::{Mutex, Condvar},\n@@ -54,7 +54,7 @@ pub struct QueryJob<'tcx> {\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n \n     /// The latch which is used to wait on this job\n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     latch: QueryLatch<'tcx>,\n }\n \n@@ -64,7 +64,7 @@ impl<'tcx> QueryJob<'tcx> {\n         QueryJob {\n             info,\n             parent,\n-            #[cfg(parallel_queries)]\n+            #[cfg(parallel_compiler)]\n             latch: QueryLatch::new(),\n         }\n     }\n@@ -73,7 +73,7 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(never)]\n     #[cold]\n     pub(super) fn cycle_error<'lcx, 'a, D: QueryDescription<'tcx>>(\n@@ -88,7 +88,7 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n     /// query that means that there is a query cycle, thus this always running a cycle error.\n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     pub(super) fn await<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n@@ -113,7 +113,7 @@ impl<'tcx> QueryJob<'tcx> {\n         })\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     fn find_cycle_in_stack<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n@@ -152,7 +152,7 @@ impl<'tcx> QueryJob<'tcx> {\n     /// This does nothing for single threaded rustc,\n     /// as there are no concurrent jobs which could be waiting on us\n     pub fn signal_complete(&self) {\n-        #[cfg(parallel_queries)]\n+        #[cfg(parallel_compiler)]\n         self.latch.set();\n     }\n \n@@ -161,34 +161,34 @@ impl<'tcx> QueryJob<'tcx> {\n     }\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n struct QueryWaiter<'tcx> {\n     query: Option<Lrc<QueryJob<'tcx>>>,\n     condvar: Condvar,\n     span: Span,\n     cycle: Lock<Option<CycleError<'tcx>>>,\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n impl<'tcx> QueryWaiter<'tcx> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n struct QueryLatchInfo<'tcx> {\n     complete: bool,\n     waiters: Vec<Lrc<QueryWaiter<'tcx>>>,\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n struct QueryLatch<'tcx> {\n     info: Mutex<QueryLatchInfo<'tcx>>,\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n impl<'tcx> QueryLatch<'tcx> {\n     fn new() -> Self {\n         QueryLatch {\n@@ -242,7 +242,7 @@ impl<'tcx> QueryLatch<'tcx> {\n }\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n@@ -254,7 +254,7 @@ type Waiter<'tcx> = (Lrc<QueryJob<'tcx>>, usize);\n /// For visits of resumable waiters it returns Some(Some(Waiter)) which has the\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn visit_waiters<'tcx, F>(query: Lrc<QueryJob<'tcx>>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n where\n     F: FnMut(Span, Lrc<QueryJob<'tcx>>) -> Option<Option<Waiter<'tcx>>>\n@@ -282,7 +282,7 @@ where\n /// `span` is the reason for the `query` to execute. This is initially DUMMY_SP.\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n                      span: Span,\n                      stack: &mut Vec<(Span, Lrc<QueryJob<'tcx>>)>,\n@@ -321,7 +321,7 @@ fn cycle_check<'tcx>(query: Lrc<QueryJob<'tcx>>,\n /// Finds out if there's a path to the compiler root (aka. code which isn't in a query)\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n@@ -346,7 +346,7 @@ fn connected_to_root<'tcx>(\n }\n \n // Deterministically pick an query from a list\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n     tcx: TyCtxt<'_, 'tcx, '_>,\n     queries: &'a [T],\n@@ -372,7 +372,7 @@ fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n /// the function return true.\n /// If a cycle was not found, the starting query is removed from `jobs` and\n /// the function returns false.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn remove_cycle<'tcx>(\n     jobs: &mut Vec<Lrc<QueryJob<'tcx>>>,\n     wakelist: &mut Vec<Lrc<QueryWaiter<'tcx>>>,\n@@ -475,7 +475,7 @@ fn remove_cycle<'tcx>(\n /// Creates a new thread and forwards information in thread locals to it.\n /// The new thread runs the deadlock handler.\n /// Must only be called when a deadlock is about to happen.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n pub unsafe fn handle_deadlock() {\n     use syntax;\n     use syntax_pos;\n@@ -514,7 +514,7 @@ pub unsafe fn handle_deadlock() {\n /// uses a query latch and then resuming that waiter.\n /// There may be multiple cycles involved in a deadlock, so this searches\n /// all active queries for cycles before finally resuming all the waiters at once.\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n     let on_panic = OnDrop(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");"}, {"sha": "195bec11ee570b960296edb5d44ec1a19d982785", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -69,7 +69,7 @@ pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n pub use self::job::handle_deadlock;\n \n mod keys;"}, {"sha": "e777c883c37874ab73b371337ba8d4b77ab07b04", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -153,12 +153,12 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n \n             // If we are single-threaded we know that we have cycle error,\n             // so we just turn the errror\n-            #[cfg(not(parallel_queries))]\n+            #[cfg(not(parallel_compiler))]\n             return job.cycle_error(tcx, span);\n \n             // With parallel queries we might just have to wait on some other\n             // thread\n-            #[cfg(parallel_queries)]\n+            #[cfg(parallel_compiler)]\n             {\n                 if let Err(cycle) = job.await(tcx, span) {\n                     return TryGetJob::JobCompleted(Err(cycle));\n@@ -695,7 +695,7 @@ macro_rules! define_queries_inner {\n         [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use std::mem;\n-        #[cfg(parallel_queries)]\n+        #[cfg(parallel_compiler)]\n         use ty::query::job::QueryResult;\n         use rustc_data_structures::sync::Lock;\n         use {\n@@ -736,7 +736,7 @@ macro_rules! define_queries_inner {\n                 });\n             }\n \n-            #[cfg(parallel_queries)]\n+            #[cfg(parallel_compiler)]\n             pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n                 let mut jobs = Vec::new();\n "}, {"sha": "cae3087fe586cc73a26c2b0baf0965fd508acf72", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -1,21 +1,21 @@\n-//! This module defines types which are thread safe if cfg!(parallel_queries) is true.\n+//! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n //!\n //! `Lrc` is an alias of either Rc or Arc.\n //!\n //! `Lock` is a mutex.\n-//! It internally uses `parking_lot::Mutex` if cfg!(parallel_queries) is true,\n+//! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n //! `RefCell` otherwise.\n //!\n //! `RwLock` is a read-write lock.\n-//! It internally uses `parking_lot::RwLock` if cfg!(parallel_queries) is true,\n+//! It internally uses `parking_lot::RwLock` if cfg!(parallel_compiler) is true,\n //! `RefCell` otherwise.\n //!\n-//! `MTLock` is a mutex which disappears if cfg!(parallel_queries) is false.\n+//! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n //!\n-//! `MTRef` is a immutable reference if cfg!(parallel_queries), and an mutable reference otherwise.\n+//! `MTRef` is a immutable reference if cfg!(parallel_compiler), and an mutable reference otherwise.\n //!\n //! `rustc_erase_owner!` erases a OwningRef owner into Erased or Erased + Send + Sync\n-//! depending on the value of cfg!(parallel_queries).\n+//! depending on the value of cfg!(parallel_compiler).\n \n use std::collections::HashMap;\n use std::hash::{Hash, BuildHasher};\n@@ -50,7 +50,7 @@ pub use std::sync::atomic::Ordering::SeqCst;\n pub use std::sync::atomic::Ordering;\n \n cfg_if! {\n-    if #[cfg(not(parallel_queries))] {\n+    if #[cfg(not(parallel_compiler))] {\n         pub auto trait Send {}\n         pub auto trait Sync {}\n \n@@ -461,19 +461,19 @@ impl<T> Lock<T> {\n         self.0.get_mut()\n     }\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline(always)]\n     pub fn try_lock(&self) -> Option<LockGuard<T>> {\n         self.0.try_lock()\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn try_lock(&self) -> Option<LockGuard<T>> {\n         self.0.try_borrow_mut().ok()\n     }\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline(always)]\n     pub fn lock(&self) -> LockGuard<T> {\n         if ERROR_CHECKING {\n@@ -483,7 +483,7 @@ impl<T> Lock<T> {\n         }\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn lock(&self) -> LockGuard<T> {\n         self.0.borrow_mut()\n@@ -539,13 +539,13 @@ impl<T> RwLock<T> {\n         self.0.get_mut()\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn read(&self) -> ReadGuard<T> {\n         self.0.borrow()\n     }\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline(always)]\n     pub fn read(&self) -> ReadGuard<T> {\n         if ERROR_CHECKING {\n@@ -560,25 +560,25 @@ impl<T> RwLock<T> {\n         f(&*self.read())\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn try_write(&self) -> Result<WriteGuard<T>, ()> {\n         self.0.try_borrow_mut().map_err(|_| ())\n     }\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline(always)]\n     pub fn try_write(&self) -> Result<WriteGuard<T>, ()> {\n         self.0.try_write().ok_or(())\n     }\n \n-    #[cfg(not(parallel_queries))]\n+    #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn write(&self) -> WriteGuard<T> {\n         self.0.borrow_mut()\n     }\n \n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     #[inline(always)]\n     pub fn write(&self) -> WriteGuard<T> {\n         if ERROR_CHECKING {\n@@ -616,27 +616,27 @@ impl<T: Clone> Clone for RwLock<T> {\n /// It will panic if it is used on multiple threads.\n #[derive(Copy, Clone, Hash, Debug, Eq, PartialEq)]\n pub struct OneThread<T> {\n-    #[cfg(parallel_queries)]\n+    #[cfg(parallel_compiler)]\n     thread: thread::ThreadId,\n     inner: T,\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n unsafe impl<T> std::marker::Sync for OneThread<T> {}\n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n unsafe impl<T> std::marker::Send for OneThread<T> {}\n \n impl<T> OneThread<T> {\n     #[inline(always)]\n     fn check(&self) {\n-        #[cfg(parallel_queries)]\n+        #[cfg(parallel_compiler)]\n         assert_eq!(thread::current().id(), self.thread);\n     }\n \n     #[inline(always)]\n     pub fn new(inner: T) -> Self {\n         OneThread {\n-            #[cfg(parallel_queries)]\n+            #[cfg(parallel_compiler)]\n             thread: thread::current().id(),\n             inner,\n         }"}, {"sha": "c586c705676f40e1053dd592fa63f390482377c6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -56,7 +56,7 @@ use proc_macro_decls;\n use profile;\n use super::Compilation;\n \n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n     opts: config::Options,\n     f: F\n@@ -66,7 +66,7 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     })\n }\n \n-#[cfg(parallel_queries)]\n+#[cfg(parallel_compiler)]\n pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n     opts: config::Options,\n     f: F\n@@ -78,7 +78,7 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     let gcx_ptr = &Lock::new(0);\n \n     let config = ThreadPoolBuilder::new()\n-        .num_threads(Session::query_threads_from_opts(&opts))\n+        .num_threads(Session::threads_from_opts(&opts))\n         .deadlock_handler(|| unsafe { ty::query::handle_deadlock() })\n         .stack_size(::STACK_SIZE);\n "}, {"sha": "2a85779239689666a04adeffa6235ed0c92e6ba3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -238,9 +238,9 @@ impl SpanData {\n // The interner is pointed to by a thread local value which is only set on the main thread\n // with parallelization is disabled. So we don't allow `Span` to transfer between threads\n // to avoid panics and other errors, even though it would be memory safe to do so.\n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n impl !Send for Span {}\n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n impl !Sync for Span {}\n \n impl PartialOrd for Span {"}, {"sha": "7097f332b8b8f5cbdd210714b58e7d425215148a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -150,9 +150,9 @@ newtype_index! {\n // The interner is pointed to by a thread local value which is only set on the main thread\n // with parallelization is disabled. So we don't allow `Symbol` to transfer between threads\n // to avoid panics and other errors, even though it would be memory safe to do so.\n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n impl !Send for Symbol { }\n-#[cfg(not(parallel_queries))]\n+#[cfg(not(parallel_compiler))]\n impl !Sync for Symbol { }\n \n impl Symbol {"}, {"sha": "3581c4cfbcb84d5b4ea58b5820a9f80a043399c0", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae1ba150a280ebe428c760fbbbd58ae758ba9ea7/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=ae1ba150a280ebe428c760fbbbd58ae758ba9ea7", "patch": "@@ -1727,6 +1727,9 @@ impl<'test> TestCx<'test> {\n         // FIXME Why is -L here?\n         rustc.arg(input_file); //.arg(\"-L\").arg(&self.config.build_base);\n \n+        // Use a single thread for efficiency and a deterministic error message order\n+        rustc.arg(\"-Zthreads=1\");\n+\n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self\n             .props"}]}