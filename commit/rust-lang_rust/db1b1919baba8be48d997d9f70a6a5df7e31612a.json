{"sha": "db1b1919baba8be48d997d9f70a6a5df7e31612a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMWIxOTE5YmFiYThiZTQ4ZDk5N2Q5ZjcwYTZhNWRmN2UzMTYxMmE=", "commit": {"author": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2016-06-21T21:27:15Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2016-06-29T23:08:32Z"}, "message": "std: use siphash-1-3 for HashMap", "tree": {"sha": "144c3a5cf592d004de76aafc793fc3e047ac22c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/144c3a5cf592d004de76aafc793fc3e047ac22c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db1b1919baba8be48d997d9f70a6a5df7e31612a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db1b1919baba8be48d997d9f70a6a5df7e31612a", "html_url": "https://github.com/rust-lang/rust/commit/db1b1919baba8be48d997d9f70a6a5df7e31612a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db1b1919baba8be48d997d9f70a6a5df7e31612a/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59152a45af3688b53e677ea2362339643499c1a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/59152a45af3688b53e677ea2362339643499c1a4", "html_url": "https://github.com/rust-lang/rust/commit/59152a45af3688b53e677ea2362339643499c1a4"}], "stats": {"total": 413, "additions": 336, "deletions": 77}, "files": [{"sha": "9e3f7a4a84a814b318a9833f18fb6352fca5b1e3", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -80,6 +80,9 @@ use mem;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sip::SipHasher;\n \n+#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+pub use self::sip::{SipHasher13, SipHasher24};\n+\n mod sip;\n \n /// A hashable type."}, {"sha": "c52c0b0730be785d8d8aad84bdd68577df4023e3", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 197, "deletions": 52, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -8,12 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An implementation of SipHash 2-4.\n+//! An implementation of SipHash.\n \n use prelude::v1::*;\n \n+use marker::PhantomData;\n use ptr;\n-use super::Hasher;\n+\n+/// An implementation of SipHash 1-3.\n+///\n+/// See: https://131002.net/siphash/\n+#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[derive(Debug, Clone, Default)]\n+pub struct SipHasher13 {\n+    hasher: Hasher<Sip13Rounds>,\n+}\n+\n+/// An implementation of SipHash 2-4.\n+///\n+/// See: https://131002.net/siphash/\n+#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[derive(Debug, Clone, Default)]\n+pub struct SipHasher24 {\n+    hasher: Hasher<Sip24Rounds>,\n+}\n \n /// An implementation of SipHash 2-4.\n ///\n@@ -30,22 +48,31 @@ use super::Hasher;\n /// Although the SipHash algorithm is considered to be generally strong,\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n-#[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SipHasher {\n+#[derive(Debug, Clone, Default)]\n+pub struct SipHasher(SipHasher24);\n+\n+#[derive(Debug)]\n+struct Hasher<S: Sip> {\n     k0: u64,\n     k1: u64,\n     length: usize, // how many bytes we've processed\n+    state: State, // hash State\n+    tail: u64, // unprocessed bytes le\n+    ntail: usize, // how many bytes in tail are valid\n+    _marker: PhantomData<S>,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+struct State {\n     // v0, v2 and v1, v3 show up in pairs in the algorithm,\n     // and simd implementations of SipHash will use vectors\n     // of v02 and v13. By placing them in this order in the struct,\n     // the compiler can pick up on just a few simd optimizations by itself.\n-    v0: u64, // hash state\n+    v0: u64,\n     v2: u64,\n     v1: u64,\n     v3: u64,\n-    tail: u64, // unprocessed bytes le\n-    ntail: usize, // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -93,6 +120,9 @@ macro_rules! rotl {\n }\n \n macro_rules! compress {\n+    ($state:expr) => ({\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    });\n     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n         $v0 = $v0.wrapping_add($v1); $v1 = rotl!($v1, 13); $v1 ^= $v0;\n@@ -101,7 +131,7 @@ macro_rules! compress {\n         $v0 = $v0.wrapping_add($v3); $v3 = rotl!($v3, 21); $v3 ^= $v0;\n         $v2 = $v2.wrapping_add($v1); $v1 = rotl!($v1, 17); $v1 ^= $v2;\n         $v2 = rotl!($v2, 32);\n-    })\n+    });\n }\n \n impl SipHasher {\n@@ -116,16 +146,63 @@ impl SipHasher {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        let mut state = SipHasher {\n+        SipHasher(SipHasher24::new_with_keys(key0, key1))\n+    }\n+}\n+\n+\n+impl SipHasher13 {\n+    /// Creates a new `SipHasher13` with the two initial keys set to 0.\n+    #[inline]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    pub fn new() -> SipHasher13 {\n+        SipHasher13::new_with_keys(0, 0)\n+    }\n+\n+    /// Creates a `SipHasher13` that is keyed off the provided keys.\n+    #[inline]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n+        SipHasher13 {\n+            hasher: Hasher::new_with_keys(key0, key1)\n+        }\n+    }\n+}\n+\n+impl SipHasher24 {\n+    /// Creates a new `SipHasher24` with the two initial keys set to 0.\n+    #[inline]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    pub fn new() -> SipHasher24 {\n+        SipHasher24::new_with_keys(0, 0)\n+    }\n+\n+    /// Creates a `SipHasher24` that is keyed off the provided keys.\n+    #[inline]\n+    #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n+        SipHasher24 {\n+            hasher: Hasher::new_with_keys(key0, key1)\n+        }\n+    }\n+}\n+\n+impl<S: Sip> Hasher<S> {\n+    #[inline]\n+    fn new_with_keys(key0: u64, key1: u64) -> Hasher<S> {\n+        let mut state = Hasher {\n             k0: key0,\n             k1: key1,\n             length: 0,\n-            v0: 0,\n-            v1: 0,\n-            v2: 0,\n-            v3: 0,\n+            state: State {\n+                v0: 0,\n+                v1: 0,\n+                v2: 0,\n+                v3: 0,\n+            },\n             tail: 0,\n             ntail: 0,\n+            _marker: PhantomData,\n         };\n         state.reset();\n         state\n@@ -134,16 +211,54 @@ impl SipHasher {\n     #[inline]\n     fn reset(&mut self) {\n         self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.state.v3 = self.k1 ^ 0x7465646279746573;\n         self.ntail = 0;\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Hasher for SipHasher {\n+impl super::Hasher for SipHasher {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.0.write(msg)\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.0.finish()\n+    }\n+}\n+\n+#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+impl super::Hasher for SipHasher13 {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.hasher.write(msg)\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hasher.finish()\n+    }\n+}\n+\n+#[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+impl super::Hasher for SipHasher24 {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.hasher.write(msg)\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hasher.finish()\n+    }\n+}\n+\n+impl<S: Sip> super::Hasher for Hasher<S> {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -161,10 +276,9 @@ impl Hasher for SipHasher {\n \n             let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n \n-            self.v3 ^= m;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= m;\n+            self.state.v3 ^= m;\n+            S::c_rounds(&mut self.state);\n+            self.state.v0 ^= m;\n \n             self.ntail = 0;\n         }\n@@ -177,10 +291,9 @@ impl Hasher for SipHasher {\n         while i < len - left {\n             let mi = unsafe { load_u64_le(msg, i) };\n \n-            self.v3 ^= mi;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= mi;\n+            self.state.v3 ^= mi;\n+            S::c_rounds(&mut self.state);\n+            self.state.v0 ^= mi;\n \n             i += 8;\n         }\n@@ -191,49 +304,81 @@ impl Hasher for SipHasher {\n \n     #[inline]\n     fn finish(&self) -> u64 {\n-        let mut v0 = self.v0;\n-        let mut v1 = self.v1;\n-        let mut v2 = self.v2;\n-        let mut v3 = self.v3;\n+        let mut state = self.state;\n \n         let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n \n-        v3 ^= b;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        v0 ^= b;\n+        state.v3 ^= b;\n+        S::c_rounds(&mut state);\n+        state.v0 ^= b;\n \n-        v2 ^= 0xff;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n+        state.v2 ^= 0xff;\n+        S::d_rounds(&mut state);\n \n-        v0 ^ v1 ^ v2 ^ v3\n+        state.v0 ^ state.v1 ^ state.v2 ^ state.v3\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for SipHasher {\n+impl<S: Sip> Clone for Hasher<S> {\n     #[inline]\n-    fn clone(&self) -> SipHasher {\n-        SipHasher {\n+    fn clone(&self) -> Hasher<S> {\n+        Hasher {\n             k0: self.k0,\n             k1: self.k1,\n             length: self.length,\n-            v0: self.v0,\n-            v1: self.v1,\n-            v2: self.v2,\n-            v3: self.v3,\n+            state: self.state,\n             tail: self.tail,\n             ntail: self.ntail,\n+            _marker: self._marker,\n         }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for SipHasher {\n-    fn default() -> SipHasher {\n-        SipHasher::new()\n+impl<S: Sip> Default for Hasher<S> {\n+    #[inline]\n+    fn default() -> Hasher<S> {\n+        Hasher::new_with_keys(0, 0)\n+    }\n+}\n+\n+#[doc(hidden)]\n+trait Sip {\n+    fn c_rounds(&mut State);\n+    fn d_rounds(&mut State);\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct Sip13Rounds;\n+\n+impl Sip for Sip13Rounds {\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct Sip24Rounds;\n+\n+impl Sip for Sip24Rounds {\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n     }\n }"}, {"sha": "a5e6005545bd73d8407ca7985c6c4463c3c1f213", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 110, "deletions": 21, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -10,7 +10,7 @@\n use test::{Bencher, black_box};\n \n use core::hash::{Hash, Hasher};\n-use core::hash::SipHasher;\n+use core::hash::{SipHasher, SipHasher13, SipHasher24};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -45,27 +45,117 @@ macro_rules! u8to64_le {\n     });\n }\n \n-fn hash<T: Hash>(x: &T) -> u64 {\n-    let mut st = SipHasher::new();\n+fn hash_with<H: Hasher, T: Hash>(mut st: H, x: &T) -> u64 {\n     x.hash(&mut st);\n     st.finish()\n }\n \n-fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 {\n-    let mut st = SipHasher::new_with_keys(k1, k2);\n-    x.hash(&mut st);\n-    st.finish()\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    hash_with(SipHasher::new(), x)\n }\n \n-fn hash_bytes(x: &[u8]) -> u64 {\n-    let mut s = SipHasher::default();\n+fn hash_bytes<H: Hasher>(mut s: H, x: &[u8]) -> u64 {\n     Hasher::write(&mut s, x);\n     s.finish()\n }\n \n #[test]\n #[allow(unused_must_use)]\n-fn test_siphash() {\n+fn test_siphash_1_3() {\n+    let vecs : [[u8; 8]; 64] = [\n+        [ 0xdc, 0xc4, 0x0f, 0x05, 0x58, 0x01, 0xac, 0xab ],\n+        [ 0x93, 0xca, 0x57, 0x7d, 0xf3, 0x9b, 0xf4, 0xc9 ],\n+        [ 0x4d, 0xd4, 0xc7, 0x4d, 0x02, 0x9b, 0xcb, 0x82 ],\n+        [ 0xfb, 0xf7, 0xdd, 0xe7, 0xb8, 0x0a, 0xf8, 0x8b ],\n+        [ 0x28, 0x83, 0xd3, 0x88, 0x60, 0x57, 0x75, 0xcf ],\n+        [ 0x67, 0x3b, 0x53, 0x49, 0x2f, 0xd5, 0xf9, 0xde ],\n+        [ 0xa7, 0x22, 0x9f, 0xc5, 0x50, 0x2b, 0x0d, 0xc5 ],\n+        [ 0x40, 0x11, 0xb1, 0x9b, 0x98, 0x7d, 0x92, 0xd3 ],\n+        [ 0x8e, 0x9a, 0x29, 0x8d, 0x11, 0x95, 0x90, 0x36 ],\n+        [ 0xe4, 0x3d, 0x06, 0x6c, 0xb3, 0x8e, 0xa4, 0x25 ],\n+        [ 0x7f, 0x09, 0xff, 0x92, 0xee, 0x85, 0xde, 0x79 ],\n+        [ 0x52, 0xc3, 0x4d, 0xf9, 0xc1, 0x18, 0xc1, 0x70 ],\n+        [ 0xa2, 0xd9, 0xb4, 0x57, 0xb1, 0x84, 0xa3, 0x78 ],\n+        [ 0xa7, 0xff, 0x29, 0x12, 0x0c, 0x76, 0x6f, 0x30 ],\n+        [ 0x34, 0x5d, 0xf9, 0xc0, 0x11, 0xa1, 0x5a, 0x60 ],\n+        [ 0x56, 0x99, 0x51, 0x2a, 0x6d, 0xd8, 0x20, 0xd3 ],\n+        [ 0x66, 0x8b, 0x90, 0x7d, 0x1a, 0xdd, 0x4f, 0xcc ],\n+        [ 0x0c, 0xd8, 0xdb, 0x63, 0x90, 0x68, 0xf2, 0x9c ],\n+        [ 0x3e, 0xe6, 0x73, 0xb4, 0x9c, 0x38, 0xfc, 0x8f ],\n+        [ 0x1c, 0x7d, 0x29, 0x8d, 0xe5, 0x9d, 0x1f, 0xf2 ],\n+        [ 0x40, 0xe0, 0xcc, 0xa6, 0x46, 0x2f, 0xdc, 0xc0 ],\n+        [ 0x44, 0xf8, 0x45, 0x2b, 0xfe, 0xab, 0x92, 0xb9 ],\n+        [ 0x2e, 0x87, 0x20, 0xa3, 0x9b, 0x7b, 0xfe, 0x7f ],\n+        [ 0x23, 0xc1, 0xe6, 0xda, 0x7f, 0x0e, 0x5a, 0x52 ],\n+        [ 0x8c, 0x9c, 0x34, 0x67, 0xb2, 0xae, 0x64, 0xf4 ],\n+        [ 0x79, 0x09, 0x5b, 0x70, 0x28, 0x59, 0xcd, 0x45 ],\n+        [ 0xa5, 0x13, 0x99, 0xca, 0xe3, 0x35, 0x3e, 0x3a ],\n+        [ 0x35, 0x3b, 0xde, 0x4a, 0x4e, 0xc7, 0x1d, 0xa9 ],\n+        [ 0x0d, 0xd0, 0x6c, 0xef, 0x02, 0xed, 0x0b, 0xfb ],\n+        [ 0xf4, 0xe1, 0xb1, 0x4a, 0xb4, 0x3c, 0xd9, 0x88 ],\n+        [ 0x63, 0xe6, 0xc5, 0x43, 0xd6, 0x11, 0x0f, 0x54 ],\n+        [ 0xbc, 0xd1, 0x21, 0x8c, 0x1f, 0xdd, 0x70, 0x23 ],\n+        [ 0x0d, 0xb6, 0xa7, 0x16, 0x6c, 0x7b, 0x15, 0x81 ],\n+        [ 0xbf, 0xf9, 0x8f, 0x7a, 0xe5, 0xb9, 0x54, 0x4d ],\n+        [ 0x3e, 0x75, 0x2a, 0x1f, 0x78, 0x12, 0x9f, 0x75 ],\n+        [ 0x91, 0x6b, 0x18, 0xbf, 0xbe, 0xa3, 0xa1, 0xce ],\n+        [ 0x06, 0x62, 0xa2, 0xad, 0xd3, 0x08, 0xf5, 0x2c ],\n+        [ 0x57, 0x30, 0xc3, 0xa3, 0x2d, 0x1c, 0x10, 0xb6 ],\n+        [ 0xa1, 0x36, 0x3a, 0xae, 0x96, 0x74, 0xf4, 0xb3 ],\n+        [ 0x92, 0x83, 0x10, 0x7b, 0x54, 0x57, 0x6b, 0x62 ],\n+        [ 0x31, 0x15, 0xe4, 0x99, 0x32, 0x36, 0xd2, 0xc1 ],\n+        [ 0x44, 0xd9, 0x1a, 0x3f, 0x92, 0xc1, 0x7c, 0x66 ],\n+        [ 0x25, 0x88, 0x13, 0xc8, 0xfe, 0x4f, 0x70, 0x65 ],\n+        [ 0xa6, 0x49, 0x89, 0xc2, 0xd1, 0x80, 0xf2, 0x24 ],\n+        [ 0x6b, 0x87, 0xf8, 0xfa, 0xed, 0x1c, 0xca, 0xc2 ],\n+        [ 0x96, 0x21, 0x04, 0x9f, 0xfc, 0x4b, 0x16, 0xc2 ],\n+        [ 0x23, 0xd6, 0xb1, 0x68, 0x93, 0x9c, 0x6e, 0xa1 ],\n+        [ 0xfd, 0x14, 0x51, 0x8b, 0x9c, 0x16, 0xfb, 0x49 ],\n+        [ 0x46, 0x4c, 0x07, 0xdf, 0xf8, 0x43, 0x31, 0x9f ],\n+        [ 0xb3, 0x86, 0xcc, 0x12, 0x24, 0xaf, 0xfd, 0xc6 ],\n+        [ 0x8f, 0x09, 0x52, 0x0a, 0xd1, 0x49, 0xaf, 0x7e ],\n+        [ 0x9a, 0x2f, 0x29, 0x9d, 0x55, 0x13, 0xf3, 0x1c ],\n+        [ 0x12, 0x1f, 0xf4, 0xa2, 0xdd, 0x30, 0x4a, 0xc4 ],\n+        [ 0xd0, 0x1e, 0xa7, 0x43, 0x89, 0xe9, 0xfa, 0x36 ],\n+        [ 0xe6, 0xbc, 0xf0, 0x73, 0x4c, 0xb3, 0x8f, 0x31 ],\n+        [ 0x80, 0xe9, 0xa7, 0x70, 0x36, 0xbf, 0x7a, 0xa2 ],\n+        [ 0x75, 0x6d, 0x3c, 0x24, 0xdb, 0xc0, 0xbc, 0xb4 ],\n+        [ 0x13, 0x15, 0xb7, 0xfd, 0x52, 0xd8, 0xf8, 0x23 ],\n+        [ 0x08, 0x8a, 0x7d, 0xa6, 0x4d, 0x5f, 0x03, 0x8f ],\n+        [ 0x48, 0xf1, 0xe8, 0xb7, 0xe5, 0xd0, 0x9c, 0xd8 ],\n+        [ 0xee, 0x44, 0xa6, 0xf7, 0xbc, 0xe6, 0xf4, 0xf6 ],\n+        [ 0xf2, 0x37, 0x18, 0x0f, 0xd8, 0x9a, 0xc5, 0xae ],\n+        [ 0xe0, 0x94, 0x66, 0x4b, 0x15, 0xf6, 0xb2, 0xc3 ],\n+        [ 0xa8, 0xb3, 0xbb, 0xb7, 0x62, 0x90, 0x19, 0x9d ]\n+    ];\n+\n+    let k0 = 0x_07_06_05_04_03_02_01_00;\n+    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+    let mut buf = Vec::new();\n+    let mut t = 0;\n+    let mut state_inc = SipHasher13::new_with_keys(k0, k1);\n+\n+    while t < 64 {\n+        let vec = u8to64_le!(vecs[t], 0);\n+        let out = hash_with(SipHasher13::new_with_keys(k0, k1), &Bytes(&buf));\n+        assert_eq!(vec, out);\n+\n+        let full = hash_with(SipHasher13::new_with_keys(k0, k1), &Bytes(&buf));\n+        let i = state_inc.finish();\n+\n+        assert_eq!(full, i);\n+        assert_eq!(full, vec);\n+\n+        buf.push(t as u8);\n+        Hasher::write(&mut state_inc, &[t as u8]);\n+\n+        t += 1;\n+    }\n+}\n+\n+#[test]\n+#[allow(unused_must_use)]\n+fn test_siphash_2_4() {\n     let vecs : [[u8; 8]; 64] = [\n         [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n         [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n@@ -137,14 +227,14 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n+    let mut state_inc = SipHasher24::new_with_keys(k0, k1);\n \n     while t < 64 {\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with_keys(k0, k1, &Bytes(&buf));\n+        let out = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        let full = hash_with_keys(k0, k1, &Bytes(&buf));\n+        let full = hash_with(SipHasher24::new_with_keys(k0, k1), &Bytes(&buf));\n         let i = state_inc.finish();\n \n         assert_eq!(full, i);\n@@ -156,7 +246,6 @@ fn test_siphash() {\n         t += 1;\n     }\n }\n-\n #[test] #[cfg(target_arch = \"arm\")]\n fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n@@ -289,7 +378,7 @@ fn bench_u32_keyed(b: &mut Bencher) {\n     let k1 = black_box(0x1);\n     let k2 = black_box(0x2);\n     b.iter(|| {\n-        hash_with_keys(k1, k2, &u)\n+        hash_with(SipHasher::new_with_keys(k1, k2), &u)\n     });\n     b.bytes = 8;\n }\n@@ -308,7 +397,7 @@ fn bench_u64(b: &mut Bencher) {\n fn bench_bytes_4(b: &mut Bencher) {\n     let data = black_box([b' '; 4]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 4;\n }\n@@ -317,7 +406,7 @@ fn bench_bytes_4(b: &mut Bencher) {\n fn bench_bytes_7(b: &mut Bencher) {\n     let data = black_box([b' '; 7]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 7;\n }\n@@ -326,7 +415,7 @@ fn bench_bytes_7(b: &mut Bencher) {\n fn bench_bytes_8(b: &mut Bencher) {\n     let data = black_box([b' '; 8]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 8;\n }\n@@ -335,7 +424,7 @@ fn bench_bytes_8(b: &mut Bencher) {\n fn bench_bytes_a_16(b: &mut Bencher) {\n     let data = black_box([b' '; 16]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 16;\n }\n@@ -344,7 +433,7 @@ fn bench_bytes_a_16(b: &mut Bencher) {\n fn bench_bytes_b_32(b: &mut Bencher) {\n     let data = black_box([b' '; 32]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 32;\n }\n@@ -353,7 +442,7 @@ fn bench_bytes_b_32(b: &mut Bencher) {\n fn bench_bytes_c_128(b: &mut Bencher) {\n     let data = black_box([b' '; 128]);\n     b.iter(|| {\n-        hash_bytes(&data)\n+        hash_bytes(SipHasher::default(), &data)\n     });\n     b.bytes = 128;\n }"}, {"sha": "0c4385725edfceef762f9aafbeb754cfc78f6c1a", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -26,6 +26,7 @@\n #![feature(nonzero)]\n #![feature(rand)]\n #![feature(raw)]\n+#![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n #![feature(step_by)]\n #![feature(test)]"}, {"sha": "60d7e01d98814a99dc61c725a6fd97c09713c7e2", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -14,7 +14,7 @@ use self::VacantEntryState::*;\n use borrow::Borrow;\n use cmp::max;\n use fmt::{self, Debug};\n-use hash::{Hash, SipHasher, BuildHasher};\n+use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::FromIterator;\n use mem::{self, replace};\n use ops::{Deref, Index};\n@@ -1711,10 +1711,30 @@ impl RandomState {\n \n #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n impl BuildHasher for RandomState {\n-    type Hasher = SipHasher;\n+    type Hasher = DefaultHasher;\n     #[inline]\n-    fn build_hasher(&self) -> SipHasher {\n-        SipHasher::new_with_keys(self.k0, self.k1)\n+    fn build_hasher(&self) -> DefaultHasher {\n+        DefaultHasher(SipHasher13::new_with_keys(self.k0, self.k1))\n+    }\n+}\n+\n+/// The default `Hasher` used by `RandomState`.\n+///\n+/// The internal algorithm is not specified, and so it and its hashes should\n+/// not be relied upon over releases.\n+#[unstable(feature = \"hashmap_default_hasher\", issue = \"0\")]\n+pub struct DefaultHasher(SipHasher13);\n+\n+#[unstable(feature = \"hashmap_default_hasher\", issue = \"0\")]\n+impl Hasher for DefaultHasher {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.0.write(msg)\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.0.finish()\n     }\n }\n "}, {"sha": "a396c7be09ad16db2effaf51845b45085bd80d47", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db1b1919baba8be48d997d9f70a6a5df7e31612a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=db1b1919baba8be48d997d9f70a6a5df7e31612a", "patch": "@@ -255,6 +255,7 @@\n #![feature(reflect_marker)]\n #![feature(rustc_attrs)]\n #![feature(shared)]\n+#![feature(sip_hash_13)]\n #![feature(slice_bytes)]\n #![feature(slice_concat_ext)]\n #![feature(slice_patterns)]"}]}