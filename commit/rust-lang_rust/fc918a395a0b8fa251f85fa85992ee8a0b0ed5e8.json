{"sha": "fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOTE4YTM5NWEwYjhmYTI1MWY4NWZhODU5OTJlZThhMGIwZWQ1ZTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-27T09:36:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-27T11:23:34Z"}, "message": "rename InterpretCx -> InterpCx\n\nThat's more consistent with InterpResult and InterpError.", "tree": {"sha": "7814ee146a664e36b2a7d1a279836d1ac6ce63dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7814ee146a664e36b2a7d1a279836d1ac6ce63dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "html_url": "https://github.com/rust-lang/rust/commit/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "html_url": "https://github.com/rust-lang/rust/commit/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "8494f8a7fb516e65d1e9c0fa8feb7ce5160babd8", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -178,7 +178,7 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n /// up with a Rust-level backtrace of where the error occured.\n /// Thsese should always be constructed by calling `.into()` on\n /// a `InterpError`. In `librustc_mir::interpret`, we have the `err!`\n-/// macro for this\n+/// macro for this.\n #[derive(Debug, Clone)]\n pub struct InterpErrorInfo<'tcx> {\n     pub kind: InterpError<'tcx, u64>,"}, {"sha": "aa264bbd4bb5c84e117453ba2ea916edf329f692", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -22,7 +22,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n-    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n+    InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n@@ -34,7 +34,7 @@ const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n /// Should be a power of two for performance reasons.\n const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n \n-/// The `InterpretCx` is only meant to be used to do field and index projections into constants for\n+/// The `InterpCx` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n@@ -47,7 +47,7 @@ pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n+    InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n pub(crate) fn eval_promoted<'mir, 'tcx>(\n@@ -303,7 +303,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n }\n \n crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -326,12 +326,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -371,7 +371,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -387,7 +387,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn ptr_op(\n-        _ecx: &InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -424,15 +424,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn box_alloc(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -457,13 +457,13 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     #[inline(always)]\n-    fn stack_push(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n-    fn stack_pop(_ecx: &mut InterpretCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n+    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n         Ok(())\n     }\n }\n@@ -508,7 +508,7 @@ pub fn const_variant_index<'tcx>(\n }\n \n pub fn error_to_const_error<'mir, 'tcx>(\n-    ecx: &InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: &InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();\n@@ -632,7 +632,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     }\n \n     let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = InterpretCx::new(tcx.at(span), key.param_env, CompileTimeInterpreter::new());\n+    let mut ecx = InterpCx::new(tcx.at(span), key.param_env, CompileTimeInterpreter::new());\n \n     let res = ecx.load_mir(cid.instance.def);\n     res.map(|body| {"}, {"sha": "59f1e461e94c60b7e0e12700bd623025693ef4a9", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -11,9 +11,9 @@ use rustc::mir::interpret::{\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "e24fa6351e5dfd7d6b0cbfdea8908f9b0521e25e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -26,7 +26,7 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct InterpretCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -158,14 +158,14 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpCx<'mir, 'tcx, M>\n where\n     M: Machine<'mir, 'tcx>,\n {\n@@ -175,7 +175,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, M> layout::HasParamEnv<'tcx> for InterpCx<'mir, 'tcx, M>\n where\n     M: Machine<'mir, 'tcx>,\n {\n@@ -184,7 +184,7 @@ where\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     type Ty = Ty<'tcx>;\n     type TyLayout = InterpResult<'tcx, TyLayout<'tcx>>;\n \n@@ -195,9 +195,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpretCx<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>, machine: M) -> Self {\n-        InterpretCx {\n+        InterpCx {\n             machine,\n             tcx,\n             param_env,"}, {"sha": "cf36c10a614e5a3fa06512be1149a2017933fe26", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, PlaceTy, OpTy, InterpretCx, Immediate,\n+    Machine, PlaceTy, OpTy, InterpCx, Immediate,\n };\n \n mod type_name;\n@@ -39,7 +39,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "f16c21857b987251d31d9be015dbd5e0863b358f", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -95,11 +95,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -145,15 +145,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n@@ -193,19 +193,19 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a new stack frame got pushed\n-    fn stack_push(ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n+    fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n "}, {"sha": "2b20f9df53837775b24cdf0aefd8313de66f8591", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -19,7 +19,7 @@ mod intern;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    InterpretCx, Frame, StackPopCleanup, LocalState, LocalValue,\n+    InterpCx, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "68c9047f7b70842758c4b0484ac805532818e929", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -15,7 +15,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    InterpretCx, Machine,\n+    InterpCx, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -213,7 +213,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "20180c9cba542423aeaa53acc00b77e23c245692", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -4,10 +4,10 @@ use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n \n-use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n+use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -36,7 +36,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "4f3727fbd8d9af00feeedb6f0a30b2eb28f0881d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -13,7 +13,7 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n-    InterpretCx, Machine, AllocMap, AllocationExtra,\n+    InterpCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n };\n \n@@ -290,7 +290,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'mir, 'tcx, Tag, M> InterpretCx<'mir, 'tcx, M>\n+impl<'mir, 'tcx, Tag, M> InterpCx<'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug + Copy + Eq + Hash + 'static,\n@@ -583,7 +583,7 @@ where\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n+                // this InterpCx uses another Machine (e.g., in miri).  This is what we\n                 // want!  This way, computing statics works consistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation."}, {"sha": "dc5302eb18fc4b2d1ac407b9afd805a55edfc37c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -1,12 +1,12 @@\n-//! This module contains the `InterpretCx` methods for executing a single step of the interpreter.\n+//! This module contains the `InterpCx` methods for executing a single step of the interpreter.\n //!\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n \n-use super::{InterpretCx, Machine};\n+use super::{InterpCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn run(&mut self) -> InterpResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "d6f3de02ec918bf83e7959f60da11d23a4927039", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -8,10 +8,10 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n-    InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> InterpResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "27d127514229c479d7e82a5a3ae32a531964cd68", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -2,9 +2,9 @@ use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n-use super::{InterpretCx, InterpError, Machine, MemoryKind};\n+use super::{InterpCx, InterpError, Machine, MemoryKind};\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "374f42261bf62f533fabec7c9a2d4bae8653c3f9", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n use std::hash::Hash;\n \n use super::{\n-    OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n+    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -174,7 +174,7 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n         MPlaceTy<'tcx, M::PointerTag>,\n         Vec<PathElem>,\n     >>,\n-    ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n+    ecx: &'rt InterpCx<'mir, 'tcx, M>,\n }\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n@@ -259,7 +259,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &InterpretCx<'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpCx<'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -628,7 +628,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n+impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "783d2522637352977299bba19f493ff3a9b105f7", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, InterpretCx, MPlaceTy, OpTy,\n+    Machine, InterpCx, MPlaceTy, OpTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -21,7 +21,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -30,14 +30,14 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self>;\n }\n@@ -53,7 +53,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'mir, 'tcx, M>,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -66,7 +66,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -75,7 +75,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n@@ -91,7 +91,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &InterpretCx<'mir, 'tcx, M>,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -104,7 +104,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -113,7 +113,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx,\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &InterpretCx<'mir, 'tcx, M>,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n         field: u64,\n     ) -> InterpResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -126,9 +126,9 @@ macro_rules! make_value_visitor {\n         pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n             type V: Value<'mir, 'tcx, M>;\n \n-            /// The visitor must have an `InterpretCx` in it.\n+            /// The visitor must have an `InterpCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? InterpretCx<'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpCx<'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "29480f88fcedc421e291fa5026cd5352907de848", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fc918a395a0b8fa251f85fa85992ee8a0b0ed5e8", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::layout::{\n };\n \n use crate::interpret::{\n-    self, InterpretCx, ScalarMaybeUndef, Immediate, OpTy,\n+    self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n     ImmTy, MemoryKind, StackPopCleanup, LocalValue, LocalState,\n };\n use crate::const_eval::{\n@@ -117,7 +117,7 @@ type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // If the local is `Unitialized` or `Dead` then we haven't propagated a value into it.\n         //\n-        // `InterpretCx::access_local()` mostly takes care of this for us however, for ZSTs,\n+        // `InterpCx::access_local()` mostly takes care of this for us however, for ZSTs,\n         // it will synthesize a value for us. In doing so, that will cause the\n         // `get_const(l).is_empty()` assert right before we call `set_const()` in `visit_statement`\n         // to fail."}]}