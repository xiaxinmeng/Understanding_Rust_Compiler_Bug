{"sha": "a7ecab4ae778b2a8778e4da2f18a39b4217de627", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZWNhYjRhZTc3OGIyYTg3NzhlNGRhMmYxOGEzOWI0MjE3ZGU2Mjc=", "commit": {"author": {"name": "Brian Leibig", "email": "brian.leibig@gmail.com", "date": "2012-11-19T22:54:12Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-20T00:28:03Z"}, "message": "Added support for multiline commands in the REPL with :{ .. :}", "tree": {"sha": "91a45b2e8c1f332fdad93b4f75d30e282a01364f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a45b2e8c1f332fdad93b4f75d30e282a01364f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7ecab4ae778b2a8778e4da2f18a39b4217de627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7ecab4ae778b2a8778e4da2f18a39b4217de627", "html_url": "https://github.com/rust-lang/rust/commit/a7ecab4ae778b2a8778e4da2f18a39b4217de627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7ecab4ae778b2a8778e4da2f18a39b4217de627/comments", "author": {"login": "bleibig", "id": 1253302, "node_id": "MDQ6VXNlcjEyNTMzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1253302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bleibig", "html_url": "https://github.com/bleibig", "followers_url": "https://api.github.com/users/bleibig/followers", "following_url": "https://api.github.com/users/bleibig/following{/other_user}", "gists_url": "https://api.github.com/users/bleibig/gists{/gist_id}", "starred_url": "https://api.github.com/users/bleibig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bleibig/subscriptions", "organizations_url": "https://api.github.com/users/bleibig/orgs", "repos_url": "https://api.github.com/users/bleibig/repos", "events_url": "https://api.github.com/users/bleibig/events{/privacy}", "received_events_url": "https://api.github.com/users/bleibig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "html_url": "https://github.com/rust-lang/rust/commit/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e"}], "stats": {"total": 139, "additions": 96, "deletions": 43}, "files": [{"sha": "dd79d124c5f9234e58266c3a5d273356192a34e0", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 96, "deletions": 43, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a7ecab4ae778b2a8778e4da2f18a39b4217de627/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7ecab4ae778b2a8778e4da2f18a39b4217de627/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=a7ecab4ae778b2a8778e4da2f18a39b4217de627", "patch": "@@ -10,6 +10,12 @@ struct Repl {\n     stmts: ~str\n }\n \n+// Action to do after reading a :command\n+enum CmdAction {\n+    action_none,\n+    action_run_line(~str),\n+}\n+\n /// A utility function that hands off a pretty printer to a callback.\n fn with_pp(intr: @token::ident_interner,\n            cb: fn(pprust::ps, io::Writer)) -> ~str {\n@@ -234,9 +240,26 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     record(repl, blk, sess.parse_sess.interner)\n }\n \n+/// Tries to get a line from rl after outputting a prompt. Returns\n+/// None if no input was read (e.g. EOF was reached).\n+fn get_line(prompt: ~str) -> Option<~str> {\n+    let result = unsafe { rl::read(prompt) };\n+\n+    if result.is_none() {\n+        return None;\n+    }\n+\n+    let line = result.get();\n+\n+    unsafe { rl::add_history(line) };\n+\n+    return Some(line);\n+}\n+\n /// Run a command, e.g. :clear, :exit, etc.\n fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n-           cmd: ~str, _args: ~[~str]) {\n+           cmd: ~str, _args: ~[~str]) -> CmdAction {\n+    let mut action = action_none;\n     match cmd {\n         ~\"exit\" => repl.running = false,\n         ~\"clear\" => {\n@@ -247,12 +270,74 @@ fn run_cmd(repl: &mut Repl, _in: io::Reader, _out: io::Writer,\n             //rl::clear();\n         }\n         ~\"help\" => {\n-            io::println(~\":clear - clear the screen\\n\" +\n+            io::println(~\":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\" +\n+                        ~\":clear - clear the screen\\n\" +\n                         ~\":exit - exit from the repl\\n\" +\n                         ~\":help - show this message\");\n         }\n+        ~\"{\" => {\n+            let mut multiline_cmd = ~\"\";\n+            let mut end_multiline = false;\n+            while (!end_multiline) {\n+                match get_line(~\"rusti| \") {\n+                    None => fail ~\"unterminated multiline command :{ .. :}\",\n+                    Some(line) => {\n+                        if str::trim(line) == ~\":}\" {\n+                            end_multiline = true;\n+                        } else {\n+                            multiline_cmd += line + ~\"\\n\";\n+                        }\n+                    }\n+                }\n+            }\n+            action = action_run_line(multiline_cmd);\n+        }\n         _ => io::println(~\"unknown cmd: \" + cmd)\n     }\n+    return action;\n+}\n+\n+/// Executes a line of input, which may either be rust code or a\n+/// :command. Returns a new Repl if it has changed.\n+fn run_line(repl: &mut Repl, in: io::Reader, out: io::Writer, line: ~str)\n+    -> Option<Repl> {\n+    if line.starts_with(~\":\") {\n+        let full = line.substr(1, line.len() - 1);\n+        let split = str::words(full);\n+        let len = split.len();\n+\n+        if len > 0 {\n+            let cmd = split[0];\n+\n+            if !cmd.is_empty() {\n+                let args = if len > 1 {\n+                    do vec::view(split, 1, len - 1).map |arg| {\n+                        *arg\n+                    }\n+                } else { ~[] };\n+\n+                match run_cmd(repl, in, out, cmd, args) {\n+                    action_none => { }\n+                    action_run_line(multiline_cmd) => {\n+                        if !multiline_cmd.is_empty() {\n+                            return run_line(repl, in, out, multiline_cmd);\n+                        }\n+                    }\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    let r = *repl;\n+    let result = do task::try |copy r| {\n+        run(r, line)\n+    };\n+\n+    if result.is_ok() {\n+        return Some(result.get());\n+    }\n+    return None;\n }\n \n pub fn main() {\n@@ -278,50 +363,18 @@ pub fn main() {\n     }\n \n     while repl.running {\n-        let result = unsafe { rl::read(repl.prompt) };\n-\n-        if result.is_none() {\n-            break;\n-        }\n-\n-        let line = result.get();\n-\n-        if line.is_empty() {\n-            io::println(~\"()\");\n-\n-            loop;\n-        }\n-\n-        unsafe { rl::add_history(line) };\n-\n-        if line.starts_with(~\":\") {\n-            let full = line.substr(1, line.len() - 1);\n-            let split = full.split_char(' ');\n-            let len = split.len();\n-\n-            if len > 0 {\n-                let cmd = split[0];\n-\n-                if !cmd.is_empty() {\n-                    let args = if len > 1 {\n-                        do vec::view(split, 1, len - 1).map |arg| {\n-                            *arg\n-                        }\n-                    } else { ~[] };\n-\n-                    run_cmd(&mut repl, in, out, cmd, args);\n-\n+        match get_line(repl.prompt) {\n+            None => break,\n+            Some(line) => {\n+                if line.is_empty() {\n+                    io::println(~\"()\");\n                     loop;\n                 }\n+                match run_line(&mut repl, in, out, line) {\n+                    Some(new_repl) => repl = new_repl,\n+                    None => { }\n+                }\n             }\n         }\n-\n-        let result = do task::try |copy repl| {\n-            run(copy repl, line)\n-        };\n-\n-        if result.is_ok() {\n-            repl = result.get();\n-        }\n     }\n }"}]}