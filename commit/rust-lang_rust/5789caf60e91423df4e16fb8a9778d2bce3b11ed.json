{"sha": "5789caf60e91423df4e16fb8a9778d2bce3b11ed", "node_id": "C_kwDOAAsO6NoAKDU3ODljYWY2MGU5MTQyM2RmNGUxNmZiOGE5Nzc4ZDJiY2UzYjExZWQ", "commit": {"author": {"name": "vi_mi", "email": "fkjainco@gmail.com", "date": "2022-03-08T19:54:07Z"}, "committer": {"name": "vi_mi", "email": "fkjainco@gmail.com", "date": "2022-03-08T20:08:53Z"}, "message": "fix: extract_module selection inside impl", "tree": {"sha": "af893520ed4620e843bf19e60213b695492416c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af893520ed4620e843bf19e60213b695492416c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5789caf60e91423df4e16fb8a9778d2bce3b11ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5789caf60e91423df4e16fb8a9778d2bce3b11ed", "html_url": "https://github.com/rust-lang/rust/commit/5789caf60e91423df4e16fb8a9778d2bce3b11ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5789caf60e91423df4e16fb8a9778d2bce3b11ed/comments", "author": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "feniljain", "id": 49019259, "node_id": "MDQ6VXNlcjQ5MDE5MjU5", "avatar_url": "https://avatars.githubusercontent.com/u/49019259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feniljain", "html_url": "https://github.com/feniljain", "followers_url": "https://api.github.com/users/feniljain/followers", "following_url": "https://api.github.com/users/feniljain/following{/other_user}", "gists_url": "https://api.github.com/users/feniljain/gists{/gist_id}", "starred_url": "https://api.github.com/users/feniljain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feniljain/subscriptions", "organizations_url": "https://api.github.com/users/feniljain/orgs", "repos_url": "https://api.github.com/users/feniljain/repos", "events_url": "https://api.github.com/users/feniljain/events{/privacy}", "received_events_url": "https://api.github.com/users/feniljain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9e46b960c37f04a26742c186e0a26b7bc131b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9e46b960c37f04a26742c186e0a26b7bc131b3", "html_url": "https://github.com/rust-lang/rust/commit/5b9e46b960c37f04a26742c186e0a26b7bc131b3"}], "stats": {"total": 181, "additions": 167, "deletions": 14}, "files": [{"sha": "08bfd10dc798be08c7d6452fdf2fe994c436c3a1", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 167, "deletions": 14, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5789caf60e91423df4e16fb8a9778d2bce3b11ed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5789caf60e91423df4e16fb8a9778d2bce3b11ed/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=5789caf60e91423df4e16fb8a9778d2bce3b11ed", "patch": "@@ -7,6 +7,7 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     search::{FileReference, SearchScope},\n };\n+use parser::SyntaxKind::WHITESPACE;\n use stdx::format_to;\n use syntax::{\n     algo::find_node_at_range,\n@@ -59,6 +60,20 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n \n+    //If the selection is inside impl block, we need to place new module outside impl block,\n+    //as impl blocks cannot contain modules\n+\n+    let mut impl_parent: Option<ast::Impl> = None;\n+    let mut impl_child_count: usize = 0;\n+    if let Some(parent_assoc_list) = node.parent() {\n+        if let Some(parent_impl) = parent_assoc_list.parent() {\n+            if let Some(impl_) = ast::Impl::cast(parent_impl) {\n+                impl_child_count = parent_assoc_list.children().count();\n+                impl_parent = Some(impl_);\n+            }\n+        }\n+    }\n+\n     let mut curr_parent_module: Option<ast::Module> = None;\n     if let Some(mod_syn_opt) = node.ancestors().find(|it| ast::Module::can_cast(it.kind())) {\n         curr_parent_module = ast::Module::cast(mod_syn_opt);\n@@ -98,18 +113,55 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         \"Extract Module\",\n         module.text_range,\n         |builder| {\n-            let _ = &module;\n+            let mut body_items: Vec<String> = Vec::new();\n+            let mut items_to_be_processed: Vec<ast::Item> = module.body_items.clone();\n+            let mut new_item_indent = old_item_indent + 1;\n \n-            let mut body_items = Vec::new();\n-            let new_item_indent = old_item_indent + 1;\n-            for item in module.body_items {\n+            if impl_parent.is_some() {\n+                new_item_indent = old_item_indent + 2;\n+            } else {\n+                items_to_be_processed = [module.use_items.clone(), items_to_be_processed].concat();\n+            }\n+\n+            for item in items_to_be_processed {\n                 let item = item.indent(IndentLevel(1));\n                 let mut indented_item = String::new();\n                 format_to!(indented_item, \"{}{}\", new_item_indent, item.to_string());\n                 body_items.push(indented_item);\n             }\n \n-            let body = body_items.join(\"\\n\\n\");\n+            let mut body = body_items.join(\"\\n\\n\");\n+\n+            if let Some(impl_) = &impl_parent {\n+                let mut impl_body_def = String::new();\n+\n+                if let Some(self_ty) = impl_.self_ty() {\n+                    format_to!(\n+                        impl_body_def,\n+                        \"{}impl {} {{\\n{}\\n{}}}\",\n+                        old_item_indent + 1,\n+                        self_ty.to_string(),\n+                        body,\n+                        old_item_indent + 1\n+                    );\n+\n+                    body = impl_body_def;\n+\n+                    // Add the import for enum/struct corresponding to given impl block\n+                    if let Some(_) = module.make_use_stmt_of_node_with_super(self_ty.syntax()) {\n+                        for item in module.use_items {\n+                            let mut indented_item = String::new();\n+                            format_to!(\n+                                indented_item,\n+                                \"{}{}\",\n+                                old_item_indent + 1,\n+                                item.to_string()\n+                            );\n+                            body = format!(\"{}\\n\\n{}\", indented_item, body);\n+                        }\n+                    }\n+                }\n+            }\n \n             let mut module_def = String::new();\n \n@@ -135,7 +187,29 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n             for import_path_text_range in import_paths_to_be_removed {\n                 builder.delete(import_path_text_range);\n             }\n-            builder.replace(module.text_range, module_def)\n+\n+            if let Some(impl_) = impl_parent {\n+                let node_to_be_removed;\n+\n+                // Remove complete impl block if it has only one child (as such it will be empty\n+                // after deleting that child)\n+                if impl_child_count == 1 {\n+                    node_to_be_removed = impl_.syntax()\n+                } else {\n+                    //Remove selected node\n+                    node_to_be_removed = &node;\n+                }\n+\n+                builder.delete(node_to_be_removed.text_range());\n+                // Remove preceding indentation from node\n+                if let Some(range) = indent_range_before_given_node(&node_to_be_removed) {\n+                    builder.delete(range);\n+                }\n+\n+                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{}\", module_def));\n+            } else {\n+                builder.replace(module.text_range, module_def)\n+            }\n         },\n     )\n }\n@@ -144,16 +218,24 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n struct Module {\n     text_range: TextRange,\n     name: String,\n-    body_items: Vec<ast::Item>,\n+    body_items: Vec<ast::Item>, // All items except use items\n+    use_items: Vec<ast::Item>, // Use items are kept separately as they help when the selection is inside an impl block, we can directly take these items and keep them outside generated impl block inside generated module\n }\n \n fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n+    let mut use_items = vec![];\n+\n     let mut body_items: Vec<ast::Item> = node\n         .children()\n         .filter_map(|child| {\n-            if let Some(item) = ast::Item::cast(child) {\n-                if selection_range.contains_range(item.syntax().text_range()) {\n-                    return Some(item);\n+            if selection_range.contains_range(child.text_range()) {\n+                let child_kind = child.kind();\n+                if let Some(item) = ast::Item::cast(child) {\n+                    if ast::Use::can_cast(child_kind) {\n+                        use_items.push(item);\n+                    } else {\n+                        return Some(item);\n+                    }\n                 }\n                 return None;\n             }\n@@ -165,7 +247,7 @@ fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Modul\n         body_items.push(node_item);\n     }\n \n-    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items })\n+    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items, use_items })\n }\n \n impl Module {\n@@ -543,23 +625,27 @@ impl Module {\n             let use_ =\n                 make::use_(None, make::use_tree(make::join_paths(use_tree_str), None, None, false));\n             if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-                self.body_items.insert(0, item);\n+                self.use_items.insert(0, item);\n             }\n         }\n \n         import_path_to_be_removed\n     }\n \n-    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) {\n+    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) -> Option<ast::Item> {\n         let super_path = make::ext::ident_path(\"super\");\n         let node_path = make::ext::ident_path(&node_syntax.to_string());\n         let use_ = make::use_(\n             None,\n             make::use_tree(make::join_paths(vec![super_path, node_path]), None, None, false),\n         );\n+\n         if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-            self.body_items.insert(0, item);\n+            self.use_items.insert(0, item.clone());\n+            return Some(item);\n         }\n+\n+        return None;\n     }\n \n     fn process_use_stmt_for_import_resolve(\n@@ -859,6 +945,14 @@ fn compare_hir_and_ast_module(\n     return Some(());\n }\n \n+fn indent_range_before_given_node(node: &SyntaxNode) -> Option<TextRange> {\n+    let x = node.siblings_with_tokens(syntax::Direction::Prev).find(|x| {\n+        return x.kind() == WHITESPACE;\n+    })?;\n+\n+    return Some(x.text_range());\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -1435,4 +1529,63 @@ mod modname {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn test_if_inside_impl_block_generate_module_outside() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            struct A {}\n+\n+            impl A {\n+$0fn foo() {}$0\n+                fn bar() {}\n+            }\n+        \",\n+            r\"\n+            struct A {}\n+\n+            impl A {\n+                fn bar() {}\n+            }\n+\n+mod modname {\n+    use super::A;\n+\n+    impl A {\n+        pub(crate) fn foo() {}\n+    }\n+}\n+        \",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_if_inside_impl_block_generate_module_outside_but_impl_block_having_one_child() {\n+        check_assist(\n+            extract_module,\n+            r\"\n+            struct A {}\n+            struct B {}\n+\n+            impl A {\n+$0fn foo(x: B) {}$0\n+            }\n+        \",\n+            r\"\n+            struct A {}\n+            struct B {}\n+\n+mod modname {\n+    use super::B;\n+\n+    use super::A;\n+\n+    impl A {\n+        pub(crate) fn foo(x: B) {}\n+    }\n+}\n+        \",\n+        )\n+    }\n }"}]}