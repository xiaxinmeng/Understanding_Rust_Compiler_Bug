{"sha": "e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "node_id": "C_kwDOAAsO6NoAKGUyMTJhZjJmNjVjZjI5MGU5ZTU4NzVlNWFjMWQ5NGQxYTgzYmU5Y2U", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-02T14:22:53Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-04T13:49:39Z"}, "message": "re-architect the tag visitor traits", "tree": {"sha": "7019849e7fbdecec6c6c14ff1892c95d3d006590", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7019849e7fbdecec6c6c14ff1892c95d3d006590"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "html_url": "https://github.com/rust-lang/rust/commit/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "841d1b24ed72117a531a09c38ddd4f8e1c83116b", "url": "https://api.github.com/repos/rust-lang/rust/commits/841d1b24ed72117a531a09c38ddd4f8e1c83116b", "html_url": "https://github.com/rust-lang/rust/commit/841d1b24ed72117a531a09c38ddd4f8e1c83116b"}], "stats": {"total": 528, "additions": 306, "deletions": 222}, "files": [{"sha": "d0fc349f1acc3a011d087dc335e3b875b0f198c0", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -696,6 +696,12 @@ pub struct VClockAlloc {\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n }\n \n+impl VisitTags for VClockAlloc {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // No tags here.\n+    }\n+}\n+\n impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n     pub fn new_allocation(\n@@ -1239,6 +1245,12 @@ pub struct GlobalState {\n     pub track_outdated_loads: bool,\n }\n \n+impl VisitTags for GlobalState {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // We don't have any tags.\n+    }\n+}\n+\n impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1."}, {"sha": "ec1da4138d448c392155a2adcad3df7ad46c7dbe", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -32,7 +32,7 @@ pub enum SchedulingAction {\n \n /// Timeout callbacks can be created by synchronization primitives to tell the\n /// scheduler that they should be called once some period of time passes.\n-pub trait MachineCallback<'mir, 'tcx>: VisitMachineValues {\n+pub trait MachineCallback<'mir, 'tcx>: VisitTags {\n     fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n }\n \n@@ -183,25 +183,21 @@ impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n     }\n }\n \n-impl VisitMachineValues for Thread<'_, '_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for Thread<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let Thread { panic_payload, last_error, stack, state: _, thread_name: _, join_status: _ } =\n             self;\n \n-        if let Some(payload) = panic_payload {\n-            visit.visit(*payload);\n-        }\n-        if let Some(error) = last_error {\n-            visit.visit(**error);\n-        }\n+        panic_payload.visit_tags(visit);\n+        last_error.visit_tags(visit);\n         for frame in stack {\n-            frame.visit_machine_values(visit)\n+            frame.visit_tags(visit)\n         }\n     }\n }\n \n-impl VisitMachineValues for Frame<'_, '_, Provenance, FrameData<'_>> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for Frame<'_, '_, Provenance, FrameData<'_>> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let Frame {\n             return_place,\n             locals,\n@@ -210,21 +206,20 @@ impl VisitMachineValues for Frame<'_, '_, Provenance, FrameData<'_>> {\n             instance: _,\n             return_to_block: _,\n             loc: _,\n+            // There are some private fields we cannot access; they contain no tags.\n             ..\n         } = self;\n \n         // Return place.\n-        if let Place::Ptr(mplace) = **return_place {\n-            visit.visit(mplace);\n-        }\n+        return_place.visit_tags(visit);\n         // Locals.\n         for local in locals.iter() {\n             if let LocalValue::Live(value) = &local.value {\n-                visit.visit(value);\n+                value.visit_tags(visit);\n             }\n         }\n \n-        extra.visit_machine_values(visit);\n+        extra.visit_tags(visit);\n     }\n }\n \n@@ -300,8 +295,8 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     }\n }\n \n-impl VisitMachineValues for ThreadManager<'_, '_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for ThreadManager<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let ThreadManager {\n             threads,\n             thread_local_alloc_ids,\n@@ -312,13 +307,13 @@ impl VisitMachineValues for ThreadManager<'_, '_> {\n         } = self;\n \n         for thread in threads {\n-            thread.visit_machine_values(visit);\n+            thread.visit_tags(visit);\n         }\n-        for ptr in thread_local_alloc_ids.borrow().values().copied() {\n-            visit.visit(ptr);\n+        for ptr in thread_local_alloc_ids.borrow().values() {\n+            ptr.visit_tags(visit);\n         }\n         for callback in timeout_callbacks.values() {\n-            callback.callback.visit_machine_values(visit);\n+            callback.callback.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "9d7a49c0b4301b3260c3080ca024e40fda3a005f", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -108,15 +108,15 @@ pub struct StoreBufferAlloc {\n     store_buffers: RefCell<RangeObjectMap<StoreBuffer>>,\n }\n \n-impl VisitMachineValues for StoreBufferAlloc {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        for val in self\n-            .store_buffers\n+impl VisitTags for StoreBufferAlloc {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let Self { store_buffers } = self;\n+        for val in store_buffers\n             .borrow()\n             .iter()\n             .flat_map(|buf| buf.buffer.iter().map(|element| &element.val))\n         {\n-            visit.visit(val);\n+            val.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "9722b7643e426cea90324dc1f7258816a29d7104", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -44,6 +44,12 @@ pub struct GlobalStateInner {\n     provenance_mode: ProvenanceMode,\n }\n \n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // Nothing to visit here.\n+    }\n+}\n+\n impl GlobalStateInner {\n     pub fn new(config: &MiriConfig) -> Self {\n         GlobalStateInner {"}, {"sha": "463feb4dcc8a1ed309e2990dae8e8ac8b9210180", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -112,7 +112,7 @@ pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n     CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n-pub use crate::tag_gc::{EvalContextExt as _, ProvenanceVisitor, VisitMachineValues};\n+pub use crate::tag_gc::{EvalContextExt as _, VisitTags};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power."}, {"sha": "20ae908fce87c7db5eb5f5cf34b2a12a7548826f", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -63,13 +63,12 @@ impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     }\n }\n \n-impl VisitMachineValues for FrameData<'_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        let FrameData { catch_unwind, stacked_borrows: _, timing: _ } = self;\n+impl VisitTags for FrameData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let FrameData { catch_unwind, stacked_borrows, timing: _ } = self;\n \n-        if let Some(catch_unwind) = catch_unwind {\n-            catch_unwind.visit_machine_values(visit);\n-        }\n+        catch_unwind.visit_tags(visit);\n+        stacked_borrows.visit_tags(visit);\n     }\n }\n \n@@ -261,17 +260,13 @@ pub struct AllocExtra {\n     pub weak_memory: Option<weak_memory::AllocExtra>,\n }\n \n-impl VisitMachineValues for AllocExtra {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        let AllocExtra { stacked_borrows, data_race: _, weak_memory } = self;\n-\n-        if let Some(stacked_borrows) = stacked_borrows {\n-            stacked_borrows.borrow().visit_machine_values(visit);\n-        }\n+impl VisitTags for AllocExtra {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let AllocExtra { stacked_borrows, data_race, weak_memory } = self;\n \n-        if let Some(weak_memory) = weak_memory {\n-            weak_memory.visit_machine_values(visit);\n-        }\n+        stacked_borrows.visit_tags(visit);\n+        data_race.visit_tags(visit);\n+        weak_memory.visit_tags(visit);\n     }\n }\n \n@@ -615,8 +610,9 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n     }\n }\n \n-impl VisitMachineValues for MiriMachine<'_, '_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for MiriMachine<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        #[rustfmt::skip]\n         let MiriMachine {\n             threads,\n             tls,\n@@ -626,25 +622,52 @@ impl VisitMachineValues for MiriMachine<'_, '_> {\n             cmd_line,\n             extern_statics,\n             dir_handler,\n-            ..\n+            stacked_borrows,\n+            data_race,\n+            intptrcast,\n+            file_handler,\n+            tcx: _,\n+            isolated_op: _,\n+            validate: _,\n+            enforce_abi: _,\n+            clock: _,\n+            layouts: _,\n+            static_roots: _,\n+            profiler: _,\n+            string_cache: _,\n+            exported_symbols_cache: _,\n+            panic_on_unsupported: _,\n+            backtrace_style: _,\n+            local_crates: _,\n+            rng: _,\n+            tracked_alloc_ids: _,\n+            check_alignment: _,\n+            cmpxchg_weak_failure_rate: _,\n+            mute_stdout_stderr: _,\n+            weak_memory: _,\n+            preemption_rate: _,\n+            report_progress: _,\n+            basic_block_count: _,\n+            #[cfg(unix)]\n+            external_so_lib: _,\n+            gc_interval: _,\n+            since_gc: _,\n+            num_cpus: _,\n         } = self;\n \n-        threads.visit_machine_values(visit);\n-        tls.visit_machine_values(visit);\n-        env_vars.visit_machine_values(visit);\n-        dir_handler.visit_machine_values(visit);\n-\n-        if let Some(argc) = argc {\n-            visit.visit(argc);\n-        }\n-        if let Some(argv) = argv {\n-            visit.visit(argv);\n-        }\n-        if let Some(cmd_line) = cmd_line {\n-            visit.visit(cmd_line);\n-        }\n-        for ptr in extern_statics.values().copied() {\n-            visit.visit(ptr);\n+        threads.visit_tags(visit);\n+        tls.visit_tags(visit);\n+        env_vars.visit_tags(visit);\n+        dir_handler.visit_tags(visit);\n+        file_handler.visit_tags(visit);\n+        data_race.visit_tags(visit);\n+        stacked_borrows.visit_tags(visit);\n+        intptrcast.visit_tags(visit);\n+        argc.visit_tags(visit);\n+        argv.visit_tags(visit);\n+        cmd_line.visit_tags(visit);\n+        for ptr in extern_statics.values() {\n+            ptr.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "076d3878de2ac6b0f3e3fa8c922a40f88d25a102", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -36,15 +36,13 @@ pub struct EnvVars<'tcx> {\n     pub(crate) environ: Option<MPlaceTy<'tcx, Provenance>>,\n }\n \n-impl VisitMachineValues for EnvVars<'_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for EnvVars<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let EnvVars { map, environ } = self;\n \n+        environ.visit_tags(visit);\n         for ptr in map.values() {\n-            visit.visit(*ptr);\n-        }\n-        if let Some(env) = environ {\n-            visit.visit(**env);\n+            ptr.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "698e025961da83c174affcb58a6572a4a325e8d2", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -35,11 +35,12 @@ pub struct CatchUnwindData<'tcx> {\n     ret: mir::BasicBlock,\n }\n \n-impl VisitMachineValues for CatchUnwindData<'_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        let CatchUnwindData { catch_fn, data, dest: _, ret: _ } = self;\n-        visit.visit(catch_fn);\n-        visit.visit(data);\n+impl VisitTags for CatchUnwindData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let CatchUnwindData { catch_fn, data, dest, ret: _ } = self;\n+        catch_fn.visit_tags(visit);\n+        data.visit_tags(visit);\n+        dest.visit_tags(visit);\n     }\n }\n "}, {"sha": "9f04034e1a12d9265e3af4b2dbadba8b63b53ab9", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -219,7 +219,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(Callback { active_thread }),\n+            Box::new(UnblockCallback { thread_to_unblock: active_thread }),\n         );\n \n         Ok(0)\n@@ -242,24 +242,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(Callback { active_thread }),\n+            Box::new(UnblockCallback { thread_to_unblock: active_thread }),\n         );\n \n         Ok(())\n     }\n }\n \n-struct Callback {\n-    active_thread: ThreadId,\n+struct UnblockCallback {\n+    thread_to_unblock: ThreadId,\n }\n \n-impl VisitMachineValues for Callback {\n-    fn visit_machine_values(&self, _visit: &mut ProvenanceVisitor) {}\n+impl VisitTags for UnblockCallback {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {}\n }\n \n-impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback {\n+impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for UnblockCallback {\n     fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n-        ecx.unblock_thread(self.active_thread);\n+        ecx.unblock_thread(self.thread_to_unblock);\n         Ok(())\n     }\n }"}, {"sha": "430dedbc1700c978dfb048d7c61bdaeb04b06c91", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -235,15 +235,15 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl VisitMachineValues for TlsData<'_> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for TlsData<'_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let TlsData { keys, macos_thread_dtors, next_key: _, dtors_running: _ } = self;\n \n         for scalar in keys.values().flat_map(|v| v.data.values()) {\n-            visit.visit(scalar);\n+            scalar.visit_tags(visit);\n         }\n         for (_, scalar) in macos_thread_dtors.values() {\n-            visit.visit(scalar);\n+            scalar.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "9713cd9265e55e86e55d9013d910d9a24d49a1ca", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -256,6 +256,12 @@ pub struct FileHandler {\n     handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n }\n \n+impl VisitTags for FileHandler {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // All our FileDescriptor do not have any tags.\n+    }\n+}\n+\n impl FileHandler {\n     pub(crate) fn new(mute_stdout_stderr: bool) -> FileHandler {\n         let mut handles: BTreeMap<_, Box<dyn FileDescriptor>> = BTreeMap::new();\n@@ -462,12 +468,12 @@ impl Default for DirHandler {\n     }\n }\n \n-impl VisitMachineValues for DirHandler {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for DirHandler {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         let DirHandler { streams, next_id: _ } = self;\n \n         for dir in streams.values() {\n-            visit.visit(dir.entry);\n+            dir.entry.visit_tags(visit);\n         }\n     }\n }"}, {"sha": "5762ee27b84af89b69f5d902bcf29ad77fa5ef47", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -189,6 +189,31 @@ pub fn futex<'tcx>(\n                 // Register a timeout callback if a timeout was specified.\n                 // This callback will override the return value when the timeout triggers.\n                 if let Some(timeout_time) = timeout_time {\n+                    struct Callback<'tcx> {\n+                        thread: ThreadId,\n+                        addr_usize: u64,\n+                        dest: PlaceTy<'tcx, Provenance>,\n+                    }\n+\n+                    impl<'tcx> VisitTags for Callback<'tcx> {\n+                        fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                            let Callback { thread: _, addr_usize: _, dest } = self;\n+                            dest.visit_tags(visit);\n+                        }\n+                    }\n+\n+                    impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                        fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                            this.unblock_thread(self.thread);\n+                            this.futex_remove_waiter(self.addr_usize, self.thread);\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            this.set_last_error(etimedout)?;\n+                            this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n+\n+                            Ok(())\n+                        }\n+                    }\n+\n                     let dest = dest.clone();\n                     this.register_timeout_callback(\n                         thread,\n@@ -252,30 +277,3 @@ pub fn futex<'tcx>(\n \n     Ok(())\n }\n-\n-struct Callback<'tcx> {\n-    thread: ThreadId,\n-    addr_usize: u64,\n-    dest: PlaceTy<'tcx, Provenance>,\n-}\n-\n-impl<'tcx> VisitMachineValues for Callback<'tcx> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        let Callback { thread: _, addr_usize: _, dest } = self;\n-        if let Place::Ptr(place) = **dest {\n-            visit.visit(place);\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n-    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n-        this.unblock_thread(self.thread);\n-        this.futex_remove_waiter(self.addr_usize, self.thread);\n-        let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n-        this.set_last_error(etimedout)?;\n-        this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n-\n-        Ok(())\n-    }\n-}"}, {"sha": "5aafe76ade1d44ffd933af47385a3c132d8878ab", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -851,6 +851,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;\n \n+        struct Callback<'tcx> {\n+            active_thread: ThreadId,\n+            mutex_id: MutexId,\n+            id: CondvarId,\n+            dest: PlaceTy<'tcx, Provenance>,\n+        }\n+\n+        impl<'tcx> VisitTags for Callback<'tcx> {\n+            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n+                dest.visit_tags(visit);\n+            }\n+        }\n+\n+        impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+            fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                // We are not waiting for the condvar any more, wait for the\n+                // mutex instead.\n+                reacquire_cond_mutex(ecx, self.active_thread, self.mutex_id)?;\n+\n+                // Remove the thread from the conditional variable.\n+                ecx.condvar_remove_waiter(self.id, self.active_thread);\n+\n+                // Set the return value: we timed out.\n+                let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n+                ecx.write_scalar(etimedout, &self.dest)?;\n+\n+                Ok(())\n+            }\n+        }\n+\n         // Register the timeout callback.\n         let dest = dest.clone();\n         this.register_timeout_callback(\n@@ -885,39 +916,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n }\n \n-struct Callback<'tcx> {\n-    active_thread: ThreadId,\n-    mutex_id: MutexId,\n-    id: CondvarId,\n-    dest: PlaceTy<'tcx, Provenance>,\n-}\n-\n-impl<'tcx> VisitMachineValues for Callback<'tcx> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n-        let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n-        if let Place::Ptr(place) = **dest {\n-            visit.visit(place);\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n-    fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n-        // We are not waiting for the condvar any more, wait for the\n-        // mutex instead.\n-        reacquire_cond_mutex(ecx, self.active_thread, self.mutex_id)?;\n-\n-        // Remove the thread from the conditional variable.\n-        ecx.condvar_remove_waiter(self.id, self.active_thread);\n-\n-        // Set the return value: we timed out.\n-        let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n-        ecx.write_scalar(etimedout, &self.dest)?;\n-\n-        Ok(())\n-    }\n-}\n-\n fn layout_of_maybe_uninit<'tcx>(tcx: TyCtxtAt<'tcx>, param: Ty<'tcx>) -> TyAndLayout<'tcx> {\n     let def_id = tcx.require_lang_item(LangItem::MaybeUninit, None);\n     let ty = tcx.bound_type_of(def_id).subst(*tcx, &[param.into()]);"}, {"sha": "829703d65626254b49362e45ead0a49ac736b4d5", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -71,6 +71,12 @@ pub struct FrameExtra {\n     protected_tags: SmallVec<[SbTag; 2]>,\n }\n \n+impl VisitTags for FrameExtra {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // `protected_tags` are fine to GC.\n+    }\n+}\n+\n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n pub struct Stacks {\n@@ -109,6 +115,13 @@ pub struct GlobalStateInner {\n     retag_fields: bool,\n }\n \n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(SbTag)) {\n+        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n+        // GC the bottommost tag.\n+    }\n+}\n+\n /// We need interior mutable access to the global state.\n pub type GlobalState = RefCell<GlobalStateInner>;\n \n@@ -513,10 +526,10 @@ impl Stacks {\n     }\n }\n \n-impl VisitMachineValues for Stacks {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for Stacks {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         for tag in self.exposed_tags.iter().copied() {\n-            visit.visit(tag);\n+            visit(tag);\n         }\n     }\n }"}, {"sha": "5aa653632f395818dc69ca5b13e34436fec63dbf", "filename": "src/tools/miri/src/tag_gc.rs", "status": "modified", "additions": 103, "deletions": 69, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e212af2f65cf290e9e5875e5ac1d94d1a83be9ce/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Ftag_gc.rs?ref=e212af2f65cf290e9e5875e5ac1d94d1a83be9ce", "patch": "@@ -2,133 +2,167 @@ use rustc_data_structures::fx::FxHashSet;\n \n use crate::*;\n \n-pub trait VisitMachineValues {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor);\n+pub trait VisitTags {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag));\n }\n \n-pub trait MachineValue {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>);\n+impl<T: VisitTags> VisitTags for Option<T> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        if let Some(x) = self {\n+            x.visit_tags(visit);\n+        }\n+    }\n }\n \n-pub struct ProvenanceVisitor {\n-    tags: FxHashSet<SbTag>,\n+impl<T: VisitTags> VisitTags for std::cell::RefCell<T> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        self.borrow().visit_tags(visit)\n+    }\n }\n \n-impl ProvenanceVisitor {\n-    pub fn visit<V>(&mut self, v: V)\n-    where\n-        V: MachineValue,\n-    {\n-        v.visit_provenance(&mut self.tags);\n+impl VisitTags for SbTag {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        visit(*self)\n     }\n }\n \n-impl<T: MachineValue> MachineValue for &T {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        (**self).visit_provenance(tags);\n+impl VisitTags for Provenance {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        if let Provenance::Concrete { sb, .. } = self {\n+            visit(*sb);\n+        }\n     }\n }\n \n-impl MachineValue for Operand<Provenance> {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n+impl VisitTags for Pointer<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let (prov, _offset) = self.into_parts();\n+        prov.visit_tags(visit);\n+    }\n+}\n+\n+impl VisitTags for Pointer<Option<Provenance>> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let (prov, _offset) = self.into_parts();\n+        prov.visit_tags(visit);\n+    }\n+}\n+\n+impl VisitTags for Scalar<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         match self {\n-            Operand::Immediate(Immediate::Scalar(s)) => {\n-                s.visit_provenance(tags);\n-            }\n-            Operand::Immediate(Immediate::ScalarPair(s1, s2)) => {\n-                s1.visit_provenance(tags);\n-                s2.visit_provenance(tags);\n-            }\n-            Operand::Immediate(Immediate::Uninit) => {}\n-            Operand::Indirect(p) => {\n-                p.visit_provenance(tags);\n-            }\n+            Scalar::Ptr(ptr, _) => ptr.visit_tags(visit),\n+            Scalar::Int(_) => (),\n         }\n     }\n }\n \n-impl MachineValue for Scalar<Provenance> {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        if let Scalar::Ptr(ptr, _) = self {\n-            if let Provenance::Concrete { sb, .. } = ptr.provenance {\n-                tags.insert(sb);\n+impl VisitTags for Immediate<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Immediate::Scalar(s) => {\n+                s.visit_tags(visit);\n+            }\n+            Immediate::ScalarPair(s1, s2) => {\n+                s1.visit_tags(visit);\n+                s2.visit_tags(visit);\n             }\n+            Immediate::Uninit => {}\n         }\n     }\n }\n \n-impl MachineValue for MemPlace<Provenance> {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        if let Some(Provenance::Concrete { sb, .. }) = self.ptr.provenance {\n-            tags.insert(sb);\n+impl VisitTags for MemPlaceMeta<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            MemPlaceMeta::Meta(m) => m.visit_tags(visit),\n+            MemPlaceMeta::None => {}\n         }\n     }\n }\n \n-impl MachineValue for SbTag {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        tags.insert(*self);\n+impl VisitTags for MemPlace<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        let MemPlace { ptr, meta } = self;\n+        ptr.visit_tags(visit);\n+        meta.visit_tags(visit);\n     }\n }\n \n-impl MachineValue for Pointer<Provenance> {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        let (prov, _offset) = self.into_parts();\n-        if let Provenance::Concrete { sb, .. } = prov {\n-            tags.insert(sb);\n+impl VisitTags for MPlaceTy<'_, Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        (**self).visit_tags(visit)\n+    }\n+}\n+\n+impl VisitTags for Place<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Place::Ptr(p) => p.visit_tags(visit),\n+            Place::Local { .. } => {\n+                // Will be visited as part of the stack frame.\n+            }\n         }\n     }\n }\n \n-impl MachineValue for Pointer<Option<Provenance>> {\n-    fn visit_provenance(&self, tags: &mut FxHashSet<SbTag>) {\n-        let (prov, _offset) = self.into_parts();\n-        if let Some(Provenance::Concrete { sb, .. }) = prov {\n-            tags.insert(sb);\n+impl VisitTags for PlaceTy<'_, Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        (**self).visit_tags(visit)\n+    }\n+}\n+\n+impl VisitTags for Operand<Provenance> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        match self {\n+            Operand::Immediate(imm) => {\n+                imm.visit_tags(visit);\n+            }\n+            Operand::Indirect(p) => {\n+                p.visit_tags(visit);\n+            }\n         }\n     }\n }\n \n-impl VisitMachineValues for Allocation<Provenance, AllocExtra> {\n-    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+impl VisitTags for Allocation<Provenance, AllocExtra> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         for (_size, prov) in self.provenance().iter() {\n-            if let Provenance::Concrete { sb, .. } = prov {\n-                visit.visit(*sb);\n-            }\n+            prov.visit_tags(visit);\n         }\n \n-        self.extra.visit_machine_values(visit);\n+        self.extra.visit_tags(visit);\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n-    /// GC helper to visit everything that can store provenance. The `ProvenanceVisitor` knows how\n-    /// to extract provenance from the interpreter data types.\n-    fn visit_all_machine_values(&self, acc: &mut ProvenanceVisitor) {\n-        let this = self.eval_context_ref();\n-\n+impl VisitTags for crate::MiriInterpCx<'_, '_> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n         // Memory.\n-        this.memory.alloc_map().iter(|it| {\n+        self.memory.alloc_map().iter(|it| {\n             for (_id, (_kind, alloc)) in it {\n-                alloc.visit_machine_values(acc);\n+                alloc.visit_tags(visit);\n             }\n         });\n \n         // And all the other machine values.\n-        this.machine.visit_machine_values(acc);\n+        self.machine.visit_tags(visit);\n     }\n+}\n \n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off.\n         if this.machine.stacked_borrows.is_none() {\n             return Ok(());\n         }\n \n-        let mut visitor = ProvenanceVisitor { tags: FxHashSet::default() };\n-        this.visit_all_machine_values(&mut visitor);\n-        self.remove_unreachable_tags(visitor.tags);\n+        let mut tags = FxHashSet::default();\n+        this.visit_tags(&mut |tag| {\n+            tags.insert(tag);\n+        });\n+        self.remove_unreachable_tags(tags);\n \n         Ok(())\n     }"}]}