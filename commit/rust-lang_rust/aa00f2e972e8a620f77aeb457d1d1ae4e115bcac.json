{"sha": "aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDBmMmU5NzJlOGE2MjBmNzdhZWI0NTdkMWQxYWU0ZTExNWJjYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-17T06:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-17T06:56:15Z"}, "message": "Auto merge of #26025 - alexcrichton:update-llvm, r=brson\n\nThis commit updates the LLVM submodule in use to the current HEAD of the LLVM\r\nrepository. This is primarily being done to start picking up unwinding support\r\nfor MSVC, which is currently unimplemented in the revision of LLVM we are using.\r\nAlong the way a few changes had to be made:\r\n\r\n* As usual, lots of C++ debuginfo bindings in LLVM changed, so there were some\r\n  significant changes to our RustWrapper.cpp\r\n* As usual, some pass management changed in LLVM, so clang was re-scrutinized to\r\n  ensure that we're doing the same thing as clang.\r\n* Some optimization options are now passed directly into the\r\n  `PassManagerBuilder` instead of through CLI switches to LLVM.\r\n* The `NoFramePointerElim` option was removed from LLVM, favoring instead the\r\n  `no-frame-pointer-elim` function attribute instead.\r\n* The `LoopVectorize` option of the LLVM optimization passes has been disabled\r\n  as it causes a divide-by-zero exception to happen in LLVM for zero-sized\r\n  types. This is reported as https://llvm.org/bugs/show_bug.cgi?id=23763\r\n\r\nAdditionally, LLVM has picked up some new optimizations which required fixing an\r\nexisting soundness hole in the IR we generate. It appears that the current LLVM\r\nwe use does not expose this hole. When an enum is moved, the previous slot in\r\nmemory is overwritten with a bit pattern corresponding to \"dropped\". When the\r\ndrop glue for this slot is run, however, the switch on the discriminant can\r\noften start executing the `unreachable` block of the switch due to the\r\ndiscriminant now being outside the normal range. This was patched over locally\r\nfor now by having the `unreachable` block just change to a `ret void`.", "tree": {"sha": "c46f2e7d39ae99525d180ba0c4e7738560c1f431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c46f2e7d39ae99525d180ba0c4e7738560c1f431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "html_url": "https://github.com/rust-lang/rust/commit/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0250ff9a5f1347f3177516e178fd8382d48169c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0250ff9a5f1347f3177516e178fd8382d48169c7", "html_url": "https://github.com/rust-lang/rust/commit/0250ff9a5f1347f3177516e178fd8382d48169c7"}, {"sha": "f9d4149c29e8b989fa3624993be379f380e48dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d4149c29e8b989fa3624993be379f380e48dcf", "html_url": "https://github.com/rust-lang/rust/commit/f9d4149c29e8b989fa3624993be379f380e48dcf"}], "stats": {"total": 411, "additions": 302, "deletions": 109}, "files": [{"sha": "bf331705b32c92480bf0f43b291b8efd6ab655d3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -976,6 +976,9 @@ extern {\n     pub fn LLVMAddDereferenceableAttr(Fn: ValueRef, index: c_uint, bytes: uint64_t);\n     pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n     pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+    pub fn LLVMAddFunctionAttrStringValue(Fn: ValueRef, index: c_uint,\n+                                          Name: *const c_char,\n+                                          Value: *const c_char);\n     pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n     pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n     pub fn LLVMRemoveFunctionAttr(Fn: ValueRef, val: c_ulonglong);\n@@ -1920,6 +1923,7 @@ extern {\n                                            VarInfo: DIVariable,\n                                            AddrOps: *const i64,\n                                            AddrOpsCount: c_uint,\n+                                           DL: ValueRef,\n                                            InsertAtEnd: BasicBlockRef)\n                                            -> ValueRef;\n \n@@ -1928,6 +1932,7 @@ extern {\n                                             VarInfo: DIVariable,\n                                             AddrOps: *const i64,\n                                             AddrOpsCount: c_uint,\n+                                            DL: ValueRef,\n                                             InsertBefore: ValueRef)\n                                             -> ValueRef;\n \n@@ -2035,7 +2040,6 @@ extern {\n                                        Level: CodeGenOptLevel,\n                                        EnableSegstk: bool,\n                                        UseSoftFP: bool,\n-                                       NoFramePointerElim: bool,\n                                        PositionIndependentExecutable: bool,\n                                        FunctionSections: bool,\n                                        DataSections: bool) -> TargetMachineRef;\n@@ -2046,6 +2050,11 @@ extern {\n     pub fn LLVMRustAddBuilderLibraryInfo(PMB: PassManagerBuilderRef,\n                                          M: ModuleRef,\n                                          DisableSimplifyLibCalls: bool);\n+    pub fn LLVMRustConfigurePassManagerBuilder(PMB: PassManagerBuilderRef,\n+                                               OptLevel: CodeGenOptLevel,\n+                                               MergeFunctions: bool,\n+                                               SLPVectorize: bool,\n+                                               LoopVectorize: bool);\n     pub fn LLVMRustAddLibraryInfo(PM: PassManagerRef, M: ModuleRef,\n                                   DisableSimplifyLibCalls: bool);\n     pub fn LLVMRustRunFunctionPassManager(PM: PassManagerRef, M: ModuleRef);\n@@ -2116,6 +2125,12 @@ extern {\n     pub fn LLVMWriteSMDiagnosticToString(d: SMDiagnosticRef, s: RustStringRef);\n }\n \n+// LLVM requires symbols from this library, but apparently they're not printed\n+// during llvm-config?\n+#[cfg(windows)]\n+#[link(name = \"ole32\")]\n+extern {}\n+\n pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n     unsafe {\n         LLVMSetInstructionCallConv(instr, cc as c_uint);"}, {"sha": "1b8f049972f215ee540c4fac25d7d36212bacc2a", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -10,7 +10,7 @@\n \n use back::lto;\n use back::link::{get_cc_prog, remove};\n-use session::config::{OutputFilenames, NoDebugInfo, Passes, SomePasses, AllPasses};\n+use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config;\n use llvm;\n@@ -188,10 +188,6 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let opt_level = get_llvm_opt_level(sess.opts.optimize);\n     let use_softfp = sess.opts.cg.soft_float;\n \n-    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a parameter.\n-    let no_fp_elim = (sess.opts.debuginfo != NoDebugInfo) ||\n-                     !sess.target.target.options.eliminate_frame_pointer;\n-\n     let any_library = sess.crate_types.borrow().iter().any(|ty| {\n         *ty != config::CrateTypeExecutable\n     });\n@@ -237,7 +233,6 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             opt_level,\n             true /* EnableSegstk */,\n             use_softfp,\n-            no_fp_elim,\n             !any_library && reloc_model == llvm::RelocPIC,\n             ffunction_sections,\n             fdata_sections,\n@@ -279,6 +274,9 @@ struct ModuleConfig {\n     no_prepopulate_passes: bool,\n     no_builtins: bool,\n     time_passes: bool,\n+    vectorize_loop: bool,\n+    vectorize_slp: bool,\n+    merge_functions: bool,\n }\n \n unsafe impl Send for ModuleConfig { }\n@@ -301,6 +299,9 @@ impl ModuleConfig {\n             no_prepopulate_passes: false,\n             no_builtins: false,\n             time_passes: false,\n+            vectorize_loop: false,\n+            vectorize_slp: false,\n+            merge_functions: false,\n         }\n     }\n \n@@ -309,6 +310,18 @@ impl ModuleConfig {\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = trans.no_builtins;\n         self.time_passes = sess.time_passes();\n+\n+        // Copy what clang does by turning on loop vectorization at O2 and\n+        // slp vectorization at O3. Otherwise configure other optimization aspects\n+        // of this pass manager builder.\n+        self.vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n+                             (sess.opts.optimize == config::Default ||\n+                              sess.opts.optimize == config::Aggressive);\n+        self.vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n+                            sess.opts.optimize == config::Aggressive;\n+\n+        self.merge_functions = sess.opts.optimize == config::Default ||\n+                               sess.opts.optimize == config::Aggressive;\n     }\n }\n \n@@ -448,27 +461,26 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 let pass = CString::new(pass).unwrap();\n                 llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n             };\n-            if !config.no_verify { assert!(addpass(\"verify\")); }\n \n+            if !config.no_verify { assert!(addpass(\"verify\")); }\n             if !config.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, opt_level,\n-                                     config.no_builtins);\n+                populate_llvm_passes(fpm, mpm, llmod, opt_level, &config);\n             }\n \n             for pass in &config.passes {\n-                let pass = CString::new(pass.clone()).unwrap();\n-                if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n-                    cgcx.handler.warn(&format!(\"unknown pass {:?}, ignoring\", pass));\n+                if !addpass(pass) {\n+                    cgcx.handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                                               pass));\n                 }\n             }\n \n             for pass in &cgcx.plugin_passes {\n-                let pass = CString::new(pass.clone()).unwrap();\n-                if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n-                    cgcx.handler.err(&format!(\"a plugin asked for LLVM pass {:?} but LLVM \\\n-                                               does not recognize it\", pass));\n+                if !addpass(pass) {\n+                    cgcx.handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                                               `{}` but LLVM does not \\\n+                                               recognize it\", pass));\n                 }\n             }\n \n@@ -520,7 +532,6 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n         llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n         f(cpm);\n-        llvm::LLVMDisposePassManager(cpm);\n     }\n \n     if config.emit_bc {\n@@ -537,13 +548,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             let out = path2cstr(&out);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n+                llvm::LLVMDisposePassManager(cpm);\n             })\n         }\n \n         if config.emit_asm {\n             let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n+                                  llvm::AssemblyFileType);\n             });\n         }\n \n@@ -1008,25 +1021,16 @@ unsafe fn configure_llvm(sess: &Session) {\n     use std::sync::Once;\n     static INIT: Once = Once::new();\n \n-    // Copy what clang does by turning on loop vectorization at O2 and\n-    // slp vectorization at O3\n-    let vectorize_loop = !sess.opts.cg.no_vectorize_loops &&\n-                         (sess.opts.optimize == config::Default ||\n-                          sess.opts.optimize == config::Aggressive);\n-    let vectorize_slp = !sess.opts.cg.no_vectorize_slp &&\n-                        sess.opts.optimize == config::Aggressive;\n-\n     let mut llvm_c_strs = Vec::new();\n     let mut llvm_args = Vec::new();\n+\n     {\n         let mut add = |arg: &str| {\n             let s = CString::new(arg).unwrap();\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);\n         };\n         add(\"rustc\"); // fake program name\n-        if vectorize_loop { add(\"-vectorize-loops\"); }\n-        if vectorize_slp  { add(\"-vectorize-slp\");   }\n         if sess.time_llvm_passes() { add(\"-time-passes\"); }\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n@@ -1084,41 +1088,40 @@ unsafe fn populate_llvm_passes(fpm: llvm::PassManagerRef,\n                                mpm: llvm::PassManagerRef,\n                                llmod: ModuleRef,\n                                opt: llvm::CodeGenOptLevel,\n-                               no_builtins: bool) {\n+                               config: &ModuleConfig) {\n     // Create the PassManagerBuilder for LLVM. We configure it with\n     // reasonable defaults and prepare it to actually populate the pass\n     // manager.\n     let builder = llvm::LLVMPassManagerBuilderCreate();\n+\n+    llvm::LLVMRustConfigurePassManagerBuilder(builder, opt,\n+                                              config.merge_functions,\n+                                              config.vectorize_slp,\n+                                              config.vectorize_loop);\n+\n+    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n+\n+    // Here we match what clang does (kinda). For O0 we only inline\n+    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n+    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n+    // thresholds copied from clang.\n     match opt {\n         llvm::CodeGenLevelNone => {\n-            // Don't add lifetime intrinsics at O0\n             llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n         }\n         llvm::CodeGenLevelLess => {\n             llvm::LLVMRustAddAlwaysInlinePass(builder, true);\n         }\n-        // numeric values copied from clang\n         llvm::CodeGenLevelDefault => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                225);\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n         }\n         llvm::CodeGenLevelAggressive => {\n-            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder,\n-                                                                275);\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n         }\n     }\n-    llvm::LLVMPassManagerBuilderSetOptLevel(builder, opt as c_uint);\n-    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, no_builtins);\n \n     // Use the builder to populate the function/module pass managers.\n     llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(builder, fpm);\n     llvm::LLVMPassManagerBuilderPopulateModulePassManager(builder, mpm);\n     llvm::LLVMPassManagerBuilderDispose(builder);\n-\n-    match opt {\n-        llvm::CodeGenLevelDefault | llvm::CodeGenLevelAggressive => {\n-            llvm::LLVMRustAddPass(mpm, \"mergefunc\\0\".as_ptr() as *const _);\n-        }\n-        _ => {}\n-    };\n }"}, {"sha": "68d72ab4241ade19950fa454b5b7025ca71dd20a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -1029,11 +1029,26 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         }\n         General(ity, ref cases, _) => {\n             let ccx = bcx.ccx();\n-            let unr_cx = fcx.new_temp_block(\"enum-variant-iter-unr\");\n-            Unreachable(unr_cx);\n+\n+            // See the comments in trans/base.rs for more information (inside\n+            // iter_structural_ty), but the gist here is that if the enum's\n+            // discriminant is *not* in the range that we're expecting (in which\n+            // case we'll take the fall-through branch on the switch\n+            // instruction) then we can't just optimize this to an Unreachable\n+            // block.\n+            //\n+            // Currently we still have filling drop, so this means that the drop\n+            // glue for enums may be called when the enum has been paved over\n+            // with the \"I've been dropped\" value. In this case the default\n+            // branch of the switch instruction will actually be taken at\n+            // runtime, so the basic block isn't actually unreachable, so we\n+            // need to make it do something with defined behavior. In this case\n+            // we just return early from the function.\n+            let ret_void_cx = fcx.new_temp_block(\"enum-variant-iter-ret-void\");\n+            RetVoid(ret_void_cx, DebugLoc::None);\n \n             let discr_val = trans_get_discr(bcx, r, value, None);\n-            let llswitch = Switch(bcx, discr_val, unr_cx.llbb, cases.len());\n+            let llswitch = Switch(bcx, discr_val, ret_void_cx.llbb, cases.len());\n             let bcx_next = fcx.new_temp_block(\"enum-variant-iter-next\");\n \n             for (discr, case) in cases.iter().enumerate() {"}, {"sha": "b0f44e6573957d4e566e4100a2939da2cccedcd3", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -12,6 +12,7 @@\n use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n use middle::ty::{self, ClosureTyper};\n+use session::config::NoDebugInfo;\n use syntax::abi;\n use syntax::ast;\n pub use syntax::attr::InlineAttr;\n@@ -106,6 +107,20 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n     use syntax::attr::*;\n     inline(llfn, find_inline_attr(Some(ccx.sess().diagnostic()), attrs));\n \n+    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a\n+    // parameter.\n+    let no_fp_elim = (ccx.sess().opts.debuginfo != NoDebugInfo) ||\n+                     !ccx.sess().target.target.options.eliminate_frame_pointer;\n+    if no_fp_elim {\n+        unsafe {\n+            let attr = \"no-frame-pointer-elim\\0\".as_ptr() as *const _;\n+            let val = \"true\\0\".as_ptr() as *const _;\n+            llvm::LLVMAddFunctionAttrStringValue(llfn,\n+                                                 llvm::FunctionIndex as c_uint,\n+                                                 attr, val);\n+        }\n+    }\n+\n     for attr in attrs {\n         if attr.check_name(\"no_stack_check\") {\n             split_stack(llfn, false);"}, {"sha": "c2293dcc6d483500c0d5cab00de94eb6a04334a9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -481,9 +481,23 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n-                  let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n-                  Unreachable(unr_cx);\n-                  let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n+\n+                  // Create a fall-through basic block for the \"else\" case of\n+                  // the switch instruction we're about to generate. Note that\n+                  // we do **not** use an Unreachable instruction here, even\n+                  // though most of the time this basic block will never be hit.\n+                  //\n+                  // When an enum is dropped it's contents are currently\n+                  // overwritten to DTOR_DONE, which means the discriminant\n+                  // could have changed value to something not within the actual\n+                  // range of the discriminant. Currently this function is only\n+                  // used for drop glue so in this case we just return quickly\n+                  // from the outer function, and any other use case will only\n+                  // call this for an already-valid enum in which case the `ret\n+                  // void` will never be hit.\n+                  let ret_void_cx = fcx.new_temp_block(\"enum-iter-ret-void\");\n+                  RetVoid(ret_void_cx, DebugLoc::None);\n+                  let llswitch = Switch(cx, lldiscrim_a, ret_void_cx.llbb,\n                                         n_variants);\n                   let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n "}, {"sha": "5e35e5c67f396363df2812a2174fb019cb5db32b", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -1677,7 +1677,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         DIB(cx),\n         containing_scope,\n         enum_name.as_ptr(),\n-        UNKNOWN_FILE_METADATA,\n+        file_metadata,\n         UNKNOWN_LINE_NUMBER,\n         bytes_to_bits(enum_type_size),\n         bytes_to_bits(enum_type_align),"}, {"sha": "06f1a56c6ef1f8a351bf4573a1fda3df2da7ae82", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -485,10 +485,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n-                        file_metadata,\n+                        ptr::null_mut(),\n                         name.as_ptr(),\n                         actual_self_type_metadata,\n-                        ptr::null_mut(),\n+                        file_metadata,\n                         0,\n                         0)\n                 };\n@@ -519,10 +519,10 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n-                        file_metadata,\n+                        ptr::null_mut(),\n                         name.as_ptr(),\n                         actual_type_metadata,\n-                        ptr::null_mut(),\n+                        file_metadata,\n                         0,\n                         0)\n                 };\n@@ -581,12 +581,14 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                           loc.line,\n                                                                           loc.col.to_usize()));\n             unsafe {\n+                let debug_loc = llvm::LLVMGetCurrentDebugLocation(cx.raw_builder());\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n                     DIB(cx),\n                     alloca,\n                     metadata,\n                     address_operations.as_ptr(),\n                     address_operations.len() as c_uint,\n+                    debug_loc,\n                     bcx.llbb);\n \n                 llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);"}, {"sha": "8cbcdf1b72e1b23679646f6faca265f76b20d379", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -1 +1 @@\n-Subproject commit bff69076975642c64e76dbeaa53476bfa7212086\n+Subproject commit 8cbcdf1b72e1b23679646f6faca265f76b20d379"}, {"sha": "df83f32670c0c892529201fdb7ae5928e797dd5d", "filename": "src/rustllvm/ExecutionEngineWrapper.cpp", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FExecutionEngineWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FExecutionEngineWrapper.cpp?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -103,9 +103,6 @@ extern \"C\" LLVMExecutionEngineRef LLVMBuildExecutionEngine(LLVMModuleRef mod)\n     std::string error_str;\n     TargetOptions options;\n \n-    options.JITEmitDebugInfo = true;\n-    options.NoFramePointerElim = true;\n-\n     RustJITMemoryManager *mm = new RustJITMemoryManager;\n \n     ExecutionEngine *ee ="}, {"sha": "2c0240eb8f92bac7476ff00467bbb5a6b5e8d430", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 51, "deletions": 7, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -15,12 +15,19 @@\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n+#if LLVM_VERSION_MINOR >= 7\n+#include \"llvm/Analysis/TargetLibraryInfo.h\"\n+#include \"llvm/Analysis/TargetTransformInfo.h\"\n+#else\n #include \"llvm/Target/TargetLibraryInfo.h\"\n+#endif\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n \n+\n #include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n using namespace llvm;\n+using namespace llvm::legacy;\n \n extern cl::opt<bool> EnableARMEHABI;\n \n@@ -71,7 +78,6 @@ LLVMRustCreateTargetMachine(const char *triple,\n                             CodeGenOpt::Level OptLevel,\n                             bool EnableSegmentedStacks,\n                             bool UseSoftFloat,\n-                            bool NoFramePointerElim,\n                             bool PositionIndependentExecutable,\n                             bool FunctionSections,\n                             bool DataSections) {\n@@ -91,12 +97,12 @@ LLVMRustCreateTargetMachine(const char *triple,\n \n     TargetOptions Options;\n     Options.PositionIndependentExecutable = PositionIndependentExecutable;\n-    Options.NoFramePointerElim = NoFramePointerElim;\n     Options.FloatABIType = FloatABI::Default;\n-    Options.UseSoftFloat = UseSoftFloat;\n     if (UseSoftFloat) {\n         Options.FloatABIType = FloatABI::Soft;\n     }\n+    Options.DataSections = DataSections;\n+    Options.FunctionSections = FunctionSections;\n \n     TargetMachine *TM = TheTarget->createTargetMachine(Trip.getTriple(),\n                                                        real_cpu,\n@@ -105,8 +111,6 @@ LLVMRustCreateTargetMachine(const char *triple,\n                                                        RM,\n                                                        CM,\n                                                        OptLevel);\n-    TM->setDataSections(DataSections);\n-    TM->setFunctionSections(FunctionSections);\n     return wrap(TM);\n }\n \n@@ -123,12 +127,32 @@ LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n                           LLVMPassManagerRef PMR,\n                           LLVMModuleRef M) {\n     PassManagerBase *PM = unwrap(PMR);\n-#if LLVM_VERSION_MINOR >= 6\n+#if LLVM_VERSION_MINOR >= 7\n+    PM->add(createTargetTransformInfoWrapperPass(\n+          unwrap(TM)->getTargetIRAnalysis()));\n+#else\n+#if LLVM_VERSION_MINOR == 6\n     PM->add(new DataLayoutPass());\n #else\n     PM->add(new DataLayoutPass(unwrap(M)));\n #endif\n     unwrap(TM)->addAnalysisPasses(*PM);\n+#endif\n+}\n+\n+extern \"C\" void\n+LLVMRustConfigurePassManagerBuilder(LLVMPassManagerBuilderRef PMB,\n+                                    CodeGenOpt::Level OptLevel,\n+                                    bool MergeFunctions,\n+                                    bool SLPVectorize,\n+                                    bool LoopVectorize) {\n+#if LLVM_VERSION_MINOR >= 6\n+    // Ignore mergefunc for now as enabling it causes crashes.\n+    //unwrap(PMB)->MergeFunctions = MergeFunctions;\n+#endif\n+    unwrap(PMB)->SLPVectorize = SLPVectorize;\n+    unwrap(PMB)->OptLevel = OptLevel;\n+    unwrap(PMB)->LoopVectorize = LoopVectorize;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n@@ -138,7 +162,11 @@ LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n                               LLVMModuleRef M,\n                               bool DisableSimplifyLibCalls) {\n     Triple TargetTriple(unwrap(M)->getTargetTriple());\n+#if LLVM_VERSION_MINOR >= 7\n+    TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n+#else\n     TargetLibraryInfo *TLI = new TargetLibraryInfo(TargetTriple);\n+#endif\n     if (DisableSimplifyLibCalls)\n       TLI->disableAllFunctions();\n     unwrap(PMB)->LibraryInfo = TLI;\n@@ -151,10 +179,17 @@ LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB,\n                        LLVMModuleRef M,\n                        bool DisableSimplifyLibCalls) {\n     Triple TargetTriple(unwrap(M)->getTargetTriple());\n+#if LLVM_VERSION_MINOR >= 7\n+    TargetLibraryInfoImpl TLII(TargetTriple);\n+    if (DisableSimplifyLibCalls)\n+      TLII.disableAllFunctions();\n+    unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n+#else\n     TargetLibraryInfo *TLI = new TargetLibraryInfo(TargetTriple);\n     if (DisableSimplifyLibCalls)\n       TLI->disableAllFunctions();\n     unwrap(PMB)->add(TLI);\n+#endif\n }\n \n // Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n@@ -204,10 +239,19 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n     LLVMRustSetLastError(ErrorInfo.c_str());\n     return false;\n   }\n-  formatted_raw_ostream FOS(OS);\n \n+#if LLVM_VERSION_MINOR >= 7\n+  unwrap(Target)->addPassesToEmitFile(*PM, OS, FileType, false);\n+#else\n+  formatted_raw_ostream FOS(OS);\n   unwrap(Target)->addPassesToEmitFile(*PM, FOS, FileType, false);\n+#endif\n   PM->run(*unwrap(M));\n+\n+  // Apparently `addPassesToEmitFile` adds an pointer to our on-the-stack output\n+  // stream (OS), so the only real safe place to delete this is here? Don't we\n+  // wish this was written in Rust?\n+  delete PM;\n   return true;\n }\n "}, {"sha": "70ef64afc433628a6b8d422c55a00eedbf681c5e", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 115, "deletions": 31, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -141,6 +141,15 @@ extern \"C\" void LLVMAddFunctionAttrString(LLVMValueRef Fn, unsigned index, const\n   F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n }\n \n+extern \"C\" void LLVMAddFunctionAttrStringValue(LLVMValueRef Fn, unsigned index,\n+                                               const char *Name,\n+                                               const char *Value) {\n+  Function *F = unwrap<Function>(Fn);\n+  AttrBuilder B;\n+  B.addAttribute(Name, Value);\n+  F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n+}\n+\n extern \"C\" void LLVMRemoveFunctionAttrString(LLVMValueRef fn, unsigned index, const char *Name) {\n   Function *f = unwrap<Function>(fn);\n   LLVMContext &C = f->getContext();\n@@ -228,10 +237,25 @@ inline Metadata **unwrap(LLVMMetadataRef *Vals) {\n typedef LLVMValueRef LLVMMetadataRef;\n #endif\n \n+template<typename DIT>\n+DIT* unwrapDIptr(LLVMMetadataRef ref) {\n+    return (DIT*) (ref ? unwrap<MDNode>(ref) : NULL);\n+}\n+\n+#if LLVM_VERSION_MINOR <= 6\n template<typename DIT>\n DIT unwrapDI(LLVMMetadataRef ref) {\n     return DIT(ref ? unwrap<MDNode>(ref) : NULL);\n }\n+#else\n+#define DIDescriptor DIScope\n+#define DIArray DINodeArray\n+#define unwrapDI unwrapDIptr\n+#endif\n+\n+#if LLVM_VERSION_MINOR <= 5\n+#define DISubroutineType DICompositeType\n+#endif\n \n extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n     return DEBUG_METADATA_VERSION;\n@@ -296,7 +320,9 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateSubroutineType(\n     LLVMMetadataRef ParameterTypes) {\n     return wrap(Builder->createSubroutineType(\n         unwrapDI<DIFile>(File),\n-#if LLVM_VERSION_MINOR >= 6\n+#if LLVM_VERSION_MINOR >= 7\n+        DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n+#elif LLVM_VERSION_MINOR >= 6\n         unwrapDI<DITypeArray>(ParameterTypes)));\n #else\n         unwrapDI<DIArray>(ParameterTypes)));\n@@ -322,11 +348,11 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateFunction(\n     return wrap(Builder->createFunction(\n         unwrapDI<DIScope>(Scope), Name, LinkageName,\n         unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DICompositeType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n+        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n         Flags, isOptimized,\n         unwrap<Function>(Fn),\n-        unwrapDI<MDNode*>(TParam),\n-        unwrapDI<MDNode*>(Decl)));\n+        unwrapDIptr<MDNode>(TParam),\n+        unwrapDIptr<MDNode>(Decl)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateBasicType(\n@@ -373,7 +399,11 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStructType(\n         AlignInBits,\n         Flags,\n         unwrapDI<DIType>(DerivedFrom),\n+#if LLVM_VERSION_MINOR >= 7\n+        DINodeArray(unwrapDI<MDTuple>(Elements)),\n+#else\n         unwrapDI<DIArray>(Elements),\n+#endif\n         RunTimeLang,\n         unwrapDI<DIType>(VTableHolder),\n         UniqueId\n@@ -436,7 +466,7 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateStaticVariable(\n         unwrapDI<DIType>(Ty),\n         isLocalToUnit,\n         cast<Constant>(unwrap(Val)),\n-        unwrapDI<MDNode*>(Decl)));\n+        unwrapDIptr<MDNode>(Decl)));\n }\n \n extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVariable(\n@@ -486,7 +516,12 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateArrayType(\n     LLVMMetadataRef Subscripts) {\n     return wrap(Builder->createArrayType(Size, AlignInBits,\n         unwrapDI<DIType>(Ty),\n-        unwrapDI<DIArray>(Subscripts)));\n+#if LLVM_VERSION_MINOR >= 7\n+        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n+#else\n+        unwrapDI<DIArray>(Subscripts)\n+#endif\n+    ));\n }\n \n extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVectorType(\n@@ -497,7 +532,12 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateVectorType(\n     LLVMMetadataRef Subscripts) {\n     return wrap(Builder->createVectorType(Size, AlignInBits,\n         unwrapDI<DIType>(Ty),\n-        unwrapDI<DIArray>(Subscripts)));\n+#if LLVM_VERSION_MINOR >= 7\n+        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n+#else\n+        unwrapDI<DIArray>(Subscripts)\n+#endif\n+    ));\n }\n \n extern \"C\" LLVMMetadataRef LLVMDIBuilderGetOrCreateSubrange(\n@@ -511,12 +551,18 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderGetOrCreateArray(\n     DIBuilderRef Builder,\n     LLVMMetadataRef* Ptr,\n     unsigned Count) {\n+#if LLVM_VERSION_MINOR >= 7\n+    Metadata **DataValue = unwrap(Ptr);\n+    return wrap(Builder->getOrCreateArray(\n+        ArrayRef<Metadata*>(DataValue, Count)).get());\n+#else\n     return wrap(Builder->getOrCreateArray(\n #if LLVM_VERSION_MINOR >= 6\n         ArrayRef<Metadata*>(unwrap(Ptr), Count)));\n #else\n         ArrayRef<Value*>(reinterpret_cast<Value**>(Ptr), Count)));\n #endif\n+#endif\n }\n \n extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n@@ -525,21 +571,21 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareAtEnd(\n     LLVMMetadataRef VarInfo,\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n+    LLVMValueRef DL,\n     LLVMBasicBlockRef InsertAtEnd) {\n-#if LLVM_VERSION_MINOR >= 6\n-    DIExpression Expr;\n-    if (AddrOpsCount == 0) {\n-      Expr = Builder->createExpression();\n-    } else {\n-      llvm::ArrayRef<int64_t> addr_ops(AddrOps, AddrOpsCount);\n-      Expr = Builder->createExpression(addr_ops);\n-    }\n-#endif\n     return wrap(Builder->insertDeclare(\n         unwrap(Val),\n+#if LLVM_VERSION_MINOR >= 7\n+        unwrap<DILocalVariable>(VarInfo),\n+#else\n         unwrapDI<DIVariable>(VarInfo),\n+#endif\n #if LLVM_VERSION_MINOR >= 6\n-        Expr,\n+        Builder->createExpression(\n+          llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n+#endif\n+#if LLVM_VERSION_MINOR >= 7\n+        DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n #endif\n         unwrap(InsertAtEnd)));\n }\n@@ -550,21 +596,23 @@ extern \"C\" LLVMValueRef LLVMDIBuilderInsertDeclareBefore(\n     LLVMMetadataRef VarInfo,\n     int64_t* AddrOps,\n     unsigned AddrOpsCount,\n+    LLVMValueRef DL,\n     LLVMValueRef InsertBefore) {\n #if LLVM_VERSION_MINOR >= 6\n-    DIExpression Expr;\n-    if (AddrOpsCount == 0) {\n-      Expr = Builder->createExpression();\n-    } else {\n-      llvm::ArrayRef<int64_t> addr_ops(AddrOps, AddrOpsCount);\n-      Expr = Builder->createExpression(addr_ops);\n-    }\n #endif\n     return wrap(Builder->insertDeclare(\n         unwrap(Val),\n+#if LLVM_VERSION_MINOR >= 7\n+        unwrap<DILocalVariable>(VarInfo),\n+#else\n         unwrapDI<DIVariable>(VarInfo),\n+#endif\n #if LLVM_VERSION_MINOR >= 6\n-        Expr,\n+        Builder->createExpression(\n+          llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n+#endif\n+#if LLVM_VERSION_MINOR >= 7\n+        DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n #endif\n         unwrap<Instruction>(InsertBefore)));\n }\n@@ -595,7 +643,11 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateEnumerationType(\n         LineNumber,\n         SizeInBits,\n         AlignInBits,\n+#if LLVM_VERSION_MINOR >= 7\n+        DINodeArray(unwrapDI<MDTuple>(Elements)),\n+#else\n         unwrapDI<DIArray>(Elements),\n+#endif\n         unwrapDI<DIType>(ClassType)));\n }\n \n@@ -620,7 +672,11 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateUnionType(\n         SizeInBits,\n         AlignInBits,\n         Flags,\n+#if LLVM_VERSION_MINOR >= 7\n+        DINodeArray(unwrapDI<MDTuple>(Elements)),\n+#else\n         unwrapDI<DIArray>(Elements),\n+#endif\n         RunTimeLang,\n         UniqueId\n         ));\n@@ -638,10 +694,14 @@ extern \"C\" LLVMMetadataRef LLVMDIBuilderCreateTemplateTypeParameter(\n     return wrap(Builder->createTemplateTypeParameter(\n       unwrapDI<DIDescriptor>(Scope),\n       Name,\n-      unwrapDI<DIType>(Ty),\n+      unwrapDI<DIType>(Ty)\n+#if LLVM_VERSION_MINOR <= 6\n+      ,\n       unwrapDI<MDNode*>(File),\n       LineNo,\n-      ColumnNo));\n+      ColumnNo\n+#endif\n+      ));\n }\n \n extern \"C\" int64_t LLVMDIBuilderCreateOpDeref()\n@@ -673,7 +733,10 @@ extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n     LLVMMetadataRef CompositeType,\n     LLVMMetadataRef TypeArray)\n {\n-#if LLVM_VERSION_MINOR >= 6\n+#if LLVM_VERSION_MINOR >= 7\n+    DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n+    Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n+#elif LLVM_VERSION_MINOR >= 6\n     DICompositeType tmp = unwrapDI<DICompositeType>(CompositeType);\n     Builder->replaceArrays(tmp, unwrapDI<DIArray>(TypeArray));\n #else\n@@ -692,11 +755,15 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateDebugLocation(\n \n     DebugLoc debug_loc = DebugLoc::get(Line,\n                                        Column,\n-                                       unwrapDI<MDNode*>(Scope),\n-                                       unwrapDI<MDNode*>(InlinedAt));\n+                                       unwrapDIptr<MDNode>(Scope),\n+                                       unwrapDIptr<MDNode>(InlinedAt));\n \n #if LLVM_VERSION_MINOR >= 6\n-    return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode(context)));\n+    return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode(\n+#if LLVM_VERSION_MINOR <= 6\n+            context\n+#endif\n+        )));\n #else\n     return wrap(debug_loc.getAsMDNode(context));\n #endif\n@@ -721,7 +788,12 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     Module *Dst = unwrap(dst);\n #if LLVM_VERSION_MINOR >= 6\n     std::unique_ptr<MemoryBuffer> buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+#if LLVM_VERSION_MINOR >= 7\n+    ErrorOr<std::unique_ptr<Module>> Src =\n+        llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+#else\n     ErrorOr<Module *> Src = llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+#endif\n #else\n     MemoryBuffer* buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n     ErrorOr<Module *> Src = llvm::getLazyBitcodeModule(buf, Dst->getContext());\n@@ -739,7 +811,11 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n #if LLVM_VERSION_MINOR >= 6\n     raw_string_ostream Stream(Err);\n     DiagnosticPrinterRawOStream DP(Stream);\n+#if LLVM_VERSION_MINOR >= 7\n+    if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n+#else\n     if (Linker::LinkModules(Dst, *Src, [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n+#endif\n #else\n     if (Linker::LinkModules(Dst, *Src, Linker::DestroySource, &Err)) {\n #endif\n@@ -813,8 +889,12 @@ extern \"C\" const Archive::Child*\n LLVMRustArchiveIteratorCurrent(RustArchiveIterator *rai) {\n     if (rai->cur == rai->end)\n         return NULL;\n+#if LLVM_VERSION_MINOR >= 6\n     const Archive::Child &ret = *rai->cur;\n     return &ret;\n+#else\n+    return rai->cur.operator->();\n+#endif\n }\n \n extern \"C\" void\n@@ -942,7 +1022,11 @@ extern \"C\" void LLVMWriteDebugLocToString(\n     RustStringRef str)\n {\n     raw_rust_string_ostream os(str);\n+#if LLVM_VERSION_MINOR >= 7\n+    unwrap(dl)->print(os);\n+#else\n     unwrap(dl)->print(*unwrap(C), os);\n+#endif\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)"}, {"sha": "38b7b49a3443e7371a55d2fd664b49a56e54d7ae", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-03-04\n+2015-06-16"}, {"sha": "2a47e8b089549a77bc20b0761c835adb953505a2", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -12,7 +12,6 @@\n #include \"llvm/IR/InlineAsm.h\"\n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/IR/Module.h\"\n-#include \"llvm/PassManager.h\"\n #include \"llvm/IR/InlineAsm.h\"\n #include \"llvm/IR/LLVMContext.h\"\n #include \"llvm/Analysis/Passes.h\"\n@@ -46,6 +45,12 @@\n #include \"llvm-c/ExecutionEngine.h\"\n #include \"llvm-c/Object.h\"\n \n+#if LLVM_VERSION_MINOR >= 7\n+#include \"llvm/IR/LegacyPassManager.h\"\n+#else\n+#include \"llvm/PassManager.h\"\n+#endif\n+\n #include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/IR/DebugInfo.h\"\n #include \"llvm/IR/DIBuilder.h\""}, {"sha": "bacc1acd3c4c30c34c66b7d1a17f8e7f10e11521", "filename": "src/test/auxiliary/llvm_pass_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fllvm_pass_plugin.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -24,5 +24,5 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     // Normally, we would name a pass that was registered through\n     // C++ static object constructors in the same .so file as the\n     // plugin registrar.\n-    reg.register_llvm_pass(\"inline\");\n+    reg.register_llvm_pass(\"gvn\");\n }"}, {"sha": "45b8731c3b149854e92cdb4b2e90749b23a3efc9", "filename": "src/test/codegen/loads.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fcodegen%2Floads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fcodegen%2Floads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floads.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -20,14 +20,14 @@ pub struct Bytes {\n // CHECK-LABEL: @borrow\n #[no_mangle]\n pub fn borrow(x: &i32) -> &i32 {\n-// CHECK: load i32** %x{{.*}}, !nonnull\n+// CHECK: load i32*, i32** %x{{.*}}, !nonnull\n     x\n }\n \n // CHECK-LABEL: @_box\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> i32 {\n-// CHECK: load i32** %x{{.*}}, !nonnull\n+// CHECK: load i32*, i32** %x{{.*}}, !nonnull\n     *x\n }\n \n@@ -36,7 +36,7 @@ pub fn _box(x: Box<i32>) -> i32 {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n-// CHECK: [[VAR:%[0-9]+]] = load i32* %{{.*}}, align 1\n+// CHECK: [[VAR:%[0-9]+]] = load i32, i32* %{{.*}}, align 1\n // CHECK: ret i32 [[VAR]]\n     x\n }\n@@ -46,7 +46,7 @@ pub fn small_array_alignment(x: [i8; 4]) -> [i8; 4] {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: Bytes) -> Bytes {\n-// CHECK: [[VAR:%[0-9]+]] = load i32* %{{.*}}, align 1\n+// CHECK: [[VAR:%[0-9]+]] = load i32, i32* %{{.*}}, align 1\n // CHECK: ret i32 [[VAR]]\n     x\n }"}, {"sha": "15cf76b2ab1de271c1ded1a941b710e822efc41f", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -22,7 +22,7 @@ pub struct Bytes {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: &mut [i8; 4]) {\n-// CHECK: [[VAR:%[0-9]+]] = load [4 x i8]** %x\n+// CHECK: [[VAR:%[0-9]+]] = load [4 x i8]*, [4 x i8]** %x\n // CHECK: [[VAR2:%[0-9]+]] = bitcast [4 x i8]* [[VAR]] to i32*\n // CHECK: store i32 %{{.*}}, i32* [[VAR2]], align 1\n     *x = [0; 4];\n@@ -33,7 +33,7 @@ pub fn small_array_alignment(x: &mut [i8; 4]) {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: &mut Bytes) {\n-// CHECK: [[VAR:%[0-9]+]] = load %Bytes** %x\n+// CHECK: [[VAR:%[0-9]+]] = load %Bytes*, %Bytes** %x\n // CHECK: [[VAR2:%[0-9]+]] = bitcast %Bytes* [[VAR]] to i32*\n // CHECK: store i32 %{{.*}}, i32* [[VAR2]], align 1\n     *x = Bytes {"}, {"sha": "243ecf86e9c46599c5977369aed4e827df2fdacd", "filename": "src/test/run-pass/asm-in-out-operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa00f2e972e8a620f77aeb457d1d1ae4e115bcac/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs?ref=aa00f2e972e8a620f77aeb457d1d1ae4e115bcac", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n #![feature(asm)]\n \n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n unsafe fn next_power_of_2(n: u32) -> u32 {\n     let mut tmp = n;\n     asm!(\"dec $0\" : \"+rm\"(tmp) :: \"cc\");\n-    let mut shift = 1_usize;\n+    let mut shift = 1_u32;\n     while shift <= 16 {\n         asm!(\n             \"shr %cl, $2"}]}