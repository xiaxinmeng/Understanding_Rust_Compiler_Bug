{"sha": "f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZjM2MTFmNWMyZDhiODgzNjFjZDY3ZDA2NTI4ZmYxYWU3ODc2ZTk=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-09-22T03:37:00Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2017-11-21T21:46:49Z"}, "message": "allow loading external files in documentation\n\nPartial implementation of https://github.com/rust-lang/rfcs/pull/1990\n(needs error reporting work)\n\ncc #44732", "tree": {"sha": "fc3739e05f0d3669da28533415e134b7a42a5138", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc3739e05f0d3669da28533415e134b7a42a5138"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "html_url": "https://github.com/rust-lang/rust/commit/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f28df200260c89b2a0bdf942510e0f888c29a70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f28df200260c89b2a0bdf942510e0f888c29a70d", "html_url": "https://github.com/rust-lang/rust/commit/f28df200260c89b2a0bdf942510e0f888c29a70d"}], "stats": {"total": 505, "additions": 480, "deletions": 25}, "files": [{"sha": "effae5d299949181a6cc8d7e4dc53c6a7d49cc0a", "filename": "src/doc/unstable-book/src/language-features/external-doc.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fexternal-doc.md?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,40 @@\n+# `external_doc`\n+\n+The tracking issue for this feature is: [#44732]\n+\n+The `external_doc` feature allows the use of the `include` parameter to the `#[doc]` attribute, to\n+include external files in documentation. Use the attribute in place of, or in addition to, regular\n+doc comments and `#[doc]` attributes, and `rustdoc` will load the given file when it renders\n+documentation for your crate.\n+\n+With the following files in the same directory:\n+\n+`external-doc.md`:\n+\n+```markdown\n+# My Awesome Type\n+\n+This is the documentation for this spectacular type.\n+```\n+\n+`lib.rs`:\n+\n+```no_run (needs-external-files)\n+#![feature(external_doc)]\n+\n+#[doc(include = \"external-doc.md\")]\n+pub struct MyAwesomeType;\n+```\n+\n+`rustdoc` will load the file `external-doc.md` and use it as the documentation for the `MyAwesomeType`\n+struct.\n+\n+When locating files, `rustdoc` will base paths in the `src/` directory, as if they were alongside the\n+`lib.rs` for your crate. So if you want a `docs/` folder to live alongside the `src/` directory,\n+start your paths with `../docs/` for `rustdoc` to properly find the file.\n+\n+This feature was proposed in [RFC #1990] and initially implemented in PR [#44781].\n+\n+[#44732]: https://github.com/rust-lang/rust/issues/44732\n+[RFC #1990]: https://github.com/rust-lang/rfcs/pull/1990\n+[#44781]: https://github.com/rust-lang/rust/pull/44781"}, {"sha": "42d7a31713c9041c1757e436639e5d68c6216160", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 140, "deletions": 4, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -44,6 +44,7 @@ use rustc::hir;\n \n use rustc_const_math::ConstInt;\n use std::{mem, slice, vec};\n+use std::iter::FromIterator;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -300,6 +301,11 @@ impl Item {\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n         self.attrs.doc_value()\n     }\n+    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n+    /// with newlines.\n+    pub fn collapsed_doc_value(&self) -> Option<String> {\n+        self.attrs.collapsed_doc_value()\n+    }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n             StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n@@ -564,9 +570,69 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n     }\n }\n \n+/// A portion of documentation, extracted from a `#[doc]` attribute.\n+///\n+/// Each variant contains the line number within the complete doc-comment where the fragment\n+/// starts, as well as the Span where the corresponding doc comment or attribute is located.\n+///\n+/// Included files are kept separate from inline doc comments so that proper line-number\n+/// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n+/// kept separate because of issue #42760.\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+pub enum DocFragment {\n+    // FIXME #44229 (misdreavus): sugared and raw doc comments can be brought back together once\n+    // hoedown is completely removed from rustdoc.\n+    /// A doc fragment created from a `///` or `//!` doc comment.\n+    SugaredDoc(usize, syntax_pos::Span, String),\n+    /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n+    RawDoc(usize, syntax_pos::Span, String),\n+    /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n+    /// given filename and the file contents.\n+    Include(usize, syntax_pos::Span, String, String),\n+}\n+\n+impl DocFragment {\n+    pub fn as_str(&self) -> &str {\n+        match *self {\n+            DocFragment::SugaredDoc(_, _, ref s) => &s[..],\n+            DocFragment::RawDoc(_, _, ref s) => &s[..],\n+            DocFragment::Include(_, _, _, ref s) => &s[..],\n+        }\n+    }\n+\n+    pub fn span(&self) -> syntax_pos::Span {\n+        match *self {\n+            DocFragment::SugaredDoc(_, span, _) |\n+                DocFragment::RawDoc(_, span, _) |\n+                DocFragment::Include(_, span, _, _) => span,\n+        }\n+    }\n+}\n+\n+impl<'a> FromIterator<&'a DocFragment> for String {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = &'a DocFragment>\n+    {\n+        iter.into_iter().fold(String::new(), |mut acc, frag| {\n+            if !acc.is_empty() {\n+                acc.push('\\n');\n+            }\n+            match *frag {\n+                DocFragment::SugaredDoc(_, _, ref docs)\n+                    | DocFragment::RawDoc(_, _, ref docs)\n+                    | DocFragment::Include(_, _, _, ref docs) =>\n+                    acc.push_str(docs),\n+            }\n+\n+            acc\n+        })\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Default)]\n pub struct Attributes {\n-    pub doc_strings: Vec<String>,\n+    pub doc_strings: Vec<DocFragment>,\n     pub other_attrs: Vec<ast::Attribute>,\n     pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n@@ -596,6 +662,47 @@ impl Attributes {\n         None\n     }\n \n+    /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n+    /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n+    /// its expansion.\n+    fn extract_include(mi: &ast::MetaItem)\n+        -> Option<(String, String)>\n+    {\n+        mi.meta_item_list().and_then(|list| {\n+            for meta in list {\n+                if meta.check_name(\"include\") {\n+                    // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n+                    // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n+                    // look for that instead\n+                    return meta.meta_item_list().and_then(|list| {\n+                        let mut filename: Option<String> = None;\n+                        let mut contents: Option<String> = None;\n+\n+                        for it in list {\n+                            if it.check_name(\"file\") {\n+                                if let Some(name) = it.value_str() {\n+                                    filename = Some(name.to_string());\n+                                }\n+                            } else if it.check_name(\"contents\") {\n+                                if let Some(docs) = it.value_str() {\n+                                    contents = Some(docs.to_string());\n+                                }\n+                            }\n+                        }\n+\n+                        if let (Some(filename), Some(contents)) = (filename, contents) {\n+                            Some((filename, contents))\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                }\n+            }\n+\n+            None\n+        })\n+    }\n+\n     pub fn has_doc_flag(&self, flag: &str) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.check_name(\"doc\") { continue; }\n@@ -610,18 +717,29 @@ impl Attributes {\n         false\n     }\n \n-    pub fn from_ast(diagnostic: &::errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n+    pub fn from_ast(diagnostic: &::errors::Handler,\n+                    attrs: &[ast::Attribute]) -> Attributes {\n         let mut doc_strings = vec![];\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n+        let mut doc_line = 0;\n \n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n                 if attr.check_name(\"doc\") {\n                     if let Some(mi) = attr.meta() {\n                         if let Some(value) = mi.value_str() {\n                             // Extracted #[doc = \"...\"]\n-                            doc_strings.push(value.to_string());\n+                            let value = value.to_string();\n+                            let line = doc_line;\n+                            doc_line += value.lines().count();\n+\n+                            if attr.is_sugared_doc {\n+                                doc_strings.push(DocFragment::SugaredDoc(line, attr.span, value));\n+                            } else {\n+                                doc_strings.push(DocFragment::RawDoc(line, attr.span, value));\n+                            }\n+\n                             if sp.is_none() {\n                                 sp = Some(attr.span);\n                             }\n@@ -633,6 +751,14 @@ impl Attributes {\n                                 Err(e) => diagnostic.span_err(e.span, e.msg),\n                             }\n                             return None;\n+                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n+                        {\n+                            let line = doc_line;\n+                            doc_line += contents.lines().count();\n+                            doc_strings.push(DocFragment::Include(line,\n+                                                                  attr.span,\n+                                                                  filename,\n+                                                                  contents));\n                         }\n                     }\n                 }\n@@ -650,7 +776,17 @@ impl Attributes {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n-        self.doc_strings.first().map(|s| &s[..])\n+        self.doc_strings.first().map(|s| s.as_str())\n+    }\n+\n+    /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n+    /// with newlines.\n+    pub fn collapsed_doc_value(&self) -> Option<String> {\n+        if !self.doc_strings.is_empty() {\n+            Some(self.doc_strings.iter().collect())\n+        } else {\n+            None\n+        }\n     }\n }\n "}, {"sha": "077797d1cd08c0a4f3c3c6bc778c2bdb10cdd0c5", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -36,6 +36,7 @@ pub use self::ExternalLocation::*;\n \n #[cfg(stage0)]\n use std::ascii::AsciiExt;\n+use std::borrow::Cow;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, HashSet};\n@@ -143,6 +144,23 @@ impl SharedContext {\n     }\n }\n \n+impl SharedContext {\n+    /// Returns whether the `collapse-docs` pass was run on this crate.\n+    pub fn was_collapsed(&self) -> bool {\n+        self.passes.contains(\"collapse-docs\")\n+    }\n+\n+    /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n+    /// `collapsed_doc_value` of the given item.\n+    pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n+        if self.was_collapsed() {\n+            item.collapsed_doc_value().map(|s| s.into())\n+        } else {\n+            item.doc_value().map(|s| s.into())\n+        }\n+    }\n+}\n+\n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n     /// Remote URL root of the external crate\n@@ -1817,6 +1835,9 @@ fn plain_summary_line(s: Option<&str>) -> String {\n }\n \n fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Result {\n+    if let Some(ref name) = item.name {\n+        info!(\"Documenting {}\", name);\n+    }\n     document_stability(w, cx, item)?;\n     let prefix = render_assoc_const_value(item);\n     document_full(w, item, cx, &prefix)?;\n@@ -1893,8 +1914,9 @@ fn render_assoc_const_value(item: &clean::Item) -> String {\n \n fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n                  cx: &Context, prefix: &str) -> fmt::Result {\n-    if let Some(s) = item.doc_value() {\n-        render_markdown(w, s, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n+    if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n+        debug!(\"Doc block: =====\\n{}\\n=====\", s);\n+        render_markdown(w, &*s, item.source.clone(), cx.render_type, prefix, &cx.shared)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -3326,8 +3348,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n-        if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, cx.render_type))?;\n+        if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(&*dox, cx.render_type))?;\n         }\n     }\n "}, {"sha": "a2d651d29de93362e00aee7d4857537d4ac5ff1e", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -8,10 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use clean::{self, Item};\n+use clean::{self, DocFragment, Item};\n use plugins;\n use fold;\n use fold::DocFolder;\n+use std::mem::replace;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum DocFragmentKind {\n+    Sugared,\n+    Raw,\n+    Include,\n+}\n+\n+impl DocFragment {\n+    fn kind(&self) -> DocFragmentKind {\n+        match *self {\n+            DocFragment::SugaredDoc(..) => DocFragmentKind::Sugared,\n+            DocFragment::RawDoc(..) => DocFragmentKind::Raw,\n+            DocFragment::Include(..) => DocFragmentKind::Include,\n+        }\n+    }\n+}\n \n pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     Collapser.fold_crate(krate)\n@@ -26,15 +44,51 @@ impl fold::DocFolder for Collapser {\n     }\n }\n \n-impl clean::Attributes {\n-    pub fn collapse_doc_comments(&mut self) {\n-        let mut doc_string = self.doc_strings.join(\"\\n\");\n-        if doc_string.is_empty() {\n-            self.doc_strings = vec![];\n+fn collapse(doc_strings: &mut Vec<DocFragment>) {\n+    let mut docs = vec![];\n+    let mut last_frag: Option<DocFragment> = None;\n+\n+    for frag in replace(doc_strings, vec![]) {\n+        if let Some(mut curr_frag) = last_frag.take() {\n+            let curr_kind = curr_frag.kind();\n+            let new_kind = frag.kind();\n+\n+            if curr_kind == DocFragmentKind::Include || curr_kind != new_kind {\n+                match curr_frag {\n+                    DocFragment::SugaredDoc(_, _, ref mut doc_string)\n+                        | DocFragment::RawDoc(_, _, ref mut doc_string) => {\n+                            // add a newline for extra padding between segments\n+                            doc_string.push('\\n');\n+                        }\n+                    _ => {}\n+                }\n+                docs.push(curr_frag);\n+                last_frag = Some(frag);\n+            } else {\n+                match curr_frag {\n+                    DocFragment::SugaredDoc(_, ref mut span, ref mut doc_string)\n+                        | DocFragment::RawDoc(_, ref mut span, ref mut doc_string) => {\n+                            doc_string.push('\\n');\n+                            doc_string.push_str(frag.as_str());\n+                            *span = span.to(frag.span());\n+                        }\n+                    _ => unreachable!(),\n+                }\n+                last_frag = Some(curr_frag);\n+            }\n         } else {\n-            // FIXME(eddyb) Is this still needed?\n-            doc_string.push('\\n');\n-            self.doc_strings = vec![doc_string];\n+            last_frag = Some(frag);\n         }\n     }\n+\n+    if let Some(frag) = last_frag.take() {\n+        docs.push(frag);\n+    }\n+    *doc_strings = docs;\n+}\n+\n+impl clean::Attributes {\n+    pub fn collapse_doc_comments(&mut self) {\n+        collapse(&mut self.doc_strings);\n+    }\n }"}, {"sha": "912c7646a06e58414fc5f0784856b99f7393b325", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -12,7 +12,7 @@ use std::cmp;\n use std::string::String;\n use std::usize;\n \n-use clean::{self, Item};\n+use clean::{self, DocFragment, Item};\n use plugins;\n use fold::{self, DocFolder};\n \n@@ -31,8 +31,17 @@ impl fold::DocFolder for CommentCleaner {\n \n impl clean::Attributes {\n     pub fn unindent_doc_comments(&mut self) {\n-        for doc_string in &mut self.doc_strings {\n-            *doc_string = unindent(doc_string);\n+        unindent_fragments(&mut self.doc_strings);\n+    }\n+}\n+\n+fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n+    for fragment in docs {\n+        match *fragment {\n+            DocFragment::SugaredDoc(_, _, ref mut doc_string) |\n+            DocFragment::RawDoc(_, _, ref mut doc_string) |\n+            DocFragment::Include(_, _, _, ref mut doc_string) =>\n+                *doc_string = unindent(doc_string),\n         }\n     }\n }"}, {"sha": "3aa674415f03b74e8bfe19f4471155e4fd9568b4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -663,14 +663,16 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n \n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n-        if let Some(doc) = attrs.doc_value() {\n+        // the collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n+        // anything else, this will combine them for us\n+        if let Some(doc) = attrs.collapsed_doc_value() {\n             if self.collector.render_type == RenderType::Pulldown {\n-                markdown::old_find_testable_code(doc, self.collector,\n+                markdown::old_find_testable_code(&doc, self.collector,\n                                                  attrs.span.unwrap_or(DUMMY_SP));\n-                markdown::find_testable_code(doc, self.collector,\n+                markdown::find_testable_code(&doc, self.collector,\n                                              attrs.span.unwrap_or(DUMMY_SP));\n             } else {\n-                markdown::old_find_testable_code(doc, self.collector,\n+                markdown::old_find_testable_code(&doc, self.collector,\n                                                  attrs.span.unwrap_or(DUMMY_SP));\n             }\n         }"}, {"sha": "6c96692f719ffce1b5a4fc23a965511ad0fcbdec", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -665,6 +665,7 @@ pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n+    pub root_path: PathBuf,\n     pub resolver: &'a mut Resolver,\n     pub resolve_err_count: usize,\n     pub current_expansion: ExpansionData,\n@@ -680,6 +681,7 @@ impl<'a> ExtCtxt<'a> {\n             parse_sess,\n             ecfg,\n             crate_root: None,\n+            root_path: PathBuf::new(),\n             resolver,\n             resolve_err_count: 0,\n             current_expansion: ExpansionData {"}, {"sha": "0d1b1c65a2934d50c77f1764e9c8891581315736", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -11,7 +11,7 @@\n use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n-use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, dummy_spanned};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::FatalError;\n use ext::base::*;\n@@ -35,6 +35,8 @@ use util::small_vector::SmallVector;\n use visit::Visitor;\n \n use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::Read;\n use std::mem;\n use std::rc::Rc;\n \n@@ -223,6 +225,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             directory: self.cx.codemap().span_to_unmapped_path(krate.span),\n         };\n         module.directory.pop();\n+        self.cx.root_path = module.directory.clone();\n         self.cx.current_expansion.module = Rc::new(module);\n \n         let orig_mod_span = krate.module.inner;\n@@ -843,6 +846,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n         }\n     }\n+\n+    fn check_attribute(&mut self, at: &ast::Attribute) {\n+        let features = self.cx.ecfg.features.unwrap();\n+        feature_gate::check_attribute(at, self.cx.parse_sess, features);\n+    }\n }\n \n pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n@@ -1063,6 +1071,84 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         }\n     }\n \n+    fn fold_attribute(&mut self, at: ast::Attribute) -> Option<ast::Attribute> {\n+        // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n+        // contents=\"file contents\")]` attributes\n+        if !at.check_name(\"doc\") {\n+            return noop_fold_attribute(at, self);\n+        }\n+\n+        if let Some(list) = at.meta_item_list() {\n+            if !list.iter().any(|it| it.check_name(\"include\")) {\n+                return noop_fold_attribute(at, self);\n+            }\n+\n+            let mut items = vec![];\n+\n+            for it in list {\n+                if !it.check_name(\"include\") {\n+                    items.push(noop_fold_meta_list_item(it, self));\n+                    continue;\n+                }\n+\n+                if let Some(file) = it.value_str() {\n+                    let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+                    self.check_attribute(&at);\n+                    if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+                        // avoid loading the file if they haven't enabled the feature\n+                        return noop_fold_attribute(at, self);\n+                    }\n+\n+                    let mut buf = vec![];\n+                    let filename = self.cx.root_path.join(file.to_string());\n+\n+                    match File::open(&filename).and_then(|mut f| f.read_to_end(&mut buf)) {\n+                        Ok(..) => {}\n+                        Err(e) => {\n+                            self.cx.span_warn(at.span,\n+                                              &format!(\"couldn't read {}: {}\",\n+                                                       filename.display(),\n+                                                       e));\n+                        }\n+                    }\n+\n+                    match String::from_utf8(buf) {\n+                        Ok(src) => {\n+                            let include_info = vec![\n+                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                        attr::mk_name_value_item_str(\"file\".into(),\n+                                                                     file))),\n+                                dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                        attr::mk_name_value_item_str(\"contents\".into(),\n+                                                                     (&*src).into()))),\n+                            ];\n+\n+                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n+                                        attr::mk_list_item(\"include\".into(), include_info))));\n+                        }\n+                        Err(_) => {\n+                            self.cx.span_warn(at.span,\n+                                              &format!(\"{} wasn't a utf-8 file\",\n+                                                       filename.display()));\n+                        }\n+                    }\n+                } else {\n+                    items.push(noop_fold_meta_list_item(it, self));\n+                }\n+            }\n+\n+            let meta = attr::mk_list_item(\"doc\".into(), items);\n+            match at.style {\n+                ast::AttrStyle::Inner =>\n+                    Some(attr::mk_spanned_attr_inner(at.span, at.id, meta)),\n+                ast::AttrStyle::Outer =>\n+                    Some(attr::mk_spanned_attr_outer(at.span, at.id, meta)),\n+            }\n+        } else {\n+            noop_fold_attribute(at, self)\n+        }\n+    }\n+\n     fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n         if self.monotonic {\n             assert_eq!(id, ast::DUMMY_NODE_ID);"}, {"sha": "383fe0092be578797f48e943ef1d93b2da44cb6e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -383,6 +383,8 @@ declare_features! (\n     (active, doc_masked, \"1.21.0\", Some(44027)),\n     // #[doc(spotlight)]\n     (active, doc_spotlight, \"1.22.0\", Some(45040)),\n+    // #[doc(include=\"some-file\")]\n+    (active, external_doc, \"1.22.0\", Some(44732)),\n \n     // allow `#[must_use]` on functions and comparison operators (RFC 1940)\n     (active, fn_must_use, \"1.21.0\", Some(43302)),\n@@ -1028,6 +1030,14 @@ impl<'a> Context<'a> {\n             if name == n {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc, GateStrength::Hard);\n+                } else if name == \"doc\" {\n+                    if let Some(content) = attr.meta_item_list() {\n+                        if content.iter().any(|c| c.check_name(\"include\")) {\n+                            gate_feature!(self, external_doc, attr.span,\n+                                \"#[doc(include = \\\"...\\\")] is experimental\"\n+                            );\n+                        }\n+                    }\n                 }\n                 debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n                 return;"}, {"sha": "fa0a2a29078c556746a115418085ed214e71f085", "filename": "src/test/compile-fail/feature-gate-external_doc.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-external_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Fcompile-fail%2Ffeature-gate-external_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-external_doc.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(include=\"asdf.md\")] //~ ERROR: #[doc(include = \"...\")] is experimental\n+fn main() {}"}, {"sha": "8b4e6edc69997f24261052e124e568267d2cdb20", "filename": "src/test/rustdoc/auxiliary/external-cross-doc.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross-doc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross-doc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross-doc.md?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,4 @@\n+# Cross-crate imported docs\n+\n+This file is to make sure `#[doc(include=\"file.md\")]` works when you re-export an item with included\n+docs."}, {"sha": "cb14fec7abe7a6059574bdddc07b8e7b4d34d79d", "filename": "src/test/rustdoc/auxiliary/external-cross.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-cross.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(external_doc)]\n+\n+#[doc(include=\"external-cross-doc.md\")]\n+pub struct NeedMoreDocs;"}, {"sha": "38478c1635a178ce40850d5d8f002f2e0a991a80", "filename": "src/test/rustdoc/auxiliary/external-doc.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-doc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-doc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fexternal-doc.md?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,3 @@\n+# External Docs\n+\n+This file is here to test the `#[doc(include=\"file\")]` attribute."}, {"sha": "f4a59cee32dd9763fbe7507292b03574153297f2", "filename": "src/test/rustdoc/external-cross.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fexternal-cross.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fexternal-cross.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fexternal-cross.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:external-cross.rs\n+// ignore-cross-compile\n+\n+#![crate_name=\"host\"]\n+\n+extern crate external_cross;\n+\n+// @has host/struct.NeedMoreDocs.html\n+// @has - '//h1' 'Cross-crate imported docs'\n+pub use external_cross::NeedMoreDocs;"}, {"sha": "07e784a6ccfafa8301464dcb054bdb0fe7aaf46f", "filename": "src/test/rustdoc/external-doc.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fexternal-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fexternal-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fexternal-doc.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(external_doc)]\n+\n+// @has external_doc/struct.CanHasDocs.html\n+// @has - '//h1' 'External Docs'\n+// @has - '//h2' 'Inline Docs'\n+#[doc(include = \"auxiliary/external-doc.md\")]\n+/// ## Inline Docs\n+pub struct CanHasDocs;"}, {"sha": "f5f5c4f97fd027af03998a5e18cf0d727c77d20d", "filename": "src/test/rustdoc/issue-42760.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fissue-42760.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f3611f5c2d8b88361cd67d06528ff1ae7876e9/src%2Ftest%2Frustdoc%2Fissue-42760.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-42760.rs?ref=f9f3611f5c2d8b88361cd67d06528ff1ae7876e9", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has issue_42760/struct.NonGen.html\n+// @has - '//h1' 'Example'\n+\n+/// Item docs.\n+///\n+#[doc=\"Hello there!\"]\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// // some code here\n+/// ```\n+pub struct NonGen;"}]}