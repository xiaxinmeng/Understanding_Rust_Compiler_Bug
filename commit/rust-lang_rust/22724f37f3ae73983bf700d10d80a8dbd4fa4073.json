{"sha": "22724f37f3ae73983bf700d10d80a8dbd4fa4073", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNzI0ZjM3ZjNhZTczOTgzYmY3MDBkMTBkODBhOGRiZDRmYTQwNzM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-05T20:42:38Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-12T19:43:00Z"}, "message": "Lower fully qualified associated type paths\n\nI.e. `<T as Trait>::Foo`.", "tree": {"sha": "f5970c453f15d2b60e7c7b026de34316a5c8f4e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5970c453f15d2b60e7c7b026de34316a5c8f4e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22724f37f3ae73983bf700d10d80a8dbd4fa4073", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22724f37f3ae73983bf700d10d80a8dbd4fa4073", "html_url": "https://github.com/rust-lang/rust/commit/22724f37f3ae73983bf700d10d80a8dbd4fa4073", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22724f37f3ae73983bf700d10d80a8dbd4fa4073/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cfdfdecbaed38534397f16e1ea1cda38b0b9395", "html_url": "https://github.com/rust-lang/rust/commit/6cfdfdecbaed38534397f16e1ea1cda38b0b9395"}], "stats": {"total": 151, "additions": 128, "deletions": 23}, "files": [{"sha": "1158adbbc0f7ef5feffc3e6a258ec9ba77e1c58d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=22724f37f3ae73983bf700d10d80a8dbd4fa4073", "patch": "@@ -71,6 +71,7 @@ fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n             ast::PathSegmentKind::SelfKw => a == \"self\",\n             ast::PathSegmentKind::SuperKw => a == \"super\",\n             ast::PathSegmentKind::CrateKw => a == \"crate\",\n+            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n         }\n     } else {\n         false"}, {"sha": "5ee71e421e3add42dbbbc5b25df24e4dc82ea022", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=22724f37f3ae73983bf700d10d80a8dbd4fa4073", "patch": "@@ -25,6 +25,12 @@ pub struct PathSegment {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n     pub args: Vec<GenericArg>,\n+    /// This specifies whether the args contain a Self type as the first\n+    /// element. This is the case for path segments like `<T as Trait>`, where\n+    /// `T` is actually a type parameter for the path `Trait` specifying the\n+    /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n+    /// is left out.\n+    pub has_self_type: bool,\n     // someday also bindings\n }\n \n@@ -74,6 +80,28 @@ impl Path {\n                     let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n                     segments.push(segment);\n                 }\n+                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n+                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n+\n+                    // FIXME: handle <T> syntax (type segments without trait)\n+\n+                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                    let path = Path::from_ast(trait_ref?.path()?)?;\n+                    kind = path.kind;\n+                    let mut prefix_segments = path.segments;\n+                    prefix_segments.reverse();\n+                    segments.extend(prefix_segments);\n+                    // Insert the type reference (T in the above example) as Self parameter for the trait\n+                    let self_type = TypeRef::from_ast(type_ref?);\n+                    let mut last_segment = segments.last_mut()?;\n+                    if last_segment.args_and_bindings.is_none() {\n+                        last_segment.args_and_bindings = Some(Arc::new(GenericArgs::empty()));\n+                    };\n+                    let args = last_segment.args_and_bindings.as_mut().unwrap();\n+                    let mut args_inner = Arc::make_mut(args);\n+                    args_inner.has_self_type = true;\n+                    args_inner.args.insert(0, GenericArg::Type(self_type));\n+                }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -144,11 +172,15 @@ impl GenericArgs {\n         }\n         // lifetimes and assoc type args ignored for now\n         if !args.is_empty() {\n-            Some(GenericArgs { args })\n+            Some(GenericArgs { args, has_self_type: false })\n         } else {\n             None\n         }\n     }\n+\n+    pub(crate) fn empty() -> GenericArgs {\n+        GenericArgs { args: Vec::new(), has_self_type: false }\n+    }\n }\n \n impl From<Name> for Path {\n@@ -236,6 +268,10 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n             }\n             Path { kind: PathKind::Super, segments: Vec::new() }\n         }\n+        ast::PathSegmentKind::Type { .. } => {\n+            // not allowed in imports\n+            return None;\n+        }\n     };\n     Some(res)\n }"}, {"sha": "24ec77fcf5c6d147003d752f88ebffbfe4cb9643", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 73, "deletions": 15, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=22724f37f3ae73983bf700d10d80a8dbd4fa4073", "patch": "@@ -8,7 +8,7 @@\n use std::iter;\n use std::sync::Arc;\n \n-use super::{FnSig, GenericPredicate, Substs, TraitRef, Ty, TypeCtor};\n+use super::{FnSig, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor};\n use crate::{\n     adt::VariantDef,\n     generics::HasGenericParams,\n@@ -64,7 +64,8 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         // Resolve the path (in type namespace)\n-        let resolution = resolver.resolve_path_without_assoc_items(db, path).take_types();\n+        let (resolution, remaining_index) = resolver.resolve_path_segments(db, path).into_inner();\n+        let resolution = resolution.take_types();\n \n         let def = match resolution {\n             Some(Resolution::Def(def)) => def,\n@@ -73,6 +74,10 @@ impl Ty {\n                 panic!(\"path resolved to local binding in type ns\");\n             }\n             Some(Resolution::GenericParam(idx)) => {\n+                if remaining_index.is_some() {\n+                    // e.g. T::Item\n+                    return Ty::Unknown;\n+                }\n                 return Ty::Param {\n                     idx,\n                     // FIXME: maybe return name in resolution?\n@@ -83,18 +88,59 @@ impl Ty {\n                 };\n             }\n             Some(Resolution::SelfType(impl_block)) => {\n+                if remaining_index.is_some() {\n+                    // e.g. Self::Item\n+                    return Ty::Unknown;\n+                }\n                 return impl_block.target_ty(db);\n             }\n-            None => return Ty::Unknown,\n+            None => {\n+                // path did not resolve\n+                return Ty::Unknown;\n+            }\n         };\n \n-        let typable: TypableDef = match def.into() {\n-            None => return Ty::Unknown,\n-            Some(it) => it,\n-        };\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path(db, resolver, path, typable);\n-        ty.subst(&substs)\n+        if let ModuleDef::Trait(trait_) = def {\n+            let segment = match remaining_index {\n+                None => path.segments.last().expect(\"resolved path has at least one element\"),\n+                Some(i) => &path.segments[i - 1],\n+            };\n+            let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n+            if let Some(remaining_index) = remaining_index {\n+                if remaining_index == path.segments.len() - 1 {\n+                    let segment = &path.segments[remaining_index];\n+                    let associated_ty =\n+                        match trait_ref.trait_.associated_type_by_name(db, segment.name.clone()) {\n+                            Some(t) => t,\n+                            None => {\n+                                // associated type not found\n+                                return Ty::Unknown;\n+                            }\n+                        };\n+                    eprintln!(\n+                        \"assoc ty: {:?}, parameters: {:?}\",\n+                        associated_ty.name(db),\n+                        trait_ref.substs\n+                    );\n+                    // FIXME handle type parameters on the segment\n+                    Ty::Projection(ProjectionTy { associated_ty, parameters: trait_ref.substs })\n+                } else {\n+                    // FIXME more than one segment remaining, is this possible?\n+                    Ty::Unknown\n+                }\n+            } else {\n+                // FIXME dyn Trait without the dyn\n+                Ty::Unknown\n+            }\n+        } else {\n+            let typable: TypableDef = match def.into() {\n+                None => return Ty::Unknown,\n+                Some(it) => it,\n+            };\n+            let ty = db.type_for_def(typable, Namespace::Types);\n+            let substs = Ty::substs_from_path(db, resolver, path, typable);\n+            ty.subst(&substs)\n+        }\n     }\n \n     pub(super) fn substs_from_path_segment(\n@@ -219,14 +265,25 @@ impl TraitRef {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n         };\n-        let mut substs = Self::substs_from_path(db, resolver, path, resolved);\n+        let segment = path.segments.last().expect(\"path should have at least one segment\");\n+        Some(TraitRef::from_resolved_path(db, resolver, resolved, segment, explicit_self_ty))\n+    }\n+\n+    fn from_resolved_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        resolved: Trait,\n+        segment: &PathSegment,\n+        explicit_self_ty: Option<Ty>,\n+    ) -> Self {\n+        let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             // FIXME this could be nicer\n             let mut substs_vec = substs.0.to_vec();\n             substs_vec[0] = self_ty;\n             substs.0 = substs_vec.into();\n         }\n-        Some(TraitRef { trait_: resolved, substs })\n+        TraitRef { trait_: resolved, substs }\n     }\n \n     pub(crate) fn from_hir(\n@@ -245,11 +302,12 @@ impl TraitRef {\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        path: &Path,\n+        segment: &PathSegment,\n         resolved: Trait,\n     ) -> Substs {\n-        let segment = path.segments.last().expect(\"path should have at least one segment\");\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), true)\n+        let has_self_param =\n+            segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n+        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {"}, {"sha": "01b3583359579ebe4a1fef69a590e4fde56f24c1", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=22724f37f3ae73983bf700d10d80a8dbd4fa4073", "patch": "@@ -2515,10 +2515,10 @@ fn test<T: Iterable>() {\n         @r###\"\n    \u22ee\n    \u22ee[108; 227) '{     ...ter; }': ()\n-   \u22ee[118; 119) 'x': i32\n-   \u22ee[145; 146) '1': i32\n-   \u22ee[156; 157) 'y': {unknown}\n-   \u22ee[183; 192) 'no_matter': {unknown}\n+   \u22ee[118; 119) 'x': <S as Iterable>::Item\n+   \u22ee[145; 146) '1': <S as Iterable>::Item\n+   \u22ee[156; 157) 'y': <T as Iterable>::Item\n+   \u22ee[183; 192) 'no_matter': <T as Iterable>::Item\n    \u22ee[202; 203) 'z': {unknown}\n    \u22ee[215; 224) 'no_matter': {unknown}\n     \"###\n@@ -2552,9 +2552,9 @@ fn test() {\n    \u22ee[205; 209) 'foo1': fn foo1<S>(T) -> {unknown}\n    \u22ee[205; 212) 'foo1(S)': {unknown}\n    \u22ee[210; 211) 'S': S\n-   \u22ee[222; 223) 'y': {unknown}\n-   \u22ee[226; 230) 'foo2': fn foo2<S>(T) -> {unknown}\n-   \u22ee[226; 233) 'foo2(S)': {unknown}\n+   \u22ee[222; 223) 'y': <S as Iterable>::Item\n+   \u22ee[226; 230) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+   \u22ee[226; 233) 'foo2(S)': <S as Iterable>::Item\n    \u22ee[231; 232) 'S': S\n     \"###\n     );"}, {"sha": "2a59cf653734ff92504b6dd9bacac6bd3d8cb09f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22724f37f3ae73983bf700d10d80a8dbd4fa4073/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=22724f37f3ae73983bf700d10d80a8dbd4fa4073", "patch": "@@ -91,6 +91,7 @@ impl ast::Attr {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathSegmentKind {\n     Name(ast::NameRef),\n+    Type { type_ref: Option<ast::TypeRef>, trait_ref: Option<ast::PathType> },\n     SelfKw,\n     SuperKw,\n     CrateKw,\n@@ -112,6 +113,15 @@ impl ast::PathSegment {\n                 T![self] => PathSegmentKind::SelfKw,\n                 T![super] => PathSegmentKind::SuperKw,\n                 T![crate] => PathSegmentKind::CrateKw,\n+                T![<] => {\n+                    // <T> or <T as Trait>\n+                    // T is any TypeRef, Trait has to be a PathType\n+                    let mut type_refs =\n+                        self.syntax().children().filter(|node| ast::TypeRef::can_cast(node.kind()));\n+                    let type_ref = type_refs.next().and_then(ast::TypeRef::cast);\n+                    let trait_ref = type_refs.next().and_then(ast::PathType::cast);\n+                    PathSegmentKind::Type { type_ref, trait_ref }\n+                }\n                 _ => return None,\n             }\n         };"}]}