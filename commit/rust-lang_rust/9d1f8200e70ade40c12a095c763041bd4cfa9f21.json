{"sha": "9d1f8200e70ade40c12a095c763041bd4cfa9f21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMWY4MjAwZTcwYWRlNDBjMTJhMDk1Yzc2MzA0MWJkNGNmYTlmMjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T07:08:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T07:08:17Z"}, "message": "Auto merge of #28004 - Diggsey:win-backtrace, r=alexcrichton\n\nTechnically this could also be used for `windows-msvc` targets, as I believe they have *both* dwarf and pdb debug information, but I haven't enabled it there as it should really use the native windows APIs for that, instead of libbacktrace.\r\n\r\nI wasn't exactly sure where I should put \"gnu\" specific stuff, so tell me if I should structure things differently.\r\n\r\nThis is still a WIP, and I haven't tested properly to make sure I haven't broken msvc/linux builds yet.", "tree": {"sha": "7553893fb154c3fcc75b69b4a08dec614fcacc88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7553893fb154c3fcc75b69b4a08dec614fcacc88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d1f8200e70ade40c12a095c763041bd4cfa9f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d1f8200e70ade40c12a095c763041bd4cfa9f21", "html_url": "https://github.com/rust-lang/rust/commit/9d1f8200e70ade40c12a095c763041bd4cfa9f21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d1f8200e70ade40c12a095c763041bd4cfa9f21/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "791e7bcb418381480bf10cb87ef5da769be7143f", "url": "https://api.github.com/repos/rust-lang/rust/commits/791e7bcb418381480bf10cb87ef5da769be7143f", "html_url": "https://github.com/rust-lang/rust/commit/791e7bcb418381480bf10cb87ef5da769be7143f"}, {"sha": "d4fc3ec208186f0a9de8d05a6802c95b07e058fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4fc3ec208186f0a9de8d05a6802c95b07e058fd", "html_url": "https://github.com/rust-lang/rust/commit/d4fc3ec208186f0a9de8d05a6802c95b07e058fd"}], "stats": {"total": 1504, "additions": 1349, "deletions": 155}, "files": [{"sha": "1f60aaed4730b979c82ee199e0e1707bb86d978d", "filename": "mk/rt.mk", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -259,8 +259,10 @@ BACKTRACE_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),backtrace)\n BACKTRACE_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(BACKTRACE_NAME_$(1))\n BACKTRACE_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/libbacktrace\n \n-# We don't use this on platforms that aren't linux-based, so just make the file\n-# available, the compilation of libstd won't actually build it.\n+# We don't use this on platforms that aren't linux-based (with the exception of\n+# msys2/mingw builds on windows, which use it to read the dwarf debug\n+# information) so just make the file available, the compilation of libstd won't\n+# actually build it.\n ifeq ($$(findstring darwin,$$(OSTYPE_$(1))),darwin)\n # See comment above\n $$(BACKTRACE_LIB_$(1)):\n@@ -273,7 +275,7 @@ $$(BACKTRACE_LIB_$(1)):\n \ttouch $$@\n else\n \n-ifeq ($$(CFG_WINDOWSY_$(1)),1)\n+ifeq ($$(findstring msvc,$(1)),msvc)\n # See comment above\n $$(BACKTRACE_LIB_$(1)):\n \ttouch $$@\n@@ -296,16 +298,25 @@ endif\n # ./configure script. This is done to force libbacktrace to *not* use the\n # atomic/sync functionality because it pulls in unnecessary dependencies and we\n # never use it anyway.\n+#\n+# We also use `env PWD=` to clear the PWD environment variable, and then\n+# execute the command in a new shell. This is necessary to workaround a\n+# buildbot/msys2 bug: the shell is launched with PWD set to a windows-style path,\n+# which results in all further uses of `pwd` also printing a windows-style path,\n+# which breaks libbacktrace's configure script. Clearing PWD within the same\n+# shell is not sufficient.\n+\n $$(BACKTRACE_BUILD_DIR_$(1))/Makefile: $$(BACKTRACE_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, configure: libbacktrace for $(1))\n \t$$(Q)rm -rf $$(BACKTRACE_BUILD_DIR_$(1))\n \t$$(Q)mkdir -p $$(BACKTRACE_BUILD_DIR_$(1))\n-\t$$(Q)(cd $$(BACKTRACE_BUILD_DIR_$(1)) && \\\n+\t$$(Q)(cd $$(BACKTRACE_BUILD_DIR_$(1)) && env \\\n+\t      PWD= \\\n \t      CC=\"$$(CC_$(1))\" \\\n \t      AR=\"$$(AR_$(1))\" \\\n \t      RANLIB=\"$$(AR_$(1)) s\" \\\n \t      CFLAGS=\"$$(CFG_GCCISH_CFLAGS_$(1):-Werror=) -fno-stack-protector\" \\\n-\t      $(S)src/libbacktrace/configure --target=$(1) --host=$(CFG_BUILD))\n+\t      $(S)src/libbacktrace/configure --build=$(CFG_GNU_TRIPLE_$(CFG_BUILD)) --host=$(CFG_GNU_TRIPLE_$(1)))\n \t$$(Q)echo '#undef HAVE_ATOMIC_FUNCTIONS' >> \\\n \t      $$(BACKTRACE_BUILD_DIR_$(1))/config.h\n \t$$(Q)echo '#undef HAVE_SYNC_FUNCTIONS' >> \\\n@@ -317,7 +328,7 @@ $$(BACKTRACE_LIB_$(1)): $$(BACKTRACE_BUILD_DIR_$(1))/Makefile $$(MKFILE_DEPS)\n \t\tINCDIR=$(S)src/libbacktrace\n \t$$(Q)cp $$(BACKTRACE_BUILD_DIR_$(1))/.libs/libbacktrace.a $$@\n \n-endif # endif for windowsy\n+endif # endif for msvc\n endif # endif for ios\n endif # endif for darwin\n "}, {"sha": "c31c651f95c6b3b83bda5f7ca7778988f599c7ae", "filename": "src/libbacktrace/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FChangeLog", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -1,3 +1,41 @@\n+2015-08-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* configure.ac: Set have_mmap to no on spu-*-* targets.\n+\t* configure: Regenerate.\n+\n+2015-08-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_function_entry): Add vec_inlined parameter.\n+\tChange all callers.\n+\n+2015-06-11  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR sanitizer/65479\n+\t* dwarf.c (struct line): Add new field idx.\n+\t(line_compare): Use it.\n+\t(add_line): Set it.\n+\t(read_line_info): Reset it.\n+\n+2015-05-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* pecoff.c: New file.\n+\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n+\t* Makefile.in: Regenerate.\n+\t* filetype.awk: Detect pecoff.\n+\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n+\tAdd pecoff.\n+\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n+\ttrue.\n+\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n+\t* configure: Regenerate.\n+\t* pecoff.c: New file.\n+\n+2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n+\n+\t* Makefile.in: Regenerated with automake-1.11.6.\n+\t* aclocal.m4: Likewise.\n+\t* configure: Likewise.\n+\n 2015-01-24  Matthias Klose  <doko@ubuntu.com>\n \n \t* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC."}, {"sha": "c5f0dcbcf7a19157326dec3e9e408d4cdafd8e60", "filename": "src/libbacktrace/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -56,6 +56,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tpecoff.c \\\n \tunknown.c\n \n VIEW_FILES = \\\n@@ -124,6 +125,7 @@ fileline.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h\n+pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n print.lo: config.h backtrace.h internal.h\n read.lo: config.h backtrace.h internal.h"}, {"sha": "b434d76edb620e81aa048bdea1019c0fd8213a4a", "filename": "src/libbacktrace/Makefile.in", "status": "modified", "additions": 50, "deletions": 22, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -1,9 +1,9 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# Makefile.in generated by automake 1.11.6 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -16,7 +16,7 @@\n @SET_MAKE@\n \n # Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012-2014 Free Software Foundation, Inc.\n+# Copyright (C) 2012-2015 Free Software Foundation, Inc.\n \n # Redistribution and use in source and binary forms, with or without\n # modification, are permitted provided that the following conditions are\n@@ -47,6 +47,23 @@\n # POSSIBILITY OF SUCH DAMAGE.\n \n VPATH = @srcdir@\n+am__make_dryrun = \\\n+  { \\\n+    am__dry=no; \\\n+    case $$MAKEFLAGS in \\\n+      *\\\\[\\ \\\t]*) \\\n+        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n+      *) \\\n+        for am__flg in $$MAKEFLAGS; do \\\n+          case $$am__flg in \\\n+            *=*|--*) ;; \\\n+            *n*) am__dry=yes; break;; \\\n+          esac; \\\n+        done;; \\\n+    esac; \\\n+    test $$am__dry = yes; \\\n+  }\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n pkglibdir = $(libdir)/@PACKAGE@\n@@ -126,6 +143,11 @@ MULTIDIRS =\n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n+am__can_run_installinfo = \\\n+  case $$AM_UPDATE_INFO_DIR in \\\n+    n|no|NO) false;; \\\n+    *) (install-info --version) >/dev/null 2>&1;; \\\n+  esac\n ETAGS = etags\n CTAGS = ctags\n am__tty_colors = \\\n@@ -277,6 +299,7 @@ BACKTRACE_FILES = \\\n \n FORMAT_FILES = \\\n \telf.c \\\n+\tpecoff.c \\\n \tunknown.c\n \n VIEW_FILES = \\\n@@ -324,7 +347,7 @@ all: config.h\n \n .SUFFIXES:\n .SUFFIXES: .c .lo .o .obj\n-am--refresh:\n+am--refresh: Makefile\n \t@:\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n@@ -360,10 +383,8 @@ $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n $(am__aclocal_m4_deps):\n \n config.h: stamp-h1\n-\t@if test ! -f $@; then \\\n-\t  rm -f stamp-h1; \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n-\telse :; fi\n+\t@if test ! -f $@; then rm -f stamp-h1; else :; fi\n+\t@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi\n \n stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n \t@rm -f stamp-h1\n@@ -386,7 +407,7 @@ clean-noinstLTLIBRARIES:\n \t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n \t  rm -f \"$${dir}/so_locations\"; \\\n \tdone\n-libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) \n+libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES) \n \t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n \n clean-checkPROGRAMS:\n@@ -397,10 +418,10 @@ clean-checkPROGRAMS:\n \tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n \techo \" rm -f\" $$list; \\\n \trm -f $$list\n-btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) \n+btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES) \n \t@rm -f btest$(EXEEXT)\n \t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n-stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) \n+stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n \t@rm -f stest$(EXEEXT)\n \t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n \n@@ -584,14 +605,15 @@ check-TESTS: $(TESTS)\n \t  fi; \\\n \t  dashes=`echo \"$$dashes\" | sed s/./=/g`; \\\n \t  if test \"$$failed\" -eq 0; then \\\n-\t    echo \"$$grn$$dashes\"; \\\n+\t    col=\"$$grn\"; \\\n \t  else \\\n-\t    echo \"$$red$$dashes\"; \\\n+\t    col=\"$$red\"; \\\n \t  fi; \\\n-\t  echo \"$$banner\"; \\\n-\t  test -z \"$$skipped\" || echo \"$$skipped\"; \\\n-\t  test -z \"$$report\" || echo \"$$report\"; \\\n-\t  echo \"$$dashes$$std\"; \\\n+\t  echo \"$${col}$$dashes$${std}\"; \\\n+\t  echo \"$${col}$$banner$${std}\"; \\\n+\t  test -z \"$$skipped\" || echo \"$${col}$$skipped$${std}\"; \\\n+\t  test -z \"$$report\" || echo \"$${col}$$report$${std}\"; \\\n+\t  echo \"$${col}$$dashes$${std}\"; \\\n \t  test \"$$failed\" -eq 0; \\\n \telse :; fi\n check-am: all-am\n@@ -610,10 +632,15 @@ install-am: all-am\n \n installcheck: installcheck-am\n install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n mostlyclean-generic:\n \n clean-generic:\n@@ -727,6 +754,7 @@ fileline.lo: config.h backtrace.h internal.h\n mmap.lo: config.h backtrace.h internal.h\n mmapio.lo: config.h backtrace.h internal.h\n nounwind.lo: config.h internal.h\n+pecoff.lo: config.h backtrace.h internal.h\n posix.lo: config.h backtrace.h internal.h\n print.lo: config.h backtrace.h internal.h\n read.lo: config.h backtrace.h internal.h"}, {"sha": "8e84ddd1f10132210a49e7d08ba522e09df3a8ad", "filename": "src/libbacktrace/aclocal.m4", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Faclocal.m4?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -1,7 +1,8 @@\n-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+# generated automatically by aclocal 1.11.6 -*- Autoconf -*-\n \n # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n+# Inc.\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -19,12 +20,15 @@ You have another version of autoconf.  It may work, but is not guaranteed to.\n If you have problems, you may need to regenerate the build system entirely.\n To do so, use the procedure documented by the package, typically `autoreconf'.])])\n \n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n+# Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n+# serial 1\n+\n # AM_AUTOMAKE_VERSION(VERSION)\n # ----------------------------\n # Automake X.Y traces this macro to ensure aclocal.m4 has been\n@@ -34,7 +38,7 @@ AC_DEFUN([AM_AUTOMAKE_VERSION],\n [am__api_version='1.11'\n dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.1], [],\n+m4_if([$1], [1.11.6], [],\n       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n ])\n \n@@ -50,19 +54,21 @@ m4_define([_AM_AUTOCONF_VERSION], [])\n # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+[AM_AUTOMAKE_VERSION([1.11.6])dnl\n m4_ifndef([AC_AUTOCONF_VERSION],\n   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n \n # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n \n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n+# serial 1\n+\n # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n # `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n@@ -283,12 +289,15 @@ for _am_header in $config_headers :; do\n done\n echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n \n-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n+# Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n+# serial 1\n+\n # AM_PROG_INSTALL_SH\n # ------------------\n # Define $install_sh.\n@@ -307,8 +316,8 @@ AC_SUBST(install_sh)])\n # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n # From Jim Meyering\n \n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,\n+# 2011 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -328,7 +337,7 @@ AC_DEFUN([AM_MAINTAINER_MODE],\n        [disable], [m4_define([am_maintainer_other], [enable])],\n        [m4_define([am_maintainer_other], [enable])\n         m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n   dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n   AC_ARG_ENABLE([maintainer-mode],\n [  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n@@ -387,12 +396,15 @@ else\n fi\n ])\n \n-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n+# Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n+# serial 1\n+\n # AM_PROG_MKDIR_P\n # ---------------\n # Check for `mkdir -p'.\n@@ -415,27 +427,28 @@ esac\n \n # Helper functions for option handling.                     -*- Autoconf -*-\n \n-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n+# Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 4\n+# serial 5\n \n # _AM_MANGLE_OPTION(NAME)\n # -----------------------\n AC_DEFUN([_AM_MANGLE_OPTION],\n [[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n \n # _AM_SET_OPTION(NAME)\n-# ------------------------------\n+# --------------------\n # Set option NAME.  Presently that only means defining a flag for this option.\n AC_DEFUN([_AM_SET_OPTION],\n [m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n \n # _AM_SET_OPTIONS(OPTIONS)\n-# ----------------------------------\n+# ------------------------\n # OPTIONS is a space-separated list of Automake options.\n AC_DEFUN([_AM_SET_OPTIONS],\n [m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n@@ -511,12 +524,14 @@ Check your system clock])\n fi\n AC_MSG_RESULT(yes)])\n \n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n+# serial 1\n+\n # AM_PROG_INSTALL_STRIP\n # ---------------------\n # One issue with vendor `install' (even GNU) is that you can't\n@@ -539,13 +554,13 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n \n-# serial 2\n+# serial 3\n \n # _AM_SUBST_NOTMAKE(VARIABLE)\n # ---------------------------\n@@ -554,13 +569,13 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])\n AC_DEFUN([_AM_SUBST_NOTMAKE])\n \n # AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n+# --------------------------\n # Public sister of _AM_SUBST_NOTMAKE.\n AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n \n # Check how to create a tarball.                            -*- Autoconf -*-\n \n-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n #\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n@@ -582,10 +597,11 @@ AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n # a tarball read from stdin.\n #     $(am__untar) < result.tar\n AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.\n-AM_MISSING_PROG([AMTAR], [tar])\n+[# Always define AMTAR for backward compatibility.  Yes, it's still used\n+# in the wild :-(  We should find a proper way to deprecate it ...\n+AC_SUBST([AMTAR], ['$${TAR-tar}'])\n m4_if([$1], [v7],\n-     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n      [m4_case([$1], [ustar],, [pax],,\n               [m4_fatal([Unknown tar format])])\n AC_MSG_CHECKING([how to create a $1 tar archive])"}, {"sha": "ab051a1689826ba57d4bdf8688beb1a643a97e98", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -59,3 +59,8 @@ POSSIBILITY OF SUCH DAMAGE.  */\n    as 0.  */\n \n #define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@\n+\n+/* BACKTRACE_SUPPORTS_DATA will be #defined'd as 1 if the backtrace_syminfo\n+   will work for variables.  It will always work for functions.  */\n+\n+#define BACKTRACE_SUPPORTS_DATA @BACKTRACE_SUPPORTS_DATA@"}, {"sha": "9821e34c0c1ba69c48b98e71b75e46533c8a030e", "filename": "src/libbacktrace/btest.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -616,6 +616,8 @@ f33 (int f1line, int f2line)\n   return failures;\n }\n \n+#if BACKTRACE_SUPPORTS_DATA\n+\n int global = 1;\n \n static int\n@@ -684,6 +686,8 @@ test5 (void)\n   return failures;\n }\n \n+#endif /* BACKTRACE_SUPPORTS_DATA  */\n+\n static void\n error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n \t\t       int errnum)\n@@ -708,7 +712,9 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)\n   test2 ();\n   test3 ();\n   test4 ();\n+#if BACKTRACE_SUPPORTS_DATA\n   test5 ();\n+#endif\n #endif\n \n   exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);"}, {"sha": "d9e8075845f836b93e3d894d614ffa236ebcf38f", "filename": "src/libbacktrace/configure", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -607,6 +607,7 @@ NATIVE_TRUE\n BACKTRACE_USES_MALLOC\n ALLOC_FILE\n VIEW_FILE\n+BACKTRACE_SUPPORTS_DATA\n BACKTRACE_SUPPORTED\n FORMAT_FILE\n BACKTRACE_SUPPORTS_THREADS\n@@ -3973,7 +3974,7 @@ am_lf='\n '\n case `pwd` in\n   *[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]*)\n-    as_fn_error \"unsafe absolute working directory name\" \"$LINENO\" 5;;\n+    as_fn_error \"unsafe absolute working directory name: \\``pwd`'\" \"$LINENO\" 5;;\n esac\n case $srcdir in\n   *[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]*)\n@@ -4326,11 +4327,11 @@ MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n # We need awk for the \"check\" target.  The system \"awk\" is bad on\n # some platforms.\n-# Always define AMTAR for backward compatibility.\n+# Always define AMTAR for backward compatibility.  Yes, it's still used\n+# in the wild :-(  We should find a proper way to deprecate it ...\n+AMTAR='$${TAR-tar}'\n \n-AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n-\n-am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'\n+am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'\n \n \n \n@@ -11129,7 +11130,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11132 \"configure\"\n+#line 11133 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11235,7 +11236,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11238 \"configure\"\n+#line 11239 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11569,6 +11570,12 @@ $as_echo \"$libbacktrace_cv_c_random_seed_string\" >&6; }\n fi\n \n \n+ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n WARN_FLAGS=\n save_CFLAGS=\"$CFLAGS\"\n for real_option in -W -Wall -Wwrite-strings -Wstrict-prototypes \\\n@@ -11615,6 +11622,12 @@ $as_echo \"$ac_res\" >&6; }\n fi\n   done\n CFLAGS=\"$save_CFLAGS\"\n+ac_ext=c\n+ac_cpp='$CPP $CPPFLAGS'\n+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\n+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\n+ac_compiler_gnu=$ac_cv_c_compiler_gnu\n+\n \n \n if test -n \"${with_target_subdir}\"; then\n@@ -11826,8 +11839,12 @@ $as_echo \"$libbacktrace_cv_sys_filetype\" >&6; }\n \n # Match the file type to decide what files to compile.\n FORMAT_FILE=\n+backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+pecoff) FORMAT_FILE=\"pecoff.lo\"\n+        backtrace_supports_data=no\n+\t;;\n *) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: could not determine output file type\" >&5\n $as_echo \"$as_me: WARNING: could not determine output file type\" >&2;}\n    FORMAT_FILE=\"unknown.lo\"\n@@ -11841,6 +11858,7 @@ elfsize=\n case \"$libbacktrace_cv_sys_filetype\" in\n elf32) elfsize=32 ;;\n elf64) elfsize=64 ;;\n+*)     elfsize=unused\n esac\n \n cat >>confdefs.h <<_ACEOF\n@@ -11854,6 +11872,12 @@ if test \"$backtrace_supported\" = \"yes\"; then\n fi\n \n \n+BACKTRACE_SUPPORTS_DATA=0\n+if test \"$backtrace_supports_data\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_DATA=1\n+fi\n+\n+\n \n \n inttype_headers=`echo inttypes.h sys/inttypes.h  | sed -e 's/,/ /g'`\n@@ -12280,6 +12304,12 @@ else\n     # When built as a GCC target library, we can't do a link test.  We\n     # simply assume that if we have mman.h, we have mmap.\n     have_mmap=yes\n+    case \"${host}\" in\n+    spu-*-*)\n+        # The SPU does not have mmap, but it has a sys/mman.h header file\n+        # containing \"mmap_eaddr\" and the mmap flags, confusing the test.\n+\thave_mmap=no ;;\n+    esac\n   else\n     ac_fn_c_check_func \"$LINENO\" \"mmap\" \"ac_cv_func_mmap\"\n if test \"x$ac_cv_func_mmap\" = x\"\"yes; then :"}, {"sha": "a0e487bb42d71fa88cda59a0b16cbf733716cfaa", "filename": "src/libbacktrace/configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -229,8 +229,12 @@ libbacktrace_cv_sys_filetype=$filetype])\n \n # Match the file type to decide what files to compile.\n FORMAT_FILE=\n+backtrace_supports_data=yes\n case \"$libbacktrace_cv_sys_filetype\" in\n elf*) FORMAT_FILE=\"elf.lo\" ;;\n+pecoff) FORMAT_FILE=\"pecoff.lo\"\n+        backtrace_supports_data=no\n+\t;;\n *) AC_MSG_WARN([could not determine output file type])\n    FORMAT_FILE=\"unknown.lo\"\n    backtrace_supported=no\n@@ -243,6 +247,7 @@ elfsize=\n case \"$libbacktrace_cv_sys_filetype\" in\n elf32) elfsize=32 ;;\n elf64) elfsize=64 ;;\n+*)     elfsize=unused\n esac\n AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n \n@@ -252,6 +257,12 @@ if test \"$backtrace_supported\" = \"yes\"; then\n fi\n AC_SUBST(BACKTRACE_SUPPORTED)\n \n+BACKTRACE_SUPPORTS_DATA=0\n+if test \"$backtrace_supports_data\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_DATA=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_DATA)\n+\n GCC_HEADER_STDINT(gstdint.h)\n \n AC_CHECK_HEADERS(sys/mman.h)\n@@ -262,6 +273,12 @@ else\n     # When built as a GCC target library, we can't do a link test.  We\n     # simply assume that if we have mman.h, we have mmap.\n     have_mmap=yes\n+    case \"${host}\" in\n+    spu-*-*)\n+        # The SPU does not have mmap, but it has a sys/mman.h header file\n+        # containing \"mmap_eaddr\" and the mmap flags, confusing the test.\n+\thave_mmap=no ;;\n+    esac\n   else\n     AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n   fi"}, {"sha": "54e5ace9b4a68cc557fcc96dce7477ea01af4a62", "filename": "src/libbacktrace/dwarf.c", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -211,6 +211,10 @@ struct line\n   const char *filename;\n   /* Line number.  */\n   int lineno;\n+  /* Index of the object in the original array read from the DWARF\n+     section, before it has been sorted.  The index makes it possible\n+     to use Quicksort and maintain stability.  */\n+  int idx;\n };\n \n /* A growable vector of line number information.  This is used while\n@@ -940,9 +944,10 @@ unit_addrs_search (const void *vkey, const void *ventry)\n     return 0;\n }\n \n-/* Sort the line vector by PC.  We want a stable sort here.  We know\n-   that the pointers are into the same array, so it is safe to compare\n-   them directly.  */\n+/* Sort the line vector by PC.  We want a stable sort here to maintain\n+   the order of lines for the same PC values.  Since the sequence is\n+   being sorted in place, their addresses cannot be relied on to\n+   maintain stability.  That is the purpose of the index member.  */\n \n static int\n line_compare (const void *v1, const void *v2)\n@@ -954,9 +959,9 @@ line_compare (const void *v1, const void *v2)\n     return -1;\n   else if (ln1->pc > ln2->pc)\n     return 1;\n-  else if (ln1 < ln2)\n+  else if (ln1->idx < ln2->idx)\n     return -1;\n-  else if (ln1 > ln2)\n+  else if (ln1->idx > ln2->idx)\n     return 1;\n   else\n     return 0;\n@@ -1551,6 +1556,7 @@ add_line (struct backtrace_state *state, struct dwarf_data *ddata,\n \n   ln->filename = filename;\n   ln->lineno = lineno;\n+  ln->idx = vec->count;\n \n   ++vec->count;\n \n@@ -2011,6 +2017,7 @@ read_line_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   ln->pc = (uintptr_t) -1;\n   ln->filename = NULL;\n   ln->lineno = 0;\n+  ln->idx = 0;\n \n   if (!backtrace_vector_release (state, &vec.vec, error_callback, data))\n     goto fail;\n@@ -2243,14 +2250,16 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t     struct unit *u, uint64_t base, struct dwarf_buf *unit_buf,\n \t\t     const struct line_header *lhdr,\n \t\t     backtrace_error_callback error_callback, void *data,\n-\t\t     struct function_vector *vec)\n+\t\t     struct function_vector *vec_function,\n+\t\t     struct function_vector *vec_inlined)\n {\n   while (unit_buf->left > 0)\n     {\n       uint64_t code;\n       const struct abbrev *abbrev;\n       int is_function;\n       struct function *function;\n+      struct function_vector *vec;\n       size_t i;\n       uint64_t lowpc;\n       int have_lowpc;\n@@ -2272,6 +2281,11 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t\t     || abbrev->tag == DW_TAG_entry_point\n \t\t     || abbrev->tag == DW_TAG_inlined_subroutine);\n \n+      if (abbrev->tag == DW_TAG_inlined_subroutine)\n+\tvec = vec_inlined;\n+      else\n+\tvec = vec_function;\n+\n       function = NULL;\n       if (is_function)\n \t{\n@@ -2451,7 +2465,8 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t  if (!is_function)\n \t    {\n \t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n-\t\t\t\t\terror_callback, data, vec))\n+\t\t\t\t\terror_callback, data, vec_function,\n+\t\t\t\t\tvec_inlined))\n \t\treturn 0;\n \t    }\n \t  else\n@@ -2464,7 +2479,8 @@ read_function_entry (struct backtrace_state *state, struct dwarf_data *ddata,\n \t      memset (&fvec, 0, sizeof fvec);\n \n \t      if (!read_function_entry (state, ddata, u, base, unit_buf, lhdr,\n-\t\t\t\t\terror_callback, data, &fvec))\n+\t\t\t\t\terror_callback, data, vec_function,\n+\t\t\t\t\t&fvec))\n \t\treturn 0;\n \n \t      if (fvec.count > 0)\n@@ -2528,7 +2544,7 @@ read_function_info (struct backtrace_state *state, struct dwarf_data *ddata,\n   while (unit_buf.left > 0)\n     {\n       if (!read_function_entry (state, ddata, u, 0, &unit_buf, lhdr,\n-\t\t\t\terror_callback, data, pfvec))\n+\t\t\t\terror_callback, data, pfvec, pfvec))\n \treturn;\n     }\n "}, {"sha": "57bab797a9a8abc1a1310ec077786f499775cfaa", "filename": "src/libbacktrace/filetype.awk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -1,3 +1,5 @@\n # An awk script to determine the type of a file.\n /\\177ELF\\001/ { if (NR == 1) { print \"elf32\"; exit } }\n /\\177ELF\\002/ { if (NR == 1) { print \"elf64\"; exit } }\n+/\\114\\001/    { if (NR == 1) { print \"pecoff\"; exit } }\n+/\\144\\206/    { if (NR == 1) { print \"pecoff\"; exit } }"}, {"sha": "ba555b56582804ccf1dc6da0e3ceb24a1dd6d29d", "filename": "src/libbacktrace/pecoff.c", "status": "added", "additions": 937, "deletions": 0, "changes": 937, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fpecoff.c", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fpecoff.c?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -0,0 +1,937 @@\n+/* pecoff.c -- Get debug data from a PE/COFFF file for backtraces.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Adapted from elf.c by Tristan Gingold, AdaCore.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Coff file header.  */\n+\n+typedef struct {\n+  uint16_t machine;\n+  uint16_t number_of_sections;\n+  uint32_t time_date_stamp;\n+  uint32_t pointer_to_symbol_table;\n+  uint32_t number_of_symbols;\n+  uint16_t size_of_optional_header;\n+  uint16_t characteristics;\n+} b_coff_file_header;\n+\n+/* Coff optional header.  */\n+\n+typedef struct {\n+  uint16_t magic;\n+  uint8_t  major_linker_version;\n+  uint8_t  minor_linker_version;\n+  uint32_t size_of_code;\n+  uint32_t size_of_initialized_data;\n+  uint32_t size_of_uninitialized_data;\n+  uint32_t address_of_entry_point;\n+  uint32_t base_of_code;\n+  union {\n+    struct {\n+      uint32_t base_of_data;\n+      uint32_t image_base;\n+    } pe;\n+    struct {\n+      uint64_t image_base;\n+    } pep;\n+  } u;\n+} b_coff_optional_header;\n+\n+/* Values of magic in optional header.  */\n+\n+#define PE_MAGIC 0x10b\t\t/* PE32 executable.  */\n+#define PEP_MAGIC 0x20b\t\t/* PE32+ executable (for 64bit targets).  */\n+\n+/* Coff section header.  */\n+\n+typedef struct {\n+  char name[8];\n+  uint32_t virtual_size;\n+  uint32_t virtual_address;\n+  uint32_t size_of_raw_data;\n+  uint32_t pointer_to_raw_data;\n+  uint32_t pointer_to_relocations;\n+  uint32_t pointer_to_line_numbers;\n+  uint16_t number_of_relocations;\n+  uint16_t number_of_line_numbers;\n+  uint32_t characteristics;\n+} b_coff_section_header;\n+\n+/* Coff symbol name.  */\n+\n+typedef union {\n+  char short_name[8];\n+  struct {\n+    unsigned char zeroes[4];\n+    unsigned char off[4];\n+  } long_name;\n+} b_coff_name;\n+\n+/* Coff symbol (external representation which is unaligned).  */\n+\n+typedef struct {\n+  b_coff_name name;\n+  unsigned char value[4];\n+  unsigned char section_number[2];\n+  unsigned char type[2];\n+  unsigned char storage_class;\n+  unsigned char number_of_aux_symbols;\n+} b_coff_external_symbol;\n+\n+/* Symbol types.  */\n+\n+#define N_TBSHFT 4\t\t\t/* Shift for the derived type.  */\n+#define IMAGE_SYM_DTYPE_FUNCTION 2\t/* Function derived type.  */\n+\n+/* Size of a coff symbol.  */\n+\n+#define SYM_SZ 18\n+\n+/* Coff symbol, internal representation (aligned).  */\n+\n+typedef struct {\n+  const char *name;\n+  uint32_t value;\n+  int16_t sec;\n+  uint16_t type;\n+  uint16_t sc;\n+} b_coff_internal_symbol;\n+\n+/* An index of sections we care about.  */\n+\n+enum debug_section\n+{\n+  DEBUG_INFO,\n+  DEBUG_LINE,\n+  DEBUG_ABBREV,\n+  DEBUG_RANGES,\n+  DEBUG_STR,\n+  DEBUG_MAX\n+};\n+\n+/* Names of sections, indexed by enum debug_section.  */\n+\n+static const char * const debug_section_names[DEBUG_MAX] =\n+{\n+  \".debug_info\",\n+  \".debug_line\",\n+  \".debug_abbrev\",\n+  \".debug_ranges\",\n+  \".debug_str\"\n+};\n+\n+/* Information we gather for the sections we care about.  */\n+\n+struct debug_section_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n+\n+/* Information we keep for an coff symbol.  */\n+\n+struct coff_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+};\n+\n+/* Information to pass to coff_syminfo.  */\n+\n+struct coff_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct coff_syminfo_data *next;\n+  /* The COFF symbols, sorted by address.  */\n+  struct coff_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+coff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in PE/COFF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+coff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t     uintptr_t addr ATTRIBUTE_UNUSED,\n+\t     backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in PE/COFF executable\", -1);\n+}\n+\n+/* Read a potentially unaligned 4 byte word at P, using native endianness.  */\n+\n+static uint32_t\n+coff_read4 (const unsigned char *p)\n+{\n+  uint32_t res;\n+\n+  memcpy (&res, p, 4);\n+  return res;\n+}\n+\n+/* Read a potentially unaligned 2 byte word at P, using native endianness.\n+   All 2 byte word in symbols are always aligned, but for coherency all\n+   fields are declared as char arrays.  */\n+\n+static uint16_t\n+coff_read2 (const unsigned char *p)\n+{\n+  uint16_t res;\n+\n+  memcpy (&res, p, sizeof (res));\n+  return res;\n+}\n+\n+/* Return the length (without the trailing 0) of a COFF short name.  */\n+\n+static size_t\n+coff_short_name_len (const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    if (name[i] == 0)\n+      return i;\n+  return 8;\n+}\n+\n+/* Return true iff COFF short name CNAME is the same as NAME (a NUL-terminated\n+   string).  */\n+\n+static int\n+coff_short_name_eq (const char *name, const char *cname)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      if (name[i] != cname[i])\n+\treturn 0;\n+      if (name[i] == 0)\n+\treturn 1;\n+    }\n+  return name[8] == 0;\n+}\n+\n+/* Return true iff NAME is the same as string at offset OFF.  */\n+\n+static int\n+coff_long_name_eq (const char *name, unsigned int off,\n+\t\t   struct backtrace_view *str_view)\n+{\n+  if (off >= str_view->len)\n+    return 0;\n+  return strcmp (name, (const char *)str_view->data + off) == 0;\n+}\n+\n+/* Compare struct coff_symbol for qsort.  */\n+\n+static int\n+coff_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct coff_symbol *e1 = (const struct coff_symbol *) v1;\n+  const struct coff_symbol *e2 = (const struct coff_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Convert SYM to internal (and aligned) format ISYM, using string table\n+   from STRTAB and STRTAB_SIZE, and number of sections SECTS_NUM.\n+   Return -1 in case of error (invalid section number or string index).  */\n+\n+static int\n+coff_expand_symbol (b_coff_internal_symbol *isym,\n+\t\t    const b_coff_external_symbol *sym,\n+\t\t    uint16_t sects_num,\n+\t\t    const unsigned char *strtab, size_t strtab_size)\n+{\n+  isym->type = coff_read2 (sym->type);\n+  isym->sec = coff_read2 (sym->section_number);\n+  isym->sc = sym->storage_class;\n+\n+  if (isym->sec > 0 && (uint16_t) isym->sec > sects_num)\n+    return -1;\n+  if (sym->name.short_name[0] != 0)\n+    isym->name = sym->name.short_name;\n+  else\n+    {\n+      uint32_t off = coff_read4 (sym->name.long_name.off);\n+\n+      if (off >= strtab_size)\n+\treturn -1;\n+      isym->name = (const char *) strtab + off;\n+    }\n+  return 0;\n+}\n+\n+/* Return true iff SYM is a defined symbol for a function.  Data symbols\n+   aren't considered because they aren't easily identified (same type as\n+   section names, presence of symbols defined by the linker script).  */\n+\n+static int\n+coff_is_function_symbol (const b_coff_internal_symbol *isym)\n+{\n+  return (isym->type >> N_TBSHFT) == IMAGE_SYM_DTYPE_FUNCTION\n+    && isym->sec > 0;\n+}\n+\n+/* Initialize the symbol table info for coff_syminfo.  */\n+\n+static int\n+coff_initialize_syminfo (struct backtrace_state *state,\n+\t\t\t uintptr_t base_address,\n+\t\t\t const b_coff_section_header *sects, size_t sects_num,\n+\t\t\t const b_coff_external_symbol *syms, size_t syms_size,\n+\t\t\t const unsigned char *strtab, size_t strtab_size,\n+\t\t\t backtrace_error_callback error_callback,\n+\t\t\t void *data, struct coff_syminfo_data *sdata)\n+{\n+  size_t syms_count;\n+  char *coff_symstr;\n+  size_t coff_symstr_len;\n+  size_t coff_symbol_count;\n+  size_t coff_symbol_size;\n+  struct coff_symbol *coff_symbols;\n+  struct coff_symbol *coff_sym;\n+  char *coff_str;\n+  size_t i;\n+\n+  syms_count = syms_size / SYM_SZ;\n+\n+  /* We only care about function symbols.  Count them.  Also count size of\n+     strings for in-symbol names.  */\n+  coff_symbol_count = 0;\n+  coff_symstr_len = 0;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size) < 0)\n+\t{\n+\t  error_callback (data, \"invalid section or offset in coff symbol\", 0);\n+\t  return 0;\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  ++coff_symbol_count;\n+\t  if (asym->name.short_name[0] != 0)\n+\t    coff_symstr_len += coff_short_name_len (asym->name.short_name) + 1;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  coff_symbol_size = (coff_symbol_count + 1) * sizeof (struct coff_symbol);\n+  coff_symbols = ((struct coff_symbol *)\n+\t\t  backtrace_alloc (state, coff_symbol_size, error_callback,\n+\t\t\t\t   data));\n+  if (coff_symbols == NULL)\n+    return 0;\n+\n+  /* Allocate memory for symbols strings.  */\n+  if (coff_symstr_len > 0)\n+    {\n+      coff_symstr = ((char *)\n+\t\t     backtrace_alloc (state, coff_symstr_len, error_callback,\n+\t\t\t\t      data));\n+      if (coff_symstr == NULL)\n+\t{\n+\t  backtrace_free (state, coff_symbols, coff_symbol_size,\n+\t\t\t  error_callback, data);\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    coff_symstr = NULL;\n+\n+  /* Copy symbols.  */\n+  coff_sym = coff_symbols;\n+  coff_str = coff_symstr;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size))\n+\t{\n+\t  /* Should not fail, as it was already tested in the previous\n+\t     loop.  */\n+\t  abort ();\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  const char *name;\n+\t  int16_t secnum;\n+\n+\t  if (asym->name.short_name[0] != 0)\n+\t    {\n+\t      size_t len = coff_short_name_len (isym.name);\n+\t      name = coff_str;\n+\t      memcpy (coff_str, isym.name, len);\n+\t      coff_str[len] = 0;\n+\t      coff_str += len + 1;\n+\t    }\n+\t  else\n+\t    name = isym.name;\n+\n+\t  /* Strip leading '_'.  */\n+\t  if (name[0] == '_')\n+\t    name++;\n+\n+\t  /* Symbol value is section relative, so we need to read the address\n+\t     of its section.  */\n+\t  secnum = coff_read2 (asym->section_number);\n+\n+\t  coff_sym->name = name;\n+\t  coff_sym->address = (coff_read4 (asym->value)\n+\t\t\t       + sects[secnum - 1].virtual_address\n+\t\t\t       + base_address);\n+\t  coff_sym++;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  /* End of symbols marker.  */\n+  coff_sym->name = NULL;\n+  coff_sym->address = -1;\n+\n+  backtrace_qsort (coff_symbols, coff_symbol_count,\n+\t\t   sizeof (struct coff_symbol), coff_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = coff_symbols;\n+  sdata->count = coff_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Add EDATA to the list in STATE.  */\n+\n+static void\n+coff_add_syminfo_data (struct backtrace_state *state,\n+\t\t       struct coff_syminfo_data *sdata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      for (pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = sdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct coff_syminfo_data **pp;\n+\n+\t  pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct coff_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n+   extra entry in the array so that this can look safely at the next\n+   entry.  */\n+\n+static int\n+coff_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct coff_symbol *entry = (const struct coff_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (addr >= entry[1].address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+coff_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t      backtrace_syminfo_callback callback,\n+\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t      void *data)\n+{\n+  struct coff_syminfo_data *sdata;\n+  struct coff_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (sdata = (struct coff_syminfo_data *) state->syminfo_data;\n+\t   sdata != NULL;\n+\t   sdata = sdata->next)\n+\t{\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  sdata = backtrace_atomic_load_pointer (pp);\n+\t  if (sdata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &sdata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, 0);\n+}\n+\n+/* Add the backtrace data for one PE/COFF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+coff_add (struct backtrace_state *state, int descriptor,\n+\t  backtrace_error_callback error_callback, void *data,\n+\t  fileline *fileline_fn, int *found_sym, int *found_dwarf)\n+{\n+  struct backtrace_view fhdr_view;\n+  off_t fhdr_off;\n+  int magic_ok;\n+  b_coff_file_header fhdr;\n+  off_t opt_sects_off;\n+  size_t opt_sects_size;\n+  unsigned int sects_num;\n+  struct backtrace_view sects_view;\n+  int sects_view_valid;\n+  const b_coff_optional_header *opt_hdr;\n+  const b_coff_section_header *sects;\n+  struct backtrace_view str_view;\n+  int str_view_valid;\n+  size_t str_size;\n+  off_t str_off;\n+  struct backtrace_view syms_view;\n+  off_t syms_off;\n+  size_t syms_size;\n+  int syms_view_valid;\n+  unsigned int syms_num;\n+  unsigned int i;\n+  struct debug_section_info sections[DEBUG_MAX];\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct backtrace_view debug_view;\n+  int debug_view_valid;\n+  uintptr_t image_base;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  sects_view_valid = 0;\n+  syms_view_valid = 0;\n+  str_view_valid = 0;\n+  debug_view_valid = 0;\n+\n+  /* Map the MS-DOS stub (if any) and extract file header offset.  */\n+  if (!backtrace_get_view (state, descriptor, 0, 0x40, error_callback,\n+\t\t\t   data, &fhdr_view))\n+    goto fail;\n+\n+  {\n+    const char *vptr = (const char *)fhdr_view.data;\n+\n+    if (vptr[0] == 'M' && vptr[1] == 'Z')\n+      memcpy (&fhdr_off, vptr + 0x3c, 4);\n+    else\n+      fhdr_off = 0;\n+  }\n+\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  /* Map the coff file header.  */\n+  if (!backtrace_get_view (state, descriptor, fhdr_off,\n+\t\t\t   sizeof (b_coff_file_header) + 4,\n+\t\t\t   error_callback, data, &fhdr_view))\n+    goto fail;\n+\n+  if (fhdr_off != 0)\n+    {\n+      const char *magic = (const char *) fhdr_view.data;\n+      magic_ok = memcmp (magic, \"PE\\0\", 4) == 0;\n+      fhdr_off += 4;\n+\n+      memcpy (&fhdr, fhdr_view.data + 4, sizeof fhdr);\n+    }\n+  else\n+    {\n+      memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n+      /* TODO: test fhdr.machine for coff but non-PE platforms.  */\n+      magic_ok = 0;\n+    }\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  if (!magic_ok)\n+    {\n+      error_callback (data, \"executable file is not COFF\", 0);\n+      goto fail;\n+    }\n+\n+  sects_num = fhdr.number_of_sections;\n+  syms_num = fhdr.number_of_symbols;\n+\n+  opt_sects_off = fhdr_off + sizeof (fhdr);\n+  opt_sects_size = (fhdr.size_of_optional_header\n+\t\t    + sects_num * sizeof (b_coff_section_header));\n+\n+  /* To translate PC to file/line when using DWARF, we need to find\n+     the .debug_info and .debug_line sections.  */\n+\n+  /* Read the optional header and the section headers.  */\n+\n+  if (!backtrace_get_view (state, descriptor, opt_sects_off, opt_sects_size,\n+\t\t\t   error_callback, data, &sects_view))\n+    goto fail;\n+  sects_view_valid = 1;\n+  opt_hdr = (const b_coff_optional_header *) sects_view.data;\n+  sects = (const b_coff_section_header *)\n+    (sects_view.data + fhdr.size_of_optional_header);\n+\n+  if (fhdr.size_of_optional_header > sizeof (*opt_hdr))\n+    {\n+      if (opt_hdr->magic == PE_MAGIC)\n+\timage_base = opt_hdr->u.pe.image_base;\n+      else if (opt_hdr->magic == PEP_MAGIC)\n+\timage_base = opt_hdr->u.pep.image_base;\n+      else\n+\t{\n+\t  error_callback (data, \"bad magic in PE optional header\", 0);\n+\t  goto fail;\n+\t}\n+    }\n+  else\n+    image_base = 0;\n+\n+  /* Read the symbol table and the string table.  */\n+\n+  if (fhdr.pointer_to_symbol_table == 0)\n+    {\n+      /* No symbol table, no string table.  */\n+      str_off = 0;\n+      str_size = 0;\n+      syms_num = 0;\n+      syms_size = 0;\n+    }\n+  else\n+    {\n+      /* Symbol table is followed by the string table.  The string table\n+\t starts with its length (on 4 bytes).\n+\t Map the symbol table and the length of the string table.  */\n+      syms_off = fhdr.pointer_to_symbol_table;\n+      syms_size = syms_num * SYM_SZ;\n+\n+      if (!backtrace_get_view (state, descriptor, syms_off, syms_size + 4,\n+\t\t\t       error_callback, data, &syms_view))\n+\tgoto fail;\n+      syms_view_valid = 1;\n+\n+      memcpy (&str_size, syms_view.data + syms_size, 4);\n+\n+      str_off = syms_off + syms_size;\n+\n+      if (str_size > 4)\n+\t{\n+\t  /* Map string table (including the length word).  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, str_off, str_size,\n+\t\t\t\t   error_callback, data, &str_view))\n+\t    goto fail;\n+\t  str_view_valid = 1;\n+\t}\n+    }\n+\n+  memset (sections, 0, sizeof sections);\n+\n+  /* Look for the symbol table.  */\n+  for (i = 0; i < sects_num; ++i)\n+    {\n+      const b_coff_section_header *s = sects + i;\n+      unsigned int str_off;\n+      int j;\n+\n+      if (s->name[0] == '/')\n+\t{\n+\t  /* Extended section name.  */\n+\t  str_off = atoi (s->name + 1);\n+\t}\n+      else\n+\tstr_off = 0;\n+\n+      for (j = 0; j < (int) DEBUG_MAX; ++j)\n+\t{\n+\t  const char *dbg_name = debug_section_names[j];\n+\t  int match;\n+\n+\t  if (str_off != 0)\n+\t    match = coff_long_name_eq (dbg_name, str_off, &str_view);\n+\t  else\n+\t    match = coff_short_name_eq (dbg_name, s->name);\n+\t  if (match)\n+\t    {\n+\t      sections[j].offset = s->pointer_to_raw_data;\n+\t      sections[j].size = s->virtual_size <= s->size_of_raw_data ?\n+\t\ts->virtual_size : s->size_of_raw_data;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (syms_num != 0)\n+    {\n+      struct coff_syminfo_data *sdata;\n+\n+      sdata = ((struct coff_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!coff_initialize_syminfo (state, image_base,\n+\t\t\t\t    sects, sects_num,\n+\t\t\t\t    syms_view.data, syms_size,\n+\t\t\t\t    str_view.data, str_size,\n+\t\t\t\t    error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      *found_sym = 1;\n+\n+      coff_add_syminfo_data (state, sdata);\n+    }\n+\n+  backtrace_release_view (state, &sects_view, error_callback, data);\n+  sects_view_valid = 0;\n+  backtrace_release_view (state, &syms_view, error_callback, data);\n+  syms_view_valid = 0;\n+\n+  /* Read all the debug sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      off_t end;\n+\n+      if (sections[i].size == 0)\n+\tcontinue;\n+      if (min_offset == 0 || sections[i].offset < min_offset)\n+\tmin_offset = sections[i].offset;\n+      end = sections[i].offset + sections[i].size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+    }\n+  if (min_offset == 0 || max_offset == 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      *fileline_fn = coff_nodebug;\n+      return 1;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, min_offset,\n+\t\t\t   max_offset - min_offset,\n+\t\t\t   error_callback, data, &debug_view))\n+    goto fail;\n+  debug_view_valid = 1;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      if (sections[i].size == 0)\n+\tsections[i].data = NULL;\n+      else\n+\tsections[i].data = ((const unsigned char *) debug_view.data\n+\t\t\t    + (sections[i].offset - min_offset));\n+    }\n+\n+  if (!backtrace_dwarf_add (state, /* base_address */ 0,\n+\t\t\t    sections[DEBUG_INFO].data,\n+\t\t\t    sections[DEBUG_INFO].size,\n+\t\t\t    sections[DEBUG_LINE].data,\n+\t\t\t    sections[DEBUG_LINE].size,\n+\t\t\t    sections[DEBUG_ABBREV].data,\n+\t\t\t    sections[DEBUG_ABBREV].size,\n+\t\t\t    sections[DEBUG_RANGES].data,\n+\t\t\t    sections[DEBUG_RANGES].size,\n+\t\t\t    sections[DEBUG_STR].data,\n+\t\t\t    sections[DEBUG_STR].size,\n+\t\t\t    0, /* FIXME */\n+\t\t\t    error_callback, data, fileline_fn))\n+    goto fail;\n+\n+  *found_dwarf = 1;\n+\n+  return 1;\n+\n+ fail:\n+  if (sects_view_valid)\n+    backtrace_release_view (state, &sects_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  if (debug_view_valid)\n+    backtrace_release_view (state, &debug_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  int found_dwarf;\n+  fileline coff_fileline_fn;\n+\n+  ret = coff_add (state, descriptor, error_callback, data,\n+\t\t  &coff_fileline_fn, &found_sym, &found_dwarf);\n+  if (!ret)\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = coff_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = coff_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, coff_syminfo);\n+      else\n+\t__sync_bool_compare_and_swap (&state->syminfo_fn, NULL, coff_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+\n+  return 1;\n+}"}, {"sha": "7845714e7f6471acf03b35058faa4e7d698acfb8", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -8,16 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io::prelude::*;\n-\n use io;\n+use io::prelude::*;\n+use str;\n+use libc;\n \n #[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: usize = 18;\n \n #[cfg(target_pointer_width = \"32\")]\n pub const HEX_WIDTH: usize = 10;\n \n+\n+// These output functions should now be used everywhere to ensure consistency.\n+pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n+              s: Option<&[u8]>) -> io::Result<()> {\n+    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n+    match s.and_then(|s| str::from_utf8(s).ok()) {\n+        Some(string) => try!(demangle(w, string)),\n+        None => try!(write!(w, \"<unknown>\")),\n+    }\n+    w.write_all(&['\\n' as u8])\n+}\n+\n+#[allow(dead_code)]\n+pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n+                       more: bool) -> io::Result<()> {\n+    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n+    // prior line: \"  ##: {:2$} - func\"\n+    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n+    if more {\n+        try!(write!(w, \" <... and possibly more>\"));\n+    }\n+    w.write_all(&['\\n' as u8])\n+}\n+\n+\n // All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n // assemblers, however, can't handle these characters in symbol names. To get\n // around this, we use C++-style mangling. The mangling method is:"}, {"sha": "7a2ca0a9f097d99249fc25bcadd929a3b32dc8a1", "filename": "src/libstd/sys/common/gnu/libbacktrace.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -11,13 +11,12 @@\n use io;\n use io::prelude::*;\n use libc;\n+use sys_common::backtrace::{output, output_fileline};\n \n-use sys::backtrace::{output, output_fileline};\n pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n              symaddr: *mut libc::c_void) -> io::Result<()> {\n     use env;\n     use ffi::CStr;\n-    use os::unix::prelude::*;\n     use ptr;\n \n     ////////////////////////////////////////////////////////////////////////\n@@ -129,14 +128,15 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n         let selfname = if cfg!(target_os = \"freebsd\") ||\n             cfg!(target_os = \"dragonfly\") ||\n             cfg!(target_os = \"bitrig\") ||\n-            cfg!(target_os = \"openbsd\") {\n+            cfg!(target_os = \"openbsd\") ||\n+            cfg!(target_os = \"windows\") {\n                 env::current_exe().ok()\n             } else {\n                 None\n             };\n-        let filename = match selfname {\n+        let filename = match selfname.as_ref().and_then(|s| s.as_os_str().to_bytes()) {\n             Some(path) => {\n-                let bytes = path.as_os_str().as_bytes();\n+                let bytes = path;\n                 if bytes.len() < LAST_FILENAME.len() {\n                     let i = bytes.iter();\n                     for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {", "previous_filename": "src/libstd/sys/unix/backtrace/printing/libbacktrace.rs"}, {"sha": "3a8cf2d84259173af8317ef21e96261c437cfec4", "filename": "src/libstd/sys/common/gnu/mod.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Fmod.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_docs)]\n+#![allow(non_camel_case_types)]\n+#![allow(non_snake_case)]\n+\n+pub mod libbacktrace;"}, {"sha": "b8074235fb2a5f041e8f1d39b89991a1428e7211", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -23,6 +23,10 @@ pub mod thread_info;\n pub mod thread_local;\n pub mod wtf8;\n \n+#[cfg(any(all(unix, not(any(target_os = \"macos\", target_os = \"ios\"))),\n+          all(windows, target_env = \"gnu\")))]\n+pub mod gnu;\n+\n // common error constructors\n \n /// A trait for viewing representations from std types"}, {"sha": "d7c05e513f68c2704d3f849c2ee97d08699c9acd", "filename": "src/libstd/sys/unix/backtrace/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fmod.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -85,36 +85,7 @@\n \n pub use self::tracing::write;\n \n-use io;\n-use io::prelude::*;\n-use libc;\n-use str;\n-\n-use sys_common::backtrace::{demangle, HEX_WIDTH};\n-\n // tracing impls:\n mod tracing;\n // symbol resolvers:\n mod printing;\n-\n-pub fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n-              s: Option<&[u8]>) -> io::Result<()> {\n-    try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n-    match s.and_then(|s| str::from_utf8(s).ok()) {\n-        Some(string) => try!(demangle(w, string)),\n-        None => try!(write!(w, \"<unknown>\")),\n-    }\n-    w.write_all(&['\\n' as u8])\n-}\n-\n-#[allow(dead_code)]\n-pub fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n-                       more: bool) -> io::Result<()> {\n-    let file = str::from_utf8(file).unwrap_or(\"<unknown>\");\n-    // prior line: \"  ##: {:2$} - func\"\n-    try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));\n-    if more {\n-        try!(write!(w, \" <... and possibly more>\"));\n-    }\n-    w.write_all(&['\\n' as u8])\n-}"}, {"sha": "d9b759dc673948351b0e7b33b64d158879979b9e", "filename": "src/libstd/sys/unix/backtrace/printing/dladdr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -14,7 +14,7 @@ use libc;\n \n pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n              _symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use sys::backtrace::{output};\n+    use sys_common::backtrace::{output};\n     use intrinsics;\n     use ffi::CStr;\n "}, {"sha": "fb06fbedaf57b3f2537da0a180c878d5273f46d4", "filename": "src/libstd/sys/unix/backtrace/printing/gnu.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fgnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fgnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fgnu.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::gnu::libbacktrace::print;"}, {"sha": "e09832c231e7a176b5b24df04609c68bdb683ff1", "filename": "src/libstd/sys/unix/backtrace/printing/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace%2Fprinting%2Fmod.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::imp::*;\n+pub use self::imp::print;\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n #[path = \"dladdr.rs\"]\n mod imp;\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-#[path = \"libbacktrace.rs\"]\n+#[path = \"gnu.rs\"]\n mod imp;"}, {"sha": "35e3c1d4663e01ff5f339f5d4d2654565169470f", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -27,17 +27,28 @@\n use io::prelude::*;\n \n use dynamic_lib::DynamicLibrary;\n-use ffi::CStr;\n use intrinsics;\n use io;\n use libc;\n-use mem;\n use path::Path;\n use ptr;\n-use str;\n use sync::StaticMutex;\n \n-use sys_common::backtrace::*;\n+macro_rules! sym{ ($lib:expr, $e:expr, $t:ident) => (unsafe {\n+    let lib = $lib;\n+    match lib.symbol($e) {\n+        Ok(f) => $crate::mem::transmute::<*mut u8, $t>(f),\n+        Err(..) => return Ok(())\n+    }\n+}) }\n+\n+#[cfg(target_env = \"msvc\")]\n+#[path = \"printing/msvc.rs\"]\n+mod printing;\n+\n+#[cfg(target_env = \"gnu\")]\n+#[path = \"printing/gnu.rs\"]\n+mod printing;\n \n #[allow(non_snake_case)]\n extern \"system\" {\n@@ -302,23 +313,15 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     // Open up dbghelp.dll, we don't link to it explicitly because it can't\n     // always be found. Additionally, it's nice having fewer dependencies.\n     let path = Path::new(\"dbghelp.dll\");\n-    let lib = match DynamicLibrary::open(Some(&path)) {\n+    let dbghelp = match DynamicLibrary::open(Some(&path)) {\n         Ok(lib) => lib,\n         Err(..) => return Ok(()),\n     };\n \n-    macro_rules! sym{ ($e:expr, $t:ident) => (unsafe {\n-        match lib.symbol($e) {\n-            Ok(f) => mem::transmute::<*mut u8, $t>(f),\n-            Err(..) => return Ok(())\n-        }\n-    }) }\n-\n     // Fetch the symbols necessary from dbghelp.dll\n-    let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n-    let SymInitialize = sym!(\"SymInitialize\", SymInitializeFn);\n-    let SymCleanup = sym!(\"SymCleanup\", SymCleanupFn);\n-    let StackWalk64 = sym!(\"StackWalk64\", StackWalk64Fn);\n+    let SymInitialize = sym!(&dbghelp, \"SymInitialize\", SymInitializeFn);\n+    let SymCleanup = sym!(&dbghelp, \"SymCleanup\", SymCleanupFn);\n+    let StackWalk64 = sym!(&dbghelp, \"StackWalk64\", StackWalk64Fn);\n \n     // Allocate necessary structures for doing the stack walk\n     let process = unsafe { GetCurrentProcess() };\n@@ -334,7 +337,9 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n     let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n     // And now that we're done with all the setup, do the stack walking!\n-    let mut i = 0;\n+    // Start from -1 to avoid printing this stack frame, which will\n+    // always be exactly the same.\n+    let mut i = -1;\n     try!(write!(w, \"stack backtrace:\\n\"));\n     while StackWalk64(image, process, thread, &mut frame, &mut context,\n                       ptr::null_mut(),\n@@ -346,28 +351,10 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n            frame.AddrReturn.Offset == 0 { break }\n \n         i += 1;\n-        try!(write!(w, \"  {:2}: {:#2$x}\", i, addr, HEX_WIDTH));\n-        let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n-        info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n-        // the struct size in C.  the value is different to\n-        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-        // due to struct alignment.\n-        info.SizeOfStruct = 88;\n-\n-        let mut displacement = 0u64;\n-        let ret = SymFromAddr(process, addr as u64, &mut displacement,\n-                              &mut info);\n-\n-        if ret == libc::TRUE {\n-            try!(write!(w, \" - \"));\n-            let ptr = info.Name.as_ptr() as *const libc::c_char;\n-            let bytes = unsafe { CStr::from_ptr(ptr).to_bytes() };\n-            match str::from_utf8(bytes) {\n-                Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write_all(&bytes[..bytes.len()-1])),\n-            }\n+\n+        if i >= 0 {\n+            try!(printing::print(w, i, addr-1, &dbghelp, process));\n         }\n-        try!(w.write_all(&['\\n' as u8]));\n     }\n \n     Ok(())"}, {"sha": "8d3c93bb7b17605da002284176104d516c525b31", "filename": "src/libstd/sys/windows/printing/gnu.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fgnu.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dynamic_lib::DynamicLibrary;\n+use io;\n+use io::prelude::*;\n+use libc;\n+\n+use sys_common::gnu::libbacktrace;\n+\n+pub fn print(w: &mut Write, i: isize, addr: u64, _: &DynamicLibrary, _: libc::HANDLE)\n+        -> io::Result<()> {\n+    let addr = addr as usize as *mut libc::c_void;\n+    libbacktrace::print(w, i, addr, addr)\n+}"}, {"sha": "25cef04ca969b8f2d85b23a1fbf7d1a14c0f4540", "filename": "src/libstd/sys/windows/printing/msvc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprinting%2Fmsvc.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use sys_common::backtrace::output;\n+use ffi::CStr;\n+use dynamic_lib::DynamicLibrary;\n+use super::{SymFromAddrFn, SYMBOL_INFO, MAX_SYM_NAME};\n+use io;\n+use io::prelude::*;\n+use intrinsics;\n+use libc;\n+\n+pub fn print(w: &mut Write, i: isize, addr: u64, dbghelp: &DynamicLibrary, process: libc::HANDLE)\n+        -> io::Result<()> {\n+    let SymFromAddr = sym!(dbghelp, \"SymFromAddr\", SymFromAddrFn);\n+\n+    let mut info: SYMBOL_INFO = unsafe { intrinsics::init() };\n+    info.MaxNameLen = MAX_SYM_NAME as libc::c_ulong;\n+    // the struct size in C.  the value is different to\n+    // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+    // due to struct alignment.\n+    info.SizeOfStruct = 88;\n+\n+    let mut displacement = 0u64;\n+    let ret = SymFromAddr(process, addr as u64, &mut displacement, &mut info);\n+\n+    let name = if ret == libc::TRUE {\n+        let ptr = info.Name.as_ptr() as *const libc::c_char;\n+        Some(unsafe { CStr::from_ptr(ptr).to_bytes() })\n+    } else {\n+        None\n+    };\n+\n+    output(w, i, addr as usize as *mut libc::c_void, name)\n+}"}, {"sha": "5feca9422f656c36d963d8aaf38f2d864aa37775", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -27,11 +27,12 @@ macro_rules! pos {\n     () => ((file!(), line!()))\n }\n \n-#[cfg(all(unix,\n-          not(target_os = \"macos\"),\n-          not(target_os = \"ios\"),\n-          not(target_os = \"android\"),\n-          not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n+#[cfg(any(all(unix,\n+              not(target_os = \"macos\"),\n+              not(target_os = \"ios\"),\n+              not(target_os = \"android\"),\n+              not(all(target_os = \"linux\", target_arch = \"arm\"))),\n+          all(windows, target_env = \"gnu\", not(target_arch = \"x86\"))))]\n macro_rules! dump_and_die {\n     ($($pos:expr),*) => ({\n         // FIXME(#18285): we cannot include the current position because\n@@ -42,11 +43,12 @@ macro_rules! dump_and_die {\n }\n \n // this does not work on Windows, Android, OSX or iOS\n-#[cfg(any(not(unix),\n-          target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"android\",\n-          all(target_os = \"linux\", target_arch = \"arm\")))]\n+#[cfg(not(any(all(unix,\n+              not(target_os = \"macos\"),\n+              not(target_os = \"ios\"),\n+              not(target_os = \"android\"),\n+              not(all(target_os = \"linux\", target_arch = \"arm\"))),\n+          all(windows, target_env = \"gnu\", not(target_arch = \"x86\")))))]\n macro_rules! dump_and_die {\n     ($($pos:expr),*) => ({ let _ = [$($pos),*]; })\n }\n@@ -165,3 +167,4 @@ fn main() {\n         run_test(&args[0]);\n     }\n }\n+"}, {"sha": "5d65f9eb2be0fe3eb8b17738cdfdf248ebf0d288", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1f8200e70ade40c12a095c763041bd4cfa9f21/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=9d1f8200e70ade40c12a095c763041bd4cfa9f21", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // no-pretty-expanded FIXME #15189\n-// ignore-windows FIXME #13259\n // ignore-android FIXME #17520\n+// ignore-msvc FIXME #28133\n \n use std::env;\n use std::process::{Command, Stdio};\n@@ -89,6 +89,7 @@ fn runtest(me: &str) {\n             \"bad output4: {}\", s);\n }\n \n+#[cfg(not(all(windows, target_arch = \"x86\")))]\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() >= 2 && args[1] == \"fail\" {\n@@ -99,3 +100,7 @@ fn main() {\n         runtest(&args[0]);\n     }\n }\n+\n+// See issue 28218\n+#[cfg(all(windows, target_arch = \"x86\"))]\n+fn main() {}"}]}