{"sha": "21699c41af325786cbda1dba2379710f98613c68", "node_id": "C_kwDOAAsO6NoAKDIxNjk5YzQxYWYzMjU3ODZjYmRhMWRiYTIzNzk3MTBmOTg2MTNjNjg", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-30T00:21:32Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T00:48:34Z"}, "message": "Simplify exit of `Delimited` submatchers.\n\nCurrently, we detect an exit from a `Delimited` submatcher when `idx`\nexceeds the bounds of the current submatcher *and* there is a `stack`\nentry.\n\nThis commit changes it to something simpler: just look for a\n`CloseDelim` token.", "tree": {"sha": "48bd5c502259f52806272ea9ba2eb5571aac647f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48bd5c502259f52806272ea9ba2eb5571aac647f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21699c41af325786cbda1dba2379710f98613c68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21699c41af325786cbda1dba2379710f98613c68", "html_url": "https://github.com/rust-lang/rust/commit/21699c41af325786cbda1dba2379710f98613c68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21699c41af325786cbda1dba2379710f98613c68/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5cf08d37b85f953b132951e868df5b924250fdc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5cf08d37b85f953b132951e868df5b924250fdc", "html_url": "https://github.com/rust-lang/rust/commit/c5cf08d37b85f953b132951e868df5b924250fdc"}], "stats": {"total": 30, "additions": 12, "deletions": 18}, "files": [{"sha": "1f86223634f204106e1bb6c5c382794d9611be95", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/21699c41af325786cbda1dba2379710f98613c68/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21699c41af325786cbda1dba2379710f98613c68/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=21699c41af325786cbda1dba2379710f98613c68", "patch": "@@ -75,7 +75,7 @@ crate use ParseResult::*;\n \n use crate::mbe::{self, SequenceRepetition, TokenTree};\n \n-use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n+use rustc_ast::token::{self, DocComment, Nonterminal, Token, TokenKind};\n use rustc_parse::parser::{NtOrTt, Parser};\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n@@ -454,18 +454,6 @@ impl<'tt> TtParser<'tt> {\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            // Backtrack out of delimited submatcher when necessary. When backtracking out again,\n-            // we need to advance the \"dot\" past the delimiters in the parent matcher(s).\n-            while mp.idx >= mp.tts.len() {\n-                match mp.stack.pop() {\n-                    Some(MatcherPosFrame { tts, idx }) => {\n-                        mp.tts = tts;\n-                        mp.idx = idx + 1;\n-                    }\n-                    None => break,\n-                }\n-            }\n-\n             // Get the current position of the \"dot\" (`idx`) in `mp` and the number of token\n             // trees in the matcher (`len`).\n             let idx = mp.idx;\n@@ -516,11 +504,10 @@ impl<'tt> TtParser<'tt> {\n \n                     TokenTree::Delimited(_, delimited) => {\n                         // To descend into a delimited submatcher, we push the current matcher onto\n-                        // a stack and push a new mp containing the submatcher onto `cur_mps`.\n-                        //\n-                        // At the beginning of the loop, if we reach the end of the delimited\n-                        // submatcher, we pop the stack to backtrack out of the descent. Note that\n-                        // we use `all_tts` to include the open and close delimiter tokens.\n+                        // a stack and push a new mp containing the submatcher onto `cur_mps`. When\n+                        // we reach the closing delimiter, we will pop the stack to backtrack out\n+                        // of the descent. Note that we use `all_tts` to include the open and close\n+                        // delimiter tokens.\n                         let tts = mem::replace(&mut mp.tts, &delimited.all_tts);\n                         let idx = mp.idx;\n                         mp.stack.push(MatcherPosFrame { tts, idx });\n@@ -542,6 +529,13 @@ impl<'tt> TtParser<'tt> {\n                             mp.idx += 1;\n                             self.cur_mps.push(mp);\n                         } else if token_name_eq(&t, token) {\n+                            if let TokenKind::CloseDelim(_) = token.kind {\n+                                // Ascend out of the delimited submatcher.\n+                                debug_assert_eq!(idx, len - 1);\n+                                let frame = mp.stack.pop().unwrap();\n+                                mp.tts = frame.tts;\n+                                mp.idx = frame.idx;\n+                            }\n                             mp.idx += 1;\n                             self.next_mps.push(mp);\n                         }"}]}