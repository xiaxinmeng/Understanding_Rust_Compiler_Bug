{"sha": "62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNjg5ZWY1NjhmYjJlNjRlMzY2NmVhNzA0NGZmYTBmMDA1ZjJmYjU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-08-09T21:03:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-09T21:03:45Z"}, "message": "Merge pull request #1861 from topecongiro/refactor-chain\n\nRemove unnecessary rewriting", "tree": {"sha": "5b60a93f2ee54ba757a5c9a2a4068dd76871523e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b60a93f2ee54ba757a5c9a2a4068dd76871523e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "html_url": "https://github.com/rust-lang/rust/commit/62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7da776423a84ff3844cc546ecdc97c6c2c948c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/7da776423a84ff3844cc546ecdc97c6c2c948c77", "html_url": "https://github.com/rust-lang/rust/commit/7da776423a84ff3844cc546ecdc97c6c2c948c77"}, {"sha": "beeaf8d0659af90de92bc2f977241cb1d297167e", "url": "https://api.github.com/repos/rust-lang/rust/commits/beeaf8d0659af90de92bc2f977241cb1d297167e", "html_url": "https://github.com/rust-lang/rust/commit/beeaf8d0659af90de92bc2f977241cb1d297167e"}], "stats": {"total": 485, "additions": 185, "deletions": 300}, "files": [{"sha": "75dac5b322762c8405f0559e0b6cad1c109b1ff8", "filename": "src/chains.rs", "status": "modified", "additions": 84, "deletions": 200, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -98,40 +98,31 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     if chain_only_try(&subexpr_list) {\n         return rewrite_try(&parent, subexpr_list.len(), context, shape);\n     }\n-    let trailing_try_num = subexpr_list\n-        .iter()\n-        .take_while(|e| match e.node {\n-            ast::ExprKind::Try(..) => true,\n-            _ => false,\n-        })\n-        .count();\n+    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n+    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n         match context.config.chain_indent() {\n             IndentStyle::Visual => shape.visual_indent(0),\n-            IndentStyle::Block => shape.block(),\n+            IndentStyle::Block => shape,\n         }\n     } else {\n         shape\n     };\n-    let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n+    let parent_rewrite = try_opt!(\n+        parent\n+            .rewrite(context, parent_shape)\n+            .map(|parent_rw| parent_rw + &repeat_try(prefix_try_num))\n+    );\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = parent_rewrite.len() <= context.config.tab_spaces();\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let first_subexpr_is_try = subexpr_list.last().map_or(false, is_try);\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        let nested_shape = if first_subexpr_is_try {\n-            parent_shape\n-                .block_indent(context.config.tab_spaces())\n-                .with_max_width(context.config)\n-        } else {\n-            chain_indent(context, shape.add_offset(parent_rewrite.len()))\n-        };\n         (\n-            nested_shape,\n+            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n             context.config.chain_indent() == IndentStyle::Visual || is_small_parent,\n         )\n     } else if is_block_expr(context, &parent, &parent_rewrite) {\n@@ -142,13 +133,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             // brace.\n             IndentStyle::Visual => (parent_shape, false),\n         }\n-    } else if parent_rewrite_contains_newline {\n-        (chain_indent(context, parent_shape), false)\n     } else {\n         (\n-            shape\n-                .block_indent(context.config.tab_spaces())\n-                .with_max_width(context.config),\n+            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n             false,\n         )\n     };\n@@ -171,95 +158,60 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         other_child_shape\n     );\n \n-    let child_shape_iter = Some(first_child_shape).into_iter().chain(\n-        ::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1),\n-    );\n-    let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n+    let child_shape_iter = Some(first_child_shape)\n+        .into_iter()\n+        .chain(iter::repeat(other_child_shape));\n+    let subexpr_num = subexpr_list.len();\n+    let last_subexpr = &subexpr_list[suffix_try_num];\n+    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n+    let iter = subexpr_list.iter().skip(1).rev().zip(child_shape_iter);\n     let mut rewrites = try_opt!(\n         iter.map(|(e, shape)| {\n             rewrite_chain_subexpr(e, total_span, context, shape)\n         }).collect::<Option<Vec<_>>>()\n     );\n \n     // Total of all items excluding the last.\n-    let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n-    let almost_total = rewrites[..last_non_try_index]\n-        .iter()\n-        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n-    let one_line_len =\n-        rewrites.iter().fold(0, |a, r| a + first_line_width(r)) + parent_rewrite.len();\n-\n-    let one_line_budget = min(shape.width, context.config.chain_one_line_max());\n-    let veto_single_line = if one_line_len > one_line_budget {\n-        if rewrites.len() > 1 {\n-            true\n-        } else if rewrites.len() == 1 {\n-            context.config.chain_split_single_child() || one_line_len > shape.width\n-        } else {\n-            false\n-        }\n-    } else if context.config.take_source_hints() && subexpr_list.len() > 1 {\n-        // Look at the source code. Unless all chain elements start on the same\n-        // line, we won't consider putting them on a single line either.\n-        let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n-        let first_span = context.snippet(subexpr_list[1].span);\n-        let last_iter = last_span.chars().take_while(|c| c.is_whitespace());\n-\n-        first_span.chars().chain(last_iter).any(|c| c == '\\n')\n+    let extend_last_subexr = last_line_extendable(&parent_rewrite) && rewrites.is_empty();\n+    let almost_total = if extend_last_subexr {\n+        last_line_width(&parent_rewrite)\n     } else {\n-        false\n+        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n     };\n-\n-    let mut fits_single_line = !veto_single_line && almost_total <= shape.width;\n-    if fits_single_line {\n-        let len = rewrites.len();\n-        let (init, last) = rewrites.split_at_mut(len - (1 + trailing_try_num));\n-        fits_single_line = init.iter().all(|s| !s.contains('\\n'));\n-\n-        if fits_single_line {\n-            fits_single_line = match expr.node {\n-                ref e @ ast::ExprKind::MethodCall(..) => {\n-                    if rewrite_method_call_with_overflow(\n-                        e,\n-                        &mut last[0],\n-                        almost_total,\n-                        total_span,\n-                        context,\n-                        shape,\n-                    ) {\n-                        // If the first line of the last method does not fit into a single line\n-                        // after the others, allow new lines.\n-                        almost_total + first_line_width(&last[0]) < context.config.max_width()\n-                    } else {\n-                        false\n+    let one_line_budget = if rewrites.is_empty() && !context.config.chain_split_single_child() {\n+        shape.width\n+    } else {\n+        min(shape.width, context.config.chain_one_line_max())\n+    };\n+    let all_in_one_line = !parent_rewrite_contains_newline &&\n+        rewrites.iter().all(|s| !s.contains('\\n')) &&\n+        almost_total < one_line_budget;\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n+    let (last_subexpr_str, fits_single_line) = try_opt!(if all_in_one_line || extend_last_subexr {\n+        parent_shape.offset_left(almost_total).map(|shape| {\n+            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n+                let line_count = rw.lines().count();\n+                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                if (line_count >= 5 && fits_single_line) || extend_last_subexr {\n+                    (Some(rw), true)\n+                } else {\n+                    match rewrite_last() {\n+                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n+                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                            (Some(rw), fits_single_line)\n+                        }\n+                        new_rw @ Some(..) => (new_rw, false),\n+                        _ => (Some(rw), fits_single_line),\n                     }\n                 }\n-                _ => !last[0].contains('\\n'),\n+            } else {\n+                (rewrite_last(), false)\n             }\n-        }\n-    }\n-\n-    // Try overflowing the last element if we are using block indent and it goes multi line\n-    // or it fits in a single line but goes over the max width.\n-    if !fits_single_line && context.use_block_indent() {\n-        let (init, last) = rewrites.split_at_mut(last_non_try_index);\n-        let almost_single_line = init.iter().all(|s| !s.contains('\\n'));\n-        if almost_single_line && last[0].contains('\\n') {\n-            let overflow_shape = Shape {\n-                width: one_line_budget,\n-                ..parent_shape\n-            };\n-            fits_single_line = rewrite_last_child_with_overflow(\n-                context,\n-                &subexpr_list[trailing_try_num],\n-                overflow_shape,\n-                total_span,\n-                almost_total,\n-                one_line_budget,\n-                &mut last[0],\n-            );\n-        }\n-    }\n+        })\n+    } else {\n+        Some((rewrite_last(), false))\n+    });\n+    rewrites.push(try_opt!(last_subexpr_str));\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n@@ -272,52 +224,42 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = choose_first_connector(\n-        context,\n-        &parent_rewrite,\n-        &rewrites[0],\n-        &connector,\n-        &subexpr_list,\n-        extend,\n-    );\n+    let first_connector = if is_small_parent || fits_single_line ||\n+        last_line_extendable(&parent_rewrite) ||\n+        context.config.chain_indent() == IndentStyle::Visual\n+    {\n+        \"\"\n+    } else {\n+        connector.as_str()\n+    };\n \n-    if is_small_parent && rewrites.len() > 1 {\n+    let result = if is_small_parent && rewrites.len() > 1 {\n         let second_connector = choose_first_connector(\n             context,\n             &rewrites[0],\n             &rewrites[1],\n             &connector,\n-            &subexpr_list[0..subexpr_list.len() - 1],\n+            &subexpr_list[..subexpr_num - 1],\n             false,\n         );\n-        wrap_str(\n-            format!(\n-                \"{}{}{}{}{}\",\n-                parent_rewrite,\n-                first_connector,\n-                rewrites[0],\n-                second_connector,\n-                join_rewrites(\n-                    &rewrites[1..],\n-                    &subexpr_list[0..subexpr_list.len() - 1],\n-                    &connector,\n-                )\n-            ),\n-            context.config.max_width(),\n-            shape,\n+        format!(\n+            \"{}{}{}{}{}\",\n+            parent_rewrite,\n+            first_connector,\n+            rewrites[0],\n+            second_connector,\n+            join_rewrites(&rewrites[1..], &subexpr_list[..subexpr_num - 1], &connector)\n         )\n     } else {\n-        wrap_str(\n-            format!(\n-                \"{}{}{}\",\n-                parent_rewrite,\n-                first_connector,\n-                join_rewrites(&rewrites, &subexpr_list, &connector)\n-            ),\n-            context.config.max_width(),\n-            shape,\n+        format!(\n+            \"{}{}{}\",\n+            parent_rewrite,\n+            first_connector,\n+            join_rewrites(&rewrites, &subexpr_list, &connector)\n         )\n-    }\n+    };\n+    let result = format!(\"{}{}\", result, repeat_try(suffix_try_num));\n+    wrap_str(result, context.config.max_width(), shape)\n }\n \n fn is_extendable_parent(context: &RewriteContext, parent_str: &str) -> bool {\n@@ -335,38 +277,18 @@ fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n \n // Try to rewrite and replace the last non-try child. Return `true` if\n // replacing succeeds.\n-fn rewrite_last_child_with_overflow(\n-    context: &RewriteContext,\n-    expr: &ast::Expr,\n-    shape: Shape,\n-    span: Span,\n-    almost_total: usize,\n-    one_line_budget: usize,\n-    last_child: &mut String,\n-) -> bool {\n-    if let Some(shape) = shape.shrink_left(almost_total) {\n-        if let Some(ref mut rw) = rewrite_chain_subexpr(expr, span, context, shape) {\n-            if almost_total + first_line_width(rw) <= one_line_budget && rw.lines().count() > 3 {\n-                ::std::mem::swap(last_child, rw);\n-                return true;\n-            }\n-        }\n-    }\n-    false\n+fn repeat_try(try_count: usize) -> String {\n+    iter::repeat(\"?\").take(try_count).collect::<String>()\n }\n \n-pub fn rewrite_try(\n+fn rewrite_try(\n     expr: &ast::Expr,\n     try_count: usize,\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n     let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n-    Some(format!(\n-        \"{}{}\",\n-        sub_expr,\n-        iter::repeat(\"?\").take(try_count).collect::<String>()\n-    ))\n+    Some(format!(\"{}{}\", sub_expr, repeat_try(try_count)))\n }\n \n fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n@@ -426,47 +348,9 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     match context.config.chain_indent() {\n         IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n-    }\n-}\n-\n-fn rewrite_method_call_with_overflow(\n-    expr_kind: &ast::ExprKind,\n-    last: &mut String,\n-    almost_total: usize,\n-    total_span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> bool {\n-    if let &ast::ExprKind::MethodCall(ref segment, ref expressions) = expr_kind {\n-        let shape = match shape.shrink_left(almost_total) {\n-            Some(b) => b,\n-            None => return false,\n-        };\n-        let types = match segment.parameters {\n-            Some(ref params) => match **params {\n-                ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                _ => &[],\n-            },\n-            _ => &[],\n-        };\n-        let mut last_rewrite = rewrite_method_call(\n-            segment.identifier,\n-            types,\n-            expressions,\n-            total_span,\n-            context,\n-            shape,\n-        );\n-\n-        if let Some(ref mut s) = last_rewrite {\n-            ::std::mem::swap(s, last);\n-            true\n-        } else {\n-            false\n-        }\n-    } else {\n-        unreachable!();\n+        IndentStyle::Block => shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config),\n     }\n }\n "}, {"sha": "d0e5df3abbbad35487cc5e19dd0fef013bcedb05", "filename": "src/expr.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -466,6 +466,7 @@ where\n         |item| item.rewrite(context, nested_shape),\n         span.lo,\n         span.hi,\n+        false,\n     ).collect::<Vec<_>>();\n \n     if items.is_empty() {\n@@ -587,6 +588,7 @@ fn rewrite_closure_fn_decl(\n         |arg| arg.rewrite(context, arg_shape),\n         context.codemap.span_after(span, \"|\"),\n         body.span.lo,\n+        false,\n     );\n     let item_vec = arg_items.collect::<Vec<_>>();\n     // 1 = space between arguments and return type.\n@@ -1130,10 +1132,7 @@ impl<'a> ControlFlow<'a> {\n \n             let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n             let expr = &self.block.stmts[0];\n-            let if_str = try_opt!(expr.rewrite(\n-                context,\n-                Shape::legacy(new_width, Indent::empty()),\n-            ));\n+            let if_str = try_opt!(expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n \n             let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n             let else_expr = &else_node.stmts[0];\n@@ -1246,14 +1245,12 @@ impl<'a> ControlFlow<'a> {\n         // for event in event\n         let between_kwd_cond = mk_sp(\n             context.codemap.span_after(self.span, self.keyword.trim()),\n-            self.pat.map_or(\n-                cond_span.lo,\n-                |p| if self.matcher.is_empty() {\n+            self.pat\n+                .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n                     p.span.lo\n                 } else {\n                     context.codemap.span_before(self.span, self.matcher.trim())\n-                },\n-            ),\n+                }),\n         );\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n@@ -2194,6 +2191,7 @@ where\n         |item| item.rewrite(context, shape),\n         span.lo,\n         span.hi,\n+        true,\n     );\n     let mut item_vec: Vec<_> = items.collect();\n \n@@ -2245,28 +2243,22 @@ where\n \n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n-    let (orig_last, placeholder) = if overflow_last {\n+    let placeholder = if overflow_last {\n         let mut context = context.clone();\n         if let Some(expr) = args[args.len() - 1].to_expr() {\n             match expr.node {\n                 ast::ExprKind::MethodCall(..) => context.force_one_line_chain = true,\n                 _ => (),\n             }\n         }\n-        last_arg_shape(&context, &item_vec, shape, args_max_width)\n-            .map_or((None, None), |arg_shape| {\n-                rewrite_last_arg_with_overflow(\n-                    &context,\n-                    args,\n-                    &mut item_vec[args.len() - 1],\n-                    arg_shape,\n-                )\n-            })\n+        last_arg_shape(&context, &item_vec, shape, args_max_width).and_then(|arg_shape| {\n+            rewrite_last_arg_with_overflow(&context, args, &mut item_vec[args.len() - 1], arg_shape)\n+        })\n     } else {\n-        (None, None)\n+        None\n     };\n \n-    let tactic = definitive_tactic(\n+    let mut tactic = definitive_tactic(\n         &*item_vec,\n         ListTactic::LimitedHorizontalVertical(args_max_width),\n         Separator::Comma,\n@@ -2279,10 +2271,17 @@ where\n         (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n             item_vec[args.len() - 1].item = placeholder;\n         }\n-        (true, _, _) => {\n-            item_vec[args.len() - 1].item = orig_last;\n+        _ if args.len() >= 1 => {\n+            item_vec[args.len() - 1].item = args.last()\n+                .and_then(|last_arg| last_arg.rewrite(context, shape));\n+            tactic = definitive_tactic(\n+                &*item_vec,\n+                ListTactic::LimitedHorizontalVertical(args_max_width),\n+                Separator::Comma,\n+                one_line_width,\n+            );\n         }\n-        (false, _, _) => {}\n+        _ => (),\n     }\n \n     tactic\n@@ -2357,7 +2356,7 @@ fn rewrite_last_arg_with_overflow<'a, T>(\n     args: &[&T],\n     last_item: &mut ListItem,\n     shape: Shape,\n-) -> (Option<String>, Option<String>)\n+) -> Option<String>\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n@@ -2388,14 +2387,13 @@ where\n     } else {\n         last_arg.rewrite(context, shape)\n     };\n-    let orig_last = last_item.item.clone();\n \n     if let Some(rewrite) = rewrite {\n         let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n         last_item.item = rewrite_first_line;\n-        (orig_last, Some(rewrite))\n+        Some(rewrite)\n     } else {\n-        (orig_last, None)\n+        None\n     }\n }\n \n@@ -2653,6 +2651,7 @@ fn rewrite_struct_lit<'a>(\n             rewrite,\n             body_lo,\n             span.hi,\n+            false,\n         );\n         let item_vec = items.collect::<Vec<_>>();\n \n@@ -2805,6 +2804,7 @@ where\n         |item| item.rewrite(context, nested_shape),\n         list_lo,\n         span.hi - BytePos(1),\n+        false,\n     );\n     let item_vec: Vec<_> = items.collect();\n     let tactic = definitive_tactic("}, {"sha": "f42975ff919d680e16efcdb5d35cf032216d5c39", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -447,6 +447,7 @@ fn rewrite_use_list(\n             rewrite_path_item,\n             context.codemap.span_after(span, \"{\"),\n             span.hi,\n+            false,\n         );\n         items.extend(iter);\n         items"}, {"sha": "09b5f7d9d306187d0bfd4bc373fa65d97c4c365d", "filename": "src/items.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -469,6 +469,7 @@ impl<'a> FmtVisitor<'a> {\n             |f| self.format_variant(f),\n             body_lo,\n             body_hi,\n+            false,\n         );\n \n         let shape = Shape::indented(self.block_indent, self.config)\n@@ -2207,6 +2208,7 @@ fn rewrite_args(\n             },\n             comment_span_start,\n             span.hi,\n+            false,\n         );\n \n         arg_items.extend(more_items);\n@@ -2411,6 +2413,7 @@ fn rewrite_generics_inner(\n         |&(_, ref str)| str.clone(),\n         context.codemap.span_after(span, \"<\"),\n         span.hi,\n+        false,\n     );\n     format_generics_item_list(context, items, shape, one_line_width)\n }\n@@ -2554,6 +2557,7 @@ fn rewrite_where_clause_rfc_style(\n         |pred| pred.rewrite(context, block_shape),\n         span_start,\n         span_end,\n+        false,\n     );\n     let comma_tactic = if where_clause_option.suppress_comma {\n         SeparatorTactic::Never\n@@ -2654,6 +2658,7 @@ fn rewrite_where_clause(\n         |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n         span_start,\n         span_end,\n+        false,\n     );\n     let item_vec = items.collect::<Vec<_>>();\n     // FIXME: we don't need to collect here if the where_layout isn't"}, {"sha": "e6ee8a7df44bda77fdb133a8c958afec7c0db847", "filename": "src/lists.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -454,6 +454,7 @@ where\n     prev_span_end: BytePos,\n     next_span_start: BytePos,\n     terminator: &'a str,\n+    leave_last: bool,\n }\n \n impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n@@ -592,7 +593,11 @@ where\n             ListItem {\n                 pre_comment: pre_comment,\n                 pre_comment_style: pre_comment_style,\n-                item: (self.get_item_string)(&item),\n+                item: if self.inner.peek().is_none() && self.leave_last {\n+                    None\n+                } else {\n+                    (self.get_item_string)(&item)\n+                },\n                 post_comment: post_comment,\n                 new_lines: new_lines,\n             }\n@@ -610,6 +615,7 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(\n     get_item_string: F3,\n     prev_span_end: BytePos,\n     next_span_start: BytePos,\n+    leave_last: bool,\n ) -> ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator<Item = T>,\n@@ -626,6 +632,7 @@ where\n         prev_span_end: prev_span_end,\n         next_span_start: next_span_start,\n         terminator: terminator,\n+        leave_last: leave_last,\n     }\n }\n "}, {"sha": "b85bc44b16226e6154c1de924fbcf8a62fd10aaa", "filename": "src/missed_spans.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -146,10 +146,11 @@ impl<'a> FmtVisitor<'a> {\n                 let subslice_num_lines = subslice.chars().filter(|c| *c == '\\n').count();\n \n                 if rewrite_next_comment &&\n-                    !self.config\n-                        .file_lines()\n-                        .intersects_range(file_name, cur_line, cur_line + subslice_num_lines)\n-                {\n+                    !self.config.file_lines().intersects_range(\n+                        file_name,\n+                        cur_line,\n+                        cur_line + subslice_num_lines,\n+                    ) {\n                     rewrite_next_comment = false;\n                 }\n "}, {"sha": "628c207d75087be959ef381a39b656fd7272dd2b", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -162,6 +162,7 @@ fn rewrite_struct_pat(\n         |f| f.node.rewrite(context, v_shape),\n         context.codemap.span_after(span, \"{\"),\n         span.hi,\n+        false,\n     );\n     let item_vec = items.collect::<Vec<_>>();\n \n@@ -342,6 +343,7 @@ fn count_wildcard_suffix_len(\n         |item| item.rewrite(context, shape),\n         context.codemap.span_after(span, \"(\"),\n         span.hi - BytePos(1),\n+        false,\n     ).collect();\n \n     for item in items.iter().rev().take_while(|i| match i.item {"}, {"sha": "f7cb3c5365686bf20dbd5506481a30c8e7d26aed", "filename": "src/types.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -241,6 +241,7 @@ fn rewrite_segment(\n                     |seg| seg.rewrite(context, generics_shape),\n                     list_lo,\n                     span_hi,\n+                    false,\n                 );\n                 let generics_str = try_opt!(format_generics_item_list(\n                     context,\n@@ -344,6 +345,7 @@ where\n         },\n         list_lo,\n         span.hi,\n+        false,\n     );\n \n     let item_vec: Vec<_> = items.collect();\n@@ -553,10 +555,7 @@ impl Rewrite for ast::TyParamBound {\n                 let budget = try_opt!(shape.width.checked_sub(1));\n                 Some(format!(\n                     \"?{}\",\n-                    try_opt!(tref.rewrite(\n-                        context,\n-                        Shape::legacy(budget, shape.indent + 1),\n-                    ))\n+                    try_opt!(tref.rewrite(context, Shape::legacy(budget, shape.indent + 1)))\n                 ))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, shape),\n@@ -609,10 +608,8 @@ impl Rewrite for ast::TyParam {\n             };\n             result.push_str(eq_str);\n             let budget = try_opt!(shape.width.checked_sub(result.len()));\n-            let rewrite = try_opt!(def.rewrite(\n-                context,\n-                Shape::legacy(budget, shape.indent + result.len()),\n-            ));\n+            let rewrite =\n+                try_opt!(def.rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n             result.push_str(&rewrite);\n         }\n "}, {"sha": "fbb4ddd3bc87c487e5ddd129968c2d8e13bd4b30", "filename": "src/vertical.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -174,13 +174,13 @@ fn struct_field_preix_max_min_width<T: AlignedItem>(\n     fields\n         .iter()\n         .map(|field| {\n-            field.rewrite_prefix(context, shape).and_then(\n-                |field_str| if field_str.contains('\\n') {\n+            field\n+                .rewrite_prefix(context, shape)\n+                .and_then(|field_str| if field_str.contains('\\n') {\n                     None\n                 } else {\n                     Some(field_str.len())\n-                },\n-            )\n+                })\n         })\n         .fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n             (Some((max_len, min_len)), Some(len)) => {\n@@ -219,6 +219,7 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n         |field| field.rewrite_aligned_item(context, item_shape, field_prefix_max_width),\n         span.lo,\n         span.hi,\n+        false,\n     ).collect::<Vec<_>>();\n \n     let tactic = definitive_tactic("}, {"sha": "4ef89979c3ff159a6060d5abb725bc639972497d", "filename": "src/visitor.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -850,6 +850,7 @@ impl Rewrite for ast::MetaItem {\n                     |nested_meta_item| nested_meta_item.rewrite(context, item_shape),\n                     self.span.lo,\n                     hi,\n+                    false,\n                 );\n                 let item_vec = items.collect::<Vec<_>>();\n                 let fmt = ListFormatting {\n@@ -887,8 +888,9 @@ impl Rewrite for ast::MetaItem {\n \n impl Rewrite for ast::Attribute {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        try_opt!(self.meta()).rewrite(context, shape).map(\n-            |rw| if self.is_sugared_doc {\n+        try_opt!(self.meta())\n+            .rewrite(context, shape)\n+            .map(|rw| if self.is_sugared_doc {\n                 rw\n             } else {\n                 let original = context.snippet(self.span);\n@@ -901,8 +903,7 @@ impl Rewrite for ast::Attribute {\n                 } else {\n                     format!(\"{}[{}]\", prefix, rw)\n                 }\n-            },\n-        )\n+            })\n     }\n }\n "}, {"sha": "66ef44fcd4ae2dced64f8122fecd9799139d836a", "filename": "tests/target/chains-indent-visual.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fchains-indent-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fchains-indent-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-indent-visual.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -1,10 +1,9 @@\n // rustfmt-chain_indent: Visual\n \n fn test() {\n-    let x = my_long_function()\n-        .my_even_longer_function()\n-        .my_nested_function()\n-        .some_random_name()\n-        .another_function()\n-        .do_it();\n+    let x = my_long_function().my_even_longer_function()\n+                              .my_nested_function()\n+                              .some_random_name()\n+                              .another_function()\n+                              .do_it();\n }"}, {"sha": "829a27867dd510b3f49580b282c9646e45a5dca2", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -32,15 +32,14 @@ fn main() {\n         x\n     });\n \n-    some_fuuuuuuuuunction()\n-        .method_call_a(aaaaa, bbbbb, |c| {\n-            let x = c;\n-            x\n-        })\n-        .method_call_b(aaaaa, bbbbb, |c| {\n-            let x = c;\n-            x\n-        });\n+    some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {\n+        let x = c;\n+        x\n+    })\n+                           .method_call_b(aaaaa, bbbbb, |c| {\n+        let x = c;\n+        x\n+    });\n \n     fffffffffffffffffffffffffffffffffff(a, {\n         SCRIPT_TASK_ROOT.with(|root| { *root.borrow_mut() = Some(&script_task); });\n@@ -67,16 +66,14 @@ fn floaters() {\n     let x = Foo {\n                 field1: val1,\n                 field2: val2,\n-            }\n-            .method_call()\n+            }.method_call()\n             .method_call();\n \n     let y = if cond {\n                 val1\n             } else {\n                 val2\n-            }\n-            .method_call();\n+            }.method_call();\n \n     {\n         match x {\n@@ -86,8 +83,7 @@ fn floaters() {\n                     mparams[match cur.to_digit(10) {\n                                 Some(d) => d as usize - 1,\n                                 None => return Err(\"bad param number\".to_owned()),\n-                            }]\n-                    .clone(),\n+                            }].clone(),\n                 );\n             }\n         }\n@@ -97,22 +93,19 @@ fn floaters() {\n         some();\n     } else {\n         none();\n-    }\n-    .bar()\n+    }.bar()\n     .baz();\n \n-    Foo { x: val }\n-        .baz(|| {\n-            force();\n-            multiline();\n-        })\n-        .quux();\n+    Foo { x: val }.baz(|| {\n+        force();\n+        multiline();\n+    })\n+                  .quux();\n \n     Foo {\n         y: i_am_multi_line,\n         z: ok,\n-    }\n-    .baz(|| {\n+    }.baz(|| {\n         force();\n         multiline();\n     })\n@@ -121,8 +114,7 @@ fn floaters() {\n     a + match x {\n             true => \"yay!\",\n             false => \"boo!\",\n-        }\n-        .bar()\n+        }.bar()\n }\n \n fn is_replaced_content() -> bool {\n@@ -137,33 +129,30 @@ fn issue587() {\n }\n \n fn issue_1389() {\n-    let names = String::from_utf8(names)?\n-        .split('|')\n-        .map(str::to_owned)\n-        .collect();\n+    let names = String::from_utf8(names)?.split('|')\n+                                         .map(str::to_owned)\n+                                         .collect();\n }\n \n fn issue1217() -> Result<Mnemonic, Error> {\n-    let random_chars: String = OsRng::new()?\n-        .gen_ascii_chars()\n-        .take(self.bit_length)\n-        .collect();\n+    let random_chars: String = OsRng::new()?.gen_ascii_chars()\n+                                            .take(self.bit_length)\n+                                            .collect();\n \n     Ok(Mnemonic::new(&random_chars))\n }\n \n fn issue1236(options: Vec<String>) -> Result<Option<String>> {\n-    let process = Command::new(\"dmenu\")\n-        .stdin(Stdio::piped())\n-        .stdout(Stdio::piped())\n-        .spawn()\n-        .chain_err(|| \"failed to spawn dmenu\")?;\n+    let process = Command::new(\"dmenu\").stdin(Stdio::piped())\n+                                       .stdout(Stdio::piped())\n+                                       .spawn()\n+                                       .chain_err(|| \"failed to spawn dmenu\")?;\n }\n \n fn issue1434() {\n     for _ in 0..100 {\n-        let prototype_id = PrototypeIdData::from_reader::<_, B>(&mut self.file_cursor)\n-            .chain_err(|| {\n+        let prototype_id =\n+            PrototypeIdData::from_reader::<_, B>(&mut self.file_cursor).chain_err(|| {\n                 format!(\n                     \"could not read prototype ID at offset {:#010x}\",\n                     current_offset"}, {"sha": "7d29e1e2321e0fac7cf924d964506422bc5d48d3", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62689ef568fb2e64e3666ea7044ffa0f005f2fb5/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=62689ef568fb2e64e3666ea7044ffa0f005f2fb5", "patch": "@@ -389,9 +389,7 @@ fn issue1395() {\n \n fn issue1456() {\n     Ok(Recording {\n-        artists: match reader\n-            .evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")?\n-        {\n+        artists: match reader.evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")? {\n             Nodeset(nodeset) => {\n                 let res: Result<Vec<ArtistRef>, ReadError> = nodeset\n                     .iter()"}]}