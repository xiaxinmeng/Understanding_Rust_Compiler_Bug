{"sha": "77c98f081509733af957af6ed7b0b277e5f57871", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3Yzk4ZjA4MTUwOTczM2FmOTU3YWY2ZWQ3YjBiMjc3ZTVmNTc4NzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-17T03:04:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-17T03:04:41Z"}, "message": "auto merge of #6523 : cmr/rust/faster_each_permutation, r=luqmana\n\nCloses #5127", "tree": {"sha": "b22d79763ac3aed77ddc1ac412c3d9dff6523a87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b22d79763ac3aed77ddc1ac412c3d9dff6523a87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77c98f081509733af957af6ed7b0b277e5f57871", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77c98f081509733af957af6ed7b0b277e5f57871", "html_url": "https://github.com/rust-lang/rust/commit/77c98f081509733af957af6ed7b0b277e5f57871", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77c98f081509733af957af6ed7b0b277e5f57871/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09bf401f1d4f843ead4d4fe955348ce5e8215fb1", "html_url": "https://github.com/rust-lang/rust/commit/09bf401f1d4f843ead4d4fe955348ce5e8215fb1"}, {"sha": "af54d58891505a67aaab5365b957679b0c593eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/af54d58891505a67aaab5365b957679b0c593eb7", "html_url": "https://github.com/rust-lang/rust/commit/af54d58891505a67aaab5365b957679b0c593eb7"}], "stats": {"total": 147, "additions": 127, "deletions": 20}, "files": [{"sha": "4c6e0791ba2ca531713b1ca6f66f58bfeffe0851", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 127, "deletions": 20, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/77c98f081509733af957af6ed7b0b277e5f57871/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c98f081509733af957af6ed7b0b277e5f57871/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=77c98f081509733af957af6ed7b0b277e5f57871", "patch": "@@ -1445,6 +1445,46 @@ pub fn reverse<T>(v: &mut [T]) {\n     }\n }\n \n+/**\n+ * Reverse part of a vector in place.\n+ *\n+ * Reverse the elements in the vector between `start` and `end - 1`.\n+ *\n+ * If either start or end do not represent valid positions in the vector, the\n+ * vector is returned unchanged.\n+ *\n+ * # Arguments\n+ *\n+ * * `v` - The mutable vector to be modified\n+ *\n+ * * `start` - Index of the first element of the slice\n+ *\n+ * * `end` - Index one past the final element to be reversed.\n+ *\n+ * # Example\n+ *\n+ * Assume a mutable vector `v` contains `[1,2,3,4,5]`. After the call:\n+ *\n+ * ~~~\n+ *\n+ * reverse_part(v, 1, 4);\n+ *\n+ * ~~~\n+ *\n+ * `v` now contains `[1,4,3,2,5]`.\n+ */\n+pub fn reverse_part<T>(v: &mut [T], start: uint, end : uint) {\n+    let sz = v.len();\n+    if start >= sz || end > sz { return; }\n+    let mut i = start;\n+    let mut j = end - 1;\n+    while i < j {\n+        vec::swap(v, i, j);\n+        i += 1;\n+        j -= 1;\n+    }\n+}\n+\n /// Returns a vector with the order of elements reversed\n pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -1739,29 +1779,49 @@ pub fn each2_mut<U, T>(v1: &mut [U], v2: &mut [T], f: &fn(u: &mut U, t: &mut T)\n  *\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n+ *\n+ * See [Algorithms to generate\n+ * permutations](http://en.wikipedia.org/wiki/Permutation).\n+ *\n+ *  # Arguments\n+ *\n+ *  * `values` - A vector of values from which the permutations are\n+ *  chosen\n+ *\n+ *  * `fun` - The function to iterate over the combinations\n  */\n-#[cfg(not(stage0))]\n-pub fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) -> bool {\n-    let ln = len(v);\n-    if ln <= 1 {\n-        put(v);\n-    } else {\n-        // This does not seem like the most efficient implementation.  You\n-        // could make far fewer copies if you put your mind to it.\n-        let mut i = 0u;\n-        while i < ln {\n-            let elt = v[i];\n-            let mut rest = slice(v, 0u, i).to_vec();\n-            rest.push_all(const_slice(v, i+1u, ln));\n-            for each_permutation(rest) |permutation| {\n-                if !put(append(~[elt], permutation)) {\n-                    return false;\n-                }\n-            }\n-            i += 1u;\n+pub fn each_permutation<T:Copy>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n+    let length = values.len();\n+    let mut permutation = vec::from_fn(length, |i| values[i]);\n+    if length <= 1 {\n+        fun(permutation);\n+        return true;\n+    }\n+    let mut indices = vec::from_fn(length, |i| i);\n+    loop {\n+        if !fun(permutation) { return true; }\n+        // find largest k such that indices[k] < indices[k+1]\n+        // if no such k exists, all permutations have been generated\n+        let mut k = length - 2;\n+        while k > 0 && indices[k] >= indices[k+1] {\n+            k -= 1;\n+        }\n+        if k == 0 && indices[0] > indices[1] { return true; }\n+        // find largest l such that indices[k] < indices[l]\n+        // k+1 is guaranteed to be such\n+        let mut l = length - 1;\n+        while indices[k] >= indices[l] {\n+            l -= 1;\n+        }\n+        // swap indices[k] and indices[l]; sort indices[k+1..]\n+        // (they're just reversed)\n+        vec::swap(indices, k, l);\n+        reverse_part(indices, k+1, length);\n+        // fixup permutation based on indices\n+        for uint::range(k, length) |i| {\n+            permutation[i] = values[indices[i]];\n         }\n     }\n-    return true;\n }\n \n /**\n@@ -4730,6 +4790,53 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_reverse_part() {\n+        let mut values = [1,2,3,4,5];\n+        reverse_part(values,1,4);\n+        assert_eq!(values, [1,4,3,2,5]);\n+    }\n+\n+    #[test]\n+    fn test_permutations0() {\n+        let values = [];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(p.to_owned());\n+        }\n+        assert_eq!(v, ~[~[]]);\n+    }\n+\n+    #[test]\n+    fn test_permutations1() {\n+        let values = [1];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(p.to_owned());\n+        }\n+        assert_eq!(v, ~[~[1]]);\n+    }\n+\n+    #[test]\n+    fn test_permutations2() {\n+        let values = [1,2];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(p.to_owned());\n+        }\n+        assert_eq!(v, ~[~[1,2],~[2,1]]);\n+    }\n+\n+    #[test]\n+    fn test_permutations3() {\n+        let values = [1,2,3];\n+        let mut v : ~[~[int]] = ~[];\n+        for each_permutation(values) |p| {\n+            v.push(p.to_owned());\n+        }\n+        assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n+    }\n+\n     #[test]\n     fn test_each_val() {\n         use old_iter::CopyableNonstrictIter;"}]}