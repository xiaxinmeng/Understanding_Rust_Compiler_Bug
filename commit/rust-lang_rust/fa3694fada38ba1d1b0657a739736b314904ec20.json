{"sha": "fa3694fada38ba1d1b0657a739736b314904ec20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMzY5NGZhZGEzOGJhMWQxYjA2NTdhNzM5NzM2YjMxNDkwNGVjMjA=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-03-06T19:00:04Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2021-03-13T20:49:32Z"}, "message": "Always lower asm! to valid HIR", "tree": {"sha": "19edaa8ff0996b1e20a3093fe01ee79cc03e3001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19edaa8ff0996b1e20a3093fe01ee79cc03e3001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa3694fada38ba1d1b0657a739736b314904ec20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa3694fada38ba1d1b0657a739736b314904ec20", "html_url": "https://github.com/rust-lang/rust/commit/fa3694fada38ba1d1b0657a739736b314904ec20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa3694fada38ba1d1b0657a739736b314904ec20/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56f74c52c1bb627ada01992787116054bf1e66e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/56f74c52c1bb627ada01992787116054bf1e66e9", "html_url": "https://github.com/rust-lang/rust/commit/56f74c52c1bb627ada01992787116054bf1e66e9"}], "stats": {"total": 125, "additions": 80, "deletions": 45}, "files": [{"sha": "584257936027e973297f7c3b1491a94e38839f81", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=fa3694fada38ba1d1b0657a739736b314904ec20", "patch": "@@ -1331,84 +1331,83 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        if self.sess.asm_arch.is_none() {\n+        // Rustdoc needs to support asm! from foriegn architectures: don't try\n+        // lowering the register contraints in this case.\n+        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n+        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n             struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n         }\n         if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n-            && !matches!(\n-                self.sess.asm_arch,\n-                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n-            )\n+            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n+            && !self.sess.opts.actually_rustdoc\n         {\n             self.sess\n                 .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n                 .emit();\n         }\n \n-        // Lower operands to HIR, filter_map skips any operands with invalid\n-        // register classes.\n+        // Lower operands to HIR. We use dummy register classes if an error\n+        // occurs during lowering because we still need to be able to produce a\n+        // valid HIR.\n         let sess = self.sess;\n         let operands: Vec<_> = asm\n             .operands\n             .iter()\n-            .filter_map(|(op, op_sp)| {\n-                let lower_reg = |reg| {\n-                    Some(match reg {\n-                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+            .map(|(op, op_sp)| {\n+                let lower_reg = |reg| match reg {\n+                    InlineAsmRegOrRegClass::Reg(s) => {\n+                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n-                                sess.asm_arch?,\n+                                asm_arch,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n                                 &sess.target,\n                                 s,\n                             )\n-                            .map_err(|e| {\n+                            .unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmReg::Err\n                             })\n-                            .ok()?,\n-                        ),\n-                        InlineAsmRegOrRegClass::RegClass(s) => {\n-                            asm::InlineAsmRegOrRegClass::RegClass(\n-                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n-                                    .map_err(|e| {\n-                                        let msg = format!(\n-                                            \"invalid register class `{}`: {}\",\n-                                            s.as_str(),\n-                                            e\n-                                        );\n-                                        sess.struct_span_err(*op_sp, &msg).emit();\n-                                    })\n-                                    .ok()?,\n-                            )\n-                        }\n-                    })\n+                        } else {\n+                            asm::InlineAsmReg::Err\n+                        })\n+                    }\n+                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmRegClass::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmRegClass::Err\n+                        })\n+                    }\n                 };\n \n-                // lower_reg is executed last because we need to lower all\n-                // sub-expressions even if we throw them away later.\n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n                     InlineAsmOperand::Const { ref expr } => {\n@@ -1418,17 +1417,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n                     }\n                 };\n-                Some((op, *op_sp))\n+                (op, *op_sp)\n             })\n             .collect();\n \n-        // Stop if there were any errors when lowering the register classes\n-        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n-            return hir::ExprKind::Err;\n-        }\n-\n         // Validate template modifiers against the register classes for the operands\n-        let asm_arch = sess.asm_arch.unwrap();\n         for p in &asm.template {\n             if let InlineAsmTemplatePiece::Placeholder {\n                 operand_idx,\n@@ -1443,7 +1436,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     | hir::InlineAsmOperand::InOut { reg, .. }\n                     | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n                         let class = reg.reg_class();\n-                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if class == asm::InlineAsmRegClass::Err {\n+                            continue;\n+                        }\n+                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n                             let mut err = sess.struct_span_err(\n                                 placeholder_span,\n@@ -1506,7 +1502,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // features. We check that at least one type is available for\n                 // the current target.\n                 let reg_class = reg.reg_class();\n-                for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                if reg_class == asm::InlineAsmRegClass::Err {\n+                    continue;\n+                }\n+                for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n                     if let Some(feature) = feature {\n                         if self.sess.target_features.contains(&Symbol::intern(feature)) {\n                             required_features.clear();"}, {"sha": "e7d359c4f149c1db4a6d94387ea58b702637e6b6", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=fa3694fada38ba1d1b0657a739736b314904ec20", "patch": "@@ -528,6 +528,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n+            InlineAsmRegClass::Err => unreachable!(),\n         }\n         .to_string(),\n     }\n@@ -594,6 +595,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n \n@@ -637,6 +639,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n "}, {"sha": "1d0013bcd2c235614c785d12c92da134843ffa21", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3694fada38ba1d1b0657a739736b314904ec20/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=fa3694fada38ba1d1b0657a739736b314904ec20", "patch": "@@ -229,6 +229,8 @@ pub enum InlineAsmReg {\n     Mips(MipsInlineAsmReg),\n     SpirV(SpirVInlineAsmReg),\n     Wasm(WasmInlineAsmReg),\n+    // Placeholder for invalid register constraints for the current target\n+    Err,\n }\n \n impl InlineAsmReg {\n@@ -240,6 +242,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::Err => \"<reg>\",\n         }\n     }\n \n@@ -251,6 +254,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n             Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),\n+            Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n \n@@ -309,6 +313,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => r.emit(out, arch, modifier),\n             Self::Hexagon(r) => r.emit(out, arch, modifier),\n             Self::Mips(r) => r.emit(out, arch, modifier),\n+            Self::Err => unreachable!(),\n         }\n     }\n \n@@ -320,6 +325,7 @@ impl InlineAsmReg {\n             Self::RiscV(_) => cb(self),\n             Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n             Self::Mips(_) => cb(self),\n+            Self::Err => unreachable!(),\n         }\n     }\n }\n@@ -346,6 +352,8 @@ pub enum InlineAsmRegClass {\n     Mips(MipsInlineAsmRegClass),\n     SpirV(SpirVInlineAsmRegClass),\n     Wasm(WasmInlineAsmRegClass),\n+    // Placeholder for invalid register constraints for the current target\n+    Err,\n }\n \n impl InlineAsmRegClass {\n@@ -360,6 +368,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.name(),\n             Self::SpirV(r) => r.name(),\n             Self::Wasm(r) => r.name(),\n+            Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n \n@@ -377,6 +386,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n+            Self::Err => unreachable!(),\n         }\n     }\n \n@@ -401,6 +411,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n             Self::SpirV(r) => r.suggest_modifier(arch, ty),\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n+            Self::Err => unreachable!(),\n         }\n     }\n \n@@ -421,6 +432,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.default_modifier(arch),\n             Self::SpirV(r) => r.default_modifier(arch),\n             Self::Wasm(r) => r.default_modifier(arch),\n+            Self::Err => unreachable!(),\n         }\n     }\n \n@@ -440,6 +452,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.supported_types(arch),\n             Self::SpirV(r) => r.supported_types(arch),\n             Self::Wasm(r) => r.supported_types(arch),\n+            Self::Err => unreachable!(),\n         }\n     }\n \n@@ -476,6 +489,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.valid_modifiers(arch),\n             Self::SpirV(r) => r.valid_modifiers(arch),\n             Self::Wasm(r) => r.valid_modifiers(arch),\n+            Self::Err => unreachable!(),\n         }\n     }\n }"}, {"sha": "dfd731474179d752247cbcf1230073b99a3be7ba", "filename": "src/test/rustdoc-ui/asm-foreign.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa3694fada38ba1d1b0657a739736b314904ec20/src%2Ftest%2Frustdoc-ui%2Fasm-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3694fada38ba1d1b0657a739736b314904ec20/src%2Ftest%2Frustdoc-ui%2Fasm-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fasm-foreign.rs?ref=fa3694fada38ba1d1b0657a739736b314904ec20", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+// Make sure rustdoc accepts asm! for a foreign architecture.\n+\n+#![feature(asm)]\n+\n+pub unsafe fn aarch64(a: f64, b: f64) {\n+    let c;\n+    asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+        || {};\n+        b\n+    });\n+    c\n+}\n+\n+pub unsafe fn x86(a: f64, b: f64) {\n+    let c;\n+    asm!(\"addsd {}, {}, xmm0\", out(xmm_reg) c, in(xmm_reg) a, in(\"xmm0\") b);\n+    c\n+}"}]}