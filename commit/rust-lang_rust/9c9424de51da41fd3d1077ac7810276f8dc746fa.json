{"sha": "9c9424de51da41fd3d1077ac7810276f8dc746fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTQyNGRlNTFkYTQxZmQzZDEwNzdhYzc4MTAyNzZmOGRjNzQ2ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-27T14:31:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-27T14:31:43Z"}, "message": "Auto merge of #49202 - csmoe:trait_engine, r=nikomatsakis\n\nIntroduce trait engine\n\naddress #48895 step 1: introduce trait engine", "tree": {"sha": "9a5112d740d092f45119a6f184a7e134010df174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a5112d740d092f45119a6f184a7e134010df174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c9424de51da41fd3d1077ac7810276f8dc746fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9424de51da41fd3d1077ac7810276f8dc746fa", "html_url": "https://github.com/rust-lang/rust/commit/9c9424de51da41fd3d1077ac7810276f8dc746fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c9424de51da41fd3d1077ac7810276f8dc746fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3efe61c825e1d49dc6febeb252954b9532c0c677", "url": "https://api.github.com/repos/rust-lang/rust/commits/3efe61c825e1d49dc6febeb252954b9532c0c677", "html_url": "https://github.com/rust-lang/rust/commit/3efe61c825e1d49dc6febeb252954b9532c0c677"}, {"sha": "39712e5721f92ca94f556d3b67f5bd60b592ebc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/39712e5721f92ca94f556d3b67f5bd60b592ebc2", "html_url": "https://github.com/rust-lang/rust/commit/39712e5721f92ca94f556d3b67f5bd60b592ebc2"}], "stats": {"total": 314, "additions": 196, "deletions": 118}, "files": [{"sha": "4bc64acc7630690ddae18eda0394d5bfbe7bd3d0", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -11,7 +11,7 @@\n use infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use traits::FulfillmentContext;\n+use traits::{FulfillmentContext, TraitEngine};\n use ty::{self, Ty, TypeFoldable};\n use ty::outlives::Component;\n use ty::wf;"}, {"sha": "8eee6f35ab9565680c6de5376fe7584d1fc7a607", "filename": "src/librustc/traits/engine.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fengine.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use ty::{self, Ty, TyCtxt};\n+use hir::def_id::DefId;\n+\n+use super::{FulfillmentContext, FulfillmentError};\n+use super::{ObligationCause, PendingPredicateObligation, PredicateObligation};\n+\n+pub trait TraitEngine<'tcx>: 'tcx {\n+    fn normalize_projection_type<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        projection_ty: ty::ProjectionTy<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+    ) -> Ty<'tcx>;\n+\n+    fn register_bound<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        def_id: DefId,\n+        cause: ObligationCause<'tcx>,\n+    );\n+\n+    fn register_predicate_obligation<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    );\n+\n+    fn select_all_or_error<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn select_where_possible<'a, 'gcx>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n+\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> dyn TraitEngine<'tcx> {\n+    pub fn new(_tcx: TyCtxt<'_, '_, 'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+\n+    pub fn register_predicate_obligations<I>(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        obligations: I,\n+    ) where\n+        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+}"}, {"sha": "1c091d68a2ef1474271ff7cb64f858a560c05b67", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -21,6 +21,7 @@ use middle::const_val::{ConstEvalErr, ErrKind};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n+use super::engine::TraitEngine;\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation, Obligation};\n use super::project;\n@@ -85,19 +86,72 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n+    {\n+        for obligation in obligations {\n+            self.register_predicate_obligation(infcx, obligation);\n+        }\n+    }\n+\n+    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n+    /// only attempts to select obligations that haven't been seen before.\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            debug!(\"select: starting another iteration\");\n+\n+            // Process pending obligations.\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n+            debug!(\"select: outcome={:?}\", outcome);\n+\n+            // FIXME: if we kept the original cache key, we could mark projection\n+            // obligations as complete for the projection cache here.\n+\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n+\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n+                break;\n+            }\n+        }\n+\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// \"Normalize\" a projection type `<SomeType as SomeTrait>::X` by\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     projection_ty: ty::ProjectionTy<'tcx>,\n-                                     cause: ObligationCause<'tcx>)\n-                                     -> Ty<'tcx>\n+    fn normalize_projection_type<'a, 'gcx>(&mut self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 projection_ty: ty::ProjectionTy<'tcx>,\n+                                 cause: ObligationCause<'tcx>)\n+                                 -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -125,12 +179,12 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Requires that `ty` must implement the trait with `def_id` in\n     /// the given environment. This trait must not have any type\n     /// parameters (except for `Self`).\n-    pub fn register_bound(&mut self,\n-                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                          param_env: ty::ParamEnv<'tcx>,\n-                          ty: Ty<'tcx>,\n-                          def_id: DefId,\n-                          cause: ObligationCause<'tcx>)\n+    fn register_bound<'a, 'gcx>(&mut self,\n+                      infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      ty: Ty<'tcx>,\n+                      def_id: DefId,\n+                      cause: ObligationCause<'tcx>)\n     {\n         let trait_ref = ty::TraitRef {\n             def_id,\n@@ -144,9 +198,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                         obligation: PredicateObligation<'tcx>)\n+    fn register_predicate_obligation<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -162,19 +216,9 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations<I>(&mut self,\n-                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                             obligations: I)\n-        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n-    {\n-        for obligation in obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-    }\n-\n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_all_or_error<'a, 'gcx>(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -190,58 +234,17 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    fn select_where_possible<'a, 'gcx>(&mut self,\n+                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                             -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+    fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n         self.predicates.pending_obligations()\n     }\n-\n-    /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n-    /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n-              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n-        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n-\n-        let mut errors = Vec::new();\n-\n-        loop {\n-            debug!(\"select: starting another iteration\");\n-\n-            // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                selcx,\n-                register_region_obligations: self.register_region_obligations\n-            });\n-            debug!(\"select: outcome={:?}\", outcome);\n-\n-            // FIXME: if we kept the original cache key, we could mark projection\n-            // obligations as complete for the projection cache here.\n-\n-            errors.extend(\n-                outcome.errors.into_iter()\n-                              .map(|e| to_fulfillment_error(e)));\n-\n-            // If nothing new was added, no need to keep looping.\n-            if outcome.stalled {\n-                break;\n-            }\n-        }\n-\n-        debug!(\"select({} predicates remaining, {} errors) done\",\n-               self.predicates.len(), errors.len());\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {"}, {"sha": "1d5d3e41c9c9a4e628a3ce5b8ecf7b71dd94ba4a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -34,7 +34,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n-pub use self::fulfill::FulfillmentContext;\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal, Normalized};\n@@ -45,6 +45,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::IntercrateAmbiguityCause;\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n+pub use self::engine::TraitEngine;\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -54,6 +55,7 @@ pub use self::util::transitive_bounds;\n \n mod coherence;\n pub mod error_reporting;\n+mod engine;\n mod fulfill;\n mod project;\n mod object_safety;"}, {"sha": "a9d1c8bcc3d995865bb03b7eab182060fa2112ac", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -26,7 +26,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n-use traits::{self, ObligationCause};\n+use traits::{self, ObligationCause, TraitEngine};\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;"}, {"sha": "31e851126d76ad495b8abf0d2513357d890c6ef4", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -18,7 +18,8 @@ use std::marker::PhantomData;\n use syntax_pos::DUMMY_SP;\n use infer::InferCtxt;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n+use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext,\n+             TraitEngine, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::TypeFoldable;"}, {"sha": "544cb5eefc8868a86ba3a2adf9e33d56d7647e7e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -20,7 +20,7 @@ use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n-use rustc::traits::{self, Normalized, FulfillmentContext};\n+use rustc::traits::{self, Normalized, TraitEngine};\n use rustc::traits::query::NoSolution;\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     where\n         OP: FnOnce(&mut Self) -> InferResult<'tcx, R>,\n     {\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(self.infcx.tcx);\n         let InferOk { value, obligations } = self.infcx.commit_if_ok(|_| op(self))?;\n         fulfill_cx.register_predicate_obligations(self.infcx, obligations);\n         if let Err(e) = fulfill_cx.select_all_or_error(self.infcx) {"}, {"sha": "aeefd5ab1d5aca903db44e5e8b20d7d2e4e3744b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::const_val::ConstVal;\n-use rustc::traits;\n+use rustc::traits::{self, TraitEngine};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n use rustc::ty::maps::Providers;"}, {"sha": "bff070ab73de342f06fab3ac80c225277594057e", "filename": "src/librustc_traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -12,7 +12,7 @@ use rustc::infer::InferCtxt;\n use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraints,\n                               QueryResult};\n use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc::traits::FulfillmentContext;\n+use rustc::traits::{FulfillmentContext, TraitEngine};\n use rustc::traits::query::NoSolution;\n use rustc::ty;\n use std::fmt::Debug;"}, {"sha": "d508b6df924c23895c011c26714fc09911afa32f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{ObligationCause, TraitEngine};\n use util::common::ErrorReported;\n \n use syntax::ast;\n@@ -84,7 +84,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let mut fulfillment_cx = TraitEngine::new(tcx);\n \n         let named_type = tcx.type_of(self_type_did);\n "}, {"sha": "0f0f59c28f8259c7d4fd874959cc3720d277fc9b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -95,7 +95,7 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n-use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n@@ -195,7 +195,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n-    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n+    fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n@@ -634,7 +634,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n                 maybe_tables: infcx.in_progress_tables,\n             },\n             infcx,\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n@@ -2910,7 +2910,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n+                let ures = self.at(&origin, self.param_env).sup(ret_ty, &formal_ret);\n \n                 // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n                 // to identity so the resulting type is not constrained.\n@@ -2921,7 +2921,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // out unconstrained or ambiguous, as we're\n                         // just trying to get hints here.\n                         self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = FulfillmentContext::new();\n+                            let mut fulfill = TraitEngine::new(self.tcx);\n                             for obligation in ok.obligations {\n                                 fulfill.register_predicate_obligation(self, obligation);\n                             }"}, {"sha": "aa4322783c606741805d835572e949208cc3cb79", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -15,7 +15,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{self, TraitEngine, ObligationCause};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n@@ -172,34 +172,34 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n-    let coerce_unsized_trait = tcx.lang_items().coerce_unsized_trait().unwrap();\n+    let coerce_unsized_trait = gcx.lang_items().coerce_unsized_trait().unwrap();\n \n-    let unsize_trait = match tcx.lang_items().require(UnsizeTraitLangItem) {\n+    let unsize_trait = match gcx.lang_items().require(UnsizeTraitLangItem) {\n         Ok(id) => id,\n         Err(err) => {\n-            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            gcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n         }\n     };\n \n     // this provider should only get invoked for local def-ids\n-    let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n+    let impl_node_id = gcx.hir.as_local_node_id(impl_did).unwrap_or_else(|| {\n         bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n     });\n \n-    let source = tcx.type_of(impl_did);\n-    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let source = gcx.type_of(impl_did);\n+    let trait_ref = gcx.impl_trait_ref(impl_did).unwrap();\n     assert_eq!(trait_ref.def_id, coerce_unsized_trait);\n     let target = trait_ref.substs.type_at(1);\n     debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n            source,\n            target);\n \n-    let span = tcx.hir.span(impl_node_id);\n-    let param_env = tcx.param_env(impl_did);\n+    let span = gcx.hir.span(impl_node_id);\n+    let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n@@ -208,11 +208,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    gcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n-        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                           mt_b: ty::TypeAndMut<'tcx>,\n-                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n+                           mt_b: ty::TypeAndMut<'gcx>,\n+                           mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n             if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                 infcx.report_mismatched_types(&cause,\n                                              mk_ptr(mt_b.ty),\n@@ -225,20 +225,20 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n             (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ref(r_b, ty))\n             }\n \n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n             (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+                check_mutbl(mt_a, mt_b, &|ty| gcx.mk_imm_ptr(ty))\n             }\n \n             (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) if def_a.is_struct() &&\n                                                                           def_b.is_struct() => {\n                 if def_a != def_b {\n-                    let source_path = tcx.item_path_str(def_a.did);\n-                    let target_path = tcx.item_path_str(def_b.did);\n-                    span_err!(tcx.sess,\n+                    let source_path = gcx.item_path_str(def_a.did);\n+                    let target_path = gcx.item_path_str(def_b.did);\n+                    span_err!(gcx.sess,\n                               span,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n@@ -292,9 +292,9 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let diff_fields = fields.iter()\n                     .enumerate()\n                     .filter_map(|(i, f)| {\n-                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+                        let (a, b) = (f.ty(gcx, substs_a), f.ty(gcx, substs_b));\n \n-                        if tcx.type_of(f.did).is_phantom_data() {\n+                        if gcx.type_of(f.did).is_phantom_data() {\n                             // Ignore PhantomData fields\n                             return None;\n                         }\n@@ -321,22 +321,22 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     .collect::<Vec<_>>();\n \n                 if diff_fields.is_empty() {\n-                    span_err!(tcx.sess,\n+                    span_err!(gcx.sess,\n                               span,\n                               E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with one field \\\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = tcx.hir.expect_item(impl_node_id);\n+                    let item = gcx.hir.expect_item(impl_node_id);\n                     let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        tcx.hir.span(impl_node_id)\n+                        gcx.hir.span(impl_node_id)\n                     };\n \n-                    let mut err = struct_span_err!(tcx.sess,\n+                    let mut err = struct_span_err!(gcx.sess,\n                                                    span,\n                                                    E0375,\n                                                    \"implementing the trait \\\n@@ -363,7 +363,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             _ => {\n-                span_err!(tcx.sess,\n+                span_err!(gcx.sess,\n                           span,\n                           E0376,\n                           \"the trait `CoerceUnsized` may only be implemented \\\n@@ -372,11 +372,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n \n         // Register an obligation for `A: Trait<B>`.\n         let cause = traits::ObligationCause::misc(span, impl_node_id);\n-        let predicate = tcx.predicate_for_trait_def(param_env,\n+        let predicate = gcx.predicate_for_trait_def(param_env,\n                                                     cause,\n                                                     trait_def_id,\n                                                     0,"}, {"sha": "86c5e49d1674bc9603416532e5e0b60947f34520", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9424de51da41fd3d1077ac7810276f8dc746fa/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9c9424de51da41fd3d1077ac7810276f8dc746fa", "patch": "@@ -88,6 +88,7 @@ This API is completely unstable and subject to change.\n #![feature(slice_patterns)]\n #![cfg_attr(stage0, feature(i128_type))]\n #![cfg_attr(stage0, feature(never_type))]\n+#![feature(dyn_trait)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -111,7 +112,7 @@ use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::traits::{FulfillmentContext, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine};\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -160,7 +161,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 -> bool {\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n         match infcx.at(&cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);"}]}