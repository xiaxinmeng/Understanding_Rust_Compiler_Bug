{"sha": "86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "node_id": "C_kwDOAAsO6NoAKDg2YzY1ZDJjMWNlNWFiYTJjMWM3NDI5OGMzZTQyNjk2Y2ZmMWQ0MWE", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-05T21:40:07Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-10-23T19:30:16Z"}, "message": "Implement Rust foreign exception protection for EMCC and SEH", "tree": {"sha": "6e1713508320bde39e1df020e1e6f438bbb9b38a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e1713508320bde39e1df020e1e6f438bbb9b38a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "html_url": "https://github.com/rust-lang/rust/commit/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e521a8d46b4437f94ba1bb85826bb7d00ba13436", "url": "https://api.github.com/repos/rust-lang/rust/commits/e521a8d46b4437f94ba1bb85826bb7d00ba13436", "html_url": "https://github.com/rust-lang/rust/commit/e521a8d46b4437f94ba1bb85826bb7d00ba13436"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "57e817ce6ad5449e6c81f28ca50ec6ad6643db5a", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "patch": "@@ -47,7 +47,12 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n     name: b\"rust_panic\\0\".as_ptr(),\n };\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const TypeInfo,\n+\n     // This is necessary because C++ code can capture our exception with\n     // std::exception_ptr and rethrow it multiple times, possibly even in\n     // another thread.\n@@ -70,16 +75,21 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let catch_data = &*(ptr as *mut CatchData);\n \n     let adjusted_ptr = __cxa_begin_catch(catch_data.ptr as *mut libc::c_void) as *mut Exception;\n-    let out = if catch_data.is_rust_panic {\n-        let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n-        if was_caught {\n-            // Since cleanup() isn't allowed to panic, we just abort instead.\n-            intrinsics::abort();\n-        }\n-        (*adjusted_ptr).data.take().unwrap()\n-    } else {\n+    if !catch_data.is_rust_panic {\n         super::__rust_foreign_exception();\n-    };\n+    }\n+\n+    let canary = ptr::addr_of!((*adjusted_ptr).canary).read();\n+    if !ptr::eq(canary, &EXCEPTION_TYPE_INFO) {\n+        super::__rust_foreign_exception();\n+    }\n+\n+    let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n+    if was_caught {\n+        // Since cleanup() isn't allowed to panic, we just abort instead.\n+        intrinsics::abort();\n+    }\n+    let out = (*adjusted_ptr).data.take().unwrap();\n     __cxa_end_catch();\n     out\n }\n@@ -90,7 +100,14 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception, Exception { caught: AtomicBool::new(false), data: Some(data) });\n+    ptr::write(\n+        exception,\n+        Exception {\n+            canary: &EXCEPTION_TYPE_INFO,\n+            caught: AtomicBool::new(false),\n+            data: Some(data),\n+        },\n+    );\n     __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n }\n "}, {"sha": "651115a8248ac50886c88de41fc1cabc71f66626", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86c65d2c1ce5aba2c1c74298c3e42696cff1d41a/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=86c65d2c1ce5aba2c1c74298c3e42696cff1d41a", "patch": "@@ -49,9 +49,15 @@\n use alloc::boxed::Box;\n use core::any::Any;\n use core::mem::{self, ManuallyDrop};\n+use core::ptr;\n use libc::{c_int, c_uint, c_void};\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const _TypeDescriptor,\n+\n     // This needs to be an Option because we catch the exception by reference\n     // and its destructor is executed by the C++ runtime. When we take the Box\n     // out of the exception, we need to leave the exception in a valid state\n@@ -235,7 +241,7 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n macro_rules! define_cleanup {\n     ($abi:tt $abi2:tt) => {\n         unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n-            if let Exception { data: Some(b) } = e.read() {\n+            if let Exception { data: Some(b), .. } = e.read() {\n                 drop(b);\n                 super::__rust_drop_panic();\n             }\n@@ -265,7 +271,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // The ManuallyDrop is needed here since we don't want Exception to be\n     // dropped when unwinding. Instead it will be dropped by exception_cleanup\n     // which is invoked by the C++ runtime.\n-    let mut exception = ManuallyDrop::new(Exception { data: Some(data) });\n+    let mut exception = ManuallyDrop::new(Exception { canary: &TYPE_DESCRIPTOR, data: Some(data) });\n     let throw_ptr = &mut exception as *mut _ as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n@@ -321,8 +327,12 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n     // __rust_try. This happens when a non-Rust foreign exception is caught.\n     if payload.is_null() {\n         super::__rust_foreign_exception();\n-    } else {\n-        let exception = &mut *(payload as *mut Exception);\n-        exception.data.take().unwrap()\n     }\n+    let exception = payload as *mut Exception;\n+    let canary = ptr::addr_of!((*exception).canary).read();\n+    if !ptr::eq(canary, &TYPE_DESCRIPTOR) {\n+        // A foreign Rust exception.\n+        super::__rust_foreign_exception();\n+    }\n+    (*exception).data.take().unwrap()\n }"}]}