{"sha": "51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYTAwNThkNGMwMWNhOGE2NDA2NjUyOGY4MmFhNGJiN2NjNGZjNTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-24T20:10:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-24T20:10:54Z"}, "message": "Merge #3998 #4006\n\n3998: Make add_function generate functions in other modules via qualified path r=matklad a=TimoFreiberg\n\nAdditional feature for #3639 \r\n\r\n- [x] Add tests for paths with more segments\r\n- [x] Make generating the function in another file work\r\n- [x] Add `pub` or `pub(crate)` to the generated function if it's generated in a different module\r\n- [x] Make the assist jump to the edited file\r\n- [x] Enable file support in the `check_assist` helper\n\n4006: Syntax highlighting for format strings r=matklad a=ltentrup\n\nI have an implementation for syntax highlighting for format string modifiers `{}`.\r\nThe first commit refactors the changes in #3826 into a separate struct.\r\nThe second commit implements the highlighting: first we check in a macro call whether the macro is a format macro from `std`. In this case, we remember the format string node. If we encounter this node during syntax highlighting, we check for the format modifiers `{}` using regular expressions.\r\n\r\nThere are a few places which I am not quite sure:\r\n- Is the way I extract the macro names correct?\r\n- Is the `HighlightTag::Attribute` suitable for highlighting the `{}`?\r\n\r\nLet me know what you think, any feedback is welcome!\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>\nCo-authored-by: Leander Tentrup <leander.tentrup@gmail.com>\nCo-authored-by: Leander Tentrup <ltentrup@users.noreply.github.com>", "tree": {"sha": "b20a5fcfcb8980dd0228c72d79f31761ba6e84e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b20a5fcfcb8980dd0228c72d79f31761ba6e84e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeo0fOCRBK7hj4Ov3rIwAAdHIIAKBNFIDxfHTcBz5YjLzq6Zbq\nFo4O7lnO5fLbQSOd4FHoLfGnohT5GY80/9rifEoH3Sc9L62cEZ/gLAp3M9PLdjk9\n4+HMCuCw3+CGPUk2Zvqt2BhvliJcihKP7PkKAvGCoNm2/9kOwil5CEmtprcOCqff\n5rGwda2eEm3PrHm2oMoWSP4r9WmwJMXWGucEvt2iscdkjiGYDVvgVDp+wdDZeVb+\npiyl/WK8j2WW5BnMgloOLvfev4fXD5nV9BuJ3+msg2IchQ7IwXTFPFpROGGfIHoT\nCN8KW7JolwcTWghk8WDge04CPePDqILY78PRMIqLvChDT91L0KzkQm55v03BJqU=\n=EG8z\n-----END PGP SIGNATURE-----\n", "payload": "tree b20a5fcfcb8980dd0228c72d79f31761ba6e84e7\nparent e55b1833ffe896179d9d97ebec9caaf9256e0616\nparent f2f882bc44a85eb13276a8fbda7533d94e92e3af\nparent 445052f6d426043b543033f3fa4594fc1a09d7fa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587759054 +0000\ncommitter GitHub <noreply@github.com> 1587759054 +0000\n\nMerge #3998 #4006\n\n3998: Make add_function generate functions in other modules via qualified path r=matklad a=TimoFreiberg\n\nAdditional feature for #3639 \r\n\r\n- [x] Add tests for paths with more segments\r\n- [x] Make generating the function in another file work\r\n- [x] Add `pub` or `pub(crate)` to the generated function if it's generated in a different module\r\n- [x] Make the assist jump to the edited file\r\n- [x] Enable file support in the `check_assist` helper\n\n4006: Syntax highlighting for format strings r=matklad a=ltentrup\n\nI have an implementation for syntax highlighting for format string modifiers `{}`.\r\nThe first commit refactors the changes in #3826 into a separate struct.\r\nThe second commit implements the highlighting: first we check in a macro call whether the macro is a format macro from `std`. In this case, we remember the format string node. If we encounter this node during syntax highlighting, we check for the format modifiers `{}` using regular expressions.\r\n\r\nThere are a few places which I am not quite sure:\r\n- Is the way I extract the macro names correct?\r\n- Is the `HighlightTag::Attribute` suitable for highlighting the `{}`?\r\n\r\nLet me know what you think, any feedback is welcome!\n\nCo-authored-by: Timo Freiberg <timo.freiberg@gmail.com>\nCo-authored-by: Leander Tentrup <leander.tentrup@gmail.com>\nCo-authored-by: Leander Tentrup <ltentrup@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "html_url": "https://github.com/rust-lang/rust/commit/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e55b1833ffe896179d9d97ebec9caaf9256e0616", "url": "https://api.github.com/repos/rust-lang/rust/commits/e55b1833ffe896179d9d97ebec9caaf9256e0616", "html_url": "https://github.com/rust-lang/rust/commit/e55b1833ffe896179d9d97ebec9caaf9256e0616"}, {"sha": "f2f882bc44a85eb13276a8fbda7533d94e92e3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f882bc44a85eb13276a8fbda7533d94e92e3af", "html_url": "https://github.com/rust-lang/rust/commit/f2f882bc44a85eb13276a8fbda7533d94e92e3af"}, {"sha": "445052f6d426043b543033f3fa4594fc1a09d7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/445052f6d426043b543033f3fa4594fc1a09d7fa", "html_url": "https://github.com/rust-lang/rust/commit/445052f6d426043b543033f3fa4594fc1a09d7fa"}], "stats": {"total": 1035, "additions": 940, "deletions": 95}, "files": [{"sha": "2791632576541ccf556ba8bfe46febf657c7194e", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::{AssistAction, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n+use crate::{AssistAction, AssistFile, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n use algo::SyntaxRewriter;\n \n #[derive(Clone, Debug)]\n@@ -180,6 +180,7 @@ pub(crate) struct ActionBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextUnit>,\n     target: Option<TextRange>,\n+    file: AssistFile,\n }\n \n impl ActionBuilder {\n@@ -241,11 +242,16 @@ impl ActionBuilder {\n         algo::diff(&node, &new).into_text_edit(&mut self.edit)\n     }\n \n+    pub(crate) fn set_file(&mut self, assist_file: AssistFile) {\n+        self.file = assist_file\n+    }\n+\n     fn build(self) -> AssistAction {\n         AssistAction {\n             edit: self.edit.finish(),\n             cursor_position: self.cursor_position,\n             target: self.target,\n+            file: self.file,\n         }\n     }\n }"}, {"sha": "e4fa9ee366e44e3b34a74fb8ab4b9af0f30d0e1b", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -66,15 +66,15 @@ fn doctest_add_function() {\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar<|>(\"\", baz());\n+    bar<|>(\"\", baz());\n }\n \n \"#####,\n         r#####\"\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar(\"\", baz());\n+    bar(\"\", baz());\n }\n \n fn bar(arg: &str, baz: Baz) {"}, {"sha": "f185cffdb7c359ee136b4ed6296fb6fcf4833a7b", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 209, "deletions": 27, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -3,8 +3,8 @@ use ra_syntax::{\n     SyntaxKind, SyntaxNode, TextUnit,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, CallExpr, Expr};\n+use crate::{Assist, AssistCtx, AssistFile, AssistId};\n+use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n use hir::HirDisplay;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -16,7 +16,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // struct Baz;\n // fn baz() -> Baz { Baz }\n // fn foo() {\n-//      bar<|>(\"\", baz());\n+//     bar<|>(\"\", baz());\n // }\n //\n // ```\n@@ -25,7 +25,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // struct Baz;\n // fn baz() -> Baz { Baz }\n // fn foo() {\n-//      bar(\"\", baz());\n+//     bar(\"\", baz());\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n@@ -38,21 +38,30 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n \n-    if path.qualifier().is_some() {\n-        return None;\n-    }\n-\n     if ctx.sema.resolve_path(&path).is_some() {\n         // The function call already resolves, no need to add a function\n         return None;\n     }\n \n-    let function_builder = FunctionBuilder::from_call(&ctx, &call)?;\n+    let target_module = if let Some(qualifier) = path.qualifier() {\n+        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) =\n+            ctx.sema.resolve_path(&qualifier)\n+        {\n+            Some(module.definition_source(ctx.sema.db))\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n         edit.target(call.syntax().text_range());\n \n         if let Some(function_template) = function_builder.render() {\n+            edit.set_file(function_template.file);\n             edit.set_cursor(function_template.cursor_offset);\n             edit.insert(function_template.insert_offset, function_template.fn_def.to_string());\n         }\n@@ -63,29 +72,67 @@ struct FunctionTemplate {\n     insert_offset: TextUnit,\n     cursor_offset: TextUnit,\n     fn_def: ast::SourceFile,\n+    file: AssistFile,\n }\n \n struct FunctionBuilder {\n-    append_fn_at: SyntaxNode,\n+    target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n+    file: AssistFile,\n+    needs_pub: bool,\n }\n \n impl FunctionBuilder {\n-    fn from_call(ctx: &AssistCtx, call: &ast::CallExpr) -> Option<Self> {\n-        let append_fn_at = next_space_for_fn(&call)?;\n-        let fn_name = fn_name(&call)?;\n+    /// Prepares a generated function that matches `call` in `generate_in`\n+    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    fn from_call(\n+        ctx: &AssistCtx,\n+        call: &ast::CallExpr,\n+        path: &ast::Path,\n+        target_module: Option<hir::InFile<hir::ModuleSource>>,\n+    ) -> Option<Self> {\n+        let needs_pub = target_module.is_some();\n+        let mut file = AssistFile::default();\n+        let target = if let Some(target_module) = target_module {\n+            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n+            file = in_file;\n+            target\n+        } else {\n+            next_space_for_fn_after_call_site(&call)?\n+        };\n+        let fn_name = fn_name(&path)?;\n         let (type_params, params) = fn_args(ctx, &call)?;\n-        Some(Self { append_fn_at, fn_name, type_params, params })\n+        Some(Self { target, fn_name, type_params, params, file, needs_pub })\n     }\n+\n     fn render(self) -> Option<FunctionTemplate> {\n         let placeholder_expr = ast::make::expr_todo();\n         let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n-        let fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        let fn_def = ast::make::add_newlines(2, fn_def);\n-        let fn_def = IndentLevel::from_node(&self.append_fn_at).increase_indent(fn_def);\n-        let insert_offset = self.append_fn_at.text_range().end();\n+        let mut fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n+        if self.needs_pub {\n+            fn_def = ast::make::add_pub_crate_modifier(fn_def);\n+        }\n+\n+        let (fn_def, insert_offset) = match self.target {\n+            GeneratedFunctionTarget::BehindItem(it) => {\n+                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n+                let indented = IndentLevel::from_node(&it).increase_indent(with_leading_blank_line);\n+                (indented, it.text_range().end())\n+            }\n+            GeneratedFunctionTarget::InEmptyItemList(it) => {\n+                let indent_once = IndentLevel(1);\n+                let indent = IndentLevel::from_node(it.syntax());\n+\n+                let fn_def = ast::make::add_leading_newlines(1, fn_def);\n+                let fn_def = indent_once.increase_indent(fn_def);\n+                let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n+                let fn_def = indent.increase_indent(fn_def);\n+                (fn_def, it.syntax().text_range().start() + TextUnit::from_usize(1))\n+            }\n+        };\n+\n         let cursor_offset_from_fn_start = fn_def\n             .syntax()\n             .descendants()\n@@ -94,19 +141,24 @@ impl FunctionBuilder {\n             .text_range()\n             .start();\n         let cursor_offset = insert_offset + cursor_offset_from_fn_start;\n-        Some(FunctionTemplate { insert_offset, cursor_offset, fn_def })\n+        Some(FunctionTemplate { insert_offset, cursor_offset, fn_def, file: self.file })\n     }\n }\n \n-fn fn_name(call: &CallExpr) -> Option<ast::Name> {\n-    let name = call.expr()?.syntax().to_string();\n+enum GeneratedFunctionTarget {\n+    BehindItem(SyntaxNode),\n+    InEmptyItemList(ast::ItemList),\n+}\n+\n+fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n+    let name = call.segment()?.syntax().to_string();\n     Some(ast::make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n     ctx: &AssistCtx,\n-    call: &CallExpr,\n+    call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n@@ -158,9 +210,9 @@ fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n     }\n }\n \n-fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n+fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     match fn_arg {\n-        Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n+        ast::Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n         _ => Some(\n             fn_arg\n                 .syntax()\n@@ -172,7 +224,7 @@ fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n+fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n@@ -184,7 +236,7 @@ fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n /// directly after the current block\n /// We want to write the generated function directly after\n /// fns, impls or macro calls, but inside mods\n-fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n+fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFunctionTarget> {\n     let mut ancestors = expr.syntax().ancestors().peekable();\n     let mut last_ancestor: Option<SyntaxNode> = None;\n     while let Some(next_ancestor) = ancestors.next() {\n@@ -201,7 +253,32 @@ fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n         }\n         last_ancestor = Some(next_ancestor);\n     }\n-    last_ancestor\n+    last_ancestor.map(GeneratedFunctionTarget::BehindItem)\n+}\n+\n+fn next_space_for_fn_in_module(\n+    db: &dyn hir::db::AstDatabase,\n+    module: hir::InFile<hir::ModuleSource>,\n+) -> Option<(AssistFile, GeneratedFunctionTarget)> {\n+    let file = module.file_id.original_file(db);\n+    let assist_file = AssistFile::TargetFile(file);\n+    let assist_item = match module.value {\n+        hir::ModuleSource::SourceFile(it) => {\n+            if let Some(last_item) = it.items().last() {\n+                GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n+            } else {\n+                GeneratedFunctionTarget::BehindItem(it.syntax().clone())\n+            }\n+        }\n+        hir::ModuleSource::Module(it) => {\n+            if let Some(last_item) = it.item_list().and_then(|it| it.items().last()) {\n+                GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n+            } else {\n+                GeneratedFunctionTarget::InEmptyItemList(it.item_list()?)\n+            }\n+        }\n+    };\n+    Some((assist_file, assist_item))\n }\n \n #[cfg(test)]\n@@ -713,6 +790,111 @@ fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n         )\n     }\n \n+    #[test]\n+    fn add_function_in_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {}\n+\n+fn foo() {\n+    bar::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    pub(crate) fn my_fn() {\n+        <|>todo!()\n+    }\n+}\n+\n+fn foo() {\n+    bar::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_in_module_containing_other_items() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {\n+    fn something_else() {}\n+}\n+\n+fn foo() {\n+    bar::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    fn something_else() {}\n+\n+    pub(crate) fn my_fn() {\n+        <|>todo!()\n+    }\n+}\n+\n+fn foo() {\n+    bar::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_in_nested_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {\n+    mod baz {}\n+}\n+\n+fn foo() {\n+    bar::baz::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    mod baz {\n+        pub(crate) fn my_fn() {\n+            <|>todo!()\n+        }\n+    }\n+}\n+\n+fn foo() {\n+    bar::baz::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_in_another_file() {\n+        check_assist(\n+            add_function,\n+            r\"\n+//- /main.rs\n+mod foo;\n+\n+fn main() {\n+    foo::bar<|>()\n+}\n+//- /foo.rs\n+\",\n+            r\"\n+\n+\n+pub(crate) fn bar() {\n+    <|>todo!()\n+}\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_not_applicable_if_function_already_exists() {\n         check_assist_not_applicable("}, {"sha": "ccc95735f789f6244a512cfab85c87e8fae7109c", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -17,7 +17,7 @@ mod doc_tests;\n pub mod utils;\n pub mod ast_transform;\n \n-use ra_db::FileRange;\n+use ra_db::{FileId, FileRange};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n@@ -54,6 +54,7 @@ pub struct AssistAction {\n     pub cursor_position: Option<TextUnit>,\n     // FIXME: This belongs to `AssistLabel`\n     pub target: Option<TextRange>,\n+    pub file: AssistFile,\n }\n \n #[derive(Debug, Clone)]\n@@ -63,6 +64,18 @@ pub struct ResolvedAssist {\n     pub action: AssistAction,\n }\n \n+#[derive(Debug, Clone, Copy)]\n+pub enum AssistFile {\n+    CurrentFile,\n+    TargetFile(FileId),\n+}\n+\n+impl Default for AssistFile {\n+    fn default() -> Self {\n+        Self::CurrentFile\n+    }\n+}\n+\n /// Return all the assists applicable at the given position.\n ///\n /// Assists are returned in the \"unresolved\" state, that is only labels are\n@@ -184,7 +197,7 @@ mod helpers {\n     use ra_ide_db::{symbol_index::SymbolsDatabase, RootDatabase};\n     use test_utils::{add_cursor, assert_eq_text, extract_range_or_offset, RangeOrOffset};\n \n-    use crate::{AssistCtx, AssistHandler};\n+    use crate::{AssistCtx, AssistFile, AssistHandler};\n     use hir::Semantics;\n \n     pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n@@ -246,7 +259,13 @@ mod helpers {\n             (Some(assist), ExpectedResult::After(after)) => {\n                 let action = assist.0[0].action.clone().unwrap();\n \n-                let mut actual = action.edit.apply(&text_without_caret);\n+                let assisted_file_text = if let AssistFile::TargetFile(file_id) = action.file {\n+                    db.file_text(file_id).as_ref().to_owned()\n+                } else {\n+                    text_without_caret\n+                };\n+\n+                let mut actual = action.edit.apply(&assisted_file_text);\n                 match action.cursor_position {\n                     None => {\n                         if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {"}, {"sha": "2b5d11681af79fe725f86bc89411a4ab505b3264", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -37,6 +37,10 @@ fn action_to_edit(\n     file_id: FileId,\n     assist_label: &AssistLabel,\n ) -> SourceChange {\n+    let file_id = match action.file {\n+        ra_assists::AssistFile::TargetFile(it) => it,\n+        _ => file_id,\n+    };\n     let file_edit = SourceFileEdit { file_id, edit: action.edit };\n     SourceChange::source_file_edit(assist_label.label.clone(), file_edit)\n         .with_cursor_opt(action.cursor_position.map(|offset| FilePosition { offset, file_id }))"}, {"sha": "433f2e0c5e91eb8c5d328781ff36e6dfe40616d7", "filename": "crates/ra_ide/src/snapshots/highlight_strings.html", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsnapshots%2Fhighlight_strings.html?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -0,0 +1,82 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.variable           { color: #DCDCCC; }\n+.mutable            { text-decoration: underline; }\n+\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+</style>\n+<pre><code><span class=\"macro\">macro_rules!</span> println {\n+    ($($arg:tt)*) =&gt; ({\n+        $<span class=\"keyword\">crate</span>::io::_print($<span class=\"keyword\">crate</span>::format_args_nl!($($arg)*));\n+    })\n+}\n+#[rustc_builtin_macro]\n+<span class=\"macro\">macro_rules!</span> format_args_nl {\n+    ($fmt:expr) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n+    ($fmt:expr, $($args:tt)*) =&gt; {{ <span class=\"comment\">/* compiler built-in */</span> }};\n+}\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span>() {\n+    <span class=\"comment\">// from https://doc.rust-lang.org/std/fmt/index.html</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello\"</span>);                 <span class=\"comment\">// =&gt; \"Hello\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello, </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"world\"</span>);   <span class=\"comment\">// =&gt; \"Hello, world!\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"The number is </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>);   <span class=\"comment\">// =&gt; \"The number is 1\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">?</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, (<span class=\"numeric_literal\">3</span>, <span class=\"numeric_literal\">4</span>));          <span class=\"comment\">// =&gt; \"(3, 4)\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">value</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, value=<span class=\"numeric_literal\">4</span>);      <span class=\"comment\">// =&gt; \"4\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, <span class=\"numeric_literal\">2</span>);           <span class=\"comment\">// =&gt; \"1 2\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">4</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">42</span>);             <span class=\"comment\">// =&gt; \"0042\" with leading zerosV</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, <span class=\"numeric_literal\">2</span>);   <span class=\"comment\">// =&gt; \"2 1 1 2\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">argument</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, argument = <span class=\"string_literal\">\"test\"</span>);   <span class=\"comment\">// =&gt; \"test\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">1</span>, name = <span class=\"numeric_literal\">2</span>);          <span class=\"comment\">// =&gt; \"2 1\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">a</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"variable\">c</span><span class=\"attribute\">}</span><span class=\"string_literal\"> </span><span class=\"attribute\">{</span><span class=\"variable\">b</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, a=<span class=\"string_literal\">\"a\"</span>, b=<span class=\"char_literal\">'b'</span>, c=<span class=\"numeric_literal\">3</span>);  <span class=\"comment\">// =&gt; \"a 3 b\"</span>\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"variable\">width</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>, width = <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">&lt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">-</span><span class=\"attribute\">&lt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">^</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">&gt;</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"x\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">+</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">#</span><span class=\"variable\">x</span><span class=\"string_literal\">}!\"</span>, <span class=\"numeric_literal\">27</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, -<span class=\"numeric_literal\">5</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">#</span><span class=\"numeric_literal\">0</span><span class=\"numeric_literal\">10</span><span class=\"variable\">x</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"numeric_literal\">27</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">5</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">0</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"numeric_literal\">1</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>,    <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"numeric_literal\">2</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>,   <span class=\"string_literal\">\"x\"</span>, <span class=\"numeric_literal\">5</span>, <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\"> is </span><span class=\"attribute\">{</span><span class=\"variable\">number</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"variable\">prec</span><span class=\"attribute\">$</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, <span class=\"string_literal\">\"x\"</span>, prec = <span class=\"numeric_literal\">5</span>, number = <span class=\"numeric_literal\">0.01</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 fractional digits\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"numeric_literal\">1234.56</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 characters\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"string_literal\">\"1234.56\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">, `</span><span class=\"attribute\">{</span><span class=\"variable\">name</span><span class=\"attribute\">:</span><span class=\"attribute\">&gt;</span><span class=\"numeric_literal\">8</span><span class=\"attribute\">.</span><span class=\"attribute\">*</span><span class=\"attribute\">}</span><span class=\"string_literal\">` has 3 right-aligned characters\"</span>, <span class=\"string_literal\">\"Hello\"</span>, <span class=\"numeric_literal\">3</span>, name=<span class=\"string_literal\">\"1234.56\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"Hello {{}}\"</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"{{ Hello\"</span>);\n+\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">r\"Hello, </span><span class=\"attribute\">{</span><span class=\"attribute\">}</span><span class=\"string_literal\">!\"</span>, <span class=\"string_literal\">\"world\"</span>);\n+\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">\\x41</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, A = <span class=\"numeric_literal\">92</span>);\n+    <span class=\"macro\">println!</span>(<span class=\"string_literal\">\"</span><span class=\"attribute\">{</span><span class=\"variable\">\u043d\u0438\u0447\u043e\u0441\u0438</span><span class=\"attribute\">}</span><span class=\"string_literal\">\"</span>, \u043d\u0438\u0447\u043e\u0441\u0438 = <span class=\"numeric_literal\">92</span>);\n+}</code></pre>\n\\ No newline at end of file"}, {"sha": "c0728bfb1299f3a4dba0ef005786fe9d932be728", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 168, "deletions": 56, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -12,7 +12,7 @@ use ra_ide_db::{\n };\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, HasQuotes, HasStringValue},\n+    ast::{self, HasFormatSpecifier, HasQuotes, HasStringValue},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n     SyntaxToken, TextRange, WalkEvent, T,\n@@ -21,6 +21,7 @@ use rustc_hash::FxHashMap;\n \n use crate::{call_info::ActiveParameter, Analysis, FileId};\n \n+use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n@@ -31,6 +32,81 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n+#[derive(Debug)]\n+struct HighlightedRangeStack {\n+    stack: Vec<Vec<HighlightedRange>>,\n+}\n+\n+/// We use a stack to implement the flattening logic for the highlighted\n+/// syntax ranges.\n+impl HighlightedRangeStack {\n+    fn new() -> Self {\n+        Self { stack: vec![Vec::new()] }\n+    }\n+\n+    fn push(&mut self) {\n+        self.stack.push(Vec::new());\n+    }\n+\n+    /// Flattens the highlighted ranges.\n+    ///\n+    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+    /// 1) parent-range: Attribute [0, 23)\n+    /// 2) child-range: String [16, 21)\n+    ///\n+    /// The following code implements the flattening, for our example this results to:\n+    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+    fn pop(&mut self) {\n+        let children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        let needs_flattening = !children.is_empty()\n+            && !prev.is_empty()\n+            && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n+        if !needs_flattening {\n+            prev.extend(children);\n+        } else {\n+            let mut parent = prev.pop().unwrap();\n+            for ele in children {\n+                assert!(ele.range.is_subrange(&parent.range));\n+                let mut cloned = parent.clone();\n+                parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n+                if !parent.range.is_empty() {\n+                    prev.push(parent);\n+                }\n+                prev.push(ele);\n+                parent = cloned;\n+            }\n+            if !parent.range.is_empty() {\n+                prev.push(parent);\n+            }\n+        }\n+    }\n+\n+    fn add(&mut self, range: HighlightedRange) {\n+        self.stack\n+            .last_mut()\n+            .expect(\"during DFS traversal, the stack must not be empty\")\n+            .push(range)\n+    }\n+\n+    fn flattened(mut self) -> Vec<HighlightedRange> {\n+        assert_eq!(\n+            self.stack.len(),\n+            1,\n+            \"after DFS traversal, the stack should only contain a single element\"\n+        );\n+        let mut res = self.stack.pop().unwrap();\n+        res.sort_by_key(|range| range.range.start());\n+        // Check that ranges are sorted and disjoint\n+        assert!(res\n+            .iter()\n+            .zip(res.iter().skip(1))\n+            .all(|(left, right)| left.range.end() <= right.range.start()));\n+        res\n+    }\n+}\n+\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -57,52 +133,18 @@ pub(crate) fn highlight(\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n     // We use a stack for the DFS traversal below.\n     // When we leave a node, the we use it to flatten the highlighted ranges.\n-    let mut res: Vec<Vec<HighlightedRange>> = vec![Vec::new()];\n+    let mut stack = HighlightedRangeStack::new();\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n+    let mut format_string: Option<SyntaxElement> = None;\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n         match &event {\n-            WalkEvent::Enter(_) => res.push(Vec::new()),\n-            WalkEvent::Leave(_) => {\n-                /* Flattens the highlighted ranges.\n-                 *\n-                 * For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-                 * 1) parent-range: Attribute [0, 23)\n-                 * 2) child-range: String [16, 21)\n-                 *\n-                 * The following code implements the flattening, for our example this results to:\n-                 * `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-                 */\n-                let children = res.pop().unwrap();\n-                let prev = res.last_mut().unwrap();\n-                let needs_flattening = !children.is_empty()\n-                    && !prev.is_empty()\n-                    && children.first().unwrap().range.is_subrange(&prev.last().unwrap().range);\n-                if !needs_flattening {\n-                    prev.extend(children);\n-                } else {\n-                    let mut parent = prev.pop().unwrap();\n-                    for ele in children {\n-                        assert!(ele.range.is_subrange(&parent.range));\n-                        let mut cloned = parent.clone();\n-                        parent.range = TextRange::from_to(parent.range.start(), ele.range.start());\n-                        cloned.range = TextRange::from_to(ele.range.end(), cloned.range.end());\n-                        if !parent.range.is_empty() {\n-                            prev.push(parent);\n-                        }\n-                        prev.push(ele);\n-                        parent = cloned;\n-                    }\n-                    if !parent.range.is_empty() {\n-                        prev.push(parent);\n-                    }\n-                }\n-            }\n+            WalkEvent::Enter(_) => stack.push(),\n+            WalkEvent::Leave(_) => stack.pop(),\n         };\n-        let current = res.last_mut().expect(\"during DFS traversal, the stack must not be empty\");\n \n         let event_range = match &event {\n             WalkEvent::Enter(it) => it.text_range(),\n@@ -119,7 +161,7 @@ pub(crate) fn highlight(\n             WalkEvent::Enter(Some(mc)) => {\n                 current_macro_call = Some(mc.clone());\n                 if let Some(range) = macro_call_range(&mc) {\n-                    current.push(HighlightedRange {\n+                    stack.add(HighlightedRange {\n                         range,\n                         highlight: HighlightTag::Macro.into(),\n                         binding_hash: None,\n@@ -130,6 +172,7 @@ pub(crate) fn highlight(\n             WalkEvent::Leave(Some(mc)) => {\n                 assert!(current_macro_call == Some(mc));\n                 current_macro_call = None;\n+                format_string = None;\n                 continue;\n             }\n             _ => (),\n@@ -150,6 +193,30 @@ pub(crate) fn highlight(\n             };\n             let token = sema.descend_into_macros(token.clone());\n             let parent = token.parent();\n+\n+            // Check if macro takes a format string and remember it for highlighting later.\n+            // The macros that accept a format string expand to a compiler builtin macros\n+            // `format_args` and `format_args_nl`.\n+            if let Some(fmt_macro_call) = parent.parent().and_then(ast::MacroCall::cast) {\n+                if let Some(name) =\n+                    fmt_macro_call.path().and_then(|p| p.segment()).and_then(|s| s.name_ref())\n+                {\n+                    match name.text().as_str() {\n+                        \"format_args\" | \"format_args_nl\" => {\n+                            format_string = parent\n+                                .children_with_tokens()\n+                                .filter(|t| t.kind() != WHITESPACE)\n+                                .nth(1)\n+                                .filter(|e| {\n+                                    ast::String::can_cast(e.kind())\n+                                        || ast::RawString::can_cast(e.kind())\n+                                })\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n             // We only care Name and Name_ref\n             match (token.kind(), parent.kind()) {\n                 (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n@@ -161,27 +228,72 @@ pub(crate) fn highlight(\n \n         if let Some(token) = element.as_token().cloned().and_then(ast::RawString::cast) {\n             let expanded = element_to_highlight.as_token().unwrap().clone();\n-            if highlight_injection(current, &sema, token, expanded).is_some() {\n+            if highlight_injection(&mut stack, &sema, token, expanded).is_some() {\n                 continue;\n             }\n         }\n \n+        let is_format_string = format_string.as_ref() == Some(&element_to_highlight);\n+\n         if let Some((highlight, binding_hash)) =\n-            highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight)\n+            highlight_element(&sema, &mut bindings_shadow_count, element_to_highlight.clone())\n         {\n-            current.push(HighlightedRange { range, highlight, binding_hash });\n+            stack.add(HighlightedRange { range, highlight, binding_hash });\n+            if let Some(string) =\n+                element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n+            {\n+                stack.push();\n+                if is_format_string {\n+                    string.lex_format_specifier(|piece_range, kind| {\n+                        if let Some(highlight) = highlight_format_specifier(kind) {\n+                            stack.add(HighlightedRange {\n+                                range: piece_range + range.start(),\n+                                highlight: highlight.into(),\n+                                binding_hash: None,\n+                            });\n+                        }\n+                    });\n+                }\n+                stack.pop();\n+            } else if let Some(string) =\n+                element_to_highlight.as_token().cloned().and_then(ast::RawString::cast)\n+            {\n+                stack.push();\n+                if is_format_string {\n+                    string.lex_format_specifier(|piece_range, kind| {\n+                        if let Some(highlight) = highlight_format_specifier(kind) {\n+                            stack.add(HighlightedRange {\n+                                range: piece_range + range.start(),\n+                                highlight: highlight.into(),\n+                                binding_hash: None,\n+                            });\n+                        }\n+                    });\n+                }\n+                stack.pop();\n+            }\n         }\n     }\n \n-    assert_eq!(res.len(), 1, \"after DFS traversal, the stack should only contain a single element\");\n-    let mut res = res.pop().unwrap();\n-    res.sort_by_key(|range| range.range.start());\n-    // Check that ranges are sorted and disjoint\n-    assert!(res\n-        .iter()\n-        .zip(res.iter().skip(1))\n-        .all(|(left, right)| left.range.end() <= right.range.start()));\n-    res\n+    stack.flattened()\n+}\n+\n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+    Some(match kind {\n+        FormatSpecifier::Open\n+        | FormatSpecifier::Close\n+        | FormatSpecifier::Colon\n+        | FormatSpecifier::Fill\n+        | FormatSpecifier::Align\n+        | FormatSpecifier::Sign\n+        | FormatSpecifier::NumberSign\n+        | FormatSpecifier::DollarSign\n+        | FormatSpecifier::Dot\n+        | FormatSpecifier::Asterisk\n+        | FormatSpecifier::QuestionMark => HighlightTag::Attribute,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HighlightTag::Local,\n+    })\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n@@ -359,7 +471,7 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n }\n \n fn highlight_injection(\n-    acc: &mut Vec<HighlightedRange>,\n+    acc: &mut HighlightedRangeStack,\n     sema: &Semantics<RootDatabase>,\n     literal: ast::RawString,\n     expanded: SyntaxToken,\n@@ -372,7 +484,7 @@ fn highlight_injection(\n     let (analysis, tmp_file_id) = Analysis::from_single_file(value);\n \n     if let Some(range) = literal.open_quote_text_range() {\n-        acc.push(HighlightedRange {\n+        acc.add(HighlightedRange {\n             range,\n             highlight: HighlightTag::StringLiteral.into(),\n             binding_hash: None,\n@@ -382,12 +494,12 @@ fn highlight_injection(\n     for mut h in analysis.highlight(tmp_file_id).unwrap() {\n         if let Some(r) = literal.map_range_up(h.range) {\n             h.range = r;\n-            acc.push(h)\n+            acc.add(h)\n         }\n     }\n \n     if let Some(range) = literal.close_quote_text_range() {\n-        acc.push(HighlightedRange {\n+        acc.add(HighlightedRange {\n             range,\n             highlight: HighlightTag::StringLiteral.into(),\n             binding_hash: None,"}, {"sha": "a9aae957f0134022c3aa6f75cd36705e246c0e88", "filename": "crates/ra_ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -168,3 +168,73 @@ macro_rules! test {}\n     );\n     let _ = analysis.highlight(file_id).unwrap();\n }\n+\n+#[test]\n+fn test_string_highlighting() {\n+    // The format string detection is based on macro-expansion,\n+    // thus, we have to copy the macro definition from `std`\n+    let (analysis, file_id) = single_file(\n+        r#\"\n+macro_rules! println {\n+    ($($arg:tt)*) => ({\n+        $crate::io::_print($crate::format_args_nl!($($arg)*));\n+    })\n+}\n+#[rustc_builtin_macro]\n+macro_rules! format_args_nl {\n+    ($fmt:expr) => {{ /* compiler built-in */ }};\n+    ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n+}\n+\n+fn main() {\n+    // from https://doc.rust-lang.org/std/fmt/index.html\n+    println!(\"Hello\");                 // => \"Hello\"\n+    println!(\"Hello, {}!\", \"world\");   // => \"Hello, world!\"\n+    println!(\"The number is {}\", 1);   // => \"The number is 1\"\n+    println!(\"{:?}\", (3, 4));          // => \"(3, 4)\"\n+    println!(\"{value}\", value=4);      // => \"4\"\n+    println!(\"{} {}\", 1, 2);           // => \"1 2\"\n+    println!(\"{:04}\", 42);             // => \"0042\" with leading zerosV\n+    println!(\"{1} {} {0} {}\", 1, 2);   // => \"2 1 1 2\"\n+    println!(\"{argument}\", argument = \"test\");   // => \"test\"\n+    println!(\"{name} {}\", 1, name = 2);          // => \"2 1\"\n+    println!(\"{a} {c} {b}\", a=\"a\", b='b', c=3);  // => \"a 3 b\"\n+    println!(\"Hello {:5}!\", \"x\");\n+    println!(\"Hello {:1$}!\", \"x\", 5);\n+    println!(\"Hello {1:0$}!\", 5, \"x\");\n+    println!(\"Hello {:width$}!\", \"x\", width = 5);\n+    println!(\"Hello {:<5}!\", \"x\");\n+    println!(\"Hello {:-<5}!\", \"x\");\n+    println!(\"Hello {:^5}!\", \"x\");\n+    println!(\"Hello {:>5}!\", \"x\");\n+    println!(\"Hello {:+}!\", 5);\n+    println!(\"{:#x}!\", 27);\n+    println!(\"Hello {:05}!\", 5);\n+    println!(\"Hello {:05}!\", -5);\n+    println!(\"{:#010x}!\", 27);\n+    println!(\"Hello {0} is {1:.5}\", \"x\", 0.01);\n+    println!(\"Hello {1} is {2:.0$}\", 5, \"x\", 0.01);\n+    println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n+    println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n+    println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+    println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n+    println!(\"{}, `{name:.*}` has 3 fractional digits\", \"Hello\", 3, name=1234.56);\n+    println!(\"{}, `{name:.*}` has 3 characters\", \"Hello\", 3, name=\"1234.56\");\n+    println!(\"{}, `{name:>8.*}` has 3 right-aligned characters\", \"Hello\", 3, name=\"1234.56\");\n+    println!(\"Hello {{}}\");\n+    println!(\"{{ Hello\");\n+\n+    println!(r\"Hello, {}!\", \"world\");\n+\n+    println!(\"{\\x41}\", A = 92);\n+    println!(\"{\u043d\u0438\u0447\u043e\u0441\u0438}\", \u043d\u0438\u0447\u043e\u0441\u0438 = 92);\n+}\"#\n+        .trim(),\n+    );\n+\n+    let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlight_strings.html\");\n+    let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n+    let expected_html = &read_text(&dst_file);\n+    fs::write(dst_file, &actual_html).unwrap();\n+    assert_eq_text!(expected_html, actual_html);\n+}"}, {"sha": "ee0f5cc406a47380b559b262f9f22bb18298cbf4", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -293,11 +293,20 @@ pub fn fn_def(\n     ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n }\n \n-pub fn add_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+pub fn add_leading_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n     let newlines = \"\\n\".repeat(amount_of_newlines);\n     ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n }\n \n+pub fn add_trailing_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+    let newlines = \"\\n\".repeat(amount_of_newlines);\n+    ast_from_text(&format!(\"{}{}\", t.syntax(), newlines))\n+}\n+\n+pub fn add_pub_crate_modifier(fn_def: ast::FnDef) -> ast::FnDef {\n+    ast_from_text(&format!(\"pub(crate) {}\", fn_def))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let node = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}, {"sha": "aa34b682d92ed75534427fcadc074c340d1f10be", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -172,3 +172,362 @@ impl RawString {\n         Some(range + contents_range.start())\n     }\n }\n+\n+#[derive(Debug)]\n+pub enum FormatSpecifier {\n+    Open,\n+    Close,\n+    Integer,\n+    Identifier,\n+    Colon,\n+    Fill,\n+    Align,\n+    Sign,\n+    NumberSign,\n+    Zero,\n+    DollarSign,\n+    Dot,\n+    Asterisk,\n+    QuestionMark,\n+}\n+\n+pub trait HasFormatSpecifier: AstToken {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>>;\n+\n+    fn lex_format_specifier<F>(&self, mut callback: F)\n+    where\n+        F: FnMut(TextRange, FormatSpecifier),\n+    {\n+        let char_ranges = if let Some(char_ranges) = self.char_ranges() {\n+            char_ranges\n+        } else {\n+            return;\n+        };\n+        let mut chars = char_ranges.iter().peekable();\n+\n+        while let Some((range, first_char)) = chars.next() {\n+            match first_char {\n+                Ok('{') => {\n+                    // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n+                    if let Some((_, Ok('{'))) = chars.peek() {\n+                        // Escaped format specifier, `{{`\n+                        chars.next();\n+                        continue;\n+                    }\n+\n+                    callback(*range, FormatSpecifier::Open);\n+\n+                    // check for integer/identifier\n+                    match chars\n+                        .peek()\n+                        .and_then(|next| next.1.as_ref().ok())\n+                        .copied()\n+                        .unwrap_or_default()\n+                    {\n+                        '0'..='9' => {\n+                            // integer\n+                            read_integer(&mut chars, &mut callback);\n+                        }\n+                        c if c == '_' || c.is_alphabetic() => {\n+                            // identifier\n+                            read_identifier(&mut chars, &mut callback);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    if let Some((_, Ok(':'))) = chars.peek() {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n+\n+                        // check for fill/align\n+                        let mut cloned = chars.clone().take(2);\n+                        let first = cloned\n+                            .next()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default();\n+                        let second = cloned\n+                            .next()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default();\n+                        match second {\n+                            '<' | '^' | '>' => {\n+                                // alignment specifier, first char specifies fillment\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::Fill,\n+                                    &mut callback,\n+                                );\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::Align,\n+                                    &mut callback,\n+                                );\n+                            }\n+                            _ => match first {\n+                                '<' | '^' | '>' => {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        FormatSpecifier::Align,\n+                                        &mut callback,\n+                                    );\n+                                }\n+                                _ => {}\n+                            },\n+                        }\n+\n+                        // check for sign\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n+                            '+' | '-' => {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::Sign,\n+                                    &mut callback,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+\n+                        // check for `#`\n+                        if let Some((_, Ok('#'))) = chars.peek() {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::NumberSign,\n+                                &mut callback,\n+                            );\n+                        }\n+\n+                        // check for `0`\n+                        let mut cloned = chars.clone().take(2);\n+                        let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+                        let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+\n+                        if first == Some('0') && second != Some('$') {\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n+                        }\n+\n+                        // width\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n+                            '0'..='9' => {\n+                                read_integer(&mut chars, &mut callback);\n+                                if let Some((_, Ok('$'))) = chars.peek() {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        FormatSpecifier::DollarSign,\n+                                        &mut callback,\n+                                    );\n+                                }\n+                            }\n+                            c if c == '_' || c.is_alphabetic() => {\n+                                read_identifier(&mut chars, &mut callback);\n+                                if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n+                                    != Some('$')\n+                                {\n+                                    continue;\n+                                }\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::DollarSign,\n+                                    &mut callback,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+\n+                        // precision\n+                        if let Some((_, Ok('.'))) = chars.peek() {\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n+\n+                            match chars\n+                                .peek()\n+                                .and_then(|next| next.1.as_ref().ok())\n+                                .copied()\n+                                .unwrap_or_default()\n+                            {\n+                                '*' => {\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        FormatSpecifier::Asterisk,\n+                                        &mut callback,\n+                                    );\n+                                }\n+                                '0'..='9' => {\n+                                    read_integer(&mut chars, &mut callback);\n+                                    if let Some((_, Ok('$'))) = chars.peek() {\n+                                        skip_char_and_emit(\n+                                            &mut chars,\n+                                            FormatSpecifier::DollarSign,\n+                                            &mut callback,\n+                                        );\n+                                    }\n+                                }\n+                                c if c == '_' || c.is_alphabetic() => {\n+                                    read_identifier(&mut chars, &mut callback);\n+                                    if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n+                                        != Some('$')\n+                                    {\n+                                        continue;\n+                                    }\n+                                    skip_char_and_emit(\n+                                        &mut chars,\n+                                        FormatSpecifier::DollarSign,\n+                                        &mut callback,\n+                                    );\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+\n+                        // type\n+                        match chars\n+                            .peek()\n+                            .and_then(|next| next.1.as_ref().ok())\n+                            .copied()\n+                            .unwrap_or_default()\n+                        {\n+                            '?' => {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::QuestionMark,\n+                                    &mut callback,\n+                                );\n+                            }\n+                            c if c == '_' || c.is_alphabetic() => {\n+                                read_identifier(&mut chars, &mut callback);\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    let mut cloned = chars.clone().take(2);\n+                    let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+                    let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n+                    if first != Some('}') {\n+                        continue;\n+                    }\n+                    if second == Some('}') {\n+                        // Escaped format end specifier, `}}`\n+                        continue;\n+                    }\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n+                }\n+                _ => {\n+                    while let Some((_, Ok(next_char))) = chars.peek() {\n+                        match next_char {\n+                            '{' => break,\n+                            _ => {}\n+                        }\n+                        chars.next();\n+                    }\n+                }\n+            };\n+        }\n+\n+        fn skip_char_and_emit<'a, I, F>(\n+            chars: &mut std::iter::Peekable<I>,\n+            emit: FormatSpecifier,\n+            callback: &mut F,\n+        ) where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let (range, _) = chars.next().unwrap();\n+            callback(*range, emit);\n+        }\n+\n+        fn read_integer<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+        where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let (mut range, c) = chars.next().unwrap();\n+            assert!(c.as_ref().unwrap().is_ascii_digit());\n+            while let Some((r, Ok(next_char))) = chars.peek() {\n+                if next_char.is_ascii_digit() {\n+                    chars.next();\n+                    range = range.extend_to(r);\n+                } else {\n+                    break;\n+                }\n+            }\n+            callback(range, FormatSpecifier::Integer);\n+        }\n+\n+        fn read_identifier<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+        where\n+            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            F: FnMut(TextRange, FormatSpecifier),\n+        {\n+            let (mut range, c) = chars.next().unwrap();\n+            assert!(c.as_ref().unwrap().is_alphabetic() || *c.as_ref().unwrap() == '_');\n+            while let Some((r, Ok(next_char))) = chars.peek() {\n+                if *next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n+                    chars.next();\n+                    range = range.extend_to(r);\n+                } else {\n+                    break;\n+                }\n+            }\n+            callback(range, FormatSpecifier::Identifier);\n+        }\n+    }\n+}\n+\n+impl HasFormatSpecifier for String {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>> {\n+        let text = self.text().as_str();\n+        let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n+        let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n+\n+        let mut res = Vec::with_capacity(text.len());\n+        rustc_lexer::unescape::unescape_str(text, &mut |range, unescaped_char| {\n+            res.push((\n+                TextRange::from_to(\n+                    TextUnit::from_usize(range.start),\n+                    TextUnit::from_usize(range.end),\n+                ) + offset,\n+                unescaped_char,\n+            ))\n+        });\n+\n+        Some(res)\n+    }\n+}\n+\n+impl HasFormatSpecifier for RawString {\n+    fn char_ranges(\n+        &self,\n+    ) -> Option<Vec<(TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>> {\n+        let text = self.text().as_str();\n+        let text = &text[self.text_range_between_quotes()? - self.syntax().text_range().start()];\n+        let offset = self.text_range_between_quotes()?.start() - self.syntax().text_range().start();\n+\n+        let mut res = Vec::with_capacity(text.len());\n+        for (idx, c) in text.char_indices() {\n+            res.push((\n+                TextRange::from_to(\n+                    TextUnit::from_usize(idx),\n+                    TextUnit::from_usize(idx + c.len_utf8()),\n+                ) + offset,\n+                Ok(c),\n+            ));\n+        }\n+        Some(res)\n+    }\n+}"}, {"sha": "6c6943622301109350b75639e08281dc8341c893", "filename": "docs/user/assists.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -65,15 +65,15 @@ Adds a stub function with a signature matching the function under the cursor.\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar\u2503(\"\", baz());\n+    bar\u2503(\"\", baz());\n }\n \n \n // AFTER\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar(\"\", baz());\n+    bar(\"\", baz());\n }\n \n fn bar(arg: &str, baz: Baz) {"}, {"sha": "af8f1df51126aac4d2cdb7971af470174aab3b56", "filename": "editors/code/src/source_change.ts", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/editors%2Fcode%2Fsrc%2Fsource_change.ts", "raw_url": "https://github.com/rust-lang/rust/raw/51a0058d4c01ca8a64066528f82aa4bb7cc4fc54/editors%2Fcode%2Fsrc%2Fsource_change.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fsource_change.ts?ref=51a0058d4c01ca8a64066528f82aa4bb7cc4fc54", "patch": "@@ -37,11 +37,13 @@ export async function applySourceChange(ctx: Ctx, change: ra.SourceChange) {\n             toReveal.position,\n         );\n         const editor = vscode.window.activeTextEditor;\n-        if (!editor || editor.document.uri.toString() !== uri.toString()) {\n+        if (!editor || !editor.selection.isEmpty) {\n             return;\n         }\n-        if (!editor.selection.isEmpty) {\n-            return;\n+\n+        if (editor.document.uri !== uri) {\n+            const doc = await vscode.workspace.openTextDocument(uri);\n+            await vscode.window.showTextDocument(doc);\n         }\n         editor.selection = new vscode.Selection(position, position);\n         editor.revealRange("}]}