{"sha": "76bf7498aa88c4de4517f4eb1218807fdfc7071b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YmY3NDk4YWE4OGM0ZGU0NTE3ZjRlYjEyMTg4MDdmZGZjNzA3MWI=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-12T17:17:52Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:16Z"}, "message": "handle watched events filtering in `Vfs`add `is_overlayed`load changed files contents in `io`", "tree": {"sha": "e95b92ce0f54df298d59eb96450bd6bd06ba2939", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95b92ce0f54df298d59eb96450bd6bd06ba2939"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76bf7498aa88c4de4517f4eb1218807fdfc7071b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76bf7498aa88c4de4517f4eb1218807fdfc7071b", "html_url": "https://github.com/rust-lang/rust/commit/76bf7498aa88c4de4517f4eb1218807fdfc7071b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76bf7498aa88c4de4517f4eb1218807fdfc7071b/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b86f038d61752bbf306ed5dd9def74be3b5dcc1", "html_url": "https://github.com/rust-lang/rust/commit/6b86f038d61752bbf306ed5dd9def74be3b5dcc1"}], "stats": {"total": 361, "additions": 218, "deletions": 143}, "files": [{"sha": "b8c840c68576bb929a053127678eb9e4df71d429", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76bf7498aa88c4de4517f4eb1218807fdfc7071b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/76bf7498aa88c4de4517f4eb1218807fdfc7071b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=76bf7498aa88c4de4517f4eb1218807fdfc7071b", "patch": "@@ -1009,7 +1009,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"notify 4.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\","}, {"sha": "a0c87fb258b8135a3c53e1debdf72409986b19ef", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=76bf7498aa88c4de4517f4eb1218807fdfc7071b", "patch": "@@ -1,22 +1,21 @@\n use std::{\n-    fmt,\n-    fs,\n+    fmt, fs,\n     path::{Path, PathBuf},\n };\n \n-use walkdir::{DirEntry, WalkDir};\n-use thread_worker::{WorkerHandle};\n use relative_path::RelativePathBuf;\n+use thread_worker::WorkerHandle;\n+use walkdir::{DirEntry, WalkDir};\n \n-use crate::{VfsRoot, has_rs_extension};\n+use crate::{has_rs_extension, watcher::WatcherChange, VfsRoot};\n \n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n         path: PathBuf,\n         filter: Box<Fn(&DirEntry) -> bool + Send>,\n     },\n-    WatcherChange(crate::watcher::WatcherChange),\n+    LoadChange(crate::watcher::WatcherChange),\n }\n \n #[derive(Debug)]\n@@ -26,29 +25,16 @@ pub struct AddRootResult {\n }\n \n #[derive(Debug)]\n-pub enum WatcherChangeResult {\n-    Create {\n-        path: PathBuf,\n-        text: String,\n-    },\n-    Write {\n-        path: PathBuf,\n-        text: String,\n-    },\n-    Remove {\n-        path: PathBuf,\n-    },\n-    // can this be replaced and use Remove and Create instead?\n-    Rename {\n-        src: PathBuf,\n-        dst: PathBuf,\n-        text: String,\n-    },\n+pub enum WatcherChangeData {\n+    Create { path: PathBuf, text: String },\n+    Write { path: PathBuf, text: String },\n+    Remove { path: PathBuf },\n }\n \n pub enum TaskResult {\n     AddRoot(AddRootResult),\n-    WatcherChange(WatcherChangeResult),\n+    HandleChange(WatcherChange),\n+    LoadChange(Option<WatcherChangeData>),\n }\n \n impl fmt::Debug for TaskResult {\n@@ -77,9 +63,10 @@ fn handle_task(task: Task) -> TaskResult {\n             log::debug!(\"... loaded {}\", path.as_path().display());\n             TaskResult::AddRoot(AddRootResult { root, files })\n         }\n-        Task::WatcherChange(change) => {\n-            // TODO\n-            unimplemented!()\n+        Task::LoadChange(change) => {\n+            log::debug!(\"loading {:?} ...\", change);\n+            let data = load_change(change);\n+            TaskResult::LoadChange(data)\n         }\n     }\n }\n@@ -113,3 +100,34 @@ fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePa\n     }\n     res\n }\n+\n+fn load_change(change: WatcherChange) -> Option<WatcherChangeData> {\n+    let data = match change {\n+        WatcherChange::Create(path) => {\n+            let text = match fs::read_to_string(&path) {\n+                Ok(text) => text,\n+                Err(e) => {\n+                    log::warn!(\"watcher error: {}\", e);\n+                    return None;\n+                }\n+            };\n+            WatcherChangeData::Create { path, text }\n+        }\n+        WatcherChange::Write(path) => {\n+            let text = match fs::read_to_string(&path) {\n+                Ok(text) => text,\n+                Err(e) => {\n+                    log::warn!(\"watcher error: {}\", e);\n+                    return None;\n+                }\n+            };\n+            WatcherChangeData::Write { path, text }\n+        }\n+        WatcherChange::Remove(path) => WatcherChangeData::Remove { path },\n+        WatcherChange::Rescan => {\n+            // this should be handled by Vfs::handle_task\n+            return None;\n+        }\n+    };\n+    Some(data)\n+}"}, {"sha": "2930f6b805695ff88b13920fe313fdbbec5ebc8b", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 124, "deletions": 41, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=76bf7498aa88c4de4517f4eb1218807fdfc7071b", "patch": "@@ -75,6 +75,7 @@ impl_arena_id!(VfsFile);\n struct VfsFileData {\n     root: VfsRoot,\n     path: RelativePathBuf,\n+    is_overlayed: bool,\n     text: Arc<String>,\n }\n \n@@ -170,7 +171,7 @@ impl Vfs {\n             } else {\n                 let text = fs::read_to_string(path).unwrap_or_default();\n                 let text = Arc::new(text);\n-                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text));\n+                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text), false);\n                 let change = VfsChange::AddFile {\n                     file,\n                     text,\n@@ -205,7 +206,7 @@ impl Vfs {\n                         continue;\n                     }\n                     let text = Arc::new(text);\n-                    let file = self.add_file(task.root, path.clone(), Arc::clone(&text));\n+                    let file = self.add_file(task.root, path.clone(), Arc::clone(&text), false);\n                     files.push((file, path, text));\n                 }\n \n@@ -215,63 +216,132 @@ impl Vfs {\n                 };\n                 self.pending_changes.push(change);\n             }\n-            io::TaskResult::WatcherChange(change) => {\n-                // TODO\n-                unimplemented!()\n+            io::TaskResult::HandleChange(change) => match &change {\n+                watcher::WatcherChange::Create(path)\n+                | watcher::WatcherChange::Remove(path)\n+                | watcher::WatcherChange::Write(path) => {\n+                    if self.should_handle_change(&path) {\n+                        self.worker.inp.send(io::Task::LoadChange(change)).unwrap()\n+                    }\n+                }\n+                watcher::WatcherChange::Rescan => {\n+                    // TODO send Task::AddRoot?\n+                }\n+            },\n+            io::TaskResult::LoadChange(None) => {}\n+            io::TaskResult::LoadChange(Some(change)) => match change {\n+                io::WatcherChangeData::Create { path, text }\n+                | io::WatcherChangeData::Write { path, text } => {\n+                    if let Some((root, path, file)) = self.find_root(&path) {\n+                        if let Some(file) = file {\n+                            self.do_change_file(file, text, false);\n+                        } else {\n+                            self.do_add_file(root, path, text, false);\n+                        }\n+                    }\n+                }\n+                io::WatcherChangeData::Remove { path } => {\n+                    if let Some((root, path, file)) = self.find_root(&path) {\n+                        if let Some(file) = file {\n+                            self.do_remove_file(root, path, file, false);\n+                        }\n+                    }\n+                }\n+            },\n+        }\n+    }\n+\n+    fn should_handle_change(&self, path: &Path) -> bool {\n+        if let Some((_root, _rel_path, file)) = self.find_root(&path) {\n+            if let Some(file) = file {\n+                if self.files[file].is_overlayed {\n+                    // file is overlayed\n+                    return false;\n+                }\n             }\n+            true\n+        } else {\n+            // file doesn't belong to any root\n+            false\n         }\n     }\n \n+    fn do_add_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: String,\n+        is_overlay: bool,\n+    ) -> Option<VfsFile> {\n+        let text = Arc::new(text);\n+        let file = self.add_file(root, path.clone(), text.clone(), is_overlay);\n+        self.pending_changes.push(VfsChange::AddFile {\n+            file,\n+            root,\n+            path,\n+            text,\n+        });\n+        Some(file)\n+    }\n+\n+    fn do_change_file(&mut self, file: VfsFile, text: String, is_overlay: bool) {\n+        if !is_overlay && self.files[file].is_overlayed {\n+            return;\n+        }\n+        let text = Arc::new(text);\n+        self.change_file(file, text.clone(), is_overlay);\n+        self.pending_changes\n+            .push(VfsChange::ChangeFile { file, text });\n+    }\n+\n+    fn do_remove_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        file: VfsFile,\n+        is_overlay: bool,\n+    ) {\n+        if !is_overlay && self.files[file].is_overlayed {\n+            return;\n+        }\n+        self.remove_file(file);\n+        self.pending_changes\n+            .push(VfsChange::RemoveFile { root, path, file });\n+    }\n+\n     pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n-        let mut res = None;\n         if let Some((root, rel_path, file)) = self.find_root(path) {\n-            let text = Arc::new(text);\n-            let change = if let Some(file) = file {\n-                res = Some(file);\n-                self.change_file(file, Arc::clone(&text));\n-                VfsChange::ChangeFile { file, text }\n+            if let Some(file) = file {\n+                self.do_change_file(file, text, true);\n+                Some(file)\n             } else {\n-                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text));\n-                res = Some(file);\n-                VfsChange::AddFile {\n-                    file,\n-                    text,\n-                    root,\n-                    path: rel_path,\n-                }\n-            };\n-            self.pending_changes.push(change);\n+                self.do_add_file(root, rel_path, text, true)\n+            }\n+        } else {\n+            None\n         }\n-        res\n     }\n \n     pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n         if let Some((_root, _path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't change a file which wasn't added\");\n-            let text = Arc::new(new_text);\n-            self.change_file(file, Arc::clone(&text));\n-            let change = VfsChange::ChangeFile { file, text };\n-            self.pending_changes.push(change);\n+            self.do_change_file(file, new_text, true);\n         }\n     }\n \n     pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n-        let mut res = None;\n         if let Some((root, path, file)) = self.find_root(path) {\n             let file = file.expect(\"can't remove a file which wasn't added\");\n-            res = Some(file);\n             let full_path = path.to_path(&self.roots[root].root);\n-            let change = if let Ok(text) = fs::read_to_string(&full_path) {\n-                let text = Arc::new(text);\n-                self.change_file(file, Arc::clone(&text));\n-                VfsChange::ChangeFile { file, text }\n+            if let Ok(text) = fs::read_to_string(&full_path) {\n+                self.do_change_file(file, text, true);\n             } else {\n-                self.remove_file(file);\n-                VfsChange::RemoveFile { root, file, path }\n-            };\n-            self.pending_changes.push(change);\n+                self.do_remove_file(root, path, file, true);\n+            }\n+            Some(file)\n+        } else {\n+            None\n         }\n-        res\n     }\n \n     pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n@@ -285,15 +355,28 @@ impl Vfs {\n         self.worker_handle.shutdown()\n     }\n \n-    fn add_file(&mut self, root: VfsRoot, path: RelativePathBuf, text: Arc<String>) -> VfsFile {\n-        let data = VfsFileData { root, path, text };\n+    fn add_file(\n+        &mut self,\n+        root: VfsRoot,\n+        path: RelativePathBuf,\n+        text: Arc<String>,\n+        is_overlayed: bool,\n+    ) -> VfsFile {\n+        let data = VfsFileData {\n+            root,\n+            path,\n+            text,\n+            is_overlayed,\n+        };\n         let file = self.files.alloc(data);\n         self.root2files.get_mut(&root).unwrap().insert(file);\n         file\n     }\n \n-    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>) {\n-        self.files[file].text = new_text;\n+    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n+        let mut file_data = &mut self.files[file];\n+        file_data.text = new_text;\n+        file_data.is_overlayed = is_overlayed;\n     }\n \n     fn remove_file(&mut self, file: VfsFile) {"}, {"sha": "a5401869ce7e568bda9c3b047cd3a843d30a320f", "filename": "crates/ra_vfs/src/watcher.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs?ref=76bf7498aa88c4de4517f4eb1218807fdfc7071b", "patch": "@@ -5,10 +5,10 @@ use std::{\n     time::Duration,\n };\n \n+use crate::io;\n use crossbeam_channel::Sender;\n use drop_bomb::DropBomb;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n-use crate::{has_rs_extension, io};\n \n pub struct Watcher {\n     watcher: RecommendedWatcher,\n@@ -21,59 +21,41 @@ pub enum WatcherChange {\n     Create(PathBuf),\n     Write(PathBuf),\n     Remove(PathBuf),\n-    // can this be replaced and use Remove and Create instead?\n-    Rename(PathBuf, PathBuf),\n+    Rescan,\n }\n \n-impl WatcherChange {\n-    fn try_from_debounced_event(ev: DebouncedEvent) -> Option<WatcherChange> {\n-        match ev {\n-            DebouncedEvent::NoticeWrite(_)\n-            | DebouncedEvent::NoticeRemove(_)\n-            | DebouncedEvent::Chmod(_) => {\n-                // ignore\n-                None\n-            }\n-            DebouncedEvent::Rescan => {\n-                // TODO should we rescan the root?\n-                None\n-            }\n-            DebouncedEvent::Create(path) => {\n-                if has_rs_extension(&path) {\n-                    Some(WatcherChange::Create(path))\n-                } else {\n-                    None\n-                }\n-            }\n-            DebouncedEvent::Write(path) => {\n-                if has_rs_extension(&path) {\n-                    Some(WatcherChange::Write(path))\n-                } else {\n-                    None\n-                }\n-            }\n-            DebouncedEvent::Remove(path) => {\n-                if has_rs_extension(&path) {\n-                    Some(WatcherChange::Remove(path))\n-                } else {\n-                    None\n-                }\n-            }\n-            DebouncedEvent::Rename(src, dst) => {\n-                match (has_rs_extension(&src), has_rs_extension(&dst)) {\n-                    (true, true) => Some(WatcherChange::Rename(src, dst)),\n-                    (true, false) => Some(WatcherChange::Remove(src)),\n-                    (false, true) => Some(WatcherChange::Create(dst)),\n-                    (false, false) => None,\n-                }\n-            }\n-            DebouncedEvent::Error(err, path) => {\n-                // TODO should we reload the file contents?\n-                log::warn!(\"watch error {}, {:?}\", err, path);\n-                None\n-            }\n+fn send_change_events(\n+    ev: DebouncedEvent,\n+    sender: &Sender<io::Task>,\n+) -> Result<(), Box<std::error::Error>> {\n+    match ev {\n+        DebouncedEvent::NoticeWrite(_)\n+        | DebouncedEvent::NoticeRemove(_)\n+        | DebouncedEvent::Chmod(_) => {\n+            // ignore\n+        }\n+        DebouncedEvent::Rescan => {\n+            sender.send(io::Task::LoadChange(WatcherChange::Rescan))?;\n+        }\n+        DebouncedEvent::Create(path) => {\n+            sender.send(io::Task::LoadChange(WatcherChange::Create(path)))?;\n+        }\n+        DebouncedEvent::Write(path) => {\n+            sender.send(io::Task::LoadChange(WatcherChange::Write(path)))?;\n+        }\n+        DebouncedEvent::Remove(path) => {\n+            sender.send(io::Task::LoadChange(WatcherChange::Remove(path)))?;\n+        }\n+        DebouncedEvent::Rename(src, dst) => {\n+            sender.send(io::Task::LoadChange(WatcherChange::Remove(src)))?;\n+            sender.send(io::Task::LoadChange(WatcherChange::Create(dst)))?;\n+        }\n+        DebouncedEvent::Error(err, path) => {\n+            // TODO should we reload the file contents?\n+            log::warn!(\"watcher error {}, {:?}\", err, path);\n         }\n     }\n+    Ok(())\n }\n \n impl Watcher {\n@@ -86,8 +68,7 @@ impl Watcher {\n             input_receiver\n                 .into_iter()\n                 // forward relevant events only\n-                .filter_map(WatcherChange::try_from_debounced_event)\n-                .try_for_each(|change| output_sender.send(io::Task::WatcherChange(change)))\n+                .try_for_each(|change| send_change_events(change, &output_sender))\n                 .unwrap()\n         });\n         Ok(Watcher {"}, {"sha": "9cde2bed7faee5a4031c83d477eb4c98cbb0c9d7", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76bf7498aa88c4de4517f4eb1218807fdfc7071b/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=76bf7498aa88c4de4517f4eb1218807fdfc7071b", "patch": "@@ -4,6 +4,13 @@ use flexi_logger::Logger;\n use ra_vfs::{Vfs, VfsChange};\n use tempfile::tempdir;\n \n+fn process_tasks(vfs: &mut Vfs, num_tasks: u32) {\n+    for _ in 0..num_tasks {\n+        let task = vfs.task_receiver().recv().unwrap();\n+        vfs.handle_task(task);\n+    }\n+}\n+\n #[test]\n fn test_vfs_works() -> std::io::Result<()> {\n     Logger::with_str(\"debug\").start().unwrap();\n@@ -25,10 +32,7 @@ fn test_vfs_works() -> std::io::Result<()> {\n     let b_root = dir.path().join(\"a/b\");\n \n     let (mut vfs, _) = Vfs::new(vec![a_root, b_root]);\n-    for _ in 0..2 {\n-        let task = vfs.task_receiver().recv().unwrap();\n-        vfs.handle_task(task);\n-    }\n+    process_tasks(&mut vfs, 2);\n     {\n         let files = vfs\n             .commit_changes()\n@@ -57,30 +61,26 @@ fn test_vfs_works() -> std::io::Result<()> {\n         assert_eq!(files, expected_files);\n     }\n \n-    // on disk change\n     fs::write(&dir.path().join(\"a/b/baz.rs\"), \"quux\").unwrap();\n-    let task = vfs.task_receiver().recv().unwrap();\n-    vfs.handle_task(task);\n+    process_tasks(&mut vfs, 1);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"quux\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // in memory change\n     vfs.change_file_overlay(&dir.path().join(\"a/b/baz.rs\"), \"m\".to_string());\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"m\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // in memory remove, restores data on disk\n+    // removing overlay restores data on disk\n     vfs.remove_file_overlay(&dir.path().join(\"a/b/baz.rs\"));\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::ChangeFile { text, .. }] => assert_eq!(text.as_str(), \"quux\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // in memory add\n     vfs.add_file_overlay(&dir.path().join(\"a/b/spam.rs\"), \"spam\".to_string());\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::AddFile { text, path, .. }] => {\n@@ -90,17 +90,14 @@ fn test_vfs_works() -> std::io::Result<()> {\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // in memory remove\n     vfs.remove_file_overlay(&dir.path().join(\"a/b/spam.rs\"));\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::RemoveFile { path, .. }] => assert_eq!(path, \"spam.rs\"),\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // on disk add\n     fs::write(&dir.path().join(\"a/new.rs\"), \"new hello\").unwrap();\n-    let task = vfs.task_receiver().recv().unwrap();\n-    vfs.handle_task(task);\n+    process_tasks(&mut vfs, 1);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::AddFile { text, path, .. }] => {\n             assert_eq!(text.as_str(), \"new hello\");\n@@ -109,10 +106,8 @@ fn test_vfs_works() -> std::io::Result<()> {\n         _ => panic!(\"unexpected changes\"),\n     }\n \n-    // on disk rename\n     fs::rename(&dir.path().join(\"a/new.rs\"), &dir.path().join(\"a/new1.rs\")).unwrap();\n-    let task = vfs.task_receiver().recv().unwrap();\n-    vfs.handle_task(task);\n+    process_tasks(&mut vfs, 2);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::RemoveFile {\n             path: removed_path, ..\n@@ -125,13 +120,11 @@ fn test_vfs_works() -> std::io::Result<()> {\n             assert_eq!(added_path, \"new1.rs\");\n             assert_eq!(text.as_str(), \"new hello\");\n         }\n-        _ => panic!(\"unexpected changes\"),\n+        xs => panic!(\"unexpected changes {:?}\", xs),\n     }\n \n-    // on disk remove\n     fs::remove_file(&dir.path().join(\"a/new1.rs\")).unwrap();\n-    let task = vfs.task_receiver().recv().unwrap();\n-    vfs.handle_task(task);\n+    process_tasks(&mut vfs, 1);\n     match vfs.commit_changes().as_slice() {\n         [VfsChange::RemoveFile { path, .. }] => assert_eq!(path, \"new1.rs\"),\n         _ => panic!(\"unexpected changes\"),"}]}