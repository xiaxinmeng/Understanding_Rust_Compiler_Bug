{"sha": "c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZWM1NjcyMTRiMWJjZWZiNzZhYTIwYWU1OGZhNzgzMTJiNmVhOTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-03T23:38:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-03T23:38:55Z"}, "message": "Rollup merge of #62297 - matklad:peek-delimited, r=petrochenkov\n\nrefactor check_for_substitution\n\nNo behavior change, just flatter and simpler code.\n\nr? @petrochenkov", "tree": {"sha": "7ef51387053b2f476299bb14e9c64c465289fb4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ef51387053b2f476299bb14e9c64c465289fb4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdHTyPCRBK7hj4Ov3rIwAAdHIIABJMTXUKPeVBdwWT8Bl4zmoR\nIB52bX+X/2IkSA7E/b/7kl5Fy8gpUPtLFKbe/7maL+79cN01CWh/sQsZB6b6rPnU\nFi0UZC1zXMopN2mw52lwzAvjhISAcm5W0daQ4l6Wn6aePFSIO6uOFLrKU2f2q0GA\nBaKHb+36rbzaEzk8ytNGAxvCGsQOPh6+VkHe3ZTs/fmuWq236PRSkAM7lnoF1eaF\nPNeT/RDND5EJjd7BnjGy6RD232Tw144vF5C2mqdF3yvheUcCdDHePOO03OXhHZfH\ngzwimvi5zJhNPEaASNJKLuoQvppcLoLEblgLJyZwy0lFdjy59nJawh5CsqW4YIU=\n=eUwr\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ef51387053b2f476299bb14e9c64c465289fb4d\nparent 44f22e694cf62f6a1106d961136e3d77d7c33a11\nparent dc088b26ce39d8a4632d73e62e5440ae474a8cb5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562197135 +0200\ncommitter GitHub <noreply@github.com> 1562197135 +0200\n\nRollup merge of #62297 - matklad:peek-delimited, r=petrochenkov\n\nrefactor check_for_substitution\n\nNo behavior change, just flatter and simpler code.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "html_url": "https://github.com/rust-lang/rust/commit/c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0ec567214b1bcefb76aa20ae58fa78312b6ea92/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f22e694cf62f6a1106d961136e3d77d7c33a11", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f22e694cf62f6a1106d961136e3d77d7c33a11", "html_url": "https://github.com/rust-lang/rust/commit/44f22e694cf62f6a1106d961136e3d77d7c33a11"}, {"sha": "dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "html_url": "https://github.com/rust-lang/rust/commit/dc088b26ce39d8a4632d73e62e5440ae474a8cb5"}], "stats": {"total": 139, "additions": 72, "deletions": 67}, "files": [{"sha": "49f714e4e4654b2609d02ac1d91654ab04dd985a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0ec567214b1bcefb76aa20ae58fa78312b6ea92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0ec567214b1bcefb76aa20ae58fa78312b6ea92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "patch": "@@ -83,28 +83,6 @@ impl<'a> StringReader<'a> {\n         Ok(ret_val)\n     }\n \n-    /// Immutably extract string if found at current position with given delimiters\n-    fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<String> {\n-        let mut pos = self.pos;\n-        let mut idx = self.src_index(pos);\n-        let mut ch = char_at(&self.src, idx);\n-        if ch != from_ch {\n-            return None;\n-        }\n-        pos = pos + Pos::from_usize(ch.len_utf8());\n-        let start_pos = pos;\n-        idx = self.src_index(pos);\n-        while idx < self.end_src_index {\n-            ch = char_at(&self.src, idx);\n-            if ch == to_ch {\n-                return Some(self.src[self.src_index(start_pos)..self.src_index(pos)].to_string());\n-            }\n-            pos = pos + Pos::from_usize(ch.len_utf8());\n-            idx = self.src_index(pos);\n-        }\n-        return None;\n-    }\n-\n     fn try_real_token(&mut self) -> Result<Token, ()> {\n         let mut t = self.try_next_token()?;\n         loop {"}, {"sha": "6a870685938a04bb8463baf75a5c22b463b5e234", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c0ec567214b1bcefb76aa20ae58fa78312b6ea92/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0ec567214b1bcefb76aa20ae58fa78312b6ea92/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=c0ec567214b1bcefb76aa20ae58fa78312b6ea92", "patch": "@@ -1,10 +1,11 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n-use syntax_pos::{Span, Pos, NO_EXPANSION};\n-use errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n+use errors::{Applicability, DiagnosticBuilder};\n+use syntax_pos::{Pos, Span, NO_EXPANSION};\n \n+#[rustfmt::skip] // for line breaks\n const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\u2028', \"Line Separator\", ' '),\n     ('\u2029', \"Paragraph Separator\", ' '),\n@@ -293,8 +294,8 @@ const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\u232a', \"Right-Pointing Angle Bracket\", '>'),\n     ('\u3009', \"Right Angle Bracket\", '>'),\n     ('\u300b', \"Right Double Angle Bracket\", '>'),\n-    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'), ];\n-\n+    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'),\n+];\n \n const ASCII_ARRAY: &[(char, &str)] = &[\n     (' ', \"Space\"),\n@@ -321,46 +322,72 @@ const ASCII_ARRAY: &[(char, &str)] = &[\n     ('+', \"Plus Sign\"),\n     ('<', \"Less-Than Sign\"),\n     ('=', \"Equals Sign\"),\n-    ('>', \"Greater-Than Sign\"), ];\n-\n-crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n-                                  ch: char,\n-                                  err: &mut DiagnosticBuilder<'a>) -> bool {\n-    UNICODE_ARRAY\n-    .iter()\n-    .find(|&&(c, _, _)| c == ch)\n-    .map(|&(_, u_name, ascii_char)| {\n-        let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n-        match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n-            Some(&(ascii_char, ascii_name)) => {\n-                // special help suggestion for \"directed\" double quotes\n-                if let Some(s) = reader.peek_delimited('\u201c', '\u201d') {\n-                    let msg = format!(\"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n-                        '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n-                                ascii_char, ascii_name);\n-                    err.span_suggestion(\n-                        Span::new(reader.pos, reader.next_pos + Pos::from_usize(s.len()) +\n-                            Pos::from_usize('\u201d'.len_utf8()), NO_EXPANSION),\n-                        &msg,\n-                        format!(\"\\\"{}\\\"\", s),\n-                        Applicability::MaybeIncorrect);\n-                } else {\n-                    let msg =\n-                        format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n-                                ch, u_name, ascii_char, ascii_name);\n-                    err.span_suggestion(\n-                        span,\n-                        &msg,\n-                        ascii_char.to_string(),\n-                        Applicability::MaybeIncorrect);\n-                }\n-                true\n-            },\n-            None => {\n-                let msg = format!(\"substitution character not found for '{}'\", ch);\n-                reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n-                false\n-            }\n+    ('>', \"Greater-Than Sign\"),\n+];\n+\n+crate fn check_for_substitution<'a>(\n+    reader: &StringReader<'a>,\n+    ch: char,\n+    err: &mut DiagnosticBuilder<'a>,\n+) -> bool {\n+    let (u_name, ascii_char) = match UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) {\n+        Some(&(_u_char, u_name, ascii_char)) => (u_name, ascii_char),\n+        None => return false,\n+    };\n+\n+    let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n+\n+    let ascii_name = match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n+        Some((_ascii_char, ascii_name)) => ascii_name,\n+        None => {\n+            let msg = format!(\"substitution character not found for '{}'\", ch);\n+            reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n+            return false\n+        },\n+    };\n+\n+    // special help suggestion for \"directed\" double quotes\n+    if let Some(s) = reader.peek_delimited('\u201c', '\u201d') {\n+        let msg = format!(\n+            \"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n+             '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n+            ascii_char, ascii_name\n+        );\n+        err.span_suggestion(\n+            Span::new(\n+                reader.pos,\n+                reader.next_pos + Pos::from_usize(s.len()) + Pos::from_usize('\u201d'.len_utf8()),\n+                NO_EXPANSION,\n+            ),\n+            &msg,\n+            format!(\"\\\"{}\\\"\", s),\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        let msg = format!(\n+            \"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n+            ch, u_name, ascii_char, ascii_name\n+        );\n+        err.span_suggestion(\n+            span,\n+            &msg,\n+            ascii_char.to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+    true\n+}\n+\n+impl StringReader<'_> {\n+    /// Immutably extract string if found at current position with given delimiters\n+    fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<&str> {\n+        let tail = &self.src[self.src_index(self.pos)..];\n+        let mut chars = tail.chars();\n+        let first_char = chars.next()?;\n+        if first_char != from_ch {\n+            return None;\n         }\n-    }).unwrap_or(false)\n+        let last_char_idx = chars.as_str().find(to_ch)?;\n+        Some(&chars.as_str()[..last_char_idx])\n+    }\n }"}]}