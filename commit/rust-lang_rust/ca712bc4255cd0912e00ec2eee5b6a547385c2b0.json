{"sha": "ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNzEyYmM0MjU1Y2QwOTEyZTAwZWMyZWVlNWI2YTU0NzM4NWMyYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-07T16:24:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-07T16:24:46Z"}, "message": "Auto merge of #85036 - Dylan-DPC:rollup-4qfabo3, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #84254 (illumos should put libc last in library search order)\n - #84442 (Unify rustc and rustdoc parsing of `cfg()`)\n - #84655 (Cleanup of `wasm`)\n - #84866 (linker: Avoid library duplication with `/WHOLEARCHIVE`)\n - #84930 (rename LLVM target for RustyHermit)\n - #84991 (rustc: Support Rust-specific features in -Ctarget-feature)\n - #85029 (SGX mutex is movable)\n - #85030 (Rearrange SGX split module files)\n - #85033 (some further small cleanups)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ff4d9ea888df4811d26c260f8bd532d901c016df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff4d9ea888df4811d26c260f8bd532d901c016df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "html_url": "https://github.com/rust-lang/rust/commit/ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f83d24aee866a14753a7cedbb4e301dfe5bef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f83d24aee866a14753a7cedbb4e301dfe5bef5", "html_url": "https://github.com/rust-lang/rust/commit/e5f83d24aee866a14753a7cedbb4e301dfe5bef5"}, {"sha": "42848090b588a53bc31cfe3718090f488a69633e", "url": "https://api.github.com/repos/rust-lang/rust/commits/42848090b588a53bc31cfe3718090f488a69633e", "html_url": "https://github.com/rust-lang/rust/commit/42848090b588a53bc31cfe3718090f488a69633e"}], "stats": {"total": 410, "additions": 199, "deletions": 211}, "files": [{"sha": "6101b90aea6dae8c7ca146092824bed8c5f4e560", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -339,24 +339,32 @@ pub fn llvm_global_features(sess: &Session) -> Vec<String> {\n         Some(_) | None => {}\n     };\n \n+    let filter = |s: &str| {\n+        if s.is_empty() {\n+            return None;\n+        }\n+        let feature = if s.starts_with(\"+\") || s.starts_with(\"-\") {\n+            &s[1..]\n+        } else {\n+            return Some(s.to_string());\n+        };\n+        // Rustc-specific feature requests like `+crt-static` or `-crt-static`\n+        // are not passed down to LLVM.\n+        if RUSTC_SPECIFIC_FEATURES.contains(&feature) {\n+            return None;\n+        }\n+        // ... otherwise though we run through `to_llvm_feature` feature when\n+        // passing requests down to LLVM. This means that all in-language\n+        // features also work on the command line instead of having two\n+        // different names when the LLVM name and the Rust name differ.\n+        Some(format!(\"{}{}\", &s[..1], to_llvm_feature(sess, feature)))\n+    };\n+\n     // Features implied by an implicit or explicit `--target`.\n-    features.extend(\n-        sess.target\n-            .features\n-            .split(',')\n-            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n-            .map(String::from),\n-    );\n+    features.extend(sess.target.features.split(',').filter_map(&filter));\n \n     // -Ctarget-features\n-    features.extend(\n-        sess.opts\n-            .cg\n-            .target_feature\n-            .split(',')\n-            .filter(|f| !f.is_empty() && !RUSTC_SPECIFIC_FEATURES.iter().any(|s| f.contains(s)))\n-            .map(String::from),\n-    );\n+    features.extend(sess.opts.cg.target_feature.split(',').filter_map(&filter));\n \n     features\n }"}, {"sha": "929bdf227558206080eada53a94fa0c4d904a90b", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -340,6 +340,14 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn link_dylib(&mut self, lib: Symbol, verbatim: bool, as_needed: bool) {\n+        if self.sess.target.os == \"illumos\" && lib.as_str() == \"c\" {\n+            // libc will be added via late_link_args on illumos so that it will\n+            // appear last in the library search order.\n+            // FIXME: This should be replaced by a more complete and generic\n+            // mechanism for controlling the order of library arguments passed\n+            // to the linker.\n+            return;\n+        }\n         if !as_needed {\n             if self.sess.target.is_like_osx {\n                 // FIXME(81490): ld64 doesn't support these flags but macOS 11\n@@ -813,11 +821,9 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: Symbol, verbatim: bool, _search_path: &[PathBuf]) {\n-        self.link_staticlib(lib, verbatim);\n         self.cmd.arg(format!(\"/WHOLEARCHIVE:{}{}\", lib, if verbatim { \"\" } else { \".lib\" }));\n     }\n     fn link_whole_rlib(&mut self, path: &Path) {\n-        self.link_rlib(path);\n         let mut arg = OsString::from(\"/WHOLEARCHIVE:\");\n         arg.push(path);\n         self.cmd.arg(arg);"}, {"sha": "f9140609c0f3c86f048d0b542c4feddb75adba82", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -464,31 +464,9 @@ impl<'a> StripUnconfigured<'a> {\n                     return true;\n                 }\n             };\n-            let error = |span, msg, suggestion: &str| {\n-                let mut err = self.sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n-                if !suggestion.is_empty() {\n-                    err.span_suggestion(\n-                        span,\n-                        \"expected syntax is\",\n-                        suggestion.into(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err.emit();\n-                true\n-            };\n-            let span = meta_item.span;\n-            match meta_item.meta_item_list() {\n-                None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n-                Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n-                Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n-                Some([single]) => match single.meta_item() {\n-                    Some(meta_item) => {\n-                        attr::cfg_matches(meta_item, &self.sess.parse_sess, self.features)\n-                    }\n-                    None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n-                },\n-            }\n+            parse_cfg(&meta_item, &self.sess).map_or(true, |meta_item| {\n+                attr::cfg_matches(&meta_item, &self.sess.parse_sess, self.features)\n+            })\n         })\n     }\n \n@@ -532,6 +510,32 @@ impl<'a> StripUnconfigured<'a> {\n     }\n }\n \n+pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a MetaItem> {\n+    let error = |span, msg, suggestion: &str| {\n+        let mut err = sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n+        if !suggestion.is_empty() {\n+            err.span_suggestion(\n+                span,\n+                \"expected syntax is\",\n+                suggestion.into(),\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+        err.emit();\n+        None\n+    };\n+    let span = meta_item.span;\n+    match meta_item.meta_item_list() {\n+        None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n+        Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n+        Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+        Some([single]) => match single.meta_item() {\n+            Some(meta_item) => Some(meta_item),\n+            None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+        },\n+    }\n+}\n+\n fn is_cfg(sess: &Session, attr: &Attribute) -> bool {\n     sess.check_name(attr, sym::cfg)\n }"}, {"sha": "2b8e046c46b0e7135ce9893b3eb4375e87760547", "filename": "compiler/rustc_target/src/spec/illumos_base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -6,6 +6,17 @@ pub fn opts() -> TargetOptions {\n     late_link_args.insert(\n         LinkerFlavor::Gcc,\n         vec![\n+            // The illumos libc contains a stack unwinding implementation, as\n+            // does libgcc_s.  The latter implementation includes several\n+            // additional symbols that are not always in base libc.  To force\n+            // the consistent use of just one unwinder, we ensure libc appears\n+            // after libgcc_s in the NEEDED list for the resultant binary by\n+            // ignoring any attempts to add it as a dynamic dependency until the\n+            // very end.\n+            // FIXME: This should be replaced by a more complete and generic\n+            // mechanism for controlling the order of library arguments passed\n+            // to the linker.\n+            \"-lc\".to_string(),\n             // LLVM will insert calls to the stack protector functions\n             // \"__stack_chk_fail\" and \"__stack_chk_guard\" into code in native\n             // object files.  Some platforms include these symbols directly in"}, {"sha": "359cb0f6881de502f3ec49bcafc5ce013bd104ce", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none_hermitkernel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_hermitkernel.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -11,7 +11,7 @@ pub fn target() -> Target {\n     base.stack_probes = StackProbeType::Call;\n \n     Target {\n-        llvm_target: \"x86_64-unknown-none-elf\".to_string(),\n+        llvm_target: \"x86_64-unknown-hermit\".to_string(),\n         pointer_width: 64,\n         data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .to_string(),"}, {"sha": "4d6caf07236e29593db7c30d89fafea47c1b40c6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -720,11 +720,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn select_obligations_where_possible(\n         &self,\n         fallback_has_occurred: bool,\n-        mutate_fullfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n+        mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) {\n         let result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n         if let Err(mut errors) = result {\n-            mutate_fullfillment_errors(&mut errors);\n+            mutate_fulfillment_errors(&mut errors);\n             self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n         }\n     }"}, {"sha": "3417bc0197253221379302eea24eb442b3952485", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -986,7 +986,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             error.obligation.predicate.kind().skip_binder()\n                         {\n                             // If any of the type arguments in this path segment caused the\n-                            // `FullfillmentError`, point at its span (#61860).\n+                            // `FulfillmentError`, point at its span (#61860).\n                             for arg in path\n                                 .segments\n                                 .iter()"}, {"sha": "7436edccf84bb3a84361f4f34604d9f02e9ad090", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -43,7 +43,7 @@ struct CheckWfFcxBuilder<'tcx> {\n impl<'tcx> CheckWfFcxBuilder<'tcx> {\n     fn with_fcx<F>(&mut self, f: F)\n     where\n-        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>, TyCtxt<'tcx>) -> Vec<Ty<'tcx>>,\n+        F: for<'b> FnOnce(&FnCtxt<'b, 'tcx>) -> Vec<Ty<'tcx>>,\n     {\n         let id = self.id;\n         let span = self.span;\n@@ -56,7 +56,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n                 // empty `param_env`.\n                 check_false_global_bounds(&fcx, span, id);\n             }\n-            let wf_tys = f(&fcx, fcx.tcx);\n+            let wf_tys = f(&fcx);\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n@@ -388,7 +388,7 @@ fn check_associated_item(\n     debug!(\"check_associated_item: {:?}\", item_id);\n \n     let code = ObligationCauseCode::MiscObligation;\n-    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n+    for_id(tcx, item_id, span).with_fcx(|fcx| {\n         let item = fcx.tcx.associated_item(fcx.tcx.hir().local_def_id(item_id));\n \n         let (mut implied_bounds, self_ty) = match item.container {\n@@ -409,7 +409,6 @@ fn check_associated_item(\n                 let sig = fcx.normalize_associated_types_in(span, sig);\n                 let hir_sig = sig_if_method.expect(\"bad signature for method\");\n                 check_fn_or_method(\n-                    tcx,\n                     fcx,\n                     item.ident.span,\n                     sig,\n@@ -467,25 +466,24 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n+    for_item(tcx, item).with_fcx(|fcx| {\n         let variants = lookup_fields(fcx);\n-        let packed = fcx.tcx.adt_def(item.def_id).repr.packed();\n+        let packed = tcx.adt_def(item.def_id).repr.packed();\n \n         for variant in &variants {\n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n                     let ty = variant.fields.last().unwrap().ty;\n-                    let ty = fcx.tcx.erase_regions(ty);\n+                    let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n-                        fcx_tcx\n-                            .sess\n+                        tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(fcx_tcx, fcx_tcx.param_env(item.def_id))\n+                        ty.needs_drop(tcx, tcx.param_env(item.def_id))\n                     }\n                 }\n             };\n@@ -497,7 +495,7 @@ fn check_type_defn<'tcx, F>(\n                 let last = idx == variant.fields.len() - 1;\n                 fcx.register_bound(\n                     field.ty,\n-                    fcx.tcx.require_lang_item(LangItem::Sized, None),\n+                    tcx.require_lang_item(LangItem::Sized, None),\n                     traits::ObligationCause::new(\n                         field.span,\n                         fcx.body_id,\n@@ -524,11 +522,10 @@ fn check_type_defn<'tcx, F>(\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n             if let Some(discr_def_id) = variant.explicit_discr {\n-                let discr_substs =\n-                    InternalSubsts::identity_for_item(fcx.tcx, discr_def_id.to_def_id());\n+                let discr_substs = InternalSubsts::identity_for_item(tcx, discr_def_id.to_def_id());\n \n                 let cause = traits::ObligationCause::new(\n-                    fcx.tcx.def_span(discr_def_id),\n+                    tcx.def_span(discr_def_id),\n                     fcx.body_id,\n                     traits::MiscObligation,\n                 );\n@@ -539,12 +536,12 @@ fn check_type_defn<'tcx, F>(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n                     )\n-                    .to_predicate(fcx.tcx),\n+                    .to_predicate(tcx),\n                 ));\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         // No implied bounds in a struct definition.\n         vec![]\n@@ -569,8 +566,9 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n         }\n     }\n \n-    for_item(tcx, item).with_fcx(|fcx, _| {\n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+    // FIXME: this shouldn't use an `FnCtxt` at all.\n+    for_item(tcx, item).with_fcx(|fcx| {\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         vec![]\n     });\n@@ -610,28 +608,20 @@ fn check_item_fn(\n     span: Span,\n     decl: &hir::FnDecl<'_>,\n ) {\n-    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n-        let def_id = fcx.tcx.hir().local_def_id(item_id);\n-        let sig = fcx.tcx.fn_sig(def_id);\n+    for_id(tcx, item_id, span).with_fcx(|fcx| {\n+        let def_id = tcx.hir().local_def_id(item_id);\n+        let sig = tcx.fn_sig(def_id);\n         let sig = fcx.normalize_associated_types_in(span, sig);\n         let mut implied_bounds = vec![];\n-        check_fn_or_method(\n-            tcx,\n-            fcx,\n-            ident.span,\n-            sig,\n-            decl,\n-            def_id.to_def_id(),\n-            &mut implied_bounds,\n-        );\n+        check_fn_or_method(fcx, ident.span, sig, decl, def_id.to_def_id(), &mut implied_bounds);\n         implied_bounds\n     })\n }\n \n fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_foreign_ty: bool) {\n     debug!(\"check_item_type: {:?}\", item_id);\n \n-    for_id(tcx, item_id, ty_span).with_fcx(|fcx, tcx| {\n+    for_id(tcx, item_id, ty_span).with_fcx(|fcx| {\n         let ty = tcx.type_of(tcx.hir().local_def_id(item_id));\n         let item_ty = fcx.normalize_associated_types_in(ty_span, ty);\n \n@@ -647,7 +637,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n         if forbid_unsized {\n             fcx.register_bound(\n                 item_ty,\n-                fcx.tcx.require_lang_item(LangItem::Sized, None),\n+                tcx.require_lang_item(LangItem::Sized, None),\n                 traits::ObligationCause::new(ty_span, fcx.body_id, traits::MiscObligation),\n             );\n         }\n@@ -665,13 +655,13 @@ fn check_impl<'tcx>(\n ) {\n     debug!(\"check_impl: {:?}\", item);\n \n-    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+    for_item(tcx, item).with_fcx(|fcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = fcx.tcx.impl_trait_ref(item.def_id).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n                 let trait_ref =\n                     fcx.normalize_associated_types_in(ast_trait_ref.path.span, trait_ref);\n                 let obligations = traits::wf::trait_obligations(\n@@ -687,7 +677,7 @@ fn check_impl<'tcx>(\n                 }\n             }\n             None => {\n-                let self_ty = fcx.tcx.type_of(item.def_id);\n+                let self_ty = tcx.type_of(item.def_id);\n                 let self_ty = fcx.normalize_associated_types_in(item.span, self_ty);\n                 fcx.register_wf_obligation(\n                     self_ty.into(),\n@@ -697,23 +687,23 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(tcx, fcx, item.span, item.def_id.to_def_id(), None);\n+        check_where_clauses(fcx, item.span, item.def_id.to_def_id(), None);\n \n         fcx.impl_implied_bounds(item.def_id.to_def_id(), item.span)\n     });\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n fn check_where_clauses<'tcx, 'fcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n     def_id: DefId,\n     return_ty: Option<(Ty<'tcx>, Span)>,\n ) {\n     debug!(\"check_where_clauses(def_id={:?}, return_ty={:?})\", def_id, return_ty);\n+    let tcx = fcx.tcx;\n \n-    let predicates = fcx.tcx.predicates_of(def_id);\n+    let predicates = tcx.predicates_of(def_id);\n     let generics = tcx.generics_of(def_id);\n \n     let is_our_default = |def: &ty::GenericParamDef| match def.kind {\n@@ -734,14 +724,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n         match param.kind {\n             GenericParamDefKind::Type { .. } => {\n                 if is_our_default(&param) {\n-                    let ty = fcx.tcx.type_of(param.def_id);\n+                    let ty = tcx.type_of(param.def_id);\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n                     if !ty.needs_subst() {\n                         fcx.register_wf_obligation(\n                             ty.into(),\n-                            fcx.tcx.def_span(param.def_id),\n+                            tcx.def_span(param.def_id),\n                             ObligationCauseCode::MiscObligation,\n                         );\n                     }\n@@ -754,7 +744,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     fcx.register_wf_obligation(\n                         default_ct.into(),\n-                        fcx.tcx.def_span(param.def_id),\n+                        tcx.def_span(param.def_id),\n                         ObligationCauseCode::MiscObligation,\n                     );\n                 }\n@@ -772,25 +762,25 @@ fn check_where_clauses<'tcx, 'fcx>(\n     // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n     //\n     // First we build the defaulted substitution.\n-    let substs = InternalSubsts::for_item(fcx.tcx, def_id, |param, _| {\n+    let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // All regions are identity.\n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n \n             GenericParamDefKind::Type { .. } => {\n                 // If the param has a default, ...\n                 if is_our_default(param) {\n-                    let default_ty = fcx.tcx.type_of(param.def_id);\n+                    let default_ty = tcx.type_of(param.def_id);\n                     // ... and it's not a dependent default, ...\n                     if !default_ty.needs_subst() {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n                 }\n \n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n             GenericParamDefKind::Const { .. } => {\n                 // FIXME(const_generics_defaults): I(@lcnr) feel like always\n@@ -811,7 +801,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     }\n                 }\n \n-                fcx.tcx.mk_param_from_def(param)\n+                tcx.mk_param_from_def(param)\n             }\n         }\n     });\n@@ -848,7 +838,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n             }\n             let mut param_count = CountParams::default();\n             let has_region = pred.visit_with(&mut param_count).is_break();\n-            let substituted_pred = pred.subst(fcx.tcx, substs);\n+            let substituted_pred = pred.subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n             if substituted_pred.has_param_types_or_consts()\n@@ -879,14 +869,14 @@ fn check_where_clauses<'tcx, 'fcx>(\n             traits::Obligation::new(cause, fcx.param_env, pred)\n         });\n \n-    let predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = predicates.instantiate_identity(tcx);\n \n     if let Some((mut return_ty, span)) = return_ty {\n         if return_ty.has_infer_types_or_consts() {\n             fcx.select_obligations_where_possible(false, |_| {});\n             return_ty = fcx.resolve_vars_if_possible(return_ty);\n         }\n-        check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n+        check_opaque_types(fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, predicates);\n@@ -905,7 +895,6 @@ fn check_where_clauses<'tcx, 'fcx>(\n }\n \n fn check_fn_or_method<'fcx, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n     sig: ty::PolyFnSig<'tcx>,\n@@ -930,7 +919,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     // FIXME(#25759) return types should not be implied bounds\n     implied_bounds.push(sig.output());\n \n-    check_where_clauses(tcx, fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n+    check_where_clauses(fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n }\n \n /// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n@@ -953,15 +942,16 @@ fn check_fn_or_method<'fcx, 'tcx>(\n /// ```\n ///\n fn check_opaque_types<'fcx, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n ) {\n-    trace!(\"check_opaque_types(ty={:?})\", ty);\n+    trace!(\"check_opaque_types(fn_def_id={:?}, ty={:?})\", fn_def_id, ty);\n+    let tcx = fcx.tcx;\n+\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n-        tcx: fcx.tcx,\n+        tcx,\n         ty_op: |ty| {\n             if let ty::Opaque(def_id, substs) = *ty.kind() {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);"}, {"sha": "13d96e9a633d34a344384e1dd760d702d346fd17", "filename": "library/std/src/sys/sgx/abi/tls/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fmod.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "previous_filename": "library/std/src/sys/sgx/abi/tls.rs"}, {"sha": "1b5ced4178f6abd5aff9b1272623b0ec67abab69", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -8,7 +8,7 @@ pub struct Mutex {\n     inner: SpinMutex<WaitVariable<bool>>,\n }\n \n-pub type MovableMutex = Box<Mutex>;\n+pub type MovableMutex = Mutex;\n \n // Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {"}, {"sha": "61bb11d9a6fad746db505927b37854ff3b8ec89a", "filename": "library/std/src/sys/sgx/waitqueue/mod.rs", "status": "renamed", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fmod.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -13,13 +13,8 @@\n #[cfg(test)]\n mod tests;\n \n-/// A doubly-linked list where callers are in charge of memory allocation\n-/// of the nodes in the list.\n-mod unsafe_list;\n-\n-/// Trivial spinlock-based implementation of `sync::Mutex`.\n-// FIXME: Perhaps use Intel TSX to avoid locking?\n mod spin_mutex;\n+mod unsafe_list;\n \n use crate::num::NonZeroUsize;\n use crate::ops::{Deref, DerefMut};", "previous_filename": "library/std/src/sys/sgx/waitqueue.rs"}, {"sha": "f6e851ccaddfaed51f9bf3b3be1a31309cfa920d", "filename": "library/std/src/sys/sgx/waitqueue/spin_mutex.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -1,3 +1,6 @@\n+//! Trivial spinlock-based implementation of `sync::Mutex`.\n+// FIXME: Perhaps use Intel TSX to avoid locking?\n+\n #[cfg(test)]\n mod tests;\n "}, {"sha": "cf2f0886c15464773fb1de1313db8913207eb4a4", "filename": "library/std/src/sys/sgx/waitqueue/unsafe_list.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -1,3 +1,6 @@\n+//! A doubly-linked list where callers are in charge of memory allocation\n+//! of the nodes in the list.\n+\n #[cfg(test)]\n mod tests;\n "}, {"sha": "a2d75a61976337f691b7bfacf3a33eae425bb29e", "filename": "library/std/src/sys/unsupported/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -1,4 +1,5 @@\n use crate::ffi::OsString;\n+use crate::fmt;\n \n pub struct Args {}\n "}, {"sha": "fde1ab79e1f4b97d73bc1ed1e3333755ab2e93f1", "filename": "library/std/src/sys/wasm/args.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83d24aee866a14753a7cedbb4e301dfe5bef5/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83d24aee866a14753a7cedbb4e301dfe5bef5/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs?ref=e5f83d24aee866a14753a7cedbb4e301dfe5bef5", "patch": "@@ -1,42 +0,0 @@\n-use crate::ffi::OsString;\n-use crate::fmt;\n-use crate::vec;\n-\n-pub fn args() -> Args {\n-    Args { iter: Vec::new().into_iter() }\n-}\n-\n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-}\n-\n-impl !Send for Args {}\n-impl !Sync for Args {}\n-\n-impl fmt::Debug for Args {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.iter.as_slice().fmt(f)\n-    }\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.iter.next_back()\n-    }\n-}"}, {"sha": "0c1c076cc914241baa16f13bce8a9e057500842d", "filename": "library/std/src/sys/wasm/atomics/condvar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "previous_filename": "library/std/src/sys/wasm/condvar_atomics.rs"}, {"sha": "3d8bf42f7255eec2b11660c02d5d082eb6a3e422", "filename": "library/std/src/sys/wasm/atomics/futex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "previous_filename": "library/std/src/sys/wasm/futex_atomics.rs"}, {"sha": "5ff0ec052b6f4c0cdc95f4f85942f107d5b47b3f", "filename": "library/std/src/sys/wasm/atomics/mutex.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "previous_filename": "library/std/src/sys/wasm/mutex_atomics.rs"}, {"sha": "06442e925f4c8710d33caf6fff3e18a54e495081", "filename": "library/std/src/sys/wasm/atomics/rwlock.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "previous_filename": "library/std/src/sys/wasm/rwlock_atomics.rs"}, {"sha": "54bc877aa7de720cbaeddd21b977f3bc804db777", "filename": "library/std/src/sys/wasm/atomics/thread.rs", "status": "renamed", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -13,20 +13,10 @@ impl Thread {\n         unsupported()\n     }\n \n-    pub fn yield_now() {\n-        // do nothing\n-    }\n+    pub fn yield_now() {}\n \n-    pub fn set_name(_name: &CStr) {\n-        // nope\n-    }\n+    pub fn set_name(_name: &CStr) {}\n \n-    #[cfg(not(target_feature = \"atomics\"))]\n-    pub fn sleep(_dur: Duration) {\n-        panic!(\"can't sleep\");\n-    }\n-\n-    #[cfg(target_feature = \"atomics\")]\n     pub fn sleep(dur: Duration) {\n         use crate::arch::wasm32;\n         use crate::cmp;\n@@ -46,9 +36,7 @@ impl Thread {\n         }\n     }\n \n-    pub fn join(self) {\n-        self.0\n-    }\n+    pub fn join(self) {}\n }\n \n pub mod guard {\n@@ -61,11 +49,9 @@ pub mod guard {\n     }\n }\n \n-// This is only used by atomics primitives when the `atomics` feature is\n-// enabled. In that mode we currently just use our own thread-local to store our\n+// We currently just use our own thread-local to store our\n // current thread's ID, and then we lazily initialize it to something allocated\n // from a global counter.\n-#[cfg(target_feature = \"atomics\")]\n pub fn my_id() -> u32 {\n     use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n ", "previous_filename": "library/std/src/sys/wasm/thread.rs"}, {"sha": "cd701a333f84cb7a9f0168770f76bc6d35e1760a", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -17,6 +17,7 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n pub mod alloc;\n+#[path = \"../unsupported/args.rs\"]\n pub mod args;\n #[path = \"../unix/cmath.rs\"]\n pub mod cmath;\n@@ -37,7 +38,6 @@ pub mod pipe;\n pub mod process;\n #[path = \"../unsupported/stdio.rs\"]\n pub mod stdio;\n-pub mod thread;\n #[path = \"../unsupported/thread_local_dtor.rs\"]\n pub mod thread_local_dtor;\n #[path = \"../unsupported/thread_local_key.rs\"]\n@@ -49,21 +49,25 @@ pub use crate::sys_common::os_str_bytes as os_str;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_feature = \"atomics\")] {\n-        #[path = \"condvar_atomics.rs\"]\n+        #[path = \"atomics/condvar.rs\"]\n         pub mod condvar;\n-        #[path = \"mutex_atomics.rs\"]\n+        #[path = \"atomics/mutex.rs\"]\n         pub mod mutex;\n-        #[path = \"rwlock_atomics.rs\"]\n+        #[path = \"atomics/rwlock.rs\"]\n         pub mod rwlock;\n-        #[path = \"futex_atomics.rs\"]\n+        #[path = \"atomics/futex.rs\"]\n         pub mod futex;\n+        #[path = \"atomics/thread.rs\"]\n+        pub mod thread;\n     } else {\n         #[path = \"../unsupported/condvar.rs\"]\n         pub mod condvar;\n         #[path = \"../unsupported/mutex.rs\"]\n         pub mod mutex;\n         #[path = \"../unsupported/rwlock.rs\"]\n         pub mod rwlock;\n+        #[path = \"../unsupported/thread.rs\"]\n+        pub mod thread;\n     }\n }\n "}, {"sha": "6d05ac073cca3e869828f6ae875186cd937fbdbf", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -317,10 +317,10 @@ fn merge_attrs(\n             } else {\n                 Attributes::from_ast(&both, None)\n             },\n-            both.cfg(cx.sess().diagnostic()),\n+            both.cfg(cx.sess()),\n         )\n     } else {\n-        (old_attrs.clean(cx), old_attrs.cfg(cx.sess().diagnostic()))\n+        (old_attrs.clean(cx), old_attrs.cfg(cx.sess()))\n     }\n }\n "}, {"sha": "e1dde8eeaf84ae838513f84283e1aa532c3204e1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -2018,7 +2018,7 @@ fn clean_extern_crate(\n         def_id: crate_def_id.into(),\n         visibility: krate.vis.clean(cx),\n         kind: box ExternCrateItem { src: orig_name },\n-        cfg: attrs.cfg(cx.sess().diagnostic()),\n+        cfg: attrs.cfg(cx.sess()),\n     }]\n }\n "}, {"sha": "9861e838e33f1c95a03b16dc92da73e472257899", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -444,7 +444,7 @@ impl Item {\n             kind,\n             box ast_attrs.clean(cx),\n             cx,\n-            ast_attrs.cfg(cx.sess().diagnostic()),\n+            ast_attrs.cfg(cx.sess()),\n         )\n     }\n \n@@ -456,7 +456,7 @@ impl Item {\n         cx: &mut DocContext<'_>,\n         cfg: Option<Arc<Cfg>>,\n     ) -> Item {\n-        debug!(\"name={:?}, def_id={:?}\", name, def_id);\n+        trace!(\"name={:?}, def_id={:?}\", name, def_id);\n \n         Item {\n             def_id: def_id.into(),\n@@ -795,7 +795,7 @@ crate trait AttributesExt {\n \n     fn other_attrs(&self) -> Vec<ast::Attribute>;\n \n-    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>>;\n+    fn cfg(&self, sess: &Session) -> Option<Arc<Cfg>>;\n }\n \n impl AttributesExt for [ast::Attribute] {\n@@ -820,17 +820,28 @@ impl AttributesExt for [ast::Attribute] {\n         self.iter().filter(|attr| attr.doc_str().is_none()).cloned().collect()\n     }\n \n-    fn cfg(&self, diagnostic: &::rustc_errors::Handler) -> Option<Arc<Cfg>> {\n+    fn cfg(&self, sess: &Session) -> Option<Arc<Cfg>> {\n         let mut cfg = Cfg::True;\n \n         for attr in self.iter() {\n+            // #[doc]\n             if attr.doc_str().is_none() && attr.has_name(sym::doc) {\n-                if let Some(mi) = attr.meta() {\n-                    if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                        // Extracted #[doc(cfg(...))]\n-                        match Cfg::parse(cfg_mi) {\n-                            Ok(new_cfg) => cfg &= new_cfg,\n-                            Err(e) => diagnostic.span_err(e.span, e.msg),\n+                // #[doc(...)]\n+                if let Some(list) = attr.meta().as_ref().and_then(|mi| mi.meta_item_list()) {\n+                    for item in list {\n+                        // #[doc(include)]\n+                        if !item.has_name(sym::cfg) {\n+                            continue;\n+                        }\n+                        // #[doc(cfg(...))]\n+                        if let Some(cfg_mi) = item\n+                            .meta_item()\n+                            .and_then(|item| rustc_expand::config::parse_cfg(&item, sess))\n+                        {\n+                            match Cfg::parse(&cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => sess.span_err(e.span, e.msg),\n+                            }\n                         }\n                     }\n                 }\n@@ -997,29 +1008,6 @@ impl Attributes {\n         self.other_attrs.lists(name)\n     }\n \n-    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n-    crate fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n-        use rustc_ast::NestedMetaItem::MetaItem;\n-\n-        if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n-            if nmis.len() == 1 {\n-                if let MetaItem(ref cfg_mi) = nmis[0] {\n-                    if cfg_mi.has_name(sym::cfg) {\n-                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.kind {\n-                            if cfg_nmis.len() == 1 {\n-                                if let MetaItem(ref content_mi) = cfg_nmis[0] {\n-                                    return Some(content_mi);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n     /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n     /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n     /// its expansion."}, {"sha": "e563889f776e539c100ac8fa36da7c41c2f6583e", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -1096,7 +1096,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         let ast_attrs = self.tcx.hir().attrs(hir_id);\n         let mut attrs = Attributes::from_ast(ast_attrs, None);\n \n-        if let Some(ref cfg) = ast_attrs.cfg(self.sess.diagnostic()) {\n+        if let Some(ref cfg) = ast_attrs.cfg(self.sess) {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;\n             }"}, {"sha": "e0c1fd06e7b6c46f021dd0c2b347b2a37f696f85", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -155,7 +155,7 @@ impl<'tcx> Context<'tcx> {\n         &self.cache\n     }\n \n-    fn sess(&self) -> &'tcx Session {\n+    pub(super) fn sess(&self) -> &'tcx Session {\n         &self.shared.tcx.sess\n     }\n "}, {"sha": "9d4ac3cf015ddda0eb0b0a1b308d653448264232", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -296,7 +296,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     let import_item = clean::Item {\n                         def_id: import_def_id.into(),\n                         attrs: import_attrs,\n-                        cfg: ast_attrs.cfg(cx.tcx().sess.diagnostic()),\n+                        cfg: ast_attrs.cfg(cx.sess()),\n                         ..myitem.clone()\n                     };\n "}, {"sha": "d237b8605c068a0614fda35c931d35c36452fc78", "filename": "src/test/rustdoc-ui/invalid-cfg.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -0,0 +1,4 @@\n+#![feature(doc_cfg)]\n+#[doc(cfg = \"x\")] //~ ERROR not followed by parentheses\n+#[doc(cfg(x, y))] //~ ERROR multiple `cfg` predicates\n+struct S {}"}, {"sha": "dae238b052b8a75331cf770f635a7a0c2f302f79", "filename": "src/test/rustdoc-ui/invalid-cfg.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-cfg.stderr?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -0,0 +1,14 @@\n+error: `cfg` is not followed by parentheses\n+  --> $DIR/invalid-cfg.rs:2:7\n+   |\n+LL | #[doc(cfg = \"x\")]\n+   |       ^^^^^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n+\n+error: multiple `cfg` predicates are specified\n+  --> $DIR/invalid-cfg.rs:3:14\n+   |\n+LL | #[doc(cfg(x, y))]\n+   |              ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "1fc80b3e76c53a7d775bf2f06192a9bef0028185", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -91,3 +91,11 @@ pub unsafe fn uses_target_feature() {\n pub fn uses_cfg_target_feature() {\n     uses_target_feature();\n }\n+\n+// multiple attributes should be allowed\n+// @has doc_cfg/fn.multiple_attrs.html \\\n+//  '//*[@id=\"main\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\\n+//  'This is supported on x and y and z only.'\n+#[doc(inline, cfg(x))]\n+#[doc(cfg(y), cfg(z))]\n+pub fn multiple_attrs() {}"}, {"sha": "1708a71a9812ff2d610261a61c5c309ea7a7a137", "filename": "src/test/ui/target-feature/rust-specific-name-no-warnings.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Fui%2Ftarget-feature%2Frust-specific-name-no-warnings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca712bc4255cd0912e00ec2eee5b6a547385c2b0/src%2Ftest%2Fui%2Ftarget-feature%2Frust-specific-name-no-warnings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Frust-specific-name-no-warnings.rs?ref=ca712bc4255cd0912e00ec2eee5b6a547385c2b0", "patch": "@@ -0,0 +1,5 @@\n+// build-pass\n+// only-x86\n+// compile-flags: -C target-feature=+pclmulqdq\n+\n+fn main() {}"}]}