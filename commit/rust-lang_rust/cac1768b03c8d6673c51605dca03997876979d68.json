{"sha": "cac1768b03c8d6673c51605dca03997876979d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYzE3NjhiMDNjOGQ2NjczYzUxNjA1ZGNhMDM5OTc4NzY5NzlkNjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-12T17:14:29Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2020-07-16T21:23:49Z"}, "message": "First cut of `std::lazy` module", "tree": {"sha": "bde94ac2ff3a01bc28a45b4737614d5485e02027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde94ac2ff3a01bc28a45b4737614d5485e02027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cac1768b03c8d6673c51605dca03997876979d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cac1768b03c8d6673c51605dca03997876979d68", "html_url": "https://github.com/rust-lang/rust/commit/cac1768b03c8d6673c51605dca03997876979d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cac1768b03c8d6673c51605dca03997876979d68/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee1b62c811a6eb68d6db6dfb91f66a49956749b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee1b62c811a6eb68d6db6dfb91f66a49956749b", "html_url": "https://github.com/rust-lang/rust/commit/6ee1b62c811a6eb68d6db6dfb91f66a49956749b"}], "stats": {"total": 1008, "additions": 1008, "deletions": 0}, "files": [{"sha": "bcac2dc311affde3b3fc9e43060e166420a98500", "filename": "src/libstd/lazy.rs", "status": "added", "additions": 1002, "deletions": 0, "changes": 1002, "blob_url": "https://github.com/rust-lang/rust/blob/cac1768b03c8d6673c51605dca03997876979d68/src%2Flibstd%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac1768b03c8d6673c51605dca03997876979d68/src%2Flibstd%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flazy.rs?ref=cac1768b03c8d6673c51605dca03997876979d68", "patch": "@@ -0,0 +1,1002 @@\n+//! `lazy` modules provides lazy values and one-time initialization of static data.\n+//!\n+//! `lazy` provides two new cell-like types, `OnceCell` and `SyncOnceCell`. `OnceCell`\n+//! might store arbitrary non-`Copy` types, can be assigned to at most once and provide direct access\n+//! to the stored contents. In a nutshell, API looks *roughly* like this:\n+//!\n+//! ```rust,ignore\n+//! impl<T> OnceCell<T> {\n+//!     fn new() -> OnceCell<T> { ... }\n+//!     fn set(&self, value: T) -> Result<(), T> { ... }\n+//!     fn get(&self) -> Option<&T> { ... }\n+//! }\n+//! ```\n+//!\n+//! Note that, like with `RefCell` and `Mutex`, the `set` method requires only a shared reference.\n+//! Because of the single assignment restriction `get` can return an `&T` instead of `Ref<T>`\n+//! or `MutexGuard<T>`.\n+//!\n+//! The `SyncOnceCell` flavor is thread-safe (that is, implements [`Sync`]) trait, while  `OnceCell` one is not.\n+//!\n+//! [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n+//!\n+//! # Patterns\n+//!\n+//! `OnceCell` might be useful for a variety of patterns.\n+//!\n+//! ## Safe Initialization of global data\n+//!\n+//! ```rust\n+//! use std::{env, io};\n+//! use std::lazy::SyncOnceCell;\n+//!\n+//! #[derive(Debug)]\n+//! pub struct Logger {\n+//!     // ...\n+//! }\n+//! static INSTANCE: OnceCell<Logger> = OnceCell::new();\n+//!\n+//! impl Logger {\n+//!     pub fn global() -> &'static Logger {\n+//!         INSTANCE.get().expect(\"logger is not initialized\")\n+//!     }\n+//!\n+//!     fn from_cli(args: env::Args) -> Result<Logger, std::io::Error> {\n+//!        // ...\n+//! #      Ok(Logger {})\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     let logger = Logger::from_cli(env::args()).unwrap();\n+//!     INSTANCE.set(logger).unwrap();\n+//!     // use `Logger::global()` from now on\n+//! }\n+//! ```\n+//!\n+//! ## Lazy initialized global data\n+//!\n+//! This is essentially `lazy_static!` macro, but without a macro.\n+//!\n+//! ```rust\n+//! use std::{sync::Mutex, collections::HashMap};\n+//! use lazy::SyncOnceCell;\n+//!\n+//! fn global_data() -> &'static Mutex<HashMap<i32, String>> {\n+//!     static INSTANCE: OnceCell<Mutex<HashMap<i32, String>>> = OnceCell::new();\n+//!     INSTANCE.get_or_init(|| {\n+//!         let mut m = HashMap::new();\n+//!         m.insert(13, \"Spica\".to_string());\n+//!         m.insert(74, \"Hoyten\".to_string());\n+//!         Mutex::new(m)\n+//!     })\n+//! }\n+//! ```\n+//!\n+//! There are also `sync::Lazy` and `unsync::Lazy` convenience types to streamline this pattern:\n+//!\n+//! ```rust\n+//! use std::{sync::Mutex, collections::HashMap};\n+//! use lazy::SyncLazy;\n+//!\n+//! static GLOBAL_DATA: Lazy<Mutex<HashMap<i32, String>>> = Lazy::new(|| {\n+//!     let mut m = HashMap::new();\n+//!     m.insert(13, \"Spica\".to_string());\n+//!     m.insert(74, \"Hoyten\".to_string());\n+//!     Mutex::new(m)\n+//! });\n+//!\n+//! fn main() {\n+//!     println!(\"{:?}\", GLOBAL_DATA.lock().unwrap());\n+//! }\n+//! ```\n+//!\n+//! ## General purpose lazy evaluation\n+//!\n+//! `Lazy` also works with local variables.\n+//!\n+//! ```rust\n+//! use std::lazy::Lazy;\n+//!\n+//! fn main() {\n+//!     let ctx = vec![1, 2, 3];\n+//!     let thunk = Lazy::new(|| {\n+//!         ctx.iter().sum::<i32>()\n+//!     });\n+//!     assert_eq!(*thunk, 6);\n+//! }\n+//! ```\n+//!\n+//! If you need a lazy field in a struct, you probably should use `OnceCell`\n+//! directly, because that will allow you to access `self` during initialization.\n+//!\n+//! ```rust\n+//! use std::{fs, path::PathBuf};\n+//!\n+//! use std::lazy::OnceCell;\n+//!\n+//! struct Ctx {\n+//!     config_path: PathBuf,\n+//!     config: OnceCell<String>,\n+//! }\n+//!\n+//! impl Ctx {\n+//!     pub fn get_config(&self) -> Result<&str, std::io::Error> {\n+//!         let cfg = self.config.get_or_try_init(|| {\n+//!             fs::read_to_string(&self.config_path)\n+//!         })?;\n+//!         Ok(cfg.as_str())\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! ## Building block\n+//!\n+//! Naturally, it is  possible to build other abstractions on top of `OnceCell`.\n+//! For example, this is a `regex!` macro which takes a string literal and returns an\n+//! *expression* that evaluates to a `&'static Regex`:\n+//!\n+//! ```\n+//! macro_rules! regex {\n+//!     ($re:literal $(,)?) => {{\n+//!         static RE: std::lazy::SyncOnceCell<regex::Regex> = std::lazy::SyncOnceCell::new();\n+//!         RE.get_or_init(|| regex::Regex::new($re).unwrap())\n+//!     }};\n+//! }\n+//! ```\n+//!\n+//! This macro can be useful to avoid \"compile regex on every loop iteration\" problem.\n+//!\n+//! # Comparison with other interior mutatbility types\n+//!\n+//! |`!Sync` types         | Access Mode            | Drawbacks                                     |\n+//! |----------------------|------------------------|-----------------------------------------------|\n+//! |`Cell<T>`             | `T`                    | requires `T: Copy` for `get`                  |\n+//! |`RefCell<T>`          | `RefMut<T>` / `Ref<T>` | may panic at runtime                          |\n+//! |`OnceCell<T>`         | `&T`                   | assignable only once                          |\n+//!\n+//! |`Sync` types          | Access Mode            | Drawbacks                                     |\n+//! |----------------------|------------------------|-----------------------------------------------|\n+//! |`AtomicT`             | `T`                    | works only with certain `Copy` types          |\n+//! |`Mutex<T>`            | `MutexGuard<T>`        | may deadlock at runtime, may block the thread |\n+//! |`SyncOnceCell<T>`     | `&T`                   | assignable only once, may block the thread    |\n+//!\n+//! Technically, calling `get_or_init` will also cause a panic or a deadlock if it recursively calls\n+//! itself. However, because the assignment can happen only once, such cases should be more rare than\n+//! equivalents with `RefCell` and `Mutex`.\n+\n+use crate::{\n+    cell::{Cell, UnsafeCell},\n+    fmt,\n+    hint::unreachable_unchecked,\n+    marker::PhantomData,\n+    ops::Deref,\n+    panic::{RefUnwindSafe, UnwindSafe},\n+    sync::atomic::{AtomicBool, AtomicUsize, Ordering},\n+    thread::{self, Thread},\n+};\n+\n+/// A cell which can be written to only once. Not thread safe.\n+///\n+/// Unlike `:td::cell::RefCell`, a `OnceCell` provides simple `&`\n+/// references to the contents.\n+///\n+/// # Example\n+/// ```\n+/// use std::lazy::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+// Similarly to a `Sync` bound on `SyncOnceCell`, we can use\n+// `&OnceCell` to sneak a `T` through `catch_unwind`,\n+// by initializing the cell in closure and extracting the value in the\n+// `Drop`.\n+#[cfg(feature = \"std\")]\n+impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for OnceCell<T> {}\n+#[cfg(feature = \"std\")]\n+impl<T: UnwindSafe> UnwindSafe for OnceCell<T> {}\n+\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+impl<T> From<T> for OnceCell<T> {\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    pub fn get(&self) -> Option<&T> {\n+        // Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        // Safe because we have unique access\n+        unsafe { &mut *self.inner.get() }.as_mut()\n+    }\n+\n+    /// Sets the contents of this cell to `value`.\n+    ///\n+    /// Returns `Ok(())` if the cell was empty and `Err(value)` if it was\n+    /// full.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+        let slot = unsafe { &mut *self.inner.get() };\n+        // This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        let val = f()?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the `OnceCell`, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::lazy::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+}\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Example\n+/// ```\n+/// use std::lazy::Lazy;\n+///\n+/// let lazy: Lazy<i32> = Lazy::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+pub struct Lazy<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl<T, F: RefUnwindSafe> RefUnwindSafe for Lazy<T, F> where OnceCell<T>: RefUnwindSafe {}\n+\n+impl<T: fmt::Debug, F: fmt::Debug> fmt::Debug for Lazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+impl<T, F> Lazy<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # fn main() {\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = Lazy::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// # }\n+    /// ```\n+    pub const fn new(init: F) -> Lazy<T, F> {\n+        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Lazy<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::Lazy;\n+    ///\n+    /// let lazy = Lazy::new(|| 92);\n+    ///\n+    /// assert_eq!(Lazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    pub fn force(this: &Lazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"Lazy instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        Lazy::force(self)\n+    }\n+}\n+\n+impl<T: Default> Default for Lazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> Lazy<T> {\n+        Lazy::new(T::default)\n+    }\n+}\n+\n+/// A thread-safe cell which can be written to only once.\n+///\n+/// `OnceCell` provides `&` references to the contents without RAII guards.\n+///\n+/// Reading a non-`None` value out of `OnceCell` establishes a\n+/// happens-before relationship with a corresponding write. For example, if\n+/// thread A initializes the cell with `get_or_init(f)`, and thread B\n+/// subsequently reads the result of this call, B also observes all the side\n+/// effects of `f`.\n+///\n+/// # Example\n+/// ```\n+/// use std::lazy::SyncOnceCell;\n+///\n+/// static CELL: OnceCell<String> = OnceCell::new();\n+/// assert!(CELL.get().is_none());\n+///\n+/// std::thread::spawn(|| {\n+///     let value: &String = CELL.get_or_init(|| {\n+///         \"Hello, World!\".to_string()\n+///     });\n+///     assert_eq!(value, \"Hello, World!\");\n+/// }).join().unwrap();\n+///\n+/// let value: Option<&String> = CELL.get();\n+/// assert!(value.is_some());\n+/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n+/// ```\n+pub struct SyncOnceCell<T> {\n+    // This `state` word is actually an encoded version of just a pointer to a\n+    // `Waiter`, so we add the `PhantomData` appropriately.\n+    state_and_queue: AtomicUsize,\n+    _marker: PhantomData<*mut Waiter>,\n+    // FIXME: switch to `std::mem::MaybeUninit` once we are ready to bump MSRV\n+    // that far. It was stabilized in 1.36.0, so, if you are reading this and\n+    // it's higher than 1.46.0 outside, please send a PR! ;) (and do the same\n+    // for `Lazy`, while we are at it).\n+    pub(crate) value: UnsafeCell<Option<T>>,\n+}\n+\n+// Why do we need `T: Send`?\n+// Thread A creates a `OnceCell` and shares it with\n+// scoped thread B, which fills the cell, which is\n+// then destroyed by A. That is, destructor observes\n+// a sent value.\n+unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n+unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n+\n+impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n+impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n+\n+impl<T> Default for SyncOnceCell<T> {\n+    fn default() -> SyncOnceCell<T> {\n+        SyncOnceCell::new()\n+    }\n+}\n+\n+impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"SyncOnceCell\").field(v).finish(),\n+            None => f.write_str(\"SyncOnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+impl<T: Clone> Clone for SyncOnceCell<T> {\n+    fn clone(&self) -> SyncOnceCell<T> {\n+        let res = SyncOnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+impl<T> From<T> for SyncOnceCell<T> {\n+    fn from(value: T) -> Self {\n+        let cell = Self::new();\n+        cell.get_or_init(|| value);\n+        cell\n+    }\n+}\n+\n+impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n+    fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+impl<T: Eq> Eq for SyncOnceCell<T> {}\n+\n+impl<T> SyncOnceCell<T> {\n+    /// Creates a new empty cell.\n+    pub const fn new() -> SyncOnceCell<T> {\n+        SyncOnceCell {\n+            state_and_queue: AtomicUsize::new(INCOMPLETE),\n+            _marker: PhantomData,\n+            value: UnsafeCell::new(None),\n+        }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty, or being initialized. This\n+    /// method never blocks.\n+    pub fn get(&self) -> Option<&T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialize\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        // Safe b/c we have a unique access.\n+        unsafe { &mut *self.value.get() }.as_mut()\n+    }\n+\n+    /// Get the reference to the underlying value, without checking if the\n+    /// cell is initialized.\n+    ///\n+    /// Safety:\n+    ///\n+    /// Caller must ensure that the cell is in initialized state, and that\n+    /// the contents are acquired by (synchronized to) this thread.\n+    pub unsafe fn get_unchecked(&self) -> &T {\n+        debug_assert!(self.is_initialized());\n+        let slot: &Option<T> = &*self.value.get();\n+        match slot {\n+            Some(value) => value,\n+            // This unsafe does improve performance, see `examples/bench`.\n+            None => {\n+                debug_assert!(false);\n+                unreachable_unchecked()\n+            }\n+        }\n+    }\n+\n+    /// Sets the contents of this cell to `value`.\n+    ///\n+    /// Returns `Ok(())` if the cell was empty and `Err(value)` if it was\n+    /// full.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+    ///\n+    /// fn main() {\n+    ///     assert!(CELL.get().is_none());\n+    ///\n+    ///     std::thread::spawn(|| {\n+    ///         assert_eq!(CELL.set(92), Ok(()));\n+    ///     }).join().unwrap();\n+    ///\n+    ///     assert_eq!(CELL.set(62), Err(62));\n+    ///     assert_eq!(CELL.get(), Some(&92));\n+    /// }\n+    /// ```\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        let mut value = Some(value);\n+        self.get_or_init(|| value.take().unwrap());\n+        match value {\n+            None => Ok(()),\n+            Some(value) => Err(value),\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if the cell\n+    /// was empty.\n+    ///\n+    /// Many threads may call `get_or_init` concurrently with different\n+    /// initializing functions, but it is guaranteed that only one function\n+    /// will be executed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The\n+    /// exact outcome is unspecified. Current implementation deadlocks, but\n+    /// this may be changed to a panic in the future.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and\n+    /// the cell remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`.\n+    /// The exact outcome is unspecified. Current implementation\n+    /// deadlocks, but this may be changed to a panic in the future.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        // Fast path check\n+        if let Some(value) = self.get() {\n+            return Ok(value);\n+        }\n+        self.initialize(f)?;\n+\n+        // Safe b/c called initialize\n+        debug_assert!(self.is_initialized());\n+        Ok(unsafe { self.get_unchecked() })\n+    }\n+\n+    /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n+    /// `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::lazy::SyncOnceCell;\n+    ///\n+    /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = SyncOnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.value.into_inner()\n+    }\n+\n+    /// Safety: synchronizes with store to value via Release/(Acquire|SeqCst).\n+    #[inline]\n+    fn is_initialized(&self) -> bool {\n+        // An `Acquire` load is enough because that makes all the initialization\n+        // operations visible to us, and, this being a fast path, weaker\n+        // ordering helps with performance. This `Acquire` synchronizes with\n+        // `SeqCst` operations on the slow path.\n+        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n+    }\n+\n+    /// Safety: synchronizes with store to value via SeqCst read from state,\n+    /// writes value only once because we never get to INCOMPLETE state after a\n+    /// successful write.\n+    #[cold]\n+    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        let mut f = Some(f);\n+        let mut res: Result<(), E> = Ok(());\n+        let slot = &self.value;\n+        initialize_inner(&self.state_and_queue, &mut || {\n+            let f = f.take().unwrap();\n+            match f() {\n+                Ok(value) => {\n+                    unsafe { *slot.get() = Some(value) };\n+                    true\n+                }\n+                Err(e) => {\n+                    res = Err(e);\n+                    false\n+                }\n+            }\n+        });\n+        res\n+    }\n+}\n+\n+// region: copy-paste\n+// The following code is copied from `sync::Once`.\n+// This should be uncopypasted once we decide the right way to handle panics.\n+const INCOMPLETE: usize = 0x0;\n+const RUNNING: usize = 0x1;\n+const COMPLETE: usize = 0x2;\n+\n+const STATE_MASK: usize = 0x3;\n+\n+\n+#[repr(align(4))]\n+struct Waiter {\n+    thread: Cell<Option<Thread>>,\n+    signaled: AtomicBool,\n+    next: *const Waiter,\n+}\n+\n+struct WaiterQueue<'a> {\n+    state_and_queue: &'a AtomicUsize,\n+    set_state_on_drop_to: usize,\n+}\n+\n+impl Drop for WaiterQueue<'_> {\n+    fn drop(&mut self) {\n+        let state_and_queue =\n+            self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n+\n+        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n+\n+        unsafe {\n+            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n+            while !queue.is_null() {\n+                let next = (*queue).next;\n+                let thread = (*queue).thread.replace(None).unwrap();\n+                (*queue).signaled.store(true, Ordering::Release);\n+                queue = next;\n+                thread.unpark();\n+            }\n+        }\n+    }\n+}\n+\n+fn initialize_inner(my_state_and_queue: &AtomicUsize, init: &mut dyn FnMut() -> bool) -> bool {\n+    let mut state_and_queue = my_state_and_queue.load(Ordering::Acquire);\n+\n+    loop {\n+        match state_and_queue {\n+            COMPLETE => return true,\n+            INCOMPLETE => {\n+                let old = my_state_and_queue.compare_and_swap(\n+                    state_and_queue,\n+                    RUNNING,\n+                    Ordering::Acquire,\n+                );\n+                if old != state_and_queue {\n+                    state_and_queue = old;\n+                    continue;\n+                }\n+                let mut waiter_queue = WaiterQueue {\n+                    state_and_queue: my_state_and_queue,\n+                    set_state_on_drop_to: INCOMPLETE,\n+                };\n+                let success = init();\n+\n+                waiter_queue.set_state_on_drop_to = if success { COMPLETE } else { INCOMPLETE };\n+                return success;\n+            }\n+            _ => {\n+                assert!(state_and_queue & STATE_MASK == RUNNING);\n+                wait(&my_state_and_queue, state_and_queue);\n+                state_and_queue = my_state_and_queue.load(Ordering::Acquire);\n+            }\n+        }\n+    }\n+}\n+\n+fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n+    loop {\n+        if current_state & STATE_MASK != RUNNING {\n+            return;\n+        }\n+\n+        let node = Waiter {\n+            thread: Cell::new(Some(thread::current())),\n+            signaled: AtomicBool::new(false),\n+            next: (current_state & !STATE_MASK) as *const Waiter,\n+        };\n+        let me = &node as *const Waiter as usize;\n+\n+        let old = state_and_queue.compare_and_swap(current_state, me | RUNNING, Ordering::Release);\n+        if old != current_state {\n+            current_state = old;\n+            continue;\n+        }\n+\n+        while !node.signaled.load(Ordering::Acquire) {\n+            thread::park();\n+        }\n+        break;\n+    }\n+}\n+// endregion: copy-paste\n+\n+/// A value which is initialized on the first access.\n+///\n+/// This type is thread-safe and can be used in statics:\n+///\n+/// # Example\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// use std::lazy::Lazy;\n+///\n+/// static HASHMAP: Lazy<HashMap<i32, String>> = Lazy::new(|| {\n+///     println!(\"initializing\");\n+///     let mut m = HashMap::new();\n+///     m.insert(13, \"Spica\".to_string());\n+///     m.insert(74, \"Hoyten\".to_string());\n+///     m\n+/// });\n+///\n+/// fn main() {\n+///     println!(\"ready\");\n+///     std::thread::spawn(|| {\n+///         println!(\"{:?}\", HASHMAP.get(&13));\n+///     }).join().unwrap();\n+///     println!(\"{:?}\", HASHMAP.get(&74));\n+///\n+///     // Prints:\n+///     //   ready\n+///     //   initializing\n+///     //   Some(\"Spica\")\n+///     //   Some(\"Hoyten\")\n+/// }\n+/// ```\n+pub struct SyncLazy<T, F = fn() -> T> {\n+    cell: SyncOnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+impl<T: fmt::Debug, F: fmt::Debug> fmt::Debug for SyncLazy<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SyncLazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}\n+\n+// We never create a `&F` from a `&SyncLazy<T, F>` so it is fine\n+// to not impl `Sync` for `F`\n+// we do create a `&mut Option<F>` in `force`, but this is\n+// properly synchronized, so it only happens once\n+// so it also does not contribute to this impl.\n+unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n+// auto-derived `Send` impl is OK.\n+\n+#[cfg(feature = \"std\")]\n+impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n+\n+impl<T, F> SyncLazy<T, F> {\n+    /// Creates a new lazy value with the given initializing\n+    /// function.\n+    pub const fn new(f: F) -> SyncLazy<T, F> {\n+        SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n+    /// Forces the evaluation of this lazy value and\n+    /// returns a reference to result. This is equivalent\n+    /// to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::lazy::SyncLazy;\n+    ///\n+    /// let lazy = SyncLazy::new(|| 92);\n+    ///\n+    /// assert_eq!(SyncLazy::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    pub fn force(this: &SyncLazy<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"SyncLazy instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        SyncLazy::force(self)\n+    }\n+}\n+\n+impl<T: Default> Default for SyncLazy<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> SyncLazy<T> {\n+        SyncLazy::new(T::default)\n+    }\n+}"}, {"sha": "171d6c3f64f8718db83571fc460198a845951600", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cac1768b03c8d6673c51605dca03997876979d68/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cac1768b03c8d6673c51605dca03997876979d68/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cac1768b03c8d6673c51605dca03997876979d68", "patch": "@@ -476,6 +476,12 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n+#[unstable(\n+    feature = \"std_lazy\",\n+    issue = \"99\",\n+)]\n+pub mod lazy;\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub mod task {\n     //! Types and Traits for working with asynchronous tasks."}]}