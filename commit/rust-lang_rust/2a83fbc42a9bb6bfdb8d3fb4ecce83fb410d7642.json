{"sha": "2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "node_id": "C_kwDOAAsO6NoAKDJhODNmYmM0MmE5YmI2YmZkYjhkM2ZiNGVjY2U4M2ZiNDEwZDc2NDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T10:25:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-12T10:25:49Z"}, "message": "Auto merge of #95966 - matthiaskrgr:rollup-hhy4nod, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95320 (Document the current MIR semantics that are clear from existing code)\n - #95722 (pre-push.sh: Use python3 if python is not found)\n - #95881 (Use `to_string` instead of `format!`)\n - #95909 (rustdoc: Reduce allocations in a `theme` function)\n - #95910 (Fix crate_type attribute to not warn on duplicates)\n - #95920 (use `Span::find_ancestor_inside` to get right span in CastCheck)\n - #95936 (Fix a bad error message for `relative paths are not supported in visibilities` error)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "adcd3859bc718dc7522e7ea8800ca338c43da86b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adcd3859bc718dc7522e7ea8800ca338c43da86b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "html_url": "https://github.com/rust-lang/rust/commit/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e1927db3c399fa34dc71992bd5dbec09f945c3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1927db3c399fa34dc71992bd5dbec09f945c3d", "html_url": "https://github.com/rust-lang/rust/commit/4e1927db3c399fa34dc71992bd5dbec09f945c3d"}, {"sha": "c3d6082e9b53f9c43f46a72af1b957b0cc0b2bf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d6082e9b53f9c43f46a72af1b957b0cc0b2bf7", "html_url": "https://github.com/rust-lang/rust/commit/c3d6082e9b53f9c43f46a72af1b957b0cc0b2bf7"}], "stats": {"total": 972, "additions": 736, "deletions": 236}, "files": [{"sha": "01af95851357e481da64e819bfc32bb2e785ca08", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 185, "deletions": 44, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -3,15 +3,14 @@\n use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPass, MirPhase, Operand,\n-    PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, START_BLOCK,\n+    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, Local, Location, MirPass,\n+    MirPhase, Operand, Place, PlaceElem, PlaceRef, ProjectionElem, Rvalue, SourceScope, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::fold::BottomUpFolder;\n-use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::AlwaysLiveLocals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n@@ -36,6 +35,13 @@ pub struct Validator {\n \n impl<'tcx> MirPass<'tcx> for Validator {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // FIXME(JakobDegen): These bodies never instantiated in codegend anyway, so it's not\n+        // terribly important that they pass the validator. However, I think other passes might\n+        // still see them, in which case they might be surprised. It would probably be better if we\n+        // didn't put this through the MIR pipeline at all.\n+        if matches!(body.source.instance, InstanceDef::Intrinsic(..) | InstanceDef::Virtual(..)) {\n+            return;\n+        }\n         let def_id = body.source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n@@ -240,58 +246,179 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n         self.super_projection_elem(local, proj_base, elem, context, location);\n     }\n \n-    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-        match &statement.kind {\n-            StatementKind::Assign(box (dest, rvalue)) => {\n-                // LHS and RHS of the assignment must have the same type.\n-                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n-                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n-                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+    fn visit_place(&mut self, place: &Place<'tcx>, _: PlaceContext, _: Location) {\n+        // Set off any `bug!`s in the type computation code\n+        let _ = place.ty(&self.body.local_decls, self.tcx);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        macro_rules! check_kinds {\n+            ($t:expr, $text:literal, $($patterns:tt)*) => {\n+                if !matches!(($t).kind(), $($patterns)*) {\n+                    self.fail(location, format!($text, $t));\n+                }\n+            };\n+        }\n+        match rvalue {\n+            Rvalue::Use(_) => {}\n+            Rvalue::Aggregate(agg_kind, _) => {\n+                let disallowed = match **agg_kind {\n+                    AggregateKind::Array(..) => false,\n+                    AggregateKind::Generator(..) => self.mir_phase >= MirPhase::GeneratorsLowered,\n+                    _ => self.mir_phase >= MirPhase::Deaggregated,\n+                };\n+                if disallowed {\n                     self.fail(\n                         location,\n-                        format!(\n-                            \"encountered `{:?}` with incompatible types:\\n\\\n-                            left-hand side has type: {}\\n\\\n-                            right-hand side has type: {}\",\n-                            statement.kind, left_ty, right_ty,\n-                        ),\n+                        format!(\"{:?} have been lowered to field assignments\", rvalue),\n+                    )\n+                }\n+            }\n+            Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n+                if self.mir_phase >= MirPhase::DropsLowered {\n+                    self.fail(\n+                        location,\n+                        \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n                     );\n                 }\n-                match rvalue {\n-                    // The sides of an assignment must not alias. Currently this just checks whether the places\n-                    // are identical.\n-                    Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) => {\n-                        if dest == src {\n+            }\n+            Rvalue::Len(p) => {\n+                let pty = p.ty(&self.body.local_decls, self.tcx).ty;\n+                check_kinds!(\n+                    pty,\n+                    \"Cannot compute length of non-array type {:?}\",\n+                    ty::Array(..) | ty::Slice(..)\n+                );\n+            }\n+            Rvalue::BinaryOp(op, vals) | Rvalue::CheckedBinaryOp(op, vals) => {\n+                use BinOp::*;\n+                let a = vals.0.ty(&self.body.local_decls, self.tcx);\n+                let b = vals.1.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    Offset => {\n+                        check_kinds!(a, \"Cannot offset non-pointer type {:?}\", ty::RawPtr(..));\n+                        if b != self.tcx.types.isize && b != self.tcx.types.usize {\n+                            self.fail(location, format!(\"Cannot offset by non-isize type {:?}\", b));\n+                        }\n+                    }\n+                    Eq | Lt | Le | Ne | Ge | Gt => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot compare type {:?}\",\n+                                ty::Bool\n+                                    | ty::Char\n+                                    | ty::Int(..)\n+                                    | ty::Uint(..)\n+                                    | ty::Float(..)\n+                                    | ty::RawPtr(..)\n+                                    | ty::FnPtr(..)\n+                            )\n+                        }\n+                        // None of the possible types have lifetimes, so we can just compare\n+                        // directly\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"encountered `Assign` statement with overlapping memory\",\n+                                format!(\"Cannot compare unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    Rvalue::Aggregate(agg_kind, _) => {\n-                        let disallowed = match **agg_kind {\n-                            AggregateKind::Array(..) => false,\n-                            AggregateKind::Generator(..) => {\n-                                self.mir_phase >= MirPhase::GeneratorsLowered\n-                            }\n-                            _ => self.mir_phase >= MirPhase::Deaggregated,\n-                        };\n-                        if disallowed {\n+                    Shl | Shr => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot shift non-integer type {:?}\",\n+                                ty::Uint(..) | ty::Int(..)\n+                            )\n+                        }\n+                    }\n+                    BitAnd | BitOr | BitXor => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform bitwise op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Bool\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                            )\n+                                format!(\n+                                    \"Cannot perform bitwise op on unequal types {:?} and {:?}\",\n+                                    a, b\n+                                ),\n+                            );\n                         }\n                     }\n-                    Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n-                        if self.mir_phase >= MirPhase::DropsLowered {\n+                    Add | Sub | Mul | Div | Rem => {\n+                        for x in [a, b] {\n+                            check_kinds!(\n+                                x,\n+                                \"Cannot perform op on type {:?}\",\n+                                ty::Uint(..) | ty::Int(..) | ty::Float(..)\n+                            )\n+                        }\n+                        if a != b {\n                             self.fail(\n                                 location,\n-                                \"`Assign` statement with a `Shallow` borrow should have been removed after drop lowering phase\",\n+                                format!(\"Cannot perform op on unequal types {:?} and {:?}\", a, b),\n                             );\n                         }\n                     }\n-                    _ => {}\n+                }\n+            }\n+            Rvalue::UnaryOp(op, operand) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                match op {\n+                    UnOp::Neg => {\n+                        check_kinds!(a, \"Cannot negate type {:?}\", ty::Int(..) | ty::Float(..))\n+                    }\n+                    UnOp::Not => {\n+                        check_kinds!(\n+                            a,\n+                            \"Cannot binary not type {:?}\",\n+                            ty::Int(..) | ty::Uint(..) | ty::Bool\n+                        );\n+                    }\n+                }\n+            }\n+            Rvalue::ShallowInitBox(operand, _) => {\n+                let a = operand.ty(&self.body.local_decls, self.tcx);\n+                check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n+            }\n+            _ => {}\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        match &statement.kind {\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                // LHS and RHS of the assignment must have the same type.\n+                let left_ty = dest.ty(&self.body.local_decls, self.tcx).ty;\n+                let right_ty = rvalue.ty(&self.body.local_decls, self.tcx);\n+                if !self.mir_assign_valid_types(right_ty, left_ty) {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered `{:?}` with incompatible types:\\n\\\n+                            left-hand side has type: {}\\n\\\n+                            right-hand side has type: {}\",\n+                            statement.kind, left_ty, right_ty,\n+                        ),\n+                    );\n+                }\n+                // FIXME(JakobDegen): Check this for all rvalues, not just this one.\n+                if let Rvalue::Use(Operand::Copy(src) | Operand::Move(src)) = rvalue {\n+                    // The sides of an assignment must not alias. Currently this just checks whether\n+                    // the places are identical.\n+                    if dest == src {\n+                        self.fail(\n+                            location,\n+                            \"encountered `Assign` statement with overlapping memory\",\n+                        );\n+                    }\n                 }\n             }\n             StatementKind::AscribeUserType(..) => {\n@@ -512,6 +639,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::Yield { resume, drop, .. } => {\n+                if self.body.generator.is_none() {\n+                    self.fail(location, \"`Yield` cannot appear outside generator bodies\");\n+                }\n                 if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(location, \"`Yield` should have been replaced by generator lowering\");\n                 }\n@@ -551,18 +681,29 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 }\n             }\n             TerminatorKind::GeneratorDrop => {\n+                if self.body.generator.is_none() {\n+                    self.fail(location, \"`GeneratorDrop` cannot appear outside generator bodies\");\n+                }\n                 if self.mir_phase >= MirPhase::GeneratorsLowered {\n                     self.fail(\n                         location,\n                         \"`GeneratorDrop` should have been replaced by generator lowering\",\n                     );\n                 }\n             }\n-            // Nothing to validate for these.\n-            TerminatorKind::Resume\n-            | TerminatorKind::Abort\n-            | TerminatorKind::Return\n-            | TerminatorKind::Unreachable => {}\n+            TerminatorKind::Resume | TerminatorKind::Abort => {\n+                let bb = location.block;\n+                if !self.body.basic_blocks()[bb].is_cleanup {\n+                    self.fail(location, \"Cannot `Resume` or `Abort` from non-cleanup basic block\")\n+                }\n+            }\n+            TerminatorKind::Return => {\n+                let bb = location.block;\n+                if self.body.basic_blocks()[bb].is_cleanup {\n+                    self.fail(location, \"Cannot `Return` from cleanup basic block\")\n+                }\n+            }\n+            TerminatorKind::Unreachable => {}\n         }\n \n         self.super_terminator(terminator, location);"}, {"sha": "e588385cfca03d6da6c72f3812a26e4d1ab329ca", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -310,7 +310,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Crate properties:\n     ungated!(crate_name, CrateLevel, template!(NameValueStr: \"name\"), FutureWarnFollowing),\n-    ungated!(crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), FutureWarnFollowing),\n+    ungated!(crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), DuplicatesOk),\n     // crate_id is deprecated\n     ungated!(crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), FutureWarnFollowing),\n "}, {"sha": "fd2b5f5335f69689407c5041f275536ae33d6b8f", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -59,6 +59,7 @@\n #![feature(unwrap_infallible)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n+#![feature(intra_doc_pointers)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "9f7832c8a64a2486e6435aa02238732941a28996", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 300, "deletions": 53, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -127,12 +127,24 @@ pub trait MirPass<'tcx> {\n /// The various \"big phases\" that MIR goes through.\n ///\n /// These phases all describe dialects of MIR. Since all MIR uses the same datastructures, the\n-/// dialects forbid certain variants or values in certain phases.\n+/// dialects forbid certain variants or values in certain phases. The sections below summarize the\n+/// changes, but do not document them thoroughly. The full documentation is found in the appropriate\n+/// documentation for the thing the change is affecting.\n ///\n /// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n+    /// The dialect of MIR used during all phases before `DropsLowered` is the same. This is also\n+    /// the MIR that analysis such as borrowck uses.\n+    ///\n+    /// One important thing to remember about the behavior of this section of MIR is that drop terminators\n+    /// (including drop and replace) are *conditional*. The elaborate drops pass will then replace each\n+    /// instance of a drop terminator with a nop, an unconditional drop, or a drop conditioned on a drop\n+    /// flag. Of course, this means that it is important that the drop elaboration can accurately recognize\n+    /// when things are initialized and when things are de-initialized. That means any code running on this\n+    /// version of MIR must be sure to produce output that drop elaboration can reason about. See the\n+    /// section on the drop terminatorss for more details.\n     Built = 0,\n     // FIXME(oli-obk): it's unclear whether we still need this phase (and its corresponding query).\n     // We used to have this for pre-miri MIR based const eval.\n@@ -162,6 +174,16 @@ pub enum MirPhase {\n     /// And the following variant is allowed:\n     /// * [`StatementKind::SetDiscriminant`]\n     Deaggregated = 4,\n+    /// Before this phase, generators are in the \"source code\" form, featuring `yield` statements\n+    /// and such. With this phase change, they are transformed into a proper state machine. Running\n+    /// optimizations before this change can be potentially dangerous because the source code is to\n+    /// some extent a \"lie.\" In particular, `yield` terminators effectively make the value of all\n+    /// locals visible to the caller. This means that dead store elimination before them, or code\n+    /// motion across them, is not correct in general. This is also exasperated by type checking\n+    /// having pre-computed a list of the types that it thinks are ok to be live across a yield\n+    /// point - this is necessary to decide eg whether autotraits are implemented. Introducing new\n+    /// types across a yield point will lead to ICEs becaues of this.\n+    ///\n     /// Beginning with this phase, the following variants are disallowed:\n     /// * [`TerminatorKind::Yield`](terminator::TerminatorKind::Yield)\n     /// * [`TerminatorKind::GeneratorDrop](terminator::TerminatorKind::GeneratorDrop)\n@@ -1573,18 +1595,45 @@ impl Statement<'_> {\n /// causing an ICE if they are violated.\n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n-    /// Write the RHS Rvalue to the LHS Place.\n+    /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n+    /// without the possibility of dropping the previous value (that must be done separately, if at\n+    /// all). The *exact* way this works is undecided. It probably does something like evaluating\n+    /// the LHS to a place and the RHS to a value, and then storing the value to the place. Various\n+    /// parts of this may do type specific things that are more complicated than simply copying\n+    /// bytes.\n+    ///\n+    /// **Needs clarification**: The implication of the above idea would be that assignment implies\n+    /// that the resulting value is initialized. I believe we could commit to this separately from\n+    /// committing to whatever part of the memory model we would need to decide on to make the above\n+    /// paragragh precise. Do we want to?\n+    ///\n+    /// Assignments in which the types of the place and rvalue differ are not well-formed.\n+    ///\n+    /// **Needs clarification**: Do we ever want to worry about non-free (in the body) lifetimes for\n+    /// the typing requirement in post drop-elaboration MIR? I think probably not - I'm not sure we\n+    /// could meaningfully require this anyway. How about free lifetimes? Is ignoring this\n+    /// interesting for optimizations? Do we want to allow such optimizations?\n     ///\n-    /// The LHS place may not overlap with any memory accessed on the RHS.\n+    /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n+    /// read as part of computation of the RHS for some rvalues (generally those not producing\n+    /// primitives). This requirement is under discussion in [#68364]. As a part of this discussion,\n+    /// it is also unclear in what order the components are evaluated.\n+    ///\n+    /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n+    ///\n+    /// See [`Rvalue`] documentation for details on each of those.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n-    /// This represents all the reading that a pattern match may do\n-    /// (e.g., inspecting constants and discriminant values), and the\n-    /// kind of pattern it comes from. This is in order to adapt potential\n-    /// error messages to these specific patterns.\n+    /// This represents all the reading that a pattern match may do (e.g., inspecting constants and\n+    /// discriminant values), and the kind of pattern it comes from. This is in order to adapt\n+    /// potential error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1599,17 +1648,35 @@ pub enum StatementKind<'tcx> {\n     /// This writes `uninit` bytes to the entire place.\n     Deinit(Box<Place<'tcx>>),\n \n-    /// Start a live range for the storage of the local.\n+    /// `StorageLive` and `StorageDead` statements mark the live range of a local.\n+    ///\n+    /// Using a local before a `StorageLive` or after a `StorageDead` is not well-formed. These\n+    /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n+    /// statements for a particular local, the local is always considered live.\n+    ///\n+    /// More precisely, the MIR validator currently does a `MaybeStorageLiveLocals` analysis to\n+    /// check validity of each use of a local. I believe this is equivalent to requiring for every\n+    /// use of a local, there exist at least one path from the root to that use that contains a\n+    /// `StorageLive` more recently than a `StorageDead`.\n+    ///\n+    /// **Needs clarification**: Is it permitted to have two `StorageLive`s without an intervening\n+    /// `StorageDead`? Two `StorageDead`s without an intervening `StorageLive`? LLVM says poison,\n+    /// yes. If the answer to any of these is \"no,\" is breaking that rule UB or is it an error to\n+    /// have a path in the CFG that might do this?\n     StorageLive(Local),\n \n-    /// End the current live range for the storage of the local.\n+    /// See `StorageLive` above.\n     StorageDead(Local),\n \n-    /// Retag references in the given place, ensuring they got fresh tags. This is\n-    /// part of the Stacked Borrows model. These statements are currently only interpreted\n-    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n-    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n-    /// for more details.\n+    /// Retag references in the given place, ensuring they got fresh tags.\n+    ///\n+    /// This is part of the Stacked Borrows model. These statements are currently only interpreted\n+    /// by miri and only generated when `-Z mir-emit-retag` is passed. See\n+    /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n+    /// more details.\n+    ///\n+    /// For code that is not specific to stacked borrows, you should consider retags to read\n+    /// and modify the place in an opaque way.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n@@ -1624,6 +1691,10 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// Marks the start of a \"coverage region\", injected with '-Cinstrument-coverage'. A\n@@ -1633,9 +1704,19 @@ pub enum StatementKind<'tcx> {\n     /// executed.\n     Coverage(Box<Coverage>),\n \n-    /// Denotes a call to the intrinsic function copy_overlapping, where `src_dst` denotes the\n-    /// memory being read from and written to(one field to save memory), and size\n-    /// indicates how many bytes are being copied over.\n+    /// Denotes a call to the intrinsic function `copy_nonoverlapping`.\n+    ///\n+    /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n+    /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n+    /// `dest` are dereferenced, and `count * size_of::<T>()` bytes beginning with the first byte of\n+    /// the `src` place are copied to the continguous range of bytes beginning with the first byte\n+    /// of `dest`.\n+    ///\n+    /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n+    /// probably match the order for assignment, but that is also undecided.\n+    ///\n+    /// **Needs clarification**: Is this typed or not, ie is there a typed load and store involved?\n+    /// I vaguely remember Ralf saying somewhere that he thought it should not be.\n     CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n@@ -1785,8 +1866,82 @@ pub struct CopyNonOverlapping<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-/// A path to a value; something that can be evaluated without\n-/// changing or disturbing program state.\n+/// Places roughly correspond to a \"location in memory.\" Places in MIR are the same mathematical\n+/// object as places in Rust. This of course means that what exactly they are is undecided and part\n+/// of the Rust memory model. However, they will likely contain at least the following pieces of\n+/// information in some form:\n+///\n+///  1. The address in memory that the place refers to.\n+///  2. The provenance with which the place is being accessed.\n+///  3. The type of the place and an optional variant index. See [`PlaceTy`][tcx::PlaceTy].\n+///  4. Optionally, some metadata. This exists if and only if the type of the place is not `Sized`.\n+///\n+/// We'll give a description below of how all pieces of the place except for the provenance are\n+/// calculated. We cannot give a description of the provenance, because that is part of the\n+/// undecided aliasing model - we only include it here at all to acknowledge its existence.\n+///\n+/// Each local naturally corresponds to the place `Place { local, projection: [] }`. This place has\n+/// the address of the local's allocation and the type of the local.\n+///\n+/// **Needs clarification:** Unsized locals seem to present a bit of an issue. Their allocation\n+/// can't actually be created on `StorageLive`, because it's unclear how big to make the allocation.\n+/// Furthermore, MIR produces assignments to unsized locals, although that is not permitted under\n+/// `#![feature(unsized_locals)]` in Rust. Besides just putting \"unsized locals are special and\n+/// different\" in a bunch of places, I (JakobDegen) don't know how to incorporate this behavior into\n+/// the current MIR semantics in a clean way - possibly this needs some design work first.\n+///\n+/// For places that are not locals, ie they have a non-empty list of projections, we define the\n+/// values as a function of the parent place, that is the place with its last [`ProjectionElem`]\n+/// stripped. The way this is computed of course depends on the kind of that last projection\n+/// element:\n+///\n+///  - [`Downcast`](ProjectionElem::Downcast): This projection sets the place's variant index to the\n+///    given one, and makes no other changes. A `Downcast` projection on a place with its variant\n+///    index already set is not well-formed.\n+///  - [`Field`](ProjectionElem::Field): `Field` projections take their parent place and create a\n+///    place referring to one of the fields of the type. The resulting address is the parent\n+///    address, plus the offset of the field. The type becomes the type of the field. If the parent\n+///    was unsized and so had metadata associated with it, then the metadata is retained if the\n+///    field is unsized and thrown out if it is sized.\n+///\n+///    These projections are only legal for tuples, ADTs, closures, and generators. If the ADT or\n+///    generator has more than one variant, the parent place's variant index must be set, indicating\n+///    which variant is being used. If it has just one variant, the variant index may or may not be\n+///    included - the single possible variant is inferred if it is not included.\n+///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n+///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n+///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n+///    place has type `[T;  N]` or `[T]` (*not* `&[T]`). Since such a `T` is always sized, any\n+///    resulting metadata is thrown out.\n+///  - [`Subslice`](ProjectionElem::Subslice): This projection calculates an offset and a new\n+///    address in a similar manner as `ConstantIndex`. It is also only legal on `[T; N]` and `[T]`.\n+///    However, this yields a `Place` of type `[T]`, and additionally sets the metadata to be the\n+///    length of the subslice.\n+///  - [`Index`](ProjectionElem::Index): Like `ConstantIndex`, only legal on `[T; N]` or `[T]`.\n+///    However, `Index` additionally takes a local from which the value of the index is computed at\n+///    runtime. Computing the value of the index involves interpreting the `Local` as a\n+///    `Place { local, projection: [] }`, and then computing its value as if done via\n+///    [`Operand::Copy`]. The array/slice is then indexed with the resulting value. The local must\n+///    have type `usize`.\n+///  - [`Deref`](ProjectionElem::Deref): Derefs are the last type of projection, and the most\n+///    complicated. They are only legal on parent places that are references, pointers, or `Box`. A\n+///    `Deref` projection begins by loading a value from the parent place, as if by\n+///    [`Operand::Copy`]. It then dereferences the resulting pointer, creating a place of the\n+///    pointee's type. The resulting address is the address that was stored in the pointer. If the\n+///    pointee type is unsized, the pointer additionally stored the value of the metadata.\n+///\n+/// Computing a place may cause UB. One possibility is that the pointer used for a `Deref` may not\n+/// be suitably aligned. Another possibility is that the place is not in bounds, meaning it does not\n+/// point to an actual allocation.\n+///\n+/// However, if this is actually UB and when the UB kicks in is undecided. This is being discussed\n+/// in [UCG#319]. The options include that every place must obey those rules, that only some places\n+/// must obey them, or that places impose no rules of their own.\n+///\n+/// [UCG#319]: https://github.com/rust-lang/unsafe-code-guidelines/issues/319\n+///\n+/// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n+/// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n@@ -2155,24 +2310,39 @@ pub struct SourceScopeLocalData {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n \n-/// These are values that can appear inside an rvalue. They are intentionally\n-/// limited to prevent rvalues from being nested in one another.\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n+///\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n+///\n+/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n+/// currently implements it, but it seems like this may be something to check against in the\n+/// validator.\n #[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum Operand<'tcx> {\n-    /// Copy: The value must be available for use afterwards.\n-    ///\n-    /// This implies that the type of the place must be `Copy`; this is true\n-    /// by construction during build, but also checked by the MIR type checker.\n+    /// Creates a value by loading the given place. The type of the place must be `Copy`\n     Copy(Place<'tcx>),\n \n-    /// Move: The value (including old borrows of it) will not be used again.\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n     ///\n-    /// Safe for values of all types (modulo future developments towards `?Move`).\n-    /// Correct usage patterns are enforced by the borrow checker for safe code.\n-    /// `Copy` may be converted to `Move` to enable \"last-use\" optimizations.\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n     Move(Place<'tcx>),\n \n-    /// Synthesizes a constant value.\n+    /// Constants are already semantically values, and remain unchanged.\n     Constant(Box<Constant<'tcx>>),\n }\n \n@@ -2280,57 +2450,134 @@ impl<'tcx> Operand<'tcx> {\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n /// The various kinds of rvalues that can appear in MIR.\n ///\n-/// Not all of these are allowed at every [`MirPhase`]. Check the documentation there to see which\n-/// ones you do not have to worry about. The MIR validator will generally enforce such restrictions,\n-/// causing an ICE if they are violated.\n+/// Not all of these are allowed at every [`MirPhase`] - when this is the case, it's stated below.\n+///\n+/// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n+/// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n+/// value that an [`Operand`] produces.\n pub enum Rvalue<'tcx> {\n-    /// x (either a move or copy, depending on type of x)\n+    /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n \n-    /// [x; 32]\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n     Repeat(Operand<'tcx>, ty::Const<'tcx>),\n \n-    /// &x or &mut x\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n \n-    /// Accessing a thread local static. This is inherently a runtime operation, even if llvm\n-    /// treats it as an access to a static. This `Rvalue` yields a reference to the thread local\n-    /// static.\n+    /// Creates a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n     ThreadLocalRef(DefId),\n \n-    /// Create a raw pointer to the given place\n-    /// Can be generated by raw address of expressions (`&raw const x`),\n-    /// or when casting a reference to a raw pointer.\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n     AddressOf(Mutability, Place<'tcx>),\n \n-    /// length of a `[X]` or `[X;n]` value\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n     Len(Place<'tcx>),\n \n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n \n+    /// * `Offset` has the same semantics as [`offset`](pointer::offset), except that the second\n+    ///   parameter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers of matching types and return a `bool`.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n     BinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` instead of `T`. In addition to performing the\n+    /// same computation as the matching `BinaryOp`, checks if the infinite precison result would be\n+    /// unequal to the actual result and sets the `bool` if this is the case.\n+    ///\n+    /// This only supports addition, subtraction, multiplication, and shift operations on integers.\n     CheckedBinaryOp(BinOp, Box<(Operand<'tcx>, Operand<'tcx>)>),\n \n+    /// Computes a value as described by the operation.\n     NullaryOp(NullOp, Ty<'tcx>),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n     UnaryOp(UnOp, Operand<'tcx>),\n \n-    /// Read the discriminant of an ADT.\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`].\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// For types defined in the source code as enums, this is well behaved. This is also well\n+    /// formed for other types, but yields no particular value - there is no reason it couldn't be\n+    /// defined to yield eg zero though.\n     ///\n-    /// Undefined (i.e., no effort is made to make it defined, but there\u2019s no reason why it cannot\n-    /// be defined to return, say, a 0) if ADT is not an enum.\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n     Discriminant(Place<'tcx>),\n \n-    /// Creates an aggregate value, like a tuple or struct. This is\n-    /// only needed because we want to distinguish `dest = Foo { x:\n-    /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n-    /// that `Foo` has a destructor. These rvalues can be optimized\n-    /// away after type-checking and before lowering.\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n-    /// This is different a normal transmute because dataflow analysis will treat the box\n-    /// as initialized but its content as uninitialized.\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ///\n+    /// Disallowed after drop elaboration.\n     ShallowInitBox(Operand<'tcx>, Ty<'tcx>),\n }\n "}, {"sha": "597ade42236842c10ba0cb8b4675c87f44779021", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -76,6 +76,9 @@ impl<'tcx> PlaceTy<'tcx> {\n         V: ::std::fmt::Debug,\n         T: ::std::fmt::Debug + Copy,\n     {\n+        if self.variant_index.is_some() && !matches!(elem, ProjectionElem::Field(..)) {\n+            bug!(\"cannot use non field projection on downcasted place\")\n+        }\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n                 let ty = self"}, {"sha": "cc08857463d5869301f8831865d10654fa01b573", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 123, "deletions": 27, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -105,13 +105,34 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n+/// A note on unwinding: Panics may occur during the execution of some terminators. Depending on the\n+/// `-C panic` flag, this may either cause the program to abort or the call stack to unwind. Such\n+/// terminators have a `cleanup: Option<BasicBlock>` field on them. If stack unwinding occurs, then\n+/// once the current function is reached, execution continues at the given basic block, if any. If\n+/// `cleanup` is `None` then no cleanup is performed, and the stack continues unwinding. This is\n+/// equivalent to the execution of a `Resume` terminator.\n+///\n+/// The basic block pointed to by a `cleanup` field must have its `cleanup` flag set. `cleanup`\n+/// basic blocks have a couple restrictions:\n+///  1. All `cleanup` fields in them must be `None`.\n+///  2. `Return` terminators are not allowed in them. `Abort` and `Unwind` terminators are.\n+///  3. All other basic blocks (in the current body) that are reachable from `cleanup` basic blocks\n+///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n+///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n+///     runtime.\n #[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n-    /// Block should have one successor in the graph; we jump there.\n+    /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlock },\n \n-    /// Operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`.\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n     SwitchInt {\n         /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n@@ -124,29 +145,62 @@ pub enum TerminatorKind<'tcx> {\n         targets: SwitchTargets,\n     },\n \n-    /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by `build::scope::diverge_cleanup`.\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n     Resume,\n \n-    /// Indicates that the landing pad is finished and that the process\n-    /// should abort. Used to prevent unwinding for foreign items.\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n     Abort,\n \n-    /// Indicates a normal return. The return place should have\n-    /// been filled in before this executes. This can occur multiple times\n-    /// in different basic blocks.\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n     Return,\n \n     /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n     Unreachable,\n \n-    /// Drop the `Place`.\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n     Drop { place: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the `Place` and assign the new value over it. This ensures\n-    /// that the assignment to `P` occurs *even if* the destructor for\n-    /// place unwinds. Its semantics are best explained by the\n-    /// elaboration:\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n     ///\n     /// ```\n     /// BB0 {\n@@ -170,15 +224,24 @@ pub enum TerminatorKind<'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Note that DropAndReplace is eliminated as part of the `ElaborateDrops` pass.\n+    /// Disallowed after drop elaboration.\n     DropAndReplace {\n         place: Place<'tcx>,\n         value: Operand<'tcx>,\n         target: BasicBlock,\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a function.\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n     Call {\n         /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n@@ -187,7 +250,7 @@ pub enum TerminatorKind<'tcx> {\n         /// This allows the memory occupied by \"by-value\" arguments to be\n         /// reused across function calls without duplicating the contents.\n         args: Vec<Operand<'tcx>>,\n-        /// Destination for the return value. If some, the call is converging.\n+        /// Destination for the return value. If none, the call necessarily diverges.\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n@@ -199,8 +262,12 @@ pub enum TerminatorKind<'tcx> {\n         fn_span: Span,\n     },\n \n-    /// Jump to the target if the condition has the expected value,\n-    /// otherwise panic with a message and a cleanup target.\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n     Assert {\n         cond: Operand<'tcx>,\n         expected: bool,\n@@ -209,7 +276,18 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point.\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n     Yield {\n         /// The value to return.\n         value: Operand<'tcx>,\n@@ -221,21 +299,39 @@ pub enum TerminatorKind<'tcx> {\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator.\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n     GeneratorDrop,\n \n-    /// A block where control flow only ever takes one real path, but borrowck\n-    /// needs to be more conservative.\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseEdge {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n         /// practice.\n         imaginary_target: BasicBlock,\n     },\n-    /// A terminator for blocks that only take one path in reality, but where we\n-    /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n-    /// This can arise in infinite loops with no function calls for example.\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FalseUnwind {\n         /// The target normal control flow will take.\n         real_target: BasicBlock,"}, {"sha": "ca81921faedcccc3f25ff84f4063134ab0f3cd47", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -970,7 +970,7 @@ impl<'a> Parser<'a> {\n         }\n         if fixed_crate_name {\n             let fixed_name_sp = ident.span.to(idents.last().unwrap().span);\n-            let mut fixed_name = format!(\"{}\", ident.name);\n+            let mut fixed_name = ident.name.to_string();\n             for part in idents {\n                 fixed_name.push_str(&format!(\"_{}\", part.name));\n             }"}, {"sha": "de2229f742d225c9ac187d41a8a37f239ca11b09", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -632,7 +632,7 @@ impl<'a> Resolver<'a> {\n             VisResolutionError::Relative2018(span, path) => {\n                 let mut err = self.session.struct_span_err(\n                     span,\n-                    \"relative paths are not supported in visibilities on 2018 edition\",\n+                    \"relative paths are not supported in visibilities in 2018 edition or later\",\n                 );\n                 err.span_suggestion(\n                     path.span,"}, {"sha": "47292b3e339e584d3ec596bbb17c8b85d34c9eb4", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -55,6 +55,7 @@ use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n pub struct CastCheck<'tcx> {\n     expr: &'tcx hir::Expr<'tcx>,\n     expr_ty: Ty<'tcx>,\n+    expr_span: Span,\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n     span: Span,\n@@ -207,7 +208,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         cast_span: Span,\n         span: Span,\n     ) -> Result<CastCheck<'tcx>, ErrorGuaranteed> {\n-        let check = CastCheck { expr, expr_ty, cast_ty, cast_span, span };\n+        let expr_span = expr.span.find_ancestor_inside(span).unwrap_or(expr.span);\n+        let check = CastCheck { expr, expr_ty, expr_span, cast_ty, cast_span, span };\n \n         // For better error messages, check for some obviously unsized\n         // cases now. We do a more thorough check at the end, once\n@@ -240,15 +242,15 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     error_span,\n                     format!(\"cannot cast `{}` as `{}`\", fcx.ty_to_string(self.expr_ty), cast_ty),\n                 );\n-                if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr.span) {\n+                if let Ok(snippet) = fcx.sess().source_map().span_to_snippet(self.expr_span) {\n                     err.span_suggestion(\n-                        self.expr.span,\n+                        self.expr_span,\n                         \"dereference the expression\",\n                         format!(\"*{}\", snippet),\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    err.span_help(self.expr.span, \"dereference the expression with `*`\");\n+                    err.span_help(self.expr_span, \"dereference the expression with `*`\");\n                 }\n                 err.emit();\n             }\n@@ -315,7 +317,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\");\n \n                 if self.expr_ty.is_numeric() {\n-                    match fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                    match fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n                         Ok(snippet) => {\n                             err.span_suggestion(\n                                 self.span,\n@@ -440,7 +442,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 }\n                 if sugg_mutref {\n                     err.span_label(self.span, \"invalid cast\");\n-                    err.span_note(self.expr.span, \"this reference is immutable\");\n+                    err.span_note(self.expr_span, \"this reference is immutable\");\n                     err.span_note(self.cast_span, \"trying to cast to a mutable reference type\");\n                 } else if let Some((sugg, remove_cast)) = sugg {\n                     err.span_label(self.span, \"invalid cast\");\n@@ -449,7 +451,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         .tcx\n                         .sess\n                         .source_map()\n-                        .span_to_snippet(self.expr.span)\n+                        .span_to_snippet(self.expr_span)\n                         .map_or(false, |snip| snip.starts_with('('));\n \n                     // Very crude check to see whether the expression must be wrapped\n@@ -458,14 +460,14 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     let needs_parens =\n                         !has_parens && matches!(self.expr.kind, hir::ExprKind::Cast(..));\n \n-                    let mut suggestion = vec![(self.expr.span.shrink_to_lo(), sugg)];\n+                    let mut suggestion = vec![(self.expr_span.shrink_to_lo(), sugg)];\n                     if needs_parens {\n                         suggestion[0].1 += \"(\";\n-                        suggestion.push((self.expr.span.shrink_to_hi(), \")\".to_string()));\n+                        suggestion.push((self.expr_span.shrink_to_hi(), \")\".to_string()));\n                     }\n                     if remove_cast {\n                         suggestion.push((\n-                            self.expr.span.shrink_to_hi().to(self.cast_span),\n+                            self.expr_span.shrink_to_hi().to(self.cast_span),\n                             String::new(),\n                         ));\n                     }\n@@ -481,7 +483,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 ) {\n                     let mut label = true;\n                     // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n-                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n                         if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::From) {\n                             let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n                             // Erase regions to avoid panic in `prove_value` when calling\n@@ -550,7 +552,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n                 if fcx.tcx.sess.is_nightly_build() {\n                     err.span_label(\n-                        self.expr.span,\n+                        self.expr_span,\n                         \"consider casting this expression to `*const ()`, \\\n                         then using `core::ptr::from_raw_parts`\",\n                     );\n@@ -651,7 +653,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 }\n             }\n             _ => {\n-                err.span_help(self.expr.span, \"consider using a box or reference as appropriate\");\n+                err.span_help(self.expr_span, \"consider using a box or reference as appropriate\");\n             }\n         }\n         err.emit()\n@@ -685,7 +687,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n     #[instrument(skip(fcx), level = \"debug\")]\n     pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n-        self.expr_ty = fcx.structurally_resolved_type(self.expr.span, self.expr_ty);\n+        self.expr_ty = fcx.structurally_resolved_type(self.expr_span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.cast_span, self.cast_ty);\n \n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.hir_id, self.expr_ty, self.cast_ty);\n@@ -741,7 +743,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     ty::FnDef(..) => {\n                         // Attempt a coercion to a fn pointer type.\n                         let f = fcx.normalize_associated_types_in(\n-                            self.expr.span,\n+                            self.expr_span,\n                             self.expr_ty.fn_sig(fcx.tcx),\n                         );\n                         let res = fcx.try_coerce(\n@@ -997,7 +999,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 ));\n \n                 let msg = \"use `.addr()` to obtain the address of a pointer\";\n-                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n                     let scalar_cast = match t_c {\n                         ty::cast::IntTy::U(ty::UintTy::Usize) => String::new(),\n                         _ => format!(\" as {}\", self.cast_ty),\n@@ -1027,13 +1029,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             self.expr.hir_id,\n             self.span,\n             |err| {\n-\n                 let mut err = err.build(&format!(\n                     \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n                     self.expr_ty, self.cast_ty\n                 ));\n                 let msg = \"use `.with_addr()` to adjust a valid pointer in the same allocation, to this address\";\n-                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr.span) {\n+                if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n                     err.span_suggestion(\n                         self.span,\n                         msg,"}, {"sha": "5f5b48bc1c0b43ff235a91779e173ac3d05e2090", "filename": "src/etc/pre-push.sh", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Fetc%2Fpre-push.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Fetc%2Fpre-push.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpre-push.sh?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/env bash\n #\n-# Call `tidy --bless` before each commit\n+# Call `tidy --bless` before git push\n # Copy this script to .git/hooks to activate,\n # and remove it from .git/hooks to deactivate.\n #\n@@ -14,6 +14,8 @@ COMMAND=\"$ROOT_DIR/x.py test tidy --bless\"\n \n if [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n   COMMAND=\"python $COMMAND\"\n+elif ! command -v python &> /dev/null; then\n+  COMMAND=\"python3 $COMMAND\"\n fi\n \n echo \"Running pre-push script '$COMMAND'\""}, {"sha": "7c19865b6d78bd1162c5eff44cf9498ad6432c78", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -173,15 +173,17 @@ fn build_rule(v: &[u8], positions: &[usize]) -> String {\n             .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n             .collect::<String>()\n             .trim()\n-            .replace('\\n', \" \")\n-            .replace('/', \"\")\n-            .replace('\\t', \" \")\n-            .replace('{', \"\")\n-            .replace('}', \"\")\n+            .chars()\n+            .filter_map(|c| match c {\n+                '\\n' | '\\t' => Some(' '),\n+                '/' | '{' | '}' => None,\n+                c => Some(c),\n+            })\n+            .collect::<String>()\n             .split(' ')\n             .filter(|s| !s.is_empty())\n-            .collect::<Vec<&str>>()\n-            .join(\" \"),\n+            .intersperse(\" \")\n+            .collect::<String>(),\n     )\n     .unwrap_or_else(|_| String::new())\n }"}, {"sha": "eab51b65f1a19a6e868dbe6b4c24221a5d7b917e", "filename": "src/test/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // EMIT_MIR lower_intrinsics.wrapping.LowerIntrinsics.diff\n-pub fn wrapping<T: Copy>(a: T, b: T) {\n+pub fn wrapping(a: i32, b: i32) {\n     let _x = core::intrinsics::wrapping_add(a, b);\n     let _y = core::intrinsics::wrapping_sub(a, b);\n     let _z = core::intrinsics::wrapping_mul(a, b);"}, {"sha": "5a0286bad2fb7cba37a66835507b7496a3a41101", "filename": "src/test/mir-opt/lower_intrinsics.wrapping.LowerIntrinsics.diff", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -1,23 +1,23 @@\n - // MIR for `wrapping` before LowerIntrinsics\n + // MIR for `wrapping` after LowerIntrinsics\n   \n-  fn wrapping(_1: T, _2: T) -> () {\n-      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:26: 6:27\n-      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:32: 6:33\n-      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:38: 6:38\n-      let _3: T;                           // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-      let mut _4: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n-      let mut _5: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n-      let mut _7: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n-      let mut _8: T;                       // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n-      let mut _10: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n-      let mut _11: T;                      // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n+  fn wrapping(_1: i32, _2: i32) -> () {\n+      debug a => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:17: 6:18\n+      debug b => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:6:25: 6:26\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:6:33: 6:33\n+      let _3: i32;                         // in scope 0 at $DIR/lower_intrinsics.rs:7:9: 7:11\n+      let mut _4: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n+      let mut _5: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n+      let mut _7: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:45: 8:46\n+      let mut _8: i32;                     // in scope 0 at $DIR/lower_intrinsics.rs:8:48: 8:49\n+      let mut _10: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:45: 9:46\n+      let mut _11: i32;                    // in scope 0 at $DIR/lower_intrinsics.rs:9:48: 9:49\n       scope 1 {\n           debug _x => _3;                  // in scope 1 at $DIR/lower_intrinsics.rs:7:9: 7:11\n-          let _6: T;                       // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n+          let _6: i32;                     // in scope 1 at $DIR/lower_intrinsics.rs:8:9: 8:11\n           scope 2 {\n               debug _y => _6;              // in scope 2 at $DIR/lower_intrinsics.rs:8:9: 8:11\n-              let _9: T;                   // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n+              let _9: i32;                 // in scope 2 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               scope 3 {\n                   debug _z => _9;          // in scope 3 at $DIR/lower_intrinsics.rs:9:9: 9:11\n               }\n@@ -30,10 +30,10 @@\n           _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:7:45: 7:46\n           StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:7:48: 7:49\n--         _3 = wrapping_add::<T>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n+-         _3 = wrapping_add::<i32>(move _4, move _5) -> bb1; // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:7:14: 7:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_add::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_add::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _3 = Add(move _4, move _5);      // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:7:14: 7:50\n       }\n@@ -46,10 +46,10 @@\n           _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:8:45: 8:46\n           StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:8:48: 8:49\n--         _6 = wrapping_sub::<T>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n+-         _6 = wrapping_sub::<i32>(move _7, move _8) -> bb2; // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:8:14: 8:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_sub::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_sub::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _6 = Sub(move _7, move _8);      // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:8:14: 8:50\n       }\n@@ -62,18 +62,18 @@\n           _10 = _1;                        // scope 2 at $DIR/lower_intrinsics.rs:9:45: 9:46\n           StorageLive(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:9:48: 9:49\n--         _9 = wrapping_mul::<T>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n+-         _9 = wrapping_mul::<i32>(move _10, move _11) -> bb3; // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:9:14: 9:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(T, T) -> T {wrapping_mul::<T>}, val: Value(Scalar(<ZST>)) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_mul::<i32>}, val: Value(Scalar(<ZST>)) }\n +         _9 = Mul(move _10, move _11);    // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:9:14: 9:50\n       }\n   \n       bb3: {\n           StorageDead(_11);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n           StorageDead(_10);                // scope 2 at $DIR/lower_intrinsics.rs:9:49: 9:50\n-          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:38: 10:2\n+          _0 = const ();                   // scope 0 at $DIR/lower_intrinsics.rs:6:33: 10:2\n           StorageDead(_9);                 // scope 2 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_6);                 // scope 1 at $DIR/lower_intrinsics.rs:10:1: 10:2\n           StorageDead(_3);                 // scope 0 at $DIR/lower_intrinsics.rs:10:1: 10:2"}, {"sha": "b509b3239bc58b133523f4c50735a68cd7c3483d", "filename": "src/test/ui/cast/cast-macro-lhs.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -0,0 +1,12 @@\n+// Test to make sure we suggest \"consider casting\" on the right span\n+\n+macro_rules! foo {\n+    () => { 0 }\n+}\n+\n+fn main() {\n+    let x = foo!() as *const [u8];\n+    //~^ ERROR cannot cast `usize` to a pointer that is wide\n+    //~| NOTE creating a `*const [u8]` requires both an address and a length\n+    //~| NOTE consider casting this expression to `*const ()`, then using `core::ptr::from_raw_parts`\n+}"}, {"sha": "db7ce57e15062e5086b0282ac6e02c4a19f4efad", "filename": "src/test/ui/cast/cast-macro-lhs.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcast%2Fcast-macro-lhs.stderr?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -0,0 +1,11 @@\n+error[E0606]: cannot cast `usize` to a pointer that is wide\n+  --> $DIR/cast-macro-lhs.rs:8:23\n+   |\n+LL |     let x = foo!() as *const [u8];\n+   |             ------    ^^^^^^^^^^^ creating a `*const [u8]` requires both an address and a length\n+   |             |\n+   |             consider casting this expression to `*const ()`, then using `core::ptr::from_raw_parts`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0606`."}, {"sha": "692617eacfbf4751dbb3718206ff9a6be4f7479e", "filename": "src/test/ui/lint/unused/unused-attr-duplicate.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -13,9 +13,6 @@\n #![crate_name = \"unused_attr_duplicate\"]\n #![crate_name = \"unused_attr_duplicate2\"] //~ ERROR unused attribute\n //~^ WARN this was previously accepted\n-#![crate_type = \"bin\"]\n-#![crate_type = \"rlib\"] //~ ERROR unused attribute\n-//~^ WARN this was previously accepted\n #![recursion_limit = \"128\"]\n #![recursion_limit = \"256\"] //~ ERROR unused attribute\n //~^ WARN this was previously accepted"}, {"sha": "f592323b550bec1b54ae2cc3e51e662fdad0d241", "filename": "src/test/ui/lint/unused/unused-attr-duplicate.stderr", "status": "modified", "additions": 44, "deletions": 57, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Funused-attr-duplicate.stderr?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -1,5 +1,5 @@\n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:36:1\n+  --> $DIR/unused-attr-duplicate.rs:33:1\n    |\n LL | #[no_link]\n    | ^^^^^^^^^^ help: remove this attribute\n@@ -10,180 +10,180 @@ note: the lint level is defined here\n LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:35:1\n+  --> $DIR/unused-attr-duplicate.rs:32:1\n    |\n LL | #[no_link]\n    | ^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:40:1\n+  --> $DIR/unused-attr-duplicate.rs:37:1\n    |\n LL | #[macro_use]\n    | ^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:39:1\n+  --> $DIR/unused-attr-duplicate.rs:36:1\n    |\n LL | #[macro_use]\n    | ^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:50:1\n+  --> $DIR/unused-attr-duplicate.rs:47:1\n    |\n LL | #[path = \"bar.rs\"]\n    | ^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:49:1\n+  --> $DIR/unused-attr-duplicate.rs:46:1\n    |\n LL | #[path = \"auxiliary/lint_unused_extern_crate.rs\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:56:1\n+  --> $DIR/unused-attr-duplicate.rs:53:1\n    |\n LL | #[ignore = \"some text\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:55:1\n+  --> $DIR/unused-attr-duplicate.rs:52:1\n    |\n LL | #[ignore]\n    | ^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:58:1\n+  --> $DIR/unused-attr-duplicate.rs:55:1\n    |\n LL | #[should_panic(expected = \"values don't match\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:57:1\n+  --> $DIR/unused-attr-duplicate.rs:54:1\n    |\n LL | #[should_panic]\n    | ^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:63:1\n+  --> $DIR/unused-attr-duplicate.rs:60:1\n    |\n LL | #[must_use = \"some message\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:62:1\n+  --> $DIR/unused-attr-duplicate.rs:59:1\n    |\n LL | #[must_use]\n    | ^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:69:1\n+  --> $DIR/unused-attr-duplicate.rs:66:1\n    |\n LL | #[non_exhaustive]\n    | ^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:68:1\n+  --> $DIR/unused-attr-duplicate.rs:65:1\n    |\n LL | #[non_exhaustive]\n    | ^^^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:73:1\n+  --> $DIR/unused-attr-duplicate.rs:70:1\n    |\n LL | #[automatically_derived]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:72:1\n+  --> $DIR/unused-attr-duplicate.rs:69:1\n    |\n LL | #[automatically_derived]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:77:1\n+  --> $DIR/unused-attr-duplicate.rs:74:1\n    |\n LL | #[inline(never)]\n    | ^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:76:1\n+  --> $DIR/unused-attr-duplicate.rs:73:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:80:1\n+  --> $DIR/unused-attr-duplicate.rs:77:1\n    |\n LL | #[cold]\n    | ^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:79:1\n+  --> $DIR/unused-attr-duplicate.rs:76:1\n    |\n LL | #[cold]\n    | ^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:82:1\n+  --> $DIR/unused-attr-duplicate.rs:79:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:81:1\n+  --> $DIR/unused-attr-duplicate.rs:78:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:95:1\n+  --> $DIR/unused-attr-duplicate.rs:92:1\n    |\n LL | #[export_name = \"exported_symbol_name\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:97:1\n+  --> $DIR/unused-attr-duplicate.rs:94:1\n    |\n LL | #[export_name = \"exported_symbol_name2\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:101:1\n+  --> $DIR/unused-attr-duplicate.rs:98:1\n    |\n LL | #[no_mangle]\n    | ^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:100:1\n+  --> $DIR/unused-attr-duplicate.rs:97:1\n    |\n LL | #[no_mangle]\n    | ^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:105:1\n+  --> $DIR/unused-attr-duplicate.rs:102:1\n    |\n LL | #[used]\n    | ^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:104:1\n+  --> $DIR/unused-attr-duplicate.rs:101:1\n    |\n LL | #[used]\n    | ^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:89:5\n+  --> $DIR/unused-attr-duplicate.rs:86:5\n    |\n LL |     #[link_name = \"this_does_not_exist\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:91:5\n+  --> $DIR/unused-attr-duplicate.rs:88:5\n    |\n LL |     #[link_name = \"rust_dbg_extern_identity_u32\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -205,102 +205,89 @@ LL | #![crate_name = \"unused_attr_duplicate\"]\n error: unused attribute\n   --> $DIR/unused-attr-duplicate.rs:17:1\n    |\n-LL | #![crate_type = \"rlib\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n-   |\n-note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:16:1\n-   |\n-LL | #![crate_type = \"bin\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-\n-error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:20:1\n-   |\n LL | #![recursion_limit = \"256\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:19:1\n+  --> $DIR/unused-attr-duplicate.rs:16:1\n    |\n LL | #![recursion_limit = \"128\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:23:1\n+  --> $DIR/unused-attr-duplicate.rs:20:1\n    |\n LL | #![type_length_limit = \"1\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:22:1\n+  --> $DIR/unused-attr-duplicate.rs:19:1\n    |\n LL | #![type_length_limit = \"1048576\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:26:1\n+  --> $DIR/unused-attr-duplicate.rs:23:1\n    |\n LL | #![no_std]\n    | ^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:25:1\n+  --> $DIR/unused-attr-duplicate.rs:22:1\n    |\n LL | #![no_std]\n    | ^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:28:1\n+  --> $DIR/unused-attr-duplicate.rs:25:1\n    |\n LL | #![no_implicit_prelude]\n    | ^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:27:1\n+  --> $DIR/unused-attr-duplicate.rs:24:1\n    |\n LL | #![no_implicit_prelude]\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:30:1\n+  --> $DIR/unused-attr-duplicate.rs:27:1\n    |\n LL | #![windows_subsystem = \"windows\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:29:1\n+  --> $DIR/unused-attr-duplicate.rs:26:1\n    |\n LL | #![windows_subsystem = \"console\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:33:1\n+  --> $DIR/unused-attr-duplicate.rs:30:1\n    |\n LL | #![no_builtins]\n    | ^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:32:1\n+  --> $DIR/unused-attr-duplicate.rs:29:1\n    |\n LL | #![no_builtins]\n    | ^^^^^^^^^^^^^^^\n \n error: unused attribute\n-  --> $DIR/unused-attr-duplicate.rs:43:5\n+  --> $DIR/unused-attr-duplicate.rs:40:5\n    |\n LL |     #[macro_export]\n    |     ^^^^^^^^^^^^^^^ help: remove this attribute\n    |\n note: attribute also specified here\n-  --> $DIR/unused-attr-duplicate.rs:42:5\n+  --> $DIR/unused-attr-duplicate.rs:39:5\n    |\n LL |     #[macro_export]\n    |     ^^^^^^^^^^^^^^^\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 23 previous errors\n "}, {"sha": "954169a9ffb559d6d313616ca7ed164a8d392421", "filename": "src/test/ui/privacy/restricted/relative-2018.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -7,7 +7,7 @@ mod m {\n     pub(in ::core) struct S4;\n     //~^ ERROR visibilities can only be restricted to ancestor modules\n     pub(in a::b) struct S5;\n-    //~^ ERROR relative paths are not supported in visibilities on 2018 edition\n+    //~^ ERROR relative paths are not supported in visibilities in 2018 edition or later\n }\n \n fn main() {}"}, {"sha": "dec0d5157da4f581914bbdf3aff076372df79126", "filename": "src/test/ui/privacy/restricted/relative-2018.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr?ref=2a83fbc42a9bb6bfdb8d3fb4ecce83fb410d7642", "patch": "@@ -4,7 +4,7 @@ error[E0742]: visibilities can only be restricted to ancestor modules\n LL |     pub(in ::core) struct S4;\n    |            ^^^^^^\n \n-error: relative paths are not supported in visibilities on 2018 edition\n+error: relative paths are not supported in visibilities in 2018 edition or later\n   --> $DIR/relative-2018.rs:9:12\n    |\n LL |     pub(in a::b) struct S5;"}]}