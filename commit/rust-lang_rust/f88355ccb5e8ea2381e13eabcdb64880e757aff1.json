{"sha": "f88355ccb5e8ea2381e13eabcdb64880e757aff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ODM1NWNjYjVlOGVhMjM4MWUxM2VhYmNkYjY0ODgwZTc1N2FmZjE=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2019-01-20T21:13:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T08:46:27Z"}, "message": "refactor, put watcher with `io::Worker`\nuse `RootFilter` to filter recursive watches\nuntested", "tree": {"sha": "3eb37e82786ed739a69d3981129e12d884be1cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb37e82786ed739a69d3981129e12d884be1cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f88355ccb5e8ea2381e13eabcdb64880e757aff1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f88355ccb5e8ea2381e13eabcdb64880e757aff1", "html_url": "https://github.com/rust-lang/rust/commit/f88355ccb5e8ea2381e13eabcdb64880e757aff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f88355ccb5e8ea2381e13eabcdb64880e757aff1/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eacf7aeb42d7ba54c305664773e77eb592b51b99", "url": "https://api.github.com/repos/rust-lang/rust/commits/eacf7aeb42d7ba54c305664773e77eb592b51b99", "html_url": "https://github.com/rust-lang/rust/commit/eacf7aeb42d7ba54c305664773e77eb592b51b99"}], "stats": {"total": 358, "additions": 187, "deletions": 171}, "files": [{"sha": "41e84b7e94a2d251f8647eb3a1d183efa9980609", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f88355ccb5e8ea2381e13eabcdb64880e757aff1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f88355ccb5e8ea2381e13eabcdb64880e757aff1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f88355ccb5e8ea2381e13eabcdb64880e757aff1", "patch": "@@ -446,18 +446,6 @@ name = \"glob\"\n version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"globset\"\n-version = \"0.4.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"heck\"\n version = \"0.3.1\"\n@@ -481,23 +469,6 @@ dependencies = [\n  \"unicode-normalization 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"ignore\"\n-version = \"0.4.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 2.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"same-file 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"im\"\n version = \"12.3.0\"\n@@ -1039,7 +1010,6 @@ dependencies = [\n  \"crossbeam-channel 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flexi_logger 0.10.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"notify 4.0.6 (git+https://github.com/vemoo/notify/?branch=v4-legacy)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1899,11 +1869,9 @@ dependencies = [\n \"checksum futures 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49e7653e374fe0d0c12de4250f0bdb60680b8c80eed558c5c7538eec9c89e21b\"\n \"checksum generic-array 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n-\"checksum globset 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4743617a7464bbda3c8aec8558ff2f9429047e025771037df561d383337ff865\"\n \"checksum heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n \"checksum humansize 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b6cab2627acfc432780848602f3f558f7e9dd427352224b0d9324025796d2a5e\"\n \"checksum idna 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38f09e0f0b1fb55fdee1f17470ad800da77af5186a1a76c026b679358b7e844e\"\n-\"checksum ignore 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad03ca67dc12474ecd91fdb94d758cbd20cb4e7a78ebe831df26a9b7511e1162\"\n \"checksum im 12.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0627d417829c1d763d602687634869f254fc79f7e22dea6c824dab993db857e4\"\n \"checksum indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n \"checksum inotify 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40b54539f3910d6f84fbf9a643efd6e3aa6e4f001426c0329576128255994718\""}, {"sha": "c7c4769b3dea8b7b02e22c1dbce07b94f693122f", "filename": "crates/ra_vfs/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2FCargo.toml?ref=f88355ccb5e8ea2381e13eabcdb64880e757aff1", "patch": "@@ -12,7 +12,6 @@ crossbeam-channel = \"0.3.5\"\n log = \"0.4.6\"\n # until https://github.com/passcod/notify/issues/169 is fixed\n notify = { git = \"https://github.com/vemoo/notify/\", branch = \"v4-legacy\" }\n-ignore = \"0.4\"\n drop_bomb = \"0.1.0\"\n parking_lot = \"0.7.0\"\n "}, {"sha": "25acec9b1da4bf897256447b2995f233e929ab18", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 88, "deletions": 17, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=f88355ccb5e8ea2381e13eabcdb64880e757aff1", "patch": "@@ -1,13 +1,20 @@\n use std::{\n     fmt, fs,\n     path::{Path, PathBuf},\n+    sync::Arc,\n+    thread,\n };\n \n+use crossbeam_channel::{Receiver, Sender};\n+use parking_lot::Mutex;\n use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::{DirEntry, WalkDir};\n \n-use crate::{has_rs_extension, watcher::WatcherChange, VfsRoot};\n+use crate::{\n+    watcher::{Watcher, WatcherChange},\n+    VfsRoot,\n+};\n \n pub(crate) enum Task {\n     AddRoot {\n@@ -17,6 +24,10 @@ pub(crate) enum Task {\n     },\n     HandleChange(WatcherChange),\n     LoadChange(WatcherChange),\n+    Watch {\n+        dir: PathBuf,\n+        filter: Box<Fn(&DirEntry) -> bool + Send>,\n+    },\n }\n \n #[derive(Debug)]\n@@ -35,7 +46,8 @@ pub enum WatcherChangeData {\n pub enum TaskResult {\n     AddRoot(AddRootResult),\n     HandleChange(WatcherChange),\n-    LoadChange(Option<WatcherChangeData>),\n+    LoadChange(WatcherChangeData),\n+    NoOp,\n }\n \n impl fmt::Debug for TaskResult {\n@@ -44,21 +56,74 @@ impl fmt::Debug for TaskResult {\n     }\n }\n \n-pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+pub(crate) struct Worker {\n+    worker: thread_worker::Worker<Task, TaskResult>,\n+    worker_handle: WorkerHandle,\n+    watcher: Arc<Mutex<Option<Watcher>>>,\n+}\n+\n+impl Worker {\n+    pub(crate) fn start() -> Worker {\n+        let watcher = Arc::new(Mutex::new(None));\n+        let watcher_clone = watcher.clone();\n+        let (worker, worker_handle) =\n+            thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n+                let res = input_receiver\n+                    .into_iter()\n+                    .map(|t| handle_task(t, &watcher_clone))\n+                    .try_for_each(|it| output_sender.send(it));\n+                res.unwrap()\n+            });\n+        match Watcher::start(worker.inp.clone()) {\n+            Ok(w) => {\n+                watcher.lock().replace(w);\n+            }\n+            Err(e) => log::error!(\"could not start watcher: {}\", e),\n+        };\n+        Worker {\n+            worker,\n+            worker_handle,\n+            watcher,\n+        }\n+    }\n+\n+    pub(crate) fn sender(&self) -> &Sender<Task> {\n+        &self.worker.inp\n+    }\n+\n+    pub(crate) fn receiver(&self) -> &Receiver<TaskResult> {\n+        &self.worker.out\n+    }\n+\n+    pub(crate) fn shutdown(self) -> thread::Result<()> {\n+        if let Some(watcher) = self.watcher.lock().take() {\n+            let _ = watcher.shutdown();\n+        }\n+        self.worker_handle.shutdown()\n+    }\n+}\n \n-pub(crate) fn start() -> (Worker, WorkerHandle) {\n-    thread_worker::spawn(\"vfs\", 128, |input_receiver, output_sender| {\n-        input_receiver\n-            .into_iter()\n-            .map(handle_task)\n-            .try_for_each(|it| output_sender.send(it))\n-            .unwrap()\n-    })\n+fn watch(\n+    watcher: &Arc<Mutex<Option<Watcher>>>,\n+    dir: &Path,\n+    filter_entry: impl Fn(&DirEntry) -> bool,\n+    emit_for_existing: bool,\n+) {\n+    let mut watcher = watcher.lock();\n+    let watcher = match *watcher {\n+        Some(ref mut w) => w,\n+        None => {\n+            // watcher dropped or couldn't start\n+            return;\n+        }\n+    };\n+    watcher.watch_recursive(dir, filter_entry, emit_for_existing)\n }\n \n-fn handle_task(task: Task) -> TaskResult {\n+fn handle_task(task: Task, watcher: &Arc<Mutex<Option<Watcher>>>) -> TaskResult {\n     match task {\n         Task::AddRoot { root, path, filter } => {\n+            watch(watcher, &path, &*filter, false);\n             log::debug!(\"loading {} ...\", path.as_path().display());\n             let files = load_root(path.as_path(), &*filter);\n             log::debug!(\"... loaded {}\", path.as_path().display());\n@@ -70,8 +135,14 @@ fn handle_task(task: Task) -> TaskResult {\n         }\n         Task::LoadChange(change) => {\n             log::debug!(\"loading {:?} ...\", change);\n-            let data = load_change(change);\n-            TaskResult::LoadChange(data)\n+            match load_change(change) {\n+                Some(data) => TaskResult::LoadChange(data),\n+                None => TaskResult::NoOp,\n+            }\n+        }\n+        Task::Watch { dir, filter } => {\n+            watch(watcher, &dir, &*filter, true);\n+            TaskResult::NoOp\n         }\n     }\n }\n@@ -90,9 +161,6 @@ fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePa\n             continue;\n         }\n         let path = entry.path();\n-        if !has_rs_extension(path) {\n-            continue;\n-        }\n         let text = match fs::read_to_string(path) {\n             Ok(text) => text,\n             Err(e) => {\n@@ -109,6 +177,9 @@ fn load_root(root: &Path, filter: &dyn Fn(&DirEntry) -> bool) -> Vec<(RelativePa\n fn load_change(change: WatcherChange) -> Option<WatcherChangeData> {\n     let data = match change {\n         WatcherChange::Create(path) => {\n+            if path.is_dir() {\n+                return None;\n+            }\n             let text = match fs::read_to_string(&path) {\n                 Ok(text) => text,\n                 Err(e) => {"}, {"sha": "1961808904e7c90acde7ee8a078c50da2e74e43b", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=f88355ccb5e8ea2381e13eabcdb64880e757aff1", "patch": "@@ -20,7 +20,7 @@ use std::{\n     cmp::Reverse,\n     ffi::OsStr,\n     fmt, fs, mem,\n-    path::{Path, PathBuf},\n+    path::{Component, Path, PathBuf},\n     sync::Arc,\n     thread,\n };\n@@ -29,39 +29,55 @@ use crossbeam_channel::Receiver;\n use ra_arena::{impl_arena_id, Arena, RawId};\n use relative_path::RelativePathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use thread_worker::WorkerHandle;\n use walkdir::DirEntry;\n \n pub use crate::io::TaskResult as VfsTask;\n-pub use crate::watcher::{Watcher, WatcherChange};\n+pub use crate::watcher::WatcherChange;\n \n /// `RootFilter` is a predicate that checks if a file can belong to a root. If\n /// several filters match a file (nested dirs), the most nested one wins.\n-struct RootFilter {\n+pub(crate) struct RootFilter {\n     root: PathBuf,\n-    file_filter: fn(&Path) -> bool,\n+    filter: fn(RootEntry) -> bool,\n+}\n+\n+pub(crate) struct RootEntry<'a, 'b> {\n+    root: &'a Path,\n+    path: &'b Path,\n }\n \n impl RootFilter {\n     fn new(root: PathBuf) -> RootFilter {\n         RootFilter {\n             root,\n-            file_filter: has_rs_extension,\n+            filter: default_filter,\n         }\n     }\n     /// Check if this root can contain `path`. NB: even if this returns\n     /// true, the `path` might actually be conained in some nested root.\n-    fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n-        if !(self.file_filter)(path) {\n+    pub(crate) fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n+        if !(self.filter)(RootEntry {\n+            root: &self.root,\n+            path,\n+        }) {\n             return None;\n         }\n         let path = path.strip_prefix(&self.root).ok()?;\n         RelativePathBuf::from_path(path).ok()\n     }\n }\n \n-pub(crate) fn has_rs_extension(p: &Path) -> bool {\n-    p.extension() == Some(OsStr::new(\"rs\"))\n+pub(crate) fn default_filter(entry: RootEntry) -> bool {\n+    if entry.path.is_dir() {\n+        // first component relative to root is \"target\"\n+        entry\n+            .path\n+            .strip_prefix(entry.root)\n+            .map(|p| p.components().next() != Some(Component::Normal(OsStr::new(\"target\"))))\n+            .unwrap_or(false)\n+    } else {\n+        entry.path.extension() == Some(OsStr::new(\"rs\"))\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -80,13 +96,11 @@ struct VfsFileData {\n }\n \n pub struct Vfs {\n-    roots: Arena<VfsRoot, RootFilter>,\n+    roots: Arena<VfsRoot, Arc<RootFilter>>,\n     files: Arena<VfsFile, VfsFileData>,\n     root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n     worker: io::Worker,\n-    worker_handle: WorkerHandle,\n-    watcher: Option<Watcher>,\n }\n \n impl fmt::Debug for Vfs {\n@@ -97,52 +111,43 @@ impl fmt::Debug for Vfs {\n \n impl Vfs {\n     pub fn new(mut roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n-        let (worker, worker_handle) = io::start();\n-\n-        let watcher = match Watcher::start(worker.inp.clone()) {\n-            Ok(watcher) => Some(watcher),\n-            Err(e) => {\n-                log::error!(\"could not start watcher: {}\", e);\n-                None\n-            }\n-        };\n+        let worker = io::Worker::start();\n \n         let mut res = Vfs {\n             roots: Arena::default(),\n             files: Arena::default(),\n             root2files: FxHashMap::default(),\n             worker,\n-            worker_handle,\n-            watcher,\n             pending_changes: Vec::new(),\n         };\n \n         // A hack to make nesting work.\n         roots.sort_by_key(|it| Reverse(it.as_os_str().len()));\n         for (i, path) in roots.iter().enumerate() {\n-            let root = res.roots.alloc(RootFilter::new(path.clone()));\n+            let root_filter = Arc::new(RootFilter::new(path.clone()));\n+\n+            let root = res.roots.alloc(root_filter.clone());\n             res.root2files.insert(root, Default::default());\n+\n             let nested = roots[..i]\n                 .iter()\n                 .filter(|it| it.starts_with(path))\n                 .map(|it| it.clone())\n                 .collect::<Vec<_>>();\n+\n             let filter = move |entry: &DirEntry| {\n-                if entry.file_type().is_file() {\n-                    has_rs_extension(entry.path())\n+                if entry.file_type().is_dir() && nested.iter().any(|it| it == entry.path()) {\n+                    false\n                 } else {\n-                    nested.iter().all(|it| it != entry.path())\n+                    root_filter.can_contain(entry.path()).is_some()\n                 }\n             };\n             let task = io::Task::AddRoot {\n                 root,\n                 path: path.clone(),\n                 filter: Box::new(filter),\n             };\n-            res.worker.inp.send(task).unwrap();\n-            if let Some(ref mut watcher) = res.watcher {\n-                watcher.watch(path);\n-            }\n+            res.worker.sender().send(task).unwrap();\n         }\n         let roots = res.roots.iter().map(|(id, _)| id).collect();\n         (res, roots)\n@@ -194,7 +199,7 @@ impl Vfs {\n     }\n \n     pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n-        &self.worker.out\n+        self.worker.receiver()\n     }\n \n     pub fn handle_task(&mut self, task: io::TaskResult) {\n@@ -225,19 +230,35 @@ impl Vfs {\n                 self.pending_changes.push(change);\n             }\n             io::TaskResult::HandleChange(change) => match &change {\n+                watcher::WatcherChange::Create(path) if path.is_dir() => {\n+                    if let Some((root, _path, _file)) = self.find_root(&path) {\n+                        let root_filter = self.roots[root].clone();\n+                        let filter =\n+                            move |entry: &DirEntry| root_filter.can_contain(entry.path()).is_some();\n+                        self.worker\n+                            .sender()\n+                            .send(io::Task::Watch {\n+                                dir: path.to_path_buf(),\n+                                filter: Box::new(filter),\n+                            })\n+                            .unwrap()\n+                    }\n+                }\n                 watcher::WatcherChange::Create(path)\n                 | watcher::WatcherChange::Remove(path)\n                 | watcher::WatcherChange::Write(path) => {\n                     if self.should_handle_change(&path) {\n-                        self.worker.inp.send(io::Task::LoadChange(change)).unwrap()\n+                        self.worker\n+                            .sender()\n+                            .send(io::Task::LoadChange(change))\n+                            .unwrap()\n                     }\n                 }\n                 watcher::WatcherChange::Rescan => {\n                     // TODO we should reload all files\n                 }\n             },\n-            io::TaskResult::LoadChange(None) => {}\n-            io::TaskResult::LoadChange(Some(change)) => match change {\n+            io::TaskResult::LoadChange(change) => match change {\n                 io::WatcherChangeData::Create { path, text }\n                 | io::WatcherChangeData::Write { path, text } => {\n                     if let Some((root, path, file)) = self.find_root(&path) {\n@@ -256,6 +277,7 @@ impl Vfs {\n                     }\n                 }\n             },\n+            io::TaskResult::NoOp => {}\n         }\n     }\n \n@@ -359,11 +381,7 @@ impl Vfs {\n \n     /// Sutdown the VFS and terminate the background watching thread.\n     pub fn shutdown(self) -> thread::Result<()> {\n-        if let Some(watcher) = self.watcher {\n-            let _ = watcher.shutdown();\n-        }\n-        let _ = self.worker.shutdown();\n-        self.worker_handle.shutdown()\n+        self.worker.shutdown()\n     }\n \n     fn add_file("}, {"sha": "d8c35f2a307f57206fe62207559111da4759f3a8", "filename": "crates/ra_vfs/src/watcher.rs", "status": "modified", "additions": 40, "deletions": 80, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f88355ccb5e8ea2381e13eabcdb64880e757aff1/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fwatcher.rs?ref=f88355ccb5e8ea2381e13eabcdb64880e757aff1", "patch": "@@ -1,20 +1,20 @@\n use crate::io;\n use crossbeam_channel::Sender;\n use drop_bomb::DropBomb;\n-use ignore::{gitignore::Gitignore, Walk};\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n-use parking_lot::Mutex;\n use std::{\n     path::{Path, PathBuf},\n-    sync::{mpsc, Arc},\n+    sync::mpsc,\n     thread,\n     time::Duration,\n };\n+use walkdir::{DirEntry, WalkDir};\n \n-pub struct Watcher {\n-    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n+pub(crate) struct Watcher {\n+    watcher: RecommendedWatcher,\n     thread: thread::JoinHandle<()>,\n     bomb: DropBomb,\n+    sender: Sender<io::Task>,\n }\n \n #[derive(Debug)]\n@@ -28,7 +28,6 @@ pub enum WatcherChange {\n fn handle_change_event(\n     ev: DebouncedEvent,\n     sender: &Sender<io::Task>,\n-    watcher: &Arc<Mutex<Option<RecommendedWatcher>>>,\n ) -> Result<(), Box<std::error::Error>> {\n     match ev {\n         DebouncedEvent::NoticeWrite(_)\n@@ -40,12 +39,6 @@ fn handle_change_event(\n             sender.send(io::Task::HandleChange(WatcherChange::Rescan))?;\n         }\n         DebouncedEvent::Create(path) => {\n-            // we have to check if `path` is ignored because Walk iterator doesn't check it\n-            // also childs are only ignored if they match a pattern\n-            // (see `matched` vs `matched_path_or_any_parents` in `Gitignore`)\n-            if path.is_dir() && !should_ignore_dir(&path) {\n-                watch_recursive(watcher, &path, Some(sender));\n-            }\n             sender.send(io::Task::HandleChange(WatcherChange::Create(path)))?;\n         }\n         DebouncedEvent::Write(path) => {\n@@ -66,98 +59,65 @@ fn handle_change_event(\n     Ok(())\n }\n \n-fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n-    match watcher.watch(dir, RecursiveMode::NonRecursive) {\n-        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n-        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n-    }\n-}\n-\n-fn watch_recursive(\n-    watcher: &Arc<Mutex<Option<RecommendedWatcher>>>,\n-    dir: &Path,\n-    sender: Option<&Sender<io::Task>>,\n-) {\n-    let mut watcher = watcher.lock();\n-    let mut watcher = match *watcher {\n-        Some(ref mut watcher) => watcher,\n-        None => {\n-            // watcher has been dropped\n-            return;\n-        }\n-    };\n-    for res in Walk::new(dir) {\n-        match res {\n-            Ok(entry) => {\n-                if entry.path().is_dir() {\n-                    watch_one(&mut watcher, entry.path());\n-                }\n-                if let Some(sender) = sender {\n-                    // emit as create because we haven't seen it yet\n-                    if let Err(e) = sender.send(io::Task::HandleChange(WatcherChange::Create(\n-                        entry.path().to_path_buf(),\n-                    ))) {\n-                        log::warn!(\"watcher error: {}\", e)\n-                    }\n-                }\n-            }\n-            Err(e) => log::warn!(\"watcher error: {}\", e),\n-        }\n-    }\n-}\n-\n-fn should_ignore_dir(dir: &Path) -> bool {\n-    let mut parent = dir;\n-    loop {\n-        parent = match parent.parent() {\n-            Some(p) => p,\n-            None => break,\n-        };\n-        let gitignore = parent.join(\".gitignore\");\n-        if gitignore.exists() {\n-            let gitignore = Gitignore::new(gitignore).0;\n-            if gitignore.matched_path_or_any_parents(dir, true).is_ignore() {\n-                log::debug!(\"ignored {}\", dir.display());\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n impl Watcher {\n     pub(crate) fn start(\n         output_sender: Sender<io::Task>,\n     ) -> Result<Watcher, Box<std::error::Error>> {\n         let (input_sender, input_receiver) = mpsc::channel();\n-        let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n-            input_sender,\n-            WATCHER_DELAY,\n-        )?)));\n-        let w = watcher.clone();\n+        let watcher = notify::watcher(input_sender, WATCHER_DELAY)?;\n+        let sender = output_sender.clone();\n         let thread = thread::spawn(move || {\n             input_receiver\n                 .into_iter()\n                 // forward relevant events only\n-                .try_for_each(|change| handle_change_event(change, &output_sender, &w))\n+                .try_for_each(|change| handle_change_event(change, &output_sender))\n                 .unwrap()\n         });\n         Ok(Watcher {\n             watcher,\n             thread,\n+            sender,\n             bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n         })\n     }\n \n-    pub fn watch(&mut self, root: impl AsRef<Path>) {\n-        watch_recursive(&self.watcher, root.as_ref(), None);\n+    pub fn watch_recursive(\n+        &mut self,\n+        dir: &Path,\n+        filter_entry: impl Fn(&DirEntry) -> bool,\n+        emit_for_existing: bool,\n+    ) {\n+        for res in WalkDir::new(dir).into_iter().filter_entry(filter_entry) {\n+            match res {\n+                Ok(entry) => {\n+                    if entry.path().is_dir() {\n+                        match self.watcher.watch(dir, RecursiveMode::NonRecursive) {\n+                            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+                            Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n+                        }\n+                    }\n+                    if emit_for_existing {\n+                        // emit as create because we haven't seen it yet\n+                        if let Err(e) =\n+                            self.sender\n+                                .send(io::Task::HandleChange(WatcherChange::Create(\n+                                    entry.path().to_path_buf(),\n+                                )))\n+                        {\n+                            log::warn!(\"watcher error: {}\", e)\n+                        }\n+                    }\n+                }\n+                Err(e) => log::warn!(\"watcher error: {}\", e),\n+            }\n+        }\n     }\n \n     pub fn shutdown(mut self) -> thread::Result<()> {\n         self.bomb.defuse();\n-        drop(self.watcher.lock().take());\n+        drop(self.watcher);\n         let res = self.thread.join();\n         match &res {\n             Ok(()) => log::info!(\"... Watcher terminated with ok\"),"}]}