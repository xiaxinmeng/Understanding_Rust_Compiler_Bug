{"sha": "cc60f3f472afbf038b9f68895c83f0bb7821e2b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNjBmM2Y0NzJhZmJmMDM4YjlmNjg4OTVjODNmMGJiNzgyMWUyYjg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-22T16:56:50Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-22T16:56:50Z"}, "message": "Rollup merge of #27163 - steveklabnik:doc_std_io_cursor, r=alexcrichton\n\nBeef up the docs on the type, as well as adding examples for all\r\nmethods.\r\n\r\nr? @alexcrichton", "tree": {"sha": "5f6c089d2c804c45dead69ea3a947d9afbfd4386", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f6c089d2c804c45dead69ea3a947d9afbfd4386"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc60f3f472afbf038b9f68895c83f0bb7821e2b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc60f3f472afbf038b9f68895c83f0bb7821e2b8", "html_url": "https://github.com/rust-lang/rust/commit/cc60f3f472afbf038b9f68895c83f0bb7821e2b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc60f3f472afbf038b9f68895c83f0bb7821e2b8/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f0c9983f6e10342b9b619348130ef232975531a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0c9983f6e10342b9b619348130ef232975531a", "html_url": "https://github.com/rust-lang/rust/commit/5f0c9983f6e10342b9b619348130ef232975531a"}, {"sha": "103749d9330e6d6ec048118489925a50db2ab93f", "url": "https://api.github.com/repos/rust-lang/rust/commits/103749d9330e6d6ec048118489925a50db2ab93f", "html_url": "https://github.com/rust-lang/rust/commit/103749d9330e6d6ec048118489925a50db2ab93f"}], "stats": {"total": 149, "additions": 140, "deletions": 9}, "files": [{"sha": "4bb7d2ebd1963ef7fe1dad775895d3c9523c4a1b", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 140, "deletions": 9, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/cc60f3f472afbf038b9f68895c83f0bb7821e2b8/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60f3f472afbf038b9f68895c83f0bb7821e2b8/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=cc60f3f472afbf038b9f68895c83f0bb7821e2b8", "patch": "@@ -15,16 +15,67 @@ use cmp;\n use io::{self, SeekFrom, Error, ErrorKind};\n use slice;\n \n-/// A `Cursor` is a type which wraps a non-I/O object to provide a `Seek`\n+/// A `Cursor` wraps another type and provides it with a [`Seek`][seek]\n /// implementation.\n ///\n-/// Cursors are typically used with memory buffer objects in order to allow\n-/// `Seek`, `Read`, and `Write` implementations. For example, common cursor types\n-/// include `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n+/// [seek]: trait.Seek.html\n ///\n-/// Implementations of the I/O traits for `Cursor<T>` are currently not generic\n-/// over `T` itself. Instead, specific implementations are provided for various\n-/// in-memory buffer types like `Vec<u8>` and `&[u8]`.\n+/// Cursors are typically used with in-memory buffers to allow them to\n+/// implement `Read` and/or `Write`, allowing these buffers to be used\n+/// anywhere you might use a reader or writer that does actual I/O.\n+///\n+/// The standard library implements some I/O traits on various types which\n+/// are commonly used as a buffer, like `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n+///\n+/// # Examples\n+///\n+/// We may want to write bytes to a [`File`][file] in our production\n+/// code, but use an in-memory buffer in our tests. We can do this with\n+/// `Cursor`:\n+///\n+/// [file]: ../fs/struct.File.html\n+///\n+/// ```no_run\n+/// use std::io::prelude::*;\n+/// use std::io::{self, SeekFrom};\n+/// use std::fs::File;\n+///\n+/// // a library function we've written\n+/// fn write_ten_bytes_at_end<W: Write + Seek>(writer: &mut W) -> io::Result<()> {\n+///     try!(writer.seek(SeekFrom::End(-10)));\n+///\n+///     for i in 0..10 {\n+///         try!(writer.write(&[i]));\n+///     }\n+///\n+///     // all went well\n+///     Ok(())\n+/// }\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// // Here's some code that uses this library function.\n+/// //\n+/// // We might want to use a BufReader here for efficiency, but let's\n+/// // keep this example focused.\n+/// let mut file = try!(File::create(\"foo.txt\"));\n+///\n+/// try!(write_ten_bytes_at_end(&mut file));\n+/// # Ok(())\n+/// # }\n+///\n+/// // now let's write a test\n+/// #[test]\n+/// fn test_writes_bytes() {\n+///     // setting up a real File is much more slow than an in-memory buffer,\n+///     // let's use a cursor instead\n+///     use std::io::Cursor;\n+///     let mut buff = Cursor::new(vec![0; 15]);\n+///\n+///     write_ten_bytes(&mut buff).unwrap();\n+///\n+///     assert_eq!(&buff.get_ref()[5..15], &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone, Debug)]\n pub struct Cursor<T> {\n@@ -34,31 +85,111 @@ pub struct Cursor<T> {\n \n impl<T> Cursor<T> {\n     /// Creates a new cursor wrapping the provided underlying I/O object.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: T) -> Cursor<T> {\n         Cursor { pos: 0, inner: inner }\n     }\n \n     /// Consumes this cursor, returning the underlying value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let vec = buff.into_inner();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T { self.inner }\n \n     /// Gets a reference to the underlying value in this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let reference = buff.get_ref();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &T { &self.inner }\n \n     /// Gets a mutable reference to the underlying value in this cursor.\n     ///\n     /// Care should be taken to avoid modifying the internal I/O state of the\n     /// underlying value as it may corrupt this cursor's position.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(Vec::new());\n+    /// # fn force_inference(_: &Cursor<Vec<u8>>) {}\n+    /// # force_inference(&buff);\n+    ///\n+    /// let reference = buff.get_mut();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.inner }\n \n-    /// Returns the current value of this cursor\n+    /// Returns the current position of this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    /// use std::io::prelude::*;\n+    /// use std::io::SeekFrom;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.position(), 0);\n+    ///\n+    /// buff.seek(SeekFrom::Current(2)).unwrap();\n+    /// assert_eq!(buff.position(), 2);\n+    ///\n+    /// buff.seek(SeekFrom::Current(-1)).unwrap();\n+    /// assert_eq!(buff.position(), 1);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn position(&self) -> u64 { self.pos }\n \n-    /// Sets the value of this cursor\n+    /// Sets the position of this cursor.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.position(), 0);\n+    ///\n+    /// buff.set_position(2);\n+    /// assert_eq!(buff.position(), 2);\n+    ///\n+    /// buff.set_position(4);\n+    /// assert_eq!(buff.position(), 4);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_position(&mut self, pos: u64) { self.pos = pos; }\n }"}]}