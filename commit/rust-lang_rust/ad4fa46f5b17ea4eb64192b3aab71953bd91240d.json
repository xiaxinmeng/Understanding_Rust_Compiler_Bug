{"sha": "ad4fa46f5b17ea4eb64192b3aab71953bd91240d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNGZhNDZmNWIxN2VhNGViNjQxOTJiM2FhYjcxOTUzYmQ5MTI0MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-27T08:01:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-27T08:01:14Z"}, "message": "auto merge of #16001 : Gankro/rust/rawstrings-proof, r=pnkfelix\n\nStumbled across this and thought it would be cool to prove. I've never used Ogden's Lemma before, but I'm pretty sure I used it right. The pumping lemma definitely doesn't seem sufficient for the job. In particular, when using the pumping lemma, you can always just pump one of the quotes, and it's fine. Ogden's Lemma lets you effectively force the pumper to use certain characters in the string.\r\n\r\n@cmr", "tree": {"sha": "62013cec6207b4fdafb6f56673a19d8e3eb8b503", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62013cec6207b4fdafb6f56673a19d8e3eb8b503"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad4fa46f5b17ea4eb64192b3aab71953bd91240d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad4fa46f5b17ea4eb64192b3aab71953bd91240d", "html_url": "https://github.com/rust-lang/rust/commit/ad4fa46f5b17ea4eb64192b3aab71953bd91240d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad4fa46f5b17ea4eb64192b3aab71953bd91240d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d114ddac030d6ed63b3076ccc0e7db081c0a9409", "url": "https://api.github.com/repos/rust-lang/rust/commits/d114ddac030d6ed63b3076ccc0e7db081c0a9409", "html_url": "https://github.com/rust-lang/rust/commit/d114ddac030d6ed63b3076ccc0e7db081c0a9409"}, {"sha": "6444b5e82bd06dd1fb907221d6c91464276532c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6444b5e82bd06dd1fb907221d6c91464276532c5", "html_url": "https://github.com/rust-lang/rust/commit/6444b5e82bd06dd1fb907221d6c91464276532c5"}], "stats": {"total": 47, "additions": 41, "deletions": 6}, "files": [{"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ad4fa46f5b17ea4eb64192b3aab71953bd91240d/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad4fa46f5b17ea4eb64192b3aab71953bd91240d/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=ad4fa46f5b17ea4eb64192b3aab71953bd91240d", "patch": "@@ -1,7 +1,11 @@\n Rust's lexical grammar is not context-free. Raw string literals are the source\n of the problem. Informally, a raw string literal is an `r`, followed by `N`\n hashes (where N can be zero), a quote, any characters, then a quote followed\n-by `N` hashes. This grammar describes this as best possible:\n+by `N` hashes. Critically, once inside the first pair of quotes,\n+another quote cannot be followed by `N` consecutive hashes. e.g.\n+`r###\"\"###\"###` is invalid.\n+\n+This grammar describes this as best possible:\n \n     R -> 'r' S\n     S -> '\"' B '\"'\n@@ -22,8 +26,39 @@ accepted as one by the above grammar, using the derivation:\n (Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n string.) The difficulty arises from the fact that it is fundamentally\n context-sensitive. In particular, the context needed is the number of hashes.\n-I know of no way to resolve this, but also have not come up with a proof that\n-it is not context sensitive. Such a proof would probably use the pumping lemma\n-for context-free languages, but I (cmr) could not come up with a proof after\n-spending a few hours on it, and decided my time best spent elsewhere. Pull\n-request welcome!\n+\n+To prove that Rust's string literals are not context-free, we will use\n+the fact that context-free languages are closed under intersection with\n+regular languages, and the\n+[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n+\n+Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n+context-free, then their intersection with `R`, `R'`, should also be context-free.\n+Therefore, to prove that raw string literals are not context-free,\n+it is sufficient to prove that `R'` is not context-free.\n+\n+The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n+\n+Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n+the pumping lemma applies. Consider the following string `s` in `R'`:\n+\n+`r#^p\"\"#^{p-1}\"#^p`\n+\n+e.g. for `p = 2`: `s = r##\"\"#\"##`\n+\n+Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n+`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n+\n+Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n+in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n+Consequently, of the three sequences of hashes, `v` and `x` combined\n+can only pump two of them.\n+If we ever choose the central sequence of hashes, then one of the outer sequences\n+will not grow when we pump, leading to an imbalance between the outer sequences.\n+Therefore, we must pump both outer sequences of hashes. However,\n+there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n+be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n+context-free.\n+\n+Since `R'` is not context-free, it follows that the Rust's raw string literals\n+must not be context-free."}]}