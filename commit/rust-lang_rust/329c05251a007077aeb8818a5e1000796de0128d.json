{"sha": "329c05251a007077aeb8818a5e1000796de0128d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOWMwNTI1MWEwMDcwNzdhZWI4ODE4YTVlMTAwMDc5NmRlMDEyOGQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-11T23:29:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T10:42:45Z"}, "message": "resolve: Visit all scopes to collect suggestion candidates for unresolved macros", "tree": {"sha": "29f3f63573d909033696513a15fdf0aacd382270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29f3f63573d909033696513a15fdf0aacd382270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329c05251a007077aeb8818a5e1000796de0128d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329c05251a007077aeb8818a5e1000796de0128d", "html_url": "https://github.com/rust-lang/rust/commit/329c05251a007077aeb8818a5e1000796de0128d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329c05251a007077aeb8818a5e1000796de0128d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79f0d88de860bed2747811cffba177504d3ead8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/79f0d88de860bed2747811cffba177504d3ead8e", "html_url": "https://github.com/rust-lang/rust/commit/79f0d88de860bed2747811cffba177504d3ead8e"}], "stats": {"total": 402, "additions": 258, "deletions": 144}, "files": [{"sha": "db568dbf9fb942b5cbba827e2dfeb05dd139e445", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -398,4 +398,12 @@ impl<Id> Res<Id> {\n             Res::Err => Res::Err,\n         }\n     }\n+\n+    pub fn macro_kind(self) -> Option<MacroKind> {\n+        match self {\n+            Res::Def(DefKind::Macro(kind), _) => Some(kind),\n+            Res::NonMacroAttr(..) => Some(MacroKind::Attr),\n+            _ => None,\n+        }\n+    }\n }"}, {"sha": "00499409743bef9966755e22b2183fcb272e787a", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 222, "deletions": 108, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, DefKind, CtorKind};\n+use rustc::hir::def::{self, DefKind, CtorKind, NonMacroAttrKind};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::PrimTy;\n@@ -11,14 +11,15 @@ use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n use syntax::ext::base::MacroKind;\n+use syntax::feature_gate::BUILTIN_ATTRIBUTES;\n use syntax::symbol::{Symbol, kw};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{BytePos, Span};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{is_self_type, is_self_value, path_names_to_string};\n-use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n-use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Segment};\n+use crate::{is_self_type, is_self_value, path_names_to_string, KNOWN_TOOLS};\n+use crate::{CrateLint, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n \n@@ -42,12 +43,44 @@ struct TypoSuggestion {\n     article: &'static str,\n }\n \n+impl TypoSuggestion {\n+    fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+        TypoSuggestion { candidate, kind: res.descr(), article: res.article() }\n+    }\n+}\n+\n /// A free importable items suggested in case of resolution failure.\n crate struct ImportSuggestion {\n     did: Option<DefId>,\n     pub path: Path,\n }\n \n+fn add_typo_suggestion(\n+    err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n+) -> bool {\n+    if let Some(suggestion) = suggestion {\n+        let msg = format!(\"{} {} with a similar name exists\", suggestion.article, suggestion.kind);\n+        err.span_suggestion(\n+            span, &msg, suggestion.candidate.to_string(), Applicability::MaybeIncorrect\n+        );\n+        return true;\n+    }\n+    false\n+}\n+\n+fn add_module_candidates(\n+    module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n+) {\n+    for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n+        if let Some(binding) = resolution.borrow().binding {\n+            let res = binding.res();\n+            if filter_fn(res) {\n+                names.push(TypoSuggestion::from_res(ident.name, res));\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n@@ -234,24 +267,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let mut levenshtein_worked = false;\n-\n         // Try Levenshtein algorithm.\n-        let suggestion = self.lookup_typo_candidate(path, ns, is_expected, span);\n-        if let Some(suggestion) = suggestion {\n-            let msg = format!(\n-                \"{} {} with a similar name exists\",\n-                suggestion.article, suggestion.kind\n-            );\n-            err.span_suggestion(\n-                ident_span,\n-                &msg,\n-                suggestion.candidate.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-\n-            levenshtein_worked = true;\n-        }\n+        let levenshtein_worked = add_typo_suggestion(\n+            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n+        );\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n@@ -538,30 +557,169 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn lookup_typo_candidate<FilterFn>(\n+    /// Lookup typo candidate in scope for a macro or import.\n+    fn early_lookup_typo_candidate(\n         &mut self,\n-        path: &[Segment],\n-        ns: Namespace,\n-        filter_fn: FilterFn,\n-        span: Span,\n-    ) -> Option<TypoSuggestion>\n-    where\n-        FilterFn: Fn(Res) -> bool,\n-    {\n-        let add_module_candidates = |module: Module<'_>, names: &mut Vec<TypoSuggestion>| {\n-            for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n-                if let Some(binding) = resolution.borrow().binding {\n-                    if filter_fn(binding.res()) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: binding.res().article(),\n-                            kind: binding.res().descr(),\n-                        });\n+        scope_set: ScopeSet,\n+        parent_scope: &ParentScope<'a>,\n+        orig_ident: Ident,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) -> Option<TypoSuggestion> {\n+        let ident = orig_ident.modern();\n+        let rust_2015 = orig_ident.span.rust_2015();\n+        let is_absolute_path = match scope_set {\n+            ScopeSet::AbsolutePath(..) => true,\n+            _ => false,\n+        };\n+\n+        let mut suggestions = Vec::new();\n+        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n+\n+        self.visit_scopes(scope_set, parent_scope, ident, |this, scope, _| {\n+            match scope {\n+                Scope::DeriveHelpers => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                    if filter_fn(res) {\n+                        for derive in &parent_scope.derives {\n+                            let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                            if let Ok((Some(ext), _)) = this.resolve_macro_path(\n+                                derive, MacroKind::Derive, &parent_scope, true, true\n+                            ) {\n+                                suggestions.extend(ext.helper_attrs.iter().map(|name| {\n+                                    TypoSuggestion::from_res(*name, res)\n+                                }));\n+                            }\n+                        }\n+                    }\n+                }\n+                Scope::MacroRules(legacy_scope) => {\n+                    if let LegacyScope::Binding(legacy_binding) = legacy_scope {\n+                        let res = legacy_binding.binding.res();\n+                        if filter_fn(res) {\n+                            suggestions.push(\n+                                TypoSuggestion::from_res(legacy_binding.ident.name, res)\n+                            )\n+                        }\n+                    }\n+                }\n+                Scope::CrateRoot => {\n+                    let root_ident = Ident::new(kw::PathRoot, orig_ident.span);\n+                    let root_module = this.resolve_crate_root(root_ident);\n+                    add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                }\n+                Scope::Module(module) => {\n+                    use_prelude = !module.no_implicit_prelude;\n+                    add_module_candidates(module, &mut suggestions, filter_fn);\n+                }\n+                Scope::MacroUsePrelude => {\n+                    if use_prelude || rust_2015 {\n+                        let macro_use_prelude = &this.macro_use_prelude;\n+                        suggestions.extend(macro_use_prelude.iter().filter_map(|(name, binding)| {\n+                            let res = binding.res();\n+                            if filter_fn(res) {\n+                                Some(TypoSuggestion::from_res(*name, res))\n+                            } else {\n+                                None\n+                            }\n+                        }));\n+                    }\n+                }\n+                Scope::BuiltinMacros => {\n+                    suggestions.extend(this.builtin_macros.iter().filter_map(|(name, binding)| {\n+                        let res = binding.res();\n+                        if filter_fn(res) {\n+                            Some(TypoSuggestion::from_res(*name, res))\n+                        } else {\n+                            None\n+                        }\n+                    }));\n+                }\n+                Scope::BuiltinAttrs => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                    if filter_fn(res) {\n+                        suggestions.extend(BUILTIN_ATTRIBUTES.iter().map(|(name, ..)| {\n+                            TypoSuggestion::from_res(*name, res)\n+                        }));\n                     }\n                 }\n+                Scope::LegacyPluginHelpers => {\n+                    if use_prelude || rust_2015 {\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+                        if filter_fn(res) {\n+                            let plugin_attributes = this.session.plugin_attributes.borrow();\n+                            suggestions.extend(plugin_attributes.iter().map(|(name, _)| {\n+                                TypoSuggestion::from_res(*name, res)\n+                            }));\n+                        }\n+                    }\n+                }\n+                Scope::ExternPrelude => {\n+                    if use_prelude || is_absolute_path {\n+                        suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n+                            let res = Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX));\n+                            if filter_fn(res) {\n+                                Some(TypoSuggestion::from_res(ident.name, res))\n+                            } else {\n+                                None\n+                            }\n+                        }));\n+                    }\n+                }\n+                Scope::ToolPrelude => {\n+                    if use_prelude {\n+                        let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n+                        suggestions.extend(KNOWN_TOOLS.iter().map(|name| {\n+                            TypoSuggestion::from_res(*name, res)\n+                        }));\n+                    }\n+                }\n+                Scope::StdLibPrelude => {\n+                    if use_prelude {\n+                        if let Some(prelude) = this.prelude {\n+                            add_module_candidates(prelude, &mut suggestions, filter_fn);\n+                        }\n+                    }\n+                }\n+                Scope::BuiltinTypes => {\n+                    let primitive_types = &this.primitive_type_table.primitive_types;\n+                    suggestions.extend(\n+                        primitive_types.iter().flat_map(|(name, prim_ty)| {\n+                            let res = Res::PrimTy(*prim_ty);\n+                            if filter_fn(res) {\n+                                Some(TypoSuggestion::from_res(*name, res))\n+                            } else {\n+                                None\n+                            }\n+                        })\n+                    )\n+                }\n             }\n-        };\n \n+            None::<()>\n+        });\n+\n+        // Make sure error reporting is deterministic.\n+        suggestions.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            suggestions.iter().map(|suggestion| &suggestion.candidate),\n+            &ident.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != ident.name => suggestions\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    fn lookup_typo_candidate(\n+        &mut self,\n+        path: &[Segment],\n+        ns: Namespace,\n+        filter_fn: &impl Fn(Res) -> bool,\n+        span: Span,\n+    ) -> Option<TypoSuggestion> {\n         let mut names = Vec::new();\n         if path.len() == 1 {\n             // Search in lexical scope.\n@@ -570,17 +728,13 @@ impl<'a> Resolver<'a> {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n                     if filter_fn(res) {\n-                        names.push(TypoSuggestion {\n-                            candidate: ident.name,\n-                            article: res.article(),\n-                            kind: res.descr(),\n-                        });\n+                        names.push(TypoSuggestion::from_res(ident.name, res));\n                     }\n                 }\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    add_module_candidates(module, &mut names);\n+                    add_module_candidates(module, &mut names, &filter_fn);\n \n                     if let ModuleKind::Block(..) = module.kind {\n                         // We can see through blocks\n@@ -612,7 +766,7 @@ impl<'a> Resolver<'a> {\n                             }));\n \n                             if let Some(prelude) = self.prelude {\n-                                add_module_candidates(prelude, &mut names);\n+                                add_module_candidates(prelude, &mut names, &filter_fn);\n                             }\n                         }\n                         break;\n@@ -622,12 +776,8 @@ impl<'a> Resolver<'a> {\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n                 names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, _)| {\n-                        TypoSuggestion {\n-                            candidate: *name,\n-                            article: \"a\",\n-                            kind: \"primitive type\",\n-                        }\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n+                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n                     })\n                 )\n             }\n@@ -638,7 +788,7 @@ impl<'a> Resolver<'a> {\n                 mod_path, Some(TypeNS), false, span, CrateLint::No\n             ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names);\n+                    add_module_candidates(module, &mut names, &filter_fn);\n                 }\n             }\n         }\n@@ -844,62 +994,26 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    crate fn suggest_macro_name(\n-        &mut self, name: Symbol, kind: MacroKind, err: &mut DiagnosticBuilder<'a>, span: Span\n+    crate fn unresolved_macro_suggestions(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        macro_kind: MacroKind,\n+        parent_scope: &ParentScope<'a>,\n+        ident: Ident,\n     ) {\n-        if kind == MacroKind::Derive && (name.as_str() == \"Send\" || name.as_str() == \"Sync\") {\n-            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", name);\n-            err.span_note(span, &msg);\n-            return;\n-        }\n-\n-        // First check if this is a locally-defined bang macro.\n-        let suggestion = if let MacroKind::Bang = kind {\n-            find_best_match_for_name(\n-                self.macro_names.iter().map(|ident| &ident.name), &name.as_str(), None)\n-        } else {\n-            None\n-        // Then check global macros.\n-        }.or_else(|| {\n-            let names = self.builtin_macros.iter().chain(self.macro_use_prelude.iter())\n-                                                  .filter_map(|(name, binding)| {\n-                if binding.macro_kind() == Some(kind) { Some(name) } else { None }\n-            });\n-            find_best_match_for_name(names, &name.as_str(), None)\n-        // Then check modules.\n-        }).or_else(|| {\n-            let is_macro = |res| {\n-                if let Res::Def(DefKind::Macro(def_kind), _) = res {\n-                    def_kind == kind\n-                } else {\n-                    false\n-                }\n-            };\n-            let ident = Ident::new(name, span);\n-            self.lookup_typo_candidate(&[Segment::from_ident(ident)], MacroNS, is_macro, span)\n-                .map(|suggestion| suggestion.candidate)\n-        });\n+        let is_expected = &|res: Res| res.macro_kind() == Some(macro_kind);\n+        let suggestion = self.early_lookup_typo_candidate(\n+            ScopeSet::Macro(macro_kind), &parent_scope, ident, is_expected\n+        );\n+        add_typo_suggestion(err, suggestion, ident.span);\n \n-        if let Some(suggestion) = suggestion {\n-            if suggestion != name {\n-                if let MacroKind::Bang = kind {\n-                    err.span_suggestion(\n-                        span,\n-                        \"you could try the macro\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                } else {\n-                    err.span_suggestion(\n-                        span,\n-                        \"try\",\n-                        suggestion.to_string(),\n-                        Applicability::MaybeIncorrect\n-                    );\n-                }\n-            } else {\n-                err.help(\"have you added the `#[macro_use]` on the module/import?\");\n-            }\n+        if macro_kind == MacroKind::Derive &&\n+           (ident.as_str() == \"Send\" || ident.as_str() == \"Sync\") {\n+            let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n+            err.span_note(ident.span, &msg);\n+        }\n+        if self.macro_names.contains(&ident.modern()) {\n+            err.help(\"have you added the `#[macro_use]` on the module/import?\");\n         }\n     }\n }"}, {"sha": "9ebe0847ccc9f5885087307920d46715484a4e71", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -85,9 +85,7 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-fn is_known_tool(name: Name) -> bool {\n-    [\"clippy\", \"rustfmt\"].contains(&&*name.as_str())\n-}\n+const KNOWN_TOOLS: &[Name] = &[sym::clippy, sym::rustfmt];\n \n enum Weak {\n     Yes,\n@@ -1498,11 +1496,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n-        match self.res() {\n-            Res::Def(DefKind::Macro(kind), _) => Some(kind),\n-            Res::NonMacroAttr(..) => Some(MacroKind::Attr),\n-            _ => None,\n-        }\n+        self.res().macro_kind()\n     }\n \n     fn descr(&self) -> &'static str {\n@@ -2390,7 +2384,7 @@ impl<'a> Resolver<'a> {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n             }\n-            if ns == TypeNS && is_known_tool(ident.name) {\n+            if ns == TypeNS && KNOWN_TOOLS.contains(&ident.name) {\n                 let binding = (Res::ToolMod, ty::Visibility::Public,\n                                DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));"}, {"sha": "250611044f110398784b6eaf89d6b09aef3b54c8", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -1,7 +1,7 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n use crate::{Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n-use crate::{is_known_tool, resolve_error};\n+use crate::{resolve_error, KNOWN_TOOLS};\n use crate::ModuleOrUniformRoot;\n use crate::Namespace::*;\n use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -57,10 +57,10 @@ impl<'a> InvocationData<'a> {\n /// Not modularized, can shadow previous legacy bindings, etc.\n #[derive(Debug)]\n pub struct LegacyBinding<'a> {\n-    binding: &'a NameBinding<'a>,\n+    crate binding: &'a NameBinding<'a>,\n     /// Legacy scope into which the `macro_rules` item was planted.\n     crate parent_legacy_scope: LegacyScope<'a>,\n-    ident: Ident,\n+    crate ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n@@ -582,7 +582,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::ToolPrelude => {\n-                    if use_prelude && is_known_tool(ident.name) {\n+                    if use_prelude && KNOWN_TOOLS.contains(&ident.name) {\n                         let binding = (Res::ToolMod, ty::Visibility::Public,\n                                        DUMMY_SP, Mark::root()).to_name_binding(this.arenas);\n                         Ok((binding, Flags::PRELUDE))\n@@ -805,7 +805,7 @@ impl<'a> Resolver<'a> {\n                     let msg =\n                         format!(\"cannot find {} `{}{}` in this scope\", kind.descr(), ident, bang);\n                     let mut err = self.session.struct_span_err(ident.span, &msg);\n-                    self.suggest_macro_name(ident.name, kind, &mut err, ident.span);\n+                    self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n             }"}, {"sha": "131df5f0a174ab6083a6c5728c38cb6545172e8c", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -603,6 +603,7 @@ symbols! {\n         rustc_then_this_would_need,\n         rustc_variance,\n         rustdoc,\n+        rustfmt,\n         rust_eh_personality,\n         rust_eh_unwind_resume,\n         rust_oom,"}, {"sha": "1b8e689c753f31a2c7ca18d12806be1d3f7c4fe2", "filename": "src/test/ui/derives/deriving-meta-unknown-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-meta-unknown-trait.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find derive macro `Eqr` in this scope\n   --> $DIR/deriving-meta-unknown-trait.rs:1:10\n    |\n LL | #[derive(Eqr)]\n-   |          ^^^ help: try: `Eq`\n+   |          ^^^ help: a derive macro with a similar name exists: `Eq`\n \n error: aborting due to previous error\n "}, {"sha": "0fdb18d967a6c41723598a15861654f47cf14a0f", "filename": "src/test/ui/hygiene/no_implicit_prelude-2018.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2018.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -3,8 +3,6 @@ error: cannot find macro `print!` in this scope\n    |\n LL |         print!();\n    |         ^^^^^\n-   |\n-   = help: have you added the `#[macro_use]` on the module/import?\n \n error: aborting due to previous error\n "}, {"sha": "a89176fe6907be708f828a492efe5c0be21fffb2", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -13,7 +13,6 @@ error: cannot find macro `panic!` in this scope\n LL |         assert_eq!(0, 0);\n    |         ^^^^^^^^^^^^^^^^^\n    |\n-   = help: have you added the `#[macro_use]` on the module/import?\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error[E0599]: no method named `clone` found for type `()` in the current scope"}, {"sha": "c557255ab502eab03f66b6efae3541cf9e1d8b10", "filename": "src/test/ui/issues/issue-49074.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49074.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find attribute macro `marco_use` in this scope\n   --> $DIR/issue-49074.rs:3:3\n    |\n LL | #[marco_use] // typo\n-   |   ^^^^^^^^^\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_use`\n \n error: cannot find macro `bar!` in this scope\n   --> $DIR/issue-49074.rs:12:4"}, {"sha": "967f4f3c4ac4a93f5785d19be37aab173189a18e", "filename": "src/test/ui/macros/macro-name-typo.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-name-typo.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `printlx!` in this scope\n   --> $DIR/macro-name-typo.rs:2:5\n    |\n LL |     printlx!(\"oh noes!\");\n-   |     ^^^^^^^ help: you could try the macro: `println`\n+   |     ^^^^^^^ help: a macro with a similar name exists: `println`\n \n error: aborting due to previous error\n "}, {"sha": "96b8a24cff293c8ccc64622fa4a9fa2c05fcff5b", "filename": "src/test/ui/macros/macro-path-prelude-fail-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-3.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `inline!` in this scope\n   --> $DIR/macro-path-prelude-fail-3.rs:2:5\n    |\n LL |     inline!();\n-   |     ^^^^^^ help: you could try the macro: `line`\n+   |     ^^^^^^ help: a macro with a similar name exists: `line`\n \n error: aborting due to previous error\n "}, {"sha": "25778fba68f7c2e008f9a15b726e6a736d89291c", "filename": "src/test/ui/macros/macro-reexport-removed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-reexport-removed.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -14,7 +14,7 @@ error: cannot find attribute macro `macro_reexport` in this scope\n   --> $DIR/macro-reexport-removed.rs:5:3\n    |\n LL | #[macro_reexport(macro_one)]\n-   |   ^^^^^^^^^^^^^^\n+   |   ^^^^^^^^^^^^^^ help: a built-in attribute with a similar name exists: `macro_export`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "28f727d6a58081ed12ddeb204824f98d99955b59", "filename": "src/test/ui/macros/macro-use-wrong-name.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-use-wrong-name.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `macro_two!` in this scope\n   --> $DIR/macro-use-wrong-name.rs:7:5\n    |\n LL |     macro_two!();\n-   |     ^^^^^^^^^ help: you could try the macro: `macro_one`\n+   |     ^^^^^^^^^ help: a macro with a similar name exists: `macro_one`\n \n error: aborting due to previous error\n "}, {"sha": "9239b2a51e62b589aa0d4ba6560261675c3c1da8", "filename": "src/test/ui/macros/macro_undefined.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_undefined.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find macro `k!` in this scope\n   --> $DIR/macro_undefined.rs:11:5\n    |\n LL |     k!();\n-   |     ^ help: you could try the macro: `kl`\n+   |     ^ help: a macro with a similar name exists: `kl`\n \n error: aborting due to previous error\n "}, {"sha": "b068c6bc83bf3804b6ed8f2f2fff41b818aafc44", "filename": "src/test/ui/proc-macro/proc-macro-attributes.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-attributes.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error: cannot find attribute macro `C` in this scope\n   --> $DIR/proc-macro-attributes.rs:7:3\n    |\n LL | #[C]\n-   |   ^\n+   |   ^ help: a derive helper attribute with a similar name exists: `B`\n \n error[E0659]: `B` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/proc-macro-attributes.rs:6:3"}, {"sha": "3c9b2baacbd91ad330c04522c37987d4009001f5", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,13 +2,13 @@ error: cannot find derive macro `FooWithLongNan` in this scope\n   --> $DIR/resolve-error.rs:22:10\n    |\n LL | #[derive(FooWithLongNan)]\n-   |          ^^^^^^^^^^^^^^ help: try: `FooWithLongName`\n+   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n \n error: cannot find attribute macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:27:3\n    |\n LL | #[attr_proc_macra]\n-   |   ^^^^^^^^^^^^^^^ help: try: `attr_proc_macro`\n+   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n \n error: cannot find attribute macro `FooWithLongNan` in this scope\n   --> $DIR/resolve-error.rs:31:3\n@@ -20,13 +20,13 @@ error: cannot find derive macro `Dlone` in this scope\n   --> $DIR/resolve-error.rs:34:10\n    |\n LL | #[derive(Dlone)]\n-   |          ^^^^^ help: try: `Clone`\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n \n error: cannot find derive macro `Dlona` in this scope\n   --> $DIR/resolve-error.rs:38:10\n    |\n LL | #[derive(Dlona)]\n-   |          ^^^^^ help: try: `Clona`\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:42:10\n@@ -38,13 +38,13 @@ error: cannot find macro `FooWithLongNama!` in this scope\n   --> $DIR/resolve-error.rs:47:5\n    |\n LL |     FooWithLongNama!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `FooWithLongNam`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n \n error: cannot find macro `attr_proc_macra!` in this scope\n   --> $DIR/resolve-error.rs:50:5\n    |\n LL |     attr_proc_macra!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `attr_proc_mac`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n \n error: cannot find macro `Dlona!` in this scope\n   --> $DIR/resolve-error.rs:53:5\n@@ -56,7 +56,7 @@ error: cannot find macro `bang_proc_macrp!` in this scope\n   --> $DIR/resolve-error.rs:56:5\n    |\n LL |     bang_proc_macrp!();\n-   |     ^^^^^^^^^^^^^^^ help: you could try the macro: `bang_proc_macro`\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n \n error: aborting due to 10 previous errors\n "}, {"sha": "2e3c0f5448e865e770f7618db2bc4bbf1e36ceae", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -2,7 +2,7 @@ error[E0412]: cannot find type `esize` in this scope\n   --> $DIR/levenshtein.rs:5:11\n    |\n LL | fn foo(c: esize) {} // Misspelled primitive type name.\n-   |           ^^^^^ help: a primitive type with a similar name exists: `isize`\n+   |           ^^^^^ help: a builtin type with a similar name exists: `isize`\n \n error[E0412]: cannot find type `Baz` in this scope\n   --> $DIR/levenshtein.rs:10:10"}, {"sha": "6b2f591b9e7d9cb57e24dd96d66d8e7cdf8dd2d1", "filename": "src/test/ui/suggestions/attribute-typos.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/329c05251a007077aeb8818a5e1000796de0128d/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fattribute-typos.stderr?ref=329c05251a007077aeb8818a5e1000796de0128d", "patch": "@@ -11,19 +11,19 @@ error: cannot find attribute macro `rustc_err` in this scope\n   --> $DIR/attribute-typos.rs:7:3\n    |\n LL | #[rustc_err]\n-   |   ^^^^^^^^^\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `rustc_error`\n \n error: cannot find attribute macro `tests` in this scope\n   --> $DIR/attribute-typos.rs:4:3\n    |\n LL | #[tests]\n-   |   ^^^^^ help: try: `test`\n+   |   ^^^^^ help: an attribute macro with a similar name exists: `test`\n \n error: cannot find attribute macro `deprcated` in this scope\n   --> $DIR/attribute-typos.rs:1:3\n    |\n LL | #[deprcated]\n-   |   ^^^^^^^^^\n+   |   ^^^^^^^^^ help: a built-in attribute with a similar name exists: `deprecated`\n \n error: aborting due to 4 previous errors\n "}]}