{"sha": "124eb2119c78651cfaaa7a046a101fa2e20f83ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNGViMjExOWM3ODY1MWNmYWFhN2EwNDZhMTAxZmEyZTIwZjgzY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T06:35:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T06:35:57Z"}, "message": "auto merge of #9026 : jbclements/rust/let-var-hygiene, r=jbclements\n\nThis is a rebase of my approved pull request from ... the end of June? It introduces hygiene for let-bound variables.", "tree": {"sha": "7efa84a80df29080ae0314d0e3788131c72bdceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7efa84a80df29080ae0314d0e3788131c72bdceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/124eb2119c78651cfaaa7a046a101fa2e20f83ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/124eb2119c78651cfaaa7a046a101fa2e20f83ca", "html_url": "https://github.com/rust-lang/rust/commit/124eb2119c78651cfaaa7a046a101fa2e20f83ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/124eb2119c78651cfaaa7a046a101fa2e20f83ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e6de6b7da8ee88bf84b0e217900051334be08da", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6de6b7da8ee88bf84b0e217900051334be08da", "html_url": "https://github.com/rust-lang/rust/commit/3e6de6b7da8ee88bf84b0e217900051334be08da"}, {"sha": "b6f3d3f24546a525d1eb80923692c1296eddc4dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f3d3f24546a525d1eb80923692c1296eddc4dc", "html_url": "https://github.com/rust-lang/rust/commit/b6f3d3f24546a525d1eb80923692c1296eddc4dc"}], "stats": {"total": 2261, "additions": 1625, "deletions": 636}, "files": [{"sha": "49bbddca1dbb773d648807b5f2a9b846d9be7449", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -14,28 +14,8 @@ use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_byt\n     add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n-\n-// Sha-512 and Sha-256 use basically the same calculations which are implemented by these macros.\n-// Inlining the calculations seems to result in better generated code.\n-macro_rules! schedule_round( ($t:expr) => (\n-        W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n-    )\n-)\n-\n-macro_rules! sha2_round(\n-    ($A:ident, $B:ident, $C:ident, $D:ident,\n-     $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n-        {\n-            $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n-            $D += $H;\n-            $H += sum0($A) + maj($A, $B, $C);\n-        }\n-    )\n-)\n-\n-\n-// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n-// functions\n+// A structure that represents that state of a digest computation for the SHA-2 512 family\n+// of digest functions\n struct Engine512State {\n     H0: u64,\n     H1: u64,\n@@ -108,6 +88,25 @@ impl Engine512State {\n \n         let mut W = [0u64, ..80];\n \n+        // Sha-512 and Sha-256 use basically the same calculations which are implemented by\n+        // these macros. Inlining the calculations seems to result in better generated code.\n+        macro_rules! schedule_round( ($t:expr) => (\n+                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+                )\n+        )\n+\n+        macro_rules! sha2_round(\n+            ($A:ident, $B:ident, $C:ident, $D:ident,\n+             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n+                {\n+                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+                    $D += $H;\n+                    $H += sum0($A) + maj($A, $B, $C);\n+                }\n+             )\n+        )\n+\n+\n         read_u64v_be(W.mut_slice(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n@@ -505,6 +504,25 @@ impl Engine256State {\n \n         let mut W = [0u32, ..64];\n \n+        // Sha-512 and Sha-256 use basically the same calculations which are implemented\n+        // by these macros. Inlining the calculations seems to result in better generated code.\n+        macro_rules! schedule_round( ($t:expr) => (\n+                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+                )\n+        )\n+\n+        macro_rules! sha2_round(\n+            ($A:ident, $B:ident, $C:ident, $D:ident,\n+             $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n+                {\n+                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+                    $D += $H;\n+                    $H += sum0($A) + maj($A, $B, $C);\n+                }\n+             )\n+        )\n+\n+\n         read_u32v_be(W.mut_slice(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for"}, {"sha": "cdae2f5e066c1f3c1eab4cbd64c8a32862532997", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -788,7 +788,7 @@ impl BorrowckCtxt {\n                 match fname {\n                     mc::NamedField(ref fname) => {\n                         out.push_char('.');\n-                        out.push_str(token::ident_to_str(fname));\n+                        out.push_str(token::interner_get(*fname));\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here"}, {"sha": "22e6bc3ac2febee28fa8f296d84e3c607381e535", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -81,7 +81,7 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n fn find_item(item: @item, ctxt: @mut EntryContext, visitor: &mut EntryVisitor) {\n     match item.node {\n         item_fn(*) => {\n-            if item.ident == special_idents::main {\n+            if item.ident.name == special_idents::main.name {\n                 match ctxt.ast_map.find(&item.id) {\n                     Some(&ast_map::node_item(_, path)) => {\n                         if path.len() == 0 {"}, {"sha": "0f5dd8cda7a99f180bb35312b31f18920d0e899c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -56,6 +56,7 @@ use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n+use syntax::parse::token;\n \n #[deriving(Eq)]\n pub enum categorization {\n@@ -99,7 +100,7 @@ pub enum InteriorKind {\n \n #[deriving(Eq, IterBytes)]\n pub enum FieldName {\n-    NamedField(ast::Ident),\n+    NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n@@ -619,7 +620,7 @@ impl mem_categorization_ctxt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name))),\n+            cat: cat_interior(base_cmt, InteriorField(NamedField(f_name.name))),\n             mutbl: base_cmt.mutbl.inherit(),\n             ty: f_ty\n         }\n@@ -1224,9 +1225,9 @@ pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n }\n \n impl Repr for InteriorKind {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n         match *self {\n-            InteriorField(NamedField(fld)) => tcx.sess.str_of(fld).to_owned(),\n+            InteriorField(NamedField(fld)) => token::interner_get(fld).to_owned(),\n             InteriorField(PositionalField(i)) => fmt!(\"#%?\", i),\n             InteriorElement(_) => ~\"[]\",\n         }"}, {"sha": "55783e3568ea6b42854380f0cdf2e78672be7e42", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -429,7 +429,7 @@ impl VisitContext {\n                     // specified and (2) have a type that\n                     // moves-by-default:\n                     let consume_with = with_fields.iter().any(|tf| {\n-                        !fields.iter().any(|f| f.ident == tf.ident) &&\n+                        !fields.iter().any(|f| f.ident.name == tf.ident.name) &&\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n "}, {"sha": "d6f61c6328a0bbf883506b948b3b1d624742b0eb", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -206,7 +206,7 @@ impl PrivacyVisitor {\n     fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n-            if field.ident != ident { loop; }\n+            if field.ident.name != ident.name { loop; }\n             if field.vis == private {\n                 self.tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n                                              token::ident_to_str(&ident)));"}, {"sha": "292047d885d5245fd99717ae97f454e04453bce0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 101, "deletions": 98, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -23,13 +23,13 @@ use middle::pat_util::pat_bindings;\n \n use syntax::ast::*;\n use syntax::ast;\n-use syntax::ast_util::{def_id_of_def, local_def};\n+use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n use syntax::parse::token;\n-use syntax::parse::token::ident_interner;\n+use syntax::parse::token::{ident_interner, interner_get};\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, dummy_sp, BytePos};\n@@ -51,7 +51,7 @@ pub struct binding_info {\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = HashMap<Ident,binding_info>;\n+pub type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[DefId]>;\n@@ -311,7 +311,7 @@ pub enum DuplicateCheckingMode {\n \n /// One local scope.\n pub struct Rib {\n-    bindings: @mut HashMap<Ident, DefLike>,\n+    bindings: @mut HashMap<Name, DefLike>,\n     self_binding: @mut Option<DefLike>,\n     kind: RibKind,\n }\n@@ -445,12 +445,12 @@ pub struct Module {\n     def_id: Option<DefId>,\n     kind: ModuleKind,\n \n-    children: @mut HashMap<Ident, @mut NameBindings>,\n+    children: @mut HashMap<Name, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n     // The external module children of this node that were declared with\n     // `extern mod`.\n-    external_module_children: @mut HashMap<Ident, @mut Module>,\n+    external_module_children: @mut HashMap<Name, @mut Module>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -469,7 +469,7 @@ pub struct Module {\n     anonymous_children: @mut HashMap<NodeId,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @mut HashMap<Ident, @mut ImportResolution>,\n+    import_resolutions: @mut HashMap<Name, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -759,15 +759,14 @@ pub fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n pub struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Ident,prim_ty>,\n+    primitive_types: HashMap<Name,prim_ty>,\n }\n \n impl PrimitiveTypeTable {\n     pub fn intern(&mut self,\n                   string: &str,\n                   primitive_type: prim_ty) {\n-        let ident = token::str_to_ident(string);\n-        self.primitive_types.insert(ident, primitive_type);\n+        self.primitive_types.insert(token::intern(string), primitive_type);\n     }\n }\n \n@@ -873,7 +872,7 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    method_map: @mut HashMap<Ident, HashSet<DefId>>,\n+    method_map: @mut HashMap<Name, HashSet<DefId>>,\n     structs: HashSet<DefId>,\n \n     // The number of imports that are currently unresolved.\n@@ -1036,10 +1035,10 @@ impl Resolver {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             None => {\n                 let child = @mut NameBindings();\n-                module_.children.insert(name, child);\n+                module_.children.insert(name.name, child);\n                 return (child, new_parent);\n             }\n             Some(&child) => {\n@@ -1307,7 +1306,7 @@ impl Resolver {\n                     } if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n-                        let new_parent = match parent.children.find(&name) {\n+                        let new_parent = match parent.children.find(&name.name) {\n                             // It already exists\n                             Some(&child) if child.get_module_if_available()\n                                                  .is_some() &&\n@@ -1426,7 +1425,7 @@ impl Resolver {\n                     match ty_m.explicit_self.node {\n                         sty_static => {}\n                         _ => {\n-                            method_names.insert(ident, ());\n+                            method_names.insert(ident.name, ());\n                         }\n                     }\n                 }\n@@ -1582,7 +1581,7 @@ impl Resolver {\n                                                           false);\n \n                         parent.external_module_children.insert(\n-                            name,\n+                            name.name,\n                             external_module);\n \n                         self.build_reduced_graph_for_external_crate(\n@@ -1727,7 +1726,7 @@ impl Resolver {\n \n                   // Add it to the trait info if not static.\n                   if explicit_self != sty_static {\n-                      interned_method_names.insert(method_name);\n+                      interned_method_names.insert(method_name.name);\n                   }\n               }\n               for name in interned_method_names.iter() {\n@@ -1981,7 +1980,7 @@ impl Resolver {\n                        self.idents_to_str(directive.module_path),\n                        self.session.str_of(target));\n \n-                match module_.import_resolutions.find(&target) {\n+                match module_.import_resolutions.find(&target.name) {\n                     Some(&resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -1996,7 +1995,7 @@ impl Resolver {\n                         debug!(\"(building import directive) creating new\");\n                         let resolution = @mut ImportResolution::new(privacy, id);\n                         resolution.outstanding_references = 1;\n-                        module_.import_resolutions.insert(target, resolution);\n+                        module_.import_resolutions.insert(target.name, resolution);\n                     }\n                 }\n             }\n@@ -2281,7 +2280,7 @@ impl Resolver {\n \n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&source) {\n+        match containing_module.children.find(&source.name) {\n             None => {\n                 // Continue.\n             }\n@@ -2315,7 +2314,7 @@ impl Resolver {\n                 // Now search the exported imports within the containing\n                 // module.\n \n-                match containing_module.import_resolutions.find(&source) {\n+                match containing_module.import_resolutions.find(&source.name) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2386,7 +2385,7 @@ impl Resolver {\n             BoundResult(*) => {}\n             _ => {\n                 match containing_module.external_module_children\n-                                       .find(&source) {\n+                                       .find(&source.name) {\n                     None => {} // Continue.\n                     Some(module) => {\n                         let name_bindings =\n@@ -2400,8 +2399,8 @@ impl Resolver {\n         }\n \n         // We've successfully resolved the import. Write the results in.\n-        assert!(module_.import_resolutions.contains_key(&target));\n-        let import_resolution = module_.import_resolutions.get(&target);\n+        assert!(module_.import_resolutions.contains_key(&target.name));\n+        let import_resolution = module_.import_resolutions.get(&target.name);\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2563,15 +2562,15 @@ impl Resolver {\n             }\n         }\n \n-        let merge_import_resolution = |ident,\n+        let merge_import_resolution = |name,\n                                        name_bindings: @mut NameBindings| {\n             let dest_import_resolution;\n-            match module_.import_resolutions.find(&ident) {\n+            match module_.import_resolutions.find(&name) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @mut ImportResolution::new(privacy, id);\n                     module_.import_resolutions.insert\n-                        (ident, dest_import_resolution);\n+                        (name, dest_import_resolution);\n                 }\n                 Some(&existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n@@ -2580,7 +2579,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   self.session.str_of(ident),\n+                   interner_get(name),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n@@ -2602,15 +2601,15 @@ impl Resolver {\n \n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n-        for (&ident, name_bindings) in containing_module.children.iter() {\n-            merge_import_resolution(ident, *name_bindings);\n+        for (&name, name_bindings) in containing_module.children.iter() {\n+            merge_import_resolution(name, *name_bindings);\n         }\n \n         // Add external module children from the containing module.\n-        for (&ident, module) in containing_module.external_module_children.iter() {\n+        for (&name, module) in containing_module.external_module_children.iter() {\n             let name_bindings =\n                 @mut Resolver::create_name_bindings_from_module(*module);\n-            merge_import_resolution(ident, name_bindings);\n+            merge_import_resolution(name, name_bindings);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -2836,7 +2835,7 @@ impl Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 return Success(Target::new(module_, *name_bindings));\n@@ -2848,7 +2847,7 @@ impl Resolver {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(&name.name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -2872,7 +2871,7 @@ impl Resolver {\n \n         // Search for external modules.\n         if namespace == TypeNS {\n-            match module_.external_module_children.find(&name) {\n+            match module_.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3034,8 +3033,9 @@ impl Resolver {\n         }\n     }\n \n-    /// Resolves a \"module prefix\". A module prefix is one of (a) `self::`;\n+    /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n+    /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     pub fn resolve_module_prefix(@mut self,\n                                  module_: @mut Module,\n                                  module_path: &[Ident])\n@@ -3091,7 +3091,7 @@ impl Resolver {\n \n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(module_);\n-        match module_.children.find(&name) {\n+        match module_.children.find(&name.name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n@@ -3112,7 +3112,7 @@ impl Resolver {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.find(&name) {\n+        match module_.import_resolutions.find(&name.name) {\n             Some(import_resolution) => {\n                 if import_resolution.privacy == Public &&\n                         import_resolution.outstanding_references != 0 {\n@@ -3147,7 +3147,7 @@ impl Resolver {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match module_.external_module_children.find(&name) {\n+            match module_.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     let name_bindings =\n@@ -3273,7 +3273,7 @@ impl Resolver {\n \n     pub fn add_exports_of_namebindings(@mut self,\n                                        exports2: &mut ~[Export2],\n-                                       ident: Ident,\n+                                       name: Name,\n                                        namebindings: @mut NameBindings,\n                                        ns: Namespace,\n                                        reexport: bool) {\n@@ -3282,11 +3282,11 @@ impl Resolver {\n             (Some(d), Some(Public)) => {\n                 debug!(\"(computing exports) YES: %s '%s' => %?\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n-                       self.session.str_of(ident),\n+                       interner_get(name),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n                     reexport: reexport,\n-                    name: self.session.str_of(ident),\n+                    name: interner_get(name),\n                     def_id: def_id_of_def(d)\n                 });\n             }\n@@ -3302,20 +3302,20 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for (ident, importresolution) in module_.import_resolutions.iter() {\n+        for (name, importresolution) in module_.import_resolutions.iter() {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n-                       self.session.str_of(*ident));\n+                       interner_get(*name));\n                 loop;\n             }\n             let xs = [TypeNS, ValueNS];\n             for ns in xs.iter() {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               self.session.str_of(*ident));\n+                               interner_get(*name));\n                         self.add_exports_of_namebindings(&mut *exports2,\n-                                                         *ident,\n+                                                         *name,\n                                                          target.bindings,\n                                                          *ns,\n                                                          true)\n@@ -3354,7 +3354,7 @@ impl Resolver {\n             }\n             Some(name) => {\n                 self.populate_module_if_necessary(orig_module);\n-                match orig_module.children.find(&name) {\n+                match orig_module.children.find(&name.name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n@@ -3498,7 +3498,7 @@ impl Resolver {\n \n     pub fn search_ribs(@mut self,\n                        ribs: &mut ~[@Rib],\n-                       name: Ident,\n+                       name: Name,\n                        span: Span,\n                        allow_capturing_self: AllowCapturingSelfFlag)\n                        -> Option<DefLike> {\n@@ -3591,7 +3591,9 @@ impl Resolver {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib::new(NormalRibKind);\n                 self.type_ribs.push(self_type_rib);\n-                self_type_rib.bindings.insert(self.type_self_ident,\n+                // plain insert (no renaming)\n+                let name = self.type_self_ident.name;\n+                self_type_rib.bindings.insert(name,\n                                               DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n@@ -3723,7 +3725,7 @@ impl Resolver {\n                 self.type_ribs.push(function_type_rib);\n \n                 for (index, type_parameter) in generics.ty_params.iter().enumerate() {\n-                    let name = type_parameter.ident;\n+                    let ident = type_parameter.ident;\n                     debug!(\"with_type_parameter_rib: %d %d\", node_id,\n                            type_parameter.id);\n                     let def_like = DlDef(DefTyParam\n@@ -3733,7 +3735,8 @@ impl Resolver {\n                     // the item that bound it\n                     self.record_def(type_parameter.id,\n                                     DefTyParamBinder(node_id));\n-                    function_type_rib.bindings.insert(name, def_like);\n+                    // plain insert (no renaming)\n+                    function_type_rib.bindings.insert(ident.name, def_like);\n                 }\n             }\n \n@@ -4064,17 +4067,23 @@ impl Resolver {\n                              None, visitor);\n     }\n \n+    // build a map from pattern identifiers to binding-info's.\n+    // this is done hygienically. This could arise for a macro\n+    // that expands into an or-pattern where one 'x' was from the\n+    // user and one 'x' came from the macro.\n     pub fn binding_mode_map(@mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n         do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n-            let ident = path_to_ident(path);\n-            result.insert(ident,\n+            let name = mtwt_resolve(path_to_ident(path));\n+            result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n         }\n         return result;\n     }\n \n+    // check that all of the arms in an or-pattern have exactly the\n+    // same set of bindings, with the same binding modes for each.\n     pub fn check_consistent_bindings(@mut self, arm: &Arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n@@ -4088,15 +4097,15 @@ impl Resolver {\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             self.session.str_of(key), i + 1));\n+                             interner_get(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 self.session.str_of(key), i + 1));\n+                                 interner_get(key), i + 1));\n                     }\n                   }\n                 }\n@@ -4108,7 +4117,7 @@ impl Resolver {\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             self.session.str_of(key), i + 1));\n+                             interner_get(key), i + 1));\n                 }\n             }\n         }\n@@ -4170,11 +4179,11 @@ impl Resolver {\n \n                 // First, check to see whether the name is a primitive type.\n                 if path.segments.len() == 1 {\n-                    let name = path.segments.last().identifier;\n+                    let id = path.segments.last().identifier;\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(&name) {\n+                            .find(&id.name) {\n \n                         Some(&primitive_type) => {\n                             result_def =\n@@ -4272,7 +4281,7 @@ impl Resolver {\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n-                           bindings_list: Option<@mut HashMap<Ident,NodeId>>,\n+                           bindings_list: Option<@mut HashMap<Name,NodeId>>,\n                            visitor: &mut ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n@@ -4290,13 +4299,14 @@ impl Resolver {\n                     // what you want).\n \n                     let ident = path.segments[0].identifier;\n+                    let renamed = mtwt_resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident) {\n                         FoundStructOrEnumVariant(def)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     struct or enum variant\",\n-                                    self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4310,13 +4320,12 @@ impl Resolver {\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                        self.session\n-                                                            .str_of(ident)));\n+                                                       interner_get(renamed)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     constant\",\n-                                    self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4331,7 +4340,7 @@ impl Resolver {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(ident));\n+                                   interner_get(renamed));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4366,16 +4375,16 @@ impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key(&ident) => {\n+                                if !bindings_list.contains_key(&renamed) => {\n                                     let this = &mut *self;\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n-                                    last_rib.bindings.insert(ident,\n+                                    last_rib.bindings.insert(renamed,\n                                                              DlDef(def));\n-                                    bindings_list.insert(ident, pat_id);\n+                                    bindings_list.insert(renamed, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(&ident) == Some(&pat_id) {\n+                                  if b.find(&renamed) == Some(&pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4391,7 +4400,7 @@ impl Resolver {\n                                     let this = &mut *self;\n                                     let last_rib = this.value_ribs[\n                                             this.value_ribs.len() - 1];\n-                                    last_rib.bindings.insert(ident,\n+                                    last_rib.bindings.insert(renamed,\n                                                              DlDef(def));\n                                 }\n                             }\n@@ -4607,6 +4616,7 @@ impl Resolver {\n         return unqualified_def;\n     }\n \n+    // resolve a single identifier (used as a varref)\n     pub fn resolve_identifier(@mut self,\n                               identifier: Ident,\n                               namespace: Namespace,\n@@ -4639,7 +4649,7 @@ impl Resolver {\n                                                 -> NameDefinition {\n         // First, search children.\n         self.populate_module_if_necessary(containing_module);\n-        match containing_module.children.find(&name) {\n+        match containing_module.children.find(&name.name) {\n             Some(child_name_bindings) => {\n                 match (child_name_bindings.def_for_namespace(namespace),\n                        child_name_bindings.privacy_for_namespace(namespace)) {\n@@ -4662,7 +4672,7 @@ impl Resolver {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.find(&name) {\n+        match containing_module.import_resolutions.find(&name.name) {\n             Some(import_resolution) if import_resolution.privacy == Public ||\n                                        xray == Xray => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n@@ -4690,7 +4700,7 @@ impl Resolver {\n \n         // Finally, search through external children.\n         if namespace == TypeNS {\n-            match containing_module.external_module_children.find(&name) {\n+            match containing_module.external_module_children.find(&name.name) {\n                 None => {}\n                 Some(module) => {\n                     match module.def_id {\n@@ -4706,25 +4716,13 @@ impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[Ident] {\n-        let mut module_path_idents = ~[];\n-        for (index, segment) in path.segments.iter().enumerate() {\n-            if index == path.segments.len() - 1 {\n-                break;\n-            }\n-\n-            module_path_idents.push(segment.identifier);\n-        }\n-\n-        return module_path_idents;\n-    }\n-\n+    // resolve a \"module-relative\" path, e.g. a::b::c\n     pub fn resolve_module_relative_path(@mut self,\n                                         path: &Path,\n                                         xray: XrayFlag,\n                                         namespace: Namespace)\n                                         -> Option<Def> {\n-        let module_path_idents = self.intern_module_part_of_path(path);\n+        let module_path_idents = path.segments.init().map(|ps| ps.identifier);\n \n         let containing_module;\n         match self.resolve_module_path(self.current_module,\n@@ -4749,9 +4747,9 @@ impl Resolver {\n             }\n         }\n \n-        let name = path.segments.last().identifier;\n+        let ident = path.segments.last().identifier;\n         let def = match self.resolve_definition_of_name_in_module(containing_module,\n-                                                        name,\n+                                                        ident,\n                                                         namespace,\n                                                         xray) {\n             NoNameDefinition => {\n@@ -4764,7 +4762,7 @@ impl Resolver {\n         };\n         match containing_module.kind {\n             TraitModuleKind | ImplModuleKind => {\n-                match self.method_map.find(&name) {\n+                match self.method_map.find(&ident.name) {\n                     Some(s) => {\n                         match containing_module.def_id {\n                             Some(def_id) if s.contains(&def_id) => {\n@@ -4790,7 +4788,7 @@ impl Resolver {\n                                        xray: XrayFlag,\n                                        namespace: Namespace)\n                                        -> Option<Def> {\n-        let module_path_idents = self.intern_module_part_of_path(path);\n+        let module_path_idents = path.segments.init().map(|ps| ps.identifier);\n \n         let root_module = self.graph_root.get_module();\n \n@@ -4841,12 +4839,14 @@ impl Resolver {\n         let search_result;\n         match namespace {\n             ValueNS => {\n-                search_result = self.search_ribs(self.value_ribs, ident,\n+                let renamed = mtwt_resolve(ident);\n+                search_result = self.search_ribs(self.value_ribs, renamed,\n                                                  span,\n                                                  DontAllowCapturingSelf);\n             }\n             TypeNS => {\n-                search_result = self.search_ribs(self.type_ribs, ident,\n+                let name = ident.name;\n+                search_result = self.search_ribs(self.type_ribs, name,\n                                                  span, AllowCapturingSelf);\n             }\n         }\n@@ -4957,7 +4957,7 @@ impl Resolver {\n         while j != 0 {\n             j -= 1;\n             for (&k, _) in this.value_ribs[j].bindings.iter() {\n-                maybes.push(this.session.str_of(k));\n+                maybes.push(interner_get(k));\n                 values.push(uint::max_value);\n             }\n         }\n@@ -5146,7 +5146,8 @@ impl Resolver {\n                         let this = &mut *self;\n                         let def_like = DlDef(DefLabel(expr.id));\n                         let rib = this.label_ribs[this.label_ribs.len() - 1];\n-                        rib.bindings.insert(label, def_like);\n+                        // plain insert (no renaming)\n+                        rib.bindings.insert(label.name, def_like);\n                     }\n \n                     visit::walk_expr(visitor, expr, ());\n@@ -5156,7 +5157,8 @@ impl Resolver {\n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n-                match self.search_ribs(self.label_ribs, label, expr.span,\n+                let name = label.name;\n+                match self.search_ribs(self.label_ribs, name, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n                         self.resolve_error(expr.span,\n@@ -5284,7 +5286,7 @@ impl Resolver {\n \n         let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n-        match self.method_map.find(&name) {\n+        match self.method_map.find(&name.name) {\n             Some(candidate_traits) => loop {\n                 // Look for the current trait.\n                 match self.current_trait_refs {\n@@ -5506,7 +5508,7 @@ impl Resolver {\n         debug!(\"Children:\");\n         self.populate_module_if_necessary(module_);\n         for (&name, _) in module_.children.iter() {\n-            debug!(\"* %s\", self.session.str_of(name));\n+            debug!(\"* %s\", interner_get(name));\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5529,7 +5531,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", self.session.str_of(*name),\n+            debug!(\"* %s:%s%s\", interner_get(*name),\n                    value_repr, type_repr);\n         }\n     }\n@@ -5554,3 +5556,4 @@ pub fn resolve_crate(session: Session,\n         trait_map: resolver.trait_map.clone(),\n     }\n }\n+"}, {"sha": "5efd81ebc474c289706909148e1f54a8865a10bc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -1482,7 +1482,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 let rec_vals = rec_fields.map(|field_name| {\n-                        let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n+                        let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n                         adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n                         });\n                 compile_submatch(\n@@ -2159,7 +2159,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n             do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for f in fields.iter() {\n-                    let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n+                    let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);"}, {"sha": "9e281172b26114dd6ce3739d65d706ea9db9c979", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 91, "deletions": 90, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -2648,146 +2648,147 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n }\n \n macro_rules! ifn (\n-    ($name:expr, $args:expr, $ret:expr) => ({\n+    ($intrinsics:ident, $name:expr, $args:expr, $ret:expr) => ({\n         let name = $name;\n         let f = decl_cdecl_fn(llmod, name, Type::func($args, &$ret));\n-        intrinsics.insert(name, f);\n+        $intrinsics.insert(name, f);\n     })\n )\n \n pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n     let i8p = Type::i8p();\n     let mut intrinsics = HashMap::new();\n \n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\",\n+    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i32\",\n          [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\",\n+    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i64\",\n          [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\",\n+    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i32\",\n          [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\",\n+    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i64\",\n          [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memset.p0i8.i32\",\n+    ifn!(intrinsics, \"llvm.memset.p0i8.i32\",\n          [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(\"llvm.memset.p0i8.i64\",\n+    ifn!(intrinsics, \"llvm.memset.p0i8.i64\",\n          [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n \n-    ifn!(\"llvm.trap\", [], Type::void());\n-    ifn!(\"llvm.frameaddress\", [Type::i32()], i8p);\n-\n-    ifn!(\"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n-    ifn!(\"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n-    ifn!(\"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n-    ifn!(\"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(\"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n-    ifn!(\"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n-    ifn!(\"llvm.sin.f32\",  [Type::f32()], Type::f32());\n-    ifn!(\"llvm.sin.f64\",  [Type::f64()], Type::f64());\n-    ifn!(\"llvm.cos.f32\",  [Type::f32()], Type::f32());\n-    ifn!(\"llvm.cos.f64\",  [Type::f64()], Type::f64());\n-    ifn!(\"llvm.exp.f32\",  [Type::f32()], Type::f32());\n-    ifn!(\"llvm.exp.f64\",  [Type::f64()], Type::f64());\n-    ifn!(\"llvm.exp2.f32\", [Type::f32()], Type::f32());\n-    ifn!(\"llvm.exp2.f64\", [Type::f64()], Type::f64());\n-    ifn!(\"llvm.log.f32\",  [Type::f32()], Type::f32());\n-    ifn!(\"llvm.log.f64\",  [Type::f64()], Type::f64());\n-    ifn!(\"llvm.log10.f32\",[Type::f32()], Type::f32());\n-    ifn!(\"llvm.log10.f64\",[Type::f64()], Type::f64());\n-    ifn!(\"llvm.log2.f32\", [Type::f32()], Type::f32());\n-    ifn!(\"llvm.log2.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(\"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n-    ifn!(\"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(\"llvm.fabs.f32\", [Type::f32()], Type::f32());\n-    ifn!(\"llvm.fabs.f64\", [Type::f64()], Type::f64());\n-    ifn!(\"llvm.floor.f32\",[Type::f32()], Type::f32());\n-    ifn!(\"llvm.floor.f64\",[Type::f64()], Type::f64());\n-    ifn!(\"llvm.ceil.f32\", [Type::f32()], Type::f32());\n-    ifn!(\"llvm.ceil.f64\", [Type::f64()], Type::f64());\n-    ifn!(\"llvm.trunc.f32\",[Type::f32()], Type::f32());\n-    ifn!(\"llvm.trunc.f64\",[Type::f64()], Type::f64());\n-\n-    ifn!(\"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n-    ifn!(\"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n-    ifn!(\"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n-    ifn!(\"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(\"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(\"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(\"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(\"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(\"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(\"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(\"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(\"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(\"llvm.bswap.i16\",[Type::i16()], Type::i16());\n-    ifn!(\"llvm.bswap.i32\",[Type::i32()], Type::i32());\n-    ifn!(\"llvm.bswap.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(\"llvm.sadd.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.trap\", [], Type::void());\n+    ifn!(intrinsics, \"llvm.frameaddress\", [Type::i32()], i8p);\n+\n+    ifn!(intrinsics, \"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n+    ifn!(intrinsics, \"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(intrinsics, \"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.sin.f32\",  [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.sin.f64\",  [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.cos.f32\",  [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.cos.f64\",  [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.exp.f32\",  [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.exp.f64\",  [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.exp2.f32\", [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.exp2.f64\", [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.log.f32\",  [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.log.f64\",  [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.log10.f32\",[Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.log10.f64\",[Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.log2.f32\", [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.log2.f64\", [Type::f64()], Type::f64());\n+\n+    ifn!(intrinsics, \"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(intrinsics, \"llvm.fabs.f32\", [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.fabs.f64\", [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.floor.f32\",[Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.floor.f64\",[Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.ceil.f32\", [Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.ceil.f64\", [Type::f64()], Type::f64());\n+    ifn!(intrinsics, \"llvm.trunc.f32\",[Type::f32()], Type::f32());\n+    ifn!(intrinsics, \"llvm.trunc.f64\",[Type::f64()], Type::f64());\n+\n+    ifn!(intrinsics, \"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n+    ifn!(intrinsics, \"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n+    ifn!(intrinsics, \"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n+    ifn!(intrinsics, \"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n+\n+    ifn!(intrinsics, \"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(intrinsics, \"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(intrinsics, \"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(intrinsics, \"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(intrinsics, \"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(intrinsics, \"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(intrinsics, \"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(intrinsics, \"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(intrinsics, \"llvm.bswap.i16\",[Type::i16()], Type::i16());\n+    ifn!(intrinsics, \"llvm.bswap.i32\",[Type::i32()], Type::i32());\n+    ifn!(intrinsics, \"llvm.bswap.i64\",[Type::i64()], Type::i64());\n+\n+    ifn!(intrinsics, \"llvm.sadd.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.sadd.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.sadd.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.sadd.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.sadd.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.sadd.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.sadd.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n-    ifn!(\"llvm.uadd.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.uadd.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.uadd.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.uadd.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.uadd.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.uadd.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.uadd.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.uadd.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n-    ifn!(\"llvm.ssub.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.ssub.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.ssub.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.ssub.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.ssub.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.ssub.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.ssub.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.ssub.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n-    ifn!(\"llvm.usub.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.usub.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.usub.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.usub.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.usub.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.usub.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.usub.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.usub.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n-    ifn!(\"llvm.smul.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.smul.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.smul.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.smul.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.smul.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.smul.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.smul.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.smul.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n-    ifn!(\"llvm.umul.with.overflow.i8\",\n+    ifn!(intrinsics, \"llvm.umul.with.overflow.i8\",\n         [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(\"llvm.umul.with.overflow.i16\",\n+    ifn!(intrinsics, \"llvm.umul.with.overflow.i16\",\n         [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(\"llvm.umul.with.overflow.i32\",\n+    ifn!(intrinsics, \"llvm.umul.with.overflow.i32\",\n         [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(\"llvm.umul.with.overflow.i64\",\n+    ifn!(intrinsics, \"llvm.umul.with.overflow.i64\",\n         [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n \n     return intrinsics;\n }\n \n pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n-    ifn!(\"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n-    ifn!(\"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n+    ifn!(intrinsics, \"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n+    ifn!(intrinsics,\n+         \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n pub fn trap(bcx: @mut Block) {"}, {"sha": "94f0b3735700101ab3a7066975ece2290edca1c3", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -374,7 +374,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n               let brepr = adt::represent_type(cx, bt);\n               let bv = const_expr(cx, base);\n               do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx, field, field_tys);\n+                  let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n                   adt::const_get_field(cx, brepr, bv, discr, ix)\n               }\n           }\n@@ -502,7 +502,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::Expr) -> ValueRef {\n                   |discr, field_tys| {\n                   let cs: ~[ValueRef] = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n-                      match fs.iter().find(|f| field_ty.ident == f.ident) {\n+                      match fs.iter().find(|f| field_ty.ident.name == f.ident.name) {\n                           Some(f) => const_expr(cx, (*f).expr),\n                           None => {\n                               match base_val {"}, {"sha": "6eb2fcf25fd3c289ff9113aa4c877ccd16099668", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -87,7 +87,7 @@ pub struct CrateContext {\n      // Cache of external const values\n      extern_const_values: HashMap<ast::DefId, ValueRef>,\n \n-     impl_method_cache: HashMap<(ast::DefId, ast::Ident), ast::DefId>,\n+     impl_method_cache: HashMap<(ast::DefId, ast::Name), ast::DefId>,\n \n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, Type>,"}, {"sha": "e4879ef4a11da0666c595ebe024670e2158fe425", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -1012,7 +1012,7 @@ fn struct_metadata(cx: &mut CrateContext,\n \n     let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n     let field_names = do fields.map |field| {\n-        if field.ident == special_idents::unnamed_field {\n+        if field.ident.name == special_idents::unnamed_field.name {\n             ~\"\"\n         } else {\n             cx.sess.str_of(field.ident).to_owned()\n@@ -1875,9 +1875,12 @@ fn populate_scope_map(cx: &mut CrateContext,\n                     // }\n \n                     // Is there already a binding with that name?\n+                    // N.B.: this comparison must be UNhygienic... because\n+                    // gdb knows nothing about the context, so any two\n+                    // variables with the same name will cause the problem.\n                     let need_new_scope = scope_stack\n                         .iter()\n-                        .any(|entry| entry.ident.iter().any(|i| *i == ident));\n+                        .any(|entry| entry.ident.iter().any(|i| i.name == ident.name));\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack"}, {"sha": "819d390ac28b09ac6997cd5633ee2ebfdb39604a", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -903,7 +903,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::Expr) -> DatumBlock {\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n         do with_field_tys(bcx.tcx(), base_datum.ty, None) |discr, field_tys| {\n-            let ix = ty::field_idx_strict(bcx.tcx(), field, field_tys);\n+            let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             DatumBlock {\n                 datum: do base_datum.get_element(bcx,\n                                                  field_tys[ix].mt.ty,\n@@ -1176,7 +1176,9 @@ fn trans_rec_or_struct(bcx: @mut Block,\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n         let numbered_fields = do fields.map |field| {\n-            let opt_pos = field_tys.iter().position(|field_ty| field_ty.ident == field.ident);\n+            let opt_pos =\n+                field_tys.iter().position(|field_ty|\n+                                          field_ty.ident.name == field.ident.name);\n             match opt_pos {\n                 Some(i) => {\n                     need_base[i] = false;"}, {"sha": "e49265a99a950a0aa46fd658fe6576752dc3e9fd", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -268,7 +268,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, callee_id,\n@@ -294,7 +294,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n \n pub fn method_with_name(ccx: &mut CrateContext,\n                         impl_id: ast::DefId,\n-                        name: ast::Ident) -> ast::DefId {\n+                        name: ast::Name) -> ast::DefId {\n     let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n     match meth_id_opt {\n         Some(m) => return m,\n@@ -303,7 +303,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n \n     let imp = ccx.tcx.impls.find(&impl_id)\n         .expect(\"could not find impl while translating\");\n-    let meth = imp.methods.iter().find(|m| m.ident == name)\n+    let meth = imp.methods.iter().find(|m| m.ident.name == name)\n         .expect(\"could not find method while translating\");\n \n     ccx.impl_method_cache.insert((impl_id, name), meth.def_id);\n@@ -323,7 +323,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n-          let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+          let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // obtain the `self` value:\n           let mut temp_cleanups = ~[];\n@@ -600,7 +600,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n         let ident = ty::method(tcx, *method_def_id).ident;\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n-        let m_id = method_with_name(ccx, impl_id, ident);\n+        let m_id = method_with_name(ccx, impl_id, ident.name);\n         let m = ty::method(tcx, m_id);\n         debug!(\"(making impl vtable) emitting method %s at subst %s\",\n                m.repr(tcx),"}, {"sha": "4a42efc339328f8f2fbe008bfc0680ab1e024bb3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -3360,19 +3360,19 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n     }\n }\n \n-pub fn field_idx(id: ast::Ident, fields: &[field]) -> Option<uint> {\n+pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n-    for f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n+    for f in fields.iter() { if f.ident.name == name { return Some(i); } i += 1u; }\n     return None;\n }\n \n-pub fn field_idx_strict(tcx: ty::ctxt, id: ast::Ident, fields: &[field])\n+pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n-    for f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n+    for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n-        tcx.sess.str_of(id),\n+        token::interner_get(name),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n "}, {"sha": "d813f97312340d58b9a9ba721b897ddc46a42985", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -296,13 +296,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n     // Index the class fields.\n     let mut field_map = HashMap::new();\n     for (i, class_field) in class_fields.iter().enumerate() {\n-        field_map.insert(class_field.ident, i);\n+        field_map.insert(class_field.ident.name, i);\n     }\n \n     // Typecheck each field.\n     let mut found_fields = HashSet::new();\n     for field in fields.iter() {\n-        match field_map.find(&field.ident) {\n+        match field_map.find(&field.ident.name) {\n             Some(&index) => {\n                 let class_field = class_fields[index];\n                 let field_type = ty::lookup_field_type(tcx,"}, {"sha": "48d630b4aa93d57dcc508a1e64588da54f19598e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -105,6 +105,7 @@ use syntax::ast::{sty_uniq, sty_static, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::parse::token;\n \n #[deriving(Eq)]\n pub enum CheckTraitsFlag {\n@@ -126,7 +127,7 @@ pub fn lookup(\n         self_expr: @ast::Expr,              // The expression `a`.\n         callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n-        m_name: ast::Ident,                 // The ident `b`.\n+        m_name: ast::Name,                  // The name `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n@@ -173,7 +174,7 @@ pub struct LookupContext<'self> {\n     expr: @ast::Expr,\n     self_expr: @ast::Expr,\n     callee_id: NodeId,\n-    m_name: ast::Ident,\n+    m_name: ast::Name,\n     supplied_tps: &'self [ty::t],\n     impl_dups: @mut HashSet<DefId>,\n     inherent_candidates: @mut ~[Candidate],\n@@ -515,7 +516,7 @@ impl<'self> LookupContext<'self> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n                 m.explicit_self != ast::sty_static &&\n-                m.ident == self.m_name })\n+                m.ident.name == self.m_name })\n             {\n                 Some(pos) => {\n                     let method = trait_methods[pos];\n@@ -558,12 +559,12 @@ impl<'self> LookupContext<'self> {\n             return; // already visited\n         }\n         debug!(\"push_candidates_from_impl: %s %s %s\",\n-               self.m_name.repr(self.tcx()),\n+               token::interner_get(self.m_name),\n                impl_info.ident.repr(self.tcx()),\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position(|m| m.ident == self.m_name) {\n+            match impl_info.methods.iter().position(|m| m.ident.name == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }"}, {"sha": "50c93468bb1619ade57c11771e6a1e0a246200ab", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -1117,10 +1117,10 @@ pub fn impl_self_ty(vcx: &VtableContext,\n pub fn lookup_field_ty(tcx: ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n-                       fieldname: ast::Ident,\n+                       fieldname: ast::Name,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n-    let o_field = items.iter().find(|f| f.ident == fieldname);\n+    let o_field = items.iter().find(|f| f.ident.name == fieldname);\n     do o_field.map() |f| {\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n@@ -1553,7 +1553,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              expr,\n                              rcvr,\n                              callee_id,\n-                             method_name,\n+                             method_name.name,\n                              expr_t,\n                              tps,\n                              DontDerefArgs,\n@@ -1637,7 +1637,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         op_ex: @ast::Expr,\n                         self_ex: @ast::Expr,\n                         self_t: ty::t,\n-                        opname: ast::Ident,\n+                        opname: ast::Name,\n                         args: ~[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n@@ -1777,7 +1777,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                             lhs_resolved_t, None)\n                 };\n                 return lookup_op_method(fcx, callee_id, ex, lhs_expr, lhs_resolved_t,\n-                                       fcx.tcx().sess.ident_of(*name),\n+                                       token::intern(*name),\n                                        ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n                                        expected_result);\n             }\n@@ -1811,7 +1811,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     -> ty::t {\n        lookup_op_method(\n             fcx, callee_id, ex, rhs_expr, rhs_t,\n-            fcx.tcx().sess.ident_of(mname), ~[],\n+            token::intern(mname), ~[],\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n                 fcx.type_error_message(ex.span, |actual| {\n@@ -1937,7 +1937,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_field(fcx: @mut FnCtxt,\n                    expr: @ast::Expr,\n                    base: @ast::Expr,\n-                   field: ast::Ident,\n+                   field: ast::Name,\n                    tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n@@ -1985,7 +1985,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted to take value of method `%s` on type `%s` \\\n                               (try writing an anonymous function)\",\n-                             tcx.sess.str_of(field), actual)\n+                             token::interner_get(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -1996,7 +1996,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted access of field `%s` on type `%s`, \\\n                               but no field with that name was found\",\n-                             tcx.sess.str_of(field), actual)\n+                             token::interner_get(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -2018,7 +2018,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut class_field_map = HashMap::new();\n         let mut fields_found = 0;\n         for field in field_types.iter() {\n-            class_field_map.insert(field.ident, (field.id, false));\n+            class_field_map.insert(field.ident.name, (field.id, false));\n         }\n \n         let mut error_happened = false;\n@@ -2027,7 +2027,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident).map_move(|x| *x);\n+            let pair = class_field_map.find(&field.ident.name).map_move(|x| *x);\n             match pair {\n                 None => {\n                     tcx.sess.span_err(\n@@ -2048,7 +2048,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, &substitutions);\n                     class_field_map.insert(\n-                        field.ident, (field_id, true));\n+                        field.ident.name, (field_id, true));\n                     fields_found += 1;\n                 }\n             }\n@@ -2070,11 +2070,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             if fields_found < field_types.len() {\n                 let mut missing_fields = ~[];\n                 for class_field in field_types.iter() {\n-                    let name = class_field.ident;\n+                    let name = class_field.ident.name;\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n-                            ~\"`\" + tcx.sess.str_of(name) + \"`\");\n+                            ~\"`\" + token::interner_get(name) + \"`\");\n                     }\n                 }\n \n@@ -2846,7 +2846,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, base, field, *tys);\n+        check_field(fcx, expr, base, field.name, *tys);\n       }\n       ast::ExprIndex(callee_id, base, idx) => {\n           check_expr(fcx, base);\n@@ -2886,7 +2886,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                     expr,\n                                                     base,\n                                                     resolved,\n-                                                    index_ident,\n+                                                    index_ident.name,\n                                                     ~[idx],\n                                                     DoDerefArgs,\n                                                     AutoderefReceiver,"}, {"sha": "700b60f1159a6ba9bbf70e0d8586c1d46f4d519e", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -553,13 +553,13 @@ impl CoherenceChecker {\n         let mut provided_names = HashSet::new();\n         // Implemented methods\n         for elt in all_methods.iter() {\n-            provided_names.insert(elt.ident);\n+            provided_names.insert(elt.ident.name);\n         }\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for method in r.iter() {\n             debug!(\"checking for %s\", method.ident.repr(tcx));\n-            if provided_names.contains(&method.ident) { loop; }\n+            if provided_names.contains(&method.ident.name) { loop; }\n \n             tcx.sess.span_err(trait_ref_span,\n                               fmt!(\"missing method `%s`\","}, {"sha": "3f5e1ef52108827e32d87ee40d73832224231234", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -698,7 +698,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_m in impl_ms.iter() {\n-        match trait_ms.iter().find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n+        match trait_ms.iter().find(|trait_m| trait_m.ident.name == impl_m.mty.ident.name) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method("}, {"sha": "e3615b7b7db037fa06712fbc5893404aca1368d4", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -375,3 +375,13 @@ impl<A:IterBytes> ToBytes for A {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    // just test to see if it compiles:\n+    #[test] fn iterbytes_compiles () {\n+        takes_iterbytes((3,4,5,false));\n+    }\n+    fn takes_iterbytes<T : IterBytes>(x : T) {}\n+}"}, {"sha": "b993f98ec82b16d735941c13b037fd120a5371c8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -20,6 +20,10 @@ use std::option::Option;\n use std::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+\n+// FIXME #6993: in librustc, uses of \"ident\" should be replaced\n+// by just \"Name\".\n+\n // an identifier contains a Name (index into the interner\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n@@ -32,6 +36,36 @@ impl Ident {\n     pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: EMPTY_CTXT}}\n }\n \n+// defining eq in this way is a way of guaranteeing that later stages of the\n+// compiler don't compare identifiers unhygienically. Unfortunately, some tests\n+// (specifically debuginfo in no-opt) want to do these comparisons, and that\n+// seems fine.  If only I could find a nice way to statically ensure that\n+// the compiler \"proper\" never compares identifiers.... I'm leaving this\n+// code here (commented out) for potential use in debugging. Specifically, if\n+// there's a bug where \"identifiers aren't matching\", it may be because\n+// they should be compared using mtwt_resolve. In such a case, re-enabling this\n+// code (and disabling deriving(Eq) for Idents) could help to isolate the\n+// problem\n+/* impl Eq for Ident {\n+    fn eq(&self, other: &Ident) -> bool {\n+        if (self.ctxt == other.ctxt) {\n+            self.name == other.name\n+        } else {\n+            // IF YOU SEE ONE OF THESE FAILS: it means that you're comparing\n+            // idents that have different contexts. You can't fix this without\n+            // knowing whether the comparison should be hygienic or non-hygienic.\n+            // if it should be non-hygienic (most things are), just compare the\n+            // 'name' fields of the idents. Or, even better, replace the idents\n+            // with Name's.\n+            fail!(fmt!(\"not allowed to compare these idents: %?, %?\", self, other));\n+        }\n+    }\n+    fn ne(&self, other: &Ident) -> bool {\n+        ! self.eq(other)\n+    }\n+}\n+*/\n+\n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n /// a fresh uint\n@@ -47,6 +81,15 @@ impl Ident {\n // storage.\n pub type SyntaxContext = uint;\n \n+// the SCTable contains a table of SyntaxContext_'s. It\n+// represents a flattened tree structure, to avoid having\n+// managed pointers everywhere (that caused an ICE).\n+// the mark_memo and rename_memo fields are side-tables\n+// that ensure that adding the same mark to the same context\n+// gives you back the same context as before. This shouldn't\n+// change the semantics--everything here is immutable--but\n+// it should cut down on memory use *a lot*; applying a mark\n+// to a tree containing 50 identifiers would otherwise generate\n pub struct SCTable {\n     table : ~[SyntaxContext_],\n     mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n@@ -70,6 +113,7 @@ pub enum SyntaxContext_ {\n     // in the \"from\" slot. In essence, they're all\n     // pointers to a single \"rename\" event node.\n     Rename (Ident,Name,SyntaxContext),\n+    // actually, IllegalCtxt may not be necessary.\n     IllegalCtxt\n }\n \n@@ -99,6 +143,7 @@ pub type FnIdent = Option<Ident>;\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n+    // FIXME #7743 : change this to Name!\n     ident: Ident\n }\n \n@@ -443,7 +488,7 @@ pub enum BlockCheckMode {\n     UnsafeBlock,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Expr {\n     id: NodeId,\n     node: Expr_,\n@@ -544,10 +589,11 @@ pub enum token_tree {\n     // a delimited sequence (the delimiters appear as the first\n     // and last elements of the vector)\n     tt_delim(@mut ~[token_tree]),\n+\n     // These only make sense for right-hand-sides of MBE macros:\n \n     // a kleene-style repetition sequence with a span, a tt_forest,\n-    // an optional separator (?), and a boolean where true indicates\n+    // an optional separator, and a boolean where true indicates\n     // zero or more (*), and false indicates one or more (+).\n     tt_seq(Span, @mut ~[token_tree], Option<::parse::token::Token>, bool),\n \n@@ -622,9 +668,13 @@ pub enum matcher_ {\n \n pub type mac = Spanned<mac_>;\n \n+// represents a macro invocation. The Path indicates which macro\n+// is being invoked, and the vector of token-trees contains the source\n+// of the macro invocation.\n+// There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum mac_ {\n-    mac_invoc_tt(Path,~[token_tree]),   // new macro-invocation\n+    mac_invoc_tt(Path,~[token_tree],SyntaxContext),   // new macro-invocation\n }\n \n pub type lit = Spanned<lit_>;"}, {"sha": "ee898c182e08a6f779d6a873a32997f03da81619", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 154, "deletions": 33, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -28,6 +28,8 @@ pub fn path_name_i(idents: &[Ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n+// totally scary function: ignores all but the last element, should have\n+// a different name\n pub fn path_to_ident(path: &Path) -> Ident {\n     path.segments.last().identifier\n }\n@@ -825,9 +827,6 @@ pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n \n // HYGIENE FUNCTIONS\n \n-/// Construct an identifier with the given name and an empty context:\n-pub fn new_ident(name: Name) -> Ident { Ident {name: name, ctxt: 0}}\n-\n /// Extend a syntax context with a given mark\n pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n     new_mark_internal(m,tail,get_sctable())\n@@ -908,42 +907,92 @@ pub fn get_sctable() -> @mut SCTable {\n     }\n }\n \n+/// print out an SCTable for debugging\n+pub fn display_sctable(table : &SCTable) {\n+    error!(\"SC table:\");\n+    for (idx,val) in table.table.iter().enumerate() {\n+        error!(\"%4u : %?\",idx,val);\n+    }\n+}\n+\n+\n /// Add a value to the end of a vec, return its index\n fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n     vec.push(val);\n     vec.len() - 1\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve(id : Ident) -> Name {\n-    resolve_internal(id, get_sctable())\n+pub fn mtwt_resolve(id : Ident) -> Name {\n+    resolve_internal(id, get_sctable(), get_resolve_table())\n+}\n+\n+// FIXME #4536: must be pub for testing\n+pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n+\n+// okay, I admit, putting this in TLS is not so nice:\n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+pub fn get_resolve_table() -> @mut ResolveTable {\n+    static resolve_table_key: local_data::Key<@@mut ResolveTable> = &local_data::Key;\n+    match local_data::get(resolve_table_key, |k| k.map(|&k| *k)) {\n+        None => {\n+            let new_table = @@mut HashMap::new();\n+            local_data::set(resolve_table_key,new_table);\n+            *new_table\n+        },\n+        Some(intr) => *intr\n+    }\n }\n \n // Resolve a syntax object to a name, per MTWT.\n+// adding memoization to possibly resolve 500+ seconds in resolve for librustc (!)\n // FIXME #4536 : currently pub to allow testing\n-pub fn resolve_internal(id : Ident, table : &mut SCTable) -> Name {\n-    match table.table[id.ctxt] {\n-        EmptyCtxt => id.name,\n-        // ignore marks here:\n-        Mark(_,subctxt) => resolve_internal(Ident{name:id.name, ctxt: subctxt},table),\n-        // do the rename if necessary:\n-        Rename(Ident{name,ctxt},toname,subctxt) => {\n-            // this could be cached or computed eagerly:\n-            let resolvedfrom = resolve_internal(Ident{name:name,ctxt:ctxt},table);\n-            let resolvedthis = resolve_internal(Ident{name:id.name,ctxt:subctxt},table);\n-            if ((resolvedthis == resolvedfrom)\n-                && (marksof(ctxt,resolvedthis,table)\n-                    == marksof(subctxt,resolvedthis,table))) {\n-                toname\n-            } else {\n-                resolvedthis\n-            }\n+pub fn resolve_internal(id : Ident,\n+                        table : &mut SCTable,\n+                        resolve_table : &mut ResolveTable) -> Name {\n+    let key = (id.name,id.ctxt);\n+    match resolve_table.contains_key(&key) {\n+        false => {\n+            let resolved = {\n+                match table.table[id.ctxt] {\n+                    EmptyCtxt => id.name,\n+                    // ignore marks here:\n+                    Mark(_,subctxt) =>\n+                        resolve_internal(Ident{name:id.name, ctxt: subctxt},table,resolve_table),\n+                    // do the rename if necessary:\n+                    Rename(Ident{name,ctxt},toname,subctxt) => {\n+                        let resolvedfrom =\n+                            resolve_internal(Ident{name:name,ctxt:ctxt},table,resolve_table);\n+                        let resolvedthis =\n+                            resolve_internal(Ident{name:id.name,ctxt:subctxt},table,resolve_table);\n+                        if ((resolvedthis == resolvedfrom)\n+                            && (marksof(ctxt,resolvedthis,table)\n+                                == marksof(subctxt,resolvedthis,table))) {\n+                            toname\n+                        } else {\n+                            resolvedthis\n+                        }\n+                    }\n+                    IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n+                }\n+            };\n+            resolve_table.insert(key,resolved);\n+            resolved\n+        }\n+        true => {\n+            // it's guaranteed to be there, because we just checked that it was\n+            // there and we never remove anything from the table:\n+            *(resolve_table.find(&key).unwrap())\n         }\n-        IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n /// Compute the marks associated with a syntax context.\n+pub fn mtwt_marksof(ctxt: SyntaxContext, stopname: Name) -> ~[Mrk] {\n+    marksof(ctxt, stopname, get_sctable())\n+}\n+\n+// the internal function for computing marks\n // it's not clear to me whether it's better to use a [] mutable\n // vector or a cons-list for this.\n pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n@@ -970,6 +1019,16 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n     }\n }\n \n+/// Return the outer mark for a context with a mark at the outside.\n+/// FAILS when outside is not a mark.\n+pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n+    let sctable = get_sctable();\n+    match sctable.table[ctxt] {\n+        ast::Mark(mrk,_) => mrk,\n+        _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n+    }\n+}\n+\n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n pub fn xorPush(marks: &mut ~[uint], mark: uint) {\n@@ -986,12 +1045,55 @@ pub fn getLast(arr: &~[Mrk]) -> uint {\n     *arr.last()\n }\n \n+// are two paths equal when compared unhygienically?\n+// since I'm using this to replace ==, it seems appropriate\n+// to compare the span, global, etc. fields as well.\n+pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n+    (a.span == b.span)\n+    && (a.global == b.global)\n+    && (segments_name_eq(a.segments, b.segments))\n+}\n+\n+// are two arrays of segments equal when compared unhygienically?\n+pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> bool {\n+    if (a.len() != b.len()) {\n+        false\n+    } else {\n+        for (idx,seg) in a.iter().enumerate() {\n+            if (seg.identifier.name != b[idx].identifier.name)\n+                // FIXME #7743: ident -> name problems in lifetime comparison?\n+                || (seg.lifetime != b[idx].lifetime)\n+                // can types contain idents?\n+                || (seg.types != b[idx].types) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+}\n \n #[cfg(test)]\n mod test {\n     use ast::*;\n     use super::*;\n     use std::io;\n+    use opt_vec;\n+    use std::hash::HashMap;\n+\n+    fn ident_to_segment(id : &Ident) -> PathSegment {\n+        PathSegment{identifier:id.clone(), lifetime: None, types: opt_vec::Empty}\n+    }\n+\n+    #[test] fn idents_name_eq_test() {\n+        assert!(segments_name_eq([Ident{name:3,ctxt:4},\n+                                   Ident{name:78,ctxt:82}].map(ident_to_segment),\n+                                 [Ident{name:3,ctxt:104},\n+                                   Ident{name:78,ctxt:182}].map(ident_to_segment)));\n+        assert!(!segments_name_eq([Ident{name:3,ctxt:4},\n+                                    Ident{name:78,ctxt:82}].map(ident_to_segment),\n+                                  [Ident{name:3,ctxt:104},\n+                                    Ident{name:77,ctxt:182}].map(ident_to_segment)));\n+    }\n \n     #[test] fn xorpush_test () {\n         let mut s = ~[];\n@@ -1122,52 +1224,59 @@ mod test {\n     #[test] fn resolve_tests () {\n         let a = 40;\n         let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n         // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t),a);\n+        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,EMPTY_CTXT),51),M(12)],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n         { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t), a);}\n+        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,EMPTY_CTXT),50),\n                                     R(id(a,EMPTY_CTXT),51)],\n                                   EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t), 51); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n         { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n          let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t),51);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n          // mark on the outside doesn't stop rename:\n          let sc = new_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t),51);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t),50);}\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),50);}\n     }\n \n+    #[test] fn mtwt_resolve_test(){\n+        let a = 40;\n+        assert_eq!(mtwt_resolve(id(a,EMPTY_CTXT)),a);\n+    }\n+\n+\n     #[test] fn hashing_tests () {\n         let mut t = new_sctable_internal();\n         assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n@@ -1177,4 +1286,16 @@ mod test {\n         // I'm assuming that the rename table will behave the same....\n     }\n \n+    #[test] fn resolve_table_hashing_tests() {\n+        let mut t = new_sctable_internal();\n+        let mut rt = HashMap::new();\n+        assert_eq!(rt.len(),0);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),1);\n+        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n+        assert_eq!(rt.len(),2);\n+    }\n+\n }"}, {"sha": "3d5d62aeadf1e99a7532ecde6c0c9f4e7395fe1f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 66, "deletions": 49, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -22,8 +22,7 @@ use std::hashmap::HashMap;\n \n // new-style macro! tt code:\n //\n-//    SyntaxExpanderTT, SyntaxExpanderTTItem, MacResult,\n-//    NormalTT, IdentTT\n+//    MacResult, NormalTT, IdentTT\n //\n // also note that ast::mac used to have a bunch of extraneous cases and\n // is now probably a redundant AST node, can be merged with\n@@ -34,33 +33,46 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-pub type ItemDecorator = @fn(@ExtCtxt,\n+// No context arg for an Item Decorator macro, simply because\n+// adding it would require adding a ctxt field to all items.\n+// we could do this if it turns out to be useful.\n+\n+pub type ItemDecoratorFun = @fn(@ExtCtxt,\n                              Span,\n                              @ast::MetaItem,\n                              ~[@ast::item])\n                           -> ~[@ast::item];\n \n-pub struct SyntaxExpanderTT {\n-    expander: SyntaxExpanderTTFun,\n-    span: Option<Span>\n-}\n-\n pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n                                    Span,\n-                                   &[ast::token_tree])\n+                                   &[ast::token_tree],\n+                                   ast::SyntaxContext)\n                                 -> MacResult;\n \n-pub struct SyntaxExpanderTTItem {\n-    expander: SyntaxExpanderTTItemFun,\n-    span: Option<Span>\n-}\n-\n pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n+                                       Span,\n+                                       ast::Ident,\n+                                       ~[ast::token_tree],\n+                                       ast::SyntaxContext)\n+                                    -> MacResult;\n+\n+// oog... in order to make the presentation of builtin_normal_tt_no_ctxt\n+// and builtin_ident_tt_no_ctxt palatable, we need one-off types for\n+// functions that don't consume a ctxt:\n+\n+pub type SyntaxExpanderTTFunNoCtxt = @fn(@ExtCtxt,\n+                                   Span,\n+                                   &[ast::token_tree])\n+                                -> MacResult;\n+\n+pub type SyntaxExpanderTTItemFunNoCtxt = @fn(@ExtCtxt,\n                                        Span,\n                                        ast::Ident,\n                                        ~[ast::token_tree])\n                                     -> MacResult;\n \n+\n+\n pub enum MacResult {\n     MRExpr(@ast::Expr),\n     MRItem(@ast::item),\n@@ -73,10 +85,10 @@ pub enum MacResult {\n pub enum SyntaxExtension {\n \n     // #[auto_encode] and such\n-    ItemDecorator(ItemDecorator),\n+    ItemDecorator(ItemDecoratorFun),\n \n     // Token-tree expanders\n-    NormalTT(SyntaxExpanderTT),\n+    NormalTT(SyntaxExpanderTTFun, Option<Span>),\n \n     // An IdentTT is a macro that has an\n     // identifier in between the name of the\n@@ -86,9 +98,10 @@ pub enum SyntaxExtension {\n \n     // perhaps macro_rules! will lose its odd special identifier argument,\n     // and this can go away also\n-    IdentTT(SyntaxExpanderTTItem),\n+    IdentTT(SyntaxExpanderTTItemFun, Option<Span>),\n }\n \n+\n // The SyntaxEnv is the environment that's threaded through the expansion\n // of macros. It contains bindings for macros, and also a special binding\n // for \" block\" (not a legal identifier) that maps to a BlockInfo\n@@ -120,12 +133,16 @@ type RenameList = ~[(ast::Ident,Name)];\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> @Transformer {\n-        @SE(NormalTT(SyntaxExpanderTT{expander: f, span: None}))\n+    // that ignore their contexts\n+    fn builtin_normal_tt_no_ctxt(f: SyntaxExpanderTTFunNoCtxt) -> @Transformer {\n+        let wrapped_expander : SyntaxExpanderTTFun = |a,b,c,_d|{f(a,b,c)};\n+        @SE(NormalTT(wrapped_expander, None))\n     }\n     // utility function to simplify creating IdentTT syntax extensions\n-    fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> @Transformer {\n-        @SE(IdentTT(SyntaxExpanderTTItem{expander: f, span: None}))\n+    // that ignore their contexts\n+    fn builtin_item_tt_no_ctxt(f: SyntaxExpanderTTItemFunNoCtxt) -> @Transformer {\n+        let wrapped_expander : SyntaxExpanderTTItemFun = |a,b,c,d,_e|{f(a,b,c,d)};\n+        @SE(IdentTT(wrapped_expander, None))\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n@@ -135,83 +152,83 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 pending_renames : @mut ~[]\n                             }));\n     syntax_expanders.insert(intern(&\"macro_rules\"),\n-                            builtin_item_tt(\n-                                ext::tt::macro_rules::add_new_extension));\n+                            @SE(IdentTT(ext::tt::macro_rules::add_new_extension, None)));\n     syntax_expanders.insert(intern(&\"fmt\"),\n-                            builtin_normal_tt(ext::fmt::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"format\"),\n-                            builtin_normal_tt(ext::ifmt::expand_format));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format));\n     syntax_expanders.insert(intern(&\"write\"),\n-                            builtin_normal_tt(ext::ifmt::expand_write));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_write));\n     syntax_expanders.insert(intern(&\"writeln\"),\n-                            builtin_normal_tt(ext::ifmt::expand_writeln));\n+                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n         intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n     syntax_expanders.insert(intern(&\"env\"),\n-                            builtin_normal_tt(ext::env::expand_env));\n+                            builtin_normal_tt_no_ctxt(ext::env::expand_env));\n     syntax_expanders.insert(intern(&\"option_env\"),\n-                            builtin_normal_tt(ext::env::expand_option_env));\n+                            builtin_normal_tt_no_ctxt(ext::env::expand_option_env));\n     syntax_expanders.insert(intern(\"bytes\"),\n-                            builtin_normal_tt(ext::bytes::expand_syntax_ext));\n+                            builtin_normal_tt_no_ctxt(ext::bytes::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"concat_idents\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::concat_idents::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"log_syntax\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(&\"quote_tokens\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_tokens));\n+                            builtin_normal_tt_no_ctxt(\n+                                ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(intern(&\"quote_expr\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_expr));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_expr));\n     syntax_expanders.insert(intern(&\"quote_ty\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_ty));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_ty));\n     syntax_expanders.insert(intern(&\"quote_item\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_item));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_item));\n     syntax_expanders.insert(intern(&\"quote_pat\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_pat));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_pat));\n     syntax_expanders.insert(intern(&\"quote_stmt\"),\n-                       builtin_normal_tt(ext::quote::expand_quote_stmt));\n+                            builtin_normal_tt_no_ctxt(ext::quote::expand_quote_stmt));\n \n     syntax_expanders.insert(intern(&\"line\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_line));\n     syntax_expanders.insert(intern(&\"col\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_col));\n     syntax_expanders.insert(intern(&\"file\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_file));\n     syntax_expanders.insert(intern(&\"stringify\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_stringify));\n     syntax_expanders.insert(intern(&\"include\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include));\n     syntax_expanders.insert(intern(&\"include_str\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include_str));\n     syntax_expanders.insert(intern(&\"include_bin\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_include_bin));\n     syntax_expanders.insert(intern(&\"module_path\"),\n-                            builtin_normal_tt(\n+                            builtin_normal_tt_no_ctxt(\n                                 ext::source_util::expand_mod));\n     syntax_expanders.insert(intern(&\"asm\"),\n-                            builtin_normal_tt(ext::asm::expand_asm));\n+                            builtin_normal_tt_no_ctxt(ext::asm::expand_asm));\n     syntax_expanders.insert(intern(&\"cfg\"),\n-                            builtin_normal_tt(ext::cfg::expand_cfg));\n+                            builtin_normal_tt_no_ctxt(ext::cfg::expand_cfg));\n     syntax_expanders.insert(\n         intern(&\"trace_macros\"),\n-        builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n+        builtin_normal_tt_no_ctxt(ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n "}, {"sha": "cde418ca991fa22d7f2afcbb0bf5ca246ff358bd", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 698, "deletions": 149, "changes": 847, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, NodeId, Expr_, ExprMac, Ident, mac_invoc_tt};\n-use ast::{item_mac, Stmt_, StmtMac, StmtExpr, StmtSemi};\n-use ast::{ILLEGAL_CTXT};\n+use ast::{Block, Crate, NodeId, DeclLocal, Expr_, ExprMac, SyntaxContext};\n+use ast::{Local, Ident, mac_invoc_tt};\n+use ast::{item_mac, Mrk, Stmt_, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{token_tree};\n use ast;\n-use ast_util::{new_rename, new_mark, resolve};\n+use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n@@ -23,7 +24,7 @@ use opt_vec;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token;\n-use parse::token::{ident_to_str, intern};\n+use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n \n@@ -41,8 +42,13 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n             match (*mac).node {\n+                // it would almost certainly be cleaner to pass the whole\n+                // macro invocation in, rather than pulling it apart and\n+                // marking the tts and the ctxt separately. This also goes\n+                // for the other three macro invocation chunks of code\n+                // in this file.\n                 // Token-tree macros:\n-                mac_invoc_tt(ref pth, ref tts) => {\n+                mac_invoc_tt(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n                         cx.span_fatal(\n                             pth.span,\n@@ -58,35 +64,38 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                 pth.span,\n                                 fmt!(\"macro undefined: '%s'\", extnamestr))\n                         }\n-                        Some(@SE(NormalTT(SyntaxExpanderTT{\n-                            expander: exp,\n-                            span: exp_sp\n-                        }))) => {\n+                        Some(@SE(NormalTT(expandfun, exp_span))) => {\n                             cx.bt_push(ExpnInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n                                     name: extnamestr,\n-                                    span: exp_sp,\n+                                    span: exp_span,\n                                 },\n                             });\n-\n-                            let expanded = match exp(cx, mac.span, *tts) {\n-                                MRExpr(e) => e,\n-                                MRAny(expr_maker,_,_) => expr_maker(),\n-                                _ => {\n-                                    cx.span_fatal(\n-                                        pth.span,\n-                                        fmt!(\n-                                            \"non-expr macro in expr pos: %s\",\n-                                            extnamestr\n+                            let fm = fresh_mark();\n+                            // mark before:\n+                            let marked_before = mark_tts(*tts,fm);\n+                            let marked_ctxt = new_mark(fm, ctxt);\n+                            let expanded =\n+                                match expandfun(cx, mac.span, marked_before, marked_ctxt) {\n+                                    MRExpr(e) => e,\n+                                    MRAny(expr_maker,_,_) => expr_maker(),\n+                                    _ => {\n+                                        cx.span_fatal(\n+                                            pth.span,\n+                                            fmt!(\n+                                                \"non-expr macro in expr pos: %s\",\n+                                                extnamestr\n+                                            )\n                                         )\n-                                    )\n-                                }\n-                            };\n+                                    }\n+                                };\n+                            // mark after:\n+                            let marked_after = mark_expr(expanded,fm);\n \n                             //keep going, outside-in\n                             let fully_expanded =\n-                                fld.fold_expr(expanded).node.clone();\n+                                fld.fold_expr(marked_after).node.clone();\n                             cx.bt_pop();\n \n                             (fully_expanded, s)\n@@ -309,7 +318,6 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     ast::_mod { items: new_items, ..module_ }\n }\n \n-\n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n@@ -333,25 +341,16 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    fld: @ast_fold,\n                    orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n                 -> Option<@ast::item> {\n-    // need to do expansion first... it might turn out to be a module.\n-    let maybe_it = match it.node {\n-      ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n-      _ => Some(it)\n-    };\n-    match maybe_it {\n-      Some(it) => {\n-          match it.node {\n-              ast::item_mod(_) | ast::item_foreign_mod(_) => {\n-                  cx.mod_push(it.ident);\n-                  let macro_escape = contains_macro_escape(it.attrs);\n-                  let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n-                  cx.mod_pop();\n-                  result\n-              }\n-              _ => orig(it,fld)\n-          }\n-      }\n-      None => None\n+    match it.node {\n+        ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n+        ast::item_mod(_) | ast::item_foreign_mod(_) => {\n+            cx.mod_push(it.ident);\n+            let macro_escape = contains_macro_escape(it.attrs);\n+            let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n+            cx.mod_pop();\n+            result\n+        },\n+        _ => orig(it,fld)\n     }\n }\n \n@@ -366,21 +365,22 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                        cx: @ExtCtxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n-    let (pth, tts) = match it.node {\n-        item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts), _}) => {\n-            (pth, (*tts).clone())\n+    let (pth, tts, ctxt) = match it.node {\n+        item_mac(codemap::Spanned { node: mac_invoc_tt(ref pth, ref tts, ctxt), _}) => {\n+            (pth, (*tts).clone(), ctxt)\n         }\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n     let extname = &pth.segments[0].identifier;\n     let extnamestr = ident_to_str(extname);\n+    let fm = fresh_mark();\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", extnamestr)),\n \n-        Some(@SE(NormalTT(ref expand))) => {\n-            if it.ident != parse::token::special_idents::invalid {\n+        Some(@SE(NormalTT(expander, span))) => {\n+            if it.ident.name != parse::token::special_idents::invalid.name {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n                                     given '%s'\", extnamestr,\n@@ -390,13 +390,16 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n-                    span: expand.span\n+                    span: span\n                 }\n             });\n-            ((*expand).expander)(cx, it.span, tts)\n+            // mark before expansion:\n+            let marked_before = mark_tts(tts,fm);\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            expander(cx, it.span, marked_before, marked_ctxt)\n         }\n-        Some(@SE(IdentTT(ref expand))) => {\n-            if it.ident == parse::token::special_idents::invalid {\n+        Some(@SE(IdentTT(expander, span))) => {\n+            if it.ident.name == parse::token::special_idents::invalid.name {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n                                    extnamestr));\n@@ -405,21 +408,27 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n                 call_site: it.span,\n                 callee: NameAndSpan {\n                     name: extnamestr,\n-                    span: expand.span\n+                    span: span\n                 }\n             });\n-            ((*expand).expander)(cx, it.span, it.ident, tts)\n+            // mark before expansion:\n+            let marked_tts = mark_tts(tts,fm);\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            expander(cx, it.span, it.ident, marked_tts, marked_ctxt)\n         }\n         _ => cx.span_fatal(\n             it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n     };\n \n     let maybe_it = match expanded {\n-        MRItem(it) => fld.fold_item(it),\n+        MRItem(it) => mark_item(it,fm).chain(|i| {fld.fold_item(i)}),\n         MRExpr(_) => cx.span_fatal(pth.span,\n                                    fmt!(\"expr macro in item position: %s\", extnamestr)),\n-        MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n+        MRAny(_, item_maker, _) => item_maker().chain(|i| {mark_item(i,fm)})\n+                                      .chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n+            // yikes... no idea how to apply the mark to this. I'm afraid\n+            // we're going to have to wait-and-see on this one.\n             insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n             None\n         }\n@@ -454,15 +463,17 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    orig: @fn(&Stmt_, Span, @ast_fold)\n                              -> (Option<Stmt_>, Span))\n                 -> (Option<Stmt_>, Span) {\n-    let (mac, pth, tts, semi) = match *s {\n+    // why the copying here and not in expand_expr?\n+    // looks like classic changed-in-only-one-place\n+    let (mac, pth, tts, semi, ctxt) = match *s {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(ref pth, ref tts) => {\n-                    ((*mac).clone(), pth, (*tts).clone(), semi)\n+                mac_invoc_tt(ref pth, ref tts, ctxt) => {\n+                    ((*mac).clone(), pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n         }\n-        _ => return orig(s, sp, fld)\n+        _ => return expand_non_macro_stmt(*extsbox,s,sp,fld,orig)\n     };\n     if (pth.segments.len() > 1u) {\n         cx.span_fatal(\n@@ -476,13 +487,16 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr)),\n \n-        Some(@SE(NormalTT(\n-            SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n+        Some(@SE(NormalTT(expandfun, exp_span))) => {\n             cx.bt_push(ExpnInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: extnamestr, span: exp_sp }\n+                callee: NameAndSpan { name: extnamestr, span: exp_span }\n             });\n-            let expanded = match exp(cx, mac.span, tts) {\n+            let fm = fresh_mark();\n+            // mark before expansion:\n+            let marked_tts = mark_tts(tts,fm);\n+            let marked_ctxt = new_mark(fm,ctxt);\n+            let expanded = match expandfun(cx, mac.span, marked_tts, marked_ctxt) {\n                 MRExpr(e) =>\n                     @codemap::Spanned { node: StmtExpr(e, cx.next_id()),\n                                     span: e.span},\n@@ -491,9 +505,10 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                     pth.span,\n                     fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n             };\n+            let marked_after = mark_stmt(expanded,fm);\n \n             //keep going, outside-in\n-            let fully_expanded = match fld.fold_stmt(expanded) {\n+            let fully_expanded = match fld.fold_stmt(marked_after) {\n                 Some(stmt) => {\n                     let fully_expanded = &stmt.node;\n                     cx.bt_pop();\n@@ -521,6 +536,73 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n }\n \n+// expand a non-macro stmt. this is essentially the fallthrough for\n+// expand_stmt, above.\n+fn expand_non_macro_stmt (exts: SyntaxEnv,\n+                          s: &Stmt_,\n+                          sp: Span,\n+                          fld: @ast_fold,\n+                          orig: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span))\n+    -> (Option<Stmt_>,Span) {\n+    // is it a let?\n+    match *s {\n+        StmtDecl(@Spanned{node: DeclLocal(ref local), span: stmt_span}, node_id) => {\n+            let block_info = get_block_info(exts);\n+            let pending_renames = block_info.pending_renames;\n+\n+            // take it apart:\n+            let @Local{is_mutbl:is_mutbl,\n+                       ty:_,\n+                       pat:pat,\n+                       init:init,\n+                       id:id,\n+                       span:span\n+                      } = *local;\n+            // types can't be copied automatically because of the owned ptr in ty_tup...\n+            let ty = local.ty.clone();\n+            // expand the pat (it might contain exprs... #:(o)>\n+            let expanded_pat = fld.fold_pat(pat);\n+            // find the pat_idents in the pattern:\n+            // oh dear heaven... this is going to include the enum names, as well....\n+            // ... but that should be okay, as long as the new names are gensyms\n+            // for the old ones.\n+            let idents = @mut ~[];\n+            let name_finder = new_name_finder(idents);\n+            name_finder.visit_pat(expanded_pat,());\n+            // generate fresh names, push them to a new pending list\n+            let new_pending_renames = @mut ~[];\n+            for ident in idents.iter() {\n+                let new_name = fresh_name(ident);\n+                new_pending_renames.push((*ident,new_name));\n+            }\n+            let rename_fld = renames_to_fold(new_pending_renames);\n+            // rewrite the pattern using the new names (the old ones\n+            // have already been applied):\n+            let rewritten_pat = rename_fld.fold_pat(expanded_pat);\n+            // add them to the existing pending renames:\n+            for pr in new_pending_renames.iter() {pending_renames.push(*pr)}\n+            // also, don't forget to expand the init:\n+            let new_init_opt = init.map(|e| fld.fold_expr(*e));\n+            let rewritten_local =\n+                @Local{is_mutbl:is_mutbl,\n+                       ty:ty,\n+                       pat:rewritten_pat,\n+                       init:new_init_opt,\n+                       id:id,\n+                       span:span};\n+            (Some(StmtDecl(@Spanned{node:DeclLocal(rewritten_local),\n+                                     span: stmt_span},node_id)),\n+             sp)\n+        },\n+        _ => {\n+            orig(s, sp, fld)\n+        }\n+    }\n+}\n+\n+// a visitor that extracts the pat_ident paths\n+// from a given thingy and puts them in a mutable\n+// array (passed in to the traversal)\n #[deriving(Clone)]\n struct NewNameFinderContext {\n     ident_accumulator: @mut ~[ast::Ident],\n@@ -664,8 +746,133 @@ impl Visitor<()> for NewNameFinderContext {\n     }\n }\n \n+// a visitor that extracts the paths\n+// from a given thingy and puts them in a mutable\n+// array (passed in to the traversal)\n+#[deriving(Clone)]\n+struct NewPathExprFinderContext {\n+    path_accumulator: @mut ~[ast::Path],\n+}\n+\n+// XXX : YIKES a lot of boilerplate again....\n+impl Visitor<()> for NewPathExprFinderContext {\n+\n+    fn visit_expr(&mut self, expr: @ast::Expr, _: ()) {\n+        match *expr {\n+            ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n+                self.path_accumulator.push(p.clone());\n+                // not calling visit_path, should be fine.\n+            }\n+            _ => visit::walk_expr(self,expr,())\n+        }\n+    }\n+\n+\n+    // XXX: Methods below can become default methods.\n+\n+    fn visit_pat(&mut self, pattern: @ast::Pat, _: ()) {\n+        visit::walk_pat(self,pattern,())\n+    }\n+\n+    fn visit_mod(&mut self, module: &ast::_mod, _: Span, _: NodeId, _: ()) {\n+        visit::walk_mod(self, module, ())\n+    }\n+\n+    fn visit_view_item(&mut self, view_item: &ast::view_item, _: ()) {\n+        visit::walk_view_item(self, view_item, ())\n+    }\n+\n+    fn visit_item(&mut self, item: @ast::item, _: ()) {\n+        visit::walk_item(self, item, ())\n+    }\n+\n+    fn visit_foreign_item(&mut self,\n+                          foreign_item: @ast::foreign_item,\n+                          _: ()) {\n+        visit::walk_foreign_item(self, foreign_item, ())\n+    }\n+\n+    fn visit_local(&mut self, local: @ast::Local, _: ()) {\n+        visit::walk_local(self, local, ())\n+    }\n+\n+    fn visit_block(&mut self, block: &ast::Block, _: ()) {\n+        visit::walk_block(self, block, ())\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: @ast::Stmt, _: ()) {\n+        visit::walk_stmt(self, stmt, ())\n+    }\n+\n+    fn visit_arm(&mut self, arm: &ast::Arm, _: ()) {\n+        visit::walk_arm(self, arm, ())\n+    }\n+\n+    fn visit_decl(&mut self, decl: @ast::Decl, _: ()) {\n+        visit::walk_decl(self, decl, ())\n+    }\n+\n+    fn visit_expr_post(&mut self, _: @ast::Expr, _: ()) {\n+        // Empty!\n+    }\n+\n+    fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n+        visit::walk_ty(self, typ, ())\n+    }\n+\n+    fn visit_generics(&mut self, generics: &ast::Generics, _: ()) {\n+        visit::walk_generics(self, generics, ())\n+    }\n+\n+    fn visit_fn(&mut self,\n+                function_kind: &visit::fn_kind,\n+                function_declaration: &ast::fn_decl,\n+                block: &ast::Block,\n+                span: Span,\n+                node_id: NodeId,\n+                _: ()) {\n+        visit::walk_fn(self,\n+                        function_kind,\n+                        function_declaration,\n+                        block,\n+                        span,\n+                        node_id,\n+                        ())\n+    }\n+\n+    fn visit_ty_method(&mut self, ty_method: &ast::TypeMethod, _: ()) {\n+        visit::walk_ty_method(self, ty_method, ())\n+    }\n+\n+    fn visit_trait_method(&mut self,\n+                          trait_method: &ast::trait_method,\n+                          _: ()) {\n+        visit::walk_trait_method(self, trait_method, ())\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        struct_def: @ast::struct_def,\n+                        ident: Ident,\n+                        generics: &ast::Generics,\n+                        node_id: NodeId,\n+                        _: ()) {\n+        visit::walk_struct_def(self,\n+                                struct_def,\n+                                ident,\n+                                generics,\n+                                node_id,\n+                                ())\n+    }\n+\n+    fn visit_struct_field(&mut self,\n+                          struct_field: @ast::struct_field,\n+                          _: ()) {\n+        visit::walk_struct_field(self, struct_field, ())\n+    }\n+}\n+\n // return a visitor that extracts the pat_ident paths\n-// from a given pattern and puts them in a mutable\n+// from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     let context = @mut NewNameFinderContext {\n@@ -674,16 +881,60 @@ pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     context as @mut Visitor<()>\n }\n \n+// return a visitor that extracts the paths\n+// from a given pattern and puts them in a mutable\n+// array (passed in to the traversal)\n+pub fn new_path_finder(paths: @mut ~[ast::Path]) -> @mut Visitor<()> {\n+    let context = @mut NewPathExprFinderContext {\n+        path_accumulator: paths,\n+    };\n+    context as @mut Visitor<()>\n+}\n+\n+// expand a block. pushes a new exts_frame, then calls expand_block_elts\n pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     _cx: @ExtCtxt,\n                     blk: &Block,\n                     fld: @ast_fold,\n-                    orig: @fn(&Block, @ast_fold) -> Block)\n+                    _orig: @fn(&Block, @ast_fold) -> Block)\n                  -> Block {\n     // see note below about treatment of exts table\n-    with_exts_frame!(extsbox,false,orig(blk,fld))\n+    with_exts_frame!(extsbox,false,\n+                     expand_block_elts(*extsbox, blk, fld))\n+}\n+\n+// expand the elements of a block.\n+pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: @ast_fold) -> Block {\n+    let block_info = get_block_info(exts);\n+    let pending_renames = block_info.pending_renames;\n+    let rename_fld = renames_to_fold(pending_renames);\n+    let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n+    let mut new_stmts = ~[];\n+    for x in b.stmts.iter() {\n+        match fld.fold_stmt(mustbesome(rename_fld.fold_stmt(*x))) {\n+            Some(s) => new_stmts.push(s),\n+            None => ()\n+        }\n+    }\n+    let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(*x)));\n+    Block{\n+        view_items: new_view_items,\n+        stmts: new_stmts,\n+        expr: new_expr,\n+        id: fld.new_id(b.id),\n+        rules: b.rules,\n+        span: b.span,\n+    }\n }\n \n+// rename_fold should never return \"None\".\n+// (basically, just .get() with a better message...)\n+fn mustbesome<T>(val : Option<T>) -> T {\n+    match val {\n+        Some(v) => v,\n+        None => fail!(\"rename_fold returned None\")\n+    }\n+}\n \n // get the (innermost) BlockInfo from an exts stack\n fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n@@ -694,43 +945,14 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     }\n }\n \n-\n-// given a mutable list of renames, return a tree-folder that applies those\n-// renames.\n-fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n-    let afp = default_ast_fold();\n-    let f_pre = @AstFoldFns {\n-        fold_ident: |id,_| {\n-            // the individual elements are memoized... it would\n-            // also be possible to memoize on the whole list at once.\n-            let new_ctxt = renames.iter().fold(id.ctxt,|ctxt,&(from,to)| {\n-                new_rename(from,to,ctxt)\n-            });\n-            ast::Ident{name:id.name,ctxt:new_ctxt}\n-        },\n-        .. *afp\n-    };\n-    make_fold(f_pre)\n-}\n-\n-// perform a bunch of renames\n-fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    match folder.fold_stmt(&stmt) {\n-        Some(s) => s,\n-        None => fail!(fmt!(\"renaming of stmt produced None\"))\n-    }\n-}\n-\n-\n-\n pub fn new_span(cx: @ExtCtxt, sp: Span) -> Span {\n     /* this discards information in the case of macro-defining macros */\n     return Span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n \n // FIXME (#2247): this is a moderately bad kludge to inject some macros into\n-// the default compilation environment. It would be much nicer to use\n-// a mechanism like syntax_quote to ensure hygiene.\n+// the default compilation environment in that it injects strings, rather than\n+// syntax elements.\n \n pub fn std_macros() -> @str {\n     return\n@@ -1179,62 +1401,165 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     return ret;\n }\n \n-// given a function from idents to idents, produce\n-// an ast_fold that applies that function:\n-pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n-    let afp = default_ast_fold();\n-    let f_pre = @AstFoldFns{\n-        fold_ident : |id, _| f(id),\n-        .. *afp\n-    };\n-    make_fold(f_pre)\n+// HYGIENIC CONTEXT EXTENSION:\n+// all of these functions are for walking over\n+// ASTs and making some change to the context of every\n+// element that has one. a CtxtFn is a trait-ified\n+// version of a closure in (SyntaxContext -> SyntaxContext).\n+// the ones defined here include:\n+// Renamer - add a rename to a context\n+// MultiRenamer - add a set of renames to a context\n+// Marker - add a mark to a context\n+// Repainter - replace a context (maybe Replacer would be a better name?)\n+\n+// a function in SyntaxContext -> SyntaxContext\n+pub trait CtxtFn{\n+    fn f(&self, ast::SyntaxContext) -> ast::SyntaxContext;\n }\n \n-// update the ctxts in a path to get a rename node\n-pub fn new_ident_renamer(from: ast::Ident,\n-                      to: ast::Name) ->\n-    @fn(ast::Ident)->ast::Ident {\n-    |id : ast::Ident|\n-    ast::Ident{\n-        name: id.name,\n-        ctxt: new_rename(from,to,id.ctxt)\n+// a renamer adds a rename to the syntax context\n+pub struct Renamer {\n+    from : ast::Ident,\n+    to : ast::Name\n+}\n+\n+impl CtxtFn for Renamer {\n+    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        new_rename(self.from,self.to,ctxt)\n+    }\n+}\n+\n+// a renamer that performs a whole bunch of renames\n+pub struct MultiRenamer {\n+    renames : @mut ~[(ast::Ident,ast::Name)]\n+}\n+\n+impl CtxtFn for MultiRenamer {\n+    fn f(&self, starting_ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        // the individual elements are memoized... it would\n+        // also be possible to memoize on the whole list at once.\n+        self.renames.iter().fold(starting_ctxt,|ctxt,&(from,to)| {\n+            new_rename(from,to,ctxt)\n+        })\n+    }\n+}\n+\n+// a marker adds the given mark to the syntax context\n+pub struct Marker { mark : Mrk }\n+\n+impl CtxtFn for Marker {\n+    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        new_mark(self.mark,ctxt)\n     }\n }\n \n+// a repainter just replaces the given context with the one it's closed over\n+pub struct Repainter { ctxt : SyntaxContext }\n \n-// update the ctxts in a path to get a mark node\n-pub fn new_ident_marker(mark: uint) ->\n-    @fn(ast::Ident)->ast::Ident {\n-    |id : ast::Ident|\n-    ast::Ident{\n-        name: id.name,\n-        ctxt: new_mark(mark,id.ctxt)\n+impl CtxtFn for Repainter {\n+    fn f(&self, _ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n+        self.ctxt\n     }\n }\n \n-// perform resolution (in the MTWT sense) on all of the\n-// idents in the tree. This is the final step in expansion.\n-pub fn new_ident_resolver() ->\n-    @fn(ast::Ident)->ast::Ident {\n-    |id : ast::Ident|\n-    ast::Ident {\n-        name : resolve(id),\n-        ctxt : ILLEGAL_CTXT\n+// given a function from ctxts to ctxts, produce\n+// an ast_fold that applies that function to all ctxts:\n+pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n+    let afp = default_ast_fold();\n+    let fi : @fn(ast::Ident, @ast_fold) -> ast::Ident =\n+        |ast::Ident{name, ctxt}, _| {\n+        ast::Ident{name:name,ctxt:cf.f(ctxt)}\n+    };\n+    let fm : @fn(&ast::mac_, Span, @ast_fold) -> (ast::mac_,Span) =\n+        |m, sp, fld| {\n+        match *m {\n+            mac_invoc_tt(ref path, ref tts, ctxt) =>\n+            (mac_invoc_tt(fld.fold_path(path),\n+                         fold_tts(*tts,fld),\n+                         cf.f(ctxt)),\n+            sp)\n+        }\n+\n+    };\n+    @AstFoldFns{\n+        fold_ident : fi,\n+        fold_mac : fm,\n+        .. *afp\n     }\n }\n \n \n+\n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+// FIXME #4536: currently pub to allow testing\n+pub fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @AstFoldFns {\n+    fun_to_ctxt_folder(@MultiRenamer{renames : renames})\n+}\n+\n+// just a convenience:\n+pub fn new_mark_folder(m : Mrk) -> @AstFoldFns {\n+    fun_to_ctxt_folder(@Marker{mark:m})\n+}\n+\n+pub fn new_rename_folder(from : ast::Ident, to : ast::Name) -> @AstFoldFns {\n+    fun_to_ctxt_folder(@Renamer{from:from,to:to})\n+}\n+\n+// apply a given mark to the given token trees. Used prior to expansion of a macro.\n+fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n+    fold_tts(tts,new_mark_folder(m) as @ast_fold)\n+}\n+\n+// apply a given mark to the given expr. Used following the expansion of a macro.\n+fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n+    new_mark_folder(m).fold_expr(expr)\n+}\n+\n+// apply a given mark to the given stmt. Used following the expansion of a macro.\n+fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n+    new_mark_folder(m).fold_stmt(expr).unwrap()\n+}\n+\n+// apply a given mark to the given item. Used following the expansion of a macro.\n+fn mark_item(expr : @ast::item, m : Mrk) -> Option<@ast::item> {\n+    new_mark_folder(m).fold_item(expr)\n+}\n+\n+// replace all contexts in a given expr with the given mark. Used\n+// for capturing macros\n+pub fn replace_ctxts(expr : @ast::Expr, ctxt : SyntaxContext) -> @ast::Expr {\n+    fun_to_ctxt_folder(@Repainter{ctxt:ctxt}).fold_expr(expr)\n+}\n+\n+// take the mark from the given ctxt (that has a mark at the outside),\n+// and apply it to everything in the token trees, thereby cancelling\n+// that mark.\n+pub fn mtwt_cancel_outer_mark(tts: &[ast::token_tree], ctxt: ast::SyntaxContext)\n+    -> ~[ast::token_tree] {\n+    let outer_mark = mtwt_outer_mark(ctxt);\n+    mark_tts(tts,outer_mark)\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, EMPTY_CTXT};\n+    use ast_util::{get_sctable, mtwt_marksof, mtwt_resolve, new_rename};\n+    use ast_util;\n     use codemap;\n     use codemap::Spanned;\n+    use fold;\n     use parse;\n-    use parse::token::{intern, get_ident_interner};\n+    use parse::token::{fresh_mark, gensym, intern, get_ident_interner, ident_to_str};\n+    use parse::token;\n     use print::pprust;\n-    use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n+    use std;\n+    use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n+    use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n+    use visit;\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -1332,28 +1657,251 @@ mod test {\n         }\n     }\n \n+    #[test] fn cancel_outer_mark_test(){\n+        let invalid_name = token::special_idents::invalid.name;\n+        let ident_str = @\"x\";\n+        let tts = string_to_tts(ident_str);\n+        let fm = fresh_mark();\n+        let marked_once = fold::fold_tts(tts,new_mark_folder(fm) as @fold::ast_fold);\n+        assert_eq!(marked_once.len(),1);\n+        let marked_once_ctxt =\n+            match marked_once[0] {\n+                ast::tt_tok(_,token::IDENT(id,_)) => id.ctxt,\n+                _ => fail!(fmt!(\"unexpected shape for marked tts: %?\",marked_once[0]))\n+            };\n+        assert_eq!(mtwt_marksof(marked_once_ctxt,invalid_name),~[fm]);\n+        let remarked = mtwt_cancel_outer_mark(marked_once,marked_once_ctxt);\n+        assert_eq!(remarked.len(),1);\n+        match remarked[0] {\n+            ast::tt_tok(_,token::IDENT(id,_)) =>\n+            assert_eq!(mtwt_marksof(id.ctxt,invalid_name),~[]),\n+            _ => fail!(fmt!(\"unexpected shape for marked tts: %?\",remarked[0]))\n+        }\n+    }\n+\n     #[test]\n     fn renaming () {\n-        let maybe_item_ast = string_to_item(@\"fn a() -> int { let b = 13; b }\");\n-        let item_ast = match maybe_item_ast {\n-            Some(x) => x,\n-            None => fail!(\"test case fail\")\n-        };\n+        let item_ast = string_to_crate(@\"fn f() -> int { a }\");\n         let a_name = intern(\"a\");\n-        let a2_name = intern(\"a2\");\n-        let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n+        let a2_name = gensym(\"a2\");\n+        let renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n                                         a2_name);\n-        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n-        let resolver = new_ident_resolver();\n-        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).unwrap();\n-        let resolved_as_str = pprust::item_to_str(resolved_ast,\n-                                                  get_ident_interner());\n-        assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");\n+        let renamed_ast = renamer.fold_crate(item_ast);\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), &renamed_ast, ());\n+        match varrefs {\n+            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n+            _ => assert_eq!(0,1)\n+        }\n+\n+        // try a double-rename, with pending_renames.\n+        let a3_name = gensym(\"a3\");\n+        // a context that renames from (\"a\",empty) to \"a2\" :\n+        let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n+        let pending_renames = @mut ~[(ast::Ident::new(a_name),a2_name),\n+                                     (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)];\n+        let double_renamed = renames_to_fold(pending_renames).fold_crate(item_ast);\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), &double_renamed, ());\n+        match varrefs {\n+            @[Path{segments:[ref seg],_}] => assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n+            _ => assert_eq!(0,1)\n+        }\n+    }\n \n+    fn fake_print_crate(crate: @ast::Crate) {\n+        let s = pprust::rust_printer(std::io::stderr(),get_ident_interner());\n+        pprust::print_crate_(s, crate);\n+    }\n \n+    fn expand_crate_str(crate_str: @str) -> @ast::Crate {\n+        let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n+        // the cfg argument actually does matter, here...\n+        expand_crate(ps,~[],crate_ast)\n     }\n \n-    // sigh... it looks like I have two different renaming mechanisms, now...\n+    //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n+        //let expanded_ast = expand_crate_str(crate_str);\n+        // std::io::println(fmt!(\"expanded: %?\\n\",expanded_ast));\n+        //mtwt_resolve_crate(expanded_ast)\n+    //}\n+    //fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n+        //let resolved_ast = expand_and_resolve(crate_str);\n+        //pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n+    //}\n+\n+    #[test] fn macro_tokens_should_match(){\n+        expand_crate_str(@\"macro_rules! m((a)=>(13)) fn main(){m!(a);}\");\n+    }\n+\n+    // renaming tests expand a crate and then check that the bindings match\n+    // the right varrefs. The specification of the test case includes the\n+    // text of the crate, and also an array of arrays.  Each element in the\n+    // outer array corresponds to a binding in the traversal of the AST\n+    // induced by visit.  Each of these arrays contains a list of indexes,\n+    // interpreted as the varrefs in the varref traversal that this binding\n+    // should match.  So, for instance, in a program with two bindings and\n+    // three varrefs, the array ~[~[1,2],~[0]] would indicate that the first\n+    // binding should match the second two varrefs, and the second binding\n+    // should match the first varref.\n+    //\n+    // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n+    // names; differences in marks don't matter any more.\n+    //\n+    // oog... I also want tests that check \"binding-identifier-=?\". That is,\n+    // not just \"do these have the same name\", but \"do they have the same\n+    // name *and* the same marks\"? Understanding this is really pretty painful.\n+    // in principle, you might want to control this boolean on a per-varref basis,\n+    // but that would make things even harder to understand, and might not be\n+    // necessary for thorough testing.\n+    type renaming_test = (&'static str, ~[~[uint]], bool);\n+\n+    #[test]\n+    fn automatic_renaming () {\n+        let tests : ~[renaming_test] =\n+            ~[// b & c should get new names throughout, in the expr too:\n+                (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+                 ~[~[0,1],~[2]], false),\n+                // both x's should be renamed (how is this causing a bug?)\n+                (\"fn main () {let x : int = 13;x;}\",\n+                 ~[~[0]], false),\n+                // the use of b after the + should be renamed, the other one not:\n+                (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n+                 ~[~[1]], false),\n+                // the b before the plus should not be renamed (requires marks)\n+                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n+                 ~[~[1]], false),\n+                // the marks going in and out of letty should cancel, allowing that $x to\n+                // capture the one following the semicolon.\n+                // this was an awesome test case, and caught a *lot* of bugs.\n+                (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n+                  macro_rules! user(($x:ident) => ({letty!($x); $x}))\n+                  fn main() -> int {user!(z)}\",\n+                 ~[~[0]], false),\n+                // FIXME #8062: this test exposes a *potential* bug; our system does\n+                // not behave exactly like MTWT, but I haven't thought of a way that\n+                // this could cause a bug in Rust, yet.\n+                // (\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n+                // ~[~[0]], true)\n+                // FIXME #6994: the next string exposes the bug referred to in issue 6994, so I'm\n+                // commenting it out.\n+                // the z flows into and out of two macros (g & f) along one path, and one\n+                // (just g) along the other, so the result of the whole thing should\n+                // be \"let z_123 = 3; z_123\"\n+                //\"macro_rules! g (($x:ident) =>\n+                //   ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n+                //   fn a(){g!(z)}\"\n+                // create a really evil test case where a $x appears inside a binding of $x\n+                // but *shouldnt* bind because it was inserted by a different macro....\n+            ];\n+        for (idx,s) in tests.iter().enumerate() {\n+            run_renaming_test(s,idx);\n+        }\n+    }\n+\n+    // run one of the renaming tests\n+    fn run_renaming_test(t : &renaming_test, test_idx: uint) {\n+        let invalid_name = token::special_idents::invalid.name;\n+        let (teststr, bound_connections, bound_ident_check) = match *t {\n+            (ref str,ref conns, bic) => (str.to_managed(), conns.clone(), bic)\n+        };\n+        let cr = expand_crate_str(teststr.to_managed());\n+        // find the bindings:\n+        let bindings = @mut ~[];\n+        visit::walk_crate(&mut new_name_finder(bindings),cr,());\n+        // find the varrefs:\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs),cr,());\n+        // must be one check clause for each binding:\n+        assert_eq!(bindings.len(),bound_connections.len());\n+        for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n+            let binding_name = mtwt_resolve(bindings[binding_idx]);\n+            let binding_marks = mtwt_marksof(bindings[binding_idx].ctxt,invalid_name);\n+            // shouldmatch can't name varrefs that don't exist:\n+            assert!((shouldmatch.len() == 0) ||\n+                    (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n+            for (idx,varref) in varrefs.iter().enumerate() {\n+                if shouldmatch.contains(&idx) {\n+                    // it should be a path of length 1, and it should\n+                    // be free-identifier=? or bound-identifier=? to the given binding\n+                    assert_eq!(varref.segments.len(),1);\n+                    let varref_name = mtwt_resolve(varref.segments[0].identifier);\n+                    let varref_marks = mtwt_marksof(varref.segments[0].identifier.ctxt,\n+                                                    invalid_name);\n+                    if (!(varref_name==binding_name)){\n+                        std::io::println(\"uh oh, should match but doesn't:\");\n+                        std::io::println(fmt!(\"varref: %?\",varref));\n+                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        ast_util::display_sctable(get_sctable());\n+                    }\n+                    assert_eq!(varref_name,binding_name);\n+                    if (bound_ident_check) {\n+                        // we're checking bound-identifier=?, and the marks\n+                        // should be the same, too:\n+                        assert_eq!(varref_marks,binding_marks.clone());\n+                    }\n+                } else {\n+                    let fail = (varref.segments.len() == 1)\n+                        && (mtwt_resolve(varref.segments[0].identifier) == binding_name);\n+                    // temp debugging:\n+                    if (fail) {\n+                        println!(\"failure on test {}\",test_idx);\n+                        println!(\"text of test case: \\\"{}\\\"\", teststr);\n+                        println!(\"\");\n+                        println!(\"uh oh, matches but shouldn't:\");\n+                        std::io::println(fmt!(\"varref: %?\",varref));\n+                        // good lord, you can't make a path with 0 segments, can you?\n+                        println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n+                                 varref.segments[0].identifier.name,\n+                                 ident_to_str(&varref.segments[0].identifier));\n+                        std::io::println(fmt!(\"binding: %?\", bindings[binding_idx]));\n+                        ast_util::display_sctable(get_sctable());\n+                    }\n+                    assert!(!fail);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test] fn fmt_in_macro_used_inside_module_macro() {\n+        let crate_str = @\"macro_rules! fmt_wrap(($b:expr)=>(fmt!(\\\"left: %?\\\", $b)))\n+macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n+foo_module!()\n+\";\n+        let cr = expand_crate_str(crate_str);\n+        // find the xx binding\n+        let bindings = @mut ~[];\n+        visit::walk_crate(&mut new_name_finder(bindings), cr, ());\n+        let cxbinds : ~[&ast::Ident] =\n+            bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n+        let cxbind = match cxbinds {\n+            [b] => b,\n+            _ => fail!(\"expected just one binding for ext_cx\")\n+        };\n+        let resolved_binding = mtwt_resolve(*cxbind);\n+        // find all the xx varrefs:\n+        let varrefs = @mut ~[];\n+        visit::walk_crate(&mut new_path_finder(varrefs), cr, ());\n+        // the xx binding should bind all of the xx varrefs:\n+        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n+                                          && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n+                                     }).enumerate() {\n+            if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n+                std::io::println(\"uh oh, xx binding didn't match xx varref:\");\n+                std::io::println(fmt!(\"this is xx varref # %?\",idx));\n+                std::io::println(fmt!(\"binding: %?\",cxbind));\n+                std::io::println(fmt!(\"resolves to: %?\",resolved_binding));\n+                std::io::println(fmt!(\"varref: %?\",v.segments[0].identifier));\n+                std::io::println(fmt!(\"resolves to: %?\",mtwt_resolve(v.segments[0].identifier)));\n+                let table = get_sctable();\n+                std::io::println(\"SC table:\");\n+                for (idx,val) in table.table.iter().enumerate() {\n+                    std::io::println(fmt!(\"%4u : %?\",idx,val));\n+                }\n+            }\n+            assert_eq!(mtwt_resolve(v.segments[0].identifier),resolved_binding);\n+        };\n+    }\n \n     #[test]\n     fn pat_idents(){\n@@ -1363,4 +1911,5 @@ mod test {\n         pat_idents.visit_pat(pat, ());\n         assert_eq!(idents, @mut strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n     }\n+\n }"}, {"sha": "6527b083cc1b6f35bcd88b4989eff7a9ed43595d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -293,45 +293,51 @@ pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: Span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n-    base::MRExpr(expand_wrapper(cx, sp, cx_expr, expr))\n+    let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_expr(cx: @ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n-                                    ~[e_attrs], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_item\",\n+                                    ~[e_attrs], tts);\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: Span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n-                                    ~[e_refutable], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n+                                    ~[e_refutable], tts);\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: Span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n-                                    ~[e_param_colons], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n+                                     ~[e_param_colons], tts);\n+    base::MRExpr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n-    base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n-                                    ~[e_attrs], tts))\n+    let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n+                                    ~[e_attrs], tts);\n+    base::MRExpr(expanded)\n }\n \n fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {"}, {"sha": "aa4183837e3b38d4554fe1b16931f8bdb72e9a7a", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -234,6 +234,15 @@ pub fn parse_or_else(\n     }\n }\n \n+// perform a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n+pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n+    match (t1,t2) {\n+        (&token::IDENT(id1,_),&token::IDENT(id2,_)) =>\n+        id1.name == id2.name,\n+        _ => *t1 == *t2\n+    }\n+}\n+\n pub fn parse(\n     sess: @mut ParseSess,\n     cfg: ast::CrateConfig,\n@@ -297,7 +306,10 @@ pub fn parse(\n                     // the *_t vars are workarounds for the lack of unary move\n                     match ei.sep {\n                       Some(ref t) if idx == len => { // we need a separator\n-                        if tok == (*t) { //pass the separator\n+                        // i'm conflicted about whether this should be hygienic....\n+                        // though in this case, if the separators are never legal\n+                        // idents, it shouldn't matter.\n+                        if token_name_eq(&tok, t) { //pass the separator\n                             let mut ei_t = ei.clone();\n                             ei_t.idx += 1;\n                             next_eis.push(ei_t);\n@@ -343,7 +355,8 @@ pub fn parse(\n                   match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n                   match_tok(ref t) => {\n                     let mut ei_t = ei.clone();\n-                    if (*t) == tok {\n+                    //if (token_name_eq(t,&tok)) {\n+                    if (token::mtwt_token_eq(t,&tok)) {\n                         ei_t.idx += 1;\n                         next_eis.push(ei_t);\n                     }\n@@ -353,7 +366,7 @@ pub fn parse(\n         }\n \n         /* error messages here could be improved with links to orig. rules */\n-        if tok == EOF {\n+        if token_name_eq(&tok, &EOF) {\n             if eof_eis.len() == 1u {\n                 let mut v = ~[];\n                 for dv in eof_eis[0u].matches.mut_iter() {"}, {"sha": "74de8eaa09e0676ceb8d3613f293c7ded9eeb78c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -14,6 +14,7 @@ use ast;\n use codemap::{Span, Spanned, dummy_sp};\n use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n+use ext::expand;\n use ext::tt::macro_parser::{error};\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n@@ -23,11 +24,17 @@ use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_st\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n+// this procedure performs the expansion of the\n+// macro_rules! macro. It parses the RHS and adds\n+// an extension to the current context.\n pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n-                         arg: ~[ast::token_tree])\n+                         arg: ~[ast::token_tree],\n+                         stx_ctxt: ast::SyntaxContext)\n                       -> base::MacResult {\n+    let arg = expand::mtwt_cancel_outer_mark(arg,stx_ctxt);\n+    // Wrap a matcher_ in a spanned to produce a matcher.\n     // these spans won't matter, anyways\n     fn ms(m: matcher_) -> matcher {\n         Spanned {\n@@ -39,6 +46,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n \n+    // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n@@ -144,11 +152,11 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree]) -> MacResult =\n-        |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n+    let exp: @fn(@ExtCtxt, Span, &[ast::token_tree], ctxt: ast::SyntaxContext) -> MacResult =\n+        |cx, sp, arg, _ctxt| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n         name: ident_to_str(&name),\n-        ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n+        ext: NormalTT(exp, Some(sp))\n     });\n }"}, {"sha": "aad992706fd01271e86209eb6f4a77962d3b20f1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 63, "deletions": 33, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -14,6 +14,14 @@ use codemap::{Span, Spanned};\n use parse::token;\n use opt_vec::OptVec;\n \n+// this file defines an ast_fold trait for objects that can perform\n+// a \"fold\" on Rust ASTs. It also contains a structure that implements\n+// that trait, and a \"default_fold\" whose fields contain closures\n+// that perform \"default traversals\", visiting all of the sub-elements\n+// and re-assembling the result. The \"fun_to_ident_folder\" in the\n+// test module provides a simple example of creating a very simple\n+// fold that only looks at identifiers.\n+\n pub trait ast_fold {\n     fn fold_crate(@self, &Crate) -> Crate;\n     fn fold_view_item(@self, &view_item) -> view_item;\n@@ -35,6 +43,7 @@ pub trait ast_fold {\n     fn fold_ident(@self, Ident) -> Ident;\n     fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @Local) -> @Local;\n+    fn fold_mac(@self, &mac) -> mac;\n     fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n     fn new_id(@self, NodeId) -> NodeId;\n     fn new_span(@self, Span) -> Span;\n@@ -64,6 +73,7 @@ pub struct AstFoldFns {\n     fold_ident: @fn(Ident, @ast_fold) -> Ident,\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n+    fold_mac: @fn(&mac_, Span, @ast_fold) -> (mac_, Span),\n     map_exprs: @fn(@fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr],\n     new_id: @fn(NodeId) -> NodeId,\n     new_span: @fn(Span) -> Span\n@@ -112,41 +122,31 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     }\n }\n \n-//used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n-    Spanned {\n-        node: match m.node {\n-            mac_invoc_tt(ref p,ref tts) =>\n-            mac_invoc_tt(fld.fold_path(p),\n-                         fold_tts(*tts,fld))\n-        },\n-        span: fld.new_span(m.span)\n-    }\n-}\n-\n-fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n+// build a new vector of tts by appling the ast_fold's fold_ident to\n+// all of the identifiers in the token trees.\n+pub fn fold_tts(tts : &[token_tree], f : @ast_fold) -> ~[token_tree] {\n     do tts.map |tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n-            tt_tok(span,maybe_fold_ident(tok,fld)),\n+            tt_tok(span,maybe_fold_ident(tok,f)),\n             tt_delim(ref tts) =>\n-            tt_delim(@mut fold_tts(**tts, fld)),\n+            tt_delim(@mut fold_tts(**tts, f)),\n             tt_seq(span, ref pattern, ref sep, is_optional) =>\n             tt_seq(span,\n-                   @mut fold_tts(**pattern, fld),\n-                   sep.map(|tok|maybe_fold_ident(tok,fld)),\n+                   @mut fold_tts(**pattern, f),\n+                   sep.map(|tok|maybe_fold_ident(tok,f)),\n                    is_optional),\n             tt_nonterminal(sp,ref ident) =>\n-            tt_nonterminal(sp,fld.fold_ident(*ident))\n+            tt_nonterminal(sp,f.fold_ident(*ident))\n         }\n     }\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident(t: &token::Token, fld: @ast_fold) -> token::Token {\n+fn maybe_fold_ident(t : &token::Token, f: @ast_fold) -> token::Token {\n     match *t {\n         token::IDENT(id,followed_by_colons) =>\n-        token::IDENT(fld.fold_ident(id),followed_by_colons),\n+        token::IDENT(f.fold_ident(id),followed_by_colons),\n         _ => (*t).clone()\n     }\n }\n@@ -209,6 +209,7 @@ pub fn noop_fold_crate(c: &Crate, fld: @ast_fold) -> Crate {\n }\n \n fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n+    // FIXME #7654: doesn't iterate over idents in a view_item_use\n     return /* FIXME (#2543) */ (*vi).clone();\n }\n \n@@ -323,11 +324,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             )\n         }\n         item_mac(ref m) => {\n-            // FIXME #2888: we might actually want to do something here.\n-            // ... okay, we're doing something. It would probably be nicer\n-            // to add something to the ast_fold trait, but I'll defer\n-            // that work.\n-            item_mac(fold_mac_(m,fld))\n+            item_mac(fld.fold_mac(m))\n         }\n     }\n }\n@@ -396,7 +393,6 @@ pub fn noop_fold_block(b: &Block, fld: @ast_fold) -> Block {\n }\n \n fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n-    let fold_mac = |x| fold_mac_(x, fld);\n     match *s {\n         StmtDecl(d, nid) => {\n             match fld.fold_decl(d) {\n@@ -410,7 +406,7 @@ fn noop_fold_stmt(s: &Stmt_, fld: @ast_fold) -> Option<Stmt_> {\n         StmtSemi(e, nid) => {\n             Some(StmtSemi(fld.fold_expr(e), fld.new_id(nid)))\n         }\n-        StmtMac(ref mac, semi) => Some(StmtMac(fold_mac(mac), semi))\n+        StmtMac(ref mac, semi) => Some(StmtMac(fld.fold_mac(mac), semi))\n     }\n }\n \n@@ -478,6 +474,12 @@ fn noop_fold_decl(d: &Decl_, fld: @ast_fold) -> Option<Decl_> {\n     }\n }\n \n+// lift a function in ast-thingy X fold -> ast-thingy to a function\n+// in (ast-thingy X span X fold) -> (ast-thingy X span). Basically,\n+// carries the span around.\n+// It seems strange to me that the call to new_fold doesn't happen\n+// here but instead in the impl down below.... probably just an\n+// accident?\n pub fn wrap<T>(f: @fn(&T, @ast_fold) -> T)\n             -> @fn(&T, Span, @ast_fold) -> (T, Span) {\n     let result: @fn(&T, Span, @ast_fold) -> (T, Span) = |x, s, fld| {\n@@ -496,8 +498,6 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n     }\n     let fold_field = |x| fold_field_(x, fld);\n \n-    let fold_mac = |x| fold_mac_(x, fld);\n-\n     match *e {\n         ExprVstore(e, v) => {\n             ExprVstore(fld.fold_expr(e), v)\n@@ -544,7 +544,7 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n         ExprDoBody(f) => ExprDoBody(fld.fold_expr(f)),\n         ExprLit(_) => (*e).clone(),\n         ExprCast(expr, ref ty) => {\n-            ExprCast(fld.fold_expr(expr), (*ty).clone())\n+            ExprCast(fld.fold_expr(expr), fld.fold_ty(ty))\n         }\n         ExprAddrOf(m, ohs) => ExprAddrOf(m, fld.fold_expr(ohs)),\n         ExprIf(cond, ref tr, fl) => {\n@@ -629,7 +629,7 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n                 .. (*a).clone()\n             })\n         }\n-        ExprMac(ref mac) => ExprMac(fold_mac(mac)),\n+        ExprMac(ref mac) => ExprMac(fld.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(\n                 fld.fold_path(path),\n@@ -642,7 +642,6 @@ pub fn noop_fold_expr(e: &Expr_, fld: @ast_fold) -> Expr_ {\n }\n \n pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n-    let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n         mt {\n             ty: ~fld.fold_ty(mt.ty),\n@@ -698,7 +697,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             )\n         }\n         ty_typeof(e) => ty_typeof(fld.fold_expr(e)),\n-        ty_mac(ref mac) => ty_mac(fold_mac(mac))\n+        ty_mac(ref mac) => ty_mac(fld.fold_mac(mac))\n     }\n }\n \n@@ -785,6 +784,19 @@ fn noop_fold_local(l: @Local, fld: @ast_fold) -> @Local {\n     }\n }\n \n+// the default macro traversal. visit the path\n+// using fold_path, and the tts using fold_tts,\n+// and the span using new_span\n+fn noop_fold_mac(m: &mac_, fld: @ast_fold) -> mac_ {\n+    match *m {\n+        mac_invoc_tt(ref p,ref tts,ctxt) =>\n+        mac_invoc_tt(fld.fold_path(p),\n+                     fold_tts(*tts,fld),\n+                     ctxt)\n+    }\n+}\n+\n+\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: @fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n@@ -817,6 +829,7 @@ pub fn default_ast_fold() -> ast_fold_fns {\n         fold_ident: noop_fold_ident,\n         fold_path: noop_fold_path,\n         fold_local: noop_fold_local,\n+        fold_mac: wrap(noop_fold_mac),\n         map_exprs: noop_map_exprs,\n         new_id: noop_id,\n         new_span: noop_span,\n@@ -922,6 +935,10 @@ impl ast_fold for AstFoldFns {\n     fn fold_local(@self, x: @Local) -> @Local {\n         (self.fold_local)(x, self as @ast_fold)\n     }\n+    fn fold_mac(@self, x: &mac) -> mac {\n+        let (n, s) = (self.fold_mac)(&x.node, x.span, self as @ast_fold);\n+        Spanned { node: n, span: (self.new_span)(s) }\n+    }\n     fn map_exprs(@self,\n                  f: @fn(@Expr) -> @Expr,\n                  e: &[@Expr])\n@@ -946,6 +963,8 @@ impl AstFoldExtensions for @ast_fold {\n     }\n }\n \n+// brson agrees with me that this function's existence is probably\n+// not a good or useful thing.\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {\n     afp as @ast_fold\n }\n@@ -1018,4 +1037,15 @@ mod test {\n                                     token::get_ident_interner()),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }\n+\n+    // and in cast expressions... this appears to be an existing bug.\n+    #[test] fn ident_transformation_in_types () {\n+        let zz_fold = fun_to_ident_folder(to_zz());\n+        let ast = string_to_crate(@\"fn a() {let z = 13 as int;}\");\n+        assert_pred!(matches_codepattern,\n+                     \"matches_codepattern\",\n+                     pprust::to_str(&zz_fold.fold_crate(ast),fake_print_crate,\n+                                    token::get_ident_interner()),\n+                     ~\"fn zz(){let zz=13 as zz;}\");\n+    }\n }"}, {"sha": "8b11a25f13ce38f655a79598a8a9ac90d8cbab1c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -21,7 +21,7 @@ use ast::{_mod, BiAdd, arg, Arm, Attribute, BindByRef, BindInfer};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n-use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, enum_def, explicit_self};\n+use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, enum_def, explicit_self};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock};\n use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n@@ -1875,7 +1875,7 @@ impl Parser {\n                                                 |p| p.parse_token_tree());\n                 let hi = self.span.hi;\n \n-                return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts));\n+                return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT));\n             } else if *self.token == token::LBRACE {\n                 // This might be a struct literal.\n                 if self.looking_at_record_literal() {\n@@ -3197,14 +3197,14 @@ impl Parser {\n \n             if id == token::special_idents::invalid {\n                 return @spanned(lo, hi, StmtMac(\n-                    spanned(lo, hi, mac_invoc_tt(pth, tts)), false));\n+                    spanned(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT)), false));\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 return @spanned(lo, hi, StmtDecl(\n                     @spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            item_mac(spanned(lo, hi, mac_invoc_tt(pth, tts))),\n+                            item_mac(spanned(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT))),\n                             inherited, ~[/*no attrs*/]))),\n                     self.get_id()));\n             }\n@@ -3518,7 +3518,10 @@ impl Parser {\n     }\n \n     fn is_self_ident(&self) -> bool {\n-        *self.token == token::IDENT(special_idents::self_, false)\n+        match *self.token {\n+          token::IDENT(id, false) => id.name == special_idents::self_.name,\n+          _ => false\n+        }\n     }\n \n     fn expect_self_ident(&self) {\n@@ -4806,7 +4809,7 @@ impl Parser {\n                 _ => self.fatal(\"expected open delimiter\")\n             };\n             // single-variant-enum... :\n-            let m = ast::mac_invoc_tt(pth, tts);\n+            let m = ast::mac_invoc_tt(pth, tts, EMPTY_CTXT);\n             let m: ast::mac = codemap::Spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };"}, {"sha": "6b3a95a14f8e6cb87b13fe05aaaff446b81d838a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 114, "deletions": 55, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -9,17 +9,15 @@\n // except according to those terms.\n \n use ast;\n-use ast::Name;\n+use ast::{Name, Mrk};\n use ast_util;\n use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n+use std::cast;\n use std::char;\n-use std::cmp::Equiv;\n use std::local_data;\n-use std::rand;\n-use std::rand::RngUtil;\n \n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n pub enum binop {\n@@ -309,22 +307,23 @@ pub fn is_bar(t: &Token) -> bool {\n     match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n-\n pub mod special_idents {\n     use ast::Ident;\n \n-    pub static underscore : Ident = Ident { name: 0, ctxt: 0};\n+    pub static underscore : Ident = Ident { name: 0, ctxt: 0}; // apparently unused?\n     pub static anon : Ident = Ident { name: 1, ctxt: 0};\n     pub static invalid : Ident = Ident { name: 2, ctxt: 0}; // ''\n-    pub static unary : Ident = Ident { name: 3, ctxt: 0};\n-    pub static not_fn : Ident = Ident { name: 4, ctxt: 0};\n-    pub static idx_fn : Ident = Ident { name: 5, ctxt: 0};\n-    pub static unary_minus_fn : Ident = Ident { name: 6, ctxt: 0};\n+    pub static unary : Ident = Ident { name: 3, ctxt: 0}; // apparently unused?\n+    pub static not_fn : Ident = Ident { name: 4, ctxt: 0}; // apparently unused?\n+    pub static idx_fn : Ident = Ident { name: 5, ctxt: 0}; // apparently unused?\n+    pub static unary_minus_fn : Ident = Ident { name: 6, ctxt: 0}; // apparently unused?\n     pub static clownshoes_extensions : Ident = Ident { name: 7, ctxt: 0};\n \n     pub static self_ : Ident = Ident { name: 8, ctxt: 0}; // 'self'\n \n     /* for matcher NTs */\n+    // none of these appear to be used, but perhaps references to\n+    // these are artificially fabricated by the macro system....\n     pub static item : Ident = Ident { name: 9, ctxt: 0};\n     pub static block : Ident = Ident { name: 10, ctxt: 0};\n     pub static stmt : Ident = Ident { name: 11, ctxt: 0};\n@@ -336,7 +335,7 @@ pub mod special_idents {\n     pub static tt : Ident = Ident { name: 17, ctxt: 0};\n     pub static matchers : Ident = Ident { name: 18, ctxt: 0};\n \n-    pub static str : Ident = Ident { name: 19, ctxt: 0}; // for the type\n+    pub static str : Ident = Ident { name: 19, ctxt: 0}; // for the type // apparently unused?\n \n     /* outside of libsyntax */\n     pub static arg : Ident = Ident { name: 20, ctxt: 0};\n@@ -349,10 +348,32 @@ pub mod special_idents {\n     pub static statik : Ident = Ident { name: 27, ctxt: 0};\n     pub static clownshoes_foreign_mod: Ident = Ident { name: 28, ctxt: 0};\n     pub static unnamed_field: Ident = Ident { name: 29, ctxt: 0};\n-    pub static c_abi: Ident = Ident { name: 30, ctxt: 0};\n+    pub static c_abi: Ident = Ident { name: 30, ctxt: 0}; // apparently unused?\n     pub static type_self: Ident = Ident { name: 31, ctxt: 0};    // `Self`\n }\n \n+// here are the ones that actually occur in the source. Maybe the rest\n+// should be removed?\n+/*\n+special_idents::anon\n+special_idents::arg\n+special_idents::blk\n+special_idents::clownshoe_abi\n+special_idents::clownshoe_stack_shim\n+special_idents::clownshoes_extensions\n+special_idents::clownshoes_foreign_mod\n+special_idents::descrim\n+special_idents::invalid\n+special_idents::main\n+special_idents::matchers\n+special_idents::opaque\n+special_idents::self_\n+special_idents::statik\n+special_idents::tt\n+special_idents::type_self\n+special_idents::unnamed_field\n+*/\n+\n /**\n  * Maps a token to a record specifying the corresponding binary\n  * operator\n@@ -381,30 +402,8 @@ pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n   }\n }\n \n-pub struct ident_interner {\n-    priv interner: StrInterner,\n-}\n-\n-impl ident_interner {\n-    pub fn intern(&self, val: &str) -> Name {\n-        self.interner.intern(val)\n-    }\n-    pub fn gensym(&self, val: &str) -> Name {\n-        self.interner.gensym(val)\n-    }\n-    pub fn get(&self, idx: Name) -> @str {\n-        self.interner.get(idx)\n-    }\n-    // is this really something that should be exposed?\n-    pub fn len(&self) -> uint {\n-        self.interner.len()\n-    }\n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n-                                                     -> Option<Name> {\n-        self.interner.find_equiv(val)\n-    }\n-}\n-\n+// looks like we can get rid of this completely...\n+pub type ident_interner = StrInterner;\n \n // return a fresh interner, preloaded with special identifiers.\n fn mk_fresh_ident_interner() -> @ident_interner {\n@@ -485,9 +484,7 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n         \"typeof\",             // 67\n     ];\n \n-    @ident_interner {\n-        interner: interner::StrInterner::prefill(init_vec)\n-    }\n+    @interner::StrInterner::prefill(init_vec)\n }\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n@@ -508,7 +505,7 @@ pub fn get_ident_interner() -> @ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @ident_interner {\n-    @ident_interner { interner: interner::StrInterner::new() }\n+    @interner::StrInterner::new()\n }\n \n // maps a string to its interned representation\n@@ -543,18 +540,44 @@ pub fn gensym_ident(str : &str) -> ast::Ident {\n     ast::Ident::new(gensym(str))\n }\n \n+// create a fresh name that maps to the same string as the old one.\n+// note that this guarantees that str_ptr_eq(ident_to_str(src),interner_get(fresh_name(src)));\n+// that is, that the new name and the old one are connected to ptr_eq strings.\n+pub fn fresh_name(src : &ast::Ident) -> Name {\n+    let interner = get_ident_interner();\n+    interner.gensym_copy(src.name)\n+    // following: debug version. Could work in final except that it's incompatible with\n+    // good error messages and uses of struct names in ambiguous could-be-binding\n+    // locations. Also definitely destroys the guarantee given above about ptr_eq.\n+    /*let num = rand::rng().gen_uint_range(0,0xffff);\n+    gensym(fmt!(\"%s_%u\",ident_to_str(src),num))*/\n+}\n+\n+// it looks like there oughta be a str_ptr_eq fn, but no one bothered to implement it?\n+\n+// determine whether two @str values are pointer-equal\n+pub fn str_ptr_eq(a : @str, b : @str) -> bool {\n+    unsafe {\n+        let p : uint = cast::transmute(a);\n+        let q : uint = cast::transmute(b);\n+        let result = p == q;\n+        // got to transmute them back, to make sure the ref count is correct:\n+        let _junk1 : @str = cast::transmute(p);\n+        let _junk2 : @str = cast::transmute(q);\n+        result\n+    }\n+}\n+\n+// return true when two identifiers refer (through the intern table) to the same ptr_eq\n+// string. This is used to compare identifiers in places where hygienic comparison is\n+// not wanted (i.e. not lexical vars).\n+pub fn ident_spelling_eq(a : &ast::Ident, b : &ast::Ident) -> bool {\n+    str_ptr_eq(interner_get(a.name),interner_get(b.name))\n+}\n \n-// create a fresh name. In principle, this is just a\n-// gensym, but for debugging purposes, you'd like the\n-// resulting name to have a suggestive stringify, without\n-// paying the cost of guaranteeing that the name is\n-// truly unique.  I'm going to try to strike a balance\n-// by using a gensym with a name that has a random number\n-// at the end. So, the gensym guarantees the uniqueness,\n-// and the int helps to avoid confusion.\n-pub fn fresh_name(src_name : &str) -> Name {\n-    let num = rand::rng().gen_uint_range(0,0xffff);\n-   gensym(fmt!(\"%s_%u\",src_name,num))\n+// create a fresh mark.\n+pub fn fresh_mark() -> Mrk {\n+    gensym(\"mark\")\n }\n \n /**\n@@ -694,12 +717,48 @@ pub fn is_reserved_keyword(tok: &Token) -> bool {\n     }\n }\n \n+pub fn mtwt_token_eq(t1 : &Token, t2 : &Token) -> bool {\n+    match (t1,t2) {\n+        (&IDENT(id1,_),&IDENT(id2,_)) =>\n+        ast_util::mtwt_resolve(id1) == ast_util::mtwt_resolve(id2),\n+        _ => *t1 == *t2\n+    }\n+}\n+\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n-    #[test] fn t1() {\n-        let a = fresh_name(\"ghi\");\n-        printfln!(\"interned name: %u,\\ntextual name: %s\\n\",\n-                  a, interner_get(a));\n+    use ast;\n+    use ast_util;\n+\n+    fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n+        ast::Ident{name:id.name,ctxt:ast_util::new_mark(m,id.ctxt)}\n     }\n+\n+    #[test] fn mtwt_token_eq_test() {\n+        assert!(mtwt_token_eq(&GT,&GT));\n+        let a = str_to_ident(\"bac\");\n+        let a1 = mark_ident(a,92);\n+        assert!(mtwt_token_eq(&IDENT(a,true),&IDENT(a1,false)));\n+    }\n+\n+\n+    #[test] fn str_ptr_eq_tests(){\n+        let a = @\"abc\";\n+        let b = @\"abc\";\n+        let c = a;\n+        assert!(str_ptr_eq(a,c));\n+        assert!(!str_ptr_eq(a,b));\n+    }\n+\n+    #[test] fn fresh_name_pointer_sharing() {\n+        let ghi = str_to_ident(\"ghi\");\n+        assert_eq!(ident_to_str(&ghi),@\"ghi\");\n+        assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&ghi)))\n+        let fresh = ast::Ident::new(fresh_name(&ghi));\n+        assert_eq!(ident_to_str(&fresh),@\"ghi\");\n+        assert!(str_ptr_eq(ident_to_str(&ghi),ident_to_str(&fresh)));\n+    }\n+\n }"}, {"sha": "f440e0a177110b36a600fb5213262f083b328663", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -619,7 +619,8 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_mac(codemap::Spanned { node: ast::mac_invoc_tt(ref pth, ref tts),\n+      // I think it's reasonable to hide the context here:\n+      ast::item_mac(codemap::Spanned { node: ast::mac_invoc_tt(ref pth, ref tts, _),\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n@@ -1021,7 +1022,8 @@ pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n \n pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n-      ast::mac_invoc_tt(ref pth, ref tts) => {\n+      // I think it's reasonable to hide the ctxt here:\n+      ast::mac_invoc_tt(ref pth, ref tts, _) => {\n         print_path(s, pth, false);\n         word(s.s, \"!\");\n         popen(s);\n@@ -1924,8 +1926,8 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n         match input.pat.node {\n             ast::PatIdent(_, ref path, _) if\n                 path.segments.len() == 1 &&\n-                path.segments[0].identifier ==\n-                    parse::token::special_idents::invalid => {\n+                path.segments[0].identifier.name ==\n+                    parse::token::special_idents::invalid.name => {\n                 // Do nothing.\n             }\n             _ => {"}, {"sha": "2b1e7eaa9b26d592a0fd6dd98e449f8a07d7817d", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -117,6 +117,23 @@ impl StrInterner {\n         new_idx\n     }\n \n+    // I want these gensyms to share name pointers\n+    // with existing entries. This would be automatic,\n+    // except that the existing gensym creates its\n+    // own managed ptr using to_managed. I think that\n+    // adding this utility function is the most\n+    // lightweight way to get what I want, though not\n+    // necessarily the cleanest.\n+\n+    // create a gensym with the same name as an existing\n+    // entry.\n+    pub fn gensym_copy(&self, idx : uint) -> uint {\n+        let new_idx = self.len();\n+        // leave out of map to avoid colliding\n+        self.vect.push(self.vect[idx]);\n+        new_idx\n+    }\n+\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n@@ -144,23 +161,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn i2 () {\n+    fn interner_tests () {\n         let i : Interner<@str> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // different string gets a different #:\n-        assert_eq!(i.intern (@\"cat\"), 1);\n-        assert_eq!(i.intern (@\"cat\"), 1);\n+        assert_eq!(i.intern(@\"cat\"), 1);\n+        assert_eq!(i.intern(@\"cat\"), 1);\n         // dog is still at zero\n-        assert_eq!(i.intern (@\"dog\"), 0);\n+        assert_eq!(i.intern(@\"dog\"), 0);\n         // gensym gets 3\n-        assert_eq!(i.gensym (@\"zebra\" ), 2);\n+        assert_eq!(i.gensym(@\"zebra\" ), 2);\n         // gensym of same string gets new number :\n         assert_eq!(i.gensym (@\"zebra\" ), 3);\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym (@\"dog\"), 4);\n+        assert_eq!(i.gensym(@\"dog\"), 4);\n         assert_eq!(i.get(0), @\"dog\");\n         assert_eq!(i.get(1), @\"cat\");\n         assert_eq!(i.get(2), @\"zebra\");\n@@ -176,4 +193,34 @@ mod tests {\n         assert_eq!(i.get(2), @\"Carol\");\n         assert_eq!(i.intern(@\"Bob\"), 1);\n     }\n+\n+    #[test]\n+    fn string_interner_tests() {\n+        let i : StrInterner = StrInterner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern(\"dog\"), 0);\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (\"dog\"), 0);\n+        // different string gets a different #:\n+        assert_eq!(i.intern(\"cat\"), 1);\n+        assert_eq!(i.intern(\"cat\"), 1);\n+        // dog is still at zero\n+        assert_eq!(i.intern(\"dog\"), 0);\n+        // gensym gets 3\n+        assert_eq!(i.gensym(\"zebra\"), 2);\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym(\"zebra\"), 3);\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym(\"dog\"), 4);\n+        // gensym tests again with gensym_copy:\n+        assert_eq!(i.gensym_copy(2), 5);\n+        assert_eq!(i.get(5), @\"zebra\");\n+        assert_eq!(i.gensym_copy(2), 6);\n+        assert_eq!(i.get(6), @\"zebra\");\n+        assert_eq!(i.get(0), @\"dog\");\n+        assert_eq!(i.get(1), @\"cat\");\n+        assert_eq!(i.get(2), @\"zebra\");\n+        assert_eq!(i.get(3), @\"zebra\");\n+        assert_eq!(i.get(4), @\"dog\");\n+    }\n }"}, {"sha": "23396c06a9a17c68db0201ee533457cb3622a84c", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -22,6 +22,12 @@ pub fn string_to_tts_and_sess (source_str : @str) -> (~[ast::token_tree],@mut Pa\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,@\"bogofile\")),ps)\n }\n \n+// map a string to tts, using a made-up filename:\n+pub fn string_to_tts(source_str : @str) -> ~[ast::token_tree] {\n+    let (tts,_) = string_to_tts_and_sess(source_str);\n+    tts\n+}\n+\n pub fn string_to_parser_and_sess(source_str: @str) -> (Parser,@mut ParseSess) {\n     let ps = new_parse_sess(None);\n     (new_parser_from_source_str(ps,~[],@\"bogofile\",source_str),ps)\n@@ -40,12 +46,19 @@ fn with_error_checking_parse<T>(s: @str, f: &fn(&mut Parser) -> T) -> T {\n     x\n }\n \n+// parse a string, return a crate.\n pub fn string_to_crate (source_str : @str) -> @ast::Crate {\n     do with_error_checking_parse(source_str) |p| {\n         p.parse_crate_mod()\n     }\n }\n \n+// parse a string, return a crate and the ParseSess\n+pub fn string_to_crate_and_sess (source_str : @str) -> (@ast::Crate,@mut ParseSess) {\n+    let (p,ps) = string_to_parser_and_sess(source_str);\n+    (p.parse_crate_mod(),ps)\n+}\n+\n // parse a string, return an expr\n pub fn string_to_expr (source_str : @str) -> @ast::Expr {\n     do with_error_checking_parse(source_str) |p| {\n@@ -60,14 +73,6 @@ pub fn string_to_item (source_str : @str) -> Option<@ast::item> {\n     }\n }\n \n-// parse a string, return an item and the ParseSess\n-pub fn string_to_item_and_sess (source_str : @str) -> (Option<@ast::item>,@mut ParseSess) {\n-    let (p,ps) = string_to_parser_and_sess(source_str);\n-    let io = p.parse_item(~[]);\n-    p.abort_if_errors();\n-    (io,ps)\n-}\n-\n // parse a string, return a stmt\n pub fn string_to_stmt(source_str : @str) -> @ast::Stmt {\n     do with_error_checking_parse(source_str) |p| {"}, {"sha": "5bfef47902ba790ff6ab6db54359e46c9ec8d2e9", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -22,20 +22,20 @@ use std::util;\n use std::vec;\n \n macro_rules! bench (\n-    ($id:ident) => (maybe_run_test(argv, stringify!($id).to_owned(), $id))\n+    ($argv:expr, $id:ident) => (maybe_run_test($argv, stringify!($id).to_owned(), $id))\n )\n \n fn main() {\n     let argv = os::args();\n     let _tests = argv.slice(1, argv.len());\n \n-    bench!(shift_push);\n-    bench!(read_line);\n-    bench!(vec_plus);\n-    bench!(vec_append);\n-    bench!(vec_push_all);\n-    bench!(is_utf8_ascii);\n-    bench!(is_utf8_multibyte);\n+    bench!(argv, shift_push);\n+    bench!(argv, read_line);\n+    bench!(argv, vec_plus);\n+    bench!(argv, vec_append);\n+    bench!(argv, vec_push_all);\n+    bench!(argv, is_utf8_ascii);\n+    bench!(argv, is_utf8_multibyte);\n }\n \n fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {"}, {"sha": "55e15cc02dd392199d741b5b3cdfcc5a1a539c94", "filename": "src/test/run-pass/hygiene-dodging-1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Fhygiene-dodging-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Fhygiene-dodging-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygiene-dodging-1.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod x {\n+    pub fn g() -> uint {14}\n+}\n+\n+fn main(){\n+    // should *not* shadow the module x:\n+    let x = 9;\n+    // use it to avoid warnings:\n+    x+3;\n+    assert_eq!(x::g(),14);\n+}"}, {"sha": "1e29d2e8969c58dda30c9657da3c73ae76faf74b", "filename": "src/test/run-pass/let-var-hygiene.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// shouldn't affect evaluation of $ex:\n+macro_rules! bad_macro (($ex:expr) => ({let _x = 9; $ex}))\n+fn main() {\n+    let _x = 8;\n+    assert_eq!(bad_macro!(_x),8)\n+}"}, {"sha": "60294e6f21e796b6a3259c4aa2a98f7da35bc02f", "filename": "src/test/run-pass/syntax-extension-minor.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/124eb2119c78651cfaaa7a046a101fa2e20f83ca/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-minor.rs?ref=124eb2119c78651cfaaa7a046a101fa2e20f83ca", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test\n+// this now fails (correctly, I claim) because hygiene prevents\n+// the assembled identifier from being a reference to the binding.\n \n pub fn main() {\n     let asdf_fdsa = ~\"<.<\";"}]}