{"sha": "47c1bd1bcc50b25d133f8be3d49825491c1df249", "node_id": "C_kwDOAAsO6NoAKDQ3YzFiZDFiY2M1MGIyNWQxMzNmOGJlM2Q0OTgyNTQ5MWMxZGYyNDk", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-11-18T17:22:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-18T17:22:57Z"}, "message": "Rollup merge of #90750 - camelid:rm-tuple-impls-1, r=jyn514\n\nrustdoc: Replace where-bounded Clean impl with simple function\n\nThis is the first step in removing the Clean impls for tuples. Either way, this\nsignificantly simplifies the code since it reduces the amount of \"trait magic\".\n\n(To clarify, I'm referring to impls like `impl Clean for (A, B)`, not Clean impls\nthat work on tuples in the user's program.)\n\ncc ``@jyn514``", "tree": {"sha": "ed1621486a4fb359124092a583617bbe300a425f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed1621486a4fb359124092a583617bbe300a425f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c1bd1bcc50b25d133f8be3d49825491c1df249", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhlovxCRBK7hj4Ov3rIwAAAeIIAIDQRH01GcZktnemSNjjK61w\nM2P0eMtNkatAozljNKOxKYD7Wm2vJZM1AkXPfc9nRTCL+1asyfxcO+LfM3FB8pYb\nVBirT1wKRTQ14LNhHpxzxssFk+WrIhamuIU0hdAkOpoWfdM8tjIRca9l6ddYLjir\nCnC1DztGBenoDaTbQjLPee/gL322srZOYnnbsdmcMNK0ZOULsVnqtDsz+ig2TT7J\nmTbnsOe/c0R6yux6RcHMMWZbCSqslsrWwYbdozhmYCwt4qnT9K6AUwHPZaLX323/\nn/QkDJv4waIZoSsSjVpY33YyYNSUUFZiMXzMpJTMGi65+RmAep3FP0kgtlMg5L0=\n=VCEn\n-----END PGP SIGNATURE-----\n", "payload": "tree ed1621486a4fb359124092a583617bbe300a425f\nparent 77c985f76564f4d47897b3488f5a609f6a89f3ec\nparent c20ee3e4d6cf00e80544227aee2e682ce52ab03e\nauthor Yuki Okushi <jtitor@2k36.org> 1637256177 +0900\ncommitter GitHub <noreply@github.com> 1637256177 +0900\n\nRollup merge of #90750 - camelid:rm-tuple-impls-1, r=jyn514\n\nrustdoc: Replace where-bounded Clean impl with simple function\n\nThis is the first step in removing the Clean impls for tuples. Either way, this\nsignificantly simplifies the code since it reduces the amount of \"trait magic\".\n\n(To clarify, I'm referring to impls like `impl Clean for (A, B)`, not Clean impls\nthat work on tuples in the user's program.)\n\ncc ``@jyn514``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c1bd1bcc50b25d133f8be3d49825491c1df249", "html_url": "https://github.com/rust-lang/rust/commit/47c1bd1bcc50b25d133f8be3d49825491c1df249", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c1bd1bcc50b25d133f8be3d49825491c1df249/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77c985f76564f4d47897b3488f5a609f6a89f3ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c985f76564f4d47897b3488f5a609f6a89f3ec", "html_url": "https://github.com/rust-lang/rust/commit/77c985f76564f4d47897b3488f5a609f6a89f3ec"}, {"sha": "c20ee3e4d6cf00e80544227aee2e682ce52ab03e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20ee3e4d6cf00e80544227aee2e682ce52ab03e", "html_url": "https://github.com/rust-lang/rust/commit/c20ee3e4d6cf00e80544227aee2e682ce52ab03e"}], "stats": {"total": 51, "additions": 33, "deletions": 18}, "files": [{"sha": "8f21fc5ba7f0e5970d39d8dd32d9bbf1e003850e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47c1bd1bcc50b25d133f8be3d49825491c1df249/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1bd1bcc50b25d133f8be3d49825491c1df249/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=47c1bd1bcc50b25d133f8be3d49825491c1df249", "patch": "@@ -229,6 +229,7 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n     let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n+        // NOTE: generics need to be cleaned before the decl!\n         ((cx.tcx.generics_of(did), predicates).clean(cx), (did, sig).clean(cx))\n     });\n     clean::Function {"}, {"sha": "5ca532198f471fafbdc093b52f2f04fc189024d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/47c1bd1bcc50b25d133f8be3d49825491c1df249/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1bd1bcc50b25d133f8be3d49825491c1df249/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=47c1bd1bcc50b25d133f8be3d49825491c1df249", "patch": "@@ -109,7 +109,10 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n                 };\n \n                 GenericBound::TraitBound(\n-                    PolyTrait { trait_: (trait_ref, &*bindings).clean(cx), generic_params: vec![] },\n+                    PolyTrait {\n+                        trait_: (trait_ref, &bindings[..]).clean(cx),\n+                        generic_params: vec![],\n+                    },\n                     hir::TraitBoundModifier::None,\n                 )\n             }\n@@ -761,8 +764,13 @@ fn clean_fn_or_proc_macro(\n \n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n-        let (generics, decl) =\n-            enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n+        let (generics, decl) = enter_impl_trait(cx, |cx| {\n+            // NOTE: generics must be cleaned before args\n+            let generics = self.1.clean(cx);\n+            let args = (self.0.decl.inputs, self.2).clean(cx);\n+            let decl = clean_fn_decl_with_args(cx, self.0.decl, args);\n+            (generics, decl)\n+        });\n         Function { decl, generics, header: self.0.header }\n     }\n }\n@@ -804,17 +812,12 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n     }\n }\n \n-impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n-where\n-    (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n-{\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n-        FnDecl {\n-            inputs: (self.0.inputs, self.1).clean(cx),\n-            output: self.0.output.clean(cx),\n-            c_variadic: self.0.c_variadic,\n-        }\n-    }\n+fn clean_fn_decl_with_args(\n+    cx: &mut DocContext<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    args: Arguments,\n+) -> FnDecl {\n+    FnDecl { inputs: args, output: decl.output.clean(cx), c_variadic: decl.c_variadic }\n }\n \n impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n@@ -894,7 +897,11 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n-                        (self.generics.clean(cx), (sig.decl, names).clean(cx))\n+                        // NOTE: generics must be cleaned before args\n+                        let generics = self.generics.clean(cx);\n+                        let args = (sig.decl.inputs, names).clean(cx);\n+                        let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n+                        (generics, decl)\n                     });\n                     let mut t = Function { header: sig.header, decl, generics };\n                     if t.header.constness == hir::Constness::Const\n@@ -1727,8 +1734,10 @@ impl Clean<PathSegment> for hir::PathSegment<'_> {\n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n+            // NOTE: generics must be cleaned before args\n             let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n-            let decl = (self.decl, self.param_names).clean(cx);\n+            let args = (self.decl.inputs, self.param_names).clean(cx);\n+            let decl = clean_fn_decl_with_args(cx, self.decl, args);\n             (generic_params, decl)\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n@@ -2029,8 +2038,13 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n             let kind = match item.kind {\n                 hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n                     let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n-                    let (generics, decl) =\n-                        enter_impl_trait(cx, |cx| (generics.clean(cx), (decl, names).clean(cx)));\n+                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n+                        // NOTE: generics must be cleaned before args\n+                        let generics = generics.clean(cx);\n+                        let args = (decl.inputs, names).clean(cx);\n+                        let decl = clean_fn_decl_with_args(cx, decl, args);\n+                        (generics, decl)\n+                    });\n                     ForeignFunctionItem(Function {\n                         decl,\n                         generics,"}]}