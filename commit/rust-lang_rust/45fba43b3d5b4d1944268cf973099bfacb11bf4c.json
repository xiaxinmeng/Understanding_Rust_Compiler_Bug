{"sha": "45fba43b3d5b4d1944268cf973099bfacb11bf4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZmJhNDNiM2Q1YjRkMTk0NDI2OGNmOTczMDk5YmZhY2IxMWJmNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-10T19:48:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-10T19:48:20Z"}, "message": "Auto merge of #48113 - kennytm:rollup, r=kennytm\n\nRollup of 20 pull requests\n\n- Successful merges: #47790, #47835, #47854, #48015, #48047, #48051, #48058, #48059, #48064, #48078, #48080, #48086, #48098, #48101, #48107, #48100, #48085, #48120, #48124, #47547\n- Failed merges:", "tree": {"sha": "60faf17ac0f398109b52b4a99f9094731b7f7bb3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60faf17ac0f398109b52b4a99f9094731b7f7bb3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45fba43b3d5b4d1944268cf973099bfacb11bf4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45fba43b3d5b4d1944268cf973099bfacb11bf4c", "html_url": "https://github.com/rust-lang/rust/commit/45fba43b3d5b4d1944268cf973099bfacb11bf4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45fba43b3d5b4d1944268cf973099bfacb11bf4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39abcc04139a0fd24422f422271849dc91e39a88", "url": "https://api.github.com/repos/rust-lang/rust/commits/39abcc04139a0fd24422f422271849dc91e39a88", "html_url": "https://github.com/rust-lang/rust/commit/39abcc04139a0fd24422f422271849dc91e39a88"}, {"sha": "4a827188cc46d47f75c72dba3a268d5c9f206582", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a827188cc46d47f75c72dba3a268d5c9f206582", "html_url": "https://github.com/rust-lang/rust/commit/4a827188cc46d47f75c72dba3a268d5c9f206582"}], "stats": {"total": 933, "additions": 399, "deletions": 534}, "files": [{"sha": "f153562a5389471c199e6afbcd5d59549a2dd95e", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -151,6 +151,10 @@\n # default.\n #extended = false\n \n+# Installs choosen set of extended tools if enables. By default builds all.\n+# If choosen tool failed to build the installation fails.\n+#tools = [\"cargo\", \"rls\", \"rustfmt\", \"analysis\", \"src\"]\n+\n # Verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n #verbose = 0\n "}, {"sha": "17841e155edf858c8ea7802dd5f5ecbef54b989f", "filename": "src/binaryen", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit 1c9bf65aa0e371b84755a8ddd6e79497fac57171\n+Subproject commit 17841e155edf858c8ea7802dd5f5ecbef54b989f"}, {"sha": "74dd4a6fa01442672ed0955a6d7933da4a35d2b3", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -570,7 +570,7 @@ impl<'a> Builder<'a> {\n         // build scripts in that situation.\n         //\n         // If LLVM support is disabled we need to use the snapshot compiler to compile\n-        // build scripts, as the new compiler doesnt support executables.\n+        // build scripts, as the new compiler doesn't support executables.\n         if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n@@ -600,9 +600,25 @@ impl<'a> Builder<'a> {\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            let cc = self.cc(target);\n-            cargo.env(format!(\"CC_{}\", target), cc)\n-                 .env(\"CC\", cc);\n+            let ccache = self.config.ccache.as_ref();\n+            let ccacheify = |s: &Path| {\n+                let ccache = match ccache {\n+                    Some(ref s) => s,\n+                    None => return s.display().to_string(),\n+                };\n+                // FIXME: the cc-rs crate only recognizes the literal strings\n+                // `ccache` and `sccache` when doing caching compilations, so we\n+                // mirror that here. It should probably be fixed upstream to\n+                // accept a new env var or otherwise work with custom ccache\n+                // vars.\n+                match &ccache[..] {\n+                    \"ccache\" | \"sccache\" => format!(\"{} {}\", ccache, s.display()),\n+                    _ => s.display().to_string(),\n+                }\n+            };\n+            let cc = ccacheify(&self.cc(target));\n+            cargo.env(format!(\"CC_{}\", target), &cc)\n+                 .env(\"CC\", &cc);\n \n             let cflags = self.cflags(target).join(\" \");\n             cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n@@ -617,8 +633,9 @@ impl<'a> Builder<'a> {\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                cargo.env(format!(\"CXX_{}\", target), cxx)\n-                     .env(\"CXX\", cxx)\n+                let cxx = ccacheify(&cxx);\n+                cargo.env(format!(\"CXX_{}\", target), &cxx)\n+                     .env(\"CXX\", &cxx)\n                      .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n                      .env(\"CXXFLAGS\", cflags);\n             }"}, {"sha": "4f4fd14ae8cabcc8c1c64635b35214b690c727a3", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -13,7 +13,7 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs::File;\n use std::io::prelude::*;\n@@ -52,6 +52,7 @@ pub struct Config {\n     pub target_config: HashMap<Interned<String>, Target>,\n     pub full_bootstrap: bool,\n     pub extended: bool,\n+    pub tools: Option<HashSet<String>>,\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n@@ -191,6 +192,7 @@ struct Build {\n     python: Option<String>,\n     full_bootstrap: Option<bool>,\n     extended: Option<bool>,\n+    tools: Option<HashSet<String>>,\n     verbose: Option<usize>,\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n@@ -395,6 +397,7 @@ impl Config {\n         set(&mut config.vendor, build.vendor);\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n         set(&mut config.extended, build.extended);\n+        config.tools = build.tools;\n         set(&mut config.verbose, build.verbose);\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);"}, {"sha": "99a3ee4e4c3695f7c82f07601968b33df3c38285", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -144,6 +144,7 @@ def v(*args):\n o(\"full-bootstrap\", \"build.full-bootstrap\", \"build three compilers instead of two\")\n o(\"extended\", \"build.extended\", \"build an extended rust tool set\")\n \n+v(\"tools\", \"build.tools\", \"List of extended tools will be installed\")\n v(\"build\", \"build.build\", \"GNUs ./configure syntax LLVM build triple\")\n v(\"host\", None, \"GNUs ./configure syntax LLVM host triples\")\n v(\"target\", None, \"GNUs ./configure syntax LLVM target triples\")"}, {"sha": "460fb016f16ea82880527704c4af40f8261b4308", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -31,6 +31,7 @@ use channel;\n use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n+use native;\n use tool::{self, Tool};\n use cache::{INTERNER, Interned};\n use time;\n@@ -898,6 +899,12 @@ impl Step for PlainSourceTarball {\n                    .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n                    .arg(\"cargo-vendor\")\n                    .env(\"RUSTC\", &build.initial_rustc);\n+                if let Some(dir) = build.openssl_install_dir(build.config.build) {\n+                    builder.ensure(native::Openssl {\n+                        target: build.config.build,\n+                    });\n+                    cmd.env(\"OPENSSL_DIR\", dir);\n+                }\n                 build.run(&mut cmd);\n             }\n "}, {"sha": "20f7d379a6967a45700f87a4de5d767e609a6b65", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -22,6 +22,7 @@ use dist::{self, pkgname, sanitize_sh, tmpdir};\n \n use builder::{Builder, RunConfig, ShouldRun, Step};\n use cache::Interned;\n+use config::Config;\n \n pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n@@ -144,6 +145,19 @@ macro_rules! install {\n             pub host: Interned<String>,\n         }\n \n+        impl $name {\n+            #[allow(dead_code)]\n+            fn should_build(config: &Config) -> bool {\n+                config.extended && config.tools.as_ref()\n+                    .map_or(true, |t| t.contains($path))\n+            }\n+\n+            #[allow(dead_code)]\n+            fn should_install(builder: &Builder) -> bool {\n+                builder.config.tools.as_ref().map_or(false, |t| t.contains($path))\n+            }\n+        }\n+\n         impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n@@ -185,32 +199,34 @@ install!((self, builder, _config),\n             install_std(builder, self.stage, *target);\n         }\n     };\n-    Cargo, \"cargo\", _config.extended, only_hosts: true, {\n+    Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n         builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n         install_cargo(builder, self.stage, self.target);\n     };\n-    Rls, \"rls\", _config.extended, only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() {\n+    Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n             install_rls(builder, self.stage, self.target);\n         } else {\n             println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n         }\n     };\n-    Rustfmt, \"rustfmt\", _config.extended, only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() {\n+    Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n             install_rustfmt(builder, self.stage, self.target);\n         } else {\n             println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n         }\n     };\n-    Analysis, \"analysis\", _config.extended, only_hosts: false, {\n+    Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n             compiler: builder.compiler(self.stage, self.host),\n             target: self.target\n         });\n         install_analysis(builder, self.stage, self.target);\n     };\n-    Src, \"src\", _config.extended, only_hosts: true, {\n+    Src, \"src\", Self::should_build(_config) , only_hosts: true, {\n         builder.ensure(dist::Src);\n         install_src(builder, self.stage);\n     }, ONLY_BUILD;"}, {"sha": "83c270865c0b75cc0c55c36488aef06fbc501d34", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -666,7 +666,7 @@ impl Build {\n         }\n     }\n \n-    /// Returns the path to the linker for the given target if it needs to be overriden.\n+    /// Returns the path to the linker for the given target if it needs to be overridden.\n     fn linker(&self, target: Interned<String>) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target)\n                                                        .and_then(|c| c.linker.as_ref()) {"}, {"sha": "f6b95f0bf97441200d1dd7b46155704d6e2b1bf2", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -902,7 +902,7 @@ impl Step for Compiletest {\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n+            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n             return;\n         }\n "}, {"sha": "5e405aa72e83d0a39e6b34a24e991dc0780160fe", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -86,7 +86,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-sanitizers \\\n       --enable-profiler \\\n-      --enable-emscripten\n+      --enable-emscripten \\\n+      --build=i686-unknown-linux-gnu\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "e730dd86087fbd62d9b8526a4ff9251b53c89e0a", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -54,7 +54,7 @@ cd usr/src\n # The options, in order, do the following\n # * this is an unprivileged build\n # * output to a predictable location\n-# * disable various uneeded stuff\n+# * disable various unneeded stuff\n MKUNPRIVED=yes TOOLDIR=/x-tools/x86_64-unknown-netbsd \\\n MKSHARE=no MKDOC=no MKHTML=no MKINFO=no MKKMOD=no MKLINT=no MKMAN=no MKNLS=no MKPROFILE=no \\\n hide_output ./build.sh -j10 -m amd64 tools"}, {"sha": "9b2dcac06c3e23235f8997b3c5f2325a6d3382df", "filename": "src/dlmalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit a2b424b600235af58f453577c2da1b0e1de2ffa5\n+Subproject commit 9b2dcac06c3e23235f8997b3c5f2325a6d3382df"}, {"sha": "ec5660820dea91df470dab0b9eb26ef798f20889", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit a645960fe48946153936dd5628df4a90bd837981\n+Subproject commit ec5660820dea91df470dab0b9eb26ef798f20889"}, {"sha": "ad5ddd62c098d5b424151beda574ae7df2154df1", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit fec3182d0b0a3cf8122e192b3270064a5b19be5b\n+Subproject commit ad5ddd62c098d5b424151beda574ae7df2154df1"}, {"sha": "254df654a9b75abf6ca08806535dbe1fad41be3f", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit e6a5d5d10aa2fde0baed7b29bf672bd9f3af8962\n+Subproject commit 254df654a9b75abf6ca08806535dbe1fad41be3f"}, {"sha": "919980be7df4ea7d45a9dca8efc34da89bcf7d6b", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1 +1 @@\n-Subproject commit 4ebb8169dfe569b3dcbeab560607800bb717978a\n+Subproject commit 919980be7df4ea7d45a9dca8efc34da89bcf7d6b"}, {"sha": "a471ccc6f5b48ef3748d8ec6fa840384758033de", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -18,7 +18,7 @@\n     <!-- Upgrade code should be different for each platform -->\n     <?if $(sys.BUILDARCH)=\"x64\" ?>\n         <?if $(env.CFG_ABI)=\"GNU\" ?>\n-            <!-- UpgradeCode shoud stay the same for all MSI versions in channel -->\n+            <!-- UpgradeCode should stay the same for all MSI versions in channel -->\n             <?if $(env.CFG_CHANNEL)=\"stable\" ?>\n                 <?define UpgradeCode=\"B440B077-F8D1-4730-8E1D-D6D37702B4CE\" ?>\n             <?elseif $(env.CFG_CHANNEL)=\"beta\" ?>\n@@ -129,7 +129,7 @@\n \n         <!-- Path of cmd.exe for the shortcut -->\n         <Property Id=\"SHORTCUTTARGET\" Value=\"%windir%\\System32\\cmd.exe\" />\n-        <!-- Microsoft Installer will resolve any Enviroment Variables in the working directory at install time -->\n+        <!-- Microsoft Installer will resolve any Environment Variables in the working directory at install time -->\n         <Property Id=\"SHORTCUTWKDIR\" Value=\"%SystemDrive%\\\" />\n \n         <InstallUISequence>"}, {"sha": "d9f78978a251e078f55d8905f99f1e63b510d66f", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -591,7 +591,7 @@ def parse_args():\n         The X86 architecture is specified as multiple files (for the different\n         instruction sets that x86 supports). To generate the compiler\n         definitions one needs to pass the script a \"platform information file\"\n-        (with the -i flag) next to the files of the different intruction sets.\n+        (with the -i flag) next to the files of the different instruction sets.\n         For example, to generate the X86 compiler-definitions for SSE4.2, just:\n \n         python generator.py --format compiler-defs -i x86/info.json sse42.json"}, {"sha": "e9f5bba2312d823fe2f1d48ad9a3e0972c0482fc", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -41,7 +41,7 @@\n (as a fraction, using the ``fractions`` module).\n \n Given an input string and the corresponding float computed via Rust, simply\n-decode the float into f * 2^k (for intergers f, k) and the ULP.\n+decode the float into f * 2^k (for integers f, k) and the ULP.\n We can now easily compute the error and check if it is within 0.5 ULP as it\n should be. Zero and infinites are handled similarly:\n "}, {"sha": "fd23815fc617a5cb8f77cdc4e95a3d177db97cbb", "filename": "src/libbacktrace/ltmain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -487,7 +487,7 @@ func_mkdir_p ()\n       # While some portion of DIR does not yet exist...\n       while test ! -d \"$my_directory_path\"; do\n         # ...make a list in topmost first order.  Use a colon delimited\n-\t# list incase some portion of path contains whitespace.\n+\t# list in case some portion of path contains whitespace.\n         my_dir_list=\"$my_directory_path:$my_dir_list\"\n \n         # If the last portion added has no slash in it, the list is done"}, {"sha": "ba7f94c079f8a8e3c227093524d8a725b1978ae9", "filename": "src/libbacktrace/macho.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -327,7 +327,7 @@ macho_get_commands (struct backtrace_state *state, int descriptor,\n         goto end;\n       file_header_view_valid = 1;\n \n-      // The endianess of the slice may be different than the fat image\n+      // The endianness of the slice may be different than the fat image\n       switch (*(uint32_t *) file_header_view.data)\n         {\n           case MH_MAGIC:"}, {"sha": "7215bd2a4768460912c424196516df62b97801b1", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -211,7 +211,7 @@ impl From<u8> for char {\n \n /// An error which can be returned when parsing a char.\n #[stable(feature = \"char_from_str\", since = \"1.20.0\")]\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub struct ParseCharError {\n     kind: CharErrorKind,\n }"}, {"sha": "33adb3f49dd0d6de94a7acd26096c659386ab52a", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1431,6 +1431,10 @@ pub trait Iterator {\n     /// Folding is useful whenever you have a collection of something, and want\n     /// to produce a single value from it.\n     ///\n+    /// Note: `fold()`, and similar methods that traverse the entire iterator,\n+    /// may not terminate for infinite iterators, even on traits for which a\n+    /// result is determinable in finite time.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "29b62c901f310822aa215be09d50002d99a3b5ef", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -298,7 +298,21 @@\n //!\n //! This will print the numbers `0` through `4`, each on their own line.\n //!\n+//! Bear in mind that methods on infinite iterators, even those for which a\n+//! result can be determined mathematically in finite time, may not terminate.\n+//! Specifically, methods such as [`min`], which in the general case require\n+//! traversing every element in the iterator, are likely not to return\n+//! successfully for any infinite iterators.\n+//!\n+//! ```no_run\n+//! let ones = std::iter::repeat(1);\n+//! let least = ones.min().unwrap(); // Oh no! An infinite loop!\n+//! // `ones.min()` causes an infinite loop, so we won't reach this point!\n+//! println!(\"The smallest number one is {}.\", least);\n+//! ```\n+//!\n //! [`take`]: trait.Iterator.html#method.take\n+//! [`min`]: trait.Iterator.html#method.min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "cc5cf6523a9e74bce160fd2da89a6b510c9b3a0a", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -327,7 +327,7 @@ macro_rules! debug_assert_ne {\n ///     }\n /// }\n ///\n-/// // The prefered method of quick returning Errors\n+/// // The preferred method of quick returning Errors\n /// fn write_to_file_question() -> Result<(), MyError> {\n ///     let mut file = File::create(\"my_best_friends.txt\")?;\n ///     file.write_all(b\"This is a list of my best friends.\")?;"}, {"sha": "88db019b02f0789fd8175a1b6623a3c5b7b678e4", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -181,7 +181,7 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(message=\"cannot substract `{RHS}` from `{Self}`\",\n+#[rustc_on_unimplemented(message=\"cannot subtract `{RHS}` from `{Self}`\",\n                          label=\"no implementation for `{Self} - {RHS}`\")]\n pub trait Sub<RHS=Self> {\n     /// The resulting type after applying the `-` operator.\n@@ -716,7 +716,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n #[lang = \"sub_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented(message=\"cannot substract-assign `{Rhs}` from `{Self}`\",\n+#[rustc_on_unimplemented(message=\"cannot subtract-assign `{Rhs}` from `{Self}`\",\n                          label=\"no implementation for `{Self} -= {Rhs}`\")]\n pub trait SubAssign<Rhs=Self> {\n     /// Performs the `-=` operation."}, {"sha": "f22862ae701903457c177c9e1737325d8fd22592", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -945,6 +945,7 @@ macro_rules! atomic_int {\n      $stable_debug:meta,\n      $stable_access:meta,\n      $stable_from:meta,\n+     $stable_nand:meta,\n      $s_int_type:expr, $int_ref:expr,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n@@ -1325,6 +1326,29 @@ macro_rules! atomic_int {\n                 unsafe { atomic_and(self.v.get(), val, order) }\n             }\n \n+            /// Bitwise \"nand\" with the current value.\n+            ///\n+            /// Performs a bitwise \"nand\" operation on the current value and the argument `val`, and\n+            /// sets the new value to the result.\n+            ///\n+            /// Returns the previous value.\n+            ///\n+            /// # Examples\n+            ///\n+            /// ```\n+            /// #![feature(atomic_nand)]\n+            ///\n+            /// use std::sync::atomic::{AtomicIsize, Ordering};\n+            ///\n+            /// let foo = AtomicIsize::new(0xf731);\n+            /// assert_eq!(foo.fetch_nand(0x137f, Ordering::SeqCst), 0xf731);\n+            /// assert_eq!(foo.load(Ordering::SeqCst), !(0xf731 & 0x137f));\n+            #[inline]\n+            #[$stable_nand]\n+            pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                unsafe { atomic_nand(self.v.get(), val, order) }\n+            }\n+\n             /// Bitwise \"or\" with the current value.\n             ///\n             /// Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n@@ -1377,6 +1401,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i8\", \"../../../std/primitive.i8.html\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n@@ -1387,6 +1412,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u8\", \"../../../std/primitive.u8.html\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n@@ -1397,6 +1423,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i16\", \"../../../std/primitive.i16.html\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n@@ -1407,6 +1434,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u16\", \"../../../std/primitive.u16.html\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n@@ -1417,6 +1445,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i32\", \"../../../std/primitive.i32.html\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n@@ -1427,6 +1456,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u32\", \"../../../std/primitive.u32.html\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n@@ -1437,6 +1467,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"i64\", \"../../../std/primitive.i64.html\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n@@ -1447,6 +1478,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"u64\", \"../../../std/primitive.u64.html\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n@@ -1457,6 +1489,7 @@ atomic_int!{\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"isize\", \"../../../std/primitive.isize.html\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n@@ -1467,6 +1500,7 @@ atomic_int!{\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n     stable(feature = \"atomic_from\", since = \"1.23.0\"),\n+    unstable(feature = \"atomic_nand\", issue = \"13226\"),\n     \"usize\", \"../../../std/primitive.usize.html\",\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n@@ -1609,6 +1643,18 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     }\n }\n \n+#[inline]\n+unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        SeqCst => intrinsics::atomic_nand(dst, val),\n+        __Nonexhaustive => panic!(\"invalid memory ordering\"),\n+    }\n+}\n+\n #[inline]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}, {"sha": "f634fabe50399ebb595c00b29d57ec273f4cd6d8", "filename": "src/libcore/tests/atomic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fatomic.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -48,6 +48,13 @@ fn uint_and() {\n     assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n }\n \n+#[test]\n+fn uint_nand() {\n+    let x = AtomicUsize::new(0xf731);\n+    assert_eq!(x.fetch_nand(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), !(0xf731 & 0x137f));\n+}\n+\n #[test]\n fn uint_or() {\n     let x = AtomicUsize::new(0xf731);\n@@ -69,6 +76,13 @@ fn int_and() {\n     assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n }\n \n+#[test]\n+fn int_nand() {\n+    let x = AtomicIsize::new(0xf731);\n+    assert_eq!(x.fetch_nand(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), !(0xf731 & 0x137f));\n+}\n+\n #[test]\n fn int_or() {\n     let x = AtomicIsize::new(0xf731);"}, {"sha": "9e90313bc0e9efeb27bb4a04def98ae2968f5194", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -42,6 +42,7 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n+#![feature(atomic_nand)]\n \n extern crate core;\n extern crate test;"}, {"sha": "71519ab21fef99d60ae47e3f55a11b26d3f752d7", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -73,7 +73,7 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The arugment is implied to be located at an index\n+    /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),"}, {"sha": "b804cf7bf5a34d532f4917f7a385610770e2001f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -965,8 +965,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n+            visitor.visit_expr(callee_expression);\n             walk_list!(visitor, visit_expr, arguments);\n-            visitor.visit_expr(callee_expression)\n         }\n         ExprMethodCall(ref segment, _, ref arguments) => {\n             visitor.visit_path_segment(expression.span, segment);"}, {"sha": "a290839425ebe2051947c32eeaf4ae0d23560a39", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -764,8 +764,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     let (closure_span, found) = found_did\n                         .and_then(|did| self.tcx.hir.get_if_local(did))\n-                        .map(|node| self.get_fn_like_arguments(node))\n-                        .unwrap_or((found_span.unwrap(), found));\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        }).unwrap_or((found_span, found));\n \n                     self.report_arg_count_mismatch(span,\n                                                    closure_span,\n@@ -875,7 +877,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n-        found_span: Span,\n+        found_span: Option<Span>,\n         expected_args: Vec<ArgKind>,\n         found_args: Vec<ArgKind>,\n         is_closure: bool,\n@@ -913,48 +915,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n-        err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-        if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-            if fields.len() == expected_args.len() {\n-                let sugg = fields.iter()\n-                    .map(|(name, _)| name.to_owned())\n-                    .collect::<Vec<String>>().join(\", \");\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to take multiple arguments instead of \\\n-                                     a single tuple\",\n-                                    format!(\"|{}|\", sugg));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields.iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>().join(\", \");\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to take multiple arguments instead of \\\n+                                         a single tuple\",\n+                                        format!(\"|{}|\", sugg));\n+                }\n             }\n-        }\n-        if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-            if fields.len() == found_args.len() && is_closure {\n-                let sugg = format!(\n-                    \"|({}){}|\",\n-                    found_args.iter()\n-                        .map(|arg| match arg {\n-                            ArgKind::Arg(name, _) => name.to_owned(),\n-                            _ => \"_\".to_owned(),\n-                        })\n-                        .collect::<Vec<String>>()\n-                        .join(\", \"),\n-                    // add type annotations if available\n-                    if found_args.iter().any(|arg| match arg {\n-                        ArgKind::Arg(_, ty) => ty != \"_\",\n-                        _ => false,\n-                    }) {\n-                        format!(\": ({})\",\n-                                fields.iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \"))\n-                    } else {\n-                        \"\".to_owned()\n-                    },\n-                );\n-                err.span_suggestion(found_span,\n-                                    \"change the closure to accept a tuple instead of individual \\\n-                                     arguments\",\n-                                    sugg);\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args.iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\": ({})\",\n+                                    fields.iter()\n+                                        .map(|(_, ty)| ty.to_owned())\n+                                        .collect::<Vec<String>>()\n+                                        .join(\", \"))\n+                        } else {\n+                            \"\".to_owned()\n+                        },\n+                    );\n+                    err.span_suggestion(found_span,\n+                                        \"change the closure to accept a tuple instead of \\\n+                                         individual arguments\",\n+                                        sugg);\n+                }\n             }\n         }\n "}, {"sha": "6b8bf8df0d33f0832e24aeefc673c946c1276982", "filename": "src/librustc_data_structures/blake2b.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/39abcc04139a0fd24422f422271849dc91e39a88/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39abcc04139a0fd24422f422271849dc91e39a88/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=39abcc04139a0fd24422f422271849dc91e39a88", "patch": "@@ -1,363 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// An implementation of the Blake2b cryptographic hash function.\n-// The implementation closely follows: https://tools.ietf.org/html/rfc7693\n-//\n-// \"BLAKE2 is a cryptographic hash function faster than MD5, SHA-1, SHA-2, and\n-//  SHA-3, yet is at least as secure as the latest standard SHA-3.\"\n-// according to their own website :)\n-//\n-// Indeed this implementation is two to three times as fast as our SHA-256\n-// implementation. If you have the luxury of being able to use crates from\n-// crates.io, you can go there and find still faster implementations.\n-\n-use std::mem;\n-use std::slice;\n-\n-#[repr(C)]\n-struct Blake2bCtx {\n-    b: [u8; 128],\n-    h: [u64; 8],\n-    t: [u64; 2],\n-    c: usize,\n-    outlen: u16,\n-    finalized: bool,\n-\n-    #[cfg(debug_assertions)]\n-    fnv_hash: u64,\n-}\n-\n-#[cfg(debug_assertions)]\n-impl ::std::fmt::Debug for Blake2bCtx {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        write!(fmt, \"{:x}\", self.fnv_hash)\n-    }\n-}\n-\n-#[cfg(not(debug_assertions))]\n-impl ::std::fmt::Debug for Blake2bCtx {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n-        write!(fmt, \"Enable debug_assertions() for more info.\")\n-    }\n-}\n-\n-#[inline(always)]\n-fn b2b_g(v: &mut [u64; 16],\n-         a: usize,\n-         b: usize,\n-         c: usize,\n-         d: usize,\n-         x: u64,\n-         y: u64)\n-{\n-    v[a] = v[a].wrapping_add(v[b]).wrapping_add(x);\n-    v[d] = (v[d] ^ v[a]).rotate_right(32);\n-    v[c] = v[c].wrapping_add(v[d]);\n-    v[b] = (v[b] ^ v[c]).rotate_right(24);\n-    v[a] = v[a].wrapping_add(v[b]).wrapping_add(y);\n-    v[d] = (v[d] ^ v[a]).rotate_right(16);\n-    v[c] = v[c].wrapping_add(v[d]);\n-    v[b] = (v[b] ^ v[c]).rotate_right(63);\n-}\n-\n-// Initialization vector\n-const BLAKE2B_IV: [u64; 8] = [\n-   0x6A09E667F3BCC908, 0xBB67AE8584CAA73B,\n-   0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1,\n-   0x510E527FADE682D1, 0x9B05688C2B3E6C1F,\n-   0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179\n-];\n-\n-fn blake2b_compress(ctx: &mut Blake2bCtx, last: bool) {\n-\n-    const SIGMA: [[usize; 16]; 12] = [\n-        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n-        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ],\n-        [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 ],\n-        [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 ],\n-        [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 ],\n-        [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 ],\n-        [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 ],\n-        [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 ],\n-        [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 ],\n-        [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 ],\n-        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ],\n-        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 ]\n-    ];\n-\n-    let mut v: [u64; 16] = [\n-        ctx.h[0],\n-        ctx.h[1],\n-        ctx.h[2],\n-        ctx.h[3],\n-        ctx.h[4],\n-        ctx.h[5],\n-        ctx.h[6],\n-        ctx.h[7],\n-\n-        BLAKE2B_IV[0],\n-        BLAKE2B_IV[1],\n-        BLAKE2B_IV[2],\n-        BLAKE2B_IV[3],\n-        BLAKE2B_IV[4],\n-        BLAKE2B_IV[5],\n-        BLAKE2B_IV[6],\n-        BLAKE2B_IV[7],\n-    ];\n-\n-    v[12] ^= ctx.t[0]; // low 64 bits of offset\n-    v[13] ^= ctx.t[1]; // high 64 bits\n-    if last {\n-        v[14] = !v[14];\n-    }\n-\n-    {\n-        // Re-interpret the input buffer in the state as an array\n-        // of little-endian u64s, converting them to machine\n-        // endianness. It's OK to modify the buffer in place\n-        // since this is the last time  this data will be accessed\n-        // before it's overwritten.\n-\n-        let m: &mut [u64; 16] = unsafe {\n-            let b: &mut [u8; 128] = &mut ctx.b;\n-            ::std::mem::transmute(b)\n-        };\n-\n-        if cfg!(target_endian = \"big\") {\n-            for word in &mut m[..] {\n-                *word = u64::from_le(*word);\n-            }\n-        }\n-\n-        for i in 0 .. 12 {\n-            b2b_g(&mut v, 0, 4,  8, 12, m[SIGMA[i][ 0]], m[SIGMA[i][ 1]]);\n-            b2b_g(&mut v, 1, 5,  9, 13, m[SIGMA[i][ 2]], m[SIGMA[i][ 3]]);\n-            b2b_g(&mut v, 2, 6, 10, 14, m[SIGMA[i][ 4]], m[SIGMA[i][ 5]]);\n-            b2b_g(&mut v, 3, 7, 11, 15, m[SIGMA[i][ 6]], m[SIGMA[i][ 7]]);\n-            b2b_g(&mut v, 0, 5, 10, 15, m[SIGMA[i][ 8]], m[SIGMA[i][ 9]]);\n-            b2b_g(&mut v, 1, 6, 11, 12, m[SIGMA[i][10]], m[SIGMA[i][11]]);\n-            b2b_g(&mut v, 2, 7,  8, 13, m[SIGMA[i][12]], m[SIGMA[i][13]]);\n-            b2b_g(&mut v, 3, 4,  9, 14, m[SIGMA[i][14]], m[SIGMA[i][15]]);\n-        }\n-    }\n-\n-    for i in 0 .. 8 {\n-        ctx.h[i] ^= v[i] ^ v[i + 8];\n-    }\n-}\n-\n-fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n-    assert!(outlen > 0 && outlen <= 64 && key.len() <= 64);\n-\n-    let mut ctx = Blake2bCtx {\n-        b: [0; 128],\n-        h: BLAKE2B_IV,\n-        t: [0; 2],\n-        c: 0,\n-        outlen: outlen as u16,\n-        finalized: false,\n-\n-        #[cfg(debug_assertions)]\n-        fnv_hash: 0xcbf29ce484222325,\n-    };\n-\n-    ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n-\n-    if key.len() > 0 {\n-       blake2b_update(&mut ctx, key);\n-       ctx.c = ctx.b.len();\n-    }\n-\n-    ctx\n-}\n-\n-fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8]) {\n-    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n-\n-    let mut bytes_to_copy = data.len();\n-    let mut space_in_buffer = ctx.b.len() - ctx.c;\n-\n-    while bytes_to_copy > space_in_buffer {\n-        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], space_in_buffer);\n-\n-        ctx.t[0] = ctx.t[0].wrapping_add(ctx.b.len() as u64);\n-        if ctx.t[0] < (ctx.b.len() as u64) {\n-            ctx.t[1] += 1;\n-        }\n-        blake2b_compress(ctx, false);\n-        ctx.c = 0;\n-\n-        data = &data[space_in_buffer .. ];\n-        bytes_to_copy -= space_in_buffer;\n-        space_in_buffer = ctx.b.len();\n-    }\n-\n-    if bytes_to_copy > 0 {\n-        checked_mem_copy(data, &mut ctx.b[ctx.c .. ], bytes_to_copy);\n-        ctx.c += bytes_to_copy;\n-    }\n-\n-    #[cfg(debug_assertions)]\n-    {\n-        // compute additional FNV hash for simpler to read debug output\n-        const MAGIC_PRIME: u64 = 0x00000100000001b3;\n-\n-        for &byte in data {\n-            ctx.fnv_hash = (ctx.fnv_hash ^ byte as u64).wrapping_mul(MAGIC_PRIME);\n-        }\n-    }\n-}\n-\n-fn blake2b_final(ctx: &mut Blake2bCtx)\n-{\n-    assert!(!ctx.finalized, \"Blake2bCtx already finalized\");\n-\n-    ctx.t[0] = ctx.t[0].wrapping_add(ctx.c as u64);\n-    if ctx.t[0] < ctx.c as u64 {\n-        ctx.t[1] += 1;\n-    }\n-\n-    while ctx.c < 128 {\n-        ctx.b[ctx.c] = 0;\n-        ctx.c += 1;\n-    }\n-\n-    blake2b_compress(ctx, true);\n-\n-    // Modify our buffer to little-endian format as it will be read\n-    // as a byte array. It's OK to modify the buffer in place since\n-    // this is the last time this data will be accessed.\n-    if cfg!(target_endian = \"big\") {\n-        for word in &mut ctx.h {\n-            *word = word.to_le();\n-        }\n-    }\n-\n-    ctx.finalized = true;\n-}\n-\n-#[inline(always)]\n-fn checked_mem_copy<T1, T2>(from: &[T1], to: &mut [T2], byte_count: usize) {\n-    let from_size = from.len() * mem::size_of::<T1>();\n-    let to_size = to.len() * mem::size_of::<T2>();\n-    assert!(from_size >= byte_count);\n-    assert!(to_size >= byte_count);\n-    let from_byte_ptr = from.as_ptr() as * const u8;\n-    let to_byte_ptr = to.as_mut_ptr() as * mut u8;\n-    unsafe {\n-        ::std::ptr::copy_nonoverlapping(from_byte_ptr, to_byte_ptr, byte_count);\n-    }\n-}\n-\n-pub fn blake2b(out: &mut [u8], key: &[u8],  data: &[u8])\n-{\n-    let mut ctx = blake2b_new(out.len(), key);\n-    blake2b_update(&mut ctx, data);\n-    blake2b_final(&mut ctx);\n-    checked_mem_copy(&ctx.h, out, ctx.outlen as usize);\n-}\n-\n-pub struct Blake2bHasher(Blake2bCtx);\n-\n-impl ::std::hash::Hasher for Blake2bHasher {\n-    fn write(&mut self, bytes: &[u8]) {\n-        blake2b_update(&mut self.0, bytes);\n-    }\n-\n-    fn finish(&self) -> u64 {\n-        assert!(self.0.outlen == 8,\n-                \"Hasher initialized with incompatible output length\");\n-        u64::from_le(self.0.h[0])\n-    }\n-}\n-\n-impl Blake2bHasher {\n-    pub fn new(outlen: usize, key: &[u8]) -> Blake2bHasher {\n-        Blake2bHasher(blake2b_new(outlen, key))\n-    }\n-\n-    pub fn finalize(&mut self) -> &[u8] {\n-        if !self.0.finalized {\n-            blake2b_final(&mut self.0);\n-        }\n-        debug_assert!(mem::size_of_val(&self.0.h) >= self.0.outlen as usize);\n-        let raw_ptr = (&self.0.h[..]).as_ptr() as * const u8;\n-        unsafe {\n-            slice::from_raw_parts(raw_ptr, self.0.outlen as usize)\n-        }\n-    }\n-}\n-\n-impl ::std::fmt::Debug for Blake2bHasher {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{:?}\", self.0)\n-    }\n-}\n-\n-#[cfg(test)]\n-fn selftest_seq(out: &mut [u8], seed: u32)\n-{\n-   let mut a: u32 = 0xDEAD4BADu32.wrapping_mul(seed);\n-   let mut b: u32 = 1;\n-\n-   for i in 0 .. out.len() {\n-       let t: u32 = a.wrapping_add(b);\n-       a = b;\n-       b = t;\n-       out[i] = ((t >> 24) & 0xFF) as u8;\n-   }\n-}\n-\n-#[test]\n-fn blake2b_selftest()\n-{\n-    use std::hash::Hasher;\n-\n-    // grand hash of hash results\n-    const BLAKE2B_RES: [u8; 32] = [\n-        0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n-        0x10, 0xF5, 0x06, 0xC6, 0x1E, 0x29, 0xDA, 0x56,\n-        0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E, 0x73,\n-        0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n-    ];\n-\n-    // parameter sets\n-    const B2B_MD_LEN: [usize; 4] = [20, 32, 48, 64];\n-    const B2B_IN_LEN: [usize; 6] = [0, 3, 128, 129, 255, 1024];\n-\n-    let mut data = [0u8; 1024];\n-    let mut md = [0u8; 64];\n-    let mut key = [0u8; 64];\n-\n-    let mut hasher = Blake2bHasher::new(32, &[]);\n-\n-    for i in 0 .. 4 {\n-       let outlen = B2B_MD_LEN[i];\n-       for j in 0 .. 6 {\n-            let inlen = B2B_IN_LEN[j];\n-\n-            selftest_seq(&mut data[.. inlen], inlen as u32); // unkeyed hash\n-            blake2b(&mut md[.. outlen], &[], &data[.. inlen]);\n-            hasher.write(&md[.. outlen]); // hash the hash\n-\n-            selftest_seq(&mut key[0 .. outlen], outlen as u32); // keyed hash\n-            blake2b(&mut md[.. outlen], &key[.. outlen], &data[.. inlen]);\n-            hasher.write(&md[.. outlen]); // hash the hash\n-       }\n-    }\n-\n-    // compute and compare the hash of hashes\n-    let md = hasher.finalize();\n-    for i in 0 .. 32 {\n-        assert_eq!(md[i], BLAKE2B_RES[i]);\n-    }\n-}"}, {"sha": "33d760d0a1482f3d365d830c39ca719a360bbaf6", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -57,7 +57,6 @@ pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n pub mod bitvec;\n-pub mod blake2b;\n pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n@@ -70,7 +69,6 @@ pub mod transitive_relation;\n pub mod unify;\n pub mod fx;\n pub mod tuple_slice;\n-pub mod veccell;\n pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;"}, {"sha": "054eee8829a4a73e0b38599ba2b3b058359b0b63", "filename": "src/librustc_data_structures/veccell/mod.rs", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/39abcc04139a0fd24422f422271849dc91e39a88/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39abcc04139a0fd24422f422271849dc91e39a88/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs?ref=39abcc04139a0fd24422f422271849dc91e39a88", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cell::UnsafeCell;\n-use std::mem;\n-\n-pub struct VecCell<T> {\n-    data: UnsafeCell<Vec<T>>,\n-}\n-\n-impl<T> VecCell<T> {\n-    pub fn with_capacity(capacity: usize) -> VecCell<T> {\n-        VecCell { data: UnsafeCell::new(Vec::with_capacity(capacity)) }\n-    }\n-\n-    #[inline]\n-    pub fn push(&self, data: T) -> usize {\n-        // The logic here, and in `swap` below, is that the `push`\n-        // method on the vector will not recursively access this\n-        // `VecCell`. Therefore, we can temporarily obtain mutable\n-        // access, secure in the knowledge that even if aliases exist\n-        // -- indeed, even if aliases are reachable from within the\n-        // vector -- they will not be used for the duration of this\n-        // particular fn call. (Note that we also are relying on the\n-        // fact that `VecCell` is not `Sync`.)\n-        unsafe {\n-            let v = self.data.get();\n-            (*v).push(data);\n-            (*v).len()\n-        }\n-    }\n-\n-    pub fn swap(&self, mut data: Vec<T>) -> Vec<T> {\n-        unsafe {\n-            let v = self.data.get();\n-            mem::swap(&mut *v, &mut data);\n-        }\n-        data\n-    }\n-}"}, {"sha": "f344624666a6cb482ff38ec857b20909da691258", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -170,6 +170,13 @@ pub fn compile_input(trans: Box<TransCrate>,\n             return Ok(())\n         }\n \n+        if let &Some(ref dir) = outdir {\n+            if fs::create_dir_all(dir).is_err() {\n+                sess.err(\"failed to find or create the directory specified by --out-dir\");\n+                return Err(CompileIncomplete::Stopped);\n+            }\n+        }\n+\n         let arenas = AllArenas::new();\n \n         // Construct the HIR map"}, {"sha": "52b87282180c4c5ad1823b82a9e6a7c41dbf69ab", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -716,6 +716,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     ReifyFnPointer => {\n                         match self.eval_operand(operand)?.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n+                                if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+                                    bug!(\"reifying a fn ptr that requires \\\n+                                          const arguments\");\n+                                }\n                                 let instance = self.resolve(def_id, substs)?;\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n                                 let valty = ValTy {"}, {"sha": "8cb25f449b66711e409e93704526b5dff7b0bd1d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1026,9 +1026,14 @@ fn import_path_to_string(names: &[SpannedIdent],\n         if names.is_empty() {\n             import_directive_subclass_to_string(subclass)\n         } else {\n-            let x = format!(\"{}::{}\",\n-                     names_to_string(names),\n-                     import_directive_subclass_to_string(subclass));\n+            // Note that this code looks a little wonky, it's currently here to\n+            // hopefully help debug #48116, but otherwise isn't intended to\n+            // cause any problems.\n+            let x = format!(\n+                \"{}::{}\",\n+                names_to_string(names),\n+                import_directive_subclass_to_string(subclass),\n+            );\n             assert!(!names.is_empty());\n             assert!(!x.starts_with(\"::\"));\n             return x"}, {"sha": "d470f92b75231de8df503ef557b020cd83605e03", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -714,6 +714,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n+                                if tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+                                    bug!(\"reifying a fn ptr that requires \\\n+                                          const arguments\");\n+                                }\n                                 callee::resolve_and_get_fn(self.cx, def_id, substs)\n                             }\n                             _ => {"}, {"sha": "2e876ec118d576d33ac2d96debc77775969d164e", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -195,6 +195,10 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     mir::CastKind::ReifyFnPointer => {\n                         match operand.layout.ty.sty {\n                             ty::TyFnDef(def_id, substs) => {\n+                                if bx.cx.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+                                    bug!(\"reifying a fn ptr that requires \\\n+                                          const arguments\");\n+                                }\n                                 OperandValue::Immediate(\n                                     callee::resolve_and_get_fn(bx.cx, def_id, substs))\n                             }"}, {"sha": "165b499cc62aaad5a55ad7855f17dd3a13a0c8b6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -4897,13 +4897,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        self.check_rustc_args_require_const(def.def_id(), node_id, span);\n+\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n         self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n         ty_substituted\n     }\n \n+    fn check_rustc_args_require_const(&self,\n+                                      def_id: DefId,\n+                                      node_id: ast::NodeId,\n+                                      span: Span) {\n+        // We're only interested in functions tagged with\n+        // #[rustc_args_required_const], so ignore anything that's not.\n+        if !self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n+            return\n+        }\n+\n+        // If our calling expression is indeed the function itself, we're good!\n+        // If not, generate an error that this can only be called directly.\n+        match self.tcx.hir.get(self.tcx.hir.get_parent_node(node_id)) {\n+            Node::NodeExpr(expr) => {\n+                match expr.node {\n+                    hir::ExprCall(ref callee, ..) => {\n+                        if callee.id == node_id {\n+                            return\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        self.tcx.sess.span_err(span, \"this function can only be invoked \\\n+                                      directly, not through a function pointer\");\n+    }\n+\n     /// Report errors if the provided parameters are too few or too many.\n     fn check_path_parameter_count(&self,\n                                   span: Span,"}, {"sha": "66b5f3b5ea366a1c262b1899edad81a41d7d89c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -1051,6 +1051,10 @@ impl Clean<Attributes> for [ast::Attribute] {\n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n             for link in markdown_links(&dox, cx.render_type) {\n+                // bail early for real links\n+                if link.contains('/') {\n+                    continue;\n+                }\n                 let (def, fragment)  = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) ="}, {"sha": "0eb4f9ba7e581469b0c4d41f843266aa8c66eb50", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -106,7 +106,9 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n                 }\n                 PP::Parenthesized { ref mut output, .. } => {\n                     assert!(output.is_none());\n-                    *output = Some(rhs.clone());\n+                    if *rhs != clean::Type::Tuple(Vec::new()) {\n+                        *output = Some(rhs.clone());\n+                    }\n                 }\n             };\n             true"}, {"sha": "f688be89beebcb6d98805b929941149391f5566a", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -123,25 +123,9 @@\n                 sidebar.appendChild(div);\n             }\n         }\n-        var themeChoices = document.getElementById(\"theme-choices\");\n-        if (themeChoices) {\n-            if (!themesWidth) {\n-                var savedState = themeChoices.style.display;\n-                themeChoices.style.display = 'block';\n-                themesWidth = themeChoices.offsetWidth + 'px';\n-                themeChoices.style.display = savedState;\n-            }\n-            themeChoices.style.position = \"fixed\";\n-            themeChoices.style.width = themesWidth;\n-            themeChoices.style.top = '78px';\n-            themeChoices.style.left = '250px';\n-        }\n-        document.getElementsByTagName(\"body\")[0].style.marginTop = '45px';\n-        var themePicker = document.getElementById(\"theme-picker\");\n-        if (themePicker) {\n-            themePicker.style.position = \"fixed\";\n-            themePicker.style.top = \"50px\";\n-            themePicker.style.left = \"250px\";\n+        var themePicker = document.getElementsByClassName(\"theme-picker\");\n+        if (themePicker && themePicker.length > 0) {\n+            themePicker[0].style.display = \"none\";\n         }\n     }\n \n@@ -157,18 +141,9 @@\n             filler.remove();\n         }\n         document.getElementsByTagName(\"body\")[0].style.marginTop = '';\n-        var themePicker = document.getElementById(\"theme-picker\");\n-        if (themePicker) {\n-            themePicker.style.position = \"absolute\";\n-            themePicker.style.top = null;\n-            themePicker.style.left = null;\n-        }\n-        var themeChoices = document.getElementById(\"theme-choices\");\n-        if (themeChoices) {\n-            themeChoices.style.position = 'absolute';\n-            themeChoices.style.width = null;\n-            themeChoices.style.top = null;\n-            themeChoices.style.left = null;\n+        var themePicker = document.getElementsByClassName(\"theme-picker\");\n+        if (themePicker && themePicker.length > 0) {\n+            themePicker[0].style.display = null;\n         }\n     }\n "}, {"sha": "cd4f2cfa678e641e69a16d0f8c1a57a50300524a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -899,7 +899,7 @@ span.since {\n \t}\n \n \t#main {\n-\t\tmargin-top: 50px;\n+\t\tmargin-top: 45px;\n \t\tpadding: 0;\n \t}\n "}, {"sha": "ae0556320b0efa2ed59aaf2f211ab890f4b7e45d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -984,6 +984,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                  \"wasm_import_memory attribute is currently unstable\",\n                                  cfg_fn!(wasm_import_memory))),\n \n+    (\"rustc_args_required_const\", Whitelisted, Gated(Stability::Unstable,\n+                                 \"rustc_attrs\",\n+                                 \"never will be stable\",\n+                                 cfg_fn!(rustc_attrs))),\n+\n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n     (\"crate_type\", CrateLevel, Ungated),"}, {"sha": "aa63019307b5b0ff920d1e22bd53cd6eeb57106b", "filename": "src/test/compile-fail/rustc-args-required-const2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fcompile-fail%2Frustc-args-required-const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fcompile-fail%2Frustc-args-required-const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-args-required-const2.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(attr_literals, rustc_attrs, const_fn)]\n+\n+#[rustc_args_required_const(0)]\n+fn foo(_a: i32) {\n+}\n+\n+fn main() {\n+    let a = foo; //~ ERROR: this function can only be invoked directly\n+    a(2);\n+}"}, {"sha": "1b30a6a43282f9272a91ec92037f3770c0fbcad4", "filename": "src/test/rustdoc/auxiliary/unit-return.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Frustdoc%2Fauxiliary%2Funit-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Frustdoc%2Fauxiliary%2Funit-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Funit-return.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn f2<F: FnMut(u32) + Clone>(f: F) {}\n+\n+pub fn f3<F: FnMut(u64) -> () + Clone>(f: F) {}"}, {"sha": "757e8979edd4ffa72d1b18062863d3e53805c151", "filename": "src/test/rustdoc/unit-return.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Frustdoc%2Funit-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Frustdoc%2Funit-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funit-return.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:unit-return.rs\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate unit_return;\n+\n+// @has 'foo/fn.f0.html' '//*[@class=\"rust fn\"]' 'F: FnMut(u8) + Clone'\n+pub fn f0<F: FnMut(u8) + Clone>(f: F) {}\n+\n+// @has 'foo/fn.f1.html' '//*[@class=\"rust fn\"]' 'F: FnMut(u16) + Clone'\n+pub fn f1<F: FnMut(u16) -> () + Clone>(f: F) {}\n+\n+// @has 'foo/fn.f2.html' '//*[@class=\"rust fn\"]' 'F: FnMut(u32) + Clone'\n+pub use unit_return::f2;\n+\n+// @has 'foo/fn.f3.html' '//*[@class=\"rust fn\"]' 'F: FnMut(u64) + Clone'\n+pub use unit_return::f3;"}, {"sha": "89739bd591cc8b46dff30b018d85c71f5947dd1d", "filename": "src/test/ui/generator/issue-48048.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    let x = (|_| {},);\n+\n+    || {\n+        let x = x;\n+\n+        x.0({ //~ ERROR borrow may still be in use when generator yields\n+            yield;\n+        });\n+    };\n+}"}, {"sha": "fd1667128ab606c12c0b9d50390524d3ceb395c7", "filename": "src/test/ui/generator/issue-48048.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-48048.stderr?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -0,0 +1,10 @@\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/issue-48048.rs:19:9\n+   |\n+19 |         x.0({ //~ ERROR borrow may still be in use when generator yields\n+   |         ^^^\n+20 |             yield;\n+   |             ----- possible yield occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "3f2cb59b11dee4f189eb36f543fe151c9fec17b2", "filename": "src/test/ui/mismatched_types/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -10,7 +10,7 @@\n \n fn main() {\n     1 + Some(1); //~ ERROR cannot add `std::option::Option<{integer}>` to `{integer}`\n-    2 as usize - Some(1); //~ ERROR cannot substract `std::option::Option<{integer}>` from `usize`\n+    2 as usize - Some(1); //~ ERROR cannot subtract `std::option::Option<{integer}>` from `usize`\n     3 * (); //~ ERROR cannot multiply `()` to `{integer}`\n     4 / \"\"; //~ ERROR cannot divide `{integer}` by `&str`\n     5 < String::new(); //~ ERROR is not satisfied"}, {"sha": "828cf636951edabc6c44fad83f4b5ffe134e7a88", "filename": "src/test/ui/mismatched_types/binops.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -6,10 +6,10 @@ error[E0277]: cannot add `std::option::Option<{integer}>` to `{integer}`\n    |\n    = help: the trait `std::ops::Add<std::option::Option<{integer}>>` is not implemented for `{integer}`\n \n-error[E0277]: cannot substract `std::option::Option<{integer}>` from `usize`\n+error[E0277]: cannot subtract `std::option::Option<{integer}>` from `usize`\n   --> $DIR/binops.rs:13:16\n    |\n-13 |     2 as usize - Some(1); //~ ERROR cannot substract `std::option::Option<{integer}>` from `usize`\n+13 |     2 as usize - Some(1); //~ ERROR cannot subtract `std::option::Option<{integer}>` from `usize`\n    |                ^ no implementation for `usize - std::option::Option<{integer}>`\n    |\n    = help: the trait `std::ops::Sub<std::option::Option<{integer}>>` is not implemented for `usize`"}, {"sha": "34232e81cbdeef0a5a5bff568fc08d9a383850c0", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -36,6 +36,9 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n     //~^ ERROR function is expected to take\n+\n+    let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+    //~^ ERROR function is expected to take\n }\n \n fn foo() {}"}, {"sha": "d2a6d6da814ca1afc29856b384fc2c5c84e4de06", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45fba43b3d5b4d1944268cf973099bfacb11bf4c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=45fba43b3d5b4d1944268cf973099bfacb11bf4c", "patch": "@@ -90,7 +90,7 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-41 | fn foo() {}\n+44 | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n@@ -107,8 +107,14 @@ error[E0593]: function is expected to take a single 2-tuple as argument, but it\n 37 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-42 | fn qux(x: usize, y: usize) {}\n+45 | fn qux(x: usize, y: usize) {}\n    | -------------------------- takes 2 distinct arguments\n \n-error: aborting due to 11 previous errors\n+error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n+  --> $DIR/closure-arg-count.rs:40:41\n+   |\n+40 |     let _it = vec![1, 2, 3].into_iter().map(usize::checked_add);\n+   |                                         ^^^ expected function that takes 1 argument\n+\n+error: aborting due to 12 previous errors\n "}]}