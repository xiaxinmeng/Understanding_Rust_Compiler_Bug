{"sha": "e0684e876954ad5a713e6f985570162cedcae8df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNjg0ZTg3Njk1NGFkNWE3MTNlNmY5ODU1NzAxNjJjZWRjYWU4ZGY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-05T21:16:49Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T01:20:48Z"}, "message": "Fallout", "tree": {"sha": "d6f5720dca6438855b491cf1fb0959c78a38b6c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6f5720dca6438855b491cf1fb0959c78a38b6c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0684e876954ad5a713e6f985570162cedcae8df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0684e876954ad5a713e6f985570162cedcae8df", "html_url": "https://github.com/rust-lang/rust/commit/e0684e876954ad5a713e6f985570162cedcae8df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0684e876954ad5a713e6f985570162cedcae8df/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48f50e1e98691d74427e23e82694f528b3fb4d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/48f50e1e98691d74427e23e82694f528b3fb4d56", "html_url": "https://github.com/rust-lang/rust/commit/48f50e1e98691d74427e23e82694f528b3fb4d56"}], "stats": {"total": 422, "additions": 211, "deletions": 211}, "files": [{"sha": "a574367ccf45f434ef17fa7c98cec29b6582bdea", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -75,14 +75,14 @@ impl<T: Clone> Clone for Box<T> {\n }\n \n #[stable]\n-impl<Sized? T: PartialEq> PartialEq for Box<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for Box<T> {\n     #[inline]\n     fn eq(&self, other: &Box<T>) -> bool { PartialEq::eq(&**self, &**other) }\n     #[inline]\n     fn ne(&self, other: &Box<T>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n+impl<T: ?Sized + PartialOrd> PartialOrd for Box<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Box<T>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n@@ -97,16 +97,16 @@ impl<Sized? T: PartialOrd> PartialOrd for Box<T> {\n     fn gt(&self, other: &Box<T>) -> bool { PartialOrd::gt(&**self, &**other) }\n }\n #[stable]\n-impl<Sized? T: Ord> Ord for Box<T> {\n+impl<T: ?Sized + Ord> Ord for Box<T> {\n     #[inline]\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n \n #[stable]}\n-impl<Sized? T: Eq> Eq for Box<T> {}\n+impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-impl<S: hash::Writer, Sized? T: Hash<S>> Hash<S> for Box<T> {\n+impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -143,7 +143,7 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-impl<Sized? T: fmt::Show> fmt::Show for Box<T> {\n+impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         (**self).fmt(f)\n     }\n@@ -155,13 +155,13 @@ impl fmt::Show for Box<Any> {\n     }\n }\n \n-impl<Sized? T> Deref for Box<T> {\n+impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { &**self }\n }\n \n-impl<Sized? T> DerefMut for Box<T> {\n+impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n "}, {"sha": "43b3f3421403dd92905aa7e6a4942311407107e0", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -130,7 +130,7 @@ pub struct Values<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single entry in a map, which may either be vacant or occupied.\n-pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub enum Entry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     /// A vacant Entry\n     Vacant(VacantEntry<'a, Q, K, V>),\n     /// An occupied Entry\n@@ -139,7 +139,7 @@ pub enum Entry<'a, Sized? Q:'a, K:'a, V:'a> {\n \n #[stable]\n /// A vacant Entry.\n-pub struct VacantEntry<'a, Sized? Q:'a, K:'a, V:'a> {\n+pub struct VacantEntry<'a, Q: ?Sized +'a, K:'a, V:'a> {\n     key: &'a Q,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n@@ -214,7 +214,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where Q: BorrowFrom<K> + Ord {\n         let mut cur_node = &self.root;\n         loop {\n             match Node::search(cur_node, key) {\n@@ -246,7 +246,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool where Q: BorrowFrom<K> + Ord {\n         self.get(key).is_some()\n     }\n \n@@ -270,7 +270,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V> where Q: BorrowFrom<K> + Ord {\n         // temp_node is a Borrowck hack for having a mutable value outlive a loop iteration\n         let mut temp_node = &mut self.root;\n         loop {\n@@ -440,7 +440,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V> where Q: BorrowFrom<K> + Ord {\n         // See `swap` for a more thorough description of the stuff going on in here\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n@@ -880,7 +880,7 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n // NOTE(stage0): remove impl after a snapshot\n #[cfg(stage0)]\n #[stable]\n-impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> Index<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     fn index(&self, key: &Q) -> &V {\n@@ -890,7 +890,7 @@ impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n \n #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[stable]\n-impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -903,7 +903,7 @@ impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n // NOTE(stage0): remove impl after a snapshot\n #[cfg(stage0)]\n #[stable]\n-impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> IndexMut<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     fn index_mut(&mut self, key: &Q) -> &mut V {\n@@ -913,7 +913,7 @@ impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n \n #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[stable]\n-impl<K: Ord, Sized? Q, V> IndexMut<Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> IndexMut<Q> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n {\n     type Output = V;\n@@ -1135,7 +1135,7 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n-impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K: Ord, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1146,7 +1146,7 @@ impl<'a, Sized? Q, K: Ord, V> Entry<'a, Q, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + ToOwned<K>, K: Ord, V> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n@@ -1386,7 +1386,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n     #[stable]\n-    pub fn entry<'a, Sized? Q>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, mut key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Ord + ToOwned<K>\n     {\n         // same basic logic of `swap` and `pop`, blended together"}, {"sha": "0a93bbf89c9971dea74fe7c5fadc95e614f35f06", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -517,7 +517,7 @@ impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n     /// `Found` will be yielded with the matching index. If it doesn't find an exact match,\n     /// `GoDown` will be yielded with the index of the subtree the key must lie in.\n-    pub fn search<Sized? Q, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n+    pub fn search<Q: ?Sized, NodeRef: Deref<Target=Node<K, V>>>(node: NodeRef, key: &Q)\n                   -> SearchResult<NodeRef> where Q: BorrowFrom<K> + Ord {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n@@ -536,7 +536,7 @@ impl<K: Ord, V> Node<K, V> {\n         }\n     }\n \n-    fn search_linear<Sized? Q>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n+    fn search_linear<Q: ?Sized>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n         for (i, k) in self.keys().iter().enumerate() {\n             match key.cmp(BorrowFrom::borrow_from(k)) {\n                 Greater => {},"}, {"sha": "98f163321706041f81f7fb731f81726ba79b1303", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -299,7 +299,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.contains_key(value)\n     }\n \n@@ -429,7 +429,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where Q: BorrowFrom<T> + Ord {\n         self.map.remove(value).is_some()\n     }\n }"}, {"sha": "efb73e7d7c8b57e4ddabe8fb7114d14631b16c71", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -989,7 +989,7 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n #[unstable = \"U should be an associated type\"]\n /// An extension trait for concatenating slices\n-pub trait SliceConcatExt<Sized? T, U> for Sized? {\n+pub trait SliceConcatExt<T: ?Sized, U> for Sized? {\n     /// Flattens a slice of `T` into a single value `U`.\n     #[stable]\n     fn concat(&self) -> U;"}, {"sha": "54621f59c2f4683114d67e62bdc410b70f71f869", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -53,50 +53,50 @@ use option::Option;\n use self::Cow::*;\n \n /// A trait for borrowing data.\n-pub trait BorrowFrom<Sized? Owned> for Sized? {\n+pub trait BorrowFrom<Owned: ?Sized> for Sized? {\n     /// Immutably borrow from an owned value.\n     fn borrow_from(owned: &Owned) -> &Self;\n }\n \n /// A trait for mutably borrowing data.\n-pub trait BorrowFromMut<Sized? Owned> for Sized? : BorrowFrom<Owned> {\n+pub trait BorrowFromMut<Owned: ?Sized> for Sized? : BorrowFrom<Owned> {\n     /// Mutably borrow from an owned value.\n     fn borrow_from_mut(owned: &mut Owned) -> &mut Self;\n }\n \n-impl<Sized? T> BorrowFrom<T> for T {\n+impl<T: ?Sized> BorrowFrom<T> for T {\n     fn borrow_from(owned: &T) -> &T { owned }\n }\n \n-impl<Sized? T> BorrowFromMut<T> for T {\n+impl<T: ?Sized> BorrowFromMut<T> for T {\n     fn borrow_from_mut(owned: &mut T) -> &mut T { owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a T> for T {\n     fn borrow_from<'b>(owned: &'b &'a T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFrom<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFrom<&'a mut T> for T {\n     fn borrow_from<'b>(owned: &'b &'a mut T) -> &'b T { &**owned }\n }\n \n-impl<'a, Sized? T> BorrowFromMut<&'a mut T> for T {\n+impl<'a, T: ?Sized> BorrowFromMut<&'a mut T> for T {\n     fn borrow_from_mut<'b>(owned: &'b mut &'a mut T) -> &'b mut T { &mut **owned }\n }\n \n-impl<'a, T, Sized? B> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> BorrowFrom<Cow<'a, T, B>> for B where B: ToOwned<T> {\n     fn borrow_from<'b>(owned: &'b Cow<'a, T, B>) -> &'b B {\n         &**owned\n     }\n }\n \n /// Trait for moving into a `Cow`\n-pub trait IntoCow<'a, T, Sized? B> {\n+pub trait IntoCow<'a, T, B: ?Sized> {\n     /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, T, B>;\n }\n \n-impl<'a, T, Sized? B> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> IntoCow<'a, T, B> for Cow<'a, T, B> where B: ToOwned<T> {\n     fn into_cow(self) -> Cow<'a, T, B> {\n         self\n     }\n@@ -129,7 +129,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n+pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n \n@@ -138,7 +138,7 @@ pub enum Cow<'a, T, Sized? B: 'a> where B: ToOwned<T> {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -150,7 +150,7 @@ impl<'a, T, Sized? B> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n+impl<'a, T, B: ?Sized> Cow<'a, T, B> where B: ToOwned<T> {\n     /// Acquire a mutable reference to the owned form of the data.\n     ///\n     /// Copies the data if it is not already owned.\n@@ -191,7 +191,7 @@ impl<'a, T, Sized? B> Cow<'a, T, B> where B: ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n+impl<'a, T, B: ?Sized> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -203,18 +203,18 @@ impl<'a, T, Sized? B> Deref for Cow<'a, T, B> where B: ToOwned<T>  {\n }\n \n #[stable]\n-impl<'a, T, Sized? B> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n+impl<'a, T, B: ?Sized> Eq for Cow<'a, T, B> where B: Eq + ToOwned<T> {}\n \n #[stable]\n-impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n+impl<'a, T, B: ?Sized> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     #[inline]\n     fn cmp(&self, other: &Cow<'a, T, B>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n }\n \n #[stable]\n-impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n+impl<'a, 'b, T, U, B: ?Sized, C: ?Sized> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n     B: PartialEq<C> + ToOwned<T>,\n     C: ToOwned<U>,\n {\n@@ -225,14 +225,14 @@ impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B\n }\n \n #[stable]\n-impl<'a, T, Sized? B> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n+impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwned<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Cow<'a, T, B>) -> Option<Ordering> {\n         PartialOrd::partial_cmp(&**self, &**other)\n     }\n }\n \n-impl<'a, T, Sized? B> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n+impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where B: fmt::Show + ToOwned<T>, T: fmt::Show {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Borrowed(ref b) => fmt::Show::fmt(b, f),"}, {"sha": "17991659f97899c6027021eae8a8dceecccd54a6", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -43,7 +43,7 @@ pub trait Clone : Sized {\n }\n \n #[stable]\n-impl<'a, Sized? T> Clone for &'a T {\n+impl<'a, T: ?Sized> Clone for &'a T {\n     /// Return a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }"}, {"sha": "933088f276528c01de4ac7ccfdbf2928fd504784", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -69,7 +69,7 @@ use option::Option::{self, Some, None};\n /// only if `a != b`.\n #[lang=\"eq\"]\n #[stable]\n-pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n+pub trait PartialEq<Rhs: ?Sized = Self> for Sized? {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n     #[stable]\n     fn eq(&self, other: &Rhs) -> bool;\n@@ -224,7 +224,7 @@ impl PartialOrd for Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n #[stable]\n-pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n+pub trait PartialOrd<Rhs: ?Sized = Self> for Sized?: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n     #[stable]\n@@ -428,14 +428,14 @@ mod impls {\n     // & pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b B> for &'a A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -450,24 +450,24 @@ mod impls {\n         fn gt(&self, other: & &'b B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: & &'a A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a A where A: Eq {}\n \n     // &mut pointers\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialOrd<&'b mut B> for &'a mut A where A: PartialOrd<B> {\n         #[inline]\n         fn partial_cmp(&self, other: &&'b mut B) -> Option<Ordering> {\n             PartialOrd::partial_cmp(*self, *other)\n@@ -482,23 +482,23 @@ mod impls {\n         fn gt(&self, other: &&'b mut B) -> bool { PartialOrd::gt(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Ord for &'a mut A where A: Ord {\n+    impl<'a, A: ?Sized> Ord for &'a mut A where A: Ord {\n         #[inline]\n         fn cmp(&self, other: &&'a mut A) -> Ordering { Ord::cmp(*self, *other) }\n     }\n     #[stable]\n-    impl<'a, Sized? A> Eq for &'a mut A where A: Eq {}\n+    impl<'a, A: ?Sized> Eq for &'a mut A where A: Eq {}\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n         fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n \n     #[stable]\n-    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+    impl<'a, 'b, A: ?Sized, B: ?Sized> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n         fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]"}, {"sha": "9e9e2b92bb7ad9d8ee88a737d1d15a9090447f6b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -78,9 +78,9 @@ pub trait Writer {\n         // This Adapter is needed to allow `self` (of type `&mut\n         // Self`) to be cast to a FormatWriter (below) without\n         // requiring a `Sized` bound.\n-        struct Adapter<'a,Sized? T:'a>(&'a mut T);\n+        struct Adapter<'a,T: ?Sized +'a>(&'a mut T);\n \n-        impl<'a, Sized? T> Writer for Adapter<'a, T>\n+        impl<'a, T: ?Sized> Writer for Adapter<'a, T>\n             where T: Writer\n         {\n             fn write_str(&mut self, s: &str) -> Result {\n@@ -592,10 +592,10 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n \n // Implementations of the core formatting traits\n \n-impl<'a, Sized? T: Show> Show for &'a T {\n+impl<'a, T: ?Sized + Show> Show for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n-impl<'a, Sized? T: Show> Show for &'a mut T {\n+impl<'a, T: ?Sized + Show> Show for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { (**self).fmt(f) }\n }\n "}, {"sha": "aaae5c2717c7b28a38c44ca5d14268ee34c1231d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -85,7 +85,7 @@ pub trait Hash<S = sip::SipState> for Sized? {\n /// containers like `HashMap`, which need a generic way hash multiple types.\n pub trait Hasher<S> {\n     /// Compute the hash of a value.\n-    fn hash<Sized? T: Hash<S>>(&self, value: &T) -> u64;\n+    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;\n }\n \n #[allow(missing_docs)]\n@@ -194,14 +194,14 @@ impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n }\n \n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n \n-impl<'a, S: Writer, Sized? T: Hash<S>> Hash<S> for &'a mut T {\n+impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n@@ -233,7 +233,7 @@ impl<S: Writer> Hash<S> for TypeId {\n     }\n }\n \n-impl<'a, T, Sized? B, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n+impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)"}, {"sha": "c4d45e9c2c80454802496457b1f8e3b17dc3762f", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -239,7 +239,7 @@ impl SipHasher {\n \n impl Hasher<SipState> for SipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 {\n         let mut state = SipState::new_with_keys(self.k0, self.k1);\n         value.hash(&mut state);\n         state.result()\n@@ -255,15 +255,15 @@ impl Default for SipHasher {\n \n /// Hashes a value using the SipHash algorithm.\n #[inline]\n-pub fn hash<Sized? T: Hash<SipState>>(value: &T) -> u64 {\n+pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 {\n     let mut state = SipState::new();\n     value.hash(&mut state);\n     state.result()\n }\n \n /// Hashes a value with the SipHash algorithm with the provided keys.\n #[inline]\n-pub fn hash_with_keys<Sized? T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n+pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     let mut state = SipState::new_with_keys(k0, k1);\n     value.hash(&mut state);\n     state.result()"}, {"sha": "1911641034c945a1d026ea3290afe1c8a7d5edd8", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -133,10 +133,10 @@ pub mod marker {\n     /// for some lifetime `'a`, but not the other way around).\n     #[lang=\"covariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct CovariantType<Sized? T>;\n+    pub struct CovariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for CovariantType<T> {}\n-    impl<Sized? T> Clone for CovariantType<T> {\n+    impl<T: ?Sized> Copy for CovariantType<T> {}\n+    impl<T: ?Sized> Clone for CovariantType<T> {\n         fn clone(&self) -> CovariantType<T> { *self }\n     }\n \n@@ -181,10 +181,10 @@ pub mod marker {\n     /// arguments of type `U`, hence such a conversion is safe.\n     #[lang=\"contravariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct ContravariantType<Sized? T>;\n+    pub struct ContravariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for ContravariantType<T> {}\n-    impl<Sized? T> Clone for ContravariantType<T> {\n+    impl<T: ?Sized> Copy for ContravariantType<T> {}\n+    impl<T: ?Sized> Clone for ContravariantType<T> {\n         fn clone(&self) -> ContravariantType<T> { *self }\n     }\n \n@@ -211,10 +211,10 @@ pub mod marker {\n     /// interior mutability.\n     #[lang=\"invariant_type\"]\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct InvariantType<Sized? T>;\n+    pub struct InvariantType<T: ?Sized>;\n \n-    impl<Sized? T> Copy for InvariantType<T> {}\n-    impl<Sized? T> Clone for InvariantType<T> {\n+    impl<T: ?Sized> Copy for InvariantType<T> {}\n+    impl<T: ?Sized> Clone for InvariantType<T> {\n         fn clone(&self) -> InvariantType<T> { *self }\n     }\n "}, {"sha": "c60569161213f68949bed4524688bc4978982d93", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -320,7 +320,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n+pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n                                                         ptr: &T) -> &'a T {\n     transmute(ptr)\n }\n@@ -329,7 +329,7 @@ pub unsafe fn copy_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a S,\n #[inline]\n #[unstable = \"this function may be removed in the future due to its \\\n               questionable utility\"]\n-pub unsafe fn copy_mut_lifetime<'a, Sized? S, Sized? T: 'a>(_ptr: &'a mut S,\n+pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,\n                                                             ptr: &mut T)\n                                                             -> &'a mut T {\n     transmute(ptr)"}, {"sha": "d7f6d3bc153570a560812199cffd90d53e422c3a", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -721,7 +721,7 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n #[cfg(stage0)]\n #[allow(missing_docs)]\n #[lang=\"index\"]\n-pub trait Index<Sized? Index, Sized? Result> for Sized? {\n+pub trait Index<Index: ?Sized, Result: ?Sized> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Result;\n }\n@@ -757,8 +757,8 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n /// ```\n #[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index\"]\n-pub trait Index<Sized? Index> for Sized? {\n-    type Sized? Output;\n+pub trait Index<Index: ?Sized> for Sized? {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n@@ -768,7 +768,7 @@ pub trait Index<Sized? Index> for Sized? {\n #[cfg(stage0)]\n #[allow(missing_docs)]\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n+pub trait IndexMut<Index: ?Sized, Result: ?Sized> for Sized? {\n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n@@ -804,8 +804,8 @@ pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n /// ```\n #[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index> for Sized? {\n-    type Sized? Output;\n+pub trait IndexMut<Index: ?Sized> for Sized? {\n+    type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n@@ -849,7 +849,7 @@ pub trait IndexMut<Sized? Index> for Sized? {\n /// }\n /// ```\n #[lang=\"slice\"]\n-pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n+pub trait Slice<Idx: ?Sized, Result: ?Sized> for Sized? {\n     /// The method for the slicing operation foo[]\n     fn as_slice_<'a>(&'a self) -> &'a Result;\n     /// The method for the slicing operation foo[from..]\n@@ -898,7 +898,7 @@ pub trait Slice<Sized? Idx, Sized? Result> for Sized? {\n /// }\n /// ```\n #[lang=\"slice_mut\"]\n-pub trait SliceMut<Sized? Idx, Sized? Result> for Sized? {\n+pub trait SliceMut<Idx: ?Sized, Result: ?Sized> for Sized? {\n     /// The method for the slicing operation foo[]\n     fn as_mut_slice_<'a>(&'a mut self) -> &'a mut Result;\n     /// The method for the slicing operation foo[from..]\n@@ -1026,19 +1026,19 @@ pub struct RangeTo<Idx> {\n /// ```\n #[lang=\"deref\"]\n pub trait Deref for Sized? {\n-    type Sized? Target;\n+    type Target: ?Sized;\n \n     /// The method called to dereference a value\n     fn deref<'a>(&'a self) -> &'a Self::Target;\n }\n \n-impl<'a, Sized? T> Deref for &'a T {\n+impl<'a, T: ?Sized> Deref for &'a T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n }\n \n-impl<'a, Sized? T> Deref for &'a mut T {\n+impl<'a, T: ?Sized> Deref for &'a mut T {\n     type Target = T;\n \n     fn deref(&self) -> &T { *self }\n@@ -1087,7 +1087,7 @@ pub trait DerefMut for Sized? : Deref {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut <Self as Deref>::Target;\n }\n \n-impl<'a, Sized? T> DerefMut for &'a mut T {\n+impl<'a, T: ?Sized> DerefMut for &'a mut T {\n     fn deref_mut(&mut self) -> &mut T { *self }\n }\n \n@@ -1112,8 +1112,8 @@ pub trait FnOnce<Args,Result> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Result;\n }\n \n-impl<Sized? F,A,R> FnMut<A,R> for F\n-    where F : Fn<A,R>\n+impl<F: ?Sized, A, R> FnMut<A, R> for F\n+    where F : Fn<A, R>\n {\n     extern \"rust-call\" fn call_mut(&mut self, args: A) -> R {\n         self.call(args)"}, {"sha": "de57136d593a4f288d2e170e957cc84191355db0", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -648,13 +648,13 @@ impl<T> AsSlice<T> for [T] {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, T, Sized? U: AsSlice<T>> AsSlice<T> for &'a mut U {\n+impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }"}, {"sha": "74fac6b76783872dac9b2eacb76fddea69d71f5d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -1140,7 +1140,7 @@ impl Str for str {\n     fn as_slice<'a>(&'a self) -> &'a str { self }\n }\n \n-impl<'a, Sized? S> Str for &'a S where S: Str {\n+impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     #[inline]\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }"}, {"sha": "a4bafe754ffdd812c011fafbb03f6a02fb57494f", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -16,7 +16,7 @@ use core::hash::{Hash, Hasher, Writer};\n struct MyWriterHasher;\n \n impl Hasher<MyWriter> for MyWriterHasher {\n-    fn hash<Sized? T: Hash<MyWriter>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<MyWriter>>(&self, value: &T) -> u64 {\n         let mut state = MyWriter { hash: 0 };\n         value.hash(&mut state);\n         state.hash"}, {"sha": "567fe04c5afbc659df4ccb13f6b344b385bdb969", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -25,7 +25,7 @@ use std::slice;\n \n // Note 2: Once Dynamically Sized Types (DST) lands, it might be\n // reasonable to replace this with something like `enum MaybeOwned<'a,\n-// Sized? U>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n+// U: ?Sized>{ Owned(Box<U>), Borrowed(&'a U) }`; and then `U` could be\n // instantiated with `[T]` or `str`, etc.  Of course, that would imply\n // removing the `Growable` variant, which relates to note 1 above.\n // Alternatively, we might add `MaybeOwned` for the general case but"}, {"sha": "a83416667abdc331eaf8534011977c4826e8fa00", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // However, it's not as simple as checking whether `T :\n         // Sized`, because even if `T : Sized` does not hold, that\n         // just means that `T` *may* not be sized.  After all, even a\n-        // type parameter `Sized? T` could be bound to a sized\n+        // type parameter `T: ?Sized` could be bound to a sized\n         // type. (Issue #20116)\n         //\n         // To handle this, we first check for \"interior\" type\n@@ -139,16 +139,16 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         // exhaustively checking all possible combinations. Here are some examples:\n         //\n         // ```\n-        // fn foo<T,U>() {\n+        // fn foo<T, U>() {\n         //     // T=int, U=int\n         // }\n         //\n-        // fn bar<Sized? T,U>() {\n+        // fn bar<T: ?Sized, U>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         // }\n         //\n-        // fn baz<Sized? T, Sized?U>() {\n+        // fn baz<T: ?Sized, U: ?Sized>() {\n         //     // T=int, U=int\n         //     // T=[int], U=int\n         //     // T=int, U=[int]"}, {"sha": "ee224d1ec80fe0361a1b52506accf6e55c1f08a4", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -75,7 +75,7 @@ pub struct FnvHasher;\n pub struct FnvState(u64);\n \n impl Hasher<FnvState> for FnvHasher {\n-    fn hash<Sized? T: Hash<FnvState>>(&self, t: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<FnvState>>(&self, t: &T) -> u64 {\n         let mut state = FnvState(0xcbf29ce484222325);\n         t.hash(&mut state);\n         let FnvState(ret) = state;"}, {"sha": "ffb7fd9e71b3c4059bffe9d5d0fb69c787d903de", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -604,7 +604,7 @@ impl<'tcx> Repr<'tcx> for () {\n     }\n }\n \n-impl<'a, 'tcx, Sized? T:Repr<'tcx>> Repr<'tcx> for &'a T {\n+impl<'a, 'tcx, T: ?Sized +Repr<'tcx>> Repr<'tcx> for &'a T {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         Repr::repr(*self, tcx)\n     }"}, {"sha": "c317b9674897c1f8507a0eb7f97b2032e8219c33", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -396,13 +396,13 @@ impl Decodable for () {\n     }\n }\n \n-impl<'a, Sized? T: Encodable> Encodable for &'a T {\n+impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<Sized? T: Encodable> Encodable for Box<T> {\n+impl<T: ?Sized + Encodable> Encodable for Box<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }"}, {"sha": "c4317b99dce06c085522b724d35013a47d99983a", "filename": "src/libserialize/serialize_stage0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -378,13 +378,13 @@ impl<E, D:Decoder<E>> Decodable<D, E> for () {\n     }\n }\n \n-impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n+impl<'a, E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for &'a T {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n+impl<E, S: Encoder<E>, T: ?Sized + Encodable<S, E>> Encodable<S, E> for Box<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }"}, {"sha": "c8a59ce6bba4c069998b1b970966135b468d07b5", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -430,7 +430,7 @@ impl ToCStr for [u8] {\n     }\n }\n \n-impl<'a, Sized? T: ToCStr> ToCStr for &'a T {\n+impl<'a, T: ?Sized + ToCStr> ToCStr for &'a T {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         (**self).to_c_str()"}, {"sha": "300fc849ace284436299fc1a3b71fc13939b5fbb", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -440,22 +440,22 @@ impl<K, V, M> SearchResult<K, V, M> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<Sized? X: Hash<S>>(&self, x: &X) -> SafeHash {\n+    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a, Sized? Q>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n-    fn search_mut<'a, Sized? Q>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n         where Q: BorrowFrom<K> + Eq + Hash<S>\n     {\n         let hash = self.make_hash(q);\n@@ -923,7 +923,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     #[stable]\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     /// Regardless of whether or not `to_owned()` has been called, the key must hash the same way.\n-    pub fn entry<'a, Sized? Q>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n+    pub fn entry<'a, Q: ?Sized>(&'a mut self, key: &'a Q) -> Entry<'a, Q, K, V>\n         where Q: Eq + Hash<S> + ToOwned<K>\n     {\n         // Gotta resize now.\n@@ -1030,7 +1030,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.get(&2), None);\n     /// ```\n     #[stable]\n-    pub fn get<Sized? Q>(&self, k: &Q) -> Option<&V>\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n@@ -1053,7 +1053,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n     #[stable]\n-    pub fn contains_key<Sized? Q>(&self, k: &Q) -> bool\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n@@ -1079,7 +1079,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map[1], \"b\");\n     /// ```\n     #[stable]\n-    pub fn get_mut<Sized? Q>(&mut self, k: &Q) -> Option<&mut V>\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n@@ -1131,7 +1131,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, k: &Q) -> Option<V>\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n         where Q: Hash<S> + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n@@ -1142,7 +1142,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-fn search_entry_hashed<'a, K, V, Sized? Q>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n+fn search_entry_hashed<'a, K, V, Q: ?Sized>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: &'a Q)\n         -> Entry<'a, Q, K, V>\n     where Q: Eq + ToOwned<K>\n {\n@@ -1229,7 +1229,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n // NOTE(stage0): remove impl after a snapshot\n #[cfg(stage0)]\n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     #[inline]\n@@ -1240,7 +1240,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V\n \n #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1254,7 +1254,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H\n // NOTE(stage0): remove impl after a snapshot\n #[cfg(stage0)]\n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     #[inline]\n@@ -1265,7 +1265,7 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n \n #[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n #[stable]\n-impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n+impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n {\n     type Output = V;\n@@ -1357,15 +1357,15 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n \n #[stable]\n /// A view into a single empty location in a HashMap\n-pub struct VacantEntry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub struct VacantEntry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: &'a Q,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable]\n /// A view into a single location in a map, which may be vacant or occupied\n-pub enum Entry<'a, Sized? Q: 'a, K: 'a, V: 'a> {\n+pub enum Entry<'a, Q: ?Sized + 'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n     Occupied(OccupiedEntry<'a, K, V>),\n     /// A vacant Entry\n@@ -1435,7 +1435,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q, K, V> Entry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized, K, V> Entry<'a, Q, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, Q, K, V>> {\n@@ -1481,7 +1481,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, Sized? Q: 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n+impl<'a, Q: ?Sized + 'a + ToOwned<K>, K: 'a, V: 'a> VacantEntry<'a, Q, K, V> {\n     #[stable]\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it"}, {"sha": "f77eaa237c1ddece14d1968c8431cde74405b829", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -451,7 +451,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.contains(&4), false);\n     /// ```\n     #[stable]\n-    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.contains_key(value)\n@@ -561,7 +561,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.remove(&2), false);\n     /// ```\n     #[stable]\n-    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n         where Q: BorrowFrom<T> + Hash<S> + Eq\n     {\n         self.map.remove(value).is_some()"}, {"sha": "1eb4408eedc403d4d4fb0e273e9bd9d52ad88eeb", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -138,7 +138,7 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<Sized? T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n     // We need to avoid 0u64 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution\n     // of initial indexes by unconditionally setting the MSB,"}, {"sha": "ac2b01e995e2c62b5b17cea4e589659149bff133", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -90,7 +90,7 @@ impl RandomSipHasher {\n \n impl Hasher<sip::SipState> for RandomSipHasher {\n     #[inline]\n-    fn hash<Sized? T: Hash<sip::SipState>>(&self, value: &T) -> u64 {\n+    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 {\n         self.hasher.hash(value)\n     }\n }"}, {"sha": "66416a21dd9a449e87fe9f5de7ffa31a5922ec3e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -1012,12 +1012,12 @@ pub trait Writer {\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n         // Create a shim which translates a Writer to a fmt::Writer and saves\n         // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, Sized? T:'a> {\n+        struct Adaptor<'a, T: ?Sized +'a> {\n             inner: &'a mut T,\n             error: IoResult<()>,\n         }\n \n-        impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n+        impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n                 match self.inner.write(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n@@ -1597,11 +1597,11 @@ pub trait Acceptor<T> {\n /// `Some`. The `Some` contains the `IoResult` representing whether the\n /// connection attempt was successful.  A successful connection will be wrapped\n /// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, Sized? A:'a> {\n+pub struct IncomingConnections<'a, A: ?Sized +'a> {\n     inc: &'a mut A,\n }\n \n-impl<'a, T, Sized? A: Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n+impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n     type Item = IoResult<T>;\n \n     fn next(&mut self) -> Option<IoResult<T>> {"}, {"sha": "4f37e8a978aa98a70be8aae759f9512512441e39", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -896,7 +896,7 @@ impl BytesContainer for CString {\n     }\n }\n \n-impl<'a, Sized? T: BytesContainer> BytesContainer for &'a T {\n+impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n         (**self).container_as_bytes()"}, {"sha": "777315b3ed66d73aeeb6bff6c91dc383cfebc120", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -344,7 +344,7 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<Sized? V: AsSlice<u8>>(v: &V) -> Vec<u8> {\n+    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;"}, {"sha": "299cf7e941b4ed5199ce566717989753e52aa655", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -95,7 +95,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"write `extern crate bar as foo` instead\"\n             ),\n             ObsoleteSyntax::Sized => (\n-                \"`Sized? T` syntax for removing the `Sized` bound\",\n+                \"`T: ?Sized` syntax for removing the `Sized` bound\",\n                 \"write `T: ?Sized` instead\"\n             ),\n         };"}, {"sha": "85eea2d9daf27226f889f7c80b4c3643587fbd48", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -77,7 +77,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n         (*vect).len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<T> + Eq + Hash {\n         let map = self.map.borrow();\n         match (*map).get(val) {\n@@ -202,7 +202,7 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n-    pub fn find<Sized? Q>(&self, val: &Q) -> Option<Name>\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<RcStr> + Eq + Hash {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),"}, {"sha": "2ab3ec1aeadd7bd309a2c40bc480c4c2f6a1e1e8", "filename": "src/test/compile-fail/associated-types-unsized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -11,7 +11,7 @@\n #![feature(associated_types)]\n \n trait Get {\n-    type Sized? Value;\n+    type Value: ?Sized;\n     fn get(&self) -> <Self as Get>::Value;\n }\n "}, {"sha": "5e360b6ab9bad8fa2d4e40dd5fbdc022bc7ee17b", "filename": "src/test/compile-fail/dst-bad-assign-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-2.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "cc709be99002ea2a35ca44d04f6c9823409a30fd", "filename": "src/test/compile-fail/dst-bad-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Forbid assignment into a dynamically sized type.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f1: int,\n     f2: &'static str,\n     ptr: T"}, {"sha": "75bd94331b11d591b431c31d1872106fd2d839b9", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the type as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "54c625221ba7d0216270ca705c30179ec57b1450", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to change the mutability as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "192d43e32fd27523dc43d60fb41dbe53a2eb55d3", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to extend the lifetime as well as unsizing.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "53ce18c73a08845e011927466a983e99f822653e", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,7 +10,7 @@\n \n // Attempt to coerce from unsized to sized.\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "b30eada162b84707134573888de917956f8ca50c", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -14,7 +14,7 @@ struct S;\n trait T {}\n impl T for S {}\n \n-struct Foo<Sized? T> {\n+struct Foo<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "b169824cb3aca2e40a44473aca31a23bee64e319", "filename": "src/test/compile-fail/dst-bad-deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -13,7 +13,7 @@\n // because it would require stack allocation of an unsized temporary (*g in the\n // test).\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     ptr: T\n }\n "}, {"sha": "c331b02c7ccdc112bc74c8b239232a67cdf2cadc", "filename": "src/test/compile-fail/dst-object-from-unsized-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-object-from-unsized-type.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -13,12 +13,12 @@\n trait Foo for Sized? {}\n impl Foo for str {}\n \n-fn test1<Sized? T: Foo>(t: &T) {\n+fn test1<T: ?Sized + Foo>(t: &T) {\n     let u: &Foo = t;\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `T`\n }\n \n-fn test2<Sized? T: Foo>(t: &T) {\n+fn test2<T: ?Sized + Foo>(t: &T) {\n     let v: &Foo = t as &Foo;\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `T`\n }"}, {"sha": "31456853e1c0f1543207f7c0776e36861700fe91", "filename": "src/test/compile-fail/transmute-fat-pointers.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -14,11 +14,11 @@\n \n use std::mem::transmute;\n \n-fn a<T, Sized? U>(x: &[T]) -> &U {\n+fn a<T, U: ?Sized>(x: &[T]) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n-fn b<Sized? T, Sized? U>(x: &T) -> &U {\n+fn b<T: ?Sized, U: ?Sized>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n@@ -30,11 +30,11 @@ fn d<T, U>(x: &[T]) -> &[U] {\n     unsafe { transmute(x) }\n }\n \n-fn e<Sized? T, U>(x: &T) -> &U {\n+fn e<T: ?Sized, U>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n \n-fn f<T, Sized? U>(x: &T) -> &U {\n+fn f<T, U: ?Sized>(x: &T) -> &U {\n     unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n }\n "}, {"sha": "a68bba285df29b39741ca7db9a78a5c4771715e4", "filename": "src/test/compile-fail/transmute-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -14,11 +14,11 @@\n \n use std::mem::transmute;\n \n-struct Foo<Sized? T> {\n+struct Foo<T: ?Sized> {\n     t: Box<T>\n }\n \n-impl<Sized? T> Foo<T> {\n+impl<T: ?Sized> Foo<T> {\n     fn m(x: &T) -> &int where T : Sized {\n         // OK here, because T : Sized is in scope.\n         unsafe { transmute(x) }"}, {"sha": "81cfcf5cde9188b1f3a037e827febed63b14d3dc", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -18,9 +18,9 @@ trait Foo<T,U,V=T> {\n     fn dummy(&self, t: T, u: U, v: V);\n }\n \n-trait Eq<Sized? X> for Sized? { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B>() where A : Eq<B> { }\n+trait Eq<X: ?Sized> for Sized? { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized>() where A : Eq<B> { }\n \n fn test<'a,'b>() {\n     // Parens are equivalent to omitting default in angle."}, {"sha": "368cb189907fe98fe3bcf9cd6fcd6498029c4626", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -20,9 +20,9 @@ trait Foo<T,U> {\n     fn dummy(&self, t: T, u: U);\n }\n \n-trait Eq<Sized? X> for Sized? { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> for Sized? { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn test<'a,'b>() {\n     // No errors expected:"}, {"sha": "8c85382f45e0ec08c9ac98735541cc17d26c501c", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -20,9 +20,9 @@ trait Foo<T,U> {\n     fn dummy(&self, t: T, u: U);\n }\n \n-trait Eq<Sized? X> for Sized? { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> for Sized? { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn main() {\n     eq::< for<'a> Foo<(&'a int,), &'a int>,"}, {"sha": "c99e7a116323f319831e6c88c436d2b4065b337a", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -21,9 +21,9 @@ trait Foo<'a,T,U> {\n     fn dummy(&'a self) -> &'a (T,U);\n }\n \n-trait Eq<Sized? X> for Sized? { }\n-impl<Sized? X> Eq<X> for X { }\n-fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+trait Eq<X: ?Sized> for Sized? { }\n+impl<X: ?Sized> Eq<X> for X { }\n+fn eq<A: ?Sized,B: ?Sized +Eq<A>>() { }\n \n fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n "}, {"sha": "2de490e018b44de240f5a898585840aac5946ce5", "filename": "src/test/compile-fail/unsized-bare-typaram.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn bar<T: Sized>() { }\n-fn foo<Sized? T>() { bar::<T>() } //~ ERROR the trait `core::kinds::Sized` is not implemented\n+fn foo<T: ?Sized>() { bar::<T>() } //~ ERROR the trait `core::kinds::Sized` is not implemented\n fn main() { }"}, {"sha": "aea236c9268157928593407a3e2bc85a4ccd4bbe", "filename": "src/test/compile-fail/unsized-enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,18 +10,18 @@\n \n \n fn is_sized<T:Sized>() { }\n-fn not_sized<Sized? T>() { }\n+fn not_sized<T: ?Sized>() { }\n \n enum Foo<U> { FooSome(U), FooNone }\n fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n-fn foo2<Sized? T>() { not_sized::<Foo<T>>() }\n+fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `T` is not sized.\n \n-enum Bar<Sized? U> { BarSome(U), BarNone }\n-fn bar1<Sized? T>() { not_sized::<Bar<T>>() }\n-fn bar2<Sized? T>() { is_sized::<Bar<T>>() }\n+enum Bar<U: ?Sized> { BarSome(U), BarNone }\n+fn bar1<T: ?Sized>() { not_sized::<Bar<T>>() }\n+fn bar2<T: ?Sized>() { is_sized::<Bar<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `Bar<T>` is not sized, but it should be."}, {"sha": "8740346a21750c8918af9545e4ceda6d20a0286b", "filename": "src/test/compile-fail/unsized-inherent-impl-self-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-inherent-impl-self-type.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -14,7 +14,7 @@\n \n struct S5<Y>;\n \n-impl<Sized? X> S5<X> { //~ ERROR not implemented\n+impl<X: ?Sized> S5<X> { //~ ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "89c711036977a68addd796bfedd63652ad312293", "filename": "src/test/compile-fail/unsized-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,18 +10,18 @@\n \n \n fn is_sized<T:Sized>() { }\n-fn not_sized<Sized? T>() { }\n+fn not_sized<T: ?Sized>() { }\n \n struct Foo<T> { data: T }\n fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n-fn foo2<Sized? T>() { not_sized::<Foo<T>>() }\n+fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `T` is not sized.\n \n-struct Bar<Sized? T> { data: T }\n-fn bar1<Sized? T>() { not_sized::<Bar<T>>() }\n-fn bar2<Sized? T>() { is_sized::<Bar<T>>() }\n+struct Bar<T: ?Sized> { data: T }\n+fn bar1<T: ?Sized>() { not_sized::<Bar<T>>() }\n+fn bar2<T: ?Sized>() { is_sized::<Bar<T>>() }\n //~^ ERROR the trait `core::kinds::Sized` is not implemented\n //\n // Not OK: `Bar<T>` is not sized, but it should be."}, {"sha": "3dd55b0ba7d23401d7c75e5922efd5c2f23038b5", "filename": "src/test/compile-fail/unsized-trait-impl-self-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-self-type.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -11,12 +11,12 @@\n // Test sized-ness checking in substitution in impls.\n \n // impl - struct\n-trait T3<Sized? Z> {\n+trait T3<Z: ?Sized> {\n }\n \n struct S5<Y>;\n \n-impl<Sized? X> T3<X> for S5<X> { //~ ERROR not implemented\n+impl<X: ?Sized> T3<X> for S5<X> { //~ ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "7ae74fc2600c84d71416e431f997c6840278b901", "filename": "src/test/compile-fail/unsized-trait-impl-trait-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-trait-impl-trait-arg.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -13,8 +13,8 @@\n // impl - unbounded\n trait T2<Z> {\n }\n-struct S4<Sized? Y>;\n-impl<Sized? X> T2<X> for S4<X> {\n+struct S4<Y: ?Sized>;\n+impl<X: ?Sized> T2<X> for S4<X> {\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n }\n "}, {"sha": "02c0fd618927d61b97d44b70c1bd72a73c8948b9", "filename": "src/test/compile-fail/unsized3.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -12,7 +12,7 @@\n \n \n // Unbounded.\n-fn f1<Sized? X>(x: &X) {\n+fn f1<X: ?Sized>(x: &X) {\n     f2::<X>(x);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n@@ -21,45 +21,45 @@ fn f2<X>(x: &X) {\n \n // Bounded.\n trait T for Sized? {}\n-fn f3<Sized? X: T>(x: &X) {\n+fn f3<X: ?Sized + T>(x: &X) {\n     f4::<X>(x);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n fn f4<X: T>(x: &X) {\n }\n \n // Test with unsized enum.\n-enum E<Sized? X> {\n+enum E<X: ?Sized> {\n     V(X),\n }\n \n fn f5<Y>(x: &Y) {}\n-fn f6<Sized? X>(x: &X) {}\n-fn f7<Sized? X>(x1: &E<X>, x2: &E<X>) {\n+fn f6<X: ?Sized>(x: &X) {}\n+fn f7<X: ?Sized>(x1: &E<X>, x2: &E<X>) {\n     f5(x1);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n \n // Test with unsized struct.\n-struct S<Sized? X> {\n+struct S<X: ?Sized> {\n     x: X,\n }\n \n-fn f8<Sized? X>(x1: &S<X>, x2: &S<X>) {\n+fn f8<X: ?Sized>(x1: &S<X>, x2: &S<X>) {\n     f5(x1);\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n     f6(x2); // ok\n }\n \n // Test some tuples.\n-fn f9<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n+fn f9<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(*x1, 34i));\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn f10<Sized? X>(x1: Box<S<X>>, x2: Box<E<X>>) {\n+fn f10<X: ?Sized>(x1: Box<S<X>>, x2: Box<E<X>>) {\n     f5(&(32i, *x2));\n     //~^ ERROR the trait `core::kinds::Sized` is not implemented\n }"}, {"sha": "f8b8ad2bf2efa4ee0b749ec7393599ba57e032c7", "filename": "src/test/compile-fail/unsized4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -11,7 +11,7 @@\n // Test that bounds are sized-compatible.\n \n trait T : Sized {}\n-fn f<Sized? Y: T>() {\n+fn f<Y: ?Sized + T>() {\n //~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n }\n "}, {"sha": "f7477d746fae42faac883697deb0af0e5b681b28", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -10,11 +10,11 @@\n \n // Test `Sized?` types not allowed in fields (except the last one).\n \n-struct S1<Sized? X> {\n+struct S1<X: ?Sized> {\n     f1: X, //~ ERROR `core::kinds::Sized` is not implemented\n     f2: int,\n }\n-struct S2<Sized? X> {\n+struct S2<X: ?Sized> {\n     f: int,\n     g: X, //~ ERROR `core::kinds::Sized` is not implemented\n     h: int,\n@@ -27,10 +27,10 @@ struct S4 {\n     f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: uint\n }\n-enum E<Sized? X> {\n+enum E<X: ?Sized> {\n     V1(X, int), //~ERROR `core::kinds::Sized` is not implemented\n }\n-enum F<Sized? X> {\n+enum F<X: ?Sized> {\n     V2{f1: X, f: int}, //~ERROR `core::kinds::Sized` is not implemented\n }\n "}, {"sha": "019d3475502535168d7265866c2266f0379d4ac7", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -13,30 +13,30 @@\n \n trait T for Sized? {}\n \n-fn f1<Sized? X>(x: &X) {\n+fn f1<X: ?Sized>(x: &X) {\n     let _: X; // <-- this is OK, no bindings created, no initializer.\n     let _: (int, (X, int)); // same\n     let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n-fn f2<Sized? X: T>(x: &X) {\n+fn f2<X: ?Sized + T>(x: &X) {\n     let y: X; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y: (int, (X, int)); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn f3<Sized? X>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y = *x2; //~ERROR the trait `core::kinds::Sized` is not implemented\n     let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n-fn f4<Sized? X: T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+fn f4<X: ?Sized + T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n     let y: X = *x1;         //~ERROR the trait `core::kinds::Sized` is not implemented\n     let y = *x2;            //~ERROR the trait `core::kinds::Sized` is not implemented\n     let (y, z) = (*x3, 4i); //~ERROR the trait `core::kinds::Sized` is not implemented\n }\n \n-fn g1<Sized? X>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n-fn g2<Sized? X: T>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n+fn g1<X: ?Sized>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n+fn g2<X: ?Sized + T>(x: X) {} //~ERROR the trait `core::kinds::Sized` is not implemented\n \n pub fn main() {\n }"}, {"sha": "af64afb23b9454dd21c7de800b5e4bac11881e40", "filename": "src/test/compile-fail/unsized7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Fcompile-fail%2Funsized7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized7.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -16,8 +16,8 @@ trait T for Sized? {}\n // impl - bounded\n trait T1<Z: T> {\n }\n-struct S3<Sized? Y>;\n-impl<Sized? X: T> T1<X> for S3<X> {\n+struct S3<Y: ?Sized>;\n+impl<X: ?Sized + T> T1<X> for S3<X> {\n     //~^ ERROR `core::kinds::Sized` is not implemented for the type `X`\n }\n "}, {"sha": "8b8b7f169c5a0274f85fcfadea6add6dc98bb225", "filename": "src/test/run-pass-valgrind/dst-dtor-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -20,7 +20,7 @@ impl Drop for Foo {\n trait Trait {}\n impl Trait for Foo {}\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "743293c23f6adbb0c1e6ad8c55f19015fb4e99e9", "filename": "src/test/run-pass-valgrind/dst-dtor-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -17,7 +17,7 @@ impl Drop for Foo {\n     }\n }\n \n-struct Fat<Sized? T> {\n+struct Fat<T: ?Sized> {\n     f: T\n }\n "}, {"sha": "f7032da82a169f5317aeef66e99ddb60282b5a0d", "filename": "src/test/run-pass/associated-types-conditional-dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-conditional-dispatch.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -18,7 +18,7 @@\n \n use std::ops::Deref;\n \n-pub trait MyEq<Sized? U=Self> for Sized? {\n+pub trait MyEq<U: ?Sized=Self> for Sized? {\n     fn eq(&self, u: &U) -> bool;\n }\n "}, {"sha": "11ffb4198dad8c6b838a3ad1f0dcab79eb4ba9d5", "filename": "src/test/run-pass/issue-18906.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0684e876954ad5a713e6f985570162cedcae8df/src%2Ftest%2Frun-pass%2Fissue-18906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18906.rs?ref=e0684e876954ad5a713e6f985570162cedcae8df", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub trait Borrow<Sized? Borrowed> {\n+pub trait Borrow<Borrowed: ?Sized> {\n         fn borrow(&self) -> &Borrowed;\n }\n "}]}