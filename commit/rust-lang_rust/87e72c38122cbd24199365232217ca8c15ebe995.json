{"sha": "87e72c38122cbd24199365232217ca8c15ebe995", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZTcyYzM4MTIyY2JkMjQxOTkzNjUyMzIyMTdjYThjMTVlYmU5OTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-19T01:22:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-19T01:22:23Z"}, "message": "auto merge of #13006 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #13008 (Made the `clone_from` implementation for `~T` reuse the `T` itself if possible)\r\nCloses #13003 (Make method Vec::remove() public)\r\nCloses #13002 (disallow duplicate methods in trait impls)\r\nCloses #13000 (rustc: test: don't silently ignore bad benches)\r\nCloses #12999 (rustc: buffer the output writer for -Z ast-json[-noexpand].)\r\nCloses #12993 (syntax: Don't parameterize the the pretty printer)\r\nCloses #12990 (`char` reference: s/character/Unicode scalar value/)\r\nCloses #12987 (Move syntax-extension-hexfloat.rs)\r\nCloses #12983 (Fix linkage1 test which fails due to --as-needed)\r\nCloses #12978 (rustc: remove linker_private/linker_private_weak)\r\nCloses #12976 (libsyntax: librustdoc: ignore utf-8 BOM in .rs files)\r\nCloses #12973 (closes #12967 fix [en|de]coding of HashMap<K,V> where K is a numeric type)\r\nCloses #12972 (Add impl IntoStr for ::std::vec_ng::Vec<Ascii>)\r\nCloses #12968 (deny missing docs getopts)\r\nCloses #12965 (Documentation and formatting changes for option.rs.)\r\nCloses #12962 (Relax the memory ordering on the implementation of UnsafeArc)\r\nCloses #12958 (Typo fixes.)\r\nCloses #12950 (Docsprint: Document ops module, primarily Deref.)\r\nCloses #12946 (rustdoc: Implement cross-crate searching)", "tree": {"sha": "f646d85985670486bfdf3d062b2a173ce76d106d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f646d85985670486bfdf3d062b2a173ce76d106d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87e72c38122cbd24199365232217ca8c15ebe995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87e72c38122cbd24199365232217ca8c15ebe995", "html_url": "https://github.com/rust-lang/rust/commit/87e72c38122cbd24199365232217ca8c15ebe995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87e72c38122cbd24199365232217ca8c15ebe995/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "891eab94a31739d6b0c330ebb7d4415529cfe1ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/891eab94a31739d6b0c330ebb7d4415529cfe1ee", "html_url": "https://github.com/rust-lang/rust/commit/891eab94a31739d6b0c330ebb7d4415529cfe1ee"}, {"sha": "2a5e04c2a427b00051424b916d9e306f0de470cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5e04c2a427b00051424b916d9e306f0de470cd", "html_url": "https://github.com/rust-lang/rust/commit/2a5e04c2a427b00051424b916d9e306f0de470cd"}], "stats": {"total": 1022, "additions": 784, "deletions": 238}, "files": [{"sha": "39b6261553618bc3b90555fd1d01de5aca85caab", "filename": "src/doc/rust.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -3136,8 +3136,12 @@ machine.\n \n The types `char` and `str` hold textual data.\n \n-A value of type `char` is a Unicode character,\n-represented as a 32-bit unsigned word holding a UCS-4 codepoint.\n+A value of type `char` is a [Unicode scalar value](\n+http://www.unicode.org/glossary/#unicode_scalar_value)\n+(ie. a code point that is not a surrogate),\n+represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF \n+or 0xE000 to 0x10FFFF range.\n+A `[char]` vector is effectively an UCS-4 / UTF-32 string.\n \n A value of type `str` is a Unicode string,\n represented as a vector of 8-bit unsigned bytes holding a sequence of UTF-8 codepoints."}, {"sha": "5d41f297e7d052f39a2aa2c5c192c150177a9e31", "filename": "src/doc/rustdoc.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Fdoc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Fdoc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc.md?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -43,7 +43,7 @@ pub fn recalibrate() {\n Doc comments are markdown, and are currently parsed with the\n [sundown][sundown] library. rustdoc does not yet do any fanciness such as\n referencing other items inline, like javadoc's `@see`. One exception to this\n-is that the first paragrah will be used as the \"summary\" of an item in the\n+is that the first paragraph will be used as the \"summary\" of an item in the\n generated documentation:\n \n ~~~\n@@ -79,11 +79,11 @@ rustdoc can also generate JSON, for consumption by other tools, with\n \n # Using the Documentation\n \n-The web pages generated by rustdoc present the same logical heirarchy that one\n+The web pages generated by rustdoc present the same logical hierarchy that one\n writes a library with. Every kind of item (function, struct, etc) has its own\n color, and one can always click on a colored type to jump to its\n documentation. There is a search bar at the top, which is powered by some\n-javascript and a statically-generated search index. No special web server is\n+JavaScript and a statically-generated search index. No special web server is\n required for the search.\n \n [sundown]: https://github.com/vmg/sundown/\n@@ -108,7 +108,7 @@ code, the `ignore` string can be added to the three-backtick form of markdown\n code block.\n \n     /**\n-    # nested codefences confuse sundown => indentation + comment to\n+    # nested code fences confuse sundown => indentation + comment to\n     #  avoid failing tests\n     ```\n     // This is a testable code block\n@@ -126,7 +126,7 @@ You can specify that the test's execution should fail with the `should_fail`\n directive.\n \n     /**\n-    # nested codefences confuse sundown => indentation + comment to\n+    # nested code fences confuse sundown => indentation + comment to\n     #  avoid failing tests\n     ```should_fail\n     // This code block is expected to generate a failure when run\n@@ -138,7 +138,7 @@ You can specify that the code block should be compiled but not run with the\n `no_run` directive.\n \n     /**\n-    # nested codefences confuse sundown => indentation + comment to\n+    # nested code fences confuse sundown => indentation + comment to\n     #  avoid failing tests\n     ```no_run\n     // This code will be compiled but not executed\n@@ -153,7 +153,7 @@ testing the code block (NB. the space after the `#` is required, so\n that one can still write things like `#[deriving(Eq)]`).\n \n     /**\n-    # nested codefences confuse sundown => indentation + comment to\n+    # nested code fences confuse sundown => indentation + comment to\n     #  avoid failing tests\n     ```rust\n     # /!\\ The three following lines are comments, which are usually stripped off by\n@@ -162,7 +162,7 @@ that one can still write things like `#[deriving(Eq)]`).\n     # these first five lines but a non breakable one.\n     #\n     #\u00a0// showing 'fib' in this documentation would just be tedious and detracts from\n-    #\u00a0// what's actualy being documented.\n+    #\u00a0// what's actually being documented.\n     #\u00a0fn fib(n: int) { n + 2 }\n \n     do spawn { fib(200); }\n@@ -190,7 +190,7 @@ $ rustdoc --test lib.rs --test-args '--help'\n ~~~\n \n When testing a library, code examples will often show how functions are used,\n-and this code often requires `use`-ing paths from the crate. To accomodate this,\n+and this code often requires `use`-ing paths from the crate. To accommodate this,\n rustdoc will implicitly add `extern crate <crate>;` where `<crate>` is the name of\n the crate being tested to the top of each code example. This means that rustdoc\n must be able to find a compiled version of the library crate being tested. Extra"}, {"sha": "5abe96b1acc46133218e09b1acf550f53fff1822", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -83,7 +83,7 @@\n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n-#[allow(missing_doc)];\n+#[deny(missing_doc)];\n #[allow(deprecated_owned_vector)];\n \n #[feature(globs, phase)];"}, {"sha": "94965e7e0dc3f1d8d7009dd5cf51e17ce614caa9", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -186,7 +186,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     });\n \n     if sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0 {\n-        let mut stdout = io::stdout();\n+        let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         krate.encode(&mut json);\n     }\n@@ -261,7 +261,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n          front::assign_node_ids_and_map::assign_node_ids_and_map(sess, krate));\n \n     if sess.opts.debugging_opts & session::AST_JSON != 0 {\n-        let mut stdout = io::stdout();\n+        let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         krate.encode(&mut json);\n     }\n@@ -596,15 +596,15 @@ struct IdentifiedAnnotation;\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n     fn pre(&self,\n-           s: &mut pprust::State<IdentifiedAnnotation>,\n+           s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n-            s: &mut pprust::State<IdentifiedAnnotation>,\n+            s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeItem(item) => {\n@@ -634,15 +634,15 @@ struct TypedAnnotation {\n \n impl pprust::PpAnn for TypedAnnotation {\n     fn pre(&self,\n-           s: &mut pprust::State<TypedAnnotation>,\n+           s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n-            s: &mut pprust::State<TypedAnnotation>,\n+            s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::IoResult<()> {\n         let tcx = &self.analysis.ty_cx;\n         match node {"}, {"sha": "6d8029b1638c4df3459cc62872d95d26a46b49e9", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -95,10 +95,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.get().as_slice()));\n \n-        if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n+        if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n             match i.node {\n-                ast::ItemFn(_, purity, _, _, _)\n-                    if purity == ast::UnsafeFn => {\n+                ast::ItemFn(_, ast::UnsafeFn, _, _, _) => {\n                     let sess = self.cx.sess;\n                     sess.span_fatal(i.span,\n                                     \"unsafe functions cannot be used for \\\n@@ -109,7 +108,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.get(),\n-                        bench: is_bench_fn(i),\n+                        bench: is_bench_fn(&self.cx, i),\n                         ignore: is_ignored(&self.cx, i),\n                         should_fail: should_fail(i)\n                     };\n@@ -233,7 +232,7 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(i: @ast::Item) -> bool {\n+fn is_bench_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n     fn has_test_signature(i: @ast::Item) -> bool {\n@@ -254,6 +253,12 @@ fn is_bench_fn(i: @ast::Item) -> bool {\n         }\n     }\n \n+    if has_bench_attr && !has_test_signature(i) {\n+        let sess = cx.sess;\n+        sess.span_err(i.span, \"functions used as benches must have signature \\\n+                      `fn(&mut BenchHarness) -> ()`\");\n+    }\n+\n     return has_bench_attr && has_test_signature(i);\n }\n "}, {"sha": "b98f3f6fd5d484b740739af09547132df732a308", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -43,24 +43,22 @@ pub enum Visibility {\n     ProtectedVisibility = 2,\n }\n \n+// This enum omits the obsolete (and no-op) linkage types DLLImportLinkage,\n+// DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n+// LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n+// they've been removed in upstream LLVM commit r203866.\n pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,\n     LinkOnceAnyLinkage = 2,\n     LinkOnceODRLinkage = 3,\n-    LinkOnceODRAutoHideLinkage = 4,\n     WeakAnyLinkage = 5,\n     WeakODRLinkage = 6,\n     AppendingLinkage = 7,\n     InternalLinkage = 8,\n     PrivateLinkage = 9,\n-    DLLImportLinkage = 10,\n-    DLLExportLinkage = 11,\n     ExternalWeakLinkage = 12,\n-    GhostLinkage = 13,\n     CommonLinkage = 14,\n-    LinkerPrivateLinkage = 15,\n-    LinkerPrivateWeakLinkage = 16,\n }\n \n #[deriving(Clone)]"}, {"sha": "be49784cba1891438b5f491dd1e5640b4cee9dfb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -85,7 +85,7 @@ struct LoopScope<'a> {\n \n impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n     fn pre(&self,\n-           ps: &mut pprust::State<DataFlowContext<'a, O>>,\n+           ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n         let id = match node {\n             pprust::NodeExpr(expr) => expr.id,"}, {"sha": "7f6781096f5840af224dc4e5239432d9b9bcacfc", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -121,8 +121,6 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n         \"extern_weak\" => Some(lib::llvm::ExternalWeakLinkage),\n         \"external\" => Some(lib::llvm::ExternalLinkage),\n         \"internal\" => Some(lib::llvm::InternalLinkage),\n-        \"linker_private\" => Some(lib::llvm::LinkerPrivateLinkage),\n-        \"linker_private_weak\" => Some(lib::llvm::LinkerPrivateWeakLinkage),\n         \"linkonce\" => Some(lib::llvm::LinkOnceAnyLinkage),\n         \"linkonce_odr\" => Some(lib::llvm::LinkOnceODRLinkage),\n         \"private\" => Some(lib::llvm::PrivateLinkage),"}, {"sha": "f65c168f3829543d9099ccffbf8fe2ed144569dc", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -48,6 +48,8 @@ use util::ppaux::Repr;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n use std::vec_ng;\n+use collections::HashSet;\n+\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -478,7 +480,12 @@ fn convert_methods(ccx: &CrateCtxt,\n                    rcvr_visibility: ast::Visibility)\n {\n     let tcx = ccx.tcx;\n+    let mut seen_methods = HashSet::new();\n     for m in ms.iter() {\n+        if !seen_methods.insert(m.ident.repr(ccx.tcx)) {\n+            tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n+        }\n+\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n         let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n                                                          num_rcvr_ty_params);"}, {"sha": "f5f755751133cad9e6c461081fc8ce1cd4db17d1", "filename": "src/librustdoc/flock.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Simple file-locking apis for each OS.\n+//!\n+//! This is not meant to be in the standard library, it does nothing with\n+//! green/native threading. This is just a bare-bones enough solution for\n+//! librustdoc, it is not production quality at all.\n+\n+#[allow(non_camel_case_types)];\n+\n+pub use self::imp::Lock;\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::libc;\n+\n+    #[cfg(target_os = \"linux\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+\n+            // not actually here, but brings in line with freebsd\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_WRLCK: libc::c_short = 1;\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_SETLK: libc::c_int = 6;\n+        pub static F_SETLKW: libc::c_int = 7;\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_WRLCK: libc::c_short = 3;\n+        pub static F_SETLK: libc::c_int = 12;\n+        pub static F_SETLKW: libc::c_int = 13;\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    mod os {\n+        use std::libc;\n+\n+        pub struct flock {\n+            l_start: libc::off_t,\n+            l_len: libc::off_t,\n+            l_pid: libc::pid_t,\n+            l_type: libc::c_short,\n+            l_whence: libc::c_short,\n+\n+            // not actually here, but brings in line with freebsd\n+            l_sysid: libc::c_int,\n+        }\n+\n+        pub static F_UNLCK: libc::c_short = 2;\n+        pub static F_WRLCK: libc::c_short = 3;\n+        pub static F_SETLK: libc::c_int = 8;\n+        pub static F_SETLKW: libc::c_int = 9;\n+    }\n+\n+    pub struct Lock {\n+        priv fd: libc::c_int,\n+    }\n+\n+    impl Lock {\n+        pub fn new(p: &Path) -> Lock {\n+            let fd = p.with_c_str(|s| unsafe {\n+                libc::open(s, libc::O_RDWR | libc::O_CREAT, libc::S_IRWXU)\n+            });\n+            assert!(fd > 0);\n+            let flock = os::flock {\n+                l_start: 0,\n+                l_len: 0,\n+                l_pid: 0,\n+                l_whence: libc::SEEK_SET as libc::c_short,\n+                l_type: os::F_WRLCK,\n+                l_sysid: 0,\n+            };\n+            let ret = unsafe {\n+                libc::fcntl(fd, os::F_SETLKW, &flock as *os::flock)\n+            };\n+            if ret == -1 {\n+                unsafe { libc::close(fd); }\n+                fail!(\"could not lock `{}`\", p.display())\n+            }\n+            Lock { fd: fd }\n+        }\n+    }\n+\n+    impl Drop for Lock {\n+        fn drop(&mut self) {\n+            let flock = os::flock {\n+                l_start: 0,\n+                l_len: 0,\n+                l_pid: 0,\n+                l_whence: libc::SEEK_SET as libc::c_short,\n+                l_type: os::F_UNLCK,\n+                l_sysid: 0,\n+            };\n+            unsafe {\n+                libc::fcntl(self.fd, os::F_SETLK, &flock as *os::flock);\n+                libc::close(self.fd);\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use std::libc;\n+    use std::mem;\n+    use std::os::win32::as_utf16_p;\n+    use std::ptr;\n+\n+    static LOCKFILE_EXCLUSIVE_LOCK: libc::DWORD = 0x00000002;\n+\n+    extern \"system\" {\n+        fn LockFileEx(hFile: libc::HANDLE,\n+                      dwFlags: libc::DWORD,\n+                      dwReserved: libc::DWORD,\n+                      nNumberOfBytesToLockLow: libc::DWORD,\n+                      nNumberOfBytesToLockHigh: libc::DWORD,\n+                      lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+        fn UnlockFileEx(hFile: libc::HANDLE,\n+                        dwReserved: libc::DWORD,\n+                        nNumberOfBytesToLockLow: libc::DWORD,\n+                        nNumberOfBytesToLockHigh: libc::DWORD,\n+                        lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n+    }\n+\n+    pub struct Lock {\n+        priv handle: libc::HANDLE,\n+    }\n+\n+    impl Lock {\n+        pub fn new(p: &Path) -> Lock {\n+            let handle = as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n+                libc::CreateFileW(p, libc::GENERIC_READ, 0, ptr::mut_null(),\n+                                  libc::CREATE_ALWAYS,\n+                                  libc::FILE_ATTRIBUTE_NORMAL,\n+                                  ptr::mut_null())\n+            });\n+            assert!(handle as uint != libc::INVALID_HANDLE_VALUE as uint);\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            let ret = unsafe {\n+                LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n+                           &mut overlapped)\n+            };\n+            if ret == 0 {\n+                unsafe { libc::CloseHandle(handle); }\n+                fail!(\"could not lock `{}`\", p.display())\n+            }\n+            Lock { handle: handle }\n+        }\n+    }\n+\n+    impl Drop for Lock {\n+        fn drop(&mut self) {\n+            let mut overlapped: libc::OVERLAPPED = unsafe { mem::init() };\n+            unsafe {\n+                UnlockFileEx(self.handle, 0, 100, 0, &mut overlapped);\n+                libc::CloseHandle(self.handle);\n+            }\n+        }\n+    }\n+}"}, {"sha": "317571ebc3ff6b078ec65db0dfcac3e5dd51b78d", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -37,7 +37,7 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <link href='http://fonts.googleapis.com/css?family=Oswald:700|Inconsolata:400,700'\n           rel='stylesheet' type='text/css'>\n-    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}{krate}/main.css\\\">\n+    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{root_path}main.css\\\">\n \n     {favicon, select, none{} other{<link rel=\\\"shortcut icon\\\" href=\\\"#\\\" />}}\n </head>\n@@ -74,13 +74,6 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n \n     <section class=\\\"footer\\\"></section>\n \n-    <script>\n-        var rootPath = \\\"{root_path}\\\";\n-    </script>\n-    <script src=\\\"{root_path}{krate}/jquery.js\\\"></script>\n-    <script src=\\\"{root_path}{krate}/search-index.js\\\"></script>\n-    <script src=\\\"{root_path}{krate}/main.js\\\"></script>\n-\n     <div id=\\\"help\\\" class=\\\"hidden\\\">\n         <div class=\\\"shortcuts\\\">\n             <h1>Keyboard shortcuts</h1>\n@@ -111,6 +104,14 @@ pub fn render<T: fmt::Show, S: fmt::Show>(\n             </p>\n         </div>\n     </div>\n+\n+    <script>\n+        var rootPath = \\\"{root_path}\\\";\n+        var currentCrate = \\\"{krate}\\\";\n+    </script>\n+    <script src=\\\"{root_path}jquery.js\\\"></script>\n+    <script src=\\\"{root_path}main.js\\\"></script>\n+    <script async src=\\\"{root_path}search-index.js\\\"></script>\n </body>\n </html>\n \","}, {"sha": "26723482595cd5d9f9adff88150dbd09ad84beaa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 64, "deletions": 30, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -36,7 +36,7 @@\n use std::fmt;\n use std::local_data;\n use std::io;\n-use std::io::{fs, File, BufferedWriter};\n+use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n use std::str;\n use std::vec;\n use std::vec_ng::Vec;\n@@ -283,48 +283,75 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         };\n     }\n \n-    // Add all the static files\n-    let mut dst = cx.dst.join(krate.name.as_slice());\n-    try!(mkdir(&dst));\n-    try!(write(dst.join(\"jquery.js\"),\n-                 include_str!(\"static/jquery-2.1.0.min.js\")));\n-    try!(write(dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n-    try!(write(dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n-    try!(write(dst.join(\"normalize.css\"),\n-                 include_str!(\"static/normalize.css\")));\n-\n     // Publish the search index\n-    {\n-        dst.push(\"search-index.js\");\n-        let mut w = BufferedWriter::new(File::create(&dst).unwrap());\n-        let w = &mut w as &mut Writer;\n-        try!(write!(w, \"var searchIndex = [\"));\n+    let index = {\n+        let mut w = MemWriter::new();\n+        try!(write!(&mut w, \"searchIndex['{}'] = [\", krate.name));\n         for (i, item) in cache.search_index.iter().enumerate() {\n             if i > 0 {\n-                try!(write!(w, \",\"));\n+                try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n-                          item.ty, item.name, item.path,\n-                          item.desc.to_json().to_str()));\n+            try!(write!(&mut w, \"\\\\{ty:\\\"{}\\\",name:\\\"{}\\\",path:\\\"{}\\\",desc:{}\",\n+                        item.ty, item.name, item.path,\n+                        item.desc.to_json().to_str()));\n             match item.parent {\n                 Some(id) => {\n-                    try!(write!(w, \",parent:'{}'\", id));\n+                    try!(write!(&mut w, \",parent:'{}'\", id));\n                 }\n                 None => {}\n             }\n-            try!(write!(w, \"\\\\}\"));\n+            try!(write!(&mut w, \"\\\\}\"));\n         }\n-        try!(write!(w, \"];\"));\n-        try!(write!(w, \"var allPaths = \\\\{\"));\n+        try!(write!(&mut w, \"];\"));\n+        try!(write!(&mut w, \"allPaths['{}'] = \\\\{\", krate.name));\n         for (i, (&id, &(ref fqp, short))) in cache.paths.iter().enumerate() {\n             if i > 0 {\n-                try!(write!(w, \",\"));\n+                try!(write!(&mut w, \",\"));\n             }\n-            try!(write!(w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n-                          id, short, *fqp.last().unwrap()));\n+            try!(write!(&mut w, \"'{}':\\\\{type:'{}',name:'{}'\\\\}\",\n+                        id, short, *fqp.last().unwrap()));\n         }\n-        try!(write!(w, \"\\\\};\"));\n-        try!(w.flush());\n+        try!(write!(&mut w, \"\\\\};\"));\n+\n+        str::from_utf8_owned(w.unwrap()).unwrap()\n+    };\n+\n+    // Write out the shared files. Note that these are shared among all rustdoc\n+    // docs placed in the output directory, so this needs to be a synchronized\n+    // operation with respect to all other rustdocs running around.\n+    {\n+        try!(mkdir(&cx.dst));\n+        let _lock = ::flock::Lock::new(&cx.dst.join(\".lock\"));\n+\n+        // Add all the static files. These may already exist, but we just\n+        // overwrite them anyway to make sure that they're fresh and up-to-date.\n+        try!(write(cx.dst.join(\"jquery.js\"),\n+                   include_str!(\"static/jquery-2.1.0.min.js\")));\n+        try!(write(cx.dst.join(\"main.js\"), include_str!(\"static/main.js\")));\n+        try!(write(cx.dst.join(\"main.css\"), include_str!(\"static/main.css\")));\n+        try!(write(cx.dst.join(\"normalize.css\"),\n+                   include_str!(\"static/normalize.css\")));\n+\n+        // Update the search index\n+        let dst = cx.dst.join(\"search-index.js\");\n+        let mut all_indexes = Vec::new();\n+        all_indexes.push(index);\n+        if dst.exists() {\n+            for line in BufferedReader::new(File::open(&dst)).lines() {\n+                let line = try!(line);\n+                if !line.starts_with(\"searchIndex\") { continue }\n+                if line.starts_with(format!(\"searchIndex['{}']\", krate.name)) {\n+                    continue\n+                }\n+                all_indexes.push(line);\n+            }\n+        }\n+        let mut w = try!(File::create(&dst));\n+        try!(writeln!(&mut w, r\"var searchIndex = \\{\\}; var allPaths = \\{\\};\"));\n+        for index in all_indexes.iter() {\n+            try!(writeln!(&mut w, \"{}\", *index));\n+        }\n+        try!(writeln!(&mut w, \"initSearch(searchIndex);\"));\n     }\n \n     // Render all source files (this may turn into a giant no-op)\n@@ -463,6 +490,13 @@ impl<'a> SourceCollector<'a> {\n         };\n         let contents = str::from_utf8_owned(contents).unwrap();\n \n+        // Remove the utf-8 BOM if any\n+        let contents = if contents.starts_with(\"\\ufeff\") {\n+            contents.as_slice().slice_from(3)\n+        } else {\n+            contents.as_slice()\n+        };\n+\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n@@ -482,7 +516,7 @@ impl<'a> SourceCollector<'a> {\n             root_path: root_path,\n         };\n         try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n-                              &page, &(\"\"), &Source(contents.as_slice())));\n+                              &page, &(\"\"), &Source(contents)));\n         try!(w.flush());\n         return Ok(());\n     }"}, {"sha": "ffdf67e56cf7fd67a84db1442c922ed5f745355a", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 125, "deletions": 119, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /*jslint browser: true, es5: true */\n-/*globals $: true, searchIndex: true, rootPath: true, allPaths: true */\n+/*globals $: true, rootPath: true, allPaths: true */\n \n (function() {\n     \"use strict\";\n@@ -23,7 +23,8 @@\n             map(function(s) {\n                 var pair = s.split(\"=\");\n                 params[decodeURIComponent(pair[0])] =\n-                    typeof pair[1] === \"undefined\" ? null : decodeURIComponent(pair[1]);\n+                    typeof pair[1] === \"undefined\" ?\n+                            null : decodeURIComponent(pair[1]);\n             });\n         return params;\n     }\n@@ -111,8 +112,9 @@\n         document.location.href = url;\n     });\n \n-    function initSearch(searchIndex) {\n-        var currentResults, index, params = getQueryStringParams();\n+    function initSearch(rawSearchIndex) {\n+        var currentResults, index, searchIndex;\n+        var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n         // but only if the input bar is empty. This avoid the obnoxious issue\n@@ -126,7 +128,8 @@\n          * Executes the query and builds an index of results\n          * @param  {[Object]} query     [The user query]\n          * @param  {[type]} max         [The maximum results returned]\n-         * @param  {[type]} searchWords [The list of search words to query against]\n+         * @param  {[type]} searchWords [The list of search words to query\n+         *                               against]\n          * @return {[type]}             [A search index of results]\n          */\n         function execQuery(query, max, searchWords) {\n@@ -148,7 +151,9 @@\n \n             // quoted values mean literal search\n             bb = searchWords.length;\n-            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") && val.charAt(val.length - 1) === val.charAt(0)) {\n+            if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n+                val.charAt(val.length - 1) === val.charAt(0))\n+            {\n                 val = val.substr(1, val.length - 2);\n                 for (aa = 0; aa < bb; aa += 1) {\n                     if (searchWords[aa] === val) {\n@@ -166,7 +171,10 @@\n                 val = val.replace(/\\_/g, \"\");\n                 for (var i = 0; i < split.length; i++) {\n                     for (aa = 0; aa < bb; aa += 1) {\n-                        if (searchWords[aa].indexOf(split[i]) > -1 || searchWords[aa].indexOf(val) > -1 || searchWords[aa].replace(/_/g, \"\").indexOf(val) > -1) {\n+                        if (searchWords[aa].indexOf(split[i]) > -1 ||\n+                            searchWords[aa].indexOf(val) > -1 ||\n+                            searchWords[aa].replace(/_/g, \"\").indexOf(val) > -1)\n+                        {\n                             // filter type: ... queries\n                             if (!typeFilter || typeFilter === searchIndex[aa].ty) {\n                                 results.push([aa, searchWords[aa].replace(/_/g, \"\").indexOf(val)]);\n@@ -185,6 +193,7 @@\n                 results[aa].push(searchIndex[results[aa][0]].path);\n                 results[aa].push(searchIndex[results[aa][0]].name);\n                 results[aa].push(searchIndex[results[aa][0]].parent);\n+                results[aa].push(searchIndex[results[aa][0]].crate);\n             }\n             // if there are no results then return to default and fail\n             if (results.length === 0) {\n@@ -193,7 +202,8 @@\n \n             // sort by exact match\n             results.sort(function search_complete_sort0(aaa, bbb) {\n-                if (searchWords[aaa[0]] === valLower && searchWords[bbb[0]] !== valLower) {\n+                if (searchWords[aaa[0]] === valLower &&\n+                    searchWords[bbb[0]] !== valLower) {\n                     return 1;\n                 }\n             });\n@@ -207,7 +217,8 @@\n             // second sorting attempt\n             // sort by item name\n             results.sort(function search_complete_sort1(aaa, bbb) {\n-                if (searchWords[aaa[0]].length === searchWords[bbb[0]].length && searchWords[aaa[0]] > searchWords[bbb[0]]) {\n+                if (searchWords[aaa[0]].length === searchWords[bbb[0]].length &&\n+                    searchWords[aaa[0]] > searchWords[bbb[0]]) {\n                     return 1;\n                 }\n             });\n@@ -223,29 +234,34 @@\n             // fourth sorting attempt\n             // sort by type\n             results.sort(function search_complete_sort3(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] && aaa[2] > bbb[2]) {\n+                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n+                    aaa[2] > bbb[2]) {\n                     return 1;\n                 }\n             });\n             // fifth sorting attempt\n             // sort by path\n             results.sort(function search_complete_sort4(aaa, bbb) {\n-                if (searchWords[aaa[0]] === searchWords[bbb[0]] && aaa[2] === bbb[2] && aaa[3] > bbb[3]) {\n+                if (searchWords[aaa[0]] === searchWords[bbb[0]] &&\n+                    aaa[2] === bbb[2] && aaa[3] > bbb[3]) {\n                     return 1;\n                 }\n             });\n             // sixth sorting attempt\n             // remove duplicates, according to the data provided\n             for (aa = results.length - 1; aa > 0; aa -= 1) {\n-                if (searchWords[results[aa][0]] === searchWords[results[aa - 1][0]] && results[aa][2] === results[aa - 1][2] && results[aa][3] === results[aa - 1][3]) {\n+                if (searchWords[results[aa][0]] === searchWords[results[aa - 1][0]] &&\n+                    results[aa][2] === results[aa - 1][2] &&\n+                    results[aa][3] === results[aa - 1][3])\n+                {\n                     results[aa][0] = -1;\n                 }\n             }\n             for (var i = 0; i < results.length; i++) {\n                 var result = results[i],\n                     name = result[4].toLowerCase(),\n                     path = result[3].toLowerCase(),\n-                    parent = allPaths[result[5]];\n+                    parent = allPaths[result[6]][result[5]];\n \n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n@@ -256,11 +272,14 @@\n         }\n \n         /**\n-         * Validate performs the following boolean logic. For example: \"File::open\" will give\n-         * IF A PARENT EXISTS => (\"file\" && \"open\") exists in (name || path || parent)\n-         * OR => (\"file\" && \"open\") exists in (name || path )\n+         * Validate performs the following boolean logic. For example:\n+         * \"File::open\" will give IF A PARENT EXISTS => (\"file\" && \"open\")\n+         * exists in (name || path || parent) OR => (\"file\" && \"open\") exists in\n+         * (name || path )\n+         *\n+         * This could be written functionally, but I wanted to minimise\n+         * functions on stack.\n          *\n-         * This could be written functionally, but I wanted to minimise functions on stack.\n          * @param  {[string]} name   [The name of the result]\n          * @param  {[string]} path   [The path of the result]\n          * @param  {[string]} keys   [The keys to be used ([\"file\", \"open\"])]\n@@ -273,17 +292,26 @@\n             //if there is a parent, then validate against parent\n             if (parent !== undefined) {\n                 for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the path, name or parent\n-                    if ((validate) && (name.toLowerCase().indexOf(keys[i]) > -1 || path.toLowerCase().indexOf(keys[i]) > -1 || parent.name.toLowerCase().indexOf(keys[i]) > -1)) {\n+                    // if previous keys are valid and current key is in the\n+                    // path, name or parent\n+                    if ((validate) &&\n+                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         parent.name.toLowerCase().indexOf(keys[i]) > -1))\n+                    {\n                         validate = true;\n                     } else {\n                         validate = false;\n                     }\n                 }\n             } else {\n                 for (var i = 0; i < keys.length; i++) {\n-                    // if previous keys are valid and current key is in the path, name\n-                    if ((validate) && (name.toLowerCase().indexOf(keys[i]) > -1 || path.toLowerCase().indexOf(keys[i]) > -1)) {\n+                    // if previous keys are valid and current key is in the\n+                    // path, name\n+                    if ((validate) &&\n+                        (name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                         path.toLowerCase().indexOf(keys[i]) > -1))\n+                    {\n                         validate = true;\n                     } else {\n                         validate = false;\n@@ -298,7 +326,10 @@\n \n             matches = query.match(/^(fn|mod|str(uct)?|enum|trait|t(ype)?d(ef)?)\\s*:\\s*/i);\n             if (matches) {\n-                type = matches[1].replace(/^td$/, 'typedef').replace(/^str$/, 'struct').replace(/^tdef$/, 'typedef').replace(/^typed$/, 'typedef');\n+                type = matches[1].replace(/^td$/, 'typedef')\n+                                 .replace(/^str$/, 'struct')\n+                                 .replace(/^tdef$/, 'typedef')\n+                                 .replace(/^typed$/, 'typedef');\n                 query = query.substring(matches[0].length);\n             }\n \n@@ -314,7 +345,6 @@\n \n             $results.on('click', function() {\n                 var dst = $(this).find('a')[0];\n-                console.log(window.location.pathname, dst.pathname);\n                 if (window.location.pathname == dst.pathname) {\n                     $('#search').addClass('hidden');\n                     $('#main').removeClass('hidden');\n@@ -362,7 +392,8 @@\n             var output, shown, query = getQuery();\n \n             currentResults = query.id;\n-            output = '<h1>Results for ' + query.query + (query.type ? ' (type: ' + query.type + ')' : '') + '</h1>';\n+            output = '<h1>Results for ' + query.query +\n+                    (query.type ? ' (type: ' + query.type + ')' : '') + '</h1>';\n             output += '<table class=\"search-results\">';\n \n             if (results.length > 0) {\n@@ -394,7 +425,7 @@\n                             '/index.html\" class=\"' + type +\n                             '\">' + name + '</a>';\n                     } else if (item.parent !== undefined) {\n-                        var myparent = allPaths[item.parent];\n+                        var myparent = allPaths[item.crate][item.parent];\n                         var anchor = '#' + type + '.' + name;\n                         output += item.path + '::' + myparent.name +\n                             '::<a href=\"' + rootPath +\n@@ -449,13 +480,15 @@\n                 return;\n             }\n \n-            // Because searching is incremental by character, only the most recent search query\n-            // is added to the browser history.\n+            // Because searching is incremental by character, only the most\n+            // recent search query is added to the browser history.\n             if (browserSupportsHistoryApi()) {\n                 if (!history.state && !params.search) {\n-                    history.pushState(query, \"\", \"?search=\" + encodeURIComponent(query.query));\n+                    history.pushState(query, \"\", \"?search=\" +\n+                                                encodeURIComponent(query.query));\n                 } else {\n-                    history.replaceState(query, \"\", \"?search=\" + encodeURIComponent(query.query));\n+                    history.replaceState(query, \"\", \"?search=\" +\n+                                                encodeURIComponent(query.query));\n                 }\n             }\n \n@@ -472,91 +505,33 @@\n                 }\n             }\n \n-            // TODO add sorting capability through this function?\n-            //\n-            //            // the handler for the table heading filtering\n-            //            filterdraw = function search_complete_filterdraw(node) {\n-            //                var name = \"\",\n-            //                    arrow = \"\",\n-            //                    op = 0,\n-            //                    tbody = node.parentNode.parentNode.nextSibling,\n-            //                    anchora = {},\n-            //                    tra = {},\n-            //                    tha = {},\n-            //                    td1a = {},\n-            //                    td2a = {},\n-            //                    td3a = {},\n-            //                    aaa = 0,\n-            //                    bbb = 0;\n-            //\n-            //                // the 4 following conditions set the rules for each\n-            //                // table heading\n-            //                if (node === ths[0]) {\n-            //                    op = 0;\n-            //                    name = \"name\";\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[1]) {\n-            //                    op = 1;\n-            //                    name = \"type\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[2]) {\n-            //                    op = 2;\n-            //                    name = \"path\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[3].innerHTML = ths[3].innerHTML.split(\" \")[0];\n-            //                }\n-            //                if (node === ths[3]) {\n-            //                    op = 3;\n-            //                    name = \"description\";\n-            //                    ths[0].innerHTML = ths[0].innerHTML.split(\" \")[0];\n-            //                    ths[1].innerHTML = ths[1].innerHTML.split(\" \")[0];\n-            //                    ths[2].innerHTML = ths[2].innerHTML.split(\" \")[0];\n-            //                }\n-            //\n-            //                // ascending or descending search\n-            //                arrow = node.innerHTML.split(\" \")[1];\n-            //                if (arrow === undefined || arrow === \"\\u25b2\") {\n-            //                    arrow = \"\\u25bc\";\n-            //                } else {\n-            //                    arrow = \"\\u25b2\";\n-            //                }\n-            //\n-            //                // filter the data\n-            //                filterdata.sort(function search_complete_filterDraw_sort(xx, yy) {\n-            //                    if ((arrow === \"\\u25b2\" && xx[op].toLowerCase() < yy[op].toLowerCase()) || (arrow === \"\\u25bc\" && xx[op].toLowerCase() > yy[op].toLowerCase())) {\n-            //                        return 1;\n-            //                    }\n-            //                });\n-            //            };\n-\n             showResults(results);\n         }\n \n-        function buildIndex(searchIndex) {\n-            var len = searchIndex.length,\n-                i = 0,\n-                searchWords = [];\n-\n-            // before any analysis is performed lets gather the search terms to\n-            // search against apart from the rest of the data.  This is a quick\n-            // operation that is cached for the life of the page state so that\n-            // all other search operations have access to this cached data for\n-            // faster analysis operations\n-            for (i = 0; i < len; i += 1) {\n-                if (typeof searchIndex[i].name === \"string\") {\n-                    searchWords.push(searchIndex[i].name.toLowerCase());\n-                } else {\n-                    searchWords.push(\"\");\n+        function buildIndex(rawSearchIndex) {\n+            searchIndex = [];\n+            var searchWords = [];\n+            for (var crate in rawSearchIndex) {\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                var len = rawSearchIndex[crate].length;\n+                var i = 0;\n+\n+                // before any analysis is performed lets gather the search terms to\n+                // search against apart from the rest of the data.  This is a quick\n+                // operation that is cached for the life of the page state so that\n+                // all other search operations have access to this cached data for\n+                // faster analysis operations\n+                for (i = 0; i < len; i += 1) {\n+                    rawSearchIndex[crate][i].crate = crate;\n+                    searchIndex.push(rawSearchIndex[crate][i]);\n+                    if (typeof rawSearchIndex[crate][i].name === \"string\") {\n+                        var word = rawSearchIndex[crate][i].name.toLowerCase();\n+                        searchWords.push(word);\n+                    } else {\n+                        searchWords.push(\"\");\n+                    }\n                 }\n             }\n-\n             return searchWords;\n         }\n \n@@ -567,37 +542,68 @@\n                 clearTimeout(keyUpTimeout);\n                 keyUpTimeout = setTimeout(search, 100);\n             });\n-            // Push and pop states are used to add search results to the browser history.\n+\n+            // Push and pop states are used to add search results to the browser\n+            // history.\n             if (browserSupportsHistoryApi()) {\n                 $(window).on('popstate', function(e) {\n                     var params = getQueryStringParams();\n-                    // When browsing back from search results the main page visibility must be reset.\n+                    // When browsing back from search results the main page\n+                    // visibility must be reset.\n                     if (!params.search) {\n                         $('#main.content').removeClass('hidden');\n                         $('#search.content').addClass('hidden');\n                     }\n-                    // When browsing forward to search results the previous search will be repeated,\n-                    // so the currentResults are cleared to ensure the search is successful.\n+                    // When browsing forward to search results the previous\n+                    // search will be repeated, so the currentResults are\n+                    // cleared to ensure the search is successful.\n                     currentResults = null;\n                     // Synchronize search bar with query string state and\n                     // perform the search, but don't empty the bar if there's\n                     // nothing there.\n                     if (params.search !== undefined) {\n                         $('.search-input').val(params.search);\n                     }\n-                    // Some browsers fire 'onpopstate' for every page load (Chrome), while others fire the\n-                    // event only when actually popping a state (Firefox), which is why search() is called\n-                    // both here and at the end of the startSearch() function.\n+                    // Some browsers fire 'onpopstate' for every page load\n+                    // (Chrome), while others fire the event only when actually\n+                    // popping a state (Firefox), which is why search() is\n+                    // called both here and at the end of the startSearch()\n+                    // function.\n                     search();\n                 });\n             }\n             search();\n         }\n \n-        index = buildIndex(searchIndex);\n+        index = buildIndex(rawSearchIndex);\n         startSearch();\n-    }\n \n-    initSearch(searchIndex);\n+        // Draw a convenient sidebar of known crates if we have a listing\n+        if (rootPath == '../') {\n+            console.log('here');\n+            var sidebar = $('.sidebar');\n+            var div = $('<div>').attr('class', 'block crate');\n+            div.append($('<h2>').text('Crates'));\n+\n+            var crates = [];\n+            for (var crate in rawSearchIndex) {\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                crates.push(crate);\n+            }\n+            crates.sort();\n+            for (var i = 0; i < crates.length; i++) {\n+                var klass = 'crate';\n+                if (crates[i] == window.currentCrate) {\n+                    klass += ' current';\n+                }\n+                div.append($('<a>', {'href': '../' + crates[i] + '/index.html',\n+                                    'class': klass}).text(crates[i]));\n+                div.append($('<br>'));\n+            }\n+            sidebar.append(div);\n+        }\n+    }\n \n+    window.initSearch = initSearch;\n }());\n+"}, {"sha": "6dc3c2073f176ff6674c681c3de387d29ad4438c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -52,6 +52,7 @@ pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n pub mod test;\n+mod flock;\n \n pub static SCHEMA_VERSION: &'static str = \"0.8.1\";\n "}, {"sha": "9b93a62304c8832daa96e4ab51c91a4891caccd0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -464,8 +464,20 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        use std::str::from_utf8;\n         if idx != 0 { try!(write!(self.wr, \",\")) }\n-        f(self)\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = Encoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n@@ -659,13 +671,25 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n     fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        use std::str::from_utf8;\n         if idx == 0 {\n             try!(write!(self.wr, \"\\n\"));\n         } else {\n             try!(write!(self.wr, \",\\n\"));\n         }\n         try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = PrettyEncoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n         f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n     }\n \n     fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n@@ -1306,13 +1330,19 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_f64(&mut self) -> f64 {\n+        use std::from_str::FromStr;\n         debug!(\"read_f64\");\n         match self.stack.pop().unwrap() {\n             Number(f) => f,\n+            String(s) => {\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // is going to have a string here, as per JSON spec..\n+                FromStr::from_str(s).unwrap()\n+            },\n             value => self.expected(\"number\", &value)\n         }\n     }\n-    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n+\n     fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n \n     fn read_char(&mut self) -> char {\n@@ -2519,4 +2549,57 @@ mod tests {\n         let expected_null = ();\n         assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n     }\n+\n+    #[test]\n+    fn test_encode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_prettyencode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n+        use collections::HashMap;\n+        use Decodable;\n+        let json_str = \"{\\\"1\\\":true}\";\n+        let json_obj = match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            Ok(o) => o\n+        };\n+        let mut decoder = Decoder::new(json_obj);\n+        let hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n+    }\n }"}, {"sha": "3ca08797dd1fe259ead6ccf81cbb6bbc57386105", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -20,6 +20,7 @@ use cast;\n use fmt;\n use iter::Iterator;\n use vec::{ImmutableVector, MutableVector, Vector};\n+use vec_ng::Vec;\n use option::{Option, Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n@@ -305,6 +306,14 @@ impl IntoStr for ~[Ascii] {\n     }\n }\n \n+impl IntoStr for Vec<Ascii> {\n+    #[inline]\n+    fn into_str(self) -> ~str {\n+        let v: ~[Ascii] = self.move_iter().collect();\n+        unsafe { cast::transmute(v) }\n+    }\n+}\n+\n /// Trait to convert to an owned byte array by consuming self\n pub trait IntoBytes {\n     /// Converts to an owned byte array by consuming self\n@@ -473,13 +482,18 @@ mod tests {\n     use super::*;\n     use str::from_char;\n     use char::from_u32;\n+    use vec_ng::Vec;\n \n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (~[$($e:expr),*]) => (~[$(Ascii{chr:$e}),*]);\n     )\n \n+    macro_rules! vec2ascii (\n+        ($($e:expr),*) => (Vec::from_slice([$(Ascii{chr:$e}),*]));\n+    )\n+\n     #[test]\n     fn test_ascii() {\n         assert_eq!(65u8.to_ascii().to_byte(), 65u8);\n@@ -535,6 +549,17 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_ascii_vec_ng() {\n+        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_lower()).into_str(), ~\"abcdef&?#\");\n+        assert_eq!(Vec::from_slice(\"abCDef&?#\".to_ascii().to_upper()).into_str(), ~\"ABCDEF&?#\");\n+\n+        assert_eq!(Vec::from_slice(\"\".to_ascii().to_lower()).into_str(), ~\"\");\n+        assert_eq!(Vec::from_slice(\"YMCA\".to_ascii().to_lower()).into_str(), ~\"ymca\");\n+        assert_eq!(Vec::from_slice(\"abcDEFxyz:.;\".to_ascii().to_upper()).into_str(),\n+                   ~\"ABCDEFXYZ:.;\");\n+    }\n+\n     #[test]\n     fn test_owned_ascii_vec() {\n         assert_eq!((~\"( ;\").into_ascii(), v2ascii!(~[40, 32, 59]));\n@@ -550,6 +575,7 @@ mod tests {\n     #[test]\n     fn test_ascii_into_str() {\n         assert_eq!(v2ascii!(~[40, 32, 59]).into_str(), ~\"( ;\");\n+        assert_eq!(vec2ascii!(40, 32, 59).into_str(), ~\"( ;\");\n     }\n \n     #[test]"}, {"sha": "cf5a9c6711c6202f354521d326525ca02e806c4f", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -45,8 +45,9 @@ impl<T: Clone> Clone for ~T {\n     fn clone(&self) -> ~T { ~(**self).clone() }\n \n     /// Perform copy-assignment from `source` by reusing the existing allocation.\n+    #[inline]\n     fn clone_from(&mut self, source: &~T) {\n-        **self = (**source).clone()\n+        (**self).clone_from(&(**source));\n     }\n }\n "}, {"sha": "42221f074491d0cd6c3be0a1654a86523ce2f720", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -3643,7 +3643,7 @@ pub mod funcs {\n                 pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 pub fn creat(path: *c_char, mode: mode_t) -> c_int;\n-                pub fn fcntl(fd: c_int, cmd: c_int) -> c_int;\n+                pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;\n             }\n         }\n "}, {"sha": "849e2a79e08b90bd60e7d6d811fe2b3c71aeed78", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// So we don't have to document the actual methods on the traits.\n-#[allow(missing_doc)];\n-\n /*!\n  *\n  * Traits representing built-in operators, useful for overloading\n@@ -83,6 +80,7 @@\n  */\n #[lang=\"drop\"]\n pub trait Drop {\n+    /// The `drop` method, called when the value goes out of scope.\n     fn drop(&mut self);\n }\n \n@@ -112,6 +110,7 @@ pub trait Drop {\n  */\n #[lang=\"add\"]\n pub trait Add<RHS,Result> {\n+    /// The method for the `+` operator\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n@@ -141,6 +140,7 @@ pub trait Add<RHS,Result> {\n  */\n #[lang=\"sub\"]\n pub trait Sub<RHS,Result> {\n+    /// The method for the `-` operator\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n@@ -170,6 +170,7 @@ pub trait Sub<RHS,Result> {\n  */\n #[lang=\"mul\"]\n pub trait Mul<RHS,Result> {\n+    /// The method for the `*` operator\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n@@ -199,6 +200,7 @@ pub trait Mul<RHS,Result> {\n  */\n #[lang=\"div\"]\n pub trait Div<RHS,Result> {\n+    /// The method for the `/` operator\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n@@ -228,6 +230,7 @@ pub trait Div<RHS,Result> {\n  */\n #[lang=\"rem\"]\n pub trait Rem<RHS,Result> {\n+    /// The method for the `%` operator\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n@@ -257,6 +260,7 @@ pub trait Rem<RHS,Result> {\n  */\n #[lang=\"neg\"]\n pub trait Neg<Result> {\n+    /// The method for the unary `-` operator\n     fn neg(&self) -> Result;\n }\n \n@@ -286,6 +290,7 @@ pub trait Neg<Result> {\n  */\n #[lang=\"not\"]\n pub trait Not<Result> {\n+    /// The method for the unary `!` operator\n     fn not(&self) -> Result;\n }\n \n@@ -315,6 +320,7 @@ pub trait Not<Result> {\n  */\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS,Result> {\n+    /// The method for the `&` operator\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n@@ -344,6 +350,7 @@ pub trait BitAnd<RHS,Result> {\n  */\n #[lang=\"bitor\"]\n pub trait BitOr<RHS,Result> {\n+    /// The method for the `|` operator\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n@@ -373,6 +380,7 @@ pub trait BitOr<RHS,Result> {\n  */\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS,Result> {\n+    /// The method for the `^` operator\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n@@ -402,6 +410,7 @@ pub trait BitXor<RHS,Result> {\n  */\n #[lang=\"shl\"]\n pub trait Shl<RHS,Result> {\n+    /// The method for the `<<` operator\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n@@ -431,6 +440,7 @@ pub trait Shl<RHS,Result> {\n  */\n #[lang=\"shr\"]\n pub trait Shr<RHS,Result> {\n+    /// The method for the `>>` operator\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n@@ -461,28 +471,96 @@ pub trait Shr<RHS,Result> {\n  */\n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n     fn index(&self, index: &Index) -> Result;\n }\n \n+/// Dummy dox\n #[cfg(stage0)]\n pub trait Deref<Result> {\n+    /// dummy dox\n     fn deref<'a>(&'a self) -> &'a Result;\n }\n \n+/**\n+ *\n+ * The `Deref` trait is used to specify the functionality of dereferencing\n+ * operations like `*v`.\n+ *\n+ * # Example\n+ *\n+ * A struct with a single field which is accessible via dereferencing the\n+ * struct.\n+ *\n+ * ```\n+ * struct DerefExample<T> {\n+ *     value: T\n+ * }\n+ *\n+ * impl<T> Deref<T> for DerefExample<T> {\n+ *     fn deref<'a>(&'a self) -> &'a T {\n+ *         &self.value\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     let x = DerefExample { value: 'a' };\n+ *     assert_eq!('a', *x);\n+ * }\n+ * ```\n+ */\n #[cfg(not(stage0))]\n #[lang=\"deref\"]\n pub trait Deref<Result> {\n+    /// The method called to dereference a value\n     fn deref<'a>(&'a self) -> &'a Result;\n }\n \n+/// dummy dox\n #[cfg(stage0)]\n pub trait DerefMut<Result>: Deref<Result> {\n+    /// dummy dox\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }\n \n+/**\n+ *\n+ * The `DerefMut` trait is used to specify the functionality of dereferencing\n+ * mutably like `*v = 1;`\n+ *\n+ * # Example\n+ *\n+ * A struct with a single field which is modifiable via dereferencing the\n+ * struct.\n+ *\n+ * ```\n+ * struct DerefMutExample<T> {\n+ *     value: T\n+ * }\n+ *\n+ * impl<T> Deref<T> for DerefMutExample<T> {\n+ *     fn deref<'a>(&'a self) -> &'a T {\n+ *         &self.value\n+ *     }\n+ * }\n+ *\n+ * impl<T> DerefMut<T> for DerefMutExample<T> {\n+ *     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+ *         &mut self.value\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     let mut x = DerefMutExample { value: 'a' };\n+ *     *x = 'b';\n+ *     assert_eq!('b', *x);\n+ * }\n+ * ```\n+ */\n #[cfg(not(stage0))]\n #[lang=\"deref_mut\"]\n pub trait DerefMut<Result>: Deref<Result> {\n+    /// The method called to mutably dereference a value\n     fn deref_mut<'a>(&'a mut self) -> &'a mut Result;\n }\n "}, {"sha": "9327136c771f09544091a942e02f41dae4990c7b", "filename": "src/libstd/option.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -149,7 +149,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or a default\n+    /// Returns the contained value or a default.\n     #[inline]\n     pub fn unwrap_or(self, def: T) -> T {\n         match self {\n@@ -158,7 +158,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Returns the contained value or computes it from a closure\n+    /// Returns the contained value or computes it from a closure.\n     #[inline]\n     pub fn unwrap_or_else(self, f: || -> T) -> T {\n         match self {\n@@ -183,7 +183,7 @@ impl<T> Option<T> {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n-    /// Apply a function to the contained value or do nothing.\n+    /// Applies a function to the contained value or does nothing.\n     /// Returns true if the contained value was mutated.\n     pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n@@ -192,7 +192,7 @@ impl<T> Option<T> {\n         } else { false }\n     }\n \n-    /// Apply a function to the contained value or set it to a default.\n+    /// Applies a function to the contained value or sets it to a default.\n     /// Returns true if the contained value was mutated, or false if set to the default.\n     pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n@@ -208,19 +208,19 @@ impl<T> Option<T> {\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Return an iterator over the possibly contained value\n+    /// Returns an iterator over the possibly contained value.\n     #[inline]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n         Item{opt: self.as_ref()}\n     }\n \n-    /// Return a mutable iterator over the possibly contained value\n+    /// Returns a mutable iterator over the possibly contained value.\n     #[inline]\n     pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n         Item{opt: self.as_mut()}\n     }\n \n-    /// Return a consuming iterator over the possibly contained value\n+    /// Returns a consuming iterator over the possibly contained value.\n     #[inline]\n     pub fn move_iter(self) -> Item<T> {\n         Item{opt: self}\n@@ -264,15 +264,15 @@ impl<T> Option<T> {\n     pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n-            None => f(),\n+            None => f()\n         }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n     // Misc\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Take the value out of the option, leaving a `None` in its place.\n+    /// Takes the value out of the option, leaving a `None` in its place.\n     #[inline]\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n@@ -282,7 +282,7 @@ impl<T> Option<T> {\n     #[inline(always)]\n     pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n         match self {\n-            Some(x) => if f(&x) {Some(x)} else {None},\n+            Some(x) => if f(&x) { Some(x) } else { None },\n             None => None\n         }\n     }"}, {"sha": "ccd08e8a716c01e19b70c40c6e4dbf9d4abbf2bd", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -2664,9 +2664,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         return multibyte_char_range_at(*self, i);\n     }\n \n-    #[inline]\n-    fn char_at(&self, i: uint) -> char { self.char_range_at(i).ch }\n-\n     #[inline]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         let mut prev = start;"}, {"sha": "56c71a5e4ff795108c7c359e62380972980b0f00", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -26,7 +26,7 @@ use clone::Clone;\n use kinds::Send;\n use ops::Drop;\n use ptr::RawPtr;\n-use sync::atomics::{AtomicUint, SeqCst, Relaxed, Acquire};\n+use sync::atomics::{fence, AtomicUint, Relaxed, Acquire, Release};\n use vec;\n \n /// An atomically reference counted pointer.\n@@ -109,8 +109,16 @@ impl<T: Send> UnsafeArc<T> {\n impl<T: Send> Clone for UnsafeArc<T> {\n     fn clone(&self) -> UnsafeArc<T> {\n         unsafe {\n-            // This barrier might be unnecessary, but I'm not sure...\n-            let old_count = (*self.data).count.fetch_add(1, Acquire);\n+            // Using a relaxed ordering is alright here, as knowledge of the original reference\n+            // prevents other threads from erroneously deleting the object.\n+            //\n+            // As explained in the [Boost documentation][1],\n+            //  Increasing the reference counter can always be done with memory_order_relaxed: New\n+            //  references to an object can only be formed from an existing reference, and passing\n+            //  an existing reference from one thread to another must already provide any required\n+            //  synchronization.\n+            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+            let old_count = (*self.data).count.fetch_add(1, Relaxed);\n             // FIXME(#12049): this needs some sort of debug assertion\n             if cfg!(test) { assert!(old_count >= 1); }\n             return UnsafeArc { data: self.data };\n@@ -127,12 +135,26 @@ impl<T> Drop for UnsafeArc<T>{\n             if self.data.is_null() {\n                 return\n             }\n-            // Must be acquire+release, not just release, to make sure this\n-            // doesn't get reordered to after the unwrapper pointer load.\n-            let old_count = (*self.data).count.fetch_sub(1, SeqCst);\n+            // Because `fetch_sub` is already atomic, we do not need to synchronize with other\n+            // threads unless we are going to delete the object.\n+            let old_count = (*self.data).count.fetch_sub(1, Release);\n             // FIXME(#12049): this needs some sort of debug assertion\n             if cfg!(test) { assert!(old_count >= 1); }\n             if old_count == 1 {\n+                // This fence is needed to prevent reordering of use of the data and deletion of\n+                // the data. Because it is marked `Release`, the decreasing of the reference count\n+                // sychronizes with this `Acquire` fence. This means that use of the data happens\n+                // before decreasing the refernce count, which happens before this fence, which\n+                // happens before the deletion of the data.\n+                //\n+                // As explained in the [Boost documentation][1],\n+                //  It is important to enforce any possible access to the object in one thread\n+                //  (through an existing reference) to *happen before* deleting the object in a\n+                //  different thread. This is achieved by a \"release\" operation after dropping a\n+                //  reference (any access to the object through this reference must obviously\n+                //  happened before), and an \"acquire\" operation before deleting the object.\n+                // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+                fence(Acquire);\n                 let _: ~ArcData<T> = cast::transmute(self.data);\n             }\n         }"}, {"sha": "c51ab48207fd8f94c77ae3a450a63a1dfee2166e", "filename": "src/libstd/vec_ng.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fvec_ng.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibstd%2Fvec_ng.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec_ng.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -427,7 +427,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    fn remove(&mut self, index: uint) -> Option<T> {\n+    pub fn remove(&mut self, index: uint) -> Option<T> {\n         let len = self.len();\n         if index < len {\n             unsafe { // infallible"}, {"sha": "d93b5803eac30ac34d2e703fd83e1719e7343469", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -271,13 +271,22 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, src: ~str) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.get().last() {\n             None => 0,\n             Some(last) => last.deref().start_pos.to_uint() + last.deref().src.len(),\n         };\n \n+        // Remove utf-8 BOM if any.\n+        // FIXME #12884: no efficient/safe way to remove from the start of a string\n+        // and reuse the allocation.\n+        let mut src = if src.starts_with(\"\\ufeff\") {\n+            src.as_slice().slice_from(3).into_owned()\n+        } else {\n+            src\n+        };\n+\n         // Append '\\n' in case it's not already there.\n         // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n         // overflowing into the next filemap in case the last byte of span is also the last"}, {"sha": "d9510ddad4b16cfcc9fbddf82c3eeb00ee82b09c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -880,8 +880,8 @@ mod test {\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate<A: pprust::PpAnn>(s: &mut pprust::State<A>,\n-                                          krate: &ast::Crate) -> io::IoResult<()> {\n+    fn fake_print_crate(s: &mut pprust::State,\n+                        krate: &ast::Crate) -> io::IoResult<()> {\n         s.print_mod(&krate.module, krate.attrs.as_slice())\n     }\n "}, {"sha": "2f96a71cc0fdb5ef3ffaa54fe715996775665074", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -43,8 +43,8 @@ pub enum AnnNode<'a> {\n }\n \n pub trait PpAnn {\n-    fn pre(&self, _state: &mut State<Self>, _node: AnnNode) -> IoResult<()> { Ok(()) }\n-    fn post(&self, _state: &mut State<Self>, _node: AnnNode) -> IoResult<()> { Ok(()) }\n+    fn pre(&self, _state: &mut State, _node: AnnNode) -> IoResult<()> { Ok(()) }\n+    fn post(&self, _state: &mut State, _node: AnnNode) -> IoResult<()> { Ok(()) }\n }\n \n pub struct NoAnn;\n@@ -56,23 +56,24 @@ pub struct CurrentCommentAndLiteral {\n     cur_lit: uint,\n }\n \n-pub struct State<'a, A> {\n+pub struct State<'a> {\n     s: pp::Printer,\n     cm: Option<&'a CodeMap>,\n     intr: @token::IdentInterner,\n     comments: Option<Vec<comments::Comment> >,\n     literals: Option<Vec<comments::Literal> >,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n     boxes: RefCell<Vec<pp::Breaks> >,\n-    ann: &'a A\n+    ann: &'a PpAnn\n }\n \n-pub fn rust_printer(writer: ~io::Writer) -> State<'static, NoAnn> {\n+pub fn rust_printer(writer: ~io::Writer) -> State<'static> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a, A: PpAnn>(writer: ~io::Writer, ann: &'a A) -> State<'a, A> {\n+pub fn rust_printer_annotated<'a>(writer: ~io::Writer,\n+                                  ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n@@ -95,14 +96,14 @@ pub static default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-pub fn print_crate<'a, A: PpAnn>(cm: &'a CodeMap,\n-                                 span_diagnostic: &diagnostic::SpanHandler,\n-                                 krate: &ast::Crate,\n-                                 filename: ~str,\n-                                 input: &mut io::Reader,\n-                                 out: ~io::Writer,\n-                                 ann: &'a A,\n-                                 is_expanded: bool) -> IoResult<()> {\n+pub fn print_crate<'a>(cm: &'a CodeMap,\n+                       span_diagnostic: &diagnostic::SpanHandler,\n+                       krate: &ast::Crate,\n+                       filename: ~str,\n+                       input: &mut io::Reader,\n+                       out: ~io::Writer,\n+                       ann: &'a PpAnn,\n+                       is_expanded: bool) -> IoResult<()> {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n         filename,\n@@ -133,7 +134,7 @@ pub fn print_crate<'a, A: PpAnn>(cm: &'a CodeMap,\n     eof(&mut s.s)\n }\n \n-pub fn to_str(f: |&mut State<NoAnn>| -> IoResult<()>) -> ~str {\n+pub fn to_str(f: |&mut State| -> IoResult<()>) -> ~str {\n     let mut s = rust_printer(~MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n@@ -237,7 +238,7 @@ pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> ~str {\n     }\n }\n \n-impl<'a, A: PpAnn> State<'a, A> {\n+impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n         self.boxes.borrow_mut().get().push(pp::Inconsistent);\n         pp::ibox(&mut self.s, u)\n@@ -365,7 +366,7 @@ impl<'a, A: PpAnn> State<'a, A> {\n     }\n \n     pub fn commasep<T>(&mut self, b: Breaks, elts: &[T],\n-                       op: |&mut State<A>, &T| -> IoResult<()>)\n+                       op: |&mut State, &T| -> IoResult<()>)\n         -> IoResult<()> {\n         try!(self.rbox(0u, b));\n         let mut first = true;\n@@ -381,7 +382,7 @@ impl<'a, A: PpAnn> State<'a, A> {\n                          &mut self,\n                          b: Breaks,\n                          elts: &[T],\n-                         op: |&mut State<A>, &T| -> IoResult<()>,\n+                         op: |&mut State, &T| -> IoResult<()>,\n                          get_span: |&T| -> codemap::Span) -> IoResult<()> {\n         try!(self.rbox(0u, b));\n         let len = elts.len();"}, {"sha": "a74c8c47cd9b7c7388c10ae457e6fb2bdec08cda", "filename": "src/test/auxiliary/linkage1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage1.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -10,3 +10,5 @@\n \n #[no_mangle]\n pub static foo: int = 3;\n+\n+pub fn bar() {}"}, {"sha": "193cbcb25b74d8bf978d5998a2df1cfacf9ba41d", "filename": "src/test/compile-fail/issue-12997-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-12997-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-12997-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-1.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+\n+//! Test that makes sure wrongly-typed bench functions aren't ignored\n+\n+#[bench]\n+fn foo() { } //~ ERROR functions used as benches\n+\n+#[bench]\n+fn bar(x: int, y: int) { } //~ ERROR functions used as benches"}, {"sha": "f520ce0eabba6aeb020d883877d846dae14f2109", "filename": "src/test/compile-fail/issue-12997-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+\n+//! Test that makes sure wrongly-typed bench functions are rejected\n+\n+// error-pattern:expected &-ptr but found int\n+#[bench]\n+fn bar(x: int) { }"}, {"sha": "2af531135eca3915c474192526fb66544f379a20", "filename": "src/test/compile-fail/issue-8153.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8153.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that duplicate methods in impls are not allowed\n+\n+struct Foo;\n+\n+trait Bar {\n+    fn bar(&self) -> int;\n+}\n+\n+impl Bar for Foo {\n+    fn bar(&self) -> int {1}\n+    fn bar(&self) -> int {2} //~ ERROR duplicate method\n+}\n+\n+fn main() {\n+    println!(\"{}\", Foo.bar());\n+}"}, {"sha": "6eeefabcf7cb9c4792cf42a22e35be192d392644", "filename": "src/test/run-pass-fulldeps/syntax-extension-hexfloat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "previous_filename": "src/test/run-pass/syntax-extension-hexfloat.rs"}, {"sha": "c6f672c5d34d0ac3ce92de28038472b16bbc229c", "filename": "src/test/run-pass/linkage1.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage1.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -26,6 +26,13 @@ extern {\n }\n \n fn main() {\n+    // It appears that the --as-needed flag to linkers will not pull in a dynamic\n+    // library unless it satisfies a non weak undefined symbol. The 'other' crate\n+    // is compiled as a dynamic library where it would only be used for a\n+    // weak-symbol as part of an executable, so the dynamic library woudl be\n+    // discarded. By adding and calling `other::bar`, we get around this problem.\n+    other::bar();\n+\n     assert!(!foo.is_null());\n     assert_eq!(unsafe { *foo }, 3);\n     assert!(something_that_should_never_exist.is_null());"}, {"sha": "ccd40cb88fe08cd844f01c707d392d39c402127e", "filename": "src/test/run-pass/utf8-bom.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass%2Futf8-bom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e72c38122cbd24199365232217ca8c15ebe995/src%2Ftest%2Frun-pass%2Futf8-bom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8-bom.rs?ref=87e72c38122cbd24199365232217ca8c15ebe995", "patch": "@@ -0,0 +1,13 @@\n+\ufeff// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file has utf-8 BOM, it should be compiled normally without error.\n+\n+pub fn main() {}"}]}