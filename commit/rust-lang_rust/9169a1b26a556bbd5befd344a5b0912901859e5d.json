{"sha": "9169a1b26a556bbd5befd344a5b0912901859e5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNjlhMWIyNmE1NTZiYmQ1YmVmZDM0NGE1YjA5MTI5MDE4NTllNWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-11T17:21:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-12T03:24:11Z"}, "message": "correct glb computation, improve region error msgs\n\ncc #3180", "tree": {"sha": "8e721ac58741a582893f02d991cafa10265758de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e721ac58741a582893f02d991cafa10265758de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9169a1b26a556bbd5befd344a5b0912901859e5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9169a1b26a556bbd5befd344a5b0912901859e5d", "html_url": "https://github.com/rust-lang/rust/commit/9169a1b26a556bbd5befd344a5b0912901859e5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9169a1b26a556bbd5befd344a5b0912901859e5d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04754061781b855b4d230a9ae3bc97799373aff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/04754061781b855b4d230a9ae3bc97799373aff4", "html_url": "https://github.com/rust-lang/rust/commit/04754061781b855b4d230a9ae3bc97799373aff4"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "d06e7c55d0c0cc75fc756d35df8e3c550318b0c7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=9169a1b26a556bbd5befd344a5b0912901859e5d", "patch": "@@ -168,7 +168,8 @@ export bound_const;\n export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n-export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n+export terr_regions_does_not_outlive, terr_mutability, terr_purity_mismatch;\n+export terr_regions_not_same, terr_regions_no_overlap;\n export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n export purity_to_str;\n@@ -463,7 +464,9 @@ enum type_err {\n     terr_record_fields(ast::ident, ast::ident),\n     terr_arg_count,\n     terr_mode_mismatch(mode, mode),\n-    terr_regions_differ(region, region),\n+    terr_regions_does_not_outlive(region, region),\n+    terr_regions_not_same(region, region),\n+    terr_regions_no_overlap(region, region),\n     terr_vstores_differ(terr_vstore_kind, vstore, vstore),\n     terr_in_field(@type_err, ast::ident),\n     terr_sorts(t, t),\n@@ -2631,11 +2634,21 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         return ~\"expected argument mode \" + mode_to_str(e_mode) +\n             ~\" but found \" + mode_to_str(a_mode);\n       }\n-      terr_regions_differ(subregion, superregion) => {\n+      terr_regions_does_not_outlive(subregion, superregion) => {\n         return fmt!{\"%s does not necessarily outlive %s\",\n                  explain_region(cx, subregion),\n                  explain_region(cx, superregion)};\n       }\n+      terr_regions_not_same(region1, region2) => {\n+        return fmt!{\"%s is not the same as %s\",\n+                 explain_region(cx, region1),\n+                 explain_region(cx, region2)};\n+      }\n+      terr_regions_no_overlap(region1, region2) => {\n+        return fmt!{\"%s does not intersect %s\",\n+                 explain_region(cx, region1),\n+                 explain_region(cx, region2)};\n+      }\n       terr_vstores_differ(k, e_vs, a_vs) => {\n         return fmt!{\"%s storage differs: expected %s but found %s\",\n                  terr_vstore_kind_to_str(k),"}, {"sha": "4eaef9aa062b00bf14fb9d0cbf776b187b79a45a", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=9169a1b26a556bbd5befd344a5b0912901859e5d", "patch": "@@ -394,7 +394,8 @@ enum infer_ctxt = @{\n     ty_var_integral_bindings: vals_and_bindings<ty::tvi_vid, int_ty_set>,\n \n     // For region variables.\n-    region_var_bindings: vals_and_bindings<ty::region_vid, bounds<ty::region>>,\n+    region_var_bindings: vals_and_bindings<ty::region_vid,\n+                                           bounds<ty::region>>,\n \n     // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n@@ -1053,7 +1054,7 @@ impl infer_ctxt {\n                                       nde_a.rank)\n     }\n \n-    fn var_sub_t_integral<V: copy vid>(\n+    fn var_integral_sub_t<V: copy vid>(\n         vb: &vals_and_bindings<V, int_ty_set>,\n         a_id: V, b: ty::t) -> ures {\n \n@@ -1146,9 +1147,19 @@ impl infer_ctxt {\n         debug!{\"eq_regions(%s, %s)\",\n                a.to_str(self), b.to_str(self)};\n         do indent {\n-            do self.sub_regions(a, b).then {\n-                self.sub_regions(b, a)\n-            }\n+            self.try(|| {\n+                do self.sub_regions(a, b).then {\n+                    self.sub_regions(b, a)\n+                }\n+            }).chain_err(|e| {\n+                // substitute a better error, but use the regions\n+                // found in the original error\n+                match e {\n+                  ty::terr_regions_does_not_outlive(a1, b1) =>\n+                    err(ty::terr_regions_not_same(a1, b1)),\n+                  _ => err(e)\n+                }\n+            })\n         }\n     }\n }\n@@ -1847,15 +1858,15 @@ fn super_tys<C:combine>(\n       }\n       (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n       (ty::ty_var_integral(a_id), ty::ty_uint(_)) => {\n-        self.infcx().vart_integral(&self.infcx().ty_var_integral_bindings,\n-                                   a_id, b)\n-            .then(|| ok(a) )\n+        self.infcx().var_integral_sub_t(\n+            &self.infcx().ty_var_integral_bindings,\n+            a_id, b).then(|| ok(a) )\n       }\n       (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n       (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().t_sub_var_integral(&self.infcx().ty_var_integral_bindings,\n-                                        a, b_id)\n-            .then(|| ok(a) )\n+        self.infcx().t_sub_var_integral(\n+            &self.infcx().ty_var_integral_bindings,\n+            a, b_id).then(|| ok(a) )\n       }\n \n       (ty::ty_int(_), _) |\n@@ -2015,8 +2026,8 @@ impl sub: combine {\n               }\n               _ => {\n                   do (&self.lub()).regions(a, b).compare(b) {\n-                    ty::terr_regions_differ(b, a)\n-                }\n+                    ty::terr_regions_does_not_outlive(b, a)\n+                  }\n               }\n             }\n         }\n@@ -2460,20 +2471,26 @@ impl glb: combine {\n                 let rm = self.infcx().tcx.region_map;\n                 match region::nearest_common_ancestor(rm, f_id, s_id) {\n                   some(r_id) if r_id == f_id => ok(s),\n-                  _ => err(ty::terr_regions_differ(b, a))\n+                  _ => err(ty::terr_regions_no_overlap(b, a))\n                 }\n               }\n \n               (ty::re_scope(a_id), ty::re_scope(b_id)) |\n               (ty::re_free(a_id, _), ty::re_free(b_id, _)) => {\n-                // We want to generate a region that is contained by both of\n-                // these: so, if one of these scopes is a subscope of the\n-                // other, return it.  Otherwise fail.\n-                let rm = self.infcx().tcx.region_map;\n-                match region::nearest_common_ancestor(rm, a_id, b_id) {\n-                  some(r_id) if a_id == r_id => ok(b),\n-                  some(r_id) if b_id == r_id => ok(a),\n-                  _ => err(ty::terr_regions_differ(b, a))\n+                if a == b {\n+                    // Same scope or same free identifier, easy case.\n+                    ok(a)\n+                } else {\n+                    // We want to generate the intersection of two\n+                    // scopes or two free regions.  So, if one of\n+                    // these scopes is a subscope of the other, return\n+                    // it.  Otherwise fail.\n+                    let rm = self.infcx().tcx.region_map;\n+                    match region::nearest_common_ancestor(rm, a_id, b_id) {\n+                      some(r_id) if a_id == r_id => ok(ty::re_scope(b_id)),\n+                      some(r_id) if b_id == r_id => ok(ty::re_scope(a_id)),\n+                      _ => err(ty::terr_regions_no_overlap(b, a))\n+                    }\n                 }\n               }\n \n@@ -2487,7 +2504,7 @@ impl glb: combine {\n                 if a == b {\n                     ok(a)\n                 } else {\n-                    err(ty::terr_regions_differ(b, a))\n+                    err(ty::terr_regions_no_overlap(b, a))\n                 }\n               }\n             }\n@@ -2589,13 +2606,13 @@ fn lattice_tys<L:lattice_ops combine>(\n           }\n \n           (ty::ty_var(a_id), _) => {\n-            lattice_var_t(self, &self.infcx().ty_var_bindings, a_id, b,\n-                          |x, y| self.tys(x, y) )\n+            lattice_var_and_t(self, &self.infcx().ty_var_bindings, a_id, b,\n+                              |x, y| self.tys(x, y) )\n           }\n \n           (_, ty::ty_var(b_id)) => {\n-            lattice_var_t(self, &self.infcx().ty_var_bindings, b_id, a,\n-                          |x, y| self.tys(x, y) )\n+            lattice_var_and_t(self, &self.infcx().ty_var_bindings, b_id, a,\n+                              |x, y| self.tys(x, y) )\n           }\n           _ => {\n             super_tys(self, a, b)\n@@ -2616,9 +2633,9 @@ fn lattice_rvars<L:lattice_ops combine>(\n       }\n \n       (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) => {\n-        lattice_var_t(self, &self.infcx().region_var_bindings,\n-                      v_id, r,\n-                      |x, y| self.regions(x, y) )\n+        lattice_var_and_t(self, &self.infcx().region_var_bindings,\n+                          v_id, r,\n+                          |x, y| self.regions(x, y) )\n       }\n \n       _ => {"}, {"sha": "94cf76330a9fe2c9940403439935f15700f6f3d1", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9169a1b26a556bbd5befd344a5b0912901859e5d/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=9169a1b26a556bbd5befd344a5b0912901859e5d", "patch": "@@ -0,0 +1,34 @@\n+mod argparse {\n+    use std;\n+\n+    import std::map;\n+    import either::{either, left, right};\n+\n+    struct Flag {\n+        name: &str;\n+        desc: &str;\n+        max_count: uint;\n+        mut value: uint;\n+    }\n+\n+    fn flag(name: &str, desc: &str) -> Flag {\n+        Flag { name: name, desc: desc, max_count: 1, value: 0 }\n+    }\n+\n+    impl Flag {\n+        fn set_desc(self, s: &str) -> Flag {\n+            Flag { //~ ERROR mismatched types\n+                name: self.name,\n+                desc: s,\n+                max_count: self.max_count,\n+                value: self.value\n+            }\n+        }\n+    }\n+}\n+\n+fn main () {\n+    let f : argparse::Flag = argparse::flag(~\"flag\", ~\"My flag\");\n+    let updated_flag = f.set_desc(~\"My new flag\");\n+    assert updated_flag.desc == \"My new flag\";\n+}"}]}