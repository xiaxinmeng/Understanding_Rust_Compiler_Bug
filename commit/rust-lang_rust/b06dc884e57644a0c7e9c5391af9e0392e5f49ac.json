{"sha": "b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNmRjODg0ZTU3NjQ0YTBjN2U5YzUzOTFhZjllMDM5MmU1ZjQ5YWM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-19T17:19:00Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-21T00:07:07Z"}, "message": "Class methods WIP\n\nIn particular, use the ast::method type to represent a class method,\nand try to reuse as much iface code as possible. (This makes sense now\nsince I'll be allowing polymorphic class methods.)", "tree": {"sha": "1d1578a0f5770193799937b84cdcc96b217e52e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d1578a0f5770193799937b84cdcc96b217e52e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "html_url": "https://github.com/rust-lang/rust/commit/b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "855c99ea758186096a68a8c13edeb0d89105a410", "url": "https://api.github.com/repos/rust-lang/rust/commits/855c99ea758186096a68a8c13edeb0d89105a410", "html_url": "https://github.com/rust-lang/rust/commit/855c99ea758186096a68a8c13edeb0d89105a410"}], "stats": {"total": 643, "additions": 384, "deletions": 259}, "files": [{"sha": "d48ca3f495e4fc34dbc611bea6e818c75fdeb1e6", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -110,6 +110,14 @@ impl session for session {\n     }\n }\n \n+// Seems out of place, but it uses session, so I'm putting it here\n+fn expect<T: copy>(sess: session, opt: option<T>, msg: fn() -> str) -> T {\n+    alt opt {\n+       some(t) { t }\n+       none { sess.bug(msg()); }\n+    }\n+}\n+\n fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n                     testing: bool) -> bool {\n     alt req_crate_type {"}, {"sha": "1d8965897ad4feef39ddfd73819e26c45d696225", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -1,15 +1,19 @@\n // Searching for information from the cstore\n \n+import std::{ebml};\n import syntax::ast;\n import syntax::ast_util;\n import middle::{ty, ast_map};\n import option::{some, none};\n import driver::session;\n+import driver::session::expect;\n import middle::trans::common::maps;\n+import common::*;\n import std::map::hashmap;\n \n export get_symbol;\n-export get_class_items;\n+export get_class_fields;\n+export get_field_type;\n export get_type_param_count;\n export lookup_defs;\n export lookup_method_purity;\n@@ -120,10 +124,10 @@ fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n     decoder::get_iface_methods(cdata, def.node, tcx)\n }\n \n-fn get_class_items(tcx: ty::ctxt, def: ast::def_id) -> [@ty::class_item_ty] {\n+fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_items(cdata, def.node, tcx)\n+    decoder::get_class_fields(tcx, cdata, def.node)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n@@ -132,6 +136,27 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n+/* FIXME: Refactor */\n+fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n+                  def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    let cstore = tcx.sess.cstore;\n+    let cdata = cstore::get_crate_data(cstore, class_id.crate);\n+    let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n+    #debug(\"Looking up %?\", class_id);\n+    let class_doc = expect(tcx.sess,\n+                           decoder::maybe_find_item(class_id.node, all_items),\n+                           {|| #fmt(\"get_field_type: class ID %? not found\",\n+                     class_id)});\n+    #debug(\"looking up %? : %?\", def, class_doc);\n+    let the_field = expect(tcx.sess,\n+        decoder::maybe_find_item(def.node, class_doc),\n+        {|| #fmt(\"get_field_type: in class %?, field ID %? not found\",\n+                 class_id, def)});\n+    #debug(\"got field data %?\", the_field);\n+    let ty = decoder::item_type(def, the_field, tcx, cdata);\n+    ret {bounds: @[], ty: ty};\n+}\n+\n fn get_impl_iface(tcx: ty::ctxt, def: ast::def_id)\n     -> option<ty::t> {\n     let cstore = tcx.sess.cstore;"}, {"sha": "8916d32d3937a92206e5ab8a5f8db5ae7c490ed2", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -14,8 +14,9 @@ import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import middle::trans::common::maps;\n+import util::ppaux::ty_to_str;\n \n-export get_class_items;\n+export get_class_fields;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n@@ -35,6 +36,8 @@ export get_impls_for_mod;\n export get_iface_methods;\n export get_crate_module_paths;\n export get_item_path;\n+export maybe_find_item; // sketchy\n+export item_type; // sketchy\n export maybe_get_item_ast;\n export item_is_intrinsic;\n \n@@ -110,9 +113,9 @@ fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     found\n }\n \n-fn class_field_id(d: ebml::doc) -> ast::def_id {\n+fn class_field_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_def_id);\n-    ret parse_def_id(ebml::doc_data(tagdoc));\n+    ret translate_def_id(cdata, parse_def_id(ebml::doc_data(tagdoc)));\n }\n \n fn variant_disr_val(d: ebml::doc) -> option<int> {\n@@ -406,37 +409,26 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n }\n \n /* Take a node ID for a class, return a vector of the class's\n- member types */\n-fn get_class_items(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n-    -> [@ty::class_item_ty] {\n+   field names/IDs */\n+fn get_class_fields(tcx: ty::ctxt,\n+               cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data), result = [];\n-    #debug(\"get_class_items: %s\", item_name(item));\n-    #debug(\"item: %?\", item);\n-    // right tag?\n-    ebml::tagged_docs(item, tag_items_class_member) {|an_item|\n+    ebml::tagged_docs(item, tag_items_data_item) {|an_item|\n         let fam = item_family(an_item);\n-        let decl = alt check fam {\n-                'g' {\n-                    let name = item_name(an_item);\n-                    #debug(\"why hello there! %s\", name);\n-                    let ty = doc_type(an_item, tcx, cdata);\n-                    let did = class_field_id(an_item);\n-                    {ident: name,\n-                     id: did.node,\n-                     contents: ty::var_ty(ty)}\n-                }\n-                _ {\n-                    fail; // FIXME\n-                }\n-        };\n-        result += [@decl];\n+        alt fam {\n+         'g' {\n+             let name = item_name(an_item);\n+             let _ty = doc_type(an_item, tcx, cdata);\n+             let did = class_field_id(an_item, cdata);\n+             result += [{ident: name, id: did}];\n+         }\n+        _ { /* this only handles fields */}\n+       }\n     }\n     result\n }\n \n-\n-\n fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n       'c' | 'T' | 'm' | 'n' | 'g' | 'h' { false }"}, {"sha": "b55a342624438569b141faa78f33ccbd95d4ca42", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 93, "deletions": 66, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -82,8 +82,8 @@ fn encode_class_item_paths(ebml_w: ebml::writer,\n           priv { cont; }\n           pub {\n               let (id, ident) = alt it.node.decl {\n-                      instance_var(v, _, _, vid) { (vid, v) }\n-                      class_method(it) { (it.id, it.ident) }\n+                 instance_var(v, _, _, vid) { (vid, v) }\n+                 class_method(it) { (it.id, it.ident) }\n               };\n               add_to_index(ebml_w, path, index, ident);\n               encode_named_def_id(ebml_w, ident, local_def(id));\n@@ -145,18 +145,18 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n             ebml_w.end_tag();\n           }\n           item_class(tps,items,ctor) {\n-              add_to_index(ebml_w, path, index, it.ident);\n-              ebml_w.start_tag(tag_paths_data_item);\n-              encode_name(ebml_w, it.ident);\n-              encode_def_id(ebml_w, local_def(it.id));\n-              ebml_w.end_tag();\n-              ebml_w.start_tag(tag_paths);\n-              add_to_index(ebml_w, path, index, it.ident);\n-              #debug(\"ctor id: %d\", ctor.node.id);\n-              encode_named_def_id(ebml_w, it.ident, local_def(ctor.node.id));\n-              encode_class_item_paths(ebml_w, items, path + [it.ident],\n+            add_to_index(ebml_w, path, index, it.ident);\n+            ebml_w.start_tag(tag_paths_data_item);\n+            encode_name(ebml_w, it.ident);\n+            encode_def_id(ebml_w, local_def(it.id));\n+            ebml_w.end_tag();\n+            ebml_w.start_tag(tag_paths);\n+            add_to_index(ebml_w, path, index, it.ident);\n+            #debug(\"ctor id: %d\", ctor.node.id);\n+            encode_named_def_id(ebml_w, it.ident, local_def(ctor.node.id));\n+            encode_class_item_paths(ebml_w, items, path + [it.ident],\n                                       index);\n-              ebml_w.end_tag();\n+            ebml_w.end_tag();\n           }\n           item_enum(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n@@ -252,7 +252,12 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n+    let sym = alt ecx.ccx.item_symbols.find(id) {\n+      some(x) { x }\n+      none { ecx.ccx.tcx.sess.bug(#fmt(\"encode_symbol: \\\n+                    id not found %d\", id)); }\n+    };\n+    ebml_w.writer.write(str::bytes(sym));\n     ebml_w.end_tag();\n }\n \n@@ -346,43 +351,53 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml_w.end_tag();\n }\n \n+/* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path, name: ident,\n-                         tps: [ty_param], items: [@class_item]) {\n+                         tps: [ty_param], items: [@class_item])\n+ -> [entry<int>] {\n+    let index = @mutable [];\n+\n     let tcx = ecx.ccx.tcx;\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'C');\n     encode_type_param_bounds(ebml_w, ecx, tps);\n     encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n     encode_name(ebml_w, name);\n+    encode_path(ebml_w, path, ast_map::path_name(name));\n \n     for ci in items {\n-            /* We encode both private and public fields -- need to include\n-             private fields to get the offsets right */\n-            ebml_w.start_tag(tag_items_class_member);\n-            alt ci.node.decl {\n-               instance_var(nm, _, _, id) {\n-                   #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n-                   encode_family(ebml_w, 'g');\n-                   encode_name(ebml_w, nm);\n-                   encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n-                   /* TODO: mutability */\n-                   encode_def_id(ebml_w, local_def(id));\n-               }\n-               class_method(it) {\n-                   encode_family(ebml_w, 'h');\n-                   encode_name(ebml_w, it.ident);\n-                   alt it.node {\n-                      item_fn(fdecl, tps, _) {\n-                          encode_info_for_fn(ecx, ebml_w, it.id, it.ident,\n-                                             path, none, tps, fdecl);\n-                      }\n-                      _ { fail; /* TODO */ }\n-                   }\n-               }\n-            }\n-            ebml_w.end_tag();\n+     /* We encode both private and public fields -- need to include\n+        private fields to get the offsets right */\n+      alt ci.node.decl {\n+        instance_var(nm, _, _, id) {\n+          *index += [{val: id, pos: ebml_w.writer.tell()}];\n+          ebml_w.start_tag(tag_items_data_item);\n+          #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n+          encode_family(ebml_w, 'g');\n+          encode_name(ebml_w, nm);\n+          encode_path(ebml_w, path, ast_map::path_name(nm));\n+          encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n+          /* TODO: mutability */\n+          encode_def_id(ebml_w, local_def(id));\n+        }\n+        class_method(m) {\n+          *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n+          ebml_w.start_tag(tag_items_data_item);\n+          encode_family(ebml_w, 'h');\n+          encode_name(ebml_w, m.ident);\n+          let impl_path = path + [ast_map::path_name(m.ident)];\n+          /*\n+            Recall methods are (currently) monomorphic, and we don't\n+            repeat the class's ty params in the method decl\n+          */\n+          encode_info_for_method(ecx, ebml_w, impl_path,\n+                                 should_inline(m.attrs), id, m, []);\n+        }\n+      }\n+      ebml_w.end_tag();\n     }\n+    *index\n }\n \n fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n@@ -408,6 +423,28 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         ebml_w.end_tag();\n }\n \n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                          impl_path: ast_map::path, should_inline: bool,\n+                          parent_id: node_id,\n+                          m: @method, all_tps: [ty_param]) {\n+    #debug(\"encode_info_for_method: %d %s\", m.id, m.ident);\n+    ebml_w.start_tag(tag_items_data_item);\n+    encode_def_id(ebml_w, local_def(m.id));\n+    encode_family(ebml_w, purity_fn_family(m.decl.purity));\n+    encode_type_param_bounds(ebml_w, ecx, all_tps);\n+    encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, m.id));\n+    encode_name(ebml_w, m.ident);\n+    encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n+    if all_tps.len() > 0u || should_inline {\n+        astencode::encode_inlined_item(\n+           ecx, ebml_w, impl_path,\n+           ii_method(local_def(parent_id), m));\n+    } else {\n+        encode_symbol(ecx, ebml_w, m.id);\n+    }\n+    ebml_w.end_tag();\n+}\n+\n fn purity_fn_family(p: purity) -> char {\n     alt p {\n       unsafe_fn { 'u' }\n@@ -417,15 +454,17 @@ fn purity_fn_family(p: purity) -> char {\n     }\n }\n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n-                        index: @mutable [entry<int>], path: ast_map::path) {\n \n-    fn should_inline(attrs: [attribute]) -> bool {\n-        alt attr::find_inline_attr(attrs) {\n-          attr::ia_none { false }\n-          attr::ia_hint | attr::ia_always { true }\n-        }\n+fn should_inline(attrs: [attribute]) -> bool {\n+    alt attr::find_inline_attr(attrs) {\n+        attr::ia_none { false }\n+        attr::ia_hint | attr::ia_always { true }\n     }\n+}\n+\n+\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n+                        index: @mutable [entry<int>], path: ast_map::path) {\n \n     let tcx = ecx.ccx.tcx;\n     let must_write = alt item.node { item_enum(_, _) { true } _ { false } };\n@@ -494,11 +533,12 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                                  path, index, tps);\n       }\n       item_class(tps,items,ctor) {\n-          /* We're not forgetting about the ctor here! It gets\n-             encoded elsewhere */\n         ebml_w.start_tag(tag_items_data_item);\n-        encode_info_for_class(ecx, ebml_w, item.id, path, item.ident,\n-                               tps, items);\n+        let idx = encode_info_for_class(ecx, ebml_w, item.id, path,\n+                 item.ident, tps, items);\n+        /* each class must have its own index */\n+        let bkts = create_index(idx, hash_node_id);\n+        encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n       item_res(_, tps, _, _, ctor_id) {\n@@ -553,21 +593,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         let impl_path = path + [ast_map::path_name(item.ident)];\n         for m in methods {\n             *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-            ebml_w.start_tag(tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(m.id));\n-            encode_family(ebml_w, purity_fn_family(m.decl.purity));\n-            encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n-            encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n-            encode_name(ebml_w, m.ident);\n-            encode_path(ebml_w, impl_path, ast_map::path_name(m.ident));\n-            if tps.len() > 0u || m.tps.len() > 0u || should_inline(m.attrs) {\n-                astencode::encode_inlined_item(\n-                    ecx, ebml_w, impl_path,\n-                    ii_method(local_def(item.id), m));\n-            } else {\n-                encode_symbol(ecx, ebml_w, m.id);\n-            }\n-            ebml_w.end_tag();\n+            encode_info_for_method(ecx, ebml_w, impl_path,\n+                   should_inline(m.attrs), item.id, m, tps + m.tps);\n         }\n       }\n       item_iface(tps, ms) {"}, {"sha": "947dbaab2f63004ea47cfcd611fa2432b83757a3", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -172,8 +172,19 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             cx.map.insert(nitem.id, node_native_item(nitem, abi, @cx.path));\n         }\n       }\n-      item_class(_, _, ctor) {\n+      item_class(_, items, ctor) {\n           cx.map.insert(ctor.node.id, node_ctor(i, item_path));\n+          let d_id = ast_util::local_def(i.id);\n+          let p = extend(cx, i.ident);\n+          for ci in items {\n+           // only need to handle methods\n+           alt ci.node.decl {\n+             class_method(m) {\n+               map_method(d_id, p, m, cx);\n+             }\n+             _ {}\n+           }\n+          }\n       }\n       _ { }\n     }"}, {"sha": "e2bb54946591cb6a6b5fec22e68f47b6d8eaa5eb", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -531,7 +531,9 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         /* visit the items */\n         for cm in members {\n             alt cm.node.decl {\n-              class_method(i) { visit_item_with_scope(e, i, class_scope, v); }\n+              class_method(m) { visit_fn_with_scope(e,\n+                 visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n+                 m.span, m.id, class_scope, v); }\n               instance_var(_,t,_,_) { v.visit_ty(t, class_scope, v); }\n             }\n         }"}, {"sha": "da0067400e0aa01375e2b03cbf05d9f23ba55cbb", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -102,14 +102,11 @@ fn traverse_public_item(cx: ctx, item: @item) {\n         cx.rmap.insert(ctor.node.id, ());\n         for item in items {\n             alt item.node.decl {\n-              class_method(i) {\n-                cx.rmap.insert(i.id, ());\n+              class_method(m) {\n+                cx.rmap.insert(m.id, ());\n                 if tps.len() > 0u ||\n-                   attr::find_inline_attr(i.attrs) != attr::ia_none {\n-                    alt i.node {\n-                      item_fn(_, _, blk) { traverse_inline_body(cx, blk); }\n-                      _ {}\n-                    }\n+                   attr::find_inline_attr(m.attrs) != attr::ia_none {\n+                    traverse_inline_body(cx, m.body);\n                 }\n               }\n               _ {}"}, {"sha": "fcc2229ffbb431bb914bee07b6e969e07cc6d51d", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -83,16 +83,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_constr(subt,_) { type_of(cx, subt) }\n       ty::ty_class(did, _) {\n         let tys: [TypeRef] = [];\n-        let cls_items = lookup_class_item_tys(cx.tcx, did);\n-        for ci in cls_items {\n-            // only instance vars are record fields at runtime\n-            alt ci.contents {\n-                var_ty(t) {\n-                  let fty = type_of(cx, t);\n-                  tys += [fty];\n-                }\n-                _ {}\n-            }\n+        // only instance vars are record fields at runtime\n+        let fields = lookup_class_fields(cx.tcx, did);\n+        for f in fields {\n+            let t = ty::lookup_field_type(cx.tcx, did, f.id);\n+            let fty = type_of(cx, t);\n+            tys += [fty];\n         }\n         T_struct(tys)\n       }"}, {"sha": "4a9f109e4e6d568fa1b2fe684bbd416ec1cab744", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -20,8 +20,6 @@ export arg;\n export args_eq;\n export ast_constr_to_constr;\n export block_ty;\n-export class_contents_ty;\n-export class_item_ty;\n export class_items_as_fields;\n export constr;\n export constr_general;\n@@ -32,6 +30,7 @@ export expr_has_ty_params;\n export expr_ty;\n export expr_ty_params_and_ty;\n export expr_is_lval;\n+export field_ty;\n export fold_ty;\n export field;\n export field_idx;\n@@ -41,7 +40,8 @@ export fm_general, fm_rptr;\n export get_element_type;\n export is_binopable;\n export is_pred_ty;\n-export lookup_class_item_tys;\n+export lookup_class_fields;\n+export lookup_field_type;\n export lookup_item_type;\n export method;\n export method_idx;\n@@ -158,17 +158,12 @@ type constr_table = hashmap<ast::node_id, [constr]>;\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n-type class_item_ty = {\n+// Just use <field> for class fields?\n+type field_ty = {\n   ident: ident,\n-  id: node_id,\n-  contents: class_contents_ty\n+  id: def_id,\n };\n \n-enum class_contents_ty {\n-  var_ty(t),   // FIXME: need mutability, too\n-  method_ty(fn_decl)\n-}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, t>;\n@@ -1971,6 +1966,9 @@ mod unify {\n         cx: @uctxt, expected: t, actual: t,\n         variance: variance, nxt: fn(t) -> ures<T>) -> ures<T> {\n \n+        #debug(\"unify_step: %s %s\", ty_to_str(cx.tcx, expected),\n+               ty_to_str(cx.tcx, actual));\n+\n         // Fast path.\n         if expected == actual { ret nxt(expected); }\n \n@@ -2434,15 +2432,40 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     }\n }\n \n+// Look up a field ID, whether or not it's local\n+fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id) -> ty::t {\n+    if id.crate == ast::local_crate {\n+            /*\n+        alt items.find(tcx.items, id.node) {\n+           some(ast_map::node_item({node: item_class(_,items,\n+        }\n+            */\n+        node_id_to_type(tcx, id.node)\n+    }\n+    else {\n+        alt tcx.tcache.find(id) {\n+           some(tpt) { ret tpt.ty; }\n+           none {\n+               let tpt = csearch::get_field_type(tcx, class_id, id);\n+               // ok b/c fields are monomorphic\n+               // TODO: Comment might be a lie, what if it mentions\n+               // class-bound ty params?\n+               tcx.tcache.insert(id, tpt);\n+               ret tpt.ty;\n+           }\n+        }\n+    }\n+}\n+\n // Look up the list of item types for a given class\n // Fails if the id is not bound to a class.\n-fn lookup_class_item_tys(cx: ctxt, did: ast::def_id) -> [@class_item_ty] {\n+fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n   if did.crate == ast::local_crate {\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(i,_)) {\n          alt i.node {\n            ast::item_class(_, items, _) {\n-               class_item_tys(cx, items)\n+               class_field_tys(items)\n            }\n            _ { cx.sess.bug(\"class ID bound to non-class\"); }\n          }\n@@ -2451,27 +2474,19 @@ fn lookup_class_item_tys(cx: ctxt, did: ast::def_id) -> [@class_item_ty] {\n     }\n         }\n   else {\n-        ret csearch::get_class_items(cx, did);\n+        ret csearch::get_class_fields(cx, did);\n     }\n }\n \n // must be called after typechecking?\n-fn class_item_tys(cx: ctxt, items: [@class_item]) -> [@class_item_ty] {\n+fn class_field_tys(items: [@class_item]) -> [field_ty] {\n     let rslt = [];\n     for it in items {\n        alt it.node.decl {\n           instance_var(nm, _, _, id) {\n-              rslt += [@{ident: nm, id: id,\n-                        contents: var_ty(node_id_to_type(cx, id)) }];\n+              rslt += [{ident: nm, id: ast_util::local_def(id)}];\n           }\n-          class_method(it) {\n-              alt it.node {\n-                 item_fn(dec, _, _) {\n-                     rslt += [@{ident: it.ident, id: it.id,\n-                                 contents: method_ty(dec)}];\n-                 }\n-                 _ { fail; /* TODO */ }\n-               }\n+          class_method(_) {\n           }\n        }\n     }\n@@ -2482,19 +2497,11 @@ fn class_item_tys(cx: ctxt, items: [@class_item]) -> [@class_item_ty] {\n // (as if the class was a record). trans uses this\n fn class_items_as_fields(cx:ctxt, did: ast::def_id) -> [field] {\n     let rslt = [];\n-    for ci in lookup_class_item_tys(cx, did) {\n-       alt ci.contents {\n-          var_ty(t) {\n-             // consider all instance vars mutable, because the\n-             // constructor may mutate all vars\n-             rslt += [{ident: ci.ident, mt: {ty: t,\n-                             mutbl: m_mutbl}}];\n-          }\n-         /* do nothing, since methods don't have a runtime\n-          representation? */\n-          method_ty(_) {\n-          }\n-       }\n+    for f in lookup_class_fields(cx, did) {\n+       // consider all instance vars mutable, because the\n+       // constructor may mutate all vars\n+      rslt += [{ident: f.ident, mt: {ty: lookup_field_type(cx, did, f.id),\n+                  mutbl: m_mutbl}}];\n     }\n     rslt\n }"}, {"sha": "87bb55e1b765da687a225a87ffbd3e268ea8deb1", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 110, "deletions": 72, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -1,7 +1,7 @@\n import result::result;\n import syntax::{ast, ast_util};\n import ast::spanned;\n-import syntax::ast_util::{local_def, respan};\n+import syntax::ast_util::{local_def, respan, split_class_items};\n import syntax::visit;\n import metadata::csearch;\n import driver::session::session;\n@@ -11,7 +11,7 @@ import pat_util::*;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n-                    ty_param_bounds_and_ty, lookup_class_item_tys};\n+                    ty_param_bounds_and_ty, lookup_class_fields};\n import util::ppaux::ty_to_str;\n import std::smallintmap;\n import std::map::{hashmap, int_hash};\n@@ -896,20 +896,38 @@ mod collect {\n           }\n         }\n     }\n-    fn convert_class_item(tcx: ty::ctxt, ci: ast::class_member) {\n+    fn convert_class_item(tcx: ty::ctxt, v: ast_util::ivar) {\n         /* we want to do something here, b/c within the\n          scope of the class, it's ok to refer to fields &\n         methods unqualified */\n \n         /* they have these types *within the scope* of the\n          class. outside the class, it's done with expr_field */\n-        alt ci {\n-         ast::instance_var(_,t,_,id) {\n-             let tt = ast_ty_to_ty(tcx, m_collect, t);\n-             write_ty(tcx, id, tt);\n-         }\n-         ast::class_method(it) { convert(tcx, it); }\n-        }\n+        let tt = ast_ty_to_ty(tcx, m_collect, v.ty);\n+        #debug(\"convert_class_item: %s %?\", v.ident, v.id);\n+        write_ty(tcx, v.id, tt);\n+    }\n+    fn convert_methods(tcx: ty::ctxt, ms: [@ast::method],\n+        i_bounds: @[ty::param_bounds], maybe_self: option<ty::t>)\n+        -> [{mty: ty::method, id: ast::node_id, span: span}] {\n+        let my_methods = [];\n+        for m in ms {\n+           alt maybe_self {\n+              some(selfty) {\n+                write_ty(tcx, m.self_id, selfty);\n+              }\n+              _ {}\n+           }\n+           let bounds = ty_param_bounds(tcx, m_collect, m.tps);\n+           let mty = ty_of_method(tcx, m_collect, m);\n+           my_methods += [{mty: mty, id: m.id, span: m.span}];\n+           let fty = ty::mk_fn(tcx, mty.fty);\n+           tcx.tcache.insert(local_def(m.id),\n+                             {bounds: @(*i_bounds + *bounds),\n+                                     ty: fty});\n+           write_ty(tcx, m.id, fty);\n+        }\n+        my_methods\n     }\n     fn convert(tcx: ty::ctxt, it: @ast::item) {\n         alt it.node {\n@@ -922,22 +940,11 @@ mod collect {\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n             let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n-            let my_methods = [];\n             let selfty = ast_ty_to_ty(tcx, m_collect, selfty);\n             write_ty(tcx, it.id, selfty);\n             tcx.tcache.insert(local_def(it.id), {bounds: i_bounds,\n                                                  ty: selfty});\n-            for m in ms {\n-                write_ty(tcx, m.self_id, selfty);\n-                let bounds = ty_param_bounds(tcx, m_collect, m.tps);\n-                let mty = ty_of_method(tcx, m_collect, m);\n-                my_methods += [{mty: mty, id: m.id, span: m.span}];\n-                let fty = ty::mk_fn(tcx, mty.fty);\n-                tcx.tcache.insert(local_def(m.id),\n-                                     {bounds: @(*i_bounds + *bounds),\n-                                      ty: fty});\n-                write_ty(tcx, m.id, fty);\n-            }\n+            let my_methods = convert_methods(tcx, ms, i_bounds, some(selfty));\n             alt ifce {\n               some(t) {\n                 let iface_ty = ast_ty_to_ty(tcx, m_collect, t);\n@@ -1028,9 +1035,11 @@ mod collect {\n                                    {bounds: tpt.bounds, ty: t_ctor});\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n-              for m in members {\n-                 convert_class_item(tcx, m.node.decl);\n+              let (fields, methods) = split_class_items(members);\n+              for f in fields {\n+                 convert_class_item(tcx, f);\n               }\n+              convert_methods(tcx, methods, @[], none);\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -1732,8 +1741,10 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n         alt ccx.method_map.find(callee.id) {\n           some(method_static(did)) {\n             if did.crate == ast::local_crate {\n-                alt check ccx.tcx.items.get(did.node) {\n+                alt ccx.tcx.items.get(did.node) {\n                   ast_map::node_method(m, _, _) { m.decl.purity }\n+                  _ { ccx.tcx.sess.span_bug(sp,\n+                             \"Node not bound to a method\") }\n                 }\n             } else {\n                 csearch::lookup_method_purity(ccx.tcx.sess.cstore, did)\n@@ -1834,6 +1845,43 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n     }\n }\n \n+enum method_parent {\n+    cls(ast::def_id),\n+    an_iface(ast::def_id)\n+}\n+\n+fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n+    tps: [ty::t], parent: method_parent, name: ast::ident, sp: span)\n+    -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n+        origin: method_origin, self_sub: option<self_subst>}> {\n+    #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n+    let i = 0u;\n+    for m in ms  {\n+       if m.ident == name {\n+          let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n+          if ty::type_has_vars(fty) {\n+               tcx.sess.span_fatal(\n+                    sp, \"can not call a method that contains a \\\n+                                    self type through a boxed iface\");\n+          } else if (*m.tps).len() > 0u {\n+                   tcx.sess.span_fatal(\n+                        sp, \"can not call a generic method through a \\\n+                                    boxed iface\");\n+          }\n+          ret some({method_ty: fty,\n+                          n_tps: vec::len(*m.tps),\n+                          substs: tps,\n+                          origin: alt parent {\n+                                    cls(did) { method_static(did) }\n+                                    an_iface(did) { method_iface(did, i) }\n+                          },\n+                      self_sub: none});\n+       }\n+       i += 1u;\n+    }\n+    ret none;\n+}\n+\n fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n                        name: ast::ident, ty: ty::t)\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n@@ -1871,26 +1919,17 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         }\n       }\n       ty::ty_iface(did, tps) {\n-        let i = 0u;\n-        for m in *ty::iface_methods(tcx, did) {\n-            if m.ident == name {\n-                let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n-                if ty::type_has_vars(fty) {\n-                    tcx.sess.span_fatal(\n-                        expr.span, \"can not call a method that contains a \\\n-                                    self type through a boxed iface\");\n-                } else if (*m.tps).len() > 0u {\n-                    tcx.sess.span_fatal(\n-                        expr.span, \"can not call a generic method through a \\\n-                                    boxed iface\");\n-                }\n-                ret some({method_ty: fty,\n-                          n_tps: vec::len(*m.tps),\n-                          substs: tps,\n-                          origin: method_iface(did, i),\n-                          self_sub: none});\n-            }\n-            i += 1u;\n+        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n+                                 an_iface(did), name, expr.span) {\n+           some(r) { ret some(r); }\n+           none {  }\n+        }\n+      }\n+      ty::ty_class(did, tps) {\n+        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n+                                 cls(did), name, expr.span) {\n+          some(r) { ret some(r); }\n+          none    { }\n         }\n       }\n       _ {}\n@@ -1957,19 +1996,12 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     result\n }\n \n-// problem -- class_item_ty should really be only used for internal stuff.\n-// or should have a privacy field.\n-fn lookup_field_ty(cx: ty::ctxt, items:[@ty::class_item_ty],\n-                   fieldname: ast::ident, sp: span)\n-    -> ty::t {\n-    for item in items {\n-            #debug(\"%s $$$ %s\", fieldname, item.ident);\n-        alt item.contents {\n-          ty::var_ty(t) if item.ident == fieldname { ret t; }\n-          _ { }\n-        }\n-    }\n-    cx.sess.span_fatal(sp, #fmt(\"unbound field %s\", fieldname));\n+// Only for fields! Returns <none> for methods>\n+// FIXME: privacy flags\n+fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n+  items:[ty::field_ty], fieldname: ast::ident) -> option<ty::t> {\n+    option::map(vec::find(items, {|f| f.ident == fieldname}),\n+                {|f| ty::lookup_field_type(tcx, class_id, f.id) })\n }\n \n /*\n@@ -2053,6 +2085,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n+\n     #debug(\"typechecking expr %s\",\n            syntax::print::pprust::expr_to_str(expr));\n \n@@ -2191,10 +2224,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n                        f: @ast::expr, args: [@ast::expr]) -> bool {\n         let bot = check_call(fcx, sp, id, f, args);\n-        /* here we're kind of hosed, as f can be any expr\n-        need to restrict it to being an explicit expr_path if we're\n-        inside a pure function, and need an environment mapping from\n-        function name onto purity-designation */\n+        /* need to restrict oper to being an explicit expr_path if we're\n+        inside a pure function */\n         require_pure_call(fcx.ccx, fcx.purity, f, sp);\n \n         // Pull the return type out of the type of the function.\n@@ -2774,13 +2805,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           ty::ty_class(base_id, _params) {\n               // (1) verify that the class id actually has a field called\n               // field\n-              let cls_items = lookup_class_item_tys(tcx, base_id);\n-              let field_ty = lookup_field_ty(fcx.ccx.tcx, cls_items, field,\n-                                             expr.span);\n-              // (2) look up what field's type is, and return it\n-              // FIXME: actually instantiate any type params\n-              write_ty(tcx, id, field_ty);\n-              handled = true;\n+              #debug(\"class named %s\", ty_to_str(tcx, base_t));\n+              let cls_items = lookup_class_fields(tcx, base_id);\n+              #debug(\"cls_items: %?\", cls_items);\n+              alt lookup_field_ty(tcx, base_id, cls_items, field) {\n+                 some(field_ty) {\n+                     #debug(\"a\");\n+                    // (2) look up what field's type is, and return it\n+                    // FIXME: actually instantiate any type params\n+                     write_ty(tcx, id, field_ty);\n+                     handled = true;\n+                 }\n+                 none { #debug(\"b\"); }\n+              }\n           }\n           _ {}\n         }\n@@ -3226,8 +3263,9 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n          ast::instance_var(_,t,_,id) {\n            rslt.insert(id, ast_ty_to_ty(ccx.tcx, m_collect, t));\n          }\n-         ast::class_method(it) {\n-             rslt.insert(it.id, ty_of_item(ccx.tcx, m_collect, it).ty);\n+         ast::class_method(mth) {\n+             rslt.insert(mth.id, ty::mk_fn(ccx.tcx,\n+                   ty_of_method(ccx.tcx, m_collect, mth).fty));\n          }\n       }\n     }\n@@ -3239,7 +3277,7 @@ fn check_class_member(ccx: @crate_ctxt, cm: ast::class_member) {\n       ast::instance_var(_,t,_,_) { // ??? Not sure\n       }\n       // not right yet -- need a scope\n-      ast::class_method(i) { check_item(ccx, i); }\n+      ast::class_method(m) { check_method(ccx, m); }\n     }\n }\n "}, {"sha": "db0f6a56d8020434b75ec2226ab523884fc15fe8", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -659,10 +659,10 @@ type class_item = spanned<class_item_>;\n #[auto_serialize]\n enum class_member {\n     instance_var(ident, @ty, class_mutability, node_id),\n-    class_method(@item) // FIXME: methods aren't allowed to be\n-    // type-parametric.\n+    class_method(@method)\n     // without constrained types, have to duplicate some stuff. or factor out\n     // item to separate out things with type params?\n+    // (FIXME) where do we enforce that type params is empty?\n }\n \n #[auto_serialize]"}, {"sha": "5625fecb95399db426dc016c23b8c036c1de811f", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -433,6 +433,21 @@ pure fn class_item_ident(ci: @class_item) -> ident {\n     }\n }\n \n+type ivar = {ident: ident, ty: @ty, cm: class_mutability, id: node_id};\n+\n+fn split_class_items(cs: [@class_item]) -> ([ivar], [@method]) {\n+    let vs = [], ms = [];\n+    for c in cs {\n+      alt c.node.decl {\n+        instance_var(i, t, cm, id) {\n+          vs += [{ident: i, ty: t, cm: cm, id: id}];\n+        }\n+        class_method(m) { ms += [m]; }\n+      }\n+    }\n+    (vs, ms)\n+}\n+\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n@@ -455,7 +470,6 @@ impl inlined_item_methods for inlined_item {\n         }\n     }\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "0927c94887f67bd8030c38f53777edd732b5850b", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -249,7 +249,7 @@ fn noop_fold_class_item(&&ci: @class_item, fld: ast_fold)\n         instance_var(ident, t, cm, id) {\n             instance_var(ident, fld.fold_ty(t), cm, id)\n         }\n-        class_method(i) { class_method(fld.fold_item(i)) }\n+        class_method(m) { class_method(fld.fold_method(m)) }\n          }},\n        span: fld.new_span(ci.span)}\n }\n@@ -656,8 +656,8 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n                instance_var(nm, f_ty(afp, f, t),\n                                  mt, id)\n            }\n-           class_method(i) {\n-               class_method(afp.fold_item(i, f))\n+           class_method(m) {\n+               class_method(afp.fold_method(m, f))\n            }\n             }}, span: afp.new_span(ci.span)}\n     }"}, {"sha": "4fe7aade41cd873b984cb9f5a47efa40742f25fe", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -1648,10 +1648,10 @@ fn parse_let(p: parser) -> @ast::decl {\n     ret @spanned(lo, p.last_span.hi, ast::decl_local(locals));\n }\n \n+/* assumes \"let\" token has already been consumed */\n fn parse_instance_var(p:parser) -> (ast::class_member, codemap::span) {\n     let is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n-    expect_word(p, \"let\");\n     if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n             is_mutbl = ast::class_mutable;\n     }\n@@ -2104,31 +2104,29 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n             expect(p, token::LBRACE);\n             let results = [];\n             while p.token != token::RBRACE {\n-               alt parse_item(p, []) {\n-                 some(i) {\n-                     results += [(ast::class_method(i), i.span)];\n-                 }\n-                 _ {\n-                     let a_var = parse_instance_var(p);\n-                     expect(p, token::SEMI);\n-                     results += [a_var];\n-                 }\n+               if eat_word(p, \"let\") {\n+                  let a_var = parse_instance_var(p);\n+                  expect(p, token::SEMI);\n+                  results += [a_var];\n+               }\n+               else {\n+                   let m = parse_method(p);\n+                   results += [(ast::class_method(m), m.span)];\n                }\n             }\n             p.bump();\n             ret priv_decls(results);\n     }\n     else {\n         // Probably need to parse attrs\n-        alt parse_item(p, []) {\n-         some(i) {\n-             ret plain_decl(ast::class_method(i), i.span);\n-         }\n-         _ {\n+        ret if eat_word(p, \"let\") {\n              let (a_var, a_span) = parse_instance_var(p);\n              expect(p, token::SEMI);\n-             ret plain_decl(a_var, a_span);\n-         }\n+             plain_decl(a_var, a_span)\n+        }\n+        else {\n+            let m = parse_method(p);\n+            plain_decl(ast::class_method(m), m.span)\n         }\n     }\n }"}, {"sha": "e10262117a4573becf6bdc02afd73d4905f107d7", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -526,8 +526,8 @@ fn print_item(s: ps, &&item: @ast::item) {\n                     print_type(s, t);\n                     word(s.s, \";\");\n                 }\n-                ast::class_method(i) {\n-                    print_item(s, i);\n+                ast::class_method(m) {\n+                    print_method(s, m);\n                 }\n              }\n              alt ci.node.privacy {\n@@ -555,12 +555,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         space(s.s);\n         bopen(s);\n         for meth in methods {\n-            hardbreak_if_not_bol(s);\n-            maybe_print_comment(s, meth.span.lo);\n-            print_outer_attributes(s, meth.attrs);\n-            print_fn(s, meth.decl, meth.ident, meth.tps);\n-            word(s.s, \" \");\n-            print_block_with_attrs(s, meth.body, meth.attrs);\n+           print_method(s, meth);\n         }\n         bclose(s, item.span);\n       }\n@@ -621,6 +616,15 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     word(s.s, \";\");\n }\n \n+fn print_method(s: ps, meth: @ast::method) {\n+    hardbreak_if_not_bol(s);\n+    maybe_print_comment(s, meth.span.lo);\n+    print_outer_attributes(s, meth.attrs);\n+    print_fn(s, meth.decl, meth.ident, meth.tps);\n+    word(s.s, \" \");\n+    print_block_with_attrs(s, meth.body, meth.attrs);\n+}\n+\n fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute in attrs {"}, {"sha": "c0b7eea6acef316dd55d3f4d749463e3a1366e42", "filename": "src/rustc/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Frustc%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fvisit.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -157,8 +157,8 @@ fn visit_class_item<E>(_s: span, _p: privacy, cm: class_member,\n         instance_var(ident, t, mt, id) {\n             v.visit_ty(t, e, v);\n         }\n-        class_method(i) {\n-            v.visit_item(i, e, v);\n+        class_method(m) {\n+            visit_method_helper(m, e, v);\n         }\n     }\n }"}, {"sha": "2c7c2c7c480d944c59f55466fc94ea93e43f67c2", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06dc884e57644a0c7e9c5391af9e0392e5f49ac/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=b06dc884e57644a0c7e9c5391af9e0392e5f49ac", "patch": "@@ -8,12 +8,18 @@ class cat {\n \n   new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n \n-  fn speak() { fail; }\n+  fn speak() {}\n+  /*\n+  fn speak() { meows += 1u; }\n+  fn meow_count() -> uint { meows }\n+  */\n }\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n   let kitty = cat(1000u, 2);\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n+  nyan.speak();\n+  //  assert(nyan.meow_count() == 53u);\n }"}]}