{"sha": "b613ef552d0c598877085e8c5b0d740b17683c24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MTNlZjU1MmQwYzU5ODg3NzA4NWU4YzViMGQ3NDBiMTc2ODNjMjQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-19T13:17:15Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-05-19T13:17:15Z"}, "message": "Rollup merge of #25580 - killercup:trpl/unify-code-blocks, r=steveklabnik\n\nThis adds strictly more information to the source files and reduces the need for customized tooling to render the book. (While this should not change the output of _rustbook_, it is very useful when rendering the sources with external tools like Pandoc.)\r\n\r\nThis only adds the language marker to \"first level\" code blocks (and not to code blocks in comments inside of code examples).\r\n\r\nr? @steveklabnik", "tree": {"sha": "341e750b390403aca298d86b846487f41e264b46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/341e750b390403aca298d86b846487f41e264b46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b613ef552d0c598877085e8c5b0d740b17683c24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b613ef552d0c598877085e8c5b0d740b17683c24", "html_url": "https://github.com/rust-lang/rust/commit/b613ef552d0c598877085e8c5b0d740b17683c24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b613ef552d0c598877085e8c5b0d740b17683c24/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc50fd6f31f2037acf41d66005fbd820a6eee297", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc50fd6f31f2037acf41d66005fbd820a6eee297", "html_url": "https://github.com/rust-lang/rust/commit/cc50fd6f31f2037acf41d66005fbd820a6eee297"}, {"sha": "f3adea5ce915166e1cbc15e112d87a991ad6c123", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3adea5ce915166e1cbc15e112d87a991ad6c123", "html_url": "https://github.com/rust-lang/rust/commit/f3adea5ce915166e1cbc15e112d87a991ad6c123"}], "stats": {"total": 213, "additions": 107, "deletions": 106}, "files": [{"sha": "797ec94774d7d7c893f36313718959c6bcad4f48", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -3,7 +3,7 @@\n Rust supports benchmark tests, which can test the performance of your\n code. Let's make our `src/lib.rs` look like this (comments elided):\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;\n@@ -77,7 +77,7 @@ the benchmark is no longer benchmarking what one expects. For example, the\n compiler might recognize that some calculation has no external effects and\n remove it entirely.\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;"}, {"sha": "1cfeb2620bd08d6fc16b5ae1a7779af4f4366822", "filename": "src/doc/trpl/borrow-and-asref.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -51,7 +51,7 @@ kind of borrowed value. This is especially true of references and slices: you\n can have both an `&T` or a `&mut T`. If we wanted to accept both of these types,\n `Borrow` is up for it:\n \n-```\n+```rust\n use std::borrow::Borrow;\n use std::fmt::Display;\n "}, {"sha": "1cf84bfd658c04b9facbbbf9f5e63e6d76d4705a", "filename": "src/doc/trpl/box-syntax-and-patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -5,7 +5,7 @@ Also it is not possible in stable Rust to destructure a `Box` in a match\n pattern. The unstable `box` keyword can be used to both create and destructure\n a `Box`. An example usage would be:\n \n-```\n+```rust\n #![feature(box_syntax, box_patterns)]\n \n fn main() {\n@@ -34,7 +34,7 @@ because the syntax may still change in the future.\n In many languages with pointers, you'd return a pointer from a function\n so as to avoid copying a large data structure. For example:\n \n-```{rust}\n+```rust\n struct BigStruct {\n     one: i32,\n     two: i32,"}, {"sha": "ccd769089d2519b60218ed8a346f251d72b7f66b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -59,7 +59,7 @@ place!\n Rust's standard library provides a library for threads, which allow you to\n run Rust code in parallel. Here's a basic example of using `std::thread`:\n \n-```\n+```rust\n use std::thread;\n \n fn main() {\n@@ -73,7 +73,7 @@ The `thread::spawn()` method accepts a closure, which is executed in a\n new thread. It returns a handle to the thread, that can be used to\n wait for the child thread to finish and extract its result:\n \n-```\n+```rust\n use std::thread;\n \n fn main() {\n@@ -189,7 +189,7 @@ guard across thread boundaries, which gives us our error.\n \n We can use `Arc<T>` to fix this. Here's the working version:\n \n-```\n+```rust\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n@@ -248,7 +248,7 @@ threads with each other. Let's talk about one of them: channels.\n Here's a version of our code that uses channels for synchronization, rather\n than waiting for a specific time:\n \n-```\n+```rust\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::sync::mpsc;\n@@ -281,7 +281,7 @@ a simple `()` down the channel, and then wait for ten of them to come back.\n While this channel is just sending a generic signal, we can send any data that\n is `Send` over the channel!\n \n-```\n+```rust\n use std::thread;\n use std::sync::mpsc;\n \n@@ -311,7 +311,7 @@ the answer, and then it `send()`s us the answer over the channel.\n A `panic!` will crash the currently executing thread. You can use Rust's\n threads as a simple isolation mechanism:\n \n-```\n+```rust\n use std::thread;\n \n let result = thread::spawn(move || {"}, {"sha": "63fdef0760febf66cc5ef05a79341136b67ac3d1", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -75,7 +75,7 @@ above.\n To define each of our modules, we use the `mod` keyword. Let\u2019s make our\n `src/lib.rs` look like this:\n \n-```\n+```rust\n mod english {\n     mod greetings {\n     }\n@@ -126,15 +126,15 @@ ways.\n \n Instead of declaring a module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english {\n     // contents of our module go here\n }\n ```\n \n We can instead declare our module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n ```\n \n@@ -173,7 +173,7 @@ $ tree .\n \n `src/lib.rs` is our crate root, and looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n mod japanese;\n ```\n@@ -184,7 +184,7 @@ on our preference. In this case, because our modules have sub-modules, we\u2019ve\n chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod greetings;\n mod farewells;\n ```\n@@ -297,7 +297,7 @@ public, and so private is the default. To make things public, you use the `pub`\n keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n to just this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n fn main() {\n@@ -308,29 +308,29 @@ fn main() {\n \n In our `src/lib.rs`, let\u2019s add `pub` to the `english` module declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n mod japanese;\n ```\n \n And in our `src/english/mod.rs`, let\u2019s make both `pub`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod greetings;\n pub mod farewells;\n ```\n \n In our `src/english/greetings.rs`, let\u2019s add `pub` to our `fn` declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"Hello!\".to_string()\n }\n ```\n \n And also in `src/english/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n }\n@@ -365,7 +365,7 @@ refer to them with shorter names. Let\u2019s talk about `use`.\n Rust has a `use` keyword, which allows us to import names into our local scope.\n Let\u2019s change our `src/main.rs` to look like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings;\n@@ -382,7 +382,7 @@ the functions by a much shorter name. By convention, when importing functions, i\n considered best practice to import the module, rather than the function directly. In\n other words, you _can_ do this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -400,7 +400,7 @@ becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -426,14 +426,14 @@ Could not compile `phrases`.\n If we\u2019re importing multiple names from the same module, we don\u2019t have to type it out\n twice. Instead of this:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::greetings;\n use phrases::english::farewells;\n ```\n \n We can use this shortcut:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::{greetings, farewells};\n ```\n \n@@ -445,7 +445,7 @@ interface that may not directly map to your internal code organization.\n \n Let\u2019s look at an example. Modify your `src/main.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::{greetings,farewells};\n@@ -462,30 +462,30 @@ fn main() {\n \n Then, modify your `src/lib.rs` to make the `japanese` mod public:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n pub mod japanese;\n ```\n \n Next, make the two functions public, first in `src/japanese/greetings.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n }\n ```\n \n And then in `src/japanese/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n }\n ```\n \n Finally, modify your `src/japanese/mod.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub use self::greetings::hello;\n pub use self::farewells::goodbye;\n "}, {"sha": "4accba90e6cdbd6cc5491af8a0919c57fc13de34", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -42,7 +42,7 @@ Documentation comments are written in Markdown.\n Rust keeps track of these comments, and uses them when generating\n documentation. This is important when documenting things like enums:\n \n-```\n+```rust\n /// The `Option` type. See [the module level documentation](../) for more.\n enum Option<T> {\n     /// No value\n@@ -80,15 +80,15 @@ thing after that last comment.\n \n Anyway, let's cover each part of this comment in detail:\n \n-```\n+```rust\n /// Constructs a new `Rc<T>`.\n # fn foo() {}\n ```\n \n The first line of a documentation comment should be a short summary of its\n functionality. One sentence. Just the basics. High level.\n \n-```\n+```rust\n ///\n /// Other details about constructing `Rc<T>`s, maybe describing complicated\n /// semantics, maybe additional options, all kinds of stuff.\n@@ -101,7 +101,7 @@ we could have added more explanation in a new paragraph.\n \n #### Special sections\n \n-```\n+```rust\n /// # Examples\n # fn foo() {}\n ```\n@@ -110,7 +110,7 @@ Next, are special sections. These are indicated with a header, `#`. There\n are three kinds of headers that are commonly used. They aren't special syntax,\n just convention, for now.\n \n-```\n+```rust\n /// # Panics\n # fn foo() {}\n ```\n@@ -120,7 +120,7 @@ usually indicated by panics, which kill the whole current thread at the very\n least. If your function has a non-trivial contract like this, that is\n detected/enforced by panics, documenting it is very important.\n \n-```\n+```rust\n /// # Failures\n # fn foo() {}\n ```\n@@ -130,15 +130,15 @@ conditions under which it returns `Err(E)` is a nice thing to do. This is\n slightly less important than `Panics`, because failure is encoded into the type\n system, but it's still a good thing to do.\n \n-```\n+```rust\n /// # Safety\n # fn foo() {}\n ```\n \n If your function is `unsafe`, you should explain which invariants the caller is\n responsible for upholding.\n \n-```\n+```rust\n /// # Examples\n ///\n /// ```\n@@ -154,7 +154,7 @@ method, and your users will love you for it. These examples go inside of\n code block annotations, which we'll talk about in a moment, and can have\n more than one section:\n \n-```\n+```rust\n /// # Examples\n ///\n /// Simple `&str` patterns:\n@@ -179,7 +179,7 @@ Let's discuss the details of these code blocks.\n \n To write some Rust code in a comment, use the triple graves:\n \n-```\n+```rust\n /// ```\n /// println!(\"Hello, world\");\n /// ```\n@@ -188,7 +188,7 @@ To write some Rust code in a comment, use the triple graves:\n \n If you want something that's not Rust code, you can add an annotation:\n \n-```\n+```rust\n /// ```c\n /// printf(\"Hello, world\\n\");\n /// ```\n@@ -208,7 +208,7 @@ generate the documentation.\n \n Let's discuss our sample example documentation:\n \n-```\n+```rust\n /// ```\n /// println!(\"Hello, world\");\n /// ```\n@@ -219,7 +219,7 @@ You'll notice that you don't need a `fn main()` or anything here. `rustdoc` will\n automatically add a main() wrapper around your code, and in the right place.\n For example:\n \n-```\n+```rust\n /// ```\n /// use std::rc::Rc;\n ///\n@@ -230,7 +230,7 @@ For example:\n \n This will end up testing:\n \n-```\n+```rust\n fn main() {\n     use std::rc::Rc;\n     let five = Rc::new(5);\n@@ -259,7 +259,7 @@ with `///` we've been talking about? The raw text:\n \n looks different than the output:\n \n-```\n+```rust\n /// Some documentation.\n # fn foo() {}\n ```\n@@ -274,7 +274,7 @@ it makes the example more clear. You can use this technique to explain\n longer examples in detail, while still preserving the testability of your\n documentation. For example, this code:\n \n-```\n+```rust\n let x = 5;\n let y = 6;\n println!(\"{}\", x + y);\n@@ -284,23 +284,23 @@ Here's an explanation, rendered:\n \n First, we set `x` to five:\n \n-```\n+```rust\n let x = 5;\n # let y = 6;\n # println!(\"{}\", x + y);\n ```\n \n Next, we set `y` to six:\n \n-```\n+```rust\n # let x = 5;\n let y = 6;\n # println!(\"{}\", x + y);\n ```\n \n Finally, we print the sum of `x` and `y`:\n \n-```\n+```rust\n # let x = 5;\n # let y = 6;\n println!(\"{}\", x + y);\n@@ -340,7 +340,7 @@ explanation.\n \n Here\u2019s an example of documenting a macro:\n \n-```\n+```rust\n /// Panic with a given message unless an expression evaluates to true.\n ///\n /// # Examples\n@@ -388,7 +388,7 @@ but with a binary, there\u2019s nothing to link to.\n There are a few more annotations that are useful to help `rustdoc` do the right\n thing when testing your code:\n \n-```\n+```rust\n /// ```ignore\n /// fn foo() {\n /// ```\n@@ -400,7 +400,7 @@ what you want, as it's the most generic. Instead, consider annotating it\n with `text` if it's not code, or using `#`s to get a working example that\n only shows the part you care about.\n \n-```\n+```rust\n /// ```should_panic\n /// assert!(false);\n /// ```\n@@ -410,7 +410,7 @@ only shows the part you care about.\n `should_panic` tells `rustdoc` that the code should compile correctly, but\n not actually pass as a test.\n \n-```\n+```rust\n /// ```no_run\n /// loop {\n ///     println!(\"Hello, world\");\n@@ -427,7 +427,7 @@ which you would want to make sure compile, but might run in an infinite loop!\n \n Rust has another kind of doc comment, `//!`. This comment doesn't document the next item, but the enclosing item. In other words:\n \n-```\n+```rust\n mod foo {\n     //! This is documentation for the `foo` module.\n     //!\n@@ -440,7 +440,7 @@ mod foo {\n This is where you'll see `//!` used most often: for module documentation. If\n you have a module in `foo.rs`, you'll often open its code and see this:\n \n-```\n+```rust\n //! A module for using `foo`s.\n //!\n //! The `foo` module contains a lot of useful functionality blah blah blah\n@@ -461,7 +461,7 @@ are written in Markdown, they're often `.md` files.\n When you write documentation in Markdown files, you don't need to prefix\n the documentation with comments. For example:\n \n-```\n+```rust\n /// # Examples\n ///\n /// ```\n@@ -499,7 +499,7 @@ This `%` line needs to be the very first line of the file.\n \n At a deeper level, documentation comments are sugar for documentation attributes:\n \n-```\n+```rust\n /// this\n # fn foo() {}\n \n@@ -509,7 +509,7 @@ At a deeper level, documentation comments are sugar for documentation attributes\n \n are the same, as are these:\n \n-```\n+```rust\n //! this\n \n #![doc=\"/// this\"]\n@@ -546,7 +546,7 @@ pub use foo::bar;\n You can control a few aspects of the HTML that `rustdoc` generates through the\n `#![doc]` version of the attribute:\n \n-```\n+```rust\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")];"}, {"sha": "7b47559e0fce05f51b6dfd4d79bab2357d74843a", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -49,7 +49,7 @@ We use `assert!` to declare that something is true. If it's not true, something\n is very wrong. Wrong enough that we can't continue with things in the current\n state. Another example is using the `unreachable!()` macro:\n \n-```{rust,ignore}\n+```rust,ignore\n enum Event {\n     NewRelease,\n }\n@@ -188,7 +188,7 @@ The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum\n In the case of an error that is unexpected and not recoverable, the `panic!`\n macro will induce a panic. This will crash the current thread, and give an error:\n \n-```{rust,ignore}\n+```rust,ignore\n panic!(\"boom\");\n ```\n \n@@ -212,7 +212,7 @@ handle and possibly recover from error.\n If we don't want to handle this error, and would rather just abort the program,\n we can use the `unwrap()` method:\n \n-```{rust,ignore}\n+```rust,ignore\n io::stdin().read_line(&mut buffer).unwrap();\n ```\n \n@@ -223,7 +223,7 @@ shorter. Sometimes, just crashing is appropriate.\n \n There's another way of doing this that's a bit nicer than `unwrap()`:\n \n-```{rust,ignore}\n+```rust,ignore\n let mut buffer = String::new();\n let input = io::stdin().read_line(&mut buffer)\n                        .ok()"}, {"sha": "9ede835e521c9a7e26212cec3c96392f537269be", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -81,7 +81,7 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{c_int, size_t};\n@@ -106,7 +106,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n@@ -133,7 +133,7 @@ pub fn compress(src: &[u8]) -> Vec<u8> {\n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n@@ -375,7 +375,7 @@ the compiler that the unsafety does not leak out of the block.\n Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n this:\n \n-```\n+```rust\n unsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n ```\n \n@@ -439,7 +439,7 @@ Most foreign code exposes a C ABI, and Rust uses the platform's C calling conven\n calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n conventions. Rust provides a way to tell the compiler which convention to use:\n \n-```\n+```rust\n # #![feature(libc)]\n extern crate libc;\n \n@@ -516,7 +516,7 @@ function pointer using the C ABI.\n You may wish to compile Rust code in a way so that it can be called from C. This is\n fairly easy, but requires a few things:\n \n-```\n+```rust\n #[no_mangle]\n pub extern fn hello_rust() -> *const u8 {\n     \"Hello, world!\\0\".as_ptr()"}, {"sha": "21a29f005998717c2b2084ce0c5e0b57d1d11561", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -146,7 +146,7 @@ expression, although its value is not particularly useful. Unlike other\n languages where an assignment evaluates to the assigned value (e.g. `5` in the\n previous example), in Rust the value of an assignment is an empty tuple `()`:\n \n-```\n+```rust\n let mut y = 5;\n \n let x = (y = 6);  // x has the value `()`, not `6`\n@@ -204,7 +204,7 @@ time.\n Rust has some special syntax for \u2018diverging functions\u2019, which are functions that\n do not return:\n \n-```\n+```rust\n fn diverges() -> ! {\n     panic!(\"This function never returns!\");\n }"}, {"sha": "f8f1962e0cf5565bb6342f1bf538b39b7229186b", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -110,7 +110,7 @@ Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover i\n \n You can store a generic type in a `struct` as well:\n \n-```\n+```rust\n struct Point<T> {\n     x: T,\n     y: T,"}, {"sha": "4220b4d04afa25c8b0d6f09b60f9d16e27955b3b", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -151,7 +151,7 @@ take a name on the left hand side, it actually accepts a\n \u2018[pattern][patterns]\u2019. We\u2019ll use patterns more later. It\u2019s easy enough\n to use for now:\n \n-```\n+```rust\n let foo = 5; // immutable.\n let mut bar = 5; // mutable\n ```"}, {"sha": "4d9166d63bfb7e81b36c316effcde41382c63c6b", "filename": "src/doc/trpl/inline-assembly.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -25,7 +25,7 @@ crate to allow) and of course requires an `unsafe` block.\n The `assembly template` is the only required parameter and must be a\n literal string (i.e. `\"\"`)\n \n-```\n+```rust\n #![feature(asm)]\n \n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n@@ -51,7 +51,7 @@ fn main() {\n Output operands, input operands, clobbers and options are all optional\n but you must add the right number of `:` if you skip them:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -65,7 +65,7 @@ asm!(\"xor %eax, %eax\"\n \n Whitespace also doesn't matter:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -79,7 +79,7 @@ Input and output operands follow the same format: `:\n \"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n expressions must be mutable lvalues, or not yet assigned:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n fn add(a: i32, b: i32) -> i32 {\n@@ -106,7 +106,7 @@ you want, and you are required to put the specific size of the\n operand. This is useful for very low level programming, where \n which register you use is important:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # unsafe fn read_byte_in(port: u16) -> u8 {\n@@ -123,7 +123,7 @@ different values so we use the clobbers list to indicate to the\n compiler not to assume any values loaded into those registers will\n stay valid.\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -155,7 +155,7 @@ Current valid options are:\n    the compiler to insert its usual stack alignment code\n 3. *intel* - use intel syntax instead of the default AT&T.\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() {"}, {"sha": "e0a8bb59e346a042119896a727cc0d0d986246ff", "filename": "src/doc/trpl/intrinsics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintrinsics.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -10,7 +10,7 @@ context, but wished to be able to `transmute` between types, and\n perform efficient pointer arithmetic, one would import those functions\n via a declaration like\n \n-```\n+```rust\n # #![feature(intrinsics)]\n # fn main() {}\n "}, {"sha": "80c0def285ab534163150f1e09b30ac2c9795588", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -116,7 +116,7 @@ A *consumer* operates on an iterator, returning some kind of value or values.\n The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n-```{rust,ignore}\n+```rust,ignore\n let one_to_one_hundred = (1..101).collect();\n ```\n \n@@ -253,7 +253,7 @@ we need to talk about with regards to iterators. Let's get to it!\n *Iterator adapters* take an iterator and modify it somehow, producing\n a new iterator. The simplest one is called `map`:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| x + 1);\n ```\n \n@@ -272,7 +272,7 @@ warning: unused result which must be used: iterator adaptors are lazy and\n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| println!(\"{}\", x));\n ```\n "}, {"sha": "8e7504c2f18ea5eb76bba3b5f02857ae98a5e17c", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -15,7 +15,7 @@ For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n-```\n+```rust\n #![feature(lang_items, box_syntax, start, no_std, libc)]\n #![no_std]\n "}, {"sha": "ce06987013d3ccd22913a30b736a5e4d95b3e250", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -698,6 +698,7 @@ assert_eq!(5, 3 + 2);\n assert!(5 < 3);\n assert_eq!(5, 3);\n ```\n+\n ## try!\n \n `try!` is used for error handling. It takes something that can return a"}, {"sha": "e5f490e15e13e64a8b0dd102bd1197a244ebdd2b", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -89,7 +89,7 @@ So, now we know how to call a method, such as `foo.bar()`. But what about our\n original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n can do it by returning `self`.\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -117,7 +117,7 @@ fn main() {\n \n Check the return type:\n \n-```\n+```rust\n # struct Circle;\n # impl Circle {\n fn grow(&self) -> Circle {\n@@ -167,7 +167,7 @@ and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn\u2019t\n have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,"}, {"sha": "fe41def4d7cc3265150ed97aa987285b52fa24be", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -161,7 +161,7 @@ b.x = 10; // error: cannot assign to immutable field `b.x`\n \n However, by using `Cell<T>`, you can emulate field-level mutability:\n \n-```\n+```rust\n use std::cell::Cell;\n \n struct Point {"}, {"sha": "0a985334b5e4b694d797eb673986bc4fdebbbbe2", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -20,7 +20,7 @@ default shim for the C `main` function with your own.\n The function marked `#[start]` is passed the command line parameters\n in the same format as C:\n \n-```\n+```rust\n #![feature(lang_items, start, no_std, libc)]\n #![no_std]\n "}, {"sha": "027909dd058769c70031e0d32a8424a803c5e58b", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -251,7 +251,7 @@ This pattern is very powerful, and we\u2019ll see it repeated more later.\n You can disambiguate a single-element tuple from a value in parentheses with a\n comma:\n \n-```\n+```rust\n (0,); // single-element tuple\n (0); // zero in parentheses\n ```\n@@ -283,7 +283,7 @@ documentation][tuple].\n \n Functions also have a type! They look like this:\n \n-```\n+```rust\n fn foo(x: i32) -> i32 { x }\n \n let x: fn(i32) -> i32 = foo;"}, {"sha": "abe17a96b39a622edc648310cd74a57e4bc3a04b", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -38,7 +38,7 @@ println!(\"{}\", s);\n \n `String`s will coerce into `&str` with an `&`:\n \n-```\n+```rust\n fn takes_slice(slice: &str) {\n     println!(\"Got: {}\", slice);\n }"}, {"sha": "759543140b5769fd65925aa3785d1cc98ad49846", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -195,7 +195,7 @@ parameter can be added to the `should_panic` attribute. The test harness will\n make sure that the failure message contains the provided text. A safer version\n of the example above would be:\n \n-```\n+```rust\n #[test]\n #[should_panic(expected = \"assertion failed\")]\n fn it_works() {\n@@ -205,7 +205,7 @@ fn it_works() {\n \n That's all there is to the basics! Let's write one 'real' test:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -225,7 +225,7 @@ There is one way in which our existing example is not idiomatic: it's\n missing the `tests` module. The idiomatic way of writing our example\n looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -253,7 +253,7 @@ we need to bring our test function into scope. This can be annoying if you have\n a large module, and so this is a common use of the `glob` feature. Let's change\n our `src/lib.rs` to make use of it:\n \n-```{rust,ignore}\n+```rust,ignore\n \n pub fn add_two(a: i32) -> i32 {\n     a + 2\n@@ -302,7 +302,7 @@ the `tests` directory\n To write an integration test, let's make a `tests` directory, and\n put a `tests/lib.rs` file inside, with this as its contents:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate adder;\n \n #[test]\n@@ -359,7 +359,7 @@ documentation has been written. To this end, Rust supports automatically\n running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n with examples:\n \n-```{rust,ignore}\n+```rust,ignore\n //! The `adder` crate provides functions that add numbers to other numbers.\n //!\n //! # Examples"}, {"sha": "efa16f2942f06d9637c79af40a7c5017d31f3777", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -253,7 +253,7 @@ Writing functions with only a few generic types and a small number of trait\n bounds isn\u2019t too bad, but as the number increases, the syntax gets increasingly\n awkward:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n@@ -268,7 +268,7 @@ far right. The bounds are getting in the way.\n \n Rust has a solution, and it\u2019s called a \u2018`where` clause\u2019:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n@@ -294,7 +294,7 @@ All you need to do is leave off the bounds when defining your type parameters,\n and then add `where` after the parameter list. For longer lists, whitespace can\n be added:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn bar<T, K>(x: T, y: K)\n@@ -311,7 +311,7 @@ This flexibility can add clarity in complex situations.\n \n `where` is also more powerful than the simpler syntax. For example:\n \n-```\n+```rust\n trait ConvertTo<Output> {\n     fn convert(&self) -> Output;\n }"}, {"sha": "d8b894a2f6522ba45b78b6debf369e3b4edbd587", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -16,7 +16,7 @@ this is just convention.)\n \n There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n-```\n+```rust\n let v = vec![0; 10]; // ten zeroes\n ```\n "}, {"sha": "0f5c3c64a4b17e1665b9b0a7d0941360e684785e", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/b613ef552d0c598877085e8c5b0d740b17683c24/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=b613ef552d0c598877085e8c5b0d740b17683c24", "patch": "@@ -2,7 +2,7 @@\n \n Rust also has a `while` loop. It looks like this:\n \n-```{rust}\n+```rust\n let mut x = 5; // mut x: i32\n let mut done = false; // mut done: bool\n "}]}