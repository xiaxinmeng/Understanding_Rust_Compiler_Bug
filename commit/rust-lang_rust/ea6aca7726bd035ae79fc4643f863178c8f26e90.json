{"sha": "ea6aca7726bd035ae79fc4643f863178c8f26e90", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNmFjYTc3MjZiZDAzNWFlNzlmYzQ2NDNmODYzMTc4YzhmMjZlOTA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-29T23:39:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T08:17:03Z"}, "message": "rustc: take TyCtxt and RegionMaps in CodeMap::span.", "tree": {"sha": "009389c2e2d9347c66b28c13016bbed40122d923", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/009389c2e2d9347c66b28c13016bbed40122d923"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea6aca7726bd035ae79fc4643f863178c8f26e90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6aca7726bd035ae79fc4643f863178c8f26e90", "html_url": "https://github.com/rust-lang/rust/commit/ea6aca7726bd035ae79fc4643f863178c8f26e90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea6aca7726bd035ae79fc4643f863178c8f26e90/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28ddd7a4ef30a89091dbf48cae18f571326510fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/28ddd7a4ef30a89091dbf48cae18f571326510fb", "html_url": "https://github.com/rust-lang/rust/commit/28ddd7a4ef30a89091dbf48cae18f571326510fb"}], "stats": {"total": 290, "additions": 120, "deletions": 170}, "files": [{"sha": "d86626c210e14ae3fea10371707b9be432a97b88", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -64,7 +64,7 @@ use std::fmt;\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n-use middle::region;\n+use middle::region::{self, RegionMaps};\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n@@ -83,6 +83,7 @@ mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n+                                   region_maps: &RegionMaps,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region<'tcx>,\n@@ -130,13 +131,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.hir) {\n-                    Some(s) => s,\n-                    None => {\n-                        err.note(&unknown_scope());\n-                        return;\n-                    }\n-                };\n+                let span = scope.span(self, region_maps);\n                 let tag = match self.hir.find(scope.node_id()) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n@@ -260,8 +255,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-\n-    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n+    pub fn report_region_errors(&self,\n+                                region_maps: &RegionMaps,\n+                                errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -285,16 +281,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                   // the error. If all of these fails, we fall back to a rather\n                   // general bit of code that displays the error information\n                   ConcreteFailure(origin, sub, sup) => {\n-\n-                      self.report_concrete_failure(origin, sub, sup).emit();\n+                      self.report_concrete_failure(region_maps, origin, sub, sup).emit();\n                   }\n \n                   GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(kind, param_ty, sub);\n+                      self.report_generic_bound_failure(region_maps, kind, param_ty, sub);\n                   }\n \n                   SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n-                        self.report_sub_sup_conflict(var_origin,\n+                        self.report_sub_sup_conflict(region_maps,\n+                                                     var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n                                                      sup_origin,\n@@ -773,6 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_generic_bound_failure(&self,\n+                                    region_maps: &RegionMaps,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n                                     sub: Region<'tcx>)\n@@ -840,6 +837,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n                                   bound_kind));\n                 self.tcx.note_and_explain_region(\n+                    region_maps,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -853,21 +851,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_sub_sup_conflict(&self,\n+                               region_maps: &RegionMaps,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");"}, {"sha": "3e78cce80f594ad24657f502a58b773f17378fe8", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::{self, InferCtxt, SubregionOrigin};\n+use middle::region::RegionMaps;\n use ty::{self, Region};\n use ty::error::TypeError;\n use errors::DiagnosticBuilder;\n@@ -144,26 +145,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub(super) fn report_concrete_failure(&self,\n+                                          region_maps: &RegionMaps,\n                                           origin: SubregionOrigin<'tcx>,\n                                           sub: Region<'tcx>,\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n+                let mut err = self.report_and_explain_type_error(trace, &terr);\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"\", sup, \"...\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"...does not necessarily outlive \", sub, \"\");\n+                err\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0312,\n                                                \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the reference is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the borrowed content is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -177,27 +183,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 of captured variable `{}`...\",\n                                                self.tcx\n                                                    .local_var_name_str_def_index(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx\n-                    .note_and_explain_region(\n-                      &mut err,\n-                      &format!(\"...but `{}` is only valid for \",\n-                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n-                      sup,\n-                      \"\");\n+                self.tcx.note_and_explain_region(\n+                    region_maps,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \",\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                    sup,\n+                    \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the closure must be valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the closure's stack frame is only valid \\\n                                                   for \",\n                                                  sup,\n@@ -209,17 +215,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0315,\n                                                \"cannot invoke closure outside of its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the closure is only valid for \", sup, \"\");\n                 err\n             }\n             infer::DerefPointer(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0473,\n                                                \"dereference of reference outside its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n             infer::FreeVariable(span, id) => {\n@@ -229,17 +235,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n                                                self.tcx.local_var_name_str(id));\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"closure is valid for \", sub, \"\");\n                 err\n             }\n             infer::IndexSlice(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0475,\n                                                \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the slice is only valid for \", sup, \"\");\n                 err\n             }\n             infer::RelateObjectBound(span) => {\n@@ -248,8 +256,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0476,\n                                                \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"object type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"source pointer is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -264,22 +273,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                self.ty_to_string(ty));\n                 match *sub {\n                     ty::ReStatic => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must satisfy \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must satisfy \", sub, \"\")\n                     }\n                     _ => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must outlive \", sub, \"\")\n                     }\n                 }\n                 err\n             }\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"lifetime parameter instantiated with \",\n                                                  sup,\n                                                  \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but lifetime parameter must outlive \",\n                                                  sub,\n                                                  \"\");\n@@ -292,7 +303,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"the type `{}` (provided as the value of a type \\\n                                                 parameter) is not valid at this point\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type must outlive \", sub, \"\");\n                 err\n             }\n             infer::CallRcvr(span) => {\n@@ -301,8 +313,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0480,\n                                                \"lifetime of method receiver does not outlive the \\\n                                                 method call\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                \"the receiver is only valid for \", sup, \"\");\n                 err\n             }\n             infer::CallArg(span) => {\n@@ -311,7 +323,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0481,\n                                                \"lifetime of function argument does not outlive \\\n                                                 the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the function argument is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -323,7 +335,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0482,\n                                                \"lifetime of return value does not outlive the \\\n                                                 function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the return value is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -335,17 +347,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0483,\n                                                \"lifetime of operand does not outlive the \\\n                                                 operation\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the operand is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AddrOf(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0484,\n                                                \"reference is not valid at the time of borrow\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the borrow is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AutoBorrow(span) => {\n@@ -354,7 +366,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0485,\n                                                \"automatically reference is not valid at the time \\\n                                                 of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the automatic borrow is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -367,7 +379,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"type of expression contains references that are \\\n                                                 not valid during the expression: `{}`\",\n                                                self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type is only valid for \", sup, \"\");\n                 err\n             }\n             infer::SafeDestructor(span) => {\n@@ -377,8 +390,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"unsafe use of destructor: destructor might be \\\n                                                 called while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"subregion: \", sub, \"\");\n                 err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n@@ -387,17 +400,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0488,\n                                                \"lifetime of variable does not enclose its \\\n                                                 declaration\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the variable is only valid for \", sup, \"\");\n                 err\n             }\n             infer::ParameterInScope(_, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0489,\n                                                \"type/lifetime parameter not in scope here\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the parameter is only valid for \", sub, \"\");\n                 err\n             }\n             infer::DataBorrowed(ty, span) => {\n@@ -406,8 +419,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0490,\n                                                \"a value of type `{}` is borrowed for too long\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -417,8 +432,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"in type `{}`, reference has a longer lifetime \\\n                                                 than the data it references\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the pointer is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but the referenced data is only valid for \",\n                                                  sup,\n                                                  \"\");"}, {"sha": "21af92a25e6845249be4e56f9f732dba18fc7063", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -1084,7 +1084,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting module\n+            self.report_region_errors(region_map, &errors); // see error_reporting module\n         }\n     }\n "}, {"sha": "10a21a582f55439da5534cb9a76b7d4df8a04ff9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -16,7 +16,6 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n-use hir::map as hir_map;\n use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n use ty;\n \n@@ -161,34 +160,31 @@ impl CodeExtent {\n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, hir_map: &hir_map::Map) -> Option<Span> {\n-        match hir_map.find(self.node_id()) {\n-            Some(hir_map::NodeBlock(ref blk)) => {\n-                match *self {\n-                    CodeExtent::CallSiteScope(_) |\n-                    CodeExtent::ParameterScope(_) |\n-                    CodeExtent::Misc(_) |\n-                    CodeExtent::DestructionScope(_) => Some(blk.span),\n-\n-                    CodeExtent::Remainder(r) => {\n-                        assert_eq!(r.block, blk.id);\n-                        // Want span for extent starting after the\n-                        // indexed statement and ending at end of\n-                        // `blk`; reuse span of `blk` and shift `lo`\n-                        // forward to end of indexed statement.\n-                        //\n-                        // (This is the special case aluded to in the\n-                        // doc-comment for this method)\n-                        let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span::new(stmt_span.hi(), blk.span.hi(), stmt_span.ctxt()))\n-                    }\n+    pub fn span(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> Span {\n+        let root_node = region_maps.root_body.unwrap().node_id;\n+        assert_eq!(DefId::local(tcx.hir.node_to_hir_id(self.node_id()).owner),\n+                   DefId::local(tcx.hir.node_to_hir_id(root_node).owner));\n+        let span = tcx.hir.span(self.node_id());\n+        if let CodeExtent::Remainder(r) = *self {\n+            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(r.block) {\n+                // Want span for extent starting after the\n+                // indexed statement and ending at end of\n+                // `blk`; reuse span of `blk` and shift `lo`\n+                // forward to end of indexed statement.\n+                //\n+                // (This is the special case aluded to in the\n+                // doc-comment for this method)\n+\n+                let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n+\n+                // To avoid issues with macro-generated spans, the span\n+                // of the statement must be nested in that of the block.\n+                if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n+                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n                 }\n             }\n-            Some(hir_map::NodeExpr(ref expr)) => Some(expr.span),\n-            Some(hir_map::NodeStmt(ref stmt)) => Some(stmt.span),\n-            Some(hir_map::NodeItem(ref item)) => Some(item.span),\n-            Some(_) | None => None,\n          }\n+         span\n     }\n }\n "}, {"sha": "49d7f40000f079b7847c5846c3b49f3b9b5521bc", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -36,11 +36,11 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<usize>),\n     ArgCount,\n+\n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n-    RegionsNotSame(Region<'tcx>, Region<'tcx>),\n-    RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n     RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n+\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n@@ -110,12 +110,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n-            RegionsNotSame(..) => {\n-                write!(f, \"lifetimes are not the same\")\n-            }\n-            RegionsNoOverlap(..) => {\n-                write!(f, \"lifetimes do not intersect\")\n-            }\n             RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n@@ -243,33 +237,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         use self::TypeError::*;\n \n         match err.clone() {\n-            RegionsDoesNotOutlive(subregion, superregion) => {\n-                self.note_and_explain_region(db, \"\", subregion, \"...\");\n-                self.note_and_explain_region(db, \"...does not necessarily outlive \",\n-                                           superregion, \"\");\n-            }\n-            RegionsNotSame(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...is not the same lifetime as \",\n-                                           region2, \"\");\n-            }\n-            RegionsNoOverlap(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...does not overlap \",\n-                                           region2, \"\");\n-            }\n-            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n-                                           conc_region, \"\");\n-            }\n-            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n-                // don't bother to print out the message below for\n-                // inference variables, it's not very illuminating.\n-            }\n-            RegionsOverlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"expected concrete lifetime is \",\n-                                           conc_region, \"\");\n-            }\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);"}, {"sha": "ae05568ab414854a6edbbbfb27ac3a9d45c57774", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -371,12 +371,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n             }\n-            RegionsNotSame(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNotSame(a, b))\n-            }\n-            RegionsNoOverlap(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n-            }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n             }\n@@ -1057,12 +1051,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsDoesNotOutlive(a, b) => {\n                 RegionsDoesNotOutlive(a.fold_with(folder), b.fold_with(folder))\n             },\n-            RegionsNotSame(a, b) => {\n-                RegionsNotSame(a.fold_with(folder), b.fold_with(folder))\n-            },\n-            RegionsNoOverlap(a, b) => {\n-                RegionsNoOverlap(a.fold_with(folder), b.fold_with(folder))\n-            },\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n             },\n@@ -1088,9 +1076,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         match *self {\n             UnsafetyMismatch(x) => x.visit_with(visitor),\n             AbiMismatch(x) => x.visit_with(visitor),\n-            RegionsDoesNotOutlive(a, b) |\n-            RegionsNotSame(a, b) |\n-            RegionsNoOverlap(a, b) => {\n+            RegionsDoesNotOutlive(a, b) => {\n                 a.visit_with(visitor) || b.visit_with(visitor)\n             },\n             RegionsInsufficientlyPolymorphic(_, b) |"}, {"sha": "e4384935e373320dc9b0b7c10cb2820949dc312e", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -943,6 +943,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"borrowed value must be valid for \",\n                                     sub_scope,\n@@ -955,6 +956,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"...but borrowed value is only valid for \",\n                                     super_scope,\n@@ -984,12 +986,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => self.cmt_to_string(&err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n@@ -1245,14 +1249,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.hir) {\n-                    Some(s) => {\n-                        Some(s.end_point())\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n+                Some(scope.span(self.tcx, &self.region_maps).end_point())\n             }\n             _ => None\n         }"}, {"sha": "5c0388a020c76b63e3724cb42cc2751e6c254fd3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let outer_visibility_scope = this.visibility_scope;\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { span, kind, opt_destruction_extent } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_extent } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n@@ -83,15 +83,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }));\n                 }\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                    let tcx = this.hir.tcx();\n-\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n-                    let remainder_span = remainder_scope.span(&tcx.hir);\n-                    let remainder_span = remainder_span.unwrap_or(span);\n+                    let remainder_span = remainder_scope.span(this.hir.tcx(),\n+                                                              &this.hir.region_maps);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n                     // Evaluate the initializer, if present."}, {"sha": "2471d8c2c56f7d66fe9710fe402ae3f482de36e2", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -633,8 +633,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-                let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.hir).unwrap();\n+                let extent_span = extent.span(self.hir.tcx(), &self.hir.region_maps);\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = extent_span.with_lo(extent_span.hi());\n                 scope.drops.push(DropData {"}, {"sha": "d38c72c37e80f97ab4927b07a20d9765d6014935", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -45,7 +45,6 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             hir::StmtExpr(ref expr, id) |\n             hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: CodeExtent::Misc(id),\n                         expr: expr.to_ref(),\n@@ -69,7 +68,6 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                                         cx.tables(),\n                                                         &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n                                 init_scope: CodeExtent::Misc(id),"}, {"sha": "58051aaecdaab464ae057200a7454b367064a53c", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -46,7 +46,6 @@ pub enum StmtRef<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n-    pub span: Span,\n     pub kind: StmtKind<'tcx>,\n     pub opt_destruction_extent: Option<CodeExtent>,\n }"}, {"sha": "46948b687d26dd09eba98862d45023b4b1b528bc", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -13,7 +13,6 @@\n //! is calculated in `rustc_mir::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use log;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n@@ -36,18 +35,15 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map(|s| {\n-            self.fcx.tcx.yield_in_extent(s, &mut self.cache).is_some()\n-        }).unwrap_or(true);\n+        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n+            self.fcx.tcx.yield_in_extent(s, &mut self.cache)\n+        });\n \n-        if live_across_yield {\n+        if let Some(span) = live_across_yield {\n             let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n \n-            if log_enabled!(log::LogLevel::Debug) {\n-                let span = scope.map(|s| s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP));\n-                debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n-                       expr, scope, ty, span);\n-            }\n+            debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n+                   expr, scope, ty, span);\n \n             // Map the type to the number of types added before it\n             let entries = self.types.len();"}, {"sha": "d928a6a0a8e64b0299ca3fc2bf807963dbce1fbd", "filename": "src/test/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea6aca7726bd035ae79fc4643f863178c8f26e90/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=ea6aca7726bd035ae79fc4643f863178c8f26e90", "patch": "@@ -4,7 +4,6 @@ error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/closure-mismatch.r\n 18 |     baz(|_| ());\n    |     ^^^ expected bound lifetime parameter, found concrete lifetime\n    |\n-   = note: concrete lifetime that was found is lifetime '_#0r\n    = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:18:9: 18:15]`\n    = note: required by `baz`\n "}]}