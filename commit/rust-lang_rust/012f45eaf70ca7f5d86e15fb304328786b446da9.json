{"sha": "012f45eaf70ca7f5d86e15fb304328786b446da9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmY0NWVhZjcwY2E3ZjVkODZlMTVmYjMwNDMyODc4NmI0NDZkYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-23T18:53:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-23T18:53:17Z"}, "message": "Auto merge of #35854 - nikomatsakis:incr-comp-cache-hash-35549, r=mw\n\ncompute and cache HIR hashes at beginning\n\nThis avoids the compile-time overhead of computing them twice.  It also fixes\nan issue where the hash computed after typeck is differen than the hash before,\nbecause typeck mutates the def-map in place.\n\nFixes #35549.\nFixes #35593.\n\nSome performance measurements suggest this `HashesMap` is very small in memory (unobservable via `-Z time-passes`) and very cheap to construct. I do see some (very minor) performance wins in the incremental case after the first run -- the first run costs more because loading the dep-graph didn't have any hashing to do in that case. Example timings from two runs  of `libsyntex-syntax` -- the (1) indicates first run, (2) indicates second run, and (*) indicates both together:\n\n| Phase | Master | Branch |\n| ---- | ---- | ---- |\n| compute_hashes_map (1) | N/A | 0.343 |\n| load_dep_graph (1) | 0 | 0 |\n| serialize dep graph (1) | 4.190 | 3.920 |\n| total (1) | 4.190 | 4.260 |\n| compute_hashes_map (2) | N/A | 0.344 |\n| load_dep_graph (2) | 0.592 | 0.252 |\n| serialize dep graph (2) | 4.119 | 3.779 |\n| total (2) | 4.71 | 4.375 |\n| total (*) | 8.9 | 8.635 |\n\nr? @michaelwoerister", "tree": {"sha": "8dac3e22d19007fe7f2aa28666cc3a077c1cf682", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dac3e22d19007fe7f2aa28666cc3a077c1cf682"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012f45eaf70ca7f5d86e15fb304328786b446da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012f45eaf70ca7f5d86e15fb304328786b446da9", "html_url": "https://github.com/rust-lang/rust/commit/012f45eaf70ca7f5d86e15fb304328786b446da9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012f45eaf70ca7f5d86e15fb304328786b446da9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bd99f9d5c3bb10920f33819b38392137f7bfa11", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd99f9d5c3bb10920f33819b38392137f7bfa11", "html_url": "https://github.com/rust-lang/rust/commit/0bd99f9d5c3bb10920f33819b38392137f7bfa11"}, {"sha": "1cc7c9010c819c1b61c661e151280d7b8ea093a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc7c9010c819c1b61c661e151280d7b8ea093a0", "html_url": "https://github.com/rust-lang/rust/commit/1cc7c9010c819c1b61c661e151280d7b8ea093a0"}], "stats": {"total": 526, "additions": 350, "deletions": 176}, "files": [{"sha": "e95fbcc89175aad607105f9471c1d88863ac1606", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -147,6 +147,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             }\n         }\n \n+        if label == \"Krate\" {\n+            // special case\n+            return Ok(DepNode::Krate);\n+        }\n+\n         check! {\n             CollectItem,\n             BorrowCheck,"}, {"sha": "99fb2d6a44905bc1eb23d00ef57b6d0f5e34488b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -1621,7 +1621,7 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_id: Option<NodeId>,"}, {"sha": "3f2f6c84da190b600a9c9737ca90b7028c56765b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -26,7 +26,7 @@ use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc_back::sha2::{Sha256, Digest};\n use rustc_borrowck as borrowck;\n-use rustc_incremental;\n+use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::macro_import;\n use rustc_metadata::creader::read_local_crates;\n@@ -172,7 +172,7 @@ pub fn compile_input(sess: &Session,\n                                     resolutions,\n                                     &arenas,\n                                     &crate_name,\n-                                    |tcx, mir_map, analysis, result| {\n+                                    |tcx, mir_map, analysis, incremental_hashes_map, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -202,7 +202,8 @@ pub fn compile_input(sess: &Session,\n             }\n             let trans = phase_4_translate_to_llvm(tcx,\n                                                   mir_map.unwrap(),\n-                                                  analysis);\n+                                                  analysis,\n+                                                  &incremental_hashes_map);\n \n             if log_enabled!(::log::INFO) {\n                 println!(\"Post-trans\");\n@@ -797,14 +798,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             Option<MirMap<'tcx>>,\n                             ty::CrateAnalysis,\n+                            IncrementalHashesMap,\n                             CompileResult) -> R\n {\n     macro_rules! try_with_f {\n-        ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n+        ($e: expr, ($t: expr, $m: expr, $a: expr, $h: expr)) => {\n             match $e {\n                 Ok(x) => x,\n                 Err(x) => {\n-                    f($t, $m, $a, Err(x));\n+                    f($t, $m, $a, $h, Err(x));\n                     return Err(x);\n                 }\n             }\n@@ -860,12 +862,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              index,\n                              name,\n                              |tcx| {\n+        let incremental_hashes_map =\n+            time(time_passes,\n+                 \"compute_incremental_hashes_map\",\n+                 || rustc_incremental::compute_incremental_hashes_map(tcx));\n         time(time_passes,\n              \"load_dep_graph\",\n-             || rustc_incremental::load_dep_graph(tcx));\n+             || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, None, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -935,7 +941,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+            return Ok(f(tcx,\n+                        Some(mir_map),\n+                        analysis,\n+                        incremental_hashes_map,\n+                        Err(sess.err_count())));\n         }\n \n         analysis.reachable =\n@@ -963,17 +973,22 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         // The above three passes generate errors w/o aborting\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+            return Ok(f(tcx,\n+                        Some(mir_map),\n+                        analysis,\n+                        incremental_hashes_map,\n+                        Err(sess.err_count())));\n         }\n \n-        Ok(f(tcx, Some(mir_map), analysis, Ok(())))\n+        Ok(f(tcx, Some(mir_map), analysis, incremental_hashes_map, Ok(())))\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            mut mir_map: MirMap<'tcx>,\n-                                           analysis: ty::CrateAnalysis)\n+                                           analysis: ty::CrateAnalysis,\n+                                           incremental_hashes_map: &IncrementalHashesMap)\n                                            -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n@@ -1007,15 +1022,15 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let translation =\n         time(time_passes,\n              \"translation\",\n-             move || trans::trans_crate(tcx, &mir_map, analysis));\n+             move || trans::trans_crate(tcx, &mir_map, analysis, &incremental_hashes_map));\n \n     time(time_passes,\n          \"assert dep graph\",\n          move || rustc_incremental::assert_dep_graph(tcx));\n \n     time(time_passes,\n          \"serialize dep graph\",\n-         move || rustc_incremental::save_dep_graph(tcx));\n+         move || rustc_incremental::save_dep_graph(tcx, &incremental_hashes_map));\n \n     translation\n }"}, {"sha": "1ffeaf322bf5715c678b30729170ac30c138df87", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -234,7 +234,7 @@ impl PpSourceMode {\n                                                                  resolutions.clone(),\n                                                                  arenas,\n                                                                  id,\n-                                                                 |tcx, _, _, _| {\n+                                                                 |tcx, _, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -951,7 +951,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      resolutions.clone(),\n                                                      arenas,\n                                                      crate_name,\n-                                                     |tcx, mir_map, _, _| {\n+                                                     |tcx, mir_map, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(mir_map) = mir_map {"}, {"sha": "8aa134ba3bfd03ef8f0e5fc9d5a87b8b33966496", "filename": "src/librustc_incremental/calculate_svh/def_path_hash.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fdef_path_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fdef_path_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fdef_path_hash.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n+\n+pub struct DefPathHashes<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    data: DefIdMap<u64>,\n+}\n+\n+impl<'a, 'tcx> DefPathHashes<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        DefPathHashes {\n+            tcx: tcx,\n+            data: DefIdMap()\n+        }\n+    }\n+\n+    pub fn hash(&mut self, def_id: DefId) -> u64 {\n+        let tcx = self.tcx;\n+        *self.data.entry(def_id)\n+                  .or_insert_with(|| {\n+                      let def_path = tcx.def_path(def_id);\n+                      def_path.deterministic_hash(tcx)\n+                  })\n+    }\n+}"}, {"sha": "42bb1a5246738e55c5031a8100ee0689cc2bc60b", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 104, "deletions": 73, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -8,106 +8,137 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Calculation of a Strict Version Hash for crates.  For a length\n-//! comment explaining the general idea, see `librustc/middle/svh.rs`.\n-\n+//! Calculation of the (misnamed) \"strict version hash\" for crates and\n+//! items. This hash is used to tell when the HIR changed in such a\n+//! way that results from previous compilations may no longer be\n+//! applicable and hence must be recomputed. It should probably be\n+//! renamed to the ICH (incremental compilation hash).\n+//!\n+//! The hashes for all items are computed once at the beginning of\n+//! compilation and stored into a map. In addition, a hash is computed\n+//! of the **entire crate**.\n+//!\n+//! Storing the hashes in a map avoids the need to compute them twice\n+//! (once when loading prior incremental results and once when\n+//! saving), but it is also important for correctness: at least as of\n+//! the time of this writing, the typeck passes rewrites entries in\n+//! the dep-map in-place to accommodate UFCS resolutions. Since name\n+//! resolution is part of the hash, the result is that hashes computed\n+//! at the end of compilation would be different from those computed\n+//! at the beginning.\n+\n+use syntax::ast;\n use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::map::{NodeItem, NodeForeignItem};\n-use rustc::hir::svh::Svh;\n+use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit::{self, Visitor};\n+use rustc_data_structures::fnv::FnvHashMap;\n \n+use self::def_path_hash::DefPathHashes;\n use self::svh_visitor::StrictVersionHashVisitor;\n \n+mod def_path_hash;\n mod svh_visitor;\n \n-pub trait SvhCalculate {\n-    /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(self) -> Svh;\n-\n-    /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(self, def_id: DefId) -> u64;\n+pub type IncrementalHashesMap = FnvHashMap<DepNode<DefId>, u64>;\n+\n+pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                                    -> IncrementalHashesMap {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+    let krate = tcx.map.krate();\n+    let mut visitor = HashItemsVisitor { tcx: tcx,\n+                                         hashes: FnvHashMap(),\n+                                         def_path_hashes: DefPathHashes::new(tcx) };\n+    visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| visit::walk_crate(v, krate));\n+    krate.visit_all_items(&mut visitor);\n+    visitor.compute_crate_hash();\n+    visitor.hashes\n }\n \n-impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n-    fn calculate_krate_hash(self) -> Svh {\n-        // FIXME (#14132): This is better than it used to be, but it still not\n-        // ideal. We now attempt to hash only the relevant portions of the\n-        // Crate AST as well as the top-level crate attributes. (However,\n-        // the hashing of the crate attributes should be double-checked\n-        // to ensure it is not incorporating implementation artifacts into\n-        // the hash that are not otherwise visible.)\n+struct HashItemsVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_path_hashes: DefPathHashes<'a, 'tcx>,\n+    hashes: IncrementalHashesMap,\n+}\n \n-        let crate_disambiguator = self.sess.local_crate_disambiguator();\n-        let krate = self.map.krate();\n+impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n+    fn calculate_node_id<W>(&mut self, id: ast::NodeId, walk_op: W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+    {\n+        let def_id = self.tcx.map.local_def_id(id);\n+        self.calculate_def_id(def_id, walk_op)\n+    }\n \n-        // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n-        //        avoid collisions.\n+    fn calculate_def_id<W>(&mut self, def_id: DefId, mut walk_op: W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+    {\n+        assert!(def_id.is_local());\n+        debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n+        // FIXME: this should use SHA1, not SipHash. SipHash is not\n+        // built to avoid collisions.\n         let mut state = SipHasher::new();\n-        debug!(\"state: {:?}\", state);\n+        walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n+                                                   self.tcx,\n+                                                   &mut self.def_path_hashes));\n+        let item_hash = state.finish();\n+        self.hashes.insert(DepNode::Hir(def_id), item_hash);\n+        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n+    }\n+\n+    fn compute_crate_hash(&mut self) {\n+        let krate = self.tcx.map.krate();\n \n-        // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n-        // this enough, and does it matter anyway?\n-        \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.hash(&mut state);\n+        let mut crate_state = SipHasher::new();\n \n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n-        debug!(\"state: {:?}\", state);\n+        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n+        \"crate_disambiguator\".hash(&mut crate_state);\n+        crate_disambiguator.len().hash(&mut crate_state);\n+        crate_disambiguator.hash(&mut crate_state);\n \n+        // add each item (in some deterministic order) to the overall\n+        // crate hash.\n         {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            krate.visit_all_items(&mut visit);\n+            let def_path_hashes = &mut self.def_path_hashes;\n+            let mut item_hashes: Vec<_> =\n+                self.hashes.iter()\n+                           .map(|(item_dep_node, &item_hash)| {\n+                               // convert from a DepNode<DefId> tp a\n+                               // DepNode<u64> where the u64 is the\n+                               // hash of the def-id's def-path:\n+                               let item_dep_node =\n+                                   item_dep_node.map_def(|&did| Some(def_path_hashes.hash(did)))\n+                                                .unwrap();\n+                               (item_dep_node, item_hash)\n+                           })\n+                           .collect();\n+            item_hashes.sort(); // avoid artificial dependencies on item ordering\n+            item_hashes.hash(&mut crate_state);\n         }\n \n-        // FIXME (#14132): This hash is still sensitive to e.g. the\n-        // spans of the crate Attributes and their underlying\n-        // MetaItems; we should make ContentHashable impl for those\n-        // types and then use hash_content.  But, since all crate\n-        // attributes should appear near beginning of the file, it is\n-        // not such a big deal to be sensitive to their spans for now.\n-        //\n-        // We hash only the MetaItems instead of the entire Attribute\n-        // to avoid hashing the AttrId\n         for attr in &krate.attrs {\n             debug!(\"krate attr {:?}\", attr);\n-            attr.meta().hash(&mut state);\n+            attr.meta().hash(&mut crate_state);\n         }\n \n-        Svh::new(state.finish())\n+        let crate_hash = crate_state.finish();\n+        self.hashes.insert(DepNode::Krate, crate_hash);\n+        debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n     }\n+}\n \n-    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n-\n-        debug!(\"calculate_item_hash(def_id={:?})\", def_id);\n-\n-        let mut state = SipHasher::new();\n-\n-        {\n-            let mut visit = StrictVersionHashVisitor::new(&mut state, self);\n-            if def_id.index == CRATE_DEF_INDEX {\n-                // the crate root itself is not registered in the map\n-                // as an item, so we have to fetch it this way\n-                let krate = self.map.krate();\n-                intravisit::walk_crate(&mut visit, krate);\n-            } else {\n-                let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                match self.map.find(node_id) {\n-                    Some(NodeItem(item)) => visit.visit_item(item),\n-                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n-                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n-                              node_id, r),\n-                }\n-            }\n-        }\n-\n-        let hash = state.finish();\n \n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, hash);\n+impl<'a, 'tcx> visit::Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        self.calculate_node_id(item.id, |v| v.visit_item(item));\n+        visit::walk_item(self, item);\n+    }\n \n-        hash\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n+        self.calculate_node_id(item.id, |v| v.visit_foreign_item(item));\n+        visit::walk_foreign_item(self, item);\n     }\n }\n+"}, {"sha": "c1158dc2d5fe990dfbabf3fa7c3c4047f12fb4e4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -25,25 +25,30 @@ use rustc::hir::def::{Def, PathResolution};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::hir::intravisit::{Visitor, FnKind};\n-use rustc::hir::map::DefPath;\n use rustc::ty::TyCtxt;\n \n use std::hash::{Hash, SipHasher};\n \n-pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+use super::def_path_hash::DefPathHashes;\n+\n+pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n+    pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n     pub st: &'a mut SipHasher,\n+\n+    // collect a deterministic hash of def-ids that we have seen\n+    def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>,\n }\n \n-impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     pub fn new(st: &'a mut SipHasher,\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+               tcx: TyCtxt<'hash, 'tcx, 'tcx>,\n+               def_path_hashes: &'a mut DefPathHashes<'hash, 'tcx>)\n                -> Self {\n-        StrictVersionHashVisitor { st: st, tcx: tcx }\n+        StrictVersionHashVisitor { st: st, tcx: tcx, def_path_hashes: def_path_hashes }\n     }\n \n-    fn hash_def_path(&mut self, path: &DefPath) {\n-        path.deterministic_hash_to(self.tcx, self.st);\n+    fn compute_def_id_hash(&mut self, def_id: DefId) -> u64 {\n+        self.def_path_hashes.hash(def_id)\n     }\n }\n \n@@ -187,20 +192,20 @@ pub enum SawStmtComponent {\n     SawStmtSemi,\n }\n \n-impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n+impl<'a, 'hash, 'tcx> Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn visit_nested_item(&mut self, _: ItemId) {\n         // Each item is hashed independently; ignore nested items.\n     }\n \n-    fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n-                          g: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, s: &'tcx VariantData, name: Name,\n+                          g: &'tcx Generics, _: NodeId, _: Span) {\n         debug!(\"visit_variant_data: st={:?}\", self.st);\n         SawStructDef(name.as_str()).hash(self.st);\n         visit::walk_generics(self, g);\n         visit::walk_struct_def(self, s)\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         debug!(\"visit_variant: st={:?}\", self.st);\n         SawVariant.hash(self.st);\n         // walk_variant does not call walk_generics, so do it here.\n@@ -227,12 +232,12 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawIdent(name.as_str()).hash(self.st);\n     }\n \n-    fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+    fn visit_lifetime(&mut self, l: &'tcx Lifetime) {\n         debug!(\"visit_lifetime: st={:?}\", self.st);\n         SawLifetime(l.name.as_str()).hash(self.st);\n     }\n \n-    fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, l: &'tcx LifetimeDef) {\n         debug!(\"visit_lifetime_def: st={:?}\", self.st);\n         SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n     }\n@@ -242,12 +247,12 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n     // monomorphization and cross-crate inlining generally implies\n     // that a change to a crate body will require downstream\n     // crates to be recompiled.\n-    fn visit_expr(&mut self, ex: &'a Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         debug!(\"visit_expr: st={:?}\", self.st);\n         SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n     }\n \n-    fn visit_stmt(&mut self, s: &'a Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx Stmt) {\n         debug!(\"visit_stmt: st={:?}\", self.st);\n \n         // We don't want to modify the hash for decls, because\n@@ -265,7 +270,7 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         visit::walk_stmt(self, s)\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx ForeignItem) {\n         debug!(\"visit_foreign_item: st={:?}\", self.st);\n \n         // FIXME (#14132) ideally we would incorporate privacy (or\n@@ -275,7 +280,7 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_item(&mut self, i: &'a Item) {\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n \n         // FIXME (#14132) ideally would incorporate reachability\n@@ -285,63 +290,63 @@ impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         SawItem.hash(self.st); visit::walk_item(self, i)\n     }\n \n-    fn visit_mod(&mut self, m: &'a Mod, _s: Span, n: NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, n: NodeId) {\n         debug!(\"visit_mod: st={:?}\", self.st);\n         SawMod.hash(self.st); visit::walk_mod(self, m, n)\n     }\n \n-    fn visit_ty(&mut self, t: &'a Ty) {\n+    fn visit_ty(&mut self, t: &'tcx Ty) {\n         debug!(\"visit_ty: st={:?}\", self.st);\n         SawTy.hash(self.st); visit::walk_ty(self, t)\n     }\n \n-    fn visit_generics(&mut self, g: &'a Generics) {\n+    fn visit_generics(&mut self, g: &'tcx Generics) {\n         debug!(\"visit_generics: st={:?}\", self.st);\n         SawGenerics.hash(self.st); visit::walk_generics(self, g)\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n-                b: &'a Block, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx FnDecl,\n+                b: &'tcx Block, s: Span, n: NodeId) {\n         debug!(\"visit_fn: st={:?}\", self.st);\n         SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, n)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx TraitItem) {\n         debug!(\"visit_trait_item: st={:?}\", self.st);\n         SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx ImplItem) {\n         debug!(\"visit_impl_item: st={:?}\", self.st);\n         SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n     }\n \n-    fn visit_struct_field(&mut self, s: &'a StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         debug!(\"visit_struct_field: st={:?}\", self.st);\n         SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n     }\n \n-    fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx Path, _: ast::NodeId) {\n         debug!(\"visit_path: st={:?}\", self.st);\n         SawPath.hash(self.st); visit::walk_path(self, path)\n     }\n \n-    fn visit_block(&mut self, b: &'a Block) {\n+    fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n         SawBlock.hash(self.st); visit::walk_block(self, b)\n     }\n \n-    fn visit_pat(&mut self, p: &'a Pat) {\n+    fn visit_pat(&mut self, p: &'tcx Pat) {\n         debug!(\"visit_pat: st={:?}\", self.st);\n         SawPat.hash(self.st); visit::walk_pat(self, p)\n     }\n \n-    fn visit_local(&mut self, l: &'a Local) {\n+    fn visit_local(&mut self, l: &'tcx Local) {\n         debug!(\"visit_local: st={:?}\", self.st);\n         SawLocal.hash(self.st); visit::walk_local(self, l)\n     }\n \n-    fn visit_arm(&mut self, a: &'a Arm) {\n+    fn visit_arm(&mut self, a: &'tcx Arm) {\n         debug!(\"visit_arm: st={:?}\", self.st);\n         SawArm.hash(self.st); visit::walk_arm(self, a)\n     }\n@@ -361,28 +366,37 @@ pub enum DefHash {\n     SawErr,\n }\n \n-impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n+impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n     fn hash_resolve(&mut self, id: ast::NodeId) {\n         // Because whether or not a given id has an entry is dependent\n         // solely on expr variant etc, we don't need to hash whether\n         // or not an entry was present (we are already hashing what\n         // variant it is above when we visit the HIR).\n \n         if let Some(def) = self.tcx.def_map.borrow().get(&id) {\n+            debug!(\"hash_resolve: id={:?} def={:?} st={:?}\", id, def, self.st);\n             self.hash_partial_def(def);\n         }\n \n         if let Some(traits) = self.tcx.trait_map.get(&id) {\n+            debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n             traits.len().hash(self.st);\n-            for candidate in traits {\n-                self.hash_def_id(candidate.def_id);\n-            }\n+\n+            // The ordering of the candidates is not fixed. So we hash\n+            // the def-ids and then sort them and hash the collection.\n+            let mut candidates: Vec<_> =\n+                traits.iter()\n+                      .map(|&TraitCandidate { def_id, import_id: _ }| {\n+                          self.compute_def_id_hash(def_id)\n+                      })\n+                      .collect();\n+            candidates.sort();\n+            candidates.hash(self.st);\n         }\n     }\n \n     fn hash_def_id(&mut self, def_id: DefId) {\n-        let def_path = self.tcx.def_path(def_id);\n-        self.hash_def_path(&def_path);\n+        self.compute_def_id_hash(def_id).hash(self.st);\n     }\n \n     fn hash_partial_def(&mut self, def: &PathResolution) {"}, {"sha": "d31d97b22cf4f80444a1cc1a96885cb835a5519c", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -38,7 +38,8 @@ mod calculate_svh;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use calculate_svh::SvhCalculate;\n+pub use calculate_svh::compute_incremental_hashes_map;\n+pub use calculate_svh::IncrementalHashesMap;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "65da3a09ecca53f3110673f88651609bd5ed2cad", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -133,6 +133,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n         match dep_node {\n+            DepNode::Krate |\n             DepNode::Hir(_) => {\n                 // HIR nodes are inputs, so if we are asserting that the HIR node is\n                 // dirty, we check the dirty input set.\n@@ -161,6 +162,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n         match dep_node {\n+            DepNode::Krate |\n             DepNode::Hir(_) => {\n                 // For HIR nodes, check the inputs.\n                 if self.dirty_inputs.contains(&dep_node) {"}, {"sha": "5d01f8806028214bdd7a0612a5e977cb277c59e0", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use calculate_svh::SvhCalculate;\n use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n@@ -21,45 +20,65 @@ use std::io::{ErrorKind, Read};\n use std::fs::File;\n use syntax::ast;\n \n+use IncrementalHashesMap;\n use super::data::*;\n use super::util::*;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    incremental_hashes_map: &'a IncrementalHashesMap,\n     item_metadata_hashes: FnvHashMap<DefId, u64>,\n     crate_hashes: FnvHashMap<ast::CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               incremental_hashes_map: &'a IncrementalHashesMap)\n+               -> Self {\n         HashContext {\n             tcx: tcx,\n+            incremental_hashes_map: incremental_hashes_map,\n             item_metadata_hashes: FnvHashMap(),\n             crate_hashes: FnvHashMap(),\n         }\n     }\n \n     pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n         match *dep_node {\n+            DepNode::Krate |\n             DepNode::Hir(_) => true,\n             DepNode::MetaData(def_id) => !def_id.is_local(),\n             _ => false,\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<(DefId, u64)> {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n         match *dep_node {\n+            DepNode::Krate => {\n+                Some(self.incremental_hashes_map[dep_node])\n+            }\n+\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n-                Some((def_id, self.hir_hash(def_id)))\n+                assert!(def_id.is_local(),\n+                        \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n+                        def_id,\n+                        self.tcx.item_path_str(def_id));\n+\n+                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n+                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n+                        def_id,\n+                        self.tcx.item_path_str(def_id));\n+\n+                Some(self.incremental_hashes_map[dep_node])\n             }\n \n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some((def_id, self.metadata_hash(def_id)))\n+                Some(self.metadata_hash(def_id))\n             }\n \n             _ => {\n@@ -72,21 +91,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn hir_hash(&mut self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local(),\n-                \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n-                def_id,\n-                self.tcx.item_path_str(def_id));\n-\n-        assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                def_id,\n-                self.tcx.item_path_str(def_id));\n-\n-        // FIXME(#32753) -- should we use a distinct hash here\n-        self.tcx.calculate_item_hash(def_id)\n-    }\n-\n     fn metadata_hash(&mut self, def_id: DefId) -> u64 {\n         debug!(\"metadata_hash(def_id={:?})\", def_id);\n "}, {"sha": "75448d199f73e5a9ba8f9e74c402885a1adefa5a", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -22,6 +22,7 @@ use std::io::Read;\n use std::fs::{self, File};\n use std::path::{Path};\n \n+use IncrementalHashesMap;\n use super::data::*;\n use super::directory::*;\n use super::dirty_clean;\n@@ -38,16 +39,18 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                incremental_hashes_map: &IncrementalHashesMap) {\n     if tcx.sess.opts.incremental.is_none() {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    load_dep_graph_if_exists(tcx);\n+    load_dep_graph_if_exists(tcx, incremental_hashes_map);\n }\n \n-fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      incremental_hashes_map: &IncrementalHashesMap) {\n     let dep_graph_path = dep_graph_path(tcx).unwrap();\n     let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n         Some(p) => p,\n@@ -60,7 +63,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         None => return // no file\n     };\n \n-    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n+    match decode_dep_graph(tcx, incremental_hashes_map, &dep_graph_data, &work_products_data) {\n         Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n@@ -97,6 +100,7 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n                                   -> Result<(), Error>\n@@ -133,7 +137,10 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // reason for this is that this way we can include nodes that have\n     // been removed (which no longer have a `DefId` in the current\n     // compilation).\n-    let dirty_raw_source_nodes = dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n+    let dirty_raw_source_nodes = dirty_nodes(tcx,\n+                                             incremental_hashes_map,\n+                                             &serialized_dep_graph.hashes,\n+                                             &retraced);\n \n     // Create a list of (raw-source-node ->\n     // retracted-target-node) edges. In the process of retracing the\n@@ -206,15 +213,16 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                         hashes: &[SerializedHash],\n+                         incremental_hashes_map: &IncrementalHashesMap,\n+                         serialized_hashes: &[SerializedHash],\n                          retraced: &RetracedDefIdDirectory)\n                          -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx);\n+    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FnvHashSet();\n \n-    for hash in hashes {\n+    for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n-            let (_, current_hash) = hcx.hash(&dep_node).unwrap();\n+            let current_hash = hcx.hash(&dep_node).unwrap();\n             if current_hash == hash.hash {\n                 continue;\n             }"}, {"sha": "af13484e4288d54174ee0763d4beb44717cebd27", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -62,7 +62,7 @@ impl<'q> Predecessors<'q> {\n         let mut hashes = FnvHashMap();\n         for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n             hashes.entry(input)\n-                  .or_insert_with(|| hcx.hash(input).unwrap().1);\n+                  .or_insert_with(|| hcx.hash(input).unwrap());\n         }\n \n         Predecessors {"}, {"sha": "74ee876d0bbc55db58e04c80c806c6c9e7710bf9", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -21,20 +21,22 @@ use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n+use IncrementalHashesMap;\n use super::data::*;\n use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::util::*;\n \n-pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                incremental_hashes_map: &IncrementalHashesMap) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n     let sess = tcx.sess;\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n-    let mut hcx = HashContext::new(tcx);\n+    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n     let query = tcx.dep_graph.query();\n     let preds = Predecessors::new(&query, &mut hcx);"}, {"sha": "9f401b13d6f97651d4c419b78dcd5ba833a44d3d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -26,10 +26,10 @@ use CrateTranslation;\n use util::common::time;\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc::dep_graph::DepNode;\n-use rustc::ty::TyCtxt;\n+use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n+use rustc_incremental::IncrementalHashesMap;\n \n-use rustc_incremental::SvhCalculate;\n use std::ascii;\n use std::char;\n use std::env;\n@@ -125,12 +125,12 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n }\n \n-pub fn build_link_meta<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 name: &str)\n-                                 -> LinkMeta {\n+pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n+                       name: &str)\n+                       -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n-        crate_hash: tcx.calculate_krate_hash(),\n+        crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate]),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "cab353cd262091a0bd2128851808813077d77695", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -48,6 +48,7 @@ use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n use rustc_data_structures::graph::OUTGOING;\n+use rustc_incremental::IncrementalHashesMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use _match;\n@@ -2481,7 +2482,8 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              mir_map: &MirMap<'tcx>,\n-                             analysis: ty::CrateAnalysis)\n+                             analysis: ty::CrateAnalysis,\n+                             incremental_hashes_map: &IncrementalHashesMap)\n                              -> CrateTranslation {\n     let _task = tcx.dep_graph.in_task(DepNode::TransCrate);\n \n@@ -2506,7 +2508,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    let link_meta = link::build_link_meta(tcx, name);\n+    let link_meta = link::build_link_meta(incremental_hashes_map, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              &mir_map,"}, {"sha": "8032b5c31046e0dec58a720642fa036e590479c6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -159,7 +159,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      resolutions,\n                                                      &arenas,\n                                                      &name,\n-                                                     |tcx, _, analysis, result| {\n+                                                     |tcx, _, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "3f1bdb7e3c6747b1bed098f45643f1e71f1c9e75", "filename": "src/test/incremental/crate_hash_reorder.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the crate hash is not affected by reordering items.\n+\n+// revisions:rpass1 rpass2 rpass3\n+// compile-flags: -Z query-dep-graph\n+\n+#![feature(rustc_attrs)]\n+\n+// Check that reordering otherwise identical items is not considered a\n+// change at all.\n+#[rustc_clean(label=\"Krate\", cfg=\"rpass2\")]\n+\n+// But removing an item, naturally, is.\n+#[rustc_dirty(label=\"Krate\", cfg=\"rpass3\")]\n+\n+#[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32,\n+}\n+\n+pub struct Y {\n+    pub x: u32,\n+}\n+\n+#[cfg(rpass2)]\n+pub struct X {\n+    pub x: u32,\n+}\n+\n+pub fn main() { }"}, {"sha": "51e04dd7b2ce0bab674b66b27418b36f606eff07", "filename": "src/test/incremental/issue-35593.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fissue-35593.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fissue-35593.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-35593.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #35593. Check that we can reuse this trivially\n+// equal example.\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+#![rustc_partition_reused(module=\"issue_35593\", cfg=\"rpass2\")]\n+\n+fn main() {\n+    println!(\"hello world\");\n+}"}, {"sha": "ba8d3cc934bfc253e6f23651c57ded089f5a66e4", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f45eaf70ca7f5d86e15fb304328786b446da9/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=012f45eaf70ca7f5d86e15fb304328786b446da9", "patch": "@@ -17,10 +17,6 @@\n // Here the only thing which changes is the string constant in `x`.\n // Therefore, the compiler deduces (correctly) that typeck is not\n // needed even for callers of `x`.\n-//\n-// It is not entirely clear why `TransCrateItem` invalidates `y` and\n-// `z`, actually, I think it's because of the structure of\n-// trans. -nmatsakis\n \n fn main() { }\n \n@@ -41,10 +37,8 @@ mod x {\n mod y {\n     use x;\n \n-    // FIXME(#35078) -- when body of `x` changes, we treat it as\n-    // though signature changed.\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n     pub fn y() {\n         x::x();\n     }"}]}