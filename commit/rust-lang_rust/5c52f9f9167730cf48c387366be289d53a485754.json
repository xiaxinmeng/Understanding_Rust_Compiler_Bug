{"sha": "5c52f9f9167730cf48c387366be289d53a485754", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNTJmOWY5MTY3NzMwY2Y0OGMzODczNjZiZTI4OWQ1M2E0ODU3NTQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-20T12:21:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-20T12:21:06Z"}, "message": "Rollup merge of #72139 - nnethercote:standalone-fold, r=cuviper\n\nMake `fold` standalone.\n\n`fold` is currently implemented via `try_fold`, but implementing it\ndirectly results in slightly less LLVM IR being generated, speeding up\ncompilation of some benchmarks.\n\nr? @cuviper", "tree": {"sha": "b5d89bd0125c63d75dbe80e4f09b62b5aec65110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5d89bd0125c63d75dbe80e4f09b62b5aec65110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c52f9f9167730cf48c387366be289d53a485754", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexSCyCRBK7hj4Ov3rIwAAdHIIAK37IJHM18zASc1W1pp4fwYP\n6/udgSpO8ghpm9qJEiNV5NuiyYoNcMaq8Og5XJc00L4cvwfvl3Mka80fWSlIZkoM\nP83UcjSnxAl3cmRpOohP5ENCCxOhimV8cOGLb8CTPbhgsqb5f7MCWqxg2fA4WYcB\ntnPIkAIFdxGLd1rJs6rwLRO4/l79GaDfymaAeixkKNDMdd63hXyC98eGxXfcu73d\nxSCalazo0DuHLe0OzGur30rJLD2Eo9xWoNzTz7cFMpZGhNZ0Vebx9FMRQcD6Q1kx\nW05Qs0pJiKq0fDMy1aHxxgRGIteAoUUFeBdjsp3cmAhlnu0iq7f2fvlG5oraLVE=\n=qaTa\n-----END PGP SIGNATURE-----\n", "payload": "tree b5d89bd0125c63d75dbe80e4f09b62b5aec65110\nparent 14c439177b779408452fdf2c8f4fc620f27905d1\nparent 959bd48887d431a0f30090af18ef40d8c5606d77\nauthor Dylan DPC <dylan.dpc@gmail.com> 1589977266 +0200\ncommitter GitHub <noreply@github.com> 1589977266 +0200\n\nRollup merge of #72139 - nnethercote:standalone-fold, r=cuviper\n\nMake `fold` standalone.\n\n`fold` is currently implemented via `try_fold`, but implementing it\ndirectly results in slightly less LLVM IR being generated, speeding up\ncompilation of some benchmarks.\n\nr? @cuviper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c52f9f9167730cf48c387366be289d53a485754", "html_url": "https://github.com/rust-lang/rust/commit/5c52f9f9167730cf48c387366be289d53a485754", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c52f9f9167730cf48c387366be289d53a485754/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14c439177b779408452fdf2c8f4fc620f27905d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c439177b779408452fdf2c8f4fc620f27905d1", "html_url": "https://github.com/rust-lang/rust/commit/14c439177b779408452fdf2c8f4fc620f27905d1"}, {"sha": "959bd48887d431a0f30090af18ef40d8c5606d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/959bd48887d431a0f30090af18ef40d8c5606d77", "html_url": "https://github.com/rust-lang/rust/commit/959bd48887d431a0f30090af18ef40d8c5606d77"}], "stats": {"total": 243, "additions": 199, "deletions": 44}, "files": [{"sha": "195847ee98dc4755944db419326f636e743961da", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=5c52f9f9167730cf48c387366be289d53a485754", "patch": "@@ -512,6 +512,9 @@ where\n             acc = self.iter.try_fold(acc, &mut f)?;\n         }\n     }\n+\n+    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n+    // and we can't do anything better than the default.\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -643,6 +646,25 @@ where\n         }\n         from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n     }\n+\n+    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return acc,\n+                Some(x) => acc = f(acc, x),\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n+    }\n }\n \n impl<I> StepBy<I>\n@@ -702,6 +724,29 @@ where\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => init,\n+            Some(x) => {\n+                let acc = f(init, x);\n+                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n+            }\n+        }\n+    }\n }\n \n // StepBy can only make the iterator shorter, so the len will still fit.\n@@ -1767,6 +1812,20 @@ where\n             self.iter.try_fold(init, check(flag, p, fold)).into_try()\n         }\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1838,6 +1897,20 @@ where\n         })\n         .into_try()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n /// An iterator that skips over `n` elements of `iter`.\n@@ -2006,6 +2079,18 @@ where\n             self.iter.try_rfold(init, check(n, fold)).into_try()\n         }\n     }\n+\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(init, ok(fold)).unwrap()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -2105,6 +2190,20 @@ where\n             self.iter.try_fold(init, check(n, fold)).into_try()\n         }\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n #[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n@@ -2156,6 +2255,24 @@ where\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n == 0 {\n+            init\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                init\n+            } else {\n+                self.iter.rfold(init, fold)\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2237,6 +2354,20 @@ where\n         let f = &mut self.f;\n         self.iter.try_fold(init, scan(state, f, fold)).into_try()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }\n \n /// An iterator that calls a function with a reference to each element before\n@@ -2444,4 +2575,17 @@ where\n             })\n             .into_try()\n     }\n+\n+    fn fold<B, F>(mut self, init: B, fold: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n }"}, {"sha": "388a5548a31a5e0f0adeb8440822619d6d36faa5", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=5c52f9f9167730cf48c387366be289d53a485754", "patch": "@@ -658,6 +658,20 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         Try::from_ok(accum)\n     }\n \n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n+    }\n+\n     #[inline]\n     fn last(mut self) -> Option<A> {\n         self.next_back()\n@@ -746,6 +760,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n         Try::from_ok(accum)\n     }\n+\n+    #[inline]\n+    fn rfold<B, F>(mut self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(init, ok(f)).unwrap()\n+    }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]"}, {"sha": "cceb373d552a86ba682c5f63121bf6496979f2fa", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=5c52f9f9167730cf48c387366be289d53a485754", "patch": "@@ -221,17 +221,16 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x);\n         }\n-\n-        self.try_rfold(accum, ok(f)).unwrap()\n+        accum\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate."}, {"sha": "1c3d95cbb8c3504f9e5b47d52ebbe809980ea18f", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c52f9f9167730cf48c387366be289d53a485754/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=5c52f9f9167730cf48c387366be289d53a485754", "patch": "@@ -1697,8 +1697,8 @@ pub trait Iterator {\n             mut f: impl FnMut(&T) -> bool + 'a,\n             left: &'a mut B,\n             right: &'a mut B,\n-        ) -> impl FnMut(T) + 'a {\n-            move |x| {\n+        ) -> impl FnMut((), T) + 'a {\n+            move |(), x| {\n                 if f(&x) {\n                     left.extend(Some(x));\n                 } else {\n@@ -1710,7 +1710,7 @@ pub trait Iterator {\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        self.for_each(extend(f, &mut left, &mut right));\n+        self.fold((), extend(f, &mut left, &mut right));\n \n         (left, right)\n     }\n@@ -1826,7 +1826,7 @@ pub trait Iterator {\n     ///\n     /// # Note to Implementors\n     ///\n-    /// Most of the other (forward) methods have default implementations in\n+    /// Several of the other (forward) methods have default implementations in\n     /// terms of this one, so try to implement this explicitly if it can\n     /// do something better than the default `for` loop implementation.\n     ///\n@@ -1944,6 +1944,15 @@ pub trait Iterator {\n     /// may not terminate for infinite iterators, even on traits for which a\n     /// result is determinable in finite time.\n     ///\n+    /// # Note to Implementors\n+    ///\n+    /// Several of the other (forward) methods have default implementations in\n+    /// terms of this one, so try to implement this explicitly if it can\n+    /// do something better than the default `for` loop implementation.\n+    ///\n+    /// In particular, try to have this call `fold()` on the internal parts\n+    /// from which this iterator is composed.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1992,17 +2001,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x);\n         }\n-\n-        self.try_fold(init, ok(f)).unwrap()\n+        accum\n     }\n \n     /// The same as [`fold()`](#method.fold), but uses the first element in the\n@@ -2273,7 +2281,7 @@ pub trait Iterator {\n         F: FnMut(&Self::Item) -> R,\n         R: Try<Ok = bool, Error = E>,\n     {\n-        self.try_for_each(move |x| match f(&x).into_result() {\n+        self.try_fold((), move |(), x| match f(&x).into_result() {\n             Ok(false) => LoopState::Continue(()),\n             Ok(true) => LoopState::Break(Ok(x)),\n             Err(x) => LoopState::Break(Err(x)),\n@@ -2665,8 +2673,8 @@ pub trait Iterator {\n         fn extend<'a, A, B>(\n             ts: &'a mut impl Extend<A>,\n             us: &'a mut impl Extend<B>,\n-        ) -> impl FnMut((A, B)) + 'a {\n-            move |(t, u)| {\n+        ) -> impl FnMut((), (A, B)) + 'a {\n+            move |(), (t, u)| {\n                 ts.extend(Some(t));\n                 us.extend(Some(u));\n             }\n@@ -2675,7 +2683,7 @@ pub trait Iterator {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        self.for_each(extend(&mut ts, &mut us));\n+        self.fold((), extend(&mut ts, &mut us));\n \n         (ts, us)\n     }"}, {"sha": "ec58f7068abac0b276f9304b313d7574efebd647", "filename": "src/test/codegen/iter-fold-closure-no-dupes.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14c439177b779408452fdf2c8f4fc620f27905d1/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c439177b779408452fdf2c8f4fc620f27905d1/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-dupes.rs?ref=14c439177b779408452fdf2c8f4fc620f27905d1", "patch": "@@ -1,14 +0,0 @@\n-//! Check that fold closures aren't duplicated for each iterator type.\n-// compile-flags: -C opt-level=0\n-\n-fn main() {\n-    (0i32..10).by_ref().count();\n-    (0i32..=10).by_ref().count();\n-}\n-\n-// `count` calls `fold`, which calls `try_fold` -- find the `fold` closure:\n-// CHECK: {{^define.*Iterator::fold::.*closure}}\n-//\n-// Only one closure is needed for both `count` calls, even from different\n-// monomorphized iterator types, as it's only generic over the item type.\n-// CHECK-NOT: {{^define.*Iterator::fold::.*closure}}"}, {"sha": "fbeafd5f395827b8774b5bd1695f4e2560a1d015", "filename": "src/test/codegen/iter-fold-closure-no-iterator.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14c439177b779408452fdf2c8f4fc620f27905d1/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c439177b779408452fdf2c8f4fc620f27905d1/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fiter-fold-closure-no-iterator.rs?ref=14c439177b779408452fdf2c8f4fc620f27905d1", "patch": "@@ -1,10 +0,0 @@\n-//! Check that fold closures aren't generic in the iterator type.\n-// compile-flags: -C opt-level=0\n-\n-fn main() {\n-    (0i32..10).by_ref().count();\n-}\n-\n-// `count` calls `fold`, which calls `try_fold` -- that `fold` closure should\n-// not be generic in the iterator type, only in the item type.\n-// CHECK-NOT: {{^define.*Iterator::fold::.*closure.*Range}}"}]}