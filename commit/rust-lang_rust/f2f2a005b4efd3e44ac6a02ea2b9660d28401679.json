{"sha": "f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZjJhMDA1YjRlZmQzZTQ0YWM2YTAyZWEyYjk2NjBkMjg0MDE2Nzk=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-03-12T14:30:50Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-03-12T14:30:50Z"}, "message": "Merge commit '6ed6f1e6a1a8f414ba7e6d9b8222e7e5a1686e42' into clippyup", "tree": {"sha": "c4ece65dffee2aa79eaa3b7f190765a95055f815", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4ece65dffee2aa79eaa3b7f190765a95055f815"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "html_url": "https://github.com/rust-lang/rust/commit/f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a27ecaacad74f69b21a12bc66b826f11f2d44e", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a27ecaacad74f69b21a12bc66b826f11f2d44e", "html_url": "https://github.com/rust-lang/rust/commit/36a27ecaacad74f69b21a12bc66b826f11f2d44e"}], "stats": {"total": 28068, "additions": 15608, "deletions": 12460}, "files": [{"sha": "9b5add4df1c12291566125daaeebbf27956dfa30", "filename": ".cargo/config", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,7 @@\n [alias]\n uitest = \"test --test compile-test\"\n dev = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --\"\n-dev-lintcheck = \"run --target-dir clippy_dev/target --package clippy_dev --bin clippy_dev --manifest-path clippy_dev/Cargo.toml --features lintcheck -- lintcheck\"\n+lintcheck = \"run --target-dir lintcheck/target --package lintcheck --bin lintcheck --manifest-path lintcheck/Cargo.toml  -- \"\n \n [build]\n rustflags = [\"-Zunstable-options\"]"}, {"sha": "32103f59d8b0e14d389e4b714c8fc419e9999ba9", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -27,6 +27,7 @@ env:\n \n jobs:\n   base:\n+    # NOTE: If you modify this job, make sure you copy the changes to clippy_bors.yml\n     runs-on: ubuntu-latest\n \n     steps:\n@@ -50,11 +51,16 @@ jobs:\n     - name: Build\n       run: cargo build --features deny-warnings,internal-lints\n \n-    - name: Test \"--fix -Zunstable-options\"\n-      run: cargo run --features deny-warnings,internal-lints --bin cargo-clippy -- clippy --fix -Zunstable-options\n+    - name: Test\n+      run: cargo test --features deny-warnings,internal-lints\n \n-    - name: Test Workspace\n-      run: cargo test --all --features deny-warnings,internal-lints\n+    - name: Test clippy_lints\n+      run: cargo test --features deny-warnings,internal-lints\n+      working-directory: clippy_lints\n+\n+    - name: Test rustc_tools_util\n+      run: cargo test --features deny-warnings\n+      working-directory: rustc_tools_util\n \n     - name: Test clippy_dev\n       run: cargo test --features deny-warnings\n@@ -64,6 +70,10 @@ jobs:\n       run: ../target/debug/cargo-clippy\n       working-directory: clippy_workspace_tests\n \n+    - name: Test cargo-clippy --fix\n+      run: ../target/debug/cargo-clippy clippy --fix -Zunstable-options\n+      working-directory: clippy_workspace_tests\n+\n     - name: Test clippy-driver\n       run: bash .github/driver.sh\n       env:"}, {"sha": "47253eecc4c4c03ccbcb2fbd10bf32ea15d22dc2", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -72,6 +72,7 @@ jobs:\n \n     runs-on: ${{ matrix.os }}\n \n+    # NOTE: If you modify this job, make sure you copy the changes to clippy.yml\n     steps:\n     # Setup\n     - uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n@@ -112,8 +113,16 @@ jobs:\n     - name: Build\n       run: cargo build --features deny-warnings,internal-lints\n \n-    - name: Test Workspace\n-      run: cargo test --all --features deny-warnings,internal-lints\n+    - name: Test\n+      run: cargo test --features deny-warnings,internal-lints\n+\n+    - name: Test clippy_lints\n+      run: cargo test --features deny-warnings,internal-lints\n+      working-directory: clippy_lints\n+\n+    - name: Test rustc_tools_util\n+      run: cargo test --features deny-warnings\n+      working-directory: rustc_tools_util\n \n     - name: Test clippy_dev\n       run: cargo test --features deny-warnings\n@@ -123,11 +132,22 @@ jobs:\n       run: ../target/debug/cargo-clippy\n       working-directory: clippy_workspace_tests\n \n+    - name: Test cargo-clippy --fix\n+      run: ../target/debug/cargo-clippy clippy --fix -Zunstable-options\n+      working-directory: clippy_workspace_tests\n+\n     - name: Test clippy-driver\n       run: bash .github/driver.sh\n       env:\n         OS: ${{ runner.os }}\n \n+    - name: Test cargo dev new lint\n+      run: |\n+        cargo dev new_lint --name new_early_pass --pass early\n+        cargo dev new_lint --name new_late_pass --pass late\n+        cargo check\n+        git reset --hard HEAD\n+\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest"}, {"sha": "376528e30853ad9ff166b8ad2094940b7e9cea09", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -21,6 +21,7 @@ out\n /clippy_utils/target\n /clippy_workspace_tests/target\n /clippy_dev/target\n+/lintcheck/target\n /rustc_tools_util/target\n \n # Generated by dogfood"}, {"sha": "41c334c68169b98e3cb73305bdd2e5a844ad7fba", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -2104,6 +2104,7 @@ Released 2018-09-13\n [`if_not_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_not_else\n [`if_same_then_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#if_same_then_else\n [`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n+[`implicit_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_clone\n [`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n [`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n [`implicit_saturating_sub`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_sub\n@@ -2134,6 +2135,7 @@ Released 2018-09-13\n [`invisible_characters`]: https://rust-lang.github.io/rust-clippy/master/index.html#invisible_characters\n [`items_after_statements`]: https://rust-lang.github.io/rust-clippy/master/index.html#items_after_statements\n [`iter_cloned_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_cloned_collect\n+[`iter_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_count\n [`iter_next_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop\n [`iter_next_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_slice\n [`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth"}, {"sha": "2b9488de28994582958504cc82fc5ce683ec527e", "filename": "Cargo.toml", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,13 +1,7 @@\n [package]\n name = \"clippy\"\n version = \"0.1.52\"\n-authors = [\n-\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n-\t\"Andre Bogus <bogusandre@gmail.com>\",\n-\t\"Georg Brandl <georg@python.org>\",\n-\t\"Martin Carton <cartonmartin@gmail.com>\",\n-\t\"Oliver Schneider <clippy-iethah7aipeen8neex1a@oli-obk.de>\"\n-]\n+authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -42,6 +36,7 @@ tester = \"0.9\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n derive-new = \"0.5\"\n+regex = \"1.4\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n@@ -55,3 +50,7 @@ rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n deny-warnings = []\n integration = [\"tempfile\"]\n internal-lints = [\"clippy_lints/internal-lints\"]\n+\n+[package.metadata.rust-analyzer]\n+# This package uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "63057609bb6fec5063ade880b9806a09fdfe42e5", "filename": "README.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -202,7 +202,6 @@ the lint(s) you are interested in:\n ```terminal\n cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n ```\n-Note that if you've run clippy before, this may only take effect after you've modified a file or ran `cargo clean`.\n \n ### Specifying the minimum supported Rust version\n "}, {"sha": "b1844e29b3273fa3e41a1a65fe070f4db1ffe73f", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,27 +1,17 @@\n [package]\n name = \"clippy_dev\"\n version = \"0.0.1\"\n-authors = [\"Philipp Hansch <dev@phansch.net>\"]\n+authors = [\"The Rust Clippy Developers\"]\n edition = \"2018\"\n \n-\n [dependencies]\n bytecount = \"0.6\"\n clap = \"2.33\"\n-flate2 = { version = \"1.0.19\", optional = true }\n-fs_extra = { version = \"1.2.0\", optional = true }\n itertools = \"0.9\"\n opener = \"0.4\"\n regex = \"1\"\n-serde = { version = \"1.0\", features = [\"derive\"], optional = true }\n-serde_json = { version = \"1.0\", optional = true }\n shell-escape = \"0.1\"\n-tar = { version = \"0.4.30\", optional = true }\n-toml = { version = \"0.5\", optional = true }\n-ureq = { version = \"2.0.0-rc3\", optional = true }\n-rayon = { version = \"1.5.0\", optional = true }\n walkdir = \"2\"\n \n [features]\n-lintcheck = [\"flate2\", \"serde_json\", \"tar\", \"toml\", \"ureq\", \"serde\", \"fs_extra\", \"rayon\"]\n deny-warnings = []"}, {"sha": "a26d6aba10d20ed5beb03e9e49d038524e0c4387", "filename": "clippy_dev/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Ffmt.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -54,6 +54,7 @@ pub fn run(check: bool, verbose: bool) {\n         success &= cargo_fmt(context, project_root.as_path())?;\n         success &= cargo_fmt(context, &project_root.join(\"clippy_dev\"))?;\n         success &= cargo_fmt(context, &project_root.join(\"rustc_tools_util\"))?;\n+        success &= cargo_fmt(context, &project_root.join(\"lintcheck\"))?;\n \n         for entry in WalkDir::new(project_root.join(\"tests\")) {\n             let entry = entry?;"}, {"sha": "a95abfaceaae026af80e2d84dc628982d18d2ee6", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -12,7 +12,6 @@ use walkdir::WalkDir;\n \n pub mod bless;\n pub mod fmt;\n-pub mod lintcheck;\n pub mod new_lint;\n pub mod ra_setup;\n pub mod serve;\n@@ -530,7 +529,7 @@ fn test_gen_deprecated() {\n #[should_panic]\n fn test_gen_deprecated_fail() {\n     let lints = vec![Lint::new(\"should_assert_eq2\", \"group2\", \"abc\", None, \"module_name\")];\n-    let _ = gen_deprecated(lints.iter());\n+    let _deprecated_lints = gen_deprecated(lints.iter());\n }\n \n #[test]"}, {"sha": "2a9f3e5348c4156c7ac5e0c7e473595ccf35d6e1", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -2,21 +2,13 @@\n \n use clap::{App, Arg, ArgMatches, SubCommand};\n use clippy_dev::{bless, fmt, new_lint, ra_setup, serve, stderr_length_check, update_lints};\n-\n-#[cfg(feature = \"lintcheck\")]\n-use clippy_dev::lintcheck;\n-\n fn main() {\n     let matches = get_clap_config();\n \n     match matches.subcommand() {\n         (\"bless\", Some(matches)) => {\n             bless::bless(matches.is_present(\"ignore-timestamp\"));\n         },\n-        #[cfg(feature = \"lintcheck\")]\n-        (\"lintcheck\", Some(matches)) => {\n-            lintcheck::run(&matches);\n-        },\n         (\"fmt\", Some(matches)) => {\n             fmt::run(matches.is_present(\"check\"), matches.is_present(\"verbose\"));\n         },\n@@ -53,33 +45,7 @@ fn main() {\n }\n \n fn get_clap_config<'a>() -> ArgMatches<'a> {\n-    #[cfg(feature = \"lintcheck\")]\n-    let lintcheck_sbcmd = SubCommand::with_name(\"lintcheck\")\n-        .about(\"run clippy on a set of crates and check output\")\n-        .arg(\n-            Arg::with_name(\"only\")\n-                .takes_value(true)\n-                .value_name(\"CRATE\")\n-                .long(\"only\")\n-                .help(\"only process a single crate of the list\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"crates-toml\")\n-                .takes_value(true)\n-                .value_name(\"CRATES-SOURCES-TOML-PATH\")\n-                .long(\"crates-toml\")\n-                .help(\"set the path for a crates.toml where lintcheck should read the sources from\"),\n-        )\n-        .arg(\n-            Arg::with_name(\"threads\")\n-                .takes_value(true)\n-                .value_name(\"N\")\n-                .short(\"j\")\n-                .long(\"jobs\")\n-                .help(\"number of threads to use, 0 automatic choice\"),\n-        );\n-\n-    let app = App::new(\"Clippy developer tooling\")\n+    App::new(\"Clippy developer tooling\")\n         .subcommand(\n             SubCommand::with_name(\"bless\")\n                 .about(\"bless the test output changes\")\n@@ -196,10 +162,6 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         .validator_os(serve::validate_port),\n                 )\n                 .arg(Arg::with_name(\"lint\").help(\"Which lint's page to load initially (optional)\")),\n-        );\n-\n-    #[cfg(feature = \"lintcheck\")]\n-    let app = app.subcommand(lintcheck_sbcmd);\n-\n-    app.get_matches()\n+        )\n+        .get_matches()\n }"}, {"sha": "6959de7ffee71dd00ea0a018a4fb35774bb31638", "filename": "clippy_dummy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dummy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_dummy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dummy%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_dummy\" # rename to clippy before publishing\n version = \"0.0.303\"\n-authors = [\"Manish Goregaokar <manishsmail@gmail.com>\"]\n+authors = [\"The Rust Clippy Developers\"]\n edition = \"2018\"\n readme = \"crates-readme.md\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust.\""}, {"sha": "6bd6c079276e4bde141d0ae61f0a6bdc0612fda6", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -3,12 +3,7 @@ name = \"clippy_lints\"\n # begin automatic update\n version = \"0.1.52\"\n # end automatic update\n-authors = [\n-\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n-\t\"Andre Bogus <bogusandre@gmail.com>\",\n-\t\"Georg Brandl <georg@python.org>\",\n-\t\"Martin Carton <cartonmartin@gmail.com>\"\n-]\n+authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\"\n@@ -29,14 +24,18 @@ smallvec = { version = \"1\", features = [\"union\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n semver = \"0.11\"\n-rustc-semver=\"1.1.0\"\n+rustc-semver = \"1.1.0\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n-url = { version =  \"2.1.0\", features = [\"serde\"] }\n+url = { version = \"2.1.0\", features = [\"serde\"] }\n quote = \"1\"\n syn = { version = \"1\", features = [\"full\"] }\n \n [features]\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n internal-lints = [\"clippy_utils/internal-lints\"]\n+\n+[package.metadata.rust-analyzer]\n+# This crate uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "e13f62d04281ac3cbfc5602a04ef4e3db3b0d5e1", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -209,7 +209,7 @@ fn lint_misrefactored_assign_op(\n                 diag.span_suggestion(\n                     expr.span,\n                     &format!(\n-                        \"Did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n+                        \"did you mean `{} = {} {} {}` or `{}`? Consider replacing it with\",\n                         snip_a,\n                         snip_a,\n                         op.node.as_str(),"}, {"sha": "869a5c28d051126d10b4abcc84da3382f90447cc", "filename": "clippy_lints/src/async_yields_async.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fasync_yields_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fasync_yields_async.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -50,8 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for AsyncYieldsAsync {\n                 let body_id = BodyId {\n                     hir_id: body.value.hir_id,\n                 };\n-                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-                let typeck_results = cx.tcx.typeck(def_id);\n+                let typeck_results = cx.tcx.typeck_body(body_id);\n                 let expr_ty = typeck_results.expr_ty(&body.value);\n \n                 if implements_trait(cx, expr_ty, future_trait_def_id, &[]) {"}, {"sha": "6250810bc42773179869a8d5e9fe4a95e840546c", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -640,7 +640,7 @@ fn check_mismatched_target_os(cx: &EarlyContext<'_>, attr: &Attribute) {\n                     diag.span_suggestion(span, \"try\", sugg, Applicability::MaybeIncorrect);\n \n                     if !unix_suggested && is_unix(os) {\n-                        diag.help(\"Did you mean `unix`?\");\n+                        diag.help(\"did you mean `unix`?\");\n                         unix_suggested = true;\n                     }\n                 }"}, {"sha": "14b6a156c621e9963dc24a5abfe8d2a5237d06e1", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -97,8 +97,7 @@ impl LateLintPass<'_> for AwaitHolding {\n             let body_id = BodyId {\n                 hir_id: body.value.hir_id,\n             };\n-            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-            let typeck_results = cx.tcx.typeck(def_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n             check_interior_types(\n                 cx,\n                 &typeck_results.generator_interior_types.as_ref().skip_binder(),\n@@ -116,20 +115,20 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n                     cx,\n                     AWAIT_HOLDING_LOCK,\n                     ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n+                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\",\n                     ty_cause.scope_span.or(Some(span)),\n                     \"these are all the await points this lock is held through\",\n                 );\n             }\n             if is_refcell_ref(cx, adt.did) {\n                 span_lint_and_note(\n-                        cx,\n-                        AWAIT_HOLDING_REFCELL_REF,\n-                        ty_cause.span,\n-                        \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\",\n-                        ty_cause.scope_span.or(Some(span)),\n-                        \"these are all the await points this ref is held through\",\n-                    );\n+                    cx,\n+                    AWAIT_HOLDING_REFCELL_REF,\n+                    ty_cause.span,\n+                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\",\n+                    ty_cause.scope_span.or(Some(span)),\n+                    \"these are all the await points this ref is held through\",\n+                );\n             }\n         }\n     }"}, {"sha": "eb5dc7ceecdc75908d133c98fe1e5603159a7002", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -28,7 +28,7 @@ declare_clippy_lint! {\n     /// &vec.iter().filter(|x| **x == 0u8).count(); // use bytecount::count instead\n     /// ```\n     pub NAIVE_BYTECOUNT,\n-    perf,\n+    pedantic,\n     \"use of naive `<slice>.filter(|&x| x == y).count()` to count byte values\"\n }\n "}, {"sha": "b15fe65352ab1205ff4f517c3f1437ad5d107cd2", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,12 +1,11 @@\n-use crate::utils::paths::STRING;\n-use crate::utils::{match_def_path, span_lint_and_help};\n+use crate::utils::span_lint_and_help;\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{source_map::Spanned, Span};\n+use rustc_span::{source_map::Spanned, symbol::sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:**\n@@ -59,7 +58,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n                     return Some(span);\n                 },\n                 ty::Adt(&ty::AdtDef { did, .. }, _) => {\n-                    if match_def_path(ctx, did, &STRING) {\n+                    if ctx.tcx.is_diagnostic_item(sym::string_type, did) {\n                         return Some(span);\n                     }\n                 },"}, {"sha": "478832a5164a08e61920e8cb314acb826e637c0c", "filename": "clippy_lints/src/casts/cast_lossless.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_lossless.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,87 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{in_constant, is_isize_or_usize, snippet_opt, span_lint_and_sugg};\n+\n+use super::{utils, CAST_LOSSLESS};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !should_lint(cx, expr, cast_from, cast_to) {\n+        return;\n+    }\n+\n+    // The suggestion is to use a function call, so if the original expression\n+    // has parens on the outside, they are no longer needed.\n+    let mut applicability = Applicability::MachineApplicable;\n+    let opt = snippet_opt(cx, cast_op.span);\n+    let sugg = opt.as_ref().map_or_else(\n+        || {\n+            applicability = Applicability::HasPlaceholders;\n+            \"..\"\n+        },\n+        |snip| {\n+            if should_strip_parens(cast_op, snip) {\n+                &snip[1..snip.len() - 1]\n+            } else {\n+                snip.as_str()\n+            }\n+        },\n+    );\n+\n+    span_lint_and_sugg(\n+        cx,\n+        CAST_LOSSLESS,\n+        expr.span,\n+        &format!(\n+            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n+            cast_from, cast_to\n+        ),\n+        \"try\",\n+        format!(\"{}::from({})\", cast_to, sugg),\n+        applicability,\n+    );\n+}\n+\n+fn should_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+    // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n+    if in_constant(cx, expr.hir_id) {\n+        return false;\n+    }\n+\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+            !is_isize_or_usize(cast_from)\n+                && !is_isize_or_usize(cast_to)\n+                && from_nbits < to_nbits\n+                && !cast_signed_to_unsigned\n+        },\n+\n+        (true, false) => {\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n+                32\n+            } else {\n+                64\n+            };\n+            from_nbits < to_nbits\n+        },\n+\n+        (_, _) => {\n+            matches!(cast_from.kind(), ty::Float(FloatTy::F32)) && matches!(cast_to.kind(), ty::Float(FloatTy::F64))\n+        },\n+    }\n+}\n+\n+fn should_strip_parens(cast_expr: &Expr<'_>, snip: &str) -> bool {\n+    if let ExprKind::Binary(_, _, _) = cast_expr.kind {\n+        if snip.starts_with('(') && snip.ends_with(')') {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "33b06b8fe7caff7a12f1b50fa5b093e73a47d0c8", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,54 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_POSSIBLE_TRUNCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let msg = match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            let (should_lint, suffix) = match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+                (true, true) | (false, false) => (to_nbits < from_nbits, \"\"),\n+                (true, false) => (\n+                    to_nbits <= 32,\n+                    if to_nbits == 32 {\n+                        \" on targets with 64-bit wide pointers\"\n+                    } else {\n+                        \"\"\n+                    },\n+                ),\n+                (false, true) => (from_nbits == 64, \" on targets with 32-bit wide pointers\"),\n+            };\n+\n+            if !should_lint {\n+                return;\n+            }\n+\n+            format!(\n+                \"casting `{}` to `{}` may truncate the value{}\",\n+                cast_from, cast_to, suffix,\n+            )\n+        },\n+\n+        (false, true) => {\n+            format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to)\n+        },\n+\n+        (_, _) => {\n+            if matches!(cast_from.kind(), &ty::Float(FloatTy::F64))\n+                && matches!(cast_to.kind(), &ty::Float(FloatTy::F32))\n+            {\n+                \"casting `f64` to `f32` may truncate the value\".to_string()\n+            } else {\n+                return;\n+            }\n+        },\n+    };\n+\n+    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, &msg);\n+}"}, {"sha": "56d301ed3e1c55485968c23b4fc5b5459fd6a6a7", "filename": "clippy_lints/src/casts/cast_possible_wrap.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_wrap.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,44 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_POSSIBLE_WRAP};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !(cast_from.is_integral() && cast_to.is_integral()) {\n+        return;\n+    }\n+\n+    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n+    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n+    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n+    let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+    let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+    let (should_lint, suffix) = match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+        (true, true) | (false, false) => (to_nbits == from_nbits && cast_unsigned_to_signed, \"\"),\n+        (true, false) => (to_nbits <= 32 && cast_unsigned_to_signed, arch_32_suffix),\n+        (false, true) => (\n+            cast_unsigned_to_signed,\n+            if from_nbits == 64 {\n+                arch_64_suffix\n+            } else {\n+                arch_32_suffix\n+            },\n+        ),\n+    };\n+\n+    if should_lint {\n+        span_lint(\n+            cx,\n+            CAST_POSSIBLE_WRAP,\n+            expr.span,\n+            &format!(\n+                \"casting `{}` to `{}` may wrap around the value{}\",\n+                cast_from, cast_to, suffix,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "a1c3900ce1f6c0a8a27d2ec6566e39140bde6b37", "filename": "clippy_lints/src/casts/cast_precision_loss.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_precision_loss.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,51 @@\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, FloatTy, Ty};\n+\n+use crate::utils::{is_isize_or_usize, span_lint};\n+\n+use super::{utils, CAST_PRECISION_LOSS};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if !cast_from.is_integral() || cast_to.is_integral() {\n+        return;\n+    }\n+\n+    let from_nbits = utils::int_ty_to_nbits(cast_from, cx.tcx);\n+    let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n+        32\n+    } else {\n+        64\n+    };\n+\n+    if !(is_isize_or_usize(cast_from) || from_nbits >= to_nbits) {\n+        return;\n+    }\n+\n+    let cast_to_f64 = to_nbits == 64;\n+    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n+    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n+    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n+    let from_nbits_str = if arch_dependent {\n+        \"64\".to_owned()\n+    } else if is_isize_or_usize(cast_from) {\n+        \"32 or 64\".to_owned()\n+    } else {\n+        utils::int_ty_to_nbits(cast_from, cx.tcx).to_string()\n+    };\n+\n+    span_lint(\n+        cx,\n+        CAST_PRECISION_LOSS,\n+        expr.span,\n+        &format!(\n+            \"casting `{0}` to `{1}` causes a loss of precision {2}(`{0}` is {3} bits wide, \\\n+             but `{1}`'s mantissa is only {4} bits wide)\",\n+            cast_from,\n+            if cast_to_f64 { \"f64\" } else { \"f32\" },\n+            if arch_dependent { arch_dependent_str } else { \"\" },\n+            from_nbits_str,\n+            mantissa_nbits\n+        ),\n+    );\n+}"}, {"sha": "87fb5557be066abf082b02f672dec71963d7d668", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,81 @@\n+use rustc_hir::{Expr, ExprKind, GenericArg};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{is_hir_ty_cfg_dependant, span_lint};\n+\n+use super::CAST_PTR_ALIGNMENT;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+        if is_hir_ty_cfg_dependant(cx, cast_to) {\n+            return;\n+        }\n+        let (cast_from, cast_to) = (\n+            cx.typeck_results().expr_ty(cast_expr),\n+            cx.typeck_results().expr_ty(expr),\n+        );\n+        lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+    } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n+        if_chain! {\n+            if method_path.ident.name == sym!(cast);\n+            if let Some(generic_args) = method_path.args;\n+            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n+            if !is_hir_ty_cfg_dependant(cx, cast_to);\n+            then {\n+                let (cast_from, cast_to) =\n+                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n+                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+    if_chain! {\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n+        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n+        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n+        if from_layout.align.abi < to_layout.align.abi;\n+        // with c_void, we inherently need to trust the user\n+        if !is_c_void(cx, from_ptr_ty.ty);\n+        // when casting from a ZST, we don't know enough to properly lint\n+        if !from_layout.is_zst();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_PTR_ALIGNMENT,\n+                expr.span,\n+                &format!(\n+                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                    cast_from,\n+                    cast_to,\n+                    from_layout.align.abi.bytes(),\n+                    to_layout.align.abi.bytes(),\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Check if the given type is either `core::ffi::c_void` or\n+/// one of the platform specific `libc::<platform>::c_void` of libc.\n+fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind() {\n+        let names = cx.get_def_path(adt.did);\n+\n+        if names.is_empty() {\n+            return false;\n+        }\n+        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "3fdc1c6168ba9b05d75080a2045effdf1e6aa56a", "filename": "clippy_lints/src/casts/cast_ref_to_mut.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ref_to_mut.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,28 @@\n+use rustc_hir::{Expr, ExprKind, MutTy, Mutability, TyKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::span_lint;\n+\n+use super::CAST_REF_TO_MUT;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n+        if let ExprKind::Cast(e, t) = &e.kind;\n+        if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n+        if let ExprKind::Cast(e, t) = &e.kind;\n+        if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n+        if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n+        then {\n+            span_lint(\n+                cx,\n+                CAST_REF_TO_MUT,\n+                expr.span,\n+                \"casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "9656fbebd772089ab159054227c47e04c049939c", "filename": "clippy_lints/src/casts/cast_sign_loss.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_sign_loss.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,70 @@\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::consts::{constant, Constant};\n+use crate::utils::{method_chain_args, sext, span_lint};\n+\n+use super::CAST_SIGN_LOSS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    if should_lint(cx, cast_op, cast_from, cast_to) {\n+        span_lint(\n+            cx,\n+            CAST_SIGN_LOSS,\n+            expr.span,\n+            &format!(\n+                \"casting `{}` to `{}` may lose the sign of the value\",\n+                cast_from, cast_to\n+            ),\n+        );\n+    }\n+}\n+\n+fn should_lint(cx: &LateContext<'_>, cast_op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) -> bool {\n+    match (cast_from.is_integral(), cast_to.is_integral()) {\n+        (true, true) => {\n+            if !cast_from.is_signed() || cast_to.is_signed() {\n+                return false;\n+            }\n+\n+            // Don't lint for positive constants.\n+            let const_val = constant(cx, &cx.typeck_results(), cast_op);\n+            if_chain! {\n+                if let Some((Constant::Int(n), _)) = const_val;\n+                if let ty::Int(ity) = *cast_from.kind();\n+                if sext(cx.tcx, n, ity) >= 0;\n+                then {\n+                    return false;\n+                }\n+            }\n+\n+            // Don't lint for the result of methods that always return non-negative values.\n+            if let ExprKind::MethodCall(ref path, _, _, _) = cast_op.kind {\n+                let mut method_name = path.ident.name.as_str();\n+                let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n+\n+                if_chain! {\n+                    if method_name == \"unwrap\";\n+                    if let Some(arglist) = method_chain_args(cast_op, &[\"unwrap\"]);\n+                    if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n+                    then {\n+                        method_name = inner_path.ident.name.as_str();\n+                    }\n+                }\n+\n+                if allowed_methods.iter().any(|&name| method_name == name) {\n+                    return false;\n+                }\n+            }\n+\n+            true\n+        },\n+\n+        (false, true) => !cast_to.is_signed(),\n+\n+        (_, _) => false,\n+    }\n+}"}, {"sha": "ccaad1b8f2ac7eae4b2b6fad0a613cfe38bf1588", "filename": "clippy_lints/src/casts/char_lit_as_u8.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fchar_lit_as_u8.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,42 @@\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, UintTy};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_then};\n+\n+use super::CHAR_LIT_AS_U8;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Cast(e, _) = &expr.kind;\n+        if let ExprKind::Lit(l) = &e.kind;\n+        if let LitKind::Char(c) = l.node;\n+        if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n+\n+            span_lint_and_then(\n+                cx,\n+                CHAR_LIT_AS_U8,\n+                expr.span,\n+                \"casting a character literal to `u8` truncates\",\n+                |diag| {\n+                    diag.note(\"`char` is four bytes wide, but `u8` is a single byte\");\n+\n+                    if c.is_ascii() {\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"use a byte literal instead\",\n+                            format!(\"b{}\", snippet),\n+                            applicability,\n+                        );\n+                    }\n+            });\n+        }\n+    }\n+}"}, {"sha": "a8d508585b5d416c3427d517bda9500ce9b41c89", "filename": "clippy_lints/src/casts/fn_to_numeric_cast.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,37 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, UintTy};\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+\n+use super::{utils, FN_TO_NUMERIC_CAST};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    // We only want to check casts to `ty::Uint` or `ty::Int`\n+    match cast_to.kind() {\n+        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n+        _ => return,\n+    }\n+\n+    match cast_from.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+\n+            if (to_nbits >= cx.tcx.data_layout.pointer_size.bits()) && (*cast_to.kind() != ty::Uint(UintTy::Usize)) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST,\n+                    expr.span,\n+                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n+                );\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "0085c7b27b2906021fdccc7e706067207fae7c20", "filename": "clippy_lints/src/casts/fn_to_numeric_cast_with_truncation.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Ffn_to_numeric_cast_with_truncation.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,39 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+\n+use super::{utils, FN_TO_NUMERIC_CAST_WITH_TRUNCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    // We only want to check casts to `ty::Uint` or `ty::Int`\n+    match cast_to.kind() {\n+        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n+        _ => return,\n+    }\n+    match cast_from.kind() {\n+        ty::FnDef(..) | ty::FnPtr(_) => {\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n+\n+            let to_nbits = utils::int_ty_to_nbits(cast_to, cx.tcx);\n+            if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n+                span_lint_and_sugg(\n+                    cx,\n+                    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+                    expr.span,\n+                    &format!(\n+                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n+                        from_snippet, cast_to\n+                    ),\n+                    \"try\",\n+                    format!(\"{} as usize\", from_snippet),\n+                    applicability,\n+                );\n+            }\n+        },\n+        _ => {},\n+    }\n+}"}, {"sha": "b726bd75f1d83ca7702a8d0aec672003d789ef33", "filename": "clippy_lints/src/casts/mod.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,407 @@\n+mod cast_lossless;\n+mod cast_possible_truncation;\n+mod cast_possible_wrap;\n+mod cast_precision_loss;\n+mod cast_ptr_alignment;\n+mod cast_ref_to_mut;\n+mod cast_sign_loss;\n+mod char_lit_as_u8;\n+mod fn_to_numeric_cast;\n+mod fn_to_numeric_cast_with_truncation;\n+mod ptr_as_ptr;\n+mod unnecessary_cast;\n+mod utils;\n+\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+use crate::utils::is_hir_ty_cfg_dependant;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from any numerical to a float type where\n+    /// the receiving type cannot store all values from the original type without\n+    /// rounding errors. This possible rounding is to be expected, so this lint is\n+    /// `Allow` by default.\n+    ///\n+    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n+    /// or any 64-bit integer to `f64`.\n+    ///\n+    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n+    /// helpful to know where precision loss can take place. This lint can help find\n+    /// those places in the code.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = u64::MAX;\n+    /// x as f64;\n+    /// ```\n+    pub CAST_PRECISION_LOSS,\n+    pedantic,\n+    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n+    /// type. In this case, negative values wrap around to large positive values,\n+    /// which can be quite surprising in practice. However, as the cast works as\n+    /// defined, this lint is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n+    /// as a one-time check to see where numerical wrapping can arise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let y: i8 = -1;\n+    /// y as u128; // will return 18446744073709551615\n+    /// ```\n+    pub CAST_SIGN_LOSS,\n+    pedantic,\n+    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts between numerical types that may\n+    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n+    /// default.\n+    ///\n+    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n+    /// truncation. This lint can be activated to help assess where additional\n+    /// checks could be beneficial.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u8(x: u64) -> u8 {\n+    ///     x as u8\n+    /// }\n+    /// ```\n+    pub CAST_POSSIBLE_TRUNCATION,\n+    pedantic,\n+    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n+    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n+    /// i.e., nothing is changed at the bit level, and the binary representation of\n+    /// the value is reinterpreted. This can cause wrapping if the value is too big\n+    /// for the target signed type. However, the cast works as defined, so this lint\n+    /// is `Allow` by default.\n+    ///\n+    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n+    /// be surprising when this is not the intended behavior, as demonstrated by the\n+    /// example below.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// u32::MAX as i32; // will yield a value of `-1`\n+    /// ```\n+    pub CAST_POSSIBLE_WRAP,\n+    pedantic,\n+    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts between numerical types that may\n+    /// be replaced by safe conversion functions.\n+    ///\n+    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n+    /// conversions, including silently lossy conversions. Conversion functions such\n+    /// as `i32::from` will only perform lossless conversions. Using the conversion\n+    /// functions prevents conversions from turning into silent lossy conversions if\n+    /// the types of the input expressions ever change, and make it easier for\n+    /// people reading the code to know that the conversion is lossless.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     x as u64\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `::from` would look like this:\n+    ///\n+    /// ```rust\n+    /// fn as_u64(x: u8) -> u64 {\n+    ///     u64::from(x)\n+    /// }\n+    /// ```\n+    pub CAST_LOSSLESS,\n+    pedantic,\n+    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n+    /// and casts of float literals to float types.\n+    ///\n+    /// **Why is this bad?** It's just unnecessary.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = 2i32 as i32;\n+    /// let _ = 0.5 as f32;\n+    /// ```\n+    ///\n+    /// Better:\n+    ///\n+    /// ```rust\n+    /// let _ = 2_i32;\n+    /// let _ = 0.5_f32;\n+    /// ```\n+    pub UNNECESSARY_CAST,\n+    complexity,\n+    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n+    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n+    ///\n+    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n+    /// behavior.\n+    ///\n+    /// **Known problems:** Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n+    /// on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n+    /// u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let _ = (&1u8 as *const u8) as *const u16;\n+    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n+    ///\n+    /// (&1u8 as *const u8).cast::<u16>();\n+    /// (&mut 1u8 as *mut u8).cast::<u16>();\n+    /// ```\n+    pub CAST_PTR_ALIGNMENT,\n+    pedantic,\n+    \"cast from a pointer to a more-strictly-aligned pointer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of function pointers to something other than usize\n+    ///\n+    /// **Why is this bad?**\n+    /// Casting a function pointer to anything other than usize/isize is not portable across\n+    /// architectures, because you end up losing bits if the target type is too small or end up with a\n+    /// bunch of extra bits that waste space and add more instructions to the final binary than\n+    /// strictly necessary for the problem\n+    ///\n+    /// Casting to isize also doesn't make sense since there are no signed addresses.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fun() -> i32 { 1 }\n+    /// let a = fun as i64;\n+    ///\n+    /// // Good\n+    /// fn fun2() -> i32 { 1 }\n+    /// let a = fun2 as usize;\n+    /// ```\n+    pub FN_TO_NUMERIC_CAST,\n+    style,\n+    \"casting a function pointer to a numeric type other than usize\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n+    /// store address.\n+    ///\n+    /// **Why is this bad?**\n+    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n+    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n+    /// a comment) to perform the truncation.\n+    ///\n+    /// **Example**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn fn1() -> i16 {\n+    ///     1\n+    /// };\n+    /// let _ = fn1 as i32;\n+    ///\n+    /// // Better: Cast to usize first, then comment with the reason for the truncation\n+    /// fn fn2() -> i16 {\n+    ///     1\n+    /// };\n+    /// let fn_ptr = fn2 as usize;\n+    /// let fn_ptr_truncated = fn_ptr as i32;\n+    /// ```\n+    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    style,\n+    \"casting a function pointer to a numeric type not wide enough to store the address\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n+    ///\n+    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n+    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n+    /// mutable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// fn x(r: &i32) {\n+    ///     unsafe {\n+    ///         *(r as *const _ as *mut _) += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Instead consider using interior mutability types.\n+    ///\n+    /// ```rust\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// fn x(r: &UnsafeCell<i32>) {\n+    ///     unsafe {\n+    ///         *r.get() += 1;\n+    ///     }\n+    /// }\n+    /// ```\n+    pub CAST_REF_TO_MUT,\n+    correctness,\n+    \"a cast of reference to a mutable pointer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for expressions where a character literal is cast\n+    /// to `u8` and suggests using a byte literal instead.\n+    ///\n+    /// **Why is this bad?** In general, casting values to smaller types is\n+    /// error-prone and should be avoided where possible. In the particular case of\n+    /// converting a character literal to u8, it is easy to avoid by just using a\n+    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n+    /// than `'a' as u8`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// 'x' as u8\n+    /// ```\n+    ///\n+    /// A better version, using the byte literal:\n+    ///\n+    /// ```rust,ignore\n+    /// b'x'\n+    /// ```\n+    pub CHAR_LIT_AS_U8,\n+    complexity,\n+    \"casting a character literal to `u8` truncates\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Checks for `as` casts between raw pointers without changing its mutability,\n+    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n+    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr as *const i32;\n+    /// let _ = mut_ptr as *mut i32;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let ptr: *const u32 = &42_u32;\n+    /// let mut_ptr: *mut u32 = &mut 42_u32;\n+    /// let _ = ptr.cast::<i32>();\n+    /// let _ = mut_ptr.cast::<i32>();\n+    /// ```\n+    pub PTR_AS_PTR,\n+    pedantic,\n+    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n+}\n+\n+pub struct Casts {\n+    msrv: Option<RustcVersion>,\n+}\n+\n+impl Casts {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self { msrv }\n+    }\n+}\n+\n+impl_lint_pass!(Casts => [\n+    CAST_PRECISION_LOSS,\n+    CAST_SIGN_LOSS,\n+    CAST_POSSIBLE_TRUNCATION,\n+    CAST_POSSIBLE_WRAP,\n+    CAST_LOSSLESS,\n+    CAST_REF_TO_MUT,\n+    CAST_PTR_ALIGNMENT,\n+    UNNECESSARY_CAST,\n+    FN_TO_NUMERIC_CAST,\n+    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+    CHAR_LIT_AS_U8,\n+    PTR_AS_PTR,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Casts {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n+            if is_hir_ty_cfg_dependant(cx, cast_to) {\n+                return;\n+            }\n+            let (cast_from, cast_to) = (\n+                cx.typeck_results().expr_ty(cast_expr),\n+                cx.typeck_results().expr_ty(expr),\n+            );\n+\n+            if unnecessary_cast::check(cx, expr, cast_expr, cast_from, cast_to) {\n+                return;\n+            }\n+\n+            fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n+            fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n+            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+                cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n+                cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n+                cast_precision_loss::check(cx, expr, cast_from, cast_to);\n+                cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to);\n+                cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n+            }\n+        }\n+\n+        cast_ref_to_mut::check(cx, expr);\n+        cast_ptr_alignment::check(cx, expr);\n+        char_lit_as_u8::check(cx, expr);\n+        ptr_as_ptr::check(cx, expr, &self.msrv);\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "abfbadf3642bed7e875f67ff6e1197c3b030a4fc", "filename": "clippy_lints/src/casts/ptr_as_ptr.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,52 @@\n+use std::borrow::Cow;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, TypeAndMut};\n+use rustc_semver::RustcVersion;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{meets_msrv, span_lint_and_sugg};\n+\n+use super::PTR_AS_PTR;\n+\n+const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: &Option<RustcVersion>) {\n+    if !meets_msrv(msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n+        return;\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n+        let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n+        if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n+        if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n+        if matches!((from_mutbl, to_mutbl),\n+            (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n+        // The `U` in `pointer::cast` have to be `Sized`\n+        // as explained here: https://github.com/rust-lang/rust/issues/60602.\n+        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n+            let turbofish = match &cast_to_hir_ty.kind {\n+                    TyKind::Infer => Cow::Borrowed(\"\"),\n+                    TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n+                    _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n+                };\n+            span_lint_and_sugg(\n+                cx,\n+                PTR_AS_PTR,\n+                expr.span,\n+                \"`as` casting between raw pointers without changing its mutability\",\n+                \"try `pointer::cast`, a safer alternative\",\n+                format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "fa2a07ef1da0c098adb6374eec6594ee46f4a916", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,106 @@\n+use rustc_ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Lit, UnOp};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, FloatTy, InferTy, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{numeric_literal::NumericLiteral, snippet_opt, span_lint, span_lint_and_sugg};\n+\n+use super::UNNECESSARY_CAST;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) -> bool {\n+    if let Some(lit) = get_numeric_literal(cast_expr) {\n+        let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+\n+        if_chain! {\n+            if let LitKind::Int(n, _) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if cast_to.is_floating_point();\n+            if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n+            let from_nbits = 128 - n.leading_zeros();\n+            let to_nbits = fp_ty_mantissa_nbits(cast_to);\n+            if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n+            then {\n+                let literal_str = if is_unary_neg(cast_expr) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                return true\n+            }\n+        }\n+\n+        match lit.node {\n+            LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n+            _ => {\n+                if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n+                    span_lint(\n+                        cx,\n+                        UNNECESSARY_CAST,\n+                        expr.span,\n+                        &format!(\n+                            \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n+                            cast_from, cast_to\n+                        ),\n+                    );\n+                    return true;\n+                }\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    span_lint_and_sugg(\n+        cx,\n+        UNNECESSARY_CAST,\n+        expr.span,\n+        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        \"try\",\n+        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n+    match expr.kind {\n+        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Unary(UnOp::Neg, e) => {\n+            if let ExprKind::Lit(ref lit) = e.kind {\n+                Some(lit)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns the mantissa bits wide of a fp type.\n+/// Will return 0 if the type is not a fp\n+fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n+    match typ.kind() {\n+        ty::Float(FloatTy::F32) => 23,\n+        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n+        _ => 0,\n+    }\n+}\n+\n+fn is_unary_neg(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n+}"}, {"sha": "00fd0b3473b4417949097b5ebb34ba8c10144e60", "filename": "clippy_lints/src/casts/utils.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcasts%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Futils.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,25 @@\n+use rustc_middle::ty::{self, IntTy, Ty, TyCtxt, UintTy};\n+\n+/// Returns the size in bits of an integral type.\n+/// Will return 0 if the type is not an int or uint variant\n+pub(super) fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n+    match typ.kind() {\n+        ty::Int(i) => match i {\n+            IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n+        },\n+        ty::Uint(i) => match i {\n+            UintTy::Usize => tcx.data_layout.pointer_size.bits(),\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n+        },\n+        _ => 0,\n+    }\n+}"}, {"sha": "e309db25995fbfa0f8bf5cbe716765047442e269", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n             expr.span,\n             \"`if` chain can be rewritten with `match`\",\n             None,\n-            \"Consider rewriting the `if` chain to use `cmp` and `match`.\",\n+            \"consider rewriting the `if` chain to use `cmp` and `match`\",\n         )\n     }\n }"}, {"sha": "369efacc9bcf47f87aea5360875ba04f40cae2b4", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -130,10 +130,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 }\n             },\n \n-            ExprKind::Struct(qpath, fields, base) => {\n+            ExprKind::Struct(_, fields, base) => {\n                 if_chain! {\n-                    if let Some(def_id) = self.cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                    let ty = self.cx.tcx.type_of(def_id);\n+                    let ty = self.cx.typeck_results().expr_ty(expr);\n                     if let Some(adt_def) = ty.ty_adt_def();\n                     if adt_def.is_struct();\n                     if let Some(variant) = adt_def.variants.iter().next();"}, {"sha": "6d3094ed6bfad5b6f7684db0e8c7d4caba4148a1", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_def_path, match_path, span_lint_and_help,\n+    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_def_path, span_lint_and_help,\n     span_lint_and_note, span_lint_and_then,\n };\n use if_chain::if_chain;\n@@ -294,7 +294,12 @@ fn check_ord_partial_ord<'tcx>(\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+    if cx\n+        .tcx\n+        .lang_items()\n+        .clone_trait()\n+        .map_or(false, |id| Some(id) == trait_ref.trait_def_id())\n+    {\n         if !is_copy(cx, ty) {\n             return;\n         }"}, {"sha": "90b02d52f8a713da572e50cb94e87a8d97675de2", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -329,9 +329,9 @@ fn lint_for_missing_headers<'tcx>(\n             if_chain! {\n                 if let Some(body_id) = body_id;\n                 if let Some(future) = cx.tcx.lang_items().future_trait();\n-                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-                let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n-                let ret_ty = mir.return_ty();\n+                let typeck = cx.tcx.typeck_body(body_id);\n+                let body = cx.tcx.hir().body(body_id);\n+                let ret_ty = typeck.expr_ty(&body.value);\n                 if implements_trait(cx, ret_ty, future, &[]);\n                 if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();"}, {"sha": "2aea00d883c41c22eeb26515df8f39b7dffc9308", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -98,13 +98,13 @@ declare_clippy_lint! {\n }\n \n const DROP_REF_SUMMARY: &str = \"calls to `std::mem::drop` with a reference instead of an owned value. \\\n-                                Dropping a reference does nothing.\";\n+                                Dropping a reference does nothing\";\n const FORGET_REF_SUMMARY: &str = \"calls to `std::mem::forget` with a reference instead of an owned value. \\\n-                                  Forgetting a reference does nothing.\";\n+                                  Forgetting a reference does nothing\";\n const DROP_COPY_SUMMARY: &str = \"calls to `std::mem::drop` with a value that implements `Copy`. \\\n-                                 Dropping a copy leaves the original intact.\";\n+                                 Dropping a copy leaves the original intact\";\n const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that implements `Copy`. \\\n-                                   Forgetting a copy leaves the original intact.\";\n+                                   Forgetting a copy leaves the original intact\";\n \n declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n "}, {"sha": "c461732fd3693dc1301f3cdbbced43026adc862c", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -10,6 +10,8 @@ use crate::utils::{\n     implements_trait, is_adjusted, iter_input_pats, snippet_opt, span_lint_and_sugg, span_lint_and_then,\n     type_is_unsafe_function,\n };\n+use clippy_utils::higher;\n+use clippy_utils::higher::VecArgs;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for closures which just call another function where\n@@ -74,7 +76,10 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         match expr.kind {\n             ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n                 for arg in args {\n-                    check_closure(cx, arg)\n+                    // skip `foo(macro!())`\n+                    if arg.span.ctxt() == expr.span.ctxt() {\n+                        check_closure(cx, arg)\n+                    }\n                 }\n             },\n             _ => (),\n@@ -87,6 +92,23 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n \n+        if ex.span.ctxt() != expr.span.ctxt() {\n+            if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n+                // replace `|| vec![]` with `Vec::new`\n+                span_lint_and_sugg(\n+                    cx,\n+                    REDUNDANT_CLOSURE,\n+                    expr.span,\n+                    \"redundant closure\",\n+                    \"replace the closure with `Vec::new`\",\n+                    \"std::vec::Vec::new\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            // skip `foo(|| macro!())`\n+            return;\n+        }\n+\n         if_chain!(\n             if let ExprKind::Call(ref caller, ref args) = ex.kind;\n \n@@ -107,11 +129,11 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n \n             then {\n-                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |diag| {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n                     if let Some(snippet) = snippet_opt(cx, caller.span) {\n                         diag.span_suggestion(\n                             expr.span,\n-                            \"remove closure as shown\",\n+                            \"replace the closure with the function itself\",\n                             snippet,\n                             Applicability::MachineApplicable,\n                         );\n@@ -141,8 +163,8 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n                     cx,\n                     REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n                     expr.span,\n-                    \"redundant closure found\",\n-                    \"remove closure as shown\",\n+                    \"redundant closure\",\n+                    \"replace the closure with the method itself\",\n                     format!(\"{}::{}\", name, path.ident.name),\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "f466dddc13c2044d7320f04fac2cec42403da220", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -133,7 +133,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                         move |diag| {\n                             diag.help(\n                                 \"`From` is intended for infallible conversions only. \\\n-                                Use `TryFrom` if there's a possibility for the conversion to fail.\");\n+                                Use `TryFrom` if there's a possibility for the conversion to fail\");\n                             diag.span_note(fpu.result, \"potential failure(s)\");\n                         });\n                 }"}, {"sha": "8e256f346841947d6c075f110aab2345afaa6871", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -145,11 +145,7 @@ fn count_digits(s: &str) -> usize {\n         .take_while(|c| *c != 'e' && *c != 'E')\n         .fold(0, |count, c| {\n             // leading zeros\n-            if c == '0' && count == 0 {\n-                count\n-            } else {\n-                count + 1\n-            }\n+            if c == '0' && count == 0 { count } else { count + 1 }\n         })\n }\n "}, {"sha": "fd6bf19db94c84c38dadef790aa69ca597cf0b48", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -28,11 +28,11 @@ declare_clippy_lint! {\n     /// ```rust\n     ///\n     /// // Bad\n-    /// # let foo = \"foo\";\n+    /// let foo = \"foo\";\n     /// format!(\"{}\", foo);\n     ///\n     /// // Good\n-    /// format!(\"foo\");\n+    /// foo.to_owned();\n     /// ```\n     pub USELESS_FORMAT,\n     complexity,"}, {"sha": "c474db06fe3fd577cf1b15151ac6ef2251a74f0a", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -317,9 +317,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n             let attr = must_use_attr(attrs);\n             if let Some(attr) = attr {\n                 check_needless_must_use(cx, &sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-            } else if is_public\n-                && !is_proc_macro(cx.sess(), attrs)\n-                && trait_ref_of_method(cx, item.hir_id()).is_none()\n+            } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none()\n             {\n                 check_must_use_candidate(\n                     cx,"}, {"sha": "b4f814e1dcccfb1894c73f14abf0ad2d268d0dcd", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{fn_has_unsatisfiable_preds, match_panic_def_id, snippet_opt, span_lint_and_then};\n+use crate::utils::{match_panic_def_id, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -133,19 +133,13 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n         span: Span,\n         _: HirId,\n     ) {\n-        let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n-\n-        // Building MIR for `fn`s with unsatisfiable preds results in ICE.\n-        if fn_has_unsatisfiable_preds(cx, def_id.to_def_id()) {\n+        if span.from_expansion() {\n             return;\n         }\n-\n-        let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n-\n-        // checking return type through MIR, HIR is not able to determine inferred closure return types\n-        // make sure it's not a macro\n-        if !mir.return_ty().is_unit() && !span.from_expansion() {\n-            expr_match(cx, &body.value);\n+        let body = cx.tcx.hir().body(body.id());\n+        if cx.typeck_results().expr_ty(&body.value).is_unit() {\n+            return;\n         }\n+        expr_match(cx, &body.value);\n     }\n }"}, {"sha": "4f35e13c85a1c7cc771425ffec4422f09b3defb4", "filename": "clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -66,8 +66,7 @@ impl LateLintPass<'_> for InconsistentStructConstructor {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Struct(qpath, fields, base) = expr.kind;\n-            if let Some(def_id)  = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-            let ty = cx.tcx.type_of(def_id);\n+            let ty = cx.typeck_results().expr_ty(expr);\n             if let Some(adt_def) = ty.ty_adt_def();\n             if adt_def.is_struct();\n             if let Some(variant) = adt_def.variants.iter().next();"}, {"sha": "c919ec097a2393a5c3c5ea1189e68278c7b54dfe", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -132,13 +132,13 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                 }\n \n                 let help_msg = match (range.start, range.end) {\n-                    (None, Some(_)) => \"Consider using `.get(..n)`or `.get_mut(..n)` instead\",\n-                    (Some(_), None) => \"Consider using `.get(n..)` or .get_mut(n..)` instead\",\n-                    (Some(_), Some(_)) => \"Consider using `.get(n..m)` or `.get_mut(n..m)` instead\",\n+                    (None, Some(_)) => \"consider using `.get(..n)`or `.get_mut(..n)` instead\",\n+                    (Some(_), None) => \"consider using `.get(n..)` or .get_mut(n..)` instead\",\n+                    (Some(_), Some(_)) => \"consider using `.get(n..m)` or `.get_mut(n..m)` instead\",\n                     (None, None) => return, // [..] is ok.\n                 };\n \n-                span_lint_and_help(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", None, help_msg);\n+                span_lint_and_help(cx, INDEXING_SLICING, expr.span, \"slicing may panic\", None, help_msg);\n             } else {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n                 if let ty::Array(..) = ty.kind() {\n@@ -153,9 +153,9 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                     cx,\n                     INDEXING_SLICING,\n                     expr.span,\n-                    \"indexing may panic.\",\n+                    \"indexing may panic\",\n                     None,\n-                    \"Consider using `.get(n)` or `.get_mut(n)` instead\",\n+                    \"consider using `.get(n)` or `.get_mut(n)` instead\",\n                 );\n             }\n         }"}, {"sha": "7040ac3191f3c69c78d4c1ac711d05aaf53a4e3e", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -89,11 +89,7 @@ impl Finiteness {\n impl From<bool> for Finiteness {\n     #[must_use]\n     fn from(b: bool) -> Self {\n-        if b {\n-            Infinite\n-        } else {\n-            Finite\n-        }\n+        if b { Infinite } else { Finite }\n     }\n }\n "}, {"sha": "c1f3e1d9d685c13809e93f128303c914722cfba7", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -139,7 +139,7 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n                 self_type.to_string()\n             ),\n             None,\n-            &format!(\"remove the inherent method from type `{}`\", self_type.to_string())\n+            &format!(\"remove the inherent method from type `{}`\", self_type.to_string()),\n         );\n     } else {\n         span_lint_and_help("}, {"sha": "39b4605e72f103b6024bcbc03c02c15fb2d77dc3", "filename": "clippy_lints/src/integer_division.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> LateLintPass<'tcx> for IntegerDivision {\n                 expr.span,\n                 \"integer division\",\n                 None,\n-                \"division of integers may cause loss of precision. consider using floats.\",\n+                \"division of integers may cause loss of precision. consider using floats\",\n             );\n         }\n     }"}, {"sha": "1e1023b2743502e8d732eaf825e8c09f6414e9ec", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 125, "deletions": 41, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,11 +1,17 @@\n-use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{\n+    get_item_name, get_parent_as_impl, is_allowed, snippet_with_applicability, span_lint, span_lint_and_sugg,\n+    span_lint_and_then,\n+};\n+use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::{AssocItemKind, BinOpKind, Expr, ExprKind, Impl, ImplItemRef, Item, ItemKind, TraitItemRef};\n+use rustc_hir::{\n+    def_id::DefId, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, ImplItem, ImplItemKind, ImplicitSelfKind, Item,\n+    ItemKind, Mutability, Node, TraitItemRef, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, AssocKind, FnSig};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{Span, Spanned, Symbol};\n \n@@ -113,14 +119,38 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             return;\n         }\n \n-        match item.kind {\n-            ItemKind::Trait(_, _, _, _, ref trait_items) => check_trait_items(cx, item, trait_items),\n-            ItemKind::Impl(Impl {\n-                of_trait: None,\n-                items: ref impl_items,\n-                ..\n-            }) => check_impl_items(cx, item, impl_items),\n-            _ => (),\n+        if let ItemKind::Trait(_, _, _, _, ref trait_items) = item.kind {\n+            check_trait_items(cx, item, trait_items);\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n+        if_chain! {\n+            if item.ident.as_str() == \"len\";\n+            if let ImplItemKind::Fn(sig, _) = &item.kind;\n+            if sig.decl.implicit_self.has_implicit_self();\n+            if cx.access_levels.is_exported(item.hir_id());\n+            if matches!(sig.decl.output, FnRetTy::Return(_));\n+            if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n+            if imp.of_trait.is_none();\n+            if let TyKind::Path(ty_path) = &imp.self_ty.kind;\n+            if let Some(ty_id) = cx.qpath_res(ty_path, imp.self_ty.hir_id).opt_def_id();\n+            if let Some(local_id) = ty_id.as_local();\n+            let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n+            if !is_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n+            then {\n+                let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n+                    Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n+                    Some(Node::Item(x)) => match x.kind {\n+                        ItemKind::Struct(..) => (x.ident.name, \"struct\"),\n+                        ItemKind::Enum(..) => (x.ident.name, \"enum\"),\n+                        ItemKind::Union(..) => (x.ident.name, \"union\"),\n+                        _ => (x.ident.name, \"type\"),\n+                    }\n+                    _ => return,\n+                };\n+                check_for_is_empty(cx, sig.span, sig.decl.implicit_self, ty_id, name, kind)\n+            }\n         }\n     }\n \n@@ -202,40 +232,94 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     }\n }\n \n-fn check_impl_items(cx: &LateContext<'_>, item: &Item<'_>, impl_items: &[ImplItemRef<'_>]) {\n-    fn is_named_self(cx: &LateContext<'_>, item: &ImplItemRef<'_>, name: &str) -> bool {\n-        item.ident.name.as_str() == name\n-            && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1\n-            } else {\n-                false\n-            }\n+/// Checks if the given signature matches the expectations for `is_empty`\n+fn check_is_empty_sig(cx: &LateContext<'_>, sig: FnSig<'_>, self_kind: ImplicitSelfKind) -> bool {\n+    match &**sig.inputs_and_output {\n+        [arg, res] if *res == cx.tcx.types.bool => {\n+            matches!(\n+                (arg.kind(), self_kind),\n+                (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)\n+                    | (ty::Ref(_, _, Mutability::Mut), ImplicitSelfKind::MutRef)\n+            ) || (!arg.is_ref() && matches!(self_kind, ImplicitSelfKind::Imm | ImplicitSelfKind::Mut))\n+        },\n+        _ => false,\n     }\n+}\n \n-    let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.hir_id()) {\n-            return;\n-        }\n-        \"a private\"\n-    } else {\n-        \"no corresponding\"\n-    };\n-\n-    if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.hir_id()) {\n-            let ty = cx.tcx.type_of(item.def_id);\n+/// Checks if the given type has an `is_empty` method with the appropriate signature.\n+fn check_for_is_empty(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    self_kind: ImplicitSelfKind,\n+    impl_ty: DefId,\n+    item_name: Symbol,\n+    item_kind: &str,\n+) {\n+    let is_empty = Symbol::intern(\"is_empty\");\n+    let is_empty = cx\n+        .tcx\n+        .inherent_impls(impl_ty)\n+        .iter()\n+        .flat_map(|&id| cx.tcx.associated_items(id).filter_by_name_unhygienic(is_empty))\n+        .find(|item| item.kind == AssocKind::Fn);\n \n-            span_lint(\n-                cx,\n-                LEN_WITHOUT_IS_EMPTY,\n-                item.span,\n-                &format!(\n-                    \"item `{}` has a public `len` method but {} `is_empty` method\",\n-                    ty, is_empty\n+    let (msg, is_empty_span, self_kind) = match is_empty {\n+        None => (\n+            format!(\n+                \"{} `{}` has a public `len` method, but no `is_empty` method\",\n+                item_kind,\n+                item_name.as_str(),\n+            ),\n+            None,\n+            None,\n+        ),\n+        Some(is_empty)\n+            if !cx\n+                .access_levels\n+                .is_exported(cx.tcx.hir().local_def_id_to_hir_id(is_empty.def_id.expect_local())) =>\n+        {\n+            (\n+                format!(\n+                    \"{} `{}` has a public `len` method, but a private `is_empty` method\",\n+                    item_kind,\n+                    item_name.as_str(),\n                 ),\n-            );\n+                Some(cx.tcx.def_span(is_empty.def_id)),\n+                None,\n+            )\n+        },\n+        Some(is_empty)\n+            if !(is_empty.fn_has_self_parameter\n+                && check_is_empty_sig(cx, cx.tcx.fn_sig(is_empty.def_id).skip_binder(), self_kind)) =>\n+        {\n+            (\n+                format!(\n+                    \"{} `{}` has a public `len` method, but the `is_empty` method has an unexpected signature\",\n+                    item_kind,\n+                    item_name.as_str(),\n+                ),\n+                Some(cx.tcx.def_span(is_empty.def_id)),\n+                Some(self_kind),\n+            )\n+        },\n+        Some(_) => return,\n+    };\n+\n+    span_lint_and_then(cx, LEN_WITHOUT_IS_EMPTY, span, &msg, |db| {\n+        if let Some(span) = is_empty_span {\n+            db.span_note(span, \"`is_empty` defined here\");\n         }\n-    }\n+        if let Some(self_kind) = self_kind {\n+            db.note(&format!(\n+                \"expected signature: `({}self) -> bool`\",\n+                match self_kind {\n+                    ImplicitSelfKind::ImmRef => \"&\",\n+                    ImplicitSelfKind::MutRef => \"&mut \",\n+                    _ => \"\",\n+                }\n+            ));\n+        }\n+    });\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {"}, {"sha": "04e151df8e8547efa01bfac782ff04afb02f1f77", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -182,6 +182,7 @@ mod booleans;\n mod bytecount;\n mod cargo_common_metadata;\n mod case_sensitive_file_extension_comparisons;\n+mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n@@ -586,6 +587,18 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &bytecount::NAIVE_BYTECOUNT,\n         &cargo_common_metadata::CARGO_COMMON_METADATA,\n         &case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+        &casts::CAST_LOSSLESS,\n+        &casts::CAST_POSSIBLE_TRUNCATION,\n+        &casts::CAST_POSSIBLE_WRAP,\n+        &casts::CAST_PRECISION_LOSS,\n+        &casts::CAST_PTR_ALIGNMENT,\n+        &casts::CAST_REF_TO_MUT,\n+        &casts::CAST_SIGN_LOSS,\n+        &casts::CHAR_LIT_AS_U8,\n+        &casts::FN_TO_NUMERIC_CAST,\n+        &casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n+        &casts::PTR_AS_PTR,\n+        &casts::UNNECESSARY_CAST,\n         &checked_conversions::CHECKED_CONVERSIONS,\n         &cognitive_complexity::COGNITIVE_COMPLEXITY,\n         &collapsible_if::COLLAPSIBLE_ELSE_IF,\n@@ -769,11 +782,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::FLAT_MAP_IDENTITY,\n         &methods::FROM_ITER_INSTEAD_OF_COLLECT,\n         &methods::GET_UNWRAP,\n+        &methods::IMPLICIT_CLONE,\n         &methods::INEFFICIENT_TO_STRING,\n         &methods::INSPECT_FOR_EACH,\n         &methods::INTO_ITER_ON_REF,\n         &methods::ITERATOR_STEP_BY_ZERO,\n         &methods::ITER_CLONED_COLLECT,\n+        &methods::ITER_COUNT,\n         &methods::ITER_NEXT_SLICE,\n         &methods::ITER_NTH,\n         &methods::ITER_NTH_ZERO,\n@@ -941,28 +956,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n-        &types::CAST_LOSSLESS,\n-        &types::CAST_POSSIBLE_TRUNCATION,\n-        &types::CAST_POSSIBLE_WRAP,\n-        &types::CAST_PRECISION_LOSS,\n-        &types::CAST_PTR_ALIGNMENT,\n-        &types::CAST_REF_TO_MUT,\n-        &types::CAST_SIGN_LOSS,\n-        &types::CHAR_LIT_AS_U8,\n-        &types::FN_TO_NUMERIC_CAST,\n-        &types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n         &types::IMPLICIT_HASHER,\n         &types::INVALID_UPCAST_COMPARISONS,\n         &types::LET_UNIT_VALUE,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n-        &types::PTR_AS_PTR,\n         &types::RC_BUFFER,\n         &types::REDUNDANT_ALLOCATION,\n         &types::TYPE_COMPLEXITY,\n         &types::UNIT_ARG,\n         &types::UNIT_CMP,\n-        &types::UNNECESSARY_CAST,\n         &types::VEC_BOX,\n         &undropped_manually_drops::UNDROPPED_MANUALLY_DROPS,\n         &unicode::INVISIBLE_CHARACTERS,\n@@ -1073,6 +1076,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box use_self::UseSelf::new(msrv));\n     store.register_late_pass(move || box missing_const_for_fn::MissingConstForFn::new(msrv));\n     store.register_late_pass(move || box needless_question_mark::NeedlessQuestionMark::new(msrv));\n+    store.register_late_pass(move || box casts::Casts::new(msrv));\n \n     store.register_late_pass(|| box size_of_in_element_count::SizeOfInElementCount);\n     store.register_late_pass(|| box map_clone::MapClone);\n@@ -1084,7 +1088,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    store.register_late_pass(|| box types::Casts);\n     let type_complexity_threshold = conf.type_complexity_threshold;\n     store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n     store.register_late_pass(|| box minmax::MinMaxPass);\n@@ -1105,7 +1108,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box panic_unimplemented::PanicUnimplemented);\n     store.register_late_pass(|| box strings::StringLitAsBytes);\n     store.register_late_pass(|| box derive::Derive);\n-    store.register_late_pass(|| box types::CharLitAsU8);\n     store.register_late_pass(|| box get_last_with_len::GetLastWithLen);\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n     store.register_late_pass(|| box empty_enum::EmptyEnum);\n@@ -1173,7 +1175,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n     store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n     store.register_late_pass(|| box unnecessary_wraps::UnnecessaryWraps);\n-    store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n     store.register_late_pass(|| box transmuting_null::TransmutingNull);\n     store.register_late_pass(|| box path_buf_push_overwrite::PathBufPushOverwrite);\n@@ -1275,7 +1276,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box strings::StringToString);\n     store.register_late_pass(|| box zero_sized_map_values::ZeroSizedMapValues);\n     store.register_late_pass(|| box vec_init_then_push::VecInitThenPush::default());\n-    store.register_late_pass(move || box types::PtrAsPtr::new(msrv));\n     store.register_late_pass(|| box case_sensitive_file_extension_comparisons::CaseSensitiveFileExtensionComparisons);\n     store.register_late_pass(|| box redundant_slicing::RedundantSlicing);\n     store.register_late_pass(|| box from_str_radix_10::FromStrRadix10);\n@@ -1341,7 +1341,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&await_holding_invalid::AWAIT_HOLDING_LOCK),\n         LintId::of(&await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n+        LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS),\n+        LintId::of(&casts::CAST_LOSSLESS),\n+        LintId::of(&casts::CAST_POSSIBLE_TRUNCATION),\n+        LintId::of(&casts::CAST_POSSIBLE_WRAP),\n+        LintId::of(&casts::CAST_PRECISION_LOSS),\n+        LintId::of(&casts::CAST_PTR_ALIGNMENT),\n+        LintId::of(&casts::CAST_SIGN_LOSS),\n+        LintId::of(&casts::PTR_AS_PTR),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),\n         LintId::of(&copy_iterator::COPY_ITERATOR),\n@@ -1380,6 +1388,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&matches::SINGLE_MATCH_ELSE),\n         LintId::of(&methods::FILTER_MAP),\n         LintId::of(&methods::FILTER_MAP_NEXT),\n+        LintId::of(&methods::IMPLICIT_CLONE),\n         LintId::of(&methods::INEFFICIENT_TO_STRING),\n         LintId::of(&methods::MAP_FLATTEN),\n         LintId::of(&methods::MAP_UNWRAP_OR),\n@@ -1400,18 +1409,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&types::CAST_LOSSLESS),\n-        LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n-        LintId::of(&types::CAST_POSSIBLE_WRAP),\n-        LintId::of(&types::CAST_PRECISION_LOSS),\n-        LintId::of(&types::CAST_PTR_ALIGNMENT),\n-        LintId::of(&types::CAST_SIGN_LOSS),\n         LintId::of(&types::IMPLICIT_HASHER),\n         LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&types::LET_UNIT_VALUE),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n-        LintId::of(&types::PTR_AS_PTR),\n         LintId::of(&unicode::NON_ASCII_LITERAL),\n         LintId::of(&unicode::UNICODE_NOT_NFC),\n         LintId::of(&unnecessary_wraps::UNNECESSARY_WRAPS),\n@@ -1455,7 +1457,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n         LintId::of(&booleans::LOGIC_BUG),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n-        LintId::of(&bytecount::NAIVE_BYTECOUNT),\n+        LintId::of(&casts::CAST_REF_TO_MUT),\n+        LintId::of(&casts::CHAR_LIT_AS_U8),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n+        LintId::of(&casts::UNNECESSARY_CAST),\n         LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n@@ -1576,6 +1582,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITERATOR_STEP_BY_ZERO),\n         LintId::of(&methods::ITER_CLONED_COLLECT),\n+        LintId::of(&methods::ITER_COUNT),\n         LintId::of(&methods::ITER_NEXT_SLICE),\n         LintId::of(&methods::ITER_NTH),\n         LintId::of(&methods::ITER_NTH_ZERO),\n@@ -1695,15 +1702,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::BOX_VEC),\n-        LintId::of(&types::CAST_REF_TO_MUT),\n-        LintId::of(&types::CHAR_LIT_AS_U8),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&types::TYPE_COMPLEXITY),\n         LintId::of(&types::UNIT_ARG),\n         LintId::of(&types::UNIT_CMP),\n-        LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n@@ -1736,6 +1738,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n         LintId::of(&blocks_in_if_conditions::BLOCKS_IN_IF_CONDITIONS),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST),\n+        LintId::of(&casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&collapsible_if::COLLAPSIBLE_ELSE_IF),\n         LintId::of(&collapsible_if::COLLAPSIBLE_IF),\n         LintId::of(&collapsible_match::COLLAPSIBLE_MATCH),\n@@ -1832,8 +1836,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(&try_err::TRY_ERR),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST),\n-        LintId::of(&types::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_unit::UNUSED_UNIT),\n         LintId::of(&upper_case_acronyms::UPPER_CASE_ACRONYMS),\n@@ -1849,6 +1851,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(&attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(&booleans::NONMINIMAL_BOOL),\n+        LintId::of(&casts::CHAR_LIT_AS_U8),\n+        LintId::of(&casts::UNNECESSARY_CAST),\n         LintId::of(&double_comparison::DOUBLE_COMPARISONS),\n         LintId::of(&double_parens::DOUBLE_PARENS),\n         LintId::of(&duration_subsec::DURATION_SUBSEC),\n@@ -1881,6 +1885,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::FILTER_NEXT),\n         LintId::of(&methods::FLAT_MAP_IDENTITY),\n         LintId::of(&methods::INSPECT_FOR_EACH),\n+        LintId::of(&methods::ITER_COUNT),\n         LintId::of(&methods::MANUAL_FILTER_MAP),\n         LintId::of(&methods::MANUAL_FIND_MAP),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n@@ -1924,10 +1929,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::TRANSMUTE_PTR_TO_PTR),\n         LintId::of(&transmute::TRANSMUTE_PTR_TO_REF),\n         LintId::of(&types::BORROWED_BOX),\n-        LintId::of(&types::CHAR_LIT_AS_U8),\n         LintId::of(&types::TYPE_COMPLEXITY),\n         LintId::of(&types::UNIT_ARG),\n-        LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n         LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n@@ -1945,6 +1948,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&bit_mask::BAD_BIT_MASK),\n         LintId::of(&bit_mask::INEFFECTIVE_BIT_MASK),\n         LintId::of(&booleans::LOGIC_BUG),\n+        LintId::of(&casts::CAST_REF_TO_MUT),\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n@@ -1997,7 +2001,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n-        LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::UNIT_CMP),\n         LintId::of(&undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n         LintId::of(&unicode::INVISIBLE_CHARACTERS),\n@@ -2010,7 +2013,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n \n     store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n-        LintId::of(&bytecount::NAIVE_BYTECOUNT),\n         LintId::of(&entry::MAP_ENTRY),\n         LintId::of(&escape::BOXED_LOCAL),\n         LintId::of(&large_const_arrays::LARGE_CONST_ARRAYS),"}, {"sha": "33ff01a30e8813c7e85a0963f5c094d6c47b9d31", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, in_macro, span_lint, trait_ref_of_method};\n+use crate::utils::{in_macro, span_lint, trait_ref_of_method};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::intravisit::{\n     walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty,\n@@ -8,8 +7,8 @@ use rustc_hir::intravisit::{\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n     BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n-    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier, TraitFn,\n-    TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n+    ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n+    TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n@@ -300,7 +299,7 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<FxHashSet<_>>().len()\n }\n \n-const CLOSURE_TRAIT_BOUNDS: [&[&str]; 3] = [&paths::FN, &paths::FN_MUT, &paths::FN_ONCE];\n+const CLOSURE_TRAIT_BOUNDS: [LangItem; 3] = [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n@@ -359,10 +358,13 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(&mut self, poly_tref: &'tcx PolyTraitRef<'tcx>, tbm: TraitBoundModifier) {\n         let trait_ref = &poly_tref.trait_ref;\n-        if CLOSURE_TRAIT_BOUNDS\n-            .iter()\n-            .any(|trait_path| trait_ref.trait_def_id() == get_trait_def_id(self.cx, trait_path))\n-        {\n+        if CLOSURE_TRAIT_BOUNDS.iter().any(|&item| {\n+            self.cx\n+                .tcx\n+                .lang_items()\n+                .require(item)\n+                .map_or(false, |id| Some(id) == trait_ref.trait_def_id())\n+        }) {\n             let mut sub_visitor = RefVisitor::new(self.cx);\n             sub_visitor.visit_trait_ref(trait_ref);\n             self.nested_elision_site_lts.append(&mut sub_visitor.all_lts());"}, {"sha": "9b626d81ebd813e03e940a3cfaca1d8239057873", "filename": "clippy_lints/src/loops.rs", "status": "removed", "additions": 0, "deletions": 3182, "changes": 3182, "blob_url": "https://github.com/rust-lang/rust/blob/36a27ecaacad74f69b21a12bc66b826f11f2d44e/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a27ecaacad74f69b21a12bc66b826f11f2d44e/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=36a27ecaacad74f69b21a12bc66b826f11f2d44e"}, {"sha": "43e85538f281da7a7f35c882b94895a2651136a2", "filename": "clippy_lints/src/loops/empty_loop.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fempty_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,17 @@\n+use super::EMPTY_LOOP;\n+use crate::utils::{is_in_panic_handler, is_no_std_crate, span_lint_and_help};\n+\n+use rustc_hir::{Block, Expr};\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+    if loop_block.stmts.is_empty() && loop_block.expr.is_none() && !is_in_panic_handler(cx, expr) {\n+        let msg = \"empty `loop {}` wastes CPU cycles\";\n+        let help = if is_no_std_crate(cx) {\n+            \"you should either use `panic!()` or add a call pausing or sleeping the thread to the loop body\"\n+        } else {\n+            \"you should either use `panic!()` or add `std::thread::sleep(..);` to the loop body\"\n+        };\n+        span_lint_and_help(cx, EMPTY_LOOP, expr.span, msg, None, help);\n+    }\n+}"}, {"sha": "8d98b940c66a95c3745c1c49dec67c2a74c9fa77", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,58 @@\n+use super::{\n+    get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor, EXPLICIT_COUNTER_LOOP,\n+};\n+use crate::utils::{get_enclosing_block, is_integer_const, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+\n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_expr(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+        for id in increment_visitor.into_results() {\n+            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n+            walk_block(&mut initialize_visitor, block);\n+\n+            if_chain! {\n+                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if is_integer_const(cx, initializer, 0);\n+                then {\n+                    let mut applicability = Applicability::MachineApplicable;\n+\n+                    let for_span = get_span_of_entire_for_loop(expr);\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        EXPLICIT_COUNTER_LOOP,\n+                        for_span.with_hi(arg.span.hi()),\n+                        &format!(\"the variable `{}` is used as a loop counter\", name),\n+                        \"consider using\",\n+                        format!(\n+                            \"for ({}, {}) in {}.enumerate()\",\n+                            name,\n+                            snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n+                            make_iterator_snippet(cx, arg, &mut applicability),\n+                        ),\n+                        applicability,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "1d778205a2ad1f3d118dd5f7461933a8387989b3", "filename": "clippy_lints/src/loops/explicit_into_iter_loop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_into_iter_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,27 @@\n+use super::EXPLICIT_INTO_ITER_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, args: &'hir [Expr<'hir>], arg: &Expr<'_>) {\n+    let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+    let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    if !TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_INTO_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over containers instead of using explicit \\\n+            iteration methods\",\n+        \"to write this more concisely, try\",\n+        object.to_string(),\n+        applicability,\n+    );\n+}"}, {"sha": "9683e59a3962d2acac1613a92f1cd864ee155af3", "filename": "clippy_lints/src/loops/explicit_iter_loop.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_iter_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,74 @@\n+use super::EXPLICIT_ITER_LOOP;\n+use crate::utils::{match_trait_method, snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::sym;\n+\n+use crate::utils::{is_type_diagnostic_item, match_type, paths};\n+\n+pub(super) fn check(cx: &LateContext<'_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n+    let should_lint = match method_name {\n+        \"iter\" | \"iter_mut\" => is_ref_iterable_type(cx, &args[0]),\n+        \"into_iter\" if match_trait_method(cx, arg, &paths::INTO_ITERATOR) => {\n+            let receiver_ty = cx.typeck_results().expr_ty(&args[0]);\n+            let receiver_ty_adjusted = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+            let ref_receiver_ty = cx.tcx.mk_ref(\n+                cx.tcx.lifetimes.re_erased,\n+                ty::TypeAndMut {\n+                    ty: receiver_ty,\n+                    mutbl: Mutability::Not,\n+                },\n+            );\n+            TyS::same_type(receiver_ty_adjusted, ref_receiver_ty)\n+        },\n+        _ => false,\n+    };\n+\n+    if !should_lint {\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n+    let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n+    span_lint_and_sugg(\n+        cx,\n+        EXPLICIT_ITER_LOOP,\n+        arg.span,\n+        \"it is more concise to loop over references to containers instead of using explicit \\\n+         iteration methods\",\n+        \"to write this more concisely, try\",\n+        format!(\"&{}{}\", muta, object),\n+        applicability,\n+    )\n+}\n+\n+/// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n+/// for `&T` and `&mut T`, such as `Vec`.\n+#[rustfmt::skip]\n+fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n+    // will allow further borrows afterwards\n+    let ty = cx.typeck_results().expr_ty(e);\n+    is_iterable_array(ty, cx) ||\n+    is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+    match_type(cx, ty, &paths::LINKED_LIST) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashmap_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::hashset_type) ||\n+    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n+    match_type(cx, ty, &paths::BINARY_HEAP) ||\n+    match_type(cx, ty, &paths::BTREEMAP) ||\n+    match_type(cx, ty, &paths::BTREESET)\n+}\n+\n+fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n+    match ty.kind() {\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n+        _ => false,\n+    }\n+}"}, {"sha": "6ee9b95a3b689035a544e65b1e1de2b7369ae98d", "filename": "clippy_lints/src/loops/for_kv_map.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_kv_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,71 @@\n+use super::FOR_KV_MAP;\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{is_type_diagnostic_item, match_type, multispan_sugg, paths, snippet, span_lint_and_then, sugg};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+/// Checks for the `FOR_KV_MAP` lint.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let pat_span = pat.span;\n+\n+    if let PatKind::Tuple(ref pat, _) = pat.kind {\n+        if pat.len() == 2 {\n+            let arg_span = arg.span;\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n+                ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n+                    (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\", ty, mutbl),\n+                    (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n+                    _ => return,\n+                },\n+                _ => return,\n+            };\n+            let mutbl = match mutbl {\n+                Mutability::Not => \"\",\n+                Mutability::Mut => \"_mut\",\n+            };\n+            let arg = match arg.kind {\n+                ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) => &**expr,\n+                _ => arg,\n+            };\n+\n+            if is_type_diagnostic_item(cx, ty, sym::hashmap_type) || match_type(cx, ty, &paths::BTREEMAP) {\n+                span_lint_and_then(\n+                    cx,\n+                    FOR_KV_MAP,\n+                    expr.span,\n+                    &format!(\"you seem to want to iterate on a map's {}s\", kind),\n+                    |diag| {\n+                        let map = sugg::Sugg::hir(cx, arg, \"map\");\n+                        multispan_sugg(\n+                            diag,\n+                            \"use the corresponding method\",\n+                            vec![\n+                                (pat_span, snippet(cx, new_pat_span, kind).into_owned()),\n+                                (arg_span, format!(\"{}.{}s{}()\", map.maybe_par(), kind, mutbl)),\n+                            ],\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n+fn pat_is_wild<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n+    match *pat {\n+        PatKind::Wild => true,\n+        PatKind::Binding(_, id, ident, None) if ident.as_str().starts_with('_') => {\n+            !LocalUsedVisitor::new(cx, id).check_expr(body)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "db22d90a304bcac0bf04a121ee818ee8ea422cab", "filename": "clippy_lints/src/loops/for_loops_over_fallibles.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loops_over_fallibles.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,45 @@\n+use super::FOR_LOOPS_OVER_FALLIBLES;\n+use crate::utils::{is_type_diagnostic_item, snippet, span_lint_and_help};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+/// Checks for `for` loops over `Option`s and `Result`s.\n+pub(super) fn check(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(arg);\n+    if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is an `Option`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Some({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    } else if is_type_diagnostic_item(cx, ty, sym::result_type) {\n+        span_lint_and_help(\n+            cx,\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            &format!(\n+                \"for loop over `{0}`, which is a `Result`. This is more readably written as an \\\n+                `if let` statement\",\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+            None,\n+            &format!(\n+                \"consider replacing `for {0} in {1}` with `if let Ok({0}) = {1}`\",\n+                snippet(cx, pat.span, \"_\"),\n+                snippet(cx, arg.span, \"_\")\n+            ),\n+        );\n+    }\n+}"}, {"sha": "cf78bbc49a3623a3f2e5b5a569fc7d19cd3da161", "filename": "clippy_lints/src/loops/iter_next_loop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fiter_next_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,19 @@\n+use super::ITER_NEXT_LOOP;\n+use crate::utils::{match_trait_method, paths, span_lint};\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, expr: &Expr<'_>) -> bool {\n+    if match_trait_method(cx, arg, &paths::ITERATOR) {\n+        span_lint(\n+            cx,\n+            ITER_NEXT_LOOP,\n+            expr.span,\n+            \"you are iterating over `Iterator::next()` which is an Option; this will compile but is \\\n+            probably not what you want\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "3d3ae6f3152a3b9b183403ad4bbefc49acc1cb7e", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,79 @@\n+use super::utils::make_iterator_snippet;\n+use super::MANUAL_FLATTEN;\n+use crate::utils::{is_ok_ctor, is_some_ctor, path_to_local_id, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+/// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n+/// iterator element is used.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    if let ExprKind::Block(ref block, _) = body.kind {\n+        // Ensure the `if let` statement is the only expression or statement in the for-loop\n+        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n+            let match_stmt = &block.stmts[0];\n+            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n+                Some(inner_expr)\n+            } else {\n+                None\n+            }\n+        } else if block.stmts.is_empty() {\n+            block.expr\n+        } else {\n+            None\n+        };\n+\n+        if_chain! {\n+            if let Some(inner_expr) = inner_expr;\n+            if let ExprKind::Match(\n+                ref match_expr, ref match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n+            ) = inner_expr.kind;\n+            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+            if path_to_local_id(match_expr, pat_hir_id);\n+            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+            if let PatKind::TupleStruct(QPath::Resolved(None, path), _, _) = match_arms[0].pat.kind;\n+            let some_ctor = is_some_ctor(cx, path.res);\n+            let ok_ctor = is_ok_ctor(cx, path.res);\n+            if some_ctor || ok_ctor;\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+\n+            then {\n+                // Prepare the error message\n+                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n+\n+                // Prepare the help message\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_FLATTEN,\n+                    span,\n+                    &msg,\n+                    |diag| {\n+                        let sugg = format!(\"{}.flatten()\", arg_snippet);\n+                        diag.span_suggestion(\n+                            arg.span,\n+                            \"try\",\n+                            sugg,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_help(\n+                            inner_expr.span,\n+                            \"...and remove the `if let` statement in the for loop\",\n+                        );\n+                    }\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "fad96c2d5c04cd822f675b54e33848d671b14744", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "added", "additions": 451, "deletions": 0, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,451 @@\n+use super::{get_span_of_entire_for_loop, IncrementVisitor, InitializeVisitor, MANUAL_MEMCPY};\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    get_enclosing_block, higher, is_type_diagnostic_item, path_to_local, snippet, span_lint_and_sugg, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::walk_block;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Pat, PatKind, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Checks for for loops that sequentially copy items from one slice-like\n+/// object to another.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> bool {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(block, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n+                // The only statements in the for loops can be indexed assignments from\n+                // indexed retrievals (except increments of loop counters).\n+                .map(|o| {\n+                    o.and_then(|(lhs, rhs)| {\n+                        let rhs = fetch_cloned_expr(rhs);\n+                        if_chain! {\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n+\n+                            // Source and destination must be different\n+                            if path_to_local(base_left) != path_to_local(base_right);\n+                            then {\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    })\n+                })\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n+                .collect::<Option<Vec<_>>>()\n+                .filter(|v| !v.is_empty())\n+                .map(|v| v.join(\"\\n    \"));\n+\n+            if let Some(big_sugg) = big_sugg {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_MEMCPY,\n+                    get_span_of_entire_for_loop(expr),\n+                    \"it looks like you're manually copying between slices\",\n+                    \"try replacing the loop by\",\n+                    big_sugg,\n+                    Applicability::Unspecified,\n+                );\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn build_manual_memcpy_suggestion<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    start: &Expr<'_>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    dst: &IndexExpr<'_>,\n+    src: &IndexExpr<'_>,\n+) -> String {\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        if offset.as_str() == \"0\" {\n+            sugg::EMPTY.into()\n+        } else {\n+            offset\n+        }\n+    }\n+\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n+        if_chain! {\n+            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n+            if method.ident.name == sym!(len);\n+            if len_args.len() == 1;\n+            if let Some(arg) = len_args.get(0);\n+            if path_to_local(arg) == path_to_local(base);\n+            then {\n+                if sugg.as_str() == end_str {\n+                    sugg::EMPTY.into()\n+                } else {\n+                    sugg\n+                }\n+            } else {\n+                match limits {\n+                    ast::RangeLimits::Closed => {\n+                        sugg + &sugg::ONE.into()\n+                    },\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n+            }\n+        }\n+    };\n+\n+    let start_str = Sugg::hir(cx, start, \"\").into();\n+    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            )\n+            .into_sugg(),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                )\n+                .into_sugg(),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n+\n+    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n+    let src_base_str = snippet(cx, src.base.span, \"???\");\n+\n+    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n+        dst_base_str\n+    } else {\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n+        .into()\n+    };\n+\n+    format!(\n+        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n+    )\n+}\n+\n+/// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n+/// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n+/// it exists for the convenience of the overloaded operators while normal functions can do the\n+/// same.\n+#[derive(Clone)]\n+struct MinifyingSugg<'a>(Sugg<'a>);\n+\n+impl<'a> MinifyingSugg<'a> {\n+    fn as_str(&self) -> &str {\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n+    }\n+\n+    fn into_sugg(self) -> Sugg<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n+    fn from(sugg: Sugg<'a>) -> Self {\n+        Self(sugg)\n+    }\n+}\n+\n+impl std::ops::Add for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self.clone(),\n+            (_, _) => (&self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self.clone(),\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (&self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self,\n+            (_, _) => (self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self,\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n+struct Offset {\n+    value: MinifyingSugg<'static>,\n+    sign: OffsetSign,\n+}\n+\n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl Offset {\n+    fn negative(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Negative,\n+        }\n+    }\n+\n+    fn positive(value: Sugg<'static>) -> Self {\n+        Self {\n+            value: value.into(),\n+            sign: OffsetSign::Positive,\n+        }\n+    }\n+\n+    fn empty() -> Self {\n+        Self::positive(sugg::ZERO)\n+    }\n+}\n+\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n+}\n+\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n+    idx_offset: Offset,\n+}\n+\n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n+}\n+\n+fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n+    let is_slice = match ty.kind() {\n+        ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n+        ty::Slice(..) | ty::Array(..) => true,\n+        _ => false,\n+    };\n+\n+    is_slice || is_type_diagnostic_item(cx, ty, sym::vec_type) || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+}\n+\n+fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n+        if method.ident.name == sym::clone;\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then { arg } else { expr }\n+    }\n+}\n+\n+fn get_details_from_idx<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn get_start<'tcx>(e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        let id = path_to_local(e)?;\n+        starts.iter().find(|start| start.id == id).map(|start| start.kind)\n+    }\n+\n+    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n+        match &e.kind {\n+            ExprKind::Lit(l) => match l.node {\n+                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n+                _ => None,\n+            },\n+            ExprKind::Path(..) if get_start(e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n+            _ => None,\n+        }\n+    }\n+\n+    match idx.kind {\n+        ExprKind::Binary(op, lhs, rhs) => match op.node {\n+            BinOpKind::Add => {\n+                let offset_opt = get_start(lhs, starts)\n+                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n+                    .or_else(|| get_start(rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n+\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n+            },\n+            BinOpKind::Sub => {\n+                get_start(lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Path(..) => get_start(idx, starts).map(|s| (s, Offset::empty())),\n+        _ => None,\n+    }\n+}\n+\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Get assignments from the given block.\n+/// The returned iterator yields `None` if no assignment expressions are there,\n+/// filtering out the increments of the given whitelisted loop counters;\n+/// because its job is to make sure there's nothing other than assignments and the increments.\n+fn get_assignments<'a, 'tcx>(\n+    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n+    loop_counters: &'a [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'a {\n+    // As the `filter` and `map` below do different things, I think putting together\n+    // just increases complexity. (cc #3188 and #4193)\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+        })\n+        .chain((*expr).into_iter())\n+        .filter(move |e| {\n+            if let ExprKind::AssignOp(_, place, _) = e.kind {\n+                path_to_local(place).map_or(false, |id| {\n+                    !loop_counters\n+                        .iter()\n+                        // skip the first item which should be `StartKind::Range`\n+                        // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                        .skip(1)\n+                        .any(|counter| counter.id == id)\n+                })\n+            } else {\n+                true\n+            }\n+        })\n+        .map(get_assignment)\n+}\n+\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n+            })\n+            .into()\n+    })\n+}"}, {"sha": "2a372c6307eabfa6417b7af4368c12708d5bb22f", "filename": "clippy_lints/src/loops/mod.rs", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,627 @@\n+mod empty_loop;\n+mod explicit_counter_loop;\n+mod explicit_into_iter_loop;\n+mod explicit_iter_loop;\n+mod for_kv_map;\n+mod for_loops_over_fallibles;\n+mod iter_next_loop;\n+mod manual_flatten;\n+mod manual_memcpy;\n+mod mut_range_bound;\n+mod needless_collect;\n+mod needless_range_loop;\n+mod never_loop;\n+mod same_item_push;\n+mod single_element_loop;\n+mod utils;\n+mod while_immutable_condition;\n+mod while_let_loop;\n+mod while_let_on_iterator;\n+\n+use crate::utils::higher;\n+use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+use utils::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for for-loops that manually copy items between\n+    /// slices that could be optimized by having a memcpy.\n+    ///\n+    /// **Why is this bad?** It is not as fast as a memcpy.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let src = vec![1];\n+    /// # let mut dst = vec![0; 65];\n+    /// for i in 0..src.len() {\n+    ///     dst[i + 64] = src[i];\n+    /// }\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// # let src = vec![1];\n+    /// # let mut dst = vec![0; 65];\n+    /// dst[64..(src.len() + 64)].clone_from_slice(&src[..]);\n+    /// ```\n+    pub MANUAL_MEMCPY,\n+    perf,\n+    \"manually copying items between slices\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for looping over the range of `0..len` of some\n+    /// collection just to get the values by index.\n+    ///\n+    /// **Why is this bad?** Just iterating the collection itself makes the intent\n+    /// more clear and is probably faster.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// for i in 0..vec.len() {\n+    ///     println!(\"{}\", vec[i]);\n+    /// }\n+    /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// let vec = vec!['a', 'b', 'c'];\n+    /// for i in vec {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    pub NEEDLESS_RANGE_LOOP,\n+    style,\n+    \"for-looping over a range of indices where an iterator over items would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.iter()` where `&x` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** False negatives. We currently only warn on some known\n+    /// types.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // with `y` a `Vec` or slice:\n+    /// # let y = vec![1];\n+    /// for x in y.iter() {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// for x in &y {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub EXPLICIT_ITER_LOOP,\n+    pedantic,\n+    \"for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `y.into_iter()` where `y` will do, and\n+    /// suggests the latter.\n+    ///\n+    /// **Why is this bad?** Readability.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// // with `y` a `Vec` or slice:\n+    /// for x in y.into_iter() {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    /// can be rewritten to\n+    /// ```rust\n+    /// # let y = vec![1];\n+    /// for x in y {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub EXPLICIT_INTO_ITER_LOOP,\n+    pedantic,\n+    \"for-looping over `_.into_iter()` when `_` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops on `x.next()`.\n+    ///\n+    /// **Why is this bad?** `next()` returns either `Some(value)` if there was a\n+    /// value, or `None` otherwise. The insidious thing is that `Option<_>`\n+    /// implements `IntoIterator`, so that possibly one value will be iterated,\n+    /// leading to some hard to find bugs. No one will want to write such code\n+    /// [except to win an Underhanded Rust\n+    /// Contest](https://www.reddit.com/r/rust/comments/3hb0wm/underhanded_rust_contest/cu5yuhr).\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for x in y.next() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub ITER_NEXT_LOOP,\n+    correctness,\n+    \"for-looping over `_.next()` which is probably not intended\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `for` loops over `Option` or `Result` values.\n+    ///\n+    /// **Why is this bad?** Readability. This is more clearly expressed as an `if\n+    /// let`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let opt = Some(1);\n+    ///\n+    /// // Bad\n+    /// for x in opt {\n+    ///     // ..\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Some(x) = opt {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    ///\n+    /// // or\n+    ///\n+    /// ```rust\n+    /// # let res: Result<i32, std::io::Error> = Ok(1);\n+    ///\n+    /// // Bad\n+    /// for x in &res {\n+    ///     // ..\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Ok(x) = res {\n+    ///     // ..\n+    /// }\n+    /// ```\n+    pub FOR_LOOPS_OVER_FALLIBLES,\n+    correctness,\n+    \"for-looping over an `Option` or a `Result`, which is more clearly expressed as an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects `loop + match` combinations that are easier\n+    /// written as a `while let` loop.\n+    ///\n+    /// **Why is this bad?** The `while let` loop is usually shorter and more\n+    /// readable.\n+    ///\n+    /// **Known problems:** Sometimes the wrong binding is displayed ([#383](https://github.com/rust-lang/rust-clippy/issues/383)).\n+    ///\n+    /// **Example:**\n+    /// ```rust,no_run\n+    /// # let y = Some(1);\n+    /// loop {\n+    ///     let x = match y {\n+    ///         Some(x) => x,\n+    ///         None => break,\n+    ///     };\n+    ///     // .. do something with x\n+    /// }\n+    /// // is easier written as\n+    /// while let Some(x) = y {\n+    ///     // .. do something with x\n+    /// };\n+    /// ```\n+    pub WHILE_LET_LOOP,\n+    complexity,\n+    \"`loop { if let { ... } else break }`, which can be written as a `while let` loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions collecting an iterator when collect\n+    /// is not needed.\n+    ///\n+    /// **Why is this bad?** `collect` causes the allocation of a new data structure,\n+    /// when this allocation may not be needed.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let iterator = vec![1].into_iter();\n+    /// let len = iterator.clone().collect::<Vec<_>>().len();\n+    /// // should be\n+    /// let len = iterator.count();\n+    /// ```\n+    pub NEEDLESS_COLLECT,\n+    perf,\n+    \"collecting an iterator when collect is not needed\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks `for` loops over slices with an explicit counter\n+    /// and suggests the use of `.enumerate()`.\n+    ///\n+    /// **Why is it bad?** Using `.enumerate()` makes the intent more clear,\n+    /// declutters the code and may be faster in some instances.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let v = vec![1];\n+    /// # fn bar(bar: usize, baz: usize) {}\n+    /// let mut i = 0;\n+    /// for item in &v {\n+    ///     bar(i, *item);\n+    ///     i += 1;\n+    /// }\n+    /// ```\n+    /// Could be written as\n+    /// ```rust\n+    /// # let v = vec![1];\n+    /// # fn bar(bar: usize, baz: usize) {}\n+    /// for (i, item) in v.iter().enumerate() { bar(i, *item); }\n+    /// ```\n+    pub EXPLICIT_COUNTER_LOOP,\n+    complexity,\n+    \"for-looping with an explicit counter when `_.enumerate()` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for empty `loop` expressions.\n+    ///\n+    /// **Why is this bad?** These busy loops burn CPU cycles without doing\n+    /// anything. It is _almost always_ a better idea to `panic!` than to have\n+    /// a busy loop.\n+    ///\n+    /// If panicking isn't possible, think of the environment and either:\n+    ///   - block on something\n+    ///   - sleep the thread for some microseconds\n+    ///   - yield or pause the thread\n+    ///\n+    /// For `std` targets, this can be done with\n+    /// [`std::thread::sleep`](https://doc.rust-lang.org/std/thread/fn.sleep.html)\n+    /// or [`std::thread::yield_now`](https://doc.rust-lang.org/std/thread/fn.yield_now.html).\n+    ///\n+    /// For `no_std` targets, doing this is more complicated, especially because\n+    /// `#[panic_handler]`s can't panic. To stop/pause the thread, you will\n+    /// probably need to invoke some target-specific intrinsic. Examples include:\n+    ///   - [`x86_64::instructions::hlt`](https://docs.rs/x86_64/0.12.2/x86_64/instructions/fn.hlt.html)\n+    ///   - [`cortex_m::asm::wfi`](https://docs.rs/cortex-m/0.6.3/cortex_m/asm/fn.wfi.html)\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```no_run\n+    /// loop {}\n+    /// ```\n+    pub EMPTY_LOOP,\n+    style,\n+    \"empty `loop {}`, which should block or sleep\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `while let` expressions on iterators.\n+    ///\n+    /// **Why is this bad?** Readability. A simple `for` loop is shorter and conveys\n+    /// the intent better.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// while let Some(val) = iter() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub WHILE_LET_ON_ITERATOR,\n+    style,\n+    \"using a `while let` loop instead of a for loop on an iterator\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for iterating a map (`HashMap` or `BTreeMap`) and\n+    /// ignoring either the keys or values.\n+    ///\n+    /// **Why is this bad?** Readability. There are `keys` and `values` methods that\n+    /// can be used to express that don't need the values or keys.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// for (k, _) in &map {\n+    ///     ..\n+    /// }\n+    /// ```\n+    ///\n+    /// could be replaced by\n+    ///\n+    /// ```ignore\n+    /// for k in map.keys() {\n+    ///     ..\n+    /// }\n+    /// ```\n+    pub FOR_KV_MAP,\n+    style,\n+    \"looping on a map using `iter` when `keys` or `values` would do\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops that will always `break`, `return` or\n+    /// `continue` an outer loop.\n+    ///\n+    /// **Why is this bad?** This loop never loops, all it does is obfuscating the\n+    /// code.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// loop {\n+    ///     ..;\n+    ///     break;\n+    /// }\n+    /// ```\n+    pub NEVER_LOOP,\n+    correctness,\n+    \"any loop that will always `break` or `return`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for loops which have a range bound that is a mutable variable\n+    ///\n+    /// **Why is this bad?** One might think that modifying the mutable variable changes the loop bounds\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut foo = 42;\n+    /// for i in 0..foo {\n+    ///     foo -= 1;\n+    ///     println!(\"{}\", i); // prints numbers from 0 to 42, not 0 to 21\n+    /// }\n+    /// ```\n+    pub MUT_RANGE_BOUND,\n+    complexity,\n+    \"for loop over a range where one of the bounds is a mutable variable\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether variables used within while loop condition\n+    /// can be (and are) mutated in the body.\n+    ///\n+    /// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n+    /// will lead to an infinite loop.\n+    ///\n+    /// **Known problems:** If the `while`-loop is in a closure, the check for mutation of the\n+    /// condition variables in the body can cause false negatives. For example when only `Upvar` `a` is\n+    /// in the condition and only `Upvar` `b` gets mutated in the body, the lint will not trigger.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let i = 0;\n+    /// while i > 10 {\n+    ///     println!(\"let me loop forever!\");\n+    /// }\n+    /// ```\n+    pub WHILE_IMMUTABLE_CONDITION,\n+    correctness,\n+    \"variables used within while expression are not mutated in the body\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop is being used to push a constant\n+    /// value into a Vec.\n+    ///\n+    /// **Why is this bad?** This kind of operation can be expressed more succinctly with\n+    /// `vec![item;SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\n+    /// have better performance.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = Vec::new();\n+    /// for _ in 0..20 {\n+    ///    vec.push(item1);\n+    /// }\n+    /// for _ in 0..30 {\n+    ///     vec.push(item2);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = vec![item1; 20];\n+    /// vec.resize(20 + 30, item2);\n+    /// ```\n+    pub SAME_ITEM_PUSH,\n+    style,\n+    \"the same item is pushed inside of a for loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop has a single element.\n+    ///\n+    /// **Why is this bad?** There is no reason to have a loop of a\n+    /// single element.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// for item in &[item1] {\n+    ///     println!(\"{}\", item);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item = &item1;\n+    /// println!(\"{}\", item);\n+    /// ```\n+    pub SINGLE_ELEMENT_LOOP,\n+    complexity,\n+    \"there is no reason to have a single element loop\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Check for unnecessary `if let` usage in a for loop\n+    /// where only the `Some` or `Ok` variant of the iterator element is used.\n+    ///\n+    /// **Why is this bad?** It is verbose and can be simplified\n+    /// by first calling the `flatten` method on the `Iterator`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x {\n+    ///     if let Some(n) = n {\n+    ///         println!(\"{}\", n);\n+    ///     }\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = vec![Some(1), Some(2), Some(3)];\n+    /// for n in x.into_iter().flatten() {\n+    ///     println!(\"{}\", n);\n+    /// }\n+    /// ```\n+    pub MANUAL_FLATTEN,\n+    complexity,\n+    \"for loops over `Option`s or `Result`s with a single expression can be simplified\"\n+}\n+\n+declare_lint_pass!(Loops => [\n+    MANUAL_MEMCPY,\n+    MANUAL_FLATTEN,\n+    NEEDLESS_RANGE_LOOP,\n+    EXPLICIT_ITER_LOOP,\n+    EXPLICIT_INTO_ITER_LOOP,\n+    ITER_NEXT_LOOP,\n+    FOR_LOOPS_OVER_FALLIBLES,\n+    WHILE_LET_LOOP,\n+    NEEDLESS_COLLECT,\n+    EXPLICIT_COUNTER_LOOP,\n+    EMPTY_LOOP,\n+    WHILE_LET_ON_ITERATOR,\n+    FOR_KV_MAP,\n+    NEVER_LOOP,\n+    MUT_RANGE_BOUND,\n+    WHILE_IMMUTABLE_CONDITION,\n+    SAME_ITEM_PUSH,\n+    SINGLE_ELEMENT_LOOP,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Loops {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n+            // we don't want to check expanded macros\n+            // this check is not at the top of the function\n+            // since higher::for_loop expressions are marked as expansions\n+            if body.span.from_expansion() {\n+                return;\n+            }\n+            check_for_loop(cx, pat, arg, body, expr, span);\n+        }\n+\n+        // we don't want to check expanded macros\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        // check for never_loop\n+        never_loop::check(cx, expr);\n+\n+        // check for `loop { if let {} else break }` that could be `while let`\n+        // (also matches an explicit \"match\" instead of \"if let\")\n+        // (even if the \"match\" or \"if let\" is used for declaration)\n+        if let ExprKind::Loop(ref block, _, LoopSource::Loop, _) = expr.kind {\n+            // also check for empty `loop {}` statements, skipping those in #[panic_handler]\n+            empty_loop::check(cx, expr, block);\n+            while_let_loop::check(cx, expr, block);\n+        }\n+\n+        while_let_on_iterator::check(cx, expr);\n+\n+        if let Some((cond, body)) = higher::while_loop(&expr) {\n+            while_immutable_condition::check(cx, cond, body);\n+        }\n+\n+        needless_collect::check(expr, cx);\n+    }\n+}\n+\n+fn check_for_loop<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+    span: Span,\n+) {\n+    let is_manual_memcpy_triggered = manual_memcpy::check(cx, pat, arg, body, expr);\n+    if !is_manual_memcpy_triggered {\n+        needless_range_loop::check(cx, pat, arg, body, expr);\n+        explicit_counter_loop::check(cx, pat, arg, body, expr);\n+    }\n+    check_for_loop_arg(cx, pat, arg, expr);\n+    for_kv_map::check(cx, pat, arg, body, expr);\n+    mut_range_bound::check(cx, arg, body);\n+    single_element_loop::check(cx, pat, arg, body, expr);\n+    same_item_push::check(cx, pat, arg, body, expr);\n+    manual_flatten::check(cx, pat, arg, body, span);\n+}\n+\n+fn check_for_loop_arg(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n+    let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n+\n+    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n+        // just the receiver, no arguments\n+        if args.len() == 1 {\n+            let method_name = &*method.ident.as_str();\n+            // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n+            match method_name {\n+                \"iter\" | \"iter_mut\" => explicit_iter_loop::check(cx, args, arg, method_name),\n+                \"into_iter\" => {\n+                    explicit_iter_loop::check(cx, args, arg, method_name);\n+                    explicit_into_iter_loop::check(cx, args, arg);\n+                },\n+                \"next\" => {\n+                    next_loop_linted = iter_next_loop::check(cx, arg, expr);\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    if !next_loop_linted {\n+        for_loops_over_fallibles::check(cx, pat, arg);\n+    }\n+}"}, {"sha": "3ae592950f13b63163efd3a3a09252b77bbe8530", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,115 @@\n+use super::MUT_RANGE_BOUND;\n+use crate::utils::{higher, path_to_local, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir::{BindingAnnotation, Expr, HirId, Node, PatKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n+\n+pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        end: Some(end),\n+        ..\n+    }) = higher::range(arg)\n+    {\n+        let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n+        if mut_ids[0].is_some() || mut_ids[1].is_some() {\n+            let (span_low, span_high) = check_for_mutation(cx, body, &mut_ids);\n+            mut_warn_with_span(cx, span_low);\n+            mut_warn_with_span(cx, span_high);\n+        }\n+    }\n+}\n+\n+fn mut_warn_with_span(cx: &LateContext<'_>, span: Option<Span>) {\n+    if let Some(sp) = span {\n+        span_lint(\n+            cx,\n+            MUT_RANGE_BOUND,\n+            sp,\n+            \"attempt to mutate range bound within loop; note that the range of the loop is unchanged\",\n+        );\n+    }\n+}\n+\n+fn check_for_mutability(cx: &LateContext<'_>, bound: &Expr<'_>) -> Option<HirId> {\n+    if_chain! {\n+        if let Some(hir_id) = path_to_local(bound);\n+        if let Node::Binding(pat) = cx.tcx.hir().get(hir_id);\n+        if let PatKind::Binding(BindingAnnotation::Mutable, ..) = pat.kind;\n+        then {\n+            return Some(hir_id);\n+        }\n+    }\n+    None\n+}\n+\n+fn check_for_mutation<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    body: &Expr<'_>,\n+    bound_ids: &[Option<HirId>],\n+) -> (Option<Span>, Option<Span>) {\n+    let mut delegate = MutatePairDelegate {\n+        cx,\n+        hir_id_low: bound_ids[0],\n+        hir_id_high: bound_ids[1],\n+        span_low: None,\n+        span_high: None,\n+    };\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        ExprUseVisitor::new(\n+            &mut delegate,\n+            &infcx,\n+            body.hir_id.owner,\n+            cx.param_env,\n+            cx.typeck_results(),\n+        )\n+        .walk_expr(body);\n+    });\n+    delegate.mutation_span()\n+}\n+\n+struct MutatePairDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    hir_id_low: Option<HirId>,\n+    hir_id_high: Option<HirId>,\n+    span_low: Option<Span>,\n+    span_high: Option<Span>,\n+}\n+\n+impl<'tcx> Delegate<'tcx> for MutatePairDelegate<'_, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId, bk: ty::BorrowKind) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            if let PlaceBase::Local(id) = cmt.place.base {\n+                if Some(id) == self.hir_id_low {\n+                    self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                }\n+                if Some(id) == self.hir_id_high {\n+                    self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>, diag_expr_id: HirId) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n+            if Some(id) == self.hir_id_low {\n+                self.span_low = Some(self.cx.tcx.hir().span(diag_expr_id))\n+            }\n+            if Some(id) == self.hir_id_high {\n+                self.span_high = Some(self.cx.tcx.hir().span(diag_expr_id))\n+            }\n+        }\n+    }\n+}\n+\n+impl MutatePairDelegate<'_, '_> {\n+    fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n+        (self.span_low, self.span_high)\n+    }\n+}"}, {"sha": "92560c806295ccc01e9397f6f244637a920d60c3", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,283 @@\n+use super::NEEDLESS_COLLECT;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, match_type, path_to_local_id, paths, snippet, span_lint_and_sugg,\n+    span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Expr, ExprKind, GenericArg, HirId, Local, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::{sym, Ident};\n+\n+const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n+\n+pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n+        if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n+        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+        then {\n+            let ty = cx.typeck_results().node_type(ty.hir_id);\n+            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n+                match_type(cx, ty, &paths::BTREEMAP) ||\n+                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n+                if method.ident.name == sym!(len) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"count()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(is_empty) {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        \"next().is_none()\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                if method.ident.name == sym!(contains) {\n+                    let contains_arg = snippet(cx, args[1].span, \"??\");\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        span,\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let (arg, pred) = contains_arg\n+                                    .strip_prefix('&')\n+                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                            diag.span_suggestion(\n+                                span,\n+                                \"replace with\",\n+                                format!(\n+                                    \"any(|{}| x == {})\",\n+                                    arg, pred\n+                                ),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    let mut used_count_visitor = UsedCountVisitor {\n+                        cx,\n+                        id: *pat_id,\n+                        count: 0,\n+                    };\n+                    walk_block(&mut used_count_visitor, block);\n+                    if used_count_visitor.count > 1 {\n+                        return;\n+                    }\n+\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        super::NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => {\n+                let s = snippet(cx, *span, \"..\");\n+                if let Some(stripped) = s.strip_prefix('&') {\n+                    format!(\".any(|x| x == {})\", stripped)\n+                } else {\n+                    format!(\".any(|x| x == *{})\", s)\n+                }\n+            },\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct UsedCountVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    id: HirId,\n+    count: usize,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if path_to_local_id(expr, self.id) {\n+            self.count += 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+/// Detect the occurrences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other { None } else { Some(visitor.uses) }\n+}\n+\n+fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n+    if_chain! {\n+        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n+        then {\n+            return expr.span.with_lo(span.lo());\n+        }\n+    }\n+    unreachable!();\n+}"}, {"sha": "5f02e4b9d875dd907844c962459487fb500dfa65", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,391 @@\n+use super::NEEDLESS_RANGE_LOOP;\n+use crate::utils::visitors::LocalUsedVisitor;\n+use crate::utils::{\n+    contains_name, has_iter_method, higher, is_integer_const, match_trait_method, multispan_sugg, path_to_local_id,\n+    paths, snippet, span_lint_and_then, sugg, SpanlessEq,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::symbol::{sym, Symbol};\n+use std::iter::Iterator;\n+use std::mem;\n+\n+/// Checks for looping over a range and then indexing a sequence with it.\n+/// The iteratee must be a range literal.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if let Some(higher::Range {\n+        start: Some(start),\n+        ref end,\n+        limits,\n+    }) = higher::range(arg)\n+    {\n+        // the var must be a single name\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {\n+            let mut visitor = VarVisitor {\n+                cx,\n+                var: canonical_id,\n+                indexed_mut: FxHashSet::default(),\n+                indexed_indirectly: FxHashMap::default(),\n+                indexed_directly: FxHashMap::default(),\n+                referenced: FxHashSet::default(),\n+                nonindex: false,\n+                prefer_mutable: false,\n+            };\n+            walk_expr(&mut visitor, body);\n+\n+            // linting condition: we only indexed one variable, and indexed it directly\n+            if visitor.indexed_indirectly.is_empty() && visitor.indexed_directly.len() == 1 {\n+                let (indexed, (indexed_extent, indexed_ty)) = visitor\n+                    .indexed_directly\n+                    .into_iter()\n+                    .next()\n+                    .expect(\"already checked that we have exactly 1 element\");\n+\n+                // ensure that the indexed variable was declared before the loop, see #601\n+                if let Some(indexed_extent) = indexed_extent {\n+                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n+                        return;\n+                    }\n+                }\n+\n+                // don't lint if the container that is indexed does not have .iter() method\n+                let has_iter = has_iter_method(cx, indexed_ty);\n+                if has_iter.is_none() {\n+                    return;\n+                }\n+\n+                // don't lint if the container that is indexed into is also used without\n+                // indexing\n+                if visitor.referenced.contains(&indexed) {\n+                    return;\n+                }\n+\n+                let starts_at_zero = is_integer_const(cx, start, 0);\n+\n+                let skip = if starts_at_zero {\n+                    String::new()\n+                } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, start) {\n+                    return;\n+                } else {\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n+                };\n+\n+                let mut end_is_start_plus_val = false;\n+\n+                let take = if let Some(end) = *end {\n+                    let mut take_expr = end;\n+\n+                    if let ExprKind::Binary(ref op, ref left, ref right) = end.kind {\n+                        if let BinOpKind::Add = op.node {\n+                            let start_equal_left = SpanlessEq::new(cx).eq_expr(start, left);\n+                            let start_equal_right = SpanlessEq::new(cx).eq_expr(start, right);\n+\n+                            if start_equal_left {\n+                                take_expr = right;\n+                            } else if start_equal_right {\n+                                take_expr = left;\n+                            }\n+\n+                            end_is_start_plus_val = start_equal_left | start_equal_right;\n+                        }\n+                    }\n+\n+                    if is_len_call(end, indexed) || is_end_eq_array_len(cx, end, limits, indexed_ty) {\n+                        String::new()\n+                    } else if visitor.indexed_mut.contains(&indexed) && contains_name(indexed, take_expr) {\n+                        return;\n+                    } else {\n+                        match limits {\n+                            ast::RangeLimits::Closed => {\n+                                let take_expr = sugg::Sugg::hir(cx, take_expr, \"<count>\");\n+                                format!(\".take({})\", take_expr + sugg::ONE)\n+                            },\n+                            ast::RangeLimits::HalfOpen => format!(\".take({})\", snippet(cx, take_expr.span, \"..\")),\n+                        }\n+                    }\n+                } else {\n+                    String::new()\n+                };\n+\n+                let (ref_mut, method) = if visitor.indexed_mut.contains(&indexed) {\n+                    (\"mut \", \"iter_mut\")\n+                } else {\n+                    (\"\", \"iter\")\n+                };\n+\n+                let take_is_empty = take.is_empty();\n+                let mut method_1 = take;\n+                let mut method_2 = skip;\n+\n+                if end_is_start_plus_val {\n+                    mem::swap(&mut method_1, &mut method_2);\n+                }\n+\n+                if visitor.nonindex {\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![\n+                                    (pat.span, format!(\"({}, <item>)\", ident.name)),\n+                                    (\n+                                        arg.span,\n+                                        format!(\"{}.{}().enumerate(){}{}\", indexed, method, method_1, method_2),\n+                                    ),\n+                                ],\n+                            );\n+                        },\n+                    );\n+                } else {\n+                    let repl = if starts_at_zero && take_is_empty {\n+                        format!(\"&{}{}\", ref_mut, indexed)\n+                    } else {\n+                        format!(\"{}.{}(){}{}\", indexed, method, method_1, method_2)\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_RANGE_LOOP,\n+                        expr.span,\n+                        &format!(\"the loop variable `{}` is only used to index `{}`\", ident.name, indexed),\n+                        |diag| {\n+                            multispan_sugg(\n+                                diag,\n+                                \"consider using an iterator\",\n+                                vec![(pat.span, \"<item>\".to_string()), (arg.span, repl)],\n+                            );\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n+        if len_args.len() == 1;\n+        if method.ident.name == sym!(len);\n+        if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n+        if path.segments.len() == 1;\n+        if path.segments[0].ident.name == var;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn is_end_eq_array_len<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    end: &Expr<'_>,\n+    limits: ast::RangeLimits,\n+    indexed_ty: Ty<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = end.kind;\n+        if let ast::LitKind::Int(end_int, _) = lit.node;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n+        if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n+        then {\n+            return match limits {\n+                ast::RangeLimits::Closed => end_int + 1 >= arr_len.into(),\n+                ast::RangeLimits::HalfOpen => end_int >= arr_len.into(),\n+            };\n+        }\n+    }\n+\n+    false\n+}\n+\n+struct VarVisitor<'a, 'tcx> {\n+    /// context reference\n+    cx: &'a LateContext<'tcx>,\n+    /// var name to look for as index\n+    var: HirId,\n+    /// indexed variables that are used mutably\n+    indexed_mut: FxHashSet<Symbol>,\n+    /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n+    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n+    /// subset of `indexed` of vars that are indexed directly: `v[i]`\n+    /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n+    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n+    /// Any names that are used outside an index operation.\n+    /// Used to detect things like `&mut vec` used together with `vec[i]`\n+    referenced: FxHashSet<Symbol>,\n+    /// has the loop variable been used in expressions other than the index of\n+    /// an index op?\n+    nonindex: bool,\n+    /// Whether we are inside the `$` in `&mut $` or `$ = foo` or `$.bar`, where bar\n+    /// takes `&mut self`\n+    prefer_mutable: bool,\n+}\n+\n+impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n+    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+        if_chain! {\n+            // the indexed container is referenced by a name\n+            if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n+            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if seqvar.segments.len() == 1;\n+            then {\n+                let index_used_directly = path_to_local_id(idx, self.var);\n+                let indexed_indirectly = {\n+                    let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n+                    walk_expr(&mut used_visitor, idx);\n+                    used_visitor.used\n+                };\n+\n+                if indexed_indirectly || index_used_directly {\n+                    if self.prefer_mutable {\n+                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                    }\n+                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n+                    match res {\n+                        Res::Local(hir_id) => {\n+                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                            if indexed_indirectly {\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n+                            }\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(\n+                                    seqvar.segments[0].ident.name,\n+                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                                );\n+                            }\n+                            return false;  // no need to walk further *on the variable*\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        }\n+        true\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            // a range index op\n+            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n+            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if !self.check(&args[1], &args[0], expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // an index op\n+            if let ExprKind::Index(ref seqexpr, ref idx) = expr.kind;\n+            if !self.check(idx, seqexpr, expr);\n+            then { return }\n+        }\n+\n+        if_chain! {\n+            // directly using a variable\n+            if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind;\n+            if let Res::Local(local_id) = path.res;\n+            then {\n+                if local_id == self.var {\n+                    self.nonindex = true;\n+                } else {\n+                    // not the correct variable, but still a variable\n+                    self.referenced.insert(path.segments[0].ident.name);\n+                }\n+            }\n+        }\n+\n+        let old = self.prefer_mutable;\n+        match expr.kind {\n+            ExprKind::AssignOp(_, ref lhs, ref rhs) | ExprKind::Assign(ref lhs, ref rhs, _) => {\n+                self.prefer_mutable = true;\n+                self.visit_expr(lhs);\n+                self.prefer_mutable = false;\n+                self.visit_expr(rhs);\n+            },\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, ref expr) => {\n+                if mutbl == Mutability::Mut {\n+                    self.prefer_mutable = true;\n+                }\n+                self.visit_expr(expr);\n+            },\n+            ExprKind::Call(ref f, args) => {\n+                self.visit_expr(f);\n+                for expr in args {\n+                    let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n+                for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n+                    self.prefer_mutable = false;\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n+                        if mutbl == Mutability::Mut {\n+                            self.prefer_mutable = true;\n+                        }\n+                    }\n+                    self.visit_expr(expr);\n+                }\n+            },\n+            ExprKind::Closure(_, _, body_id, ..) => {\n+                let body = self.cx.tcx.hir().body(body_id);\n+                self.visit_expr(&body.value);\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+        self.prefer_mutable = old;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "45e1001d755550399697dcaa064dcb0b5a5d60a8", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,172 @@\n+use super::NEVER_LOOP;\n+use crate::utils::span_lint;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use std::iter::{once, Iterator};\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Loop(ref block, _, _, _) = expr.kind {\n+        match never_loop_block(block, expr.hir_id) {\n+            NeverLoopResult::AlwaysBreak => span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n+            NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n+        }\n+    }\n+}\n+\n+enum NeverLoopResult {\n+    // A break/return always get triggered but not necessarily for the main loop.\n+    AlwaysBreak,\n+    // A continue may occur for the main loop.\n+    MayContinueMainLoop,\n+    Otherwise,\n+}\n+\n+#[must_use]\n+fn absorb_break(arg: &NeverLoopResult) -> NeverLoopResult {\n+    match *arg {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::Otherwise => NeverLoopResult::Otherwise,\n+        NeverLoopResult::MayContinueMainLoop => NeverLoopResult::MayContinueMainLoop,\n+    }\n+}\n+\n+// Combine two results for parts that are called in order.\n+#[must_use]\n+fn combine_seq(first: NeverLoopResult, second: NeverLoopResult) -> NeverLoopResult {\n+    match first {\n+        NeverLoopResult::AlwaysBreak | NeverLoopResult::MayContinueMainLoop => first,\n+        NeverLoopResult::Otherwise => second,\n+    }\n+}\n+\n+// Combine two results where both parts are called but not necessarily in order.\n+#[must_use]\n+fn combine_both(left: NeverLoopResult, right: NeverLoopResult) -> NeverLoopResult {\n+    match (left, right) {\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::AlwaysBreak, _) | (_, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::Otherwise, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+// Combine two results where only one of the part may have been executed.\n+#[must_use]\n+fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult {\n+    match (b1, b2) {\n+        (NeverLoopResult::AlwaysBreak, NeverLoopResult::AlwaysBreak) => NeverLoopResult::AlwaysBreak,\n+        (NeverLoopResult::MayContinueMainLoop, _) | (_, NeverLoopResult::MayContinueMainLoop) => {\n+            NeverLoopResult::MayContinueMainLoop\n+        },\n+        (NeverLoopResult::Otherwise, _) | (_, NeverLoopResult::Otherwise) => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    let stmts = block.stmts.iter().map(stmt_to_expr);\n+    let expr = once(block.expr.as_deref());\n+    let mut iter = stmts.chain(expr).flatten();\n+    never_loop_expr_seq(&mut iter, main_loop_id)\n+}\n+\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_seq)\n+}\n+\n+fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n+        StmtKind::Local(ref local) => local.init.as_deref(),\n+        _ => None,\n+    }\n+}\n+\n+fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+    match expr.kind {\n+        ExprKind::Box(ref e)\n+        | ExprKind::Unary(_, ref e)\n+        | ExprKind::Cast(ref e, _)\n+        | ExprKind::Type(ref e, _)\n+        | ExprKind::Field(ref e, _)\n+        | ExprKind::AddrOf(_, _, ref e)\n+        | ExprKind::Struct(_, _, Some(ref e))\n+        | ExprKind::Repeat(ref e, _)\n+        | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n+            never_loop_expr_all(&mut es.iter(), main_loop_id)\n+        },\n+        ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n+        ExprKind::Binary(_, ref e1, ref e2)\n+        | ExprKind::Assign(ref e1, ref e2, _)\n+        | ExprKind::AssignOp(_, ref e1, ref e2)\n+        | ExprKind::Index(ref e1, ref e2) => never_loop_expr_all(&mut [&**e1, &**e2].iter().cloned(), main_loop_id),\n+        ExprKind::Loop(ref b, _, _, _) => {\n+            // Break can come from the inner loop so remove them.\n+            absorb_break(&never_loop_block(b, main_loop_id))\n+        },\n+        ExprKind::If(ref e, ref e2, ref e3) => {\n+            let e1 = never_loop_expr(e, main_loop_id);\n+            let e2 = never_loop_expr(e2, main_loop_id);\n+            let e3 = e3\n+                .as_ref()\n+                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            combine_seq(e1, combine_branches(e2, e3))\n+        },\n+        ExprKind::Match(ref e, ref arms, _) => {\n+            let e = never_loop_expr(e, main_loop_id);\n+            if arms.is_empty() {\n+                e\n+            } else {\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| &*a.body), main_loop_id);\n+                combine_seq(e, arms)\n+            }\n+        },\n+        ExprKind::Block(ref b, _) => never_loop_block(b, main_loop_id),\n+        ExprKind::Continue(d) => {\n+            let id = d\n+                .target_id\n+                .expect(\"target ID can only be missing in the presence of compilation errors\");\n+            if id == main_loop_id {\n+                NeverLoopResult::MayContinueMainLoop\n+            } else {\n+                NeverLoopResult::AlwaysBreak\n+            }\n+        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n+        ExprKind::InlineAsm(ref asm) => asm\n+            .operands\n+            .iter()\n+            .map(|(o, _)| match o {\n+                InlineAsmOperand::In { expr, .. }\n+                | InlineAsmOperand::InOut { expr, .. }\n+                | InlineAsmOperand::Const { expr }\n+                | InlineAsmOperand::Sym { expr } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)\n+                },\n+            })\n+            .fold(NeverLoopResult::Otherwise, combine_both),\n+        ExprKind::Struct(_, _, None)\n+        | ExprKind::Yield(_, _)\n+        | ExprKind::Closure(_, _, _, _, _)\n+        | ExprKind::LlvmInlineAsm(_)\n+        | ExprKind::Path(_)\n+        | ExprKind::ConstBlock(_)\n+        | ExprKind::Lit(_)\n+        | ExprKind::Err => NeverLoopResult::Otherwise,\n+    }\n+}\n+\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::Otherwise, combine_both)\n+}\n+\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, main_loop_id))\n+        .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n+}"}, {"sha": "f3585830e4ae3189651ff15f0d11aef5c2405ee5", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,169 @@\n+use super::SAME_ITEM_PUSH;\n+use crate::utils::{implements_trait, is_type_diagnostic_item, snippet_with_macro_callsite, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::symbol::sym;\n+use std::iter::Iterator;\n+\n+/// Detects for loop pushing the same item into a Vec\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    _: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    _: &'tcx Expr<'_>,\n+) {\n+    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n+        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+\n+        span_lint_and_help(\n+            cx,\n+            SAME_ITEM_PUSH,\n+            vec.span,\n+            \"it looks like the same item is being pushed into this Vec\",\n+            None,\n+            &format!(\n+                \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                item_str, vec_str, item_str\n+            ),\n+        )\n+    }\n+\n+    if !matches!(pat.kind, PatKind::Wild) {\n+        return;\n+    }\n+\n+    // Determine whether it is safe to lint the body\n+    let mut same_item_push_visitor = SameItemPushVisitor {\n+        should_lint: true,\n+        vec_push: None,\n+        cx,\n+    };\n+    walk_expr(&mut same_item_push_visitor, body);\n+    if same_item_push_visitor.should_lint {\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n+            let vec_ty = cx.typeck_results().expr_ty(vec);\n+            let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+            if cx\n+                .tcx\n+                .lang_items()\n+                .clone_trait()\n+                .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+            {\n+                // Make sure that the push does not involve possibly mutating values\n+                match pushed_item.kind {\n+                    ExprKind::Path(ref qpath) => {\n+                        match cx.qpath_res(qpath, pushed_item.hir_id) {\n+                            // immutable bindings that are initialized with literal or constant\n+                            Res::Local(hir_id) => {\n+                                if_chain! {\n+                                    let node = cx.tcx.hir().get(hir_id);\n+                                    if let Node::Binding(pat) = node;\n+                                    if let PatKind::Binding(bind_ann, ..) = pat.kind;\n+                                    if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);\n+                                    let parent_node = cx.tcx.hir().get_parent_node(hir_id);\n+                                    if let Some(Node::Local(parent_let_expr)) = cx.tcx.hir().find(parent_node);\n+                                    if let Some(init) = parent_let_expr.init;\n+                                    then {\n+                                        match init.kind {\n+                                            // immutable bindings that are initialized with literal\n+                                            ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                            // immutable bindings that are initialized with constant\n+                                            ExprKind::Path(ref path) => {\n+                                                if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n+                                                    emit_lint(cx, vec, pushed_item);\n+                                                }\n+                                            }\n+                                            _ => {},\n+                                        }\n+                                    }\n+                                }\n+                            },\n+                            // constant\n+                            Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                            _ => {},\n+                        }\n+                    },\n+                    ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Scans the body of the for loop and determines whether lint should be given\n+struct SameItemPushVisitor<'a, 'tcx> {\n+    should_lint: bool,\n+    // this field holds the last vec push operation visited, which should be the only push seen\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            // Non-determinism may occur ... don't give a lint\n+            ExprKind::Loop(..) | ExprKind::Match(..) => self.should_lint = false,\n+            ExprKind::Block(block, _) => self.visit_block(block),\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+        for stmt in b.stmts.iter() {\n+            self.visit_stmt(stmt);\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n+        let vec_push_option = get_vec_push(self.cx, s);\n+        if vec_push_option.is_none() {\n+            // Current statement is not a push so visit inside\n+            match &s.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                _ => {},\n+            }\n+        } else {\n+            // Current statement is a push ...check whether another\n+            // push had been previously done\n+            if self.vec_push.is_none() {\n+                self.vec_push = vec_push_option;\n+            } else {\n+                // There are multiple pushes ... don't lint\n+                self.should_lint = false;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Given some statement, determine if that statement is a push on a Vec. If it is, return\n+// the Vec being pushed into and the item being pushed\n+fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+            // Extract method being called\n+            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            // Figure out the parameters for the method call\n+            if let Some(self_expr) = args.get(0);\n+            if let Some(pushed_item) = args.get(1);\n+            // Check that the method being called is push() on a Vec\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::vec_type);\n+            if path.ident.name.as_str() == \"push\";\n+            then {\n+                return Some((self_expr, pushed_item))\n+            }\n+    }\n+    None\n+}"}, {"sha": "38400c93c9ab205d1a9f6eeb8e63b279e9792122", "filename": "clippy_lints/src/loops/single_element_loop.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,42 @@\n+use super::{get_span_of_entire_for_loop, SINGLE_ELEMENT_LOOP};\n+use crate::utils::{indent_of, single_segment_path, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    if_chain! {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, _, ref arg_expr) = arg.kind;\n+        if let PatKind::Binding(.., target, _) = pat.kind;\n+        if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n+        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n+        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n+        if let ExprKind::Block(ref block, _) = body.kind;\n+        if !block.stmts.is_empty();\n+\n+        then {\n+            let for_span = get_span_of_entire_for_loop(expr);\n+            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            block_str.remove(0);\n+            block_str.pop();\n+\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SINGLE_ELEMENT_LOOP,\n+                for_span,\n+                \"for loop over a single element\",\n+                \"try\",\n+                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n+                Applicability::MachineApplicable\n+            )\n+        }\n+    }\n+}"}, {"sha": "9e38e17719aad116846c252a97d1c9bd00bb89bc", "filename": "clippy_lints/src/loops/utils.rs", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,350 @@\n+use crate::utils::{\n+    get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, is_integer_const, path_to_local,\n+    path_to_local_id, paths, sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n+use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Stmt, StmtKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+use std::iter::Iterator;\n+\n+#[derive(Debug, PartialEq)]\n+enum IncrementVisitorVarState {\n+    Initial,  // Not examined yet\n+    IncrOnce, // Incremented exactly once, may be a loop counter\n+    DontWarn,\n+}\n+\n+/// Scan a for loop for variables that are incremented exactly once and not used after that.\n+pub(super) struct IncrementVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,                          // context reference\n+    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                         // depth of conditional expressions\n+    done: bool,\n+}\n+\n+impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            states: FxHashMap::default(),\n+            depth: 0,\n+            done: false,\n+        }\n+    }\n+\n+    pub(super) fn into_results(self) -> impl Iterator<Item = HirId> {\n+        self.states.into_iter().filter_map(|(id, state)| {\n+            if state == IncrementVisitorVarState::IncrOnce {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.done {\n+            return;\n+        }\n+\n+        // If node is a variable\n+        if let Some(def_id) = path_to_local(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n+                if *state == IncrementVisitorVarState::IncrOnce {\n+                    *state = IncrementVisitorVarState::DontWarn;\n+                    return;\n+                }\n+\n+                match parent.kind {\n+                    ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                        if lhs.hir_id == expr.hir_id {\n+                            *state = if op.node == BinOpKind::Add\n+                                && is_integer_const(self.cx, rhs, 1)\n+                                && *state == IncrementVisitorVarState::Initial\n+                                && self.depth == 0\n+                            {\n+                                IncrementVisitorVarState::IncrOnce\n+                            } else {\n+                                // Assigned some other value or assigned multiple times\n+                                IncrementVisitorVarState::DontWarn\n+                            };\n+                        }\n+                    },\n+                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if is_loop(expr) || is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else if let ExprKind::Continue(_) = expr.kind {\n+            self.done = true;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+enum InitializeVisitorState<'hir> {\n+    Initial,          // Not examined yet\n+    Declared(Symbol), // Declared but not (yet) initialized\n+    Initialized {\n+        name: Symbol,\n+        initializer: &'hir Expr<'hir>,\n+    },\n+    DontWarn,\n+}\n+\n+/// Checks whether a variable is initialized at the start of a loop and not modified\n+/// and used after the loop.\n+pub(super) struct InitializeVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,  // context reference\n+    end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n+    var_id: HirId,\n+    state: InitializeVisitorState<'tcx>,\n+    depth: u32, // depth of conditional expressions\n+    past_loop: bool,\n+}\n+\n+impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n+    pub(super) fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            end_expr,\n+            var_id,\n+            state: InitializeVisitorState::Initial,\n+            depth: 0,\n+            past_loop: false,\n+        }\n+    }\n+\n+    pub(super) fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n+            Some((name, initializer))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        // Look for declarations of the variable\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if local.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            then {\n+                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                    InitializeVisitorState::Initialized {\n+                        initializer: init,\n+                        name: ident.name,\n+                    }\n+                })\n+            }\n+        }\n+        walk_stmt(self, stmt);\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if matches!(self.state, InitializeVisitorState::DontWarn) {\n+            return;\n+        }\n+        if expr.hir_id == self.end_expr.hir_id {\n+            self.past_loop = true;\n+            return;\n+        }\n+        // No need to visit expressions before the variable is\n+        // declared\n+        if matches!(self.state, InitializeVisitorState::Initial) {\n+            return;\n+        }\n+\n+        // If node is the desired variable, see how it's used\n+        if path_to_local_id(expr, self.var_id) {\n+            if self.past_loop {\n+                self.state = InitializeVisitorState::DontWarn;\n+                return;\n+            }\n+\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = InitializeVisitorState::DontWarn;\n+                    },\n+                    ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n+                        self.state = if_chain! {\n+                            if self.depth == 0;\n+                            if let InitializeVisitorState::Declared(name)\n+                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n+                            then {\n+                                InitializeVisitorState::Initialized { initializer: rhs, name }\n+                            } else {\n+                                InitializeVisitorState::DontWarn\n+                            }\n+                        }\n+                    },\n+                    ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n+                        self.state = InitializeVisitorState::DontWarn\n+                    },\n+                    _ => (),\n+                }\n+            }\n+\n+            walk_expr(self, expr);\n+        } else if !self.past_loop && is_loop(expr) {\n+            self.state = InitializeVisitorState::DontWarn;\n+        } else if is_conditional(expr) {\n+            self.depth += 1;\n+            walk_expr(self, expr);\n+            self.depth -= 1;\n+        } else {\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+}\n+\n+fn is_loop(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Loop(..))\n+}\n+\n+fn is_conditional(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::If(..) | ExprKind::Match(..))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub(super) enum Nesting {\n+    Unknown,     // no nesting detected yet\n+    RuledOut,    // the iterator is initialized or assigned within scope\n+    LookFurther, // no nesting detected, no further walk required\n+}\n+\n+use self::Nesting::{LookFurther, RuledOut, Unknown};\n+\n+pub(super) struct LoopNestVisitor {\n+    pub(super) hir_id: HirId,\n+    pub(super) iterator: HirId,\n+    pub(super) nesting: Nesting,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n+        if stmt.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+        } else if self.nesting == Unknown {\n+            walk_stmt(self, stmt);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if expr.hir_id == self.hir_id {\n+            self.nesting = LookFurther;\n+            return;\n+        }\n+        match expr.kind {\n+            ExprKind::Assign(ref path, _, _) | ExprKind::AssignOp(_, ref path, _) => {\n+                if path_to_local_id(path, self.iterator) {\n+                    self.nesting = RuledOut;\n+                }\n+            },\n+            _ => walk_expr(self, expr),\n+        }\n+    }\n+\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'_>) {\n+        if self.nesting != Unknown {\n+            return;\n+        }\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n+            if id == self.iterator {\n+                self.nesting = RuledOut;\n+                return;\n+            }\n+        }\n+        walk_pat(self, pat)\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// this function assumes the given expression is a `for` loop.\n+pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n+    // for some reason this is the only way to get the `Span`\n+    // of the entire `for` loop\n+    if let ExprKind::Match(_, arms, _) = &expr.kind {\n+        arms[0].body.span\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n+/// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n+/// actual `Iterator` that the loop uses.\n+pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n+    let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR).map_or(false, |id| {\n+        implements_trait(cx, cx.typeck_results().expr_ty(arg), id, &[])\n+    });\n+    if impls_iterator {\n+        format!(\n+            \"{}\",\n+            sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+        )\n+    } else {\n+        // (&x).into_iter() ==> x.iter()\n+        // (&mut x).into_iter() ==> x.iter_mut()\n+        match &arg.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n+                if has_iter_method(cx, cx.typeck_results().expr_ty(&arg_inner)).is_some() =>\n+            {\n+                let meth_name = match mutability {\n+                    Mutability::Mut => \"iter_mut\",\n+                    Mutability::Not => \"iter\",\n+                };\n+                format!(\n+                    \"{}.{}()\",\n+                    sugg::Sugg::hir_with_applicability(cx, &arg_inner, \"_\", applic_ref).maybe_par(),\n+                    meth_name,\n+                )\n+            }\n+            _ => format!(\n+                \"{}.into_iter()\",\n+                sugg::Sugg::hir_with_applicability(cx, arg, \"_\", applic_ref).maybe_par()\n+            ),\n+        }\n+    }\n+}"}, {"sha": "05e0a7225631c5421b602d06e63c443acf3130f4", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,139 @@\n+use super::WHILE_IMMUTABLE_CONDITION;\n+use crate::consts::constant;\n+use crate::utils::span_lint_and_then;\n+use crate::utils::usage::mutated_variables;\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id, Expr, ExprKind, HirId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use std::iter::Iterator;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n+    if constant(cx, cx.typeck_results(), cond).is_some() {\n+        // A pure constant condition (e.g., `while false`) is not linted.\n+        return;\n+    }\n+\n+    let mut var_visitor = VarCollectorVisitor {\n+        cx,\n+        ids: FxHashSet::default(),\n+        def_ids: FxHashMap::default(),\n+        skip: false,\n+    };\n+    var_visitor.visit_expr(cond);\n+    if var_visitor.skip {\n+        return;\n+    }\n+    let used_in_condition = &var_visitor.ids;\n+    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n+        used_in_condition.is_disjoint(&used_mutably)\n+    } else {\n+        return;\n+    };\n+    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+\n+    let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n+        has_break_or_return: false,\n+    };\n+    has_break_or_return_visitor.visit_expr(expr);\n+    let has_break_or_return = has_break_or_return_visitor.has_break_or_return;\n+\n+    if no_cond_variable_mutated && !mutable_static_in_cond {\n+        span_lint_and_then(\n+            cx,\n+            WHILE_IMMUTABLE_CONDITION,\n+            cond.span,\n+            \"variables in the condition are not mutated in the loop body\",\n+            |diag| {\n+                diag.note(\"this may lead to an infinite or to a never running loop\");\n+\n+                if has_break_or_return {\n+                    diag.note(\"this loop contains `return`s or `break`s\");\n+                    diag.help(\"rewrite it as `if cond { loop { } }`\");\n+                }\n+            },\n+        );\n+    }\n+}\n+\n+struct HasBreakOrReturnVisitor {\n+    has_break_or_return: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.has_break_or_return {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Ret(_) | ExprKind::Break(_, _) => {\n+                self.has_break_or_return = true;\n+                return;\n+            },\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Collects the set of variables in an expression\n+/// Stops analysis if a function call is found\n+/// Note: In some cases such as `self`, there are no mutable annotation,\n+/// All variables definition IDs are collected\n+struct VarCollectorVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ids: FxHashSet<HirId>,\n+    def_ids: FxHashMap<def_id::DefId, bool>,\n+    skip: bool,\n+}\n+\n+impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n+    fn insert_def_id(&mut self, ex: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Path(ref qpath) = ex.kind;\n+            if let QPath::Resolved(None, _) = *qpath;\n+            let res = self.cx.qpath_res(qpath, ex.hir_id);\n+            then {\n+                match res {\n+                    Res::Local(hir_id) => {\n+                        self.ids.insert(hir_id);\n+                    },\n+                    Res::Def(DefKind::Static, def_id) => {\n+                        let mutable = self.cx.tcx.is_mutable_static(def_id);\n+                        self.def_ids.insert(def_id, mutable);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        match ex.kind {\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n+            // If there is any function/method call\u2026 we just stop analysis\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n+\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "65d8f2f1111a34fd39051ebfa4511a3a56deb520", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,87 @@\n+use super::WHILE_LET_LOOP;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n+    // extract the expression from the first statement (if any) in a block\n+    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n+    // or extract the first expression (if any) from the block\n+    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n+        if let ExprKind::Match(ref matchexpr, ref arms, ref source) = inner.kind {\n+            // ensure \"if let\" compatible match structure\n+            match *source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n+                    if arms.len() == 2\n+                        && arms[0].guard.is_none()\n+                        && arms[1].guard.is_none()\n+                        && is_simple_break_expr(&arms[1].body)\n+                    {\n+                        if in_external_macro(cx.sess(), expr.span) {\n+                            return;\n+                        }\n+\n+                        // NOTE: we used to build a body here instead of using\n+                        // ellipsis, this was removed because:\n+                        // 1) it was ugly with big bodies;\n+                        // 2) it was not indented properly;\n+                        // 3) it wasn\u2019t very smart (see #675).\n+                        let mut applicability = Applicability::HasPlaceholders;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            WHILE_LET_LOOP,\n+                            expr.span,\n+                            \"this loop could be written as a `while let` loop\",\n+                            \"try\",\n+                            format!(\n+                                \"while let {} = {} {{ .. }}\",\n+                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n+                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n+                            ),\n+                            applicability,\n+                        );\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+}\n+\n+/// If a block begins with a statement (possibly a `let` binding) and has an\n+/// expression, return it.\n+fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    if block.stmts.is_empty() {\n+        return None;\n+    }\n+    if let StmtKind::Local(ref local) = block.stmts[0].kind {\n+        local.init //.map(|expr| expr)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If a block begins with an expression (with or without semicolon), return it.\n+fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    match block.expr {\n+        Some(ref expr) if block.stmts.is_empty() => Some(expr),\n+        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => Some(expr),\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns `true` if expr contains a single break expr without destination label\n+/// and\n+/// passed expression. The expression may be within a block.\n+fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n+        ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n+        _ => false,\n+    }\n+}"}, {"sha": "e5a47694faa4e79bbaeeba86a1d750980c2b8a69", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,171 @@\n+use super::utils::{LoopNestVisitor, Nesting};\n+use super::WHILE_LET_ON_ITERATOR;\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{\n+    get_enclosing_block, get_trait_def_id, implements_trait, is_refutable, last_path_segment, match_trait_method,\n+    path_to_local, path_to_local_id, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Expr, ExprKind, HirId, MatchSource, Node, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.kind {\n+        let pat = &arms[0].pat.kind;\n+        if let (\n+            &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n+            &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n+        ) = (pat, &match_expr.kind)\n+        {\n+            let iter_expr = &method_args[0];\n+\n+            // Don't lint when the iterator is recreated on every iteration\n+            if_chain! {\n+                if let ExprKind::MethodCall(..) | ExprKind::Call(..) = iter_expr.kind;\n+                if let Some(iter_def_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+                if implements_trait(cx, cx.typeck_results().expr_ty(iter_expr), iter_def_id, &[]);\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let lhs_constructor = last_path_segment(qpath);\n+            if method_path.ident.name == sym::next\n+                && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                && lhs_constructor.ident.name == sym::Some\n+                && (pat_args.is_empty()\n+                    || !is_refutable(cx, &pat_args[0])\n+                        && !is_used_inside(cx, iter_expr, &arms[0].body)\n+                        && !is_iterator_used_after_while_let(cx, iter_expr)\n+                        && !is_nested(cx, expr, &method_args[0]))\n+            {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let iterator = snippet_with_applicability(cx, method_args[0].span, \"_\", &mut applicability);\n+                let loop_var = if pat_args.is_empty() {\n+                    \"_\".to_string()\n+                } else {\n+                    snippet_with_applicability(cx, pat_args[0].span, \"_\", &mut applicability).into_owned()\n+                };\n+                span_lint_and_sugg(\n+                    cx,\n+                    WHILE_LET_ON_ITERATOR,\n+                    expr.span.with_hi(match_expr.span.hi()),\n+                    \"this loop could be written as a `for` loop\",\n+                    \"try\",\n+                    format!(\"for {} in {}\", loop_var, iterator),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_used_inside<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    if let Some(used_mutably) = mutated_variables(container, cx) {\n+        if used_mutably.contains(&def_id) {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn is_iterator_used_after_while_let<'tcx>(cx: &LateContext<'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n+    let def_id = match path_to_local(iter_expr) {\n+        Some(id) => id,\n+        None => return false,\n+    };\n+    let mut visitor = VarUsedAfterLoopVisitor {\n+        def_id,\n+        iter_expr_id: iter_expr.hir_id,\n+        past_while_let: false,\n+        var_used_after_while_let: false,\n+    };\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n+        walk_block(&mut visitor, enclosing_block);\n+    }\n+    visitor.var_used_after_while_let\n+}\n+\n+fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n+        let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n+        if let Some(Node::Expr(loop_expr)) = cx.tcx.hir().find(parent_node);\n+        then {\n+            return is_loop_nested(cx, loop_expr, iter_expr)\n+        }\n+    }\n+    false\n+}\n+\n+fn is_loop_nested(cx: &LateContext<'_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n+    let mut id = loop_expr.hir_id;\n+    let iter_id = if let Some(id) = path_to_local(iter_expr) {\n+        id\n+    } else {\n+        return true;\n+    };\n+    loop {\n+        let parent = cx.tcx.hir().get_parent_node(id);\n+        if parent == id {\n+            return false;\n+        }\n+        match cx.tcx.hir().find(parent) {\n+            Some(Node::Expr(expr)) => {\n+                if let ExprKind::Loop(..) = expr.kind {\n+                    return true;\n+                };\n+            },\n+            Some(Node::Block(block)) => {\n+                let mut block_visitor = LoopNestVisitor {\n+                    hir_id: id,\n+                    iterator: iter_id,\n+                    nesting: Nesting::Unknown,\n+                };\n+                walk_block(&mut block_visitor, block);\n+                if block_visitor.nesting == Nesting::RuledOut {\n+                    return false;\n+                }\n+            },\n+            Some(Node::Stmt(_)) => (),\n+            _ => {\n+                return false;\n+            },\n+        }\n+        id = parent;\n+    }\n+}\n+\n+struct VarUsedAfterLoopVisitor {\n+    def_id: HirId,\n+    iter_expr_id: HirId,\n+    past_while_let: bool,\n+    var_used_after_while_let: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.past_while_let {\n+            if path_to_local_id(expr, self.def_id) {\n+                self.var_used_after_while_let = true;\n+            }\n+        } else if self.iter_expr_id == expr.hir_id {\n+            self.past_while_let = true;\n+        }\n+        walk_expr(self, expr);\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "ac1d51e1993b481581627a5c5b576954b55a6c81", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 135, "deletions": 71, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -2,17 +2,25 @@ use crate::{\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     matches::MATCH_AS_REF,\n     utils::{\n-        is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths, peel_hir_expr_refs,\n-        peel_mid_ty_refs_is_mutable, snippet_with_applicability, span_lint_and_sugg,\n+        can_partially_move_ty, is_allowed, is_type_diagnostic_item, match_def_path, match_var, paths,\n+        peel_hir_expr_refs, peel_mid_ty_refs_is_mutable, snippet_with_applicability, snippet_with_context,\n+        span_lint_and_sugg,\n     },\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, QPath};\n+use rustc_hir::{\n+    def::Res,\n+    intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n+    Arm, BindingAnnotation, Block, Expr, ExprKind, Mutability, Pat, PatKind, Path, QPath,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{\n+    symbol::{sym, Ident},\n+    SyntaxContext,\n+};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n@@ -52,43 +60,46 @@ impl LateLintPass<'_> for ManualMap {\n         {\n             let (scrutinee_ty, ty_ref_count, ty_mutability) =\n                 peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                || !is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type)\n+            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n             {\n                 return;\n             }\n \n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) =\n-                match (try_parse_pattern(cx, arm1.pat), try_parse_pattern(cx, arm2.pat)) {\n-                    (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                        if is_none_expr(cx, arm1.body) =>\n-                    {\n-                        (arm2.body, pattern, ref_count, false)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, true)\n-                    },\n-                    (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                        if is_none_expr(cx, arm2.body) =>\n-                    {\n-                        (arm1.body, pattern, ref_count, false)\n-                    },\n-                    _ => return,\n-                };\n+            let expr_ctxt = expr.span.ctxt();\n+            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n+                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n+            ) {\n+                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n+                    if is_none_expr(cx, arm1.body) =>\n+                {\n+                    (arm2.body, pattern, ref_count, false)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, true)\n+                },\n+                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n+                    if is_none_expr(cx, arm2.body) =>\n+                {\n+                    (arm1.body, pattern, ref_count, false)\n+                },\n+                _ => return,\n+            };\n \n             // Top level or patterns aren't allowed in closures.\n             if matches!(some_pat.kind, PatKind::Or(_)) {\n                 return;\n             }\n \n-            let some_expr = match get_some_expr(cx, some_expr) {\n+            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n                 Some(expr) => expr,\n                 None => return,\n             };\n@@ -99,6 +110,10 @@ impl LateLintPass<'_> for ManualMap {\n                 return;\n             }\n \n+            if !can_move_expr_to_closure(cx, some_expr) {\n+                return;\n+            }\n+\n             // Determine which binding mode to use.\n             let explicit_ref = some_pat.contains_explicit_ref_binding();\n             let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n@@ -111,47 +126,50 @@ impl LateLintPass<'_> for ManualMap {\n \n             let mut app = Applicability::MachineApplicable;\n \n-            // Remove address-of expressions from the scrutinee. `as_ref` will be called,\n-            // the type is copyable, or the option is being passed by value.\n+            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+            // it's being passed by value.\n             let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let scrutinee_str = snippet_with_applicability(cx, scrutinee.span, \"_\", &mut app);\n-            let scrutinee_str = if expr.precedence().order() < PREC_POSTFIX {\n-                // Parens are needed to chain method calls.\n-                format!(\"({})\", scrutinee_str)\n-            } else {\n-                scrutinee_str.into()\n-            };\n+            let scrutinee_str = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+            let scrutinee_str =\n+                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+                    format!(\"({})\", scrutinee_str)\n+                } else {\n+                    scrutinee_str.into()\n+                };\n \n             let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                if let Some(func) = can_pass_as_func(cx, some_binding, some_expr) {\n-                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                } else {\n-                    if match_var(some_expr, some_binding.name)\n-                        && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                        && binding_ref.is_some()\n-                    {\n-                        return;\n-                    }\n+                match can_pass_as_func(cx, some_binding, some_expr) {\n+                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+                    },\n+                    _ => {\n+                        if match_var(some_expr, some_binding.name)\n+                            && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                            && binding_ref.is_some()\n+                        {\n+                            return;\n+                        }\n \n-                    // `ref` and `ref mut` annotations were handled earlier.\n-                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    format!(\n-                        \"|{}{}| {}\",\n-                        annotation,\n-                        some_binding,\n-                        snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n-                    )\n+                        // `ref` and `ref mut` annotations were handled earlier.\n+                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        format!(\n+                            \"|{}{}| {}\",\n+                            annotation,\n+                            some_binding,\n+                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                        )\n+                    },\n                 }\n             } else if !is_wild_none && explicit_ref.is_none() {\n                 // TODO: handle explicit reference annotations.\n                 format!(\n                     \"|{}| {}\",\n-                    snippet_with_applicability(cx, some_pat.span, \"..\", &mut app),\n-                    snippet_with_applicability(cx, some_expr.span, \"..\", &mut app)\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app),\n+                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n                 )\n             } else {\n                 // Refutable bindings and mixed reference annotations can't be handled by `map`.\n@@ -171,6 +189,51 @@ impl LateLintPass<'_> for ManualMap {\n     }\n }\n \n+// Checks if the expression can be moved into a closure as is.\n+fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        make_closure: bool,\n+    }\n+    impl Visitor<'tcx> for V<'_, 'tcx> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            match e.kind {\n+                ExprKind::Break(..)\n+                | ExprKind::Continue(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Yield(..)\n+                | ExprKind::InlineAsm(_)\n+                | ExprKind::LlvmInlineAsm(_) => {\n+                    self.make_closure = false;\n+                },\n+                // Accessing a field of a local value can only be done if the type isn't\n+                // partially moved.\n+                ExprKind::Field(base_expr, _)\n+                    if matches!(\n+                        base_expr.kind,\n+                        ExprKind::Path(QPath::Resolved(_, Path { res: Res::Local(_), .. }))\n+                    ) && can_partially_move_ty(self.cx, self.cx.typeck_results().expr_ty(base_expr)) =>\n+                {\n+                    // TODO: check if the local has been partially moved. Assume it has for now.\n+                    self.make_closure = false;\n+                    return;\n+                }\n+                _ => (),\n+            };\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    let mut v = V { cx, make_closure: true };\n+    v.visit_expr(expr);\n+    v.make_closure\n+}\n+\n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n@@ -198,11 +261,11 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize) -> Option<OptionPat<'tcx>> {\n+fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n             PatKind::Path(QPath::Resolved(None, path))\n                 if path\n                     .res\n@@ -215,18 +278,19 @@ fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) -> Option<Optio\n                 if path\n                     .res\n                     .opt_def_id()\n-                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME)) =>\n+                    .map_or(false, |id| match_def_path(cx, id, &paths::OPTION_SOME))\n+                    && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat, 0)\n+    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, ctxt: SyntaxContext) -> Option<&'tcx Expr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n         ExprKind::Call(\n@@ -235,7 +299,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             [arg],\n-        ) => {\n+        ) if ctxt == expr.span.ctxt() => {\n             if match_def_path(cx, path.res.opt_def_id()?, &paths::OPTION_SOME) {\n                 Some(arg)\n             } else {\n@@ -249,7 +313,7 @@ fn get_some_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx E\n                 ..\n             },\n             _,\n-        ) => get_some_expr(cx, expr),\n+        ) => get_some_expr(cx, expr, ctxt),\n         _ => None,\n     }\n }"}, {"sha": "4b685c09a0548771101789ac952da24cd873ce25", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -79,7 +79,9 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                             },\n                             hir::ExprKind::MethodCall(ref method, _, [obj], _) => if_chain! {\n                                 if ident_eq(name, obj) && method.ident.name == sym::clone;\n-                                if match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT);\n+                                if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n+                                if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n+                                if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n                                 // no autoderefs\n                                 if !cx.typeck_results().expr_adjustments(obj).iter()\n                                     .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));"}, {"sha": "1d5a6e7fcc53c19c47d517325c5ea99013240fd4", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1173,9 +1173,9 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n                     cx,\n                     WILDCARD_IN_OR_PATTERNS,\n                     arm.pat.span,\n-                    \"wildcard pattern covers any other pattern as it will match anyway.\",\n+                    \"wildcard pattern covers any other pattern as it will match anyway\",\n                     None,\n-                    \"Consider handling `_` separately.\",\n+                    \"consider handling `_` separately\",\n                 );\n             }\n         }"}, {"sha": "5decb81d9f2e26ca461cb3d6f9aa9343341e3adb", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -158,7 +158,7 @@ pub(crate) trait BindInsteadOfMap {\n     }\n \n     /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-    fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n+    fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) -> bool {\n         if !match_type(cx, cx.typeck_results().expr_ty(&args[0]), Self::TYPE_QPATH) {\n             return false;\n         }"}, {"sha": "71a7e195e41cee1cb2163cdf19abe032ba0d6984", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -7,7 +7,7 @@ use rustc_span::sym;\n \n use super::BYTES_NTH;\n \n-pub(super) fn lints<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>]) {\n     if_chain! {\n         if let ExprKind::MethodCall(_, _, ref args, _) = expr.kind;\n         let ty = cx.typeck_results().expr_ty(&iter_args[0]).peel_refs();"}, {"sha": "4a130ed47db15bc00e6f3afc075c963f55a5a75d", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,109 @@\n+use crate::utils::{is_copy, span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use std::iter;\n+\n+use super::CLONE_DOUBLE_REF;\n+use super::CLONE_ON_COPY;\n+\n+/// Checks for the `CLONE_ON_COPY` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n+        if let ty::Ref(_, innermost, _) = inner.kind() {\n+            span_lint_and_then(\n+                cx,\n+                CLONE_DOUBLE_REF,\n+                expr.span,\n+                &format!(\n+                    \"using `clone` on a double-reference; \\\n+                    this will copy the reference of type `{}` instead of cloning the inner type\",\n+                    ty\n+                ),\n+                |diag| {\n+                    if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                        let mut ty = innermost;\n+                        let mut n = 0;\n+                        while let ty::Ref(_, inner, _) = ty.kind() {\n+                            ty = inner;\n+                            n += 1;\n+                        }\n+                        let refs: String = iter::repeat('&').take(n + 1).collect();\n+                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"try dereferencing it\",\n+                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"or try being explicit if you are sure, that you want to clone a reference\",\n+                            explicit,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                },\n+            );\n+            return; // don't report clone_on_copy\n+        }\n+    }\n+\n+    if is_copy(cx, ty) {\n+        let snip;\n+        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n+            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n+            match &cx.tcx.hir().get(parent) {\n+                hir::Node::Expr(parent) => match parent.kind {\n+                    // &*x is a nop, &x.clone() is not\n+                    hir::ExprKind::AddrOf(..) => return,\n+                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n+                        return;\n+                    },\n+\n+                    _ => {},\n+                },\n+                hir::Node::Stmt(stmt) => {\n+                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n+                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n+                            // let ref y = *x borrows x, let ref y = x.clone() does not\n+                            return;\n+                        }\n+                    }\n+                },\n+                _ => {},\n+            }\n+\n+            // x.clone() might have dereferenced x, possibly through Deref impls\n+            if cx.typeck_results().expr_ty(arg) == ty {\n+                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n+            } else {\n+                let deref_count = cx\n+                    .typeck_results()\n+                    .expr_adjustments(arg)\n+                    .iter()\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n+                    .count();\n+                let derefs: String = iter::repeat('*').take(deref_count).collect();\n+                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n+            }\n+        } else {\n+            snip = None;\n+        }\n+        span_lint_and_then(\n+            cx,\n+            CLONE_ON_COPY,\n+            expr.span,\n+            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            |diag| {\n+                if let Some((text, snip)) = snip {\n+                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "3d5a68d69d7d2d9bbc510c70131bfbb215f4eba4", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,36 @@\n+use crate::utils::{is_type_diagnostic_item, match_type, paths, snippet_with_macro_callsite, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CLONE_ON_REF_PTR;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+\n+    if let ty::Adt(_, subst) = obj_ty.kind() {\n+        let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n+            \"Rc\"\n+        } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n+            \"Arc\"\n+        } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n+            \"Weak\"\n+        } else {\n+            return;\n+        };\n+\n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+\n+        span_lint_and_sugg(\n+            cx,\n+            CLONE_ON_REF_PTR,\n+            expr.span,\n+            \"using `.clone()` on a ref-counted pointer\",\n+            \"try this\",\n+            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n+            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n+        );\n+    }\n+}"}, {"sha": "6866e9c652ab37d9c5202f0f95a2e7a62dc0ff38", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,199 @@\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, snippet, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::EXPECT_FUN_CALL;\n+\n+/// Checks for the `EXPECT_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Span, name: &str, args: &[hir::Expr<'_>]) {\n+    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n+    // `&str`\n+    fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n+        let mut arg_root = arg;\n+        loop {\n+            arg_root = match &arg_root.kind {\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n+                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n+                    if call_args.len() == 1\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n+                        && {\n+                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n+                            let base_type = arg_type.peel_refs();\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n+                        }\n+                    {\n+                        &call_args[0]\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                _ => break,\n+            };\n+        }\n+        arg_root\n+    }\n+\n+    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n+    // converted to string.\n+    fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n+        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n+            return false;\n+        }\n+        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n+            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n+                return false;\n+            }\n+        };\n+        true\n+    }\n+\n+    // Check if an expression could have type `&'static str`, knowing that it\n+    // has type `&str` for some lifetime.\n+    fn can_be_static_str(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        match arg.kind {\n+            hir::ExprKind::Lit(_) => true,\n+            hir::ExprKind::Call(fun, _) => {\n+                if let hir::ExprKind::Path(ref p) = fun.kind {\n+                    match cx.qpath_res(p, fun.hir_id) {\n+                        hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n+                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        ),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            },\n+            hir::ExprKind::MethodCall(..) => {\n+                cx.typeck_results()\n+                    .type_dependent_def_id(arg.hir_id)\n+                    .map_or(false, |method_id| {\n+                        matches!(\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        )\n+                    })\n+            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n+            _ => false,\n+        }\n+    }\n+\n+    fn generate_format_arg_snippet(\n+        cx: &LateContext<'_>,\n+        a: &hir::Expr<'_>,\n+        applicability: &mut Applicability,\n+    ) -> Vec<String> {\n+        if_chain! {\n+            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n+\n+            then {\n+                format_arg_expr_tup\n+                    .iter()\n+                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n+                    .collect()\n+            } else {\n+                unreachable!()\n+            }\n+        }\n+    }\n+\n+    fn is_call(node: &hir::ExprKind<'_>) -> bool {\n+        match node {\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n+                is_call(&expr.kind)\n+            },\n+            hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Match(..)\n+            | hir::ExprKind::Block{ .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+        return;\n+    }\n+\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n+        \"||\"\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n+        \"|_|\"\n+    } else {\n+        return;\n+    };\n+\n+    let arg_root = get_arg_root(cx, &args[1]);\n+\n+    let span_replace_word = method_span.with_hi(expr.span.hi());\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    //Special handling for `format!` as arg_root\n+    if_chain! {\n+        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n+        if block.stmts.len() == 1;\n+        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n+        if let Some(arg_root) = &local.init;\n+        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n+        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n+        then {\n+            let fmt_spec = &format_args[0];\n+            let fmt_args = &format_args[1];\n+\n+            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n+\n+            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n+\n+            let sugg = args.join(\", \");\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{}` followed by a function call\", name),\n+                \"try this\",\n+                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+                applicability,\n+            );\n+\n+            return;\n+        }\n+    }\n+\n+    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n+    if requires_to_string(cx, arg_root) {\n+        arg_root_snippet.to_mut().push_str(\".to_string()\");\n+    }\n+\n+    span_lint_and_sugg(\n+        cx,\n+        EXPECT_FUN_CALL,\n+        span_replace_word,\n+        &format!(\"use of `{}` followed by a function call\", name),\n+        \"try this\",\n+        format!(\n+            \"unwrap_or_else({} {{ panic!(\\\"{{}}\\\", {}) }})\",\n+            closure_args, arg_root_snippet\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "90b781bd9d1905015998d3bd7df81bc067ae5008", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,30 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::EXPECT_USED;\n+\n+/// lint use of `expect()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&expect_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((EXPECT_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((EXPECT_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `expect()` on `{}` value\", kind,),\n+            None,\n+            &format!(\"if this value is an `{}`, it will panic\", none_value,),\n+        );\n+    }\n+}"}, {"sha": "b03835f97e634728bf554d2b415f04c17520ccc2", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,39 @@\n+use crate::utils::{get_parent_expr, match_type, paths, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::FILETYPE_IS_FILE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+        return;\n+    }\n+\n+    let span: Span;\n+    let verb: &str;\n+    let lint_unary: &str;\n+    let help_unary: &str;\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let hir::ExprKind::Unary(op, _) = parent.kind;\n+        if op == hir::UnOp::Not;\n+        then {\n+            lint_unary = \"!\";\n+            verb = \"denies\";\n+            help_unary = \"\";\n+            span = parent.span;\n+        } else {\n+            lint_unary = \"\";\n+            verb = \"covers\";\n+            help_unary = \"!\";\n+            span = expr.span;\n+        }\n+    }\n+    let lint_msg = format!(\"`{}FileType::is_file()` only {} regular files\", lint_unary, verb);\n+    let help_msg = format!(\"use `{}FileType::is_dir()` instead\", help_unary);\n+    span_lint_and_help(cx, FILETYPE_IS_FILE, span, &lint_msg, None, &help_msg);\n+}"}, {"sha": "8da867fce515cde5d051ce25b10043bb05f584d5", "filename": "clippy_lints/src/methods/filter_flat_map.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,21 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter().flat_map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n+                    and filtering by returning `iter::empty()`\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "f559160004cb1f56ad61fb21a5aa4a427c7e2b36", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,85 @@\n+use crate::utils::{match_trait_method, path_to_local_id, paths, snippet, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::symbol::sym;\n+\n+use super::MANUAL_FILTER_MAP;\n+use super::MANUAL_FIND_MAP;\n+\n+/// lint use of `filter().map()` or `find().map()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n+        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n+        if match_trait_method(cx, map_recv, &paths::ITERATOR);\n+\n+        // filter(|x| ...is_some())...\n+        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n+        let filter_body = cx.tcx.hir().body(filter_body_id);\n+        if let [filter_param] = filter_body.params;\n+        // optional ref pattern: `filter(|&x| ..)`\n+        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+            (ref_pat, true)\n+        } else {\n+            (filter_param.pat, false)\n+        };\n+        // closure ends with is_some() or is_ok()\n+        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n+        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n+            Some(false)\n+        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n+            Some(true)\n+        } else {\n+            None\n+        };\n+        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+\n+        // ...map(|x| ...unwrap())\n+        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n+        let map_body = cx.tcx.hir().body(map_body_id);\n+        if let [map_param] = map_body.params;\n+        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+        // closure ends with expect() or unwrap()\n+        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+\n+        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+            // in `filter(|x| ..)`, replace `*x` with `x`\n+            let a_path = if_chain! {\n+                if !is_filter_param_ref;\n+                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                then { expr_path } else { a }\n+            };\n+            // let the filter closure arg and the map closure arg be equal\n+            if_chain! {\n+                if path_to_local_id(a_path, filter_param_id);\n+                if path_to_local_id(b, map_param_id);\n+                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                then {\n+                    return true;\n+                }\n+            }\n+            false\n+        };\n+        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n+        then {\n+            let span = filter_span.to(map_span);\n+            let (filter_name, lint) = if is_find {\n+                (\"find\", MANUAL_FIND_MAP)\n+            } else {\n+                (\"filter\", MANUAL_FILTER_MAP)\n+            };\n+            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n+            let to_opt = if is_result { \".ok()\" } else { \"\" };\n+            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n+                snippet(cx, map_arg.span, \"..\"), to_opt);\n+            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+        }\n+    }\n+}"}, {"sha": "a6db138623a8c6e7d5243652d4df89fb25e80b26", "filename": "clippy_lints/src/methods/filter_map_flat_map.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,21 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter_map().flat_map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter_map().flat_map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by calling `.flat_map(..)` \\\n+                    and filtering by returning `iter::empty()`\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "d015b4c7b385e85381ecd8c9876a3a7294c9bf18", "filename": "clippy_lints/src/methods/filter_map_map.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,20 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_MAP;\n+\n+/// lint use of `filter_map().map()` for `Iterators`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n+) {\n+    // lint if caller of `.filter_map().map()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";\n+        let hint = \"this is more succinctly expressed by only calling `.filter_map(..)` instead\";\n+        span_lint_and_help(cx, FILTER_MAP, expr.span, msg, None, hint);\n+    }\n+}"}, {"sha": "a789df922ffdbfb2327419d867438ffbe2466304", "filename": "clippy_lints/src/methods/filter_map_next.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_next.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,40 @@\n+use crate::utils::{match_trait_method, meets_msrv, paths, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+\n+use super::FILTER_MAP_NEXT;\n+\n+const FILTER_MAP_NEXT_MSRV: RustcVersion = RustcVersion::new(1, 30, 0);\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if !meets_msrv(msrv, &FILTER_MAP_NEXT_MSRV) {\n+            return;\n+        }\n+\n+        let msg = \"called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find_map(..)` instead\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                FILTER_MAP_NEXT,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.find_map({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint(cx, FILTER_MAP_NEXT, expr.span, msg);\n+        }\n+    }\n+}"}, {"sha": "81619e73017f26a07892e72bd41a3ac01c9f5698", "filename": "clippy_lints/src/methods/filter_next.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_next.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,31 @@\n+use crate::utils::{match_trait_method, paths, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::FILTER_NEXT;\n+\n+/// lint use of `filter().next()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, filter_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.filter().next()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let msg = \"called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n+                   `.find(..)` instead\";\n+        let filter_snippet = snippet(cx, filter_args[1].span, \"..\");\n+        if filter_snippet.lines().count() <= 1 {\n+            let iter_snippet = snippet(cx, filter_args[0].span, \"..\");\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                FILTER_NEXT,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.find({})\", iter_snippet, filter_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint(cx, FILTER_NEXT, expr.span, msg);\n+        }\n+    }\n+}"}, {"sha": "ce3194f8a2373ef809cacc548beee4938b7ef04f", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,57 @@\n+use crate::utils::{match_qpath, match_trait_method, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::FLAT_MAP_IDENTITY;\n+\n+/// lint use of `flat_map` for `Iterators` where `flatten` would be sufficient\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    flat_map_args: &'tcx [hir::Expr<'_>],\n+    flat_map_span: Span,\n+) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let arg_node = &flat_map_args[1].kind;\n+\n+        let apply_lint = |message: &str| {\n+            span_lint_and_sugg(\n+                cx,\n+                FLAT_MAP_IDENTITY,\n+                flat_map_span.with_hi(expr.span.hi()),\n+                message,\n+                \"try\",\n+                \"flatten()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        };\n+\n+        if_chain! {\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = arg_node;\n+            let body = cx.tcx.hir().body(*body_id);\n+\n+            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = body.value.kind;\n+\n+            if path.segments.len() == 1;\n+            if path.segments[0].ident.name == binding_ident.name;\n+\n+            then {\n+                apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");\n+            }\n+        }\n+\n+        if_chain! {\n+            if let hir::ExprKind::Path(ref qpath) = arg_node;\n+\n+            if match_qpath(qpath, &paths::STD_CONVERT_IDENTITY);\n+\n+            then {\n+                apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "e50d0a3340026d466f521ca5660bbe65c6935405", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,67 @@\n+use crate::utils::{get_trait_def_id, implements_trait, paths, span_lint_and_sugg, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::ty::Ty;\n+\n+use super::FROM_ITER_INSTEAD_OF_COLLECT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n+\n+    if_chain! {\n+        if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n+        if let Some(iter_id) = get_trait_def_id(cx, &paths::ITERATOR);\n+\n+        if implements_trait(cx, ty, from_iter_id, &[]) && implements_trait(cx, arg_ty, iter_id, &[]);\n+        then {\n+            // `expr` implements `FromIterator` trait\n+            let iter_expr = sugg::Sugg::hir(cx, &args[0], \"..\").maybe_par();\n+            let turbofish = extract_turbofish(cx, expr, ty);\n+            let sugg = format!(\"{}.collect::<{}>()\", iter_expr, turbofish);\n+            span_lint_and_sugg(\n+                cx,\n+                FROM_ITER_INSTEAD_OF_COLLECT,\n+                expr.span,\n+                \"usage of `FromIterator::from_iter`\",\n+                \"use `.collect()` instead of `::from_iter()`\",\n+                sugg,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}\n+\n+fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    if_chain! {\n+        let call_site = expr.span.source_callsite();\n+        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n+        let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n+        if let Some((_, elements)) = snippet_split.split_last();\n+\n+        then {\n+            // is there a type specifier? (i.e.: like `<u32>` in `collections::BTreeSet::<u32>::`)\n+            if let Some(type_specifier) = snippet_split.iter().find(|e| e.starts_with('<') && e.ends_with('>')) {\n+                // remove the type specifier from the path elements\n+                let without_ts = elements.iter().filter_map(|e| {\n+                    if e == type_specifier { None } else { Some((*e).to_string()) }\n+                }).collect::<Vec<_>>();\n+                // join and add the type specifier at the end (i.e.: `collections::BTreeSet<u32>`)\n+                format!(\"{}{}\", without_ts.join(\"::\"), type_specifier)\n+            } else {\n+                // type is not explicitly specified so wildcards are needed\n+                // i.e.: 2 wildcards in `std::collections::BTreeMap<&i32, &char>`\n+                let ty_str = ty.to_string();\n+                let start = ty_str.find('<').unwrap_or(0);\n+                let end = ty_str.find('>').unwrap_or_else(|| ty_str.len());\n+                let nb_wildcard = ty_str[start..end].split(',').count();\n+                let wildcards = format!(\"_{}\", \", _\".repeat(nb_wildcard - 1));\n+                format!(\"{}<{}>\", elements.join(\"::\"), wildcards)\n+            }\n+        } else {\n+            ty.to_string()\n+        }\n+    }\n+}"}, {"sha": "e157db2712a9ac143c9475dab5005e7abf215a22", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,84 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{\n+    get_parent_expr, is_type_diagnostic_item, match_type, paths, snippet_with_applicability, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::GET_UNWRAP;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args: &'tcx [hir::Expr<'_>], is_mut: bool) {\n+    // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n+    // because they do not implement `IndexMut`\n+    let mut applicability = Applicability::MachineApplicable;\n+    let expr_ty = cx.typeck_results().expr_ty(&get_args[0]);\n+    let get_args_str = if get_args.len() > 1 {\n+        snippet_with_applicability(cx, get_args[1].span, \"..\", &mut applicability)\n+    } else {\n+        return; // not linting on a .get().unwrap() chain or variant\n+    };\n+    let mut needs_ref;\n+    let caller_type = if derefs_to_slice(cx, &get_args[0], expr_ty).is_some() {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vec_type) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, expr_ty, sym::vecdeque_type) {\n+        needs_ref = get_args_str.parse::<usize>().is_ok();\n+        \"VecDeque\"\n+    } else if !is_mut && is_type_diagnostic_item(cx, expr_ty, sym::hashmap_type) {\n+        needs_ref = true;\n+        \"HashMap\"\n+    } else if !is_mut && match_type(cx, expr_ty, &paths::BTREEMAP) {\n+        needs_ref = true;\n+        \"BTreeMap\"\n+    } else {\n+        return; // caller is not a type that we want to lint\n+    };\n+\n+    let mut span = expr.span;\n+\n+    // Handle the case where the result is immediately dereferenced\n+    // by not requiring ref and pulling the dereference into the\n+    // suggestion.\n+    if_chain! {\n+        if needs_ref;\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let hir::ExprKind::Unary(hir::UnOp::Deref, _) = parent.kind;\n+        then {\n+            needs_ref = false;\n+            span = parent.span;\n+        }\n+    }\n+\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n+    let borrow_str = if !needs_ref {\n+        \"\"\n+    } else if is_mut {\n+        \"&mut \"\n+    } else {\n+        \"&\"\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        GET_UNWRAP,\n+        span,\n+        &format!(\n+            \"called `.get{0}().unwrap()` on a {1}. Using `[]` is more clear and more concise\",\n+            mut_str, caller_type\n+        ),\n+        \"try this\",\n+        format!(\n+            \"{}{}[{}]\",\n+            borrow_str,\n+            snippet_with_applicability(cx, get_args[0].span, \"..\", &mut applicability),\n+            get_args_str\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "a769493d11d3f7f6d9424730b0b5e27cbe80dd44", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,32 @@\n+use crate::utils::span_lint_and_sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::ExprKind;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::symbol::Symbol;\n+\n+use super::IMPLICIT_CLONE;\n+use clippy_utils::is_diagnostic_assoc_item;\n+\n+pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, trait_diagnostic: Symbol) {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method_path, _, [arg], _) = &expr.kind;\n+        let return_type = cx.typeck_results().expr_ty(&expr);\n+        let input_type = cx.typeck_results().expr_ty(arg).peel_refs();\n+        if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n+        if TyS::same_type(return_type, input_type);\n+        if is_diagnostic_assoc_item(cx, expr_def_id, trait_diagnostic);\n+        then {\n+            span_lint_and_sugg(\n+                cx,IMPLICIT_CLONE,method_path.ident.span,\n+                &format!(\"implicitly cloning a `{}` by calling `{}` on its dereferenced type\", ty_name, method_path.ident.name),\n+                \"consider using\",\n+                \"clone\".to_string(),\n+                Applicability::MachineApplicable\n+            );\n+        }\n+    }\n+}"}, {"sha": "3045b09c2389f4890a9b1543cc3ee89c5cd0f6ca", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);"}, {"sha": "959457a5bfc960c9fb7855b895297cd616e0bf00", "filename": "clippy_lints/src/methods/inspect_for_each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finspect_for_each.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -7,7 +7,7 @@ use crate::utils::{match_trait_method, paths, span_lint_and_help};\n use super::INSPECT_FOR_EACH;\n \n /// lint use of `inspect().for_each()` for `Iterators`\n-pub(super) fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, inspect_span: Span) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, inspect_span: Span) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `inspect(..).for_each(..)` on an `Iterator`\";\n         let hint = \"move the code from `inspect(..)` to `for_each(..)` and remove the `inspect(..)`\";"}, {"sha": "1e8315dbee25eb90e9d40c957235b6877980b8ca", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,43 @@\n+use crate::utils::{has_iter_method, match_trait_method, paths, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n+\n+use super::INTO_ITER_ON_REF;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n+    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n+        return;\n+    }\n+    if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n+        span_lint_and_sugg(\n+            cx,\n+            INTO_ITER_ON_REF,\n+            method_span,\n+            &format!(\n+                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n+                method_name, kind,\n+            ),\n+            \"call directly\",\n+            method_name.to_string(),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n+    has_iter_method(cx, self_ref_ty).map(|ty_name| {\n+        let mutbl = match self_ref_ty.kind() {\n+            ty::Ref(_, _, mutbl) => mutbl,\n+            _ => unreachable!(),\n+        };\n+        let method_name = match mutbl {\n+            hir::Mutability::Not => \"iter\",\n+            hir::Mutability::Mut => \"iter_mut\",\n+        };\n+        (ty_name, method_name)\n+    })\n+}"}, {"sha": "c3e48ffa5fae4de57a7652307bd97d7b17e021f8", "filename": "clippy_lints/src/methods/iter_cloned_collect.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,30 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::ITER_CLONED_COLLECT;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type);\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0]));\n+        if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n+\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_CLONED_COLLECT,\n+                to_replace,\n+                \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                more readable\",\n+                \"try\",\n+                \".to_vec()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "869440e0165b2a7973705527e48ec729858215e1", "filename": "clippy_lints/src/methods/iter_count.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,47 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{is_type_diagnostic_item, match_type, paths, snippet_with_applicability, span_lint_and_sugg};\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::ITER_COUNT;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, iter_args: &'tcx [Expr<'tcx>], iter_method: &str) {\n+    let ty = cx.typeck_results().expr_ty(&iter_args[0]);\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], ty).is_some() {\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::vecdeque_type) {\n+        \"VecDeque\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::hashset_type) {\n+        \"HashSet\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n+        \"HashMap\"\n+    } else if match_type(cx, ty, &paths::BTREEMAP) {\n+        \"BTreeMap\"\n+    } else if match_type(cx, ty, &paths::BTREESET) {\n+        \"BTreeSet\"\n+    } else if match_type(cx, ty, &paths::LINKED_LIST) {\n+        \"LinkedList\"\n+    } else if match_type(cx, ty, &paths::BINARY_HEAP) {\n+        \"BinaryHeap\"\n+    } else {\n+        return;\n+    };\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        ITER_COUNT,\n+        expr.span,\n+        &format!(\"called `.{}().count()` on a `{}`\", iter_method, caller_type),\n+        \"try\",\n+        format!(\n+            \"{}.len()\",\n+            snippet_with_applicability(cx, iter_args[0].span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "3c03a949cfed09138abaedf02b9f500db27ca92b", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,68 @@\n+use crate::methods::derefs_to_slice;\n+use crate::utils::{get_parent_expr, higher, is_type_diagnostic_item, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::ITER_NEXT_SLICE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    let caller_expr = &iter_args[0];\n+\n+    // Skip lint if the `iter().next()` expression is a for loop argument,\n+    // since it is already covered by `&loops::ITER_NEXT_LOOP`\n+    let mut parent_expr_opt = get_parent_expr(cx, expr);\n+    while let Some(parent_expr) = parent_expr_opt {\n+        if higher::for_loop(parent_expr).is_some() {\n+            return;\n+        }\n+        parent_expr_opt = get_parent_expr(cx, parent_expr);\n+    }\n+\n+    if derefs_to_slice(cx, caller_expr, cx.typeck_results().expr_ty(caller_expr)).is_some() {\n+        // caller is a Slice\n+        if_chain! {\n+            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n+                = higher::range(index_expr);\n+            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n+            if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_NEXT_SLICE,\n+                    expr.span,\n+                    \"using `.iter().next()` on a Slice without end index\",\n+                    \"try calling\",\n+                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n+                    applicability,\n+                );\n+            }\n+        }\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n+        || matches!(\n+            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n+            ty::Array(_, _)\n+        )\n+    {\n+        // caller is a Vec or an Array\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_NEXT_SLICE,\n+            expr.span,\n+            \"using `.iter().next()` on an array\",\n+            \"try calling\",\n+            format!(\n+                \"{}.get(0)\",\n+                snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "cc3e56ea87277de289d95e242b81a32d62400cf5", "filename": "clippy_lints/src/methods/iter_nth.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,38 @@\n+use crate::methods::derefs_to_slice;\n+use crate::methods::iter_nth_zero;\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::ITER_NTH;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    nth_and_iter_args: &[&'tcx [hir::Expr<'tcx>]],\n+    is_mut: bool,\n+) {\n+    let iter_args = nth_and_iter_args[1];\n+    let mut_str = if is_mut { \"_mut\" } else { \"\" };\n+    let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.typeck_results().expr_ty(&iter_args[0])).is_some() {\n+        \"slice\"\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vec_type) {\n+        \"Vec\"\n+    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&iter_args[0]), sym::vecdeque_type) {\n+        \"VecDeque\"\n+    } else {\n+        let nth_args = nth_and_iter_args[0];\n+        iter_nth_zero::check(cx, expr, &nth_args);\n+        return; // caller is not a type that we want to lint\n+    };\n+\n+    span_lint_and_help(\n+        cx,\n+        ITER_NTH,\n+        expr.span,\n+        &format!(\"called `.iter{0}().nth()` on a {1}\", mut_str, caller_type),\n+        None,\n+        &format!(\"calling `.get{}()` is both faster and more readable\", mut_str),\n+    );\n+}"}, {"sha": "247192d81f3ec58f33340eedcecce5511655d8d4", "filename": "clippy_lints/src/methods/iter_nth_zero.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth_zero.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,27 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::{match_trait_method, paths, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITER_NTH_ZERO;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, nth_args: &'tcx [hir::Expr<'_>]) {\n+    if_chain! {\n+        if match_trait_method(cx, expr, &paths::ITERATOR);\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &nth_args[1]);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_NTH_ZERO,\n+                expr.span,\n+                \"called `.nth(0)` on a `std::iter::Iterator`, when `.next()` is equivalent\",\n+                \"try calling `.next()` instead of `.nth(0)`\",\n+                format!(\"{}.next()\", snippet_with_applicability(cx, nth_args[0].span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "5f5969134e49062483a4a5ab31f5934a28a02ff5", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,24 @@\n+use crate::utils::{match_trait_method, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITER_SKIP_NEXT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n+    // lint if caller of skip is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if let [caller, n] = skip_args {\n+            let hint = format!(\".nth({})\", snippet(cx, n.span, \"..\"));\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_SKIP_NEXT,\n+                expr.span.trim_start(caller.span).unwrap(),\n+                \"called `skip(..).next()` on an iterator\",\n+                \"use `nth` instead\",\n+                hint,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "3e05d7f76b75aa2272f7b237a5b082d71543be62", "filename": "clippy_lints/src/methods/iterator_step_by_zero.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiterator_step_by_zero.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,19 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::{match_trait_method, paths, span_lint};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::ITERATOR_STEP_BY_ZERO;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        if let Some((Constant::Int(0), _)) = constant(cx, cx.typeck_results(), &args[1]) {\n+            span_lint(\n+                cx,\n+                ITERATOR_STEP_BY_ZERO,\n+                expr.span,\n+                \"`Iterator::step_by(0)` will panic at runtime\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "0b414e0eb95676e46e9037db66be59d73bdeebac", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_target::abi::LayoutOf;\n \n-pub fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n+pub fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n     let unwrap_arg = &args[0][1];\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];"}, {"sha": "5b20e268d9f7ee8d7060d7e7eadd0fc52bbbbb73", "filename": "clippy_lints/src/methods/map_collect_result_unit.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{is_type_diagnostic_item, match_trait_method, paths, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_COLLECT_RESULT_UNIT;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    map_args: &[hir::Expr<'_>],\n+    collect_args: &[hir::Expr<'_>],\n+) {\n+    if_chain! {\n+        // called on Iterator\n+        if let [map_expr] = collect_args;\n+        if match_trait_method(cx, map_expr, &paths::ITERATOR);\n+        // return of collect `Result<(),_>`\n+        let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n+        if is_type_diagnostic_item(cx, collect_ret_ty, sym::result_type);\n+        if let ty::Adt(_, substs) = collect_ret_ty.kind();\n+        if let Some(result_t) = substs.types().next();\n+        if result_t.is_unit();\n+        // get parts for snippet\n+        if let [iter, map_fn] = map_args;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_COLLECT_RESULT_UNIT,\n+                expr.span,\n+                \"`.map().collect()` can be replaced with `.try_for_each()`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.try_for_each({})\",\n+                    snippet(cx, iter.span, \"..\"),\n+                    snippet(cx, map_fn.span, \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "14a14e4f9ecd1a4d24aae583077810b31b2731c8", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,61 @@\n+use crate::utils::{is_type_diagnostic_item, match_trait_method, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_FLATTEN;\n+\n+/// lint use of `map().flatten()` for `Iterators` and 'Options'\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.map().flatten()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let is_map_to_option = match map_closure_ty.kind() {\n+            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+                let map_closure_sig = match map_closure_ty.kind() {\n+                    ty::Closure(_, substs) => substs.as_closure().sig(),\n+                    _ => map_closure_ty.fn_sig(cx.tcx),\n+                };\n+                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n+            },\n+            _ => false,\n+        };\n+\n+        let method_to_use = if is_map_to_option {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            \"filter_map\"\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            \"flat_map\"\n+        };\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Iterator`\",\n+            &format!(\"try using `{}` instead\", method_to_use),\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // lint if caller of `.map().flatten()` is an Option\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".and_then({})\", func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Option`\",\n+            \"try using `and_then` instead\",\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "63b2cf87f32ada410984e722fcd10bb817ea259f", "filename": "clippy_lints/src/methods/map_unwrap_or.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_unwrap_or.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,76 @@\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{is_type_diagnostic_item, meets_msrv, snippet, span_lint, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_UNWRAP_OR;\n+\n+const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n+\n+/// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n+/// Return true if lint triggered\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    map_args: &'tcx [hir::Expr<'_>],\n+    unwrap_args: &'tcx [hir::Expr<'_>],\n+    msrv: Option<&RustcVersion>,\n+) -> bool {\n+    if !meets_msrv(msrv, &MAP_UNWRAP_OR_MSRV) {\n+        return false;\n+    }\n+    // lint if the caller of `map()` is an `Option`\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::result_type);\n+\n+    if is_option || is_result {\n+        // Don't make a suggestion that may fail to compile due to mutably borrowing\n+        // the same variable twice.\n+        let map_mutated_vars = mutated_variables(&map_args[0], cx);\n+        let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n+        if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n+            if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        // lint message\n+        let msg = if is_option {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on an `Option` value. This can be done more directly by calling \\\n+            `map_or_else(<g>, <f>)` instead\"\n+        } else {\n+            \"called `map(<f>).unwrap_or_else(<g>)` on a `Result` value. This can be done more directly by calling \\\n+            `.map_or_else(<g>, <f>)` instead\"\n+        };\n+        // get snippets for args to map() and unwrap_or_else()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or_else() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let var_snippet = snippet(cx, map_args[0].span, \"..\");\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_UNWRAP_OR,\n+                expr.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.map_or_else({}, {})\", var_snippet, unwrap_snippet, map_snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        } else if same_span && multiline {\n+            span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "7fd14c4f9b11c055a44dcc43ec416977ee6ba891", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 314, "deletions": 2131, "changes": 2445, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "c1706cc7cc7d266ad0c2f902e3a2d615148c6ca0", "filename": "clippy_lints/src/methods/ok_expect.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fok_expect.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{implements_trait, is_type_diagnostic_item, span_lint_and_help};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n+\n+use super::OK_EXPECT;\n+\n+/// lint use of `ok().expect()` for `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n+    if_chain! {\n+        // lint if the caller of `ok()` is a `Result`\n+        if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&ok_args[0]), sym::result_type);\n+        let result_type = cx.typeck_results().expr_ty(&ok_args[0]);\n+        if let Some(error_type) = get_error_type(cx, result_type);\n+        if has_debug_impl(error_type, cx);\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                OK_EXPECT,\n+                expr.span,\n+                \"called `ok().expect()` on a `Result` value\",\n+                None,\n+                \"you can call `expect()` directly on the `Result`\",\n+            );\n+        }\n+    }\n+}\n+\n+/// Given a `Result<T, E>` type, return its error type (`E`).\n+fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n+    match ty.kind() {\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym::result_type) => substs.types().nth(1),\n+        _ => None,\n+    }\n+}\n+\n+/// This checks whether a given type is known to implement Debug.\n+fn has_debug_impl<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n+    cx.tcx\n+        .get_diagnostic_item(sym::debug_trait)\n+        .map_or(false, |debug| implements_trait(cx, ty, debug, &[]))\n+}"}, {"sha": "89067dbfe0e51a780e6e6df125d2c9cfad98e357", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,122 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_def_path, meets_msrv, path_to_local_id, paths, remove_blocks, snippet,\n+    span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::sym;\n+\n+use super::OPTION_AS_REF_DEREF;\n+\n+const OPTION_AS_REF_DEREF_MSRV: RustcVersion = RustcVersion::new(1, 40, 0);\n+\n+/// lint use of `_.as_ref().map(Deref::deref)` for `Option`s\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    as_ref_args: &[hir::Expr<'_>],\n+    map_args: &[hir::Expr<'_>],\n+    is_mut: bool,\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if !meets_msrv(msrv, &OPTION_AS_REF_DEREF_MSRV) {\n+        return;\n+    }\n+\n+    let same_mutability = |m| (is_mut && m == &hir::Mutability::Mut) || (!is_mut && m == &hir::Mutability::Not);\n+\n+    let option_ty = cx.typeck_results().expr_ty(&as_ref_args[0]);\n+    if !is_type_diagnostic_item(cx, option_ty, sym::option_type) {\n+        return;\n+    }\n+\n+    let deref_aliases: [&[&str]; 9] = [\n+        &paths::DEREF_TRAIT_METHOD,\n+        &paths::DEREF_MUT_TRAIT_METHOD,\n+        &paths::CSTRING_AS_C_STR,\n+        &paths::OS_STRING_AS_OS_STR,\n+        &paths::PATH_BUF_AS_PATH,\n+        &paths::STRING_AS_STR,\n+        &paths::STRING_AS_MUT_STR,\n+        &paths::VEC_AS_SLICE,\n+        &paths::VEC_AS_MUT_SLICE,\n+    ];\n+\n+    let is_deref = match map_args[1].kind {\n+        hir::ExprKind::Path(ref expr_qpath) => cx\n+            .qpath_res(expr_qpath, map_args[1].hir_id)\n+            .opt_def_id()\n+            .map_or(false, |fun_def_id| {\n+                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+            }),\n+        hir::ExprKind::Closure(_, _, body_id, _, _) => {\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            match &closure_expr.kind {\n+                hir::ExprKind::MethodCall(_, _, args, _) => {\n+                    if_chain! {\n+                        if args.len() == 1;\n+                        if path_to_local_id(&args[0], closure_body.params[0].pat.hir_id);\n+                        let adj = cx\n+                            .typeck_results()\n+                            .expr_adjustments(&args[0])\n+                            .iter()\n+                            .map(|x| &x.kind)\n+                            .collect::<Box<[_]>>();\n+                        if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n+                        then {\n+                            let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n+                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref inner) if same_mutability(m) => {\n+                    if_chain! {\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner1) = inner.kind;\n+                        if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner2) = inner1.kind;\n+                        then {\n+                            path_to_local_id(inner2, closure_body.params[0].pat.hir_id)\n+                        } else {\n+                            false\n+                        }\n+                    }\n+                },\n+                _ => false,\n+            }\n+        },\n+        _ => false,\n+    };\n+\n+    if is_deref {\n+        let current_method = if is_mut {\n+            format!(\".as_mut().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        } else {\n+            format!(\".as_ref().map({})\", snippet(cx, map_args[1].span, \"..\"))\n+        };\n+        let method_hint = if is_mut { \"as_deref_mut\" } else { \"as_deref\" };\n+        let hint = format!(\"{}.{}()\", snippet(cx, as_ref_args[0].span, \"..\"), method_hint);\n+        let suggestion = format!(\"try using {} instead\", method_hint);\n+\n+        let msg = format!(\n+            \"called `{0}` on an Option value. This can be done more directly \\\n+            by calling `{1}` instead\",\n+            current_method, hint\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_AS_REF_DEREF,\n+            expr.span,\n+            &msg,\n+            &suggestion,\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "64f6ebc5062ef3ef208c2190f7b50891702ffaaf", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,78 @@\n+use crate::utils::{is_type_diagnostic_item, match_qpath, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::OPTION_MAP_OR_NONE;\n+use super::RESULT_MAP_OR_INTO_OPTION;\n+\n+/// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_or_args: &'tcx [hir::Expr<'_>]) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::option_type);\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_or_args[0]), sym::result_type);\n+\n+    // There are two variants of this `map_or` lint:\n+    // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n+    // (2) using `map_or` as a combinator instead of `and_then`\n+    //\n+    // (For this lint) we don't care if any other type calls `map_or`\n+    if !is_option && !is_result {\n+        return;\n+    }\n+\n+    let (lint_name, msg, instead, hint) = {\n+        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n+            match_qpath(qpath, &paths::OPTION_NONE)\n+        } else {\n+            return;\n+        };\n+\n+        if !default_arg_is_none {\n+            // nothing to lint!\n+            return;\n+        }\n+\n+        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_or_args[2].kind {\n+            match_qpath(qpath, &paths::OPTION_SOME)\n+        } else {\n+            false\n+        };\n+\n+        if is_option {\n+            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            let func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n+            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n+            (\n+                OPTION_MAP_OR_NONE,\n+                msg,\n+                \"try using `and_then` instead\",\n+                format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            )\n+        } else if f_arg_is_some {\n+            let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n+                       `ok()` instead\";\n+            let self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n+            (\n+                RESULT_MAP_OR_INTO_OPTION,\n+                msg,\n+                \"try using `ok` instead\",\n+                format!(\"{0}.ok()\", self_snippet),\n+            )\n+        } else {\n+            // nothing to lint!\n+            return;\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint_name,\n+        expr.span,\n+        msg,\n+        instead,\n+        hint,\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "7cdd49bbf0307a6a3a2adaa6c6e8b1e976f1ce55", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -12,7 +12,7 @@ use rustc_span::{sym, Symbol};\n use super::MAP_UNWRAP_OR;\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &rustc_hir::Expr<'_>,\n     map_args: &'tcx [rustc_hir::Expr<'_>],"}, {"sha": "5f7fc431d22483edca2dbf1c8ce14b0021bf60c5", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::eager_or_lazy::is_lazyness_candidate;\n+use crate::utils::{\n+    contains_return, get_trait_def_id, implements_trait, is_type_diagnostic_item, last_path_segment, match_type, paths,\n+    snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::OR_FUN_CALL;\n+\n+/// Checks for the `OR_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &'tcx [hir::Expr<'_>],\n+) {\n+    /// Checks for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    fn check_unwrap_or_default(\n+        cx: &LateContext<'_>,\n+        name: &str,\n+        fun: &hir::Expr<'_>,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &hir::Expr<'_>,\n+        or_has_args: bool,\n+        span: Span,\n+    ) -> bool {\n+        if_chain! {\n+            if !or_has_args;\n+            if name == \"unwrap_or\";\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            let path = &*last_path_segment(qpath).ident.as_str();\n+            if [\"default\", \"new\"].contains(&path);\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span,\n+                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                    \"try this\",\n+                    format!(\n+                        \"{}.unwrap_or_default()\",\n+                        snippet_with_applicability(cx, self_expr.span, \"..\", &mut applicability)\n+                    ),\n+                    applicability,\n+                );\n+\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks for `*or(foo())`.\n+    #[allow(clippy::too_many_arguments)]\n+    fn check_general_case<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        name: &str,\n+        method_span: Span,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &'tcx hir::Expr<'_>,\n+        span: Span,\n+        // None if lambda is required\n+        fun_span: Option<Span>,\n+    ) {\n+        // (path, fn_has_argument, methods, suffix)\n+        static KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n+            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n+            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        ];\n+\n+        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n+            if path.ident.as_str() == \"len\" {\n+                let ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+\n+                match ty.kind() {\n+                    ty::Slice(_) | ty::Array(_, _) => return,\n+                    _ => (),\n+                }\n+\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if_chain! {\n+            if KNOW_TYPES.iter().any(|k| k.2.contains(&name));\n+\n+            if is_lazyness_candidate(cx, arg);\n+            if !contains_return(&arg);\n+\n+            let self_ty = cx.typeck_results().expr_ty(self_expr);\n+\n+            if let Some(&(_, fn_has_arguments, poss, suffix)) =\n+                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+\n+            if poss.contains(&name);\n+\n+            then {\n+                let macro_expanded_snipped;\n+                let sugg: Cow<'_, str> = {\n+                    let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n+                        (false, Some(fun_span)) => (fun_span, false),\n+                        _ => (arg.span, true),\n+                    };\n+                    let snippet = {\n+                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, snippet_span, \"..\");\n+                        if not_macro_argument_snippet == \"vec![]\" {\n+                            macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n+                            match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n+                                Some(stripped) => Cow::from(stripped),\n+                                None => macro_expanded_snipped\n+                            }\n+                        }\n+                        else {\n+                            not_macro_argument_snippet\n+                        }\n+                    };\n+\n+                    if use_lambda {\n+                        let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n+                        format!(\"|{}| {}\", l_arg, snippet).into()\n+                    } else {\n+                        snippet\n+                    }\n+                };\n+                let span_replace_word = method_span.with_hi(span.hi());\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"{}_{}({})\", name, suffix, sugg),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    if args.len() == 2 {\n+        match args[1].kind {\n+            hir::ExprKind::Call(ref fun, ref or_args) => {\n+                let or_has_args = !or_args.is_empty();\n+                if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                    let fun_span = if or_has_args { None } else { Some(fun.span) };\n+                    check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, fun_span);\n+                }\n+            },\n+            hir::ExprKind::Index(..) | hir::ExprKind::MethodCall(..) => {\n+                check_general_case(cx, name, method_span, &args[0], &args[1], expr.span, None);\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "e9e654432208d94813f5083cfb2fe931faa47829", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, paths, snippet, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_sugg, strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+\n+use super::SEARCH_IS_SOME;\n+\n+/// lint searching an Iterator followed by `is_some()`\n+/// or calling `find()` on a string followed by `is_some()`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    search_method: &str,\n+    search_args: &'tcx [hir::Expr<'_>],\n+    is_some_args: &'tcx [hir::Expr<'_>],\n+    method_span: Span,\n+) {\n+    // lint if caller of search is an Iterator\n+    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n+        let msg = format!(\n+            \"called `is_some()` after searching an `Iterator` with `{}`\",\n+            search_method\n+        );\n+        let hint = \"this is more succinctly expressed by calling `any()`\";\n+        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        if search_snippet.lines().count() <= 1 {\n+            // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n+            // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n+            let any_search_snippet = if_chain! {\n+                if search_method == \"find\";\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                if let Some(closure_arg) = closure_body.params.get(0);\n+                then {\n+                    if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n+                        Some(search_snippet.replacen('&', \"\", 1))\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                        let name = &*ident.name.as_str();\n+                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            };\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                SEARCH_IS_SOME,\n+                method_span.with_hi(expr.span.hi()),\n+                &msg,\n+                \"use `any()` instead\",\n+                format!(\n+                    \"any({})\",\n+                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint_and_help(cx, SEARCH_IS_SOME, expr.span, &msg, None, hint);\n+        }\n+    }\n+    // lint if `find()` is called by `String` or `&str`\n+    else if search_method == \"find\" {\n+        let is_string_or_str_slice = |e| {\n+            let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n+            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                true\n+            } else {\n+                *self_ty.kind() == ty::Str\n+            }\n+        };\n+        if_chain! {\n+            if is_string_or_str_slice(&search_args[0]);\n+            if is_string_or_str_slice(&search_args[1]);\n+            then {\n+                let msg = \"called `is_some()` after calling `find()` on a string\";\n+                let mut applicability = Applicability::MachineApplicable;\n+                let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    method_span.with_hi(expr.span.hi()),\n+                    msg,\n+                    \"use `contains()` instead\",\n+                    format!(\"contains({})\", find_arg),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "0ce8b66978dc12cdd4e307a8612ab2dce2d860cf", "filename": "clippy_lints/src/methods/single_char_insert_string.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,27 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_ADD_STR;\n+\n+/// lint for length-1 `str`s as argument for `insert_str`\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[2], &mut applicability) {\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"_\", &mut applicability);\n+        let pos_arg = snippet_with_applicability(cx, args[1].span, \"..\", &mut applicability);\n+        let sugg = format!(\"{}.insert({}, {})\", base_string_snippet, pos_arg, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_ADD_STR,\n+            expr.span,\n+            \"calling `insert_str()` using a single-character string literal\",\n+            \"consider using `insert` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "61cbc9d2f0a6296d83d1b58af359380e9fdedd5e", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,23 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::span_lint_and_sugg;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_PATTERN;\n+\n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_PATTERN,\n+            arg.span,\n+            \"single-character string constant used as pattern\",\n+            \"try using a `char` instead\",\n+            hint,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "deacc70b713e5ae15d6b571cb9877f8aa9a8fd10", "filename": "clippy_lints/src/methods/single_char_push_string.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,26 @@\n+use crate::methods::get_hint_if_single_char_arg;\n+use crate::utils::{snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SINGLE_CHAR_ADD_STR;\n+\n+/// lint for length-1 `str`s as argument for `push_str`\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    if let Some(extension_string) = get_hint_if_single_char_arg(cx, &args[1], &mut applicability) {\n+        let base_string_snippet =\n+            snippet_with_applicability(cx, args[0].span.source_callsite(), \"..\", &mut applicability);\n+        let sugg = format!(\"{}.push({})\", base_string_snippet, extension_string);\n+        span_lint_and_sugg(\n+            cx,\n+            SINGLE_CHAR_ADD_STR,\n+            expr.span,\n+            \"calling `push_str()` using a single-character string literal\",\n+            \"consider using `push` with a character literal\",\n+            sugg,\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "8ba6ae952003e6ce480a65e9e316cd7dadf5a371", "filename": "clippy_lints/src/methods/skip_while_next.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fskip_while_next.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,20 @@\n+use crate::utils::{match_trait_method, paths, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SKIP_WHILE_NEXT;\n+\n+/// lint use of `skip_while().next()` for `Iterators`\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, _skip_while_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.skip_while().next()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        span_lint_and_help(\n+            cx,\n+            SKIP_WHILE_NEXT,\n+            expr.span,\n+            \"called `skip_while(<p>).next()` on an `Iterator`\",\n+            None,\n+            \"this is more succinctly expressed by calling `.find(!<p>)` instead\",\n+        );\n+    }\n+}"}, {"sha": "0a08ea26175fe17d7a2589923a4b303ae4abc9e8", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,42 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::STRING_EXTEND_CHARS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n+        let arg = &args[1];\n+        if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n+            let target = &arglists[0][0];\n+            let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n+            let ref_str = if *self_ty.kind() == ty::Str {\n+                \"\"\n+            } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                \"&\"\n+            } else {\n+                return;\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                STRING_EXTEND_CHARS,\n+                expr.span,\n+                \"calling `.extend(_.chars())`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.push_str({}{})\",\n+                    snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                    ref_str,\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "e135a826dc4d093e855a228d679b40669249ceb9", "filename": "clippy_lints/src/methods/suspicious_map.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,16 @@\n+use crate::utils::span_lint_and_help;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::SUSPICIOUS_MAP;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n+    span_lint_and_help(\n+        cx,\n+        SUSPICIOUS_MAP,\n+        expr.span,\n+        \"this call to `map()` won't have an effect on the call to `count()`\",\n+        None,\n+        \"make sure you did not confuse `map` with `filter` or `for_each`\",\n+    );\n+}"}, {"sha": "798b66192c81829cd53afc1816f97277125ddc37", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,35 @@\n+use crate::utils::{match_def_path, match_qpath, paths, span_lint};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::UNINIT_ASSUMED_INIT;\n+\n+/// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n+    if_chain! {\n+        if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n+        if args.is_empty();\n+        if let hir::ExprKind::Path(ref path) = callee.kind;\n+        if match_qpath(path, &paths::MEM_MAYBEUNINIT_UNINIT);\n+        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(outer));\n+        then {\n+            span_lint(\n+                cx,\n+                UNINIT_ASSUMED_INIT,\n+                outer.span,\n+                \"this call for this type may be undefined behavior\"\n+            );\n+        }\n+    }\n+}\n+\n+fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n+        ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n+        ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n+        _ => false,\n+    }\n+}"}, {"sha": "12b2cf0a16582f407d65902a5b1abe4fb64a189b", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -9,7 +9,7 @@ use if_chain::if_chain;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn lint(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }"}, {"sha": "a26443f4ee94420be3fb97007329249448c049e1", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    match_trait_method, path_to_local_id, paths, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+    strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use super::UNNECESSARY_FOLD;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n+    fn check_fold_with_op(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        fold_args: &[hir::Expr<'_>],\n+        fold_span: Span,\n+        op: hir::BinOpKind,\n+        replacement_method_name: &str,\n+        replacement_has_args: bool,\n+    ) {\n+        if_chain! {\n+            // Extract the body of the closure passed to fold\n+            if let hir::ExprKind::Closure(_, _, body_id, _, _) = fold_args[2].kind;\n+            let closure_body = cx.tcx.hir().body(body_id);\n+            let closure_expr = remove_blocks(&closure_body.value);\n+\n+            // Check if the closure body is of the form `acc <op> some_expr(x)`\n+            if let hir::ExprKind::Binary(ref bin_op, ref left_expr, ref right_expr) = closure_expr.kind;\n+            if bin_op.node == op;\n+\n+            // Extract the names of the two arguments to the closure\n+            if let [param_a, param_b] = closure_body.params;\n+            if let PatKind::Binding(_, first_arg_id, ..) = strip_pat_refs(&param_a.pat).kind;\n+            if let PatKind::Binding(_, second_arg_id, second_arg_ident, _) = strip_pat_refs(&param_b.pat).kind;\n+\n+            if path_to_local_id(left_expr, first_arg_id);\n+            if replacement_has_args || path_to_local_id(right_expr, second_arg_id);\n+\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                let sugg = if replacement_has_args {\n+                    format!(\n+                        \"{replacement}(|{s}| {r})\",\n+                        replacement = replacement_method_name,\n+                        s = second_arg_ident,\n+                        r = snippet_with_applicability(cx, right_expr.span, \"EXPR\", &mut applicability),\n+                    )\n+                } else {\n+                    format!(\n+                        \"{replacement}()\",\n+                        replacement = replacement_method_name,\n+                    )\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_FOLD,\n+                    fold_span.with_hi(expr.span.hi()),\n+                    // TODO #2371 don't suggest e.g., .any(|x| f(x)) if we can suggest .any(f)\n+                    \"this `.fold` can be written more succinctly using another method\",\n+                    \"try\",\n+                    sugg,\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+\n+    // Check that this is a call to Iterator::fold rather than just some function called fold\n+    if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+        return;\n+    }\n+\n+    assert!(\n+        fold_args.len() == 3,\n+        \"Expected fold_args to have three entries - the receiver, the initial value and the closure\"\n+    );\n+\n+    // Check if the first argument to .fold is a suitable literal\n+    if let hir::ExprKind::Lit(ref lit) = fold_args[1].kind {\n+        match lit.node {\n+            ast::LitKind::Bool(false) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Or, \"any\", true)\n+            },\n+            ast::LitKind::Bool(true) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::And, \"all\", true)\n+            },\n+            ast::LitKind::Int(0, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Add, \"sum\", false)\n+            },\n+            ast::LitKind::Int(1, _) => {\n+                check_fold_with_op(cx, expr, fold_args, fold_span, hir::BinOpKind::Mul, \"product\", false)\n+            },\n+            _ => (),\n+        }\n+    }\n+}"}, {"sha": "a17259d697faa3128d33a83f8699f9e4f5efa86e", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -9,7 +9,7 @@ use super::UNNECESSARY_LAZY_EVALUATIONS;\n \n /// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n /// replaced with `<fn>(return value of simple closure)`\n-pub(super) fn lint<'tcx>(\n+pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     args: &'tcx [hir::Expr<'_>],\n@@ -50,7 +50,7 @@ pub(super) fn lint<'tcx>(\n                     UNNECESSARY_LAZY_EVALUATIONS,\n                     expr.span,\n                     msg,\n-                    &format!(\"Use `{}` instead\", simplify_using),\n+                    &format!(\"use `{}` instead\", simplify_using),\n                     format!(\n                         \"{0}.{1}({2})\",\n                         snippet(cx, args[0].span, \"..\"),"}, {"sha": "094c3fc45c493b097b13c4bba274938aa1c5f2ee", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,34 @@\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_help};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::UNWRAP_USED;\n+\n+/// lint use of `unwrap()` for `Option`s and `Result`s\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&unwrap_args[0]).peel_refs();\n+\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym::option_type) {\n+        Some((UNWRAP_USED, \"an Option\", \"None\"))\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym::result_type) {\n+        Some((UNWRAP_USED, \"a Result\", \"Err\"))\n+    } else {\n+        None\n+    };\n+\n+    if let Some((lint, kind, none_value)) = mess {\n+        span_lint_and_help(\n+            cx,\n+            lint,\n+            expr.span,\n+            &format!(\"used `unwrap()` on `{}` value\", kind,),\n+            None,\n+            &format!(\n+                \"if you don't want to handle the `{}` case gracefully, consider \\\n+                using `expect()` to provide a better panic message\",\n+                none_value,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "e4554f8d4897e21470d34605ec481ab7d4d34dec", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,45 @@\n+use crate::utils::{\n+    get_parent_expr, match_trait_method, paths, snippet_with_applicability, span_lint_and_sugg, walk_ptrs_ty_depth,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::USELESS_ASREF;\n+\n+/// Checks for the `USELESS_ASREF` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n+    // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n+    // check if the call is to the actual `AsRef` or `AsMut` trait\n+    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+        // check if the type after `as_ref` or `as_mut` is the same as before\n+        let recvr = &as_ref_args[0];\n+        let rcv_ty = cx.typeck_results().expr_ty(recvr);\n+        let res_ty = cx.typeck_results().expr_ty(expr);\n+        let (base_res_ty, res_depth) = walk_ptrs_ty_depth(res_ty);\n+        let (base_rcv_ty, rcv_depth) = walk_ptrs_ty_depth(rcv_ty);\n+        if base_rcv_ty == base_res_ty && rcv_depth >= res_depth {\n+            // allow the `as_ref` or `as_mut` if it is followed by another method call\n+            if_chain! {\n+                if let Some(parent) = get_parent_expr(cx, expr);\n+                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n+                if span != &expr.span;\n+                then {\n+                    return;\n+                }\n+            }\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                USELESS_ASREF,\n+                expr.span,\n+                &format!(\"this call to `{}` does nothing\", call_name),\n+                \"try this\",\n+                snippet_with_applicability(cx, recvr.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "90fab577436618a231b527c75b4e9fede9bc2413", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,76 @@\n+use crate::methods::SelfKind;\n+use crate::utils::span_lint;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TyS;\n+use rustc_span::source_map::Span;\n+use std::fmt;\n+\n+use super::WRONG_PUB_SELF_CONVENTION;\n+use super::WRONG_SELF_CONVENTION;\n+\n+#[rustfmt::skip]\n+const CONVENTIONS: [(Convention, &[SelfKind]); 7] = [\n+    (Convention::Eq(\"new\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"as_\"), &[SelfKind::Ref, SelfKind::RefMut]),\n+    (Convention::StartsWith(\"from_\"), &[SelfKind::No]),\n+    (Convention::StartsWith(\"into_\"), &[SelfKind::Value]),\n+    (Convention::StartsWith(\"is_\"), &[SelfKind::Ref, SelfKind::No]),\n+    (Convention::Eq(\"to_mut\"), &[SelfKind::RefMut]),\n+    (Convention::StartsWith(\"to_\"), &[SelfKind::Ref]),\n+];\n+enum Convention {\n+    Eq(&'static str),\n+    StartsWith(&'static str),\n+}\n+\n+impl Convention {\n+    #[must_use]\n+    fn check(&self, other: &str) -> bool {\n+        match *self {\n+            Self::Eq(this) => this == other,\n+            Self::StartsWith(this) => other.starts_with(this) && this != other,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Convention {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n+        match *self {\n+            Self::Eq(this) => this.fmt(f),\n+            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    item_name: &str,\n+    is_pub: bool,\n+    self_ty: &'tcx TyS<'tcx>,\n+    first_arg_ty: &'tcx TyS<'tcx>,\n+    first_arg_span: Span,\n+) {\n+    let lint = if is_pub {\n+        WRONG_PUB_SELF_CONVENTION\n+    } else {\n+        WRONG_SELF_CONVENTION\n+    };\n+    if let Some((ref conv, self_kinds)) = &CONVENTIONS.iter().find(|(ref conv, _)| conv.check(item_name)) {\n+        if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n+            span_lint(\n+                cx,\n+                lint,\n+                first_arg_span,\n+                &format!(\n+                    \"methods called `{}` usually take {}; consider choosing a less ambiguous name\",\n+                    conv,\n+                    &self_kinds\n+                        .iter()\n+                        .map(|k| k.description())\n+                        .collect::<Vec<_>>()\n+                        .join(\" or \")\n+                ),\n+            );\n+        }\n+    }\n+}"}, {"sha": "f1335726736ca4d85f3e927091d078edd0a1247d", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,19 @@\n+use crate::utils::span_lint;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::ZST_OFFSET;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    if_chain! {\n+        if args.len() == 2;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        if layout.is_zst();\n+        then {\n+            span_lint(cx, ZST_OFFSET, expr.span, \"offset calculation on zero-sized value\");\n+        }\n+    }\n+}"}, {"sha": "acdc245456b5a1a508ce480e972b861bc44bf985", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -12,12 +12,13 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n+use rustc_span::symbol::sym;\n \n use crate::consts::{constant, Constant};\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    get_item_name, get_parent_expr, higher, implements_trait, in_constant, is_integer_const, iter_input_pats,\n-    last_path_segment, match_qpath, match_trait_method, paths, snippet, snippet_opt, span_lint, span_lint_and_sugg,\n+    get_item_name, get_parent_expr, higher, implements_trait, in_constant, is_diagnostic_assoc_item, is_integer_const,\n+    iter_input_pats, last_path_segment, match_qpath, snippet, snippet_opt, span_lint, span_lint_and_sugg,\n     span_lint_and_then, span_lint_hir_and_then, unsext, SpanlessEq,\n };\n \n@@ -292,7 +293,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                     TOPLEVEL_REF_ARG,\n                     arg.pat.span,\n                     \"`ref` directly on a function argument is ignored. \\\n-                    Consider using a reference type instead.\",\n+                    Consider using a reference type instead\",\n                 );\n             }\n         }\n@@ -422,7 +423,7 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 expr.span,\n                 &format!(\n                     \"used binding `{}` which is prefixed with an underscore. A leading \\\n-                     underscore signals that a binding will not be used.\",\n+                     underscore signals that a binding will not be used\",\n                     binding\n                 ),\n             );\n@@ -554,11 +555,16 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n \n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n-            if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.typeck_results().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n-            } else {\n-                return;\n-            }\n+            if_chain!(\n+                if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+                if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString)\n+                    || is_diagnostic_assoc_item(cx, expr_def_id, sym::ToOwned);\n+                then {\n+                    (cx.typeck_results().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                } else {\n+                    return;\n+                }\n+            )\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {"}, {"sha": "da59c820999d9e4786e190bfc1de3cde1c9b202e", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -69,21 +69,21 @@ fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp\n     }\n }\n \n-fn is_executable(cx: &LateContext<'_>) -> bool {\n+fn is_executable_or_proc_macro(cx: &LateContext<'_>) -> bool {\n     use rustc_session::config::CrateType;\n \n     cx.tcx\n         .sess\n         .crate_types()\n         .iter()\n-        .any(|t: &CrateType| matches!(t, CrateType::Executable))\n+        .any(|t: &CrateType| matches!(t, CrateType::Executable | CrateType::ProcMacro))\n }\n \n declare_lint_pass!(MissingInline => [MISSING_INLINE_IN_PUBLIC_ITEMS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingInline {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, it: &'tcx hir::Item<'_>) {\n-        if rustc_middle::lint::in_external_macro(cx.sess(), it.span) || is_executable(cx) {\n+        if rustc_middle::lint::in_external_macro(cx.sess(), it.span) || is_executable_or_proc_macro(cx) {\n             return;\n         }\n \n@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         use rustc_middle::ty::{ImplContainer, TraitContainer};\n-        if rustc_middle::lint::in_external_macro(cx.sess(), impl_item.span) || is_executable(cx) {\n+        if rustc_middle::lint::in_external_macro(cx.sess(), impl_item.span) || is_executable_or_proc_macro(cx) {\n             return;\n         }\n "}, {"sha": "9caacb5db7c9c67f00bf13a69a0f2ab66e1c38e6", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -73,11 +73,7 @@ impl<'a, 'tcx> MutArgVisitor<'a, 'tcx> {\n     }\n \n     fn expr_span(&self) -> Option<Span> {\n-        if self.found {\n-            self.expr_span\n-        } else {\n-            None\n-        }\n+        if self.found { self.expr_span } else { None }\n     }\n }\n "}, {"sha": "f449f397e7d6163e4f81ce25475ad21c3ac59e69", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,3 @@\n-//! Checks for useless borrowed references.\n-//!\n-//! This lint is **warn** by default\n-\n use crate::utils::{snippet_with_applicability, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -10,44 +6,37 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for useless borrowed references.\n-    ///\n-    /// **Why is this bad?** It is mostly useless and make the code look more\n-    /// complex than it\n-    /// actually is.\n+    /// **What it does:** Checks for bindings that destructure a reference and borrow the inner\n+    /// value with `&ref`.\n     ///\n-    /// **Known problems:** It seems that the `&ref` pattern is sometimes useful.\n-    /// For instance in the following snippet:\n-    /// ```rust,ignore\n-    /// enum Animal {\n-    ///     Cat(u64),\n-    ///     Dog(u64),\n-    /// }\n+    /// **Why is this bad?** This pattern has no effect in almost all cases.\n     ///\n-    /// fn foo(a: &Animal, b: &Animal) {\n+    /// **Known problems:** In some cases, `&ref` is needed to avoid a lifetime mismatch error.\n+    /// Example:\n+    /// ```rust\n+    /// fn foo(a: &Option<String>, b: &Option<String>) {\n     ///     match (a, b) {\n-    ///         (&Animal::Cat(v), k) | (k, &Animal::Cat(v)) => (), // lifetime mismatch error\n-    ///         (&Animal::Dog(ref c), &Animal::Dog(_)) => ()\n-    ///     }\n+    ///         (None, &ref c) | (&ref c, None) => (),\n+    ///         (&Some(ref c), _) => (),\n+    ///     };\n     /// }\n     /// ```\n-    /// There is a lifetime mismatch error for `k` (indeed a and b have distinct\n-    /// lifetime).\n-    /// This can be fixed by using the `&ref` pattern.\n-    /// However, the code can also be fixed by much cleaner ways\n     ///\n     /// **Example:**\n+    /// Bad:\n     /// ```rust\n     /// let mut v = Vec::<String>::new();\n     /// let _ = v.iter_mut().filter(|&ref a| a.is_empty());\n     /// ```\n-    /// This closure takes a reference on something that has been matched as a\n-    /// reference and\n-    /// de-referenced.\n-    /// As such, it could just be |a| a.is_empty()\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// let mut v = Vec::<String>::new();\n+    /// let _ = v.iter_mut().filter(|a| a.is_empty());\n+    /// ```\n     pub NEEDLESS_BORROWED_REFERENCE,\n     complexity,\n-    \"taking a needless borrowed reference\"\n+    \"destructuring a reference and borrowing the inner value\"\n }\n \n declare_lint_pass!(NeedlessBorrowedRef => [NEEDLESS_BORROWED_REFERENCE]);"}, {"sha": "30fe2d6225c8ae5004b029a41da5efc4d3ee50b4", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -416,11 +416,7 @@ fn erode_from_back(s: &str) -> String {\n             break;\n         }\n     }\n-    if ret.is_empty() {\n-        s.to_string()\n-    } else {\n-        ret\n-    }\n+    if ret.is_empty() { s.to_string() } else { ret }\n }\n \n fn span_of_first_expr_in_block(block: &ast::Block) -> Option<Span> {"}, {"sha": "a3293f1b3614925d017d33ce0e4a8546c0e92ef4", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -142,7 +142,7 @@ fn emit_lint(cx: &LateContext<'_>, expr: &SomeOkCall<'_>) {\n         cx,\n         NEEDLESS_QUESTION_MARK,\n         entire_expr.span,\n-        \"Question mark operator is useless here\",\n+        \"question mark operator is useless here\",\n         \"try\",\n         format!(\"{}\", utils::snippet(cx, inner_expr.span, r#\"\"...\"\"#)),\n         Applicability::MachineApplicable,"}, {"sha": "07ca196990da9b71dcafa0ec395629b01f4b562b", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -69,15 +69,11 @@ fn get_open_options(cx: &LateContext<'_>, argument: &Expr<'_>, options: &mut Vec\n                         ..\n                     } = *span\n                     {\n-                        if lit {\n-                            Argument::True\n-                        } else {\n-                            Argument::False\n-                        }\n+                        if lit { Argument::True } else { Argument::False }\n                     } else {\n-                        return; // The function is called with a literal\n-                                // which is not a boolean literal. This is theoretically\n-                                // possible, but not very likely.\n+                        // The function is called with a literal which is not a boolean literal.\n+                        // This is theoretically possible, but not very likely.\n+                        return;\n                     }\n                 },\n                 _ => Argument::Unknown,"}, {"sha": "4a7b0ad07aaebbcef27653e56e81f6d873906a10", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,10 +1,11 @@\n-use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use crate::utils::{is_type_diagnostic_item, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::sym;\n use std::path::{Component, Path};\n \n declare_clippy_lint! {\n@@ -46,7 +47,7 @@ impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n             if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n-            if match_type(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), &paths::PATH_BUF);\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]).peel_refs(), sym::PathBuf);\n             if let Some(get_index_arg) = args.get(1);\n             if let ExprKind::Lit(ref lit) = get_index_arg.kind;\n             if let LitKind::Str(ref path_lit, _) = lit.node;"}, {"sha": "6ea2d8b06d81cd60319e7d5cb0d8a9d257f4f99f", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -188,7 +188,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         PTR_ARG,\n                         arg.span,\n                         \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                         with non-Vec-based slices.\",\n+                         with non-Vec-based slices\",\n                         |diag| {\n                             if let Some(ref snippet) = get_only_generic_arg_snippet(cx, arg) {\n                                 diag.span_suggestion(\n@@ -217,7 +217,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         cx,\n                         PTR_ARG,\n                         arg.span,\n-                        \"writing `&String` instead of `&str` involves a new object where a slice will do.\",\n+                        \"writing `&String` instead of `&str` involves a new object where a slice will do\",\n                         |diag| {\n                             diag.span_suggestion(arg.span, \"change this to\", \"&str\".into(), Applicability::Unspecified);\n                             for (clonespan, suggestion) in spans {\n@@ -233,13 +233,13 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         },\n                     );\n                 }\n-            } else if match_type(cx, ty, &paths::PATH_BUF) {\n+            } else if is_type_diagnostic_item(cx, ty, sym::PathBuf) {\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n                         arg.span,\n-                        \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\",\n+                        \"writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\",\n                         |diag| {\n                             diag.span_suggestion(\n                                 arg.span,\n@@ -278,7 +278,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                                 cx,\n                                 PTR_ARG,\n                                 arg.span,\n-                                \"using a reference to `Cow` is not recommended.\",\n+                                \"using a reference to `Cow` is not recommended\",\n                                 \"change this to\",\n                                 \"&\".to_owned() + &r,\n                                 Applicability::Unspecified,"}, {"sha": "f90d48205633edebe953f6f3de291433cad8b508", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    fn_has_unsatisfiable_preds, has_drop, is_copy, is_type_diagnostic_item, match_def_path, match_type, paths,\n-    snippet_opt, span_lint_hir, span_lint_hir_and_then, walk_ptrs_ty_depth,\n+    fn_has_unsatisfiable_preds, has_drop, is_copy, is_type_diagnostic_item, match_def_path, paths, snippet_opt,\n+    span_lint_hir, span_lint_hir_and_then, walk_ptrs_ty_depth,\n };\n use if_chain::if_chain;\n use rustc_data_structures::{fx::FxHashMap, transitive_relation::TransitiveRelation};\n@@ -165,9 +165,9 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                     if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, res)) =\n                         is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n                     if res == cloned;\n-                    if match_def_path(cx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n-                    if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n-                        || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n+                    if cx.tcx.is_diagnostic_item(sym::deref_method, pred_fn_def_id);\n+                    if is_type_diagnostic_item(cx, pred_arg_ty, sym::PathBuf)\n+                        || is_type_diagnostic_item(cx, pred_arg_ty, sym::OsString);\n                     then {\n                         (pred_arg, res)\n                     } else {"}, {"sha": "44521885d2009c3b06ac90ec9d1f4ce8cf74b3f1", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -261,8 +261,8 @@ fn emit_suggestion(cx: &EarlyContext<'_>, span: Span, sugg: String, applicabilit\n         cx,\n         SUSPICIOUS_OPERATION_GROUPINGS,\n         span,\n-        \"This sequence of operators looks suspiciously like a bug.\",\n-        \"I think you meant\",\n+        \"this sequence of operators looks suspiciously like a bug\",\n+        \"did you mean\",\n         sugg,\n         applicability,\n     )"}, {"sha": "84ec2aa18abcc01336ddb8fd497b43a185a4fd59", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,8 +1,9 @@\n-use crate::utils::{match_def_path, match_trait_method, path_to_local_id, paths, span_lint};\n+use crate::utils::{is_diagnostic_assoc_item, match_def_path, path_to_local_id, paths, span_lint};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::sym;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for uses of `to_string()` in `Display` traits.\n@@ -92,7 +93,8 @@ impl LateLintPass<'_> for ToStringInDisplay {\n             if let Some(self_hir_id) = self.self_hir_id;\n             if let ExprKind::MethodCall(ref path, _, args, _) = expr.kind;\n             if path.ident.name == sym!(to_string);\n-            if match_trait_method(cx, expr, &paths::TO_STRING);\n+            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+            if is_diagnostic_assoc_item(cx, expr_def_id, sym::ToString);\n             if path_to_local_id(&args[0], self_hir_id);\n             then {\n                 span_lint("}, {"sha": "dc938ed02383dc0513ddbd2ab87a2171723c5cdc", "filename": "clippy_lints/src/transmute.rs", "status": "removed", "additions": 0, "deletions": 763, "changes": 763, "blob_url": "https://github.com/rust-lang/rust/blob/36a27ecaacad74f69b21a12bc66b826f11f2d44e/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a27ecaacad74f69b21a12bc66b826f11f2d44e/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=36a27ecaacad74f69b21a12bc66b826f11f2d44e", "patch": "@@ -1,763 +0,0 @@\n-use crate::utils::{\n-    in_constant, is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, sugg,\n-};\n-use if_chain::if_chain;\n-use rustc_ast as ast;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Mutability, QPath, TyKind, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, cast::CastKind, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::DUMMY_SP;\n-use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n-use std::borrow::Cow;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes that can't ever be correct on any\n-    /// architecture.\n-    ///\n-    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n-    ///\n-    /// **Known problems:** When accessing C, users might want to store pointer\n-    /// sized objects in `extradata` arguments to save an allocation.\n-    ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// let ptr: *const T = core::intrinsics::transmute('x')\n-    /// ```\n-    pub WRONG_TRANSMUTE,\n-    correctness,\n-    \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n-}\n-\n-// FIXME: Move this to `complexity` again, after #5343 is fixed\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes to the original type of the object\n-    /// and transmutes that could be a cast.\n-    ///\n-    /// **Why is this bad?** Readability. The code tricks people into thinking that\n-    /// something complex is going on.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n-    /// ```\n-    pub USELESS_TRANSMUTE,\n-    nursery,\n-    \"transmutes that have the same to and from types or could be a cast/coercion\"\n-}\n-\n-// FIXME: Merge this lint with USELESS_TRANSMUTE once that is out of the nursery.\n-declare_clippy_lint! {\n-    /// **What it does:**Checks for transmutes that could be a pointer cast.\n-    ///\n-    /// **Why is this bad?** Readability. The code tricks people into thinking that\n-    /// something complex is going on.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// # let p: *const [i32] = &[];\n-    /// unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # let p: *const [i32] = &[];\n-    /// p as *const [u16];\n-    /// ```\n-    pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-    complexity,\n-    \"transmutes that could be a pointer cast\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n-    ///\n-    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n-    /// pointer to that type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// core::intrinsics::transmute(t) // where the result type is the same as\n-    ///                                // `*t` or `&t`'s\n-    /// ```\n-    pub CROSSPOINTER_TRANSMUTE,\n-    complexity,\n-    \"transmutes that have to or from types that are a pointer to the other\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a pointer to a reference.\n-    ///\n-    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n-    ///\n-    /// **Known problems:**\n-    /// - `mem::transmute` in statics and constants is stable from Rust 1.46.0,\n-    /// while dereferencing raw pointer is not stable yet.\n-    /// If you need to do this in those places,\n-    /// you would have to use `transmute` instead.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// unsafe {\n-    ///     let _: &T = std::mem::transmute(p); // where p: *const T\n-    /// }\n-    ///\n-    /// // can be written:\n-    /// let _: &T = &*p;\n-    /// ```\n-    pub TRANSMUTE_PTR_TO_REF,\n-    complexity,\n-    \"transmutes from a pointer to a reference type\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a `char`.\n-    ///\n-    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n-    ///\n-    /// **Known problems:**\n-    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n-    /// as it needs to validate the input.\n-    /// If you are certain that the input is always a valid Unicode scalar value,\n-    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n-    /// but has a semantically meaningful name.\n-    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n-    ///\n-    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n-    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = 1_u32;\n-    /// unsafe {\n-    ///     let _: char = std::mem::transmute(x); // where x: u32\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _ = std::char::from_u32(x).unwrap();\n-    /// ```\n-    pub TRANSMUTE_INT_TO_CHAR,\n-    complexity,\n-    \"transmutes from an integer to a `char`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n-    ///\n-    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n-    ///\n-    /// **Known problems:**\n-    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n-    /// as it needs to validate the input.\n-    /// If you are certain that the input is always a valid UTF-8,\n-    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n-    /// but has a semantically meaningful name.\n-    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n-    ///\n-    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n-    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let b: &[u8] = &[1_u8, 2_u8];\n-    /// unsafe {\n-    ///     let _: &str = std::mem::transmute(b); // where b: &[u8]\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _ = std::str::from_utf8(b).unwrap();\n-    /// ```\n-    pub TRANSMUTE_BYTES_TO_STR,\n-    complexity,\n-    \"transmutes from a `&[u8]` to a `&str`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n-    ///\n-    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = 1_u8;\n-    /// unsafe {\n-    ///     let _: bool = std::mem::transmute(x); // where x: u8\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: bool = x != 0;\n-    /// ```\n-    pub TRANSMUTE_INT_TO_BOOL,\n-    complexity,\n-    \"transmutes from an integer to a `bool`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a float.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n-    /// and safe.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// unsafe {\n-    ///     let _: f32 = std::mem::transmute(1_u32); // where x: u32\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: f32 = f32::from_bits(1_u32);\n-    /// ```\n-    pub TRANSMUTE_INT_TO_FLOAT,\n-    complexity,\n-    \"transmutes from an integer to a float\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a float to an integer.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `to_bits` is intuitive\n-    /// and safe.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// unsafe {\n-    ///     let _: u32 = std::mem::transmute(1f32);\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: u32 = 1f32.to_bits();\n-    /// ```\n-    pub TRANSMUTE_FLOAT_TO_INT,\n-    complexity,\n-    \"transmutes from a float to an integer\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n-    /// from a reference to a reference.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n-    /// written as casts.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let ptr = &1u32 as *const u32;\n-    /// unsafe {\n-    ///     // pointer-to-pointer transmute\n-    ///     let _: *const f32 = std::mem::transmute(ptr);\n-    ///     // ref-ref transmute\n-    ///     let _: &f32 = std::mem::transmute(&1u32);\n-    /// }\n-    /// // These can be respectively written:\n-    /// let _ = ptr as *const f32;\n-    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n-    /// ```\n-    pub TRANSMUTE_PTR_TO_PTR,\n-    complexity,\n-    \"transmutes from a pointer to a pointer / a reference to a reference\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes between collections whose\n-    /// types have different ABI, size or alignment.\n-    ///\n-    /// **Why is this bad?** This is undefined behavior.\n-    ///\n-    /// **Known problems:** Currently, we cannot know whether a type is a\n-    /// collection, so we just lint the ones that come with `std`.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // different size, therefore likely out-of-bounds memory access\n-    /// // You absolutely do not want this in your code!\n-    /// unsafe {\n-    ///     std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n-    /// };\n-    /// ```\n-    ///\n-    /// You must always iterate, map and collect the values:\n-    ///\n-    /// ```rust\n-    /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n-    /// ```\n-    pub UNSOUND_COLLECTION_TRANSMUTE,\n-    correctness,\n-    \"transmute between collections of layout-incompatible types\"\n-}\n-\n-declare_lint_pass!(Transmute => [\n-    CROSSPOINTER_TRANSMUTE,\n-    TRANSMUTE_PTR_TO_REF,\n-    TRANSMUTE_PTR_TO_PTR,\n-    USELESS_TRANSMUTE,\n-    WRONG_TRANSMUTE,\n-    TRANSMUTE_INT_TO_CHAR,\n-    TRANSMUTE_BYTES_TO_STR,\n-    TRANSMUTE_INT_TO_BOOL,\n-    TRANSMUTE_INT_TO_FLOAT,\n-    TRANSMUTE_FLOAT_TO_INT,\n-    UNSOUND_COLLECTION_TRANSMUTE,\n-    TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-]);\n-\n-// used to check for UNSOUND_COLLECTION_TRANSMUTE\n-static COLLECTIONS: &[&[&str]] = &[\n-    &paths::VEC,\n-    &paths::VEC_DEQUE,\n-    &paths::BINARY_HEAP,\n-    &paths::BTREESET,\n-    &paths::BTREEMAP,\n-    &paths::HASHSET,\n-    &paths::HASHMAP,\n-];\n-impl<'tcx> LateLintPass<'tcx> for Transmute {\n-    #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n-            if let ExprKind::Path(ref qpath) = path_expr.kind;\n-            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::TRANSMUTE);\n-            then {\n-                // Avoid suggesting from/to bits and dereferencing raw pointers in const contexts.\n-                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n-                // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n-                let const_context = in_constant(cx, e.hir_id);\n-\n-                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n-                let to_ty = cx.typeck_results().expr_ty(e);\n-\n-                match (&from_ty.kind(), &to_ty.kind()) {\n-                    _ if from_ty == to_ty => span_lint(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                    ),\n-                    (ty::Ref(_, rty, rty_mutbl), ty::RawPtr(ptr_ty)) => span_lint_and_then(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        \"transmute from a reference to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let rty_and_mut = ty::TypeAndMut {\n-                                    ty: rty,\n-                                    mutbl: *rty_mutbl,\n-                                };\n-\n-                                let sugg = if *ptr_ty == rty_and_mut {\n-                                    arg.as_ty(to_ty)\n-                                } else {\n-                                    arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n-                                };\n-\n-                                diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                            }\n-                        },\n-                    ),\n-                    (ty::Int(_) | ty::Uint(_), ty::RawPtr(_)) => span_lint_and_then(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        \"transmute from an integer to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"try\",\n-                                    arg.as_ty(&to_ty.to_string()).to_string(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    ),\n-                    (ty::Float(_) | ty::Char, ty::Ref(..) | ty::RawPtr(_)) => span_lint(\n-                        cx,\n-                        WRONG_TRANSMUTE,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                    ),\n-                    (ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                        cx,\n-                        CROSSPOINTER_TRANSMUTE,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                    ),\n-                    (_, ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                        cx,\n-                        CROSSPOINTER_TRANSMUTE,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                    ),\n-                    (ty::RawPtr(from_pty), ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_PTR_TO_REF,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a pointer type (`{}`) to a reference type \\\n-                             (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                        |diag| {\n-                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let (deref, cast) = if *mutbl == Mutability::Mut {\n-                                (\"&mut *\", \"*mut\")\n-                            } else {\n-                                (\"&*\", \"*const\")\n-                            };\n-\n-                            let arg = if from_pty.ty == *to_ref_ty {\n-                                arg\n-                            } else {\n-                                arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n-                            };\n-\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"try\",\n-                                sugg::make_unop(deref, arg).to_string(),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n-                        span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_INT_TO_CHAR,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a `char`\", from_ty),\n-                            |diag| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let arg = if let ty::Int(_) = from_ty.kind() {\n-                                    arg.as_ty(ast::UintTy::U32.name_str())\n-                                } else {\n-                                    arg\n-                                };\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"consider using\",\n-                                    format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n-                                    Applicability::Unspecified,\n-                                );\n-                            },\n-                        )\n-                    },\n-                    (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n-                        if_chain! {\n-                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n-                            if let ty::Uint(ty::UintTy::U8) = slice_ty.kind();\n-                            if from_mutbl == to_mutbl;\n-                            then {\n-                                let postfix = if *from_mutbl == Mutability::Mut {\n-                                    \"_mut\"\n-                                } else {\n-                                    \"\"\n-                                };\n-\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    TRANSMUTE_BYTES_TO_STR,\n-                                    e.span,\n-                                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                    \"consider using\",\n-                                    format!(\n-                                        \"std::str::from_utf8{}({}).unwrap()\",\n-                                        postfix,\n-                                        snippet(cx, args[0].span, \"..\"),\n-                                    ),\n-                                    Applicability::Unspecified,\n-                                );\n-                            } else {\n-                                if (cx.tcx.erase_regions(from_ty) != cx.tcx.erase_regions(to_ty))\n-                                    && !const_context {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        TRANSMUTE_PTR_TO_PTR,\n-                                        e.span,\n-                                        \"transmute from a reference to a reference\",\n-                                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                            let ty_from_and_mut = ty::TypeAndMut {\n-                                                ty: ty_from,\n-                                                mutbl: *from_mutbl\n-                                            };\n-                                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n-                                            let sugg_paren = arg\n-                                                .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n-                                                .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n-                                            let sugg = if *to_mutbl == Mutability::Mut {\n-                                                sugg_paren.mut_addr_deref()\n-                                            } else {\n-                                                sugg_paren.addr_deref()\n-                                            };\n-                                            diag.span_suggestion(\n-                                                e.span,\n-                                                \"try\",\n-                                                sugg.to_string(),\n-                                                Applicability::Unspecified,\n-                                            );\n-                                        },\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (ty::RawPtr(_), ty::RawPtr(to_ty)) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_PTR_TO_PTR,\n-                        e.span,\n-                        \"transmute from a pointer to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n-                                diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                            }\n-                        },\n-                    ),\n-                    (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n-                        span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_INT_TO_BOOL,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n-                            |diag| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"consider using\",\n-                                    sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            },\n-                        )\n-                    },\n-                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_INT_TO_FLOAT,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                        |diag| {\n-                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let arg = if let ty::Int(int_ty) = from_ty.kind() {\n-                                arg.as_ty(format!(\n-                                    \"u{}\",\n-                                    int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n-                                ))\n-                            } else {\n-                                arg\n-                            };\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"consider using\",\n-                                format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_FLOAT_TO_INT,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                        |diag| {\n-                            let mut expr = &args[0];\n-                            let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n-\n-                            if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                                expr = &inner_expr;\n-                            }\n-\n-                            if_chain! {\n-                                // if the expression is a float literal and it is unsuffixed then\n-                                // add a suffix so the suggestion is valid and unambiguous\n-                                let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n-                                if let ExprKind::Lit(lit) = &expr.kind;\n-                                if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n-                                then {\n-                                    match arg {\n-                                        sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n-                                        _ => arg = sugg::Sugg::NonParen(op)\n-                                    }\n-                                }\n-                            }\n-\n-                            arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n-\n-                            // cast the result of `to_bits` if `to_ty` is signed\n-                            arg = if let ty::Int(int_ty) = to_ty.kind() {\n-                                arg.as_ty(int_ty.name_str().to_string())\n-                            } else {\n-                                arg\n-                            };\n-\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"consider using\",\n-                                arg.to_string(),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n-                        if from_adt.did != to_adt.did ||\n-                                !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n-                            return;\n-                        }\n-                        if from_substs.types().zip(to_substs.types())\n-                                              .any(|(from_ty, to_ty)| is_layout_incompatible(cx, from_ty, to_ty)) {\n-                            span_lint(\n-                                cx,\n-                                UNSOUND_COLLECTION_TRANSMUTE,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n-                                    from_ty,\n-                                    to_ty\n-                                )\n-                            );\n-                        }\n-                    },\n-                    (_, _) if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n-                            from_ty,\n-                            to_ty\n-                        ),\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n-                                diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n-                            }\n-                        }\n-                    ),\n-                    _ => {\n-                        return;\n-                    },\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n-/// not available , use\n-/// the type's `ToString` implementation. In weird cases it could lead to types\n-/// with invalid `'_`\n-/// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n-    let seg = last_path_segment(path);\n-    if_chain! {\n-        if let Some(ref params) = seg.args;\n-        if !params.parenthesized;\n-        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).nth(1);\n-        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n-        then {\n-            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n-        }\n-    }\n-\n-    to_ref_ty.to_string()\n-}\n-\n-// check if the component types of the transmuted collection and the result have different ABI,\n-// size or alignment\n-fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n-    let empty_param_env = ty::ParamEnv::empty();\n-    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n-    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n-        return false;\n-    }\n-    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n-    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n-    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n-        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n-    } else {\n-        // no idea about layout, so don't lint\n-        false\n-    }\n-}\n-\n-/// Check if the type conversion can be expressed as a pointer cast, instead of\n-/// a transmute. In certain cases, including some invalid casts from array\n-/// references to pointers, this may cause additional errors to be emitted and/or\n-/// ICE error messages. This function will panic if that occurs.\n-fn can_be_expressed_as_pointer_cast<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    from_ty: Ty<'tcx>,\n-    to_ty: Ty<'tcx>,\n-) -> bool {\n-    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n-    matches!(\n-        check_cast(cx, e, from_ty, to_ty),\n-        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n-    )\n-}\n-\n-/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n-/// the cast. In certain cases, including some invalid casts from array references\n-/// to pointers, this may cause additional errors to be emitted and/or ICE error\n-/// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n-    let hir_id = e.hir_id;\n-    let local_def_id = hir_id.owner;\n-\n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n-\n-        // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(\n-            !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n-        );\n-\n-        if let Ok(check) = CastCheck::new(\n-            &fn_ctxt, e, from_ty, to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP, DUMMY_SP,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returing Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n-}"}, {"sha": "ce87defaa940622b1978111b9a8f35d7197e6288", "filename": "clippy_lints/src/transmute/crosspointer_transmute.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,37 @@\n+use super::CROSSPOINTER_TRANSMUTE;\n+use crate::utils::span_lint;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `crosspointer_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+            span_lint(\n+                cx,\n+                CROSSPOINTER_TRANSMUTE,\n+                e.span,\n+                &format!(\n+                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+            );\n+            true\n+        },\n+        (_, ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+            span_lint(\n+                cx,\n+                CROSSPOINTER_TRANSMUTE,\n+                e.span,\n+                &format!(\n+                    \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "c1870f5208b4502071501f30f50d604c0bf46b92", "filename": "clippy_lints/src/transmute/mod.rs", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,363 @@\n+mod crosspointer_transmute;\n+mod transmute_float_to_int;\n+mod transmute_int_to_bool;\n+mod transmute_int_to_char;\n+mod transmute_int_to_float;\n+mod transmute_ptr_to_ptr;\n+mod transmute_ptr_to_ref;\n+mod transmute_ref_to_ref;\n+mod transmutes_expressible_as_ptr_casts;\n+mod unsound_collection_transmute;\n+mod useless_transmute;\n+mod utils;\n+mod wrong_transmute;\n+\n+use crate::utils::{in_constant, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes that can't ever be correct on any\n+    /// architecture.\n+    ///\n+    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n+    ///\n+    /// **Known problems:** When accessing C, users might want to store pointer\n+    /// sized objects in `extradata` arguments to save an allocation.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let ptr: *const T = core::intrinsics::transmute('x')\n+    /// ```\n+    pub WRONG_TRANSMUTE,\n+    correctness,\n+    \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n+}\n+\n+// FIXME: Move this to `complexity` again, after #5343 is fixed\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes to the original type of the object\n+    /// and transmutes that could be a cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n+    /// ```\n+    pub USELESS_TRANSMUTE,\n+    nursery,\n+    \"transmutes that have the same to and from types or could be a cast/coercion\"\n+}\n+\n+// FIXME: Merge this lint with USELESS_TRANSMUTE once that is out of the nursery.\n+declare_clippy_lint! {\n+    /// **What it does:**Checks for transmutes that could be a pointer cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let p: *const [i32] = &[];\n+    /// unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let p: *const [i32] = &[];\n+    /// p as *const [u16];\n+    /// ```\n+    pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    complexity,\n+    \"transmutes that could be a pointer cast\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n+    ///\n+    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n+    /// pointer to that type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// core::intrinsics::transmute(t) // where the result type is the same as\n+    ///                                // `*t` or `&t`'s\n+    /// ```\n+    pub CROSSPOINTER_TRANSMUTE,\n+    complexity,\n+    \"transmutes that have to or from types that are a pointer to the other\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a reference.\n+    ///\n+    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+    ///\n+    /// **Known problems:**\n+    /// - `mem::transmute` in statics and constants is stable from Rust 1.46.0,\n+    /// while dereferencing raw pointer is not stable yet.\n+    /// If you need to do this in those places,\n+    /// you would have to use `transmute` instead.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// unsafe {\n+    ///     let _: &T = std::mem::transmute(p); // where p: *const T\n+    /// }\n+    ///\n+    /// // can be written:\n+    /// let _: &T = &*p;\n+    /// ```\n+    pub TRANSMUTE_PTR_TO_REF,\n+    complexity,\n+    \"transmutes from a pointer to a reference type\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `char`.\n+    ///\n+    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid Unicode scalar value,\n+    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n+    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1_u32;\n+    /// unsafe {\n+    ///     let _: char = std::mem::transmute(x); // where x: u32\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _ = std::char::from_u32(x).unwrap();\n+    /// ```\n+    pub TRANSMUTE_INT_TO_CHAR,\n+    complexity,\n+    \"transmutes from an integer to a `char`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n+    ///\n+    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid UTF-8,\n+    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n+    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let b: &[u8] = &[1_u8, 2_u8];\n+    /// unsafe {\n+    ///     let _: &str = std::mem::transmute(b); // where b: &[u8]\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _ = std::str::from_utf8(b).unwrap();\n+    /// ```\n+    pub TRANSMUTE_BYTES_TO_STR,\n+    complexity,\n+    \"transmutes from a `&[u8]` to a `&str`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n+    ///\n+    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1_u8;\n+    /// unsafe {\n+    ///     let _: bool = std::mem::transmute(x); // where x: u8\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: bool = x != 0;\n+    /// ```\n+    pub TRANSMUTE_INT_TO_BOOL,\n+    complexity,\n+    \"transmutes from an integer to a `bool`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a float.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// unsafe {\n+    ///     let _: f32 = std::mem::transmute(1_u32); // where x: u32\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: f32 = f32::from_bits(1_u32);\n+    /// ```\n+    pub TRANSMUTE_INT_TO_FLOAT,\n+    complexity,\n+    \"transmutes from an integer to a float\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a float to an integer.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `to_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// unsafe {\n+    ///     let _: u32 = std::mem::transmute(1f32);\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: u32 = 1f32.to_bits();\n+    /// ```\n+    pub TRANSMUTE_FLOAT_TO_INT,\n+    complexity,\n+    \"transmutes from a float to an integer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n+    /// from a reference to a reference.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n+    /// written as casts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let ptr = &1u32 as *const u32;\n+    /// unsafe {\n+    ///     // pointer-to-pointer transmute\n+    ///     let _: *const f32 = std::mem::transmute(ptr);\n+    ///     // ref-ref transmute\n+    ///     let _: &f32 = std::mem::transmute(&1u32);\n+    /// }\n+    /// // These can be respectively written:\n+    /// let _ = ptr as *const f32;\n+    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n+    /// ```\n+    pub TRANSMUTE_PTR_TO_PTR,\n+    complexity,\n+    \"transmutes from a pointer to a pointer / a reference to a reference\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between collections whose\n+    /// types have different ABI, size or alignment.\n+    ///\n+    /// **Why is this bad?** This is undefined behavior.\n+    ///\n+    /// **Known problems:** Currently, we cannot know whether a type is a\n+    /// collection, so we just lint the ones that come with `std`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // different size, therefore likely out-of-bounds memory access\n+    /// // You absolutely do not want this in your code!\n+    /// unsafe {\n+    ///     std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n+    /// };\n+    /// ```\n+    ///\n+    /// You must always iterate, map and collect the values:\n+    ///\n+    /// ```rust\n+    /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n+    /// ```\n+    pub UNSOUND_COLLECTION_TRANSMUTE,\n+    correctness,\n+    \"transmute between collections of layout-incompatible types\"\n+}\n+\n+declare_lint_pass!(Transmute => [\n+    CROSSPOINTER_TRANSMUTE,\n+    TRANSMUTE_PTR_TO_REF,\n+    TRANSMUTE_PTR_TO_PTR,\n+    USELESS_TRANSMUTE,\n+    WRONG_TRANSMUTE,\n+    TRANSMUTE_INT_TO_CHAR,\n+    TRANSMUTE_BYTES_TO_STR,\n+    TRANSMUTE_INT_TO_BOOL,\n+    TRANSMUTE_INT_TO_FLOAT,\n+    TRANSMUTE_FLOAT_TO_INT,\n+    UNSOUND_COLLECTION_TRANSMUTE,\n+    TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Transmute {\n+    #[allow(clippy::similar_names, clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n+            if let ExprKind::Path(ref qpath) = path_expr.kind;\n+            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::TRANSMUTE);\n+            then {\n+                // Avoid suggesting from/to bits and dereferencing raw pointers in const contexts.\n+                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n+                // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n+                let const_context = in_constant(cx, e.hir_id);\n+\n+                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let to_ty = cx.typeck_results().expr_ty(e);\n+\n+                // If useless_transmute is triggered, the other lints can be skipped.\n+                if useless_transmute::check(cx, e, from_ty, to_ty, args) {\n+                    return;\n+                }\n+\n+                let mut linted = wrong_transmute::check(cx, e, from_ty, to_ty);\n+                linted |= crosspointer_transmute::check(cx, e, from_ty, to_ty);\n+                linted |= transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, args, qpath);\n+                linted |= transmute_int_to_char::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_ref_to_ref::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_int_to_bool::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_int_to_float::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= transmute_float_to_int::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n+\n+                if !linted {\n+                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, args);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "562d880e39afbffefa4cc996a9bdf0793fc2c61a", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,65 @@\n+use super::TRANSMUTE_FLOAT_TO_INT;\n+use crate::utils::{span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_float_to_int` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_FLOAT_TO_INT,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                |diag| {\n+                    let mut expr = &args[0];\n+                    let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n+\n+                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n+                        expr = &inner_expr;\n+                    }\n+\n+                    if_chain! {\n+                        // if the expression is a float literal and it is unsuffixed then\n+                        // add a suffix so the suggestion is valid and unambiguous\n+                        let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n+                        if let ExprKind::Lit(lit) = &expr.kind;\n+                        if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n+                        then {\n+                            match arg {\n+                                sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n+                                _ => arg = sugg::Sugg::NonParen(op)\n+                            }\n+                        }\n+                    }\n+\n+                    arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n+\n+                    // cast the result of `to_bits` if `to_ty` is signed\n+                    arg = if let ty::Int(int_ty) = to_ty.kind() {\n+                        arg.as_ty(int_ty.name_str().to_string())\n+                    } else {\n+                        arg\n+                    };\n+\n+                    diag.span_suggestion(e.span, \"consider using\", arg.to_string(), Applicability::Unspecified);\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "5b609f906a3d7d9070ac98e7c55166318b222947", "filename": "clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,41 @@\n+use super::TRANSMUTE_INT_TO_BOOL;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use std::borrow::Cow;\n+\n+/// Checks for `transmute_int_to_bool` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_INT_TO_BOOL,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using\",\n+                        sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "29d2450618a7e7ef5b3c7554b2cd35e7aa513bc5", "filename": "clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,44 @@\n+use super::TRANSMUTE_INT_TO_CHAR;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_int_to_char` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_INT_TO_CHAR,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `char`\", from_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = if let ty::Int(_) = from_ty.kind() {\n+                        arg.as_ty(ast::UintTy::U32.name_str())\n+                    } else {\n+                        arg\n+                    };\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using\",\n+                        format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "f83fba8966a11ac1399300c57c5207e4ac48a64f", "filename": "clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,47 @@\n+use super::TRANSMUTE_INT_TO_FLOAT;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_int_to_float` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_INT_TO_FLOAT,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = if let ty::Int(int_ty) = from_ty.kind() {\n+                        arg.as_ty(format!(\n+                            \"u{}\",\n+                            int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n+                        ))\n+                    } else {\n+                        arg\n+                    };\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using\",\n+                        format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "f4e60a3020cf58367976647d181e7333012bbfdb", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ptr.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,35 @@\n+use super::TRANSMUTE_PTR_TO_PTR;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_ptr_to_ptr` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(_), ty::RawPtr(to_ty)) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_PTR_TO_PTR,\n+                e.span,\n+                \"transmute from a pointer to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n+                        diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "f5dbbbe33bc640e5e1ca474875d1a92cacc1498d", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,55 @@\n+use super::utils::get_type_snippet;\n+use super::TRANSMUTE_PTR_TO_REF;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_ptr_to_ref` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    qpath: &'tcx QPath<'_>,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(from_ptr_ty), ty::Ref(_, to_ref_ty, mutbl)) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_PTR_TO_REF,\n+                e.span,\n+                &format!(\n+                    \"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let (deref, cast) = if *mutbl == Mutability::Mut {\n+                        (\"&mut *\", \"*mut\")\n+                    } else {\n+                        (\"&*\", \"*const\")\n+                    };\n+\n+                    let arg = if from_ptr_ty.ty == *to_ref_ty {\n+                        arg\n+                    } else {\n+                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                    };\n+\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"try\",\n+                        sugg::make_unop(deref, arg).to_string(),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "01b00bb0a222998c1df3ce3b6f29c62ce04ffcab", "filename": "clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,85 @@\n+use super::{TRANSMUTE_BYTES_TO_STR, TRANSMUTE_PTR_TO_PTR};\n+use crate::utils::{snippet, span_lint_and_sugg, span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_bytes_to_str` and `transmute_ptr_to_ptr` lints.\n+/// Returns `true` if either one triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    let mut triggered = false;\n+\n+    if let (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) = (&from_ty.kind(), &to_ty.kind()) {\n+        if_chain! {\n+            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n+            if let ty::Uint(ty::UintTy::U8) = slice_ty.kind();\n+            if from_mutbl == to_mutbl;\n+            then {\n+                let postfix = if *from_mutbl == Mutability::Mut {\n+                    \"_mut\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    TRANSMUTE_BYTES_TO_STR,\n+                    e.span,\n+                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                    \"consider using\",\n+                    format!(\n+                        \"std::str::from_utf8{}({}).unwrap()\",\n+                        postfix,\n+                        snippet(cx, args[0].span, \"..\"),\n+                    ),\n+                    Applicability::Unspecified,\n+                );\n+                triggered = true;\n+            } else {\n+                if (cx.tcx.erase_regions(from_ty) != cx.tcx.erase_regions(to_ty))\n+                    && !const_context {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_PTR_TO_PTR,\n+                        e.span,\n+                        \"transmute from a reference to a reference\",\n+                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                            let ty_from_and_mut = ty::TypeAndMut {\n+                                ty: ty_from,\n+                                mutbl: *from_mutbl\n+                            };\n+                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n+                            let sugg_paren = arg\n+                                .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n+                                .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n+                            let sugg = if *to_mutbl == Mutability::Mut {\n+                                sugg_paren.mut_addr_deref()\n+                            } else {\n+                                sugg_paren.addr_deref()\n+                            };\n+                            diag.span_suggestion(\n+                                e.span,\n+                                \"try\",\n+                                sugg.to_string(),\n+                                Applicability::Unspecified,\n+                            );\n+                        },\n+                    );\n+\n+                    triggered = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    triggered\n+}"}, {"sha": "dea896622f11c5727efb8e9d7f83959832a9adb0", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,38 @@\n+use super::utils::can_be_expressed_as_pointer_cast;\n+use super::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+/// Checks for `transmutes_expressible_as_ptr_casts` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) {\n+        span_lint_and_then(\n+            cx,\n+            TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+            e.span,\n+            &format!(\n+                \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n+                from_ty, to_ty\n+            ),\n+            |diag| {\n+                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n+                    diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "503c5e0ff3822c19a0a723716eb290b18f20c203", "filename": "clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,48 @@\n+use super::utils::is_layout_incompatible;\n+use super::UNSOUND_COLLECTION_TRANSMUTE;\n+use crate::utils::{match_def_path, paths, span_lint};\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+// used to check for UNSOUND_COLLECTION_TRANSMUTE\n+static COLLECTIONS: &[&[&str]] = &[\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+    &paths::BINARY_HEAP,\n+    &paths::BTREESET,\n+    &paths::BTREEMAP,\n+    &paths::HASHSET,\n+    &paths::HASHMAP,\n+];\n+\n+/// Checks for `unsound_collection_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n+            if from_adt.did != to_adt.did || !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n+                return false;\n+            }\n+            if from_substs\n+                .types()\n+                .zip(to_substs.types())\n+                .any(|(from_ty, to_ty)| is_layout_incompatible(cx, from_ty, to_ty))\n+            {\n+                span_lint(\n+                    cx,\n+                    UNSOUND_COLLECTION_TRANSMUTE,\n+                    e.span,\n+                    &format!(\n+                        \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n+                        from_ty, to_ty\n+                    ),\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "83441514af0511fa529ec9fdca8a83de00ec6588", "filename": "clippy_lints/src/transmute/useless_transmute.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,73 @@\n+use super::USELESS_TRANSMUTE;\n+use crate::utils::{span_lint, span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `useless_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        _ if from_ty == to_ty => {\n+            span_lint(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+            );\n+            true\n+        },\n+        (ty::Ref(_, rty, rty_mutbl), ty::RawPtr(ptr_ty)) => {\n+            span_lint_and_then(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                \"transmute from a reference to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        let rty_and_mut = ty::TypeAndMut {\n+                            ty: rty,\n+                            mutbl: *rty_mutbl,\n+                        };\n+\n+                        let sugg = if *ptr_ty == rty_and_mut {\n+                            arg.as_ty(to_ty)\n+                        } else {\n+                            arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n+                        };\n+\n+                        diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        (ty::Int(_) | ty::Uint(_), ty::RawPtr(_)) => {\n+            span_lint_and_then(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                \"transmute from an integer to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        diag.span_suggestion(\n+                            e.span,\n+                            \"try\",\n+                            arg.as_ty(&to_ty.to_string()).to_string(),\n+                            Applicability::Unspecified,\n+                        );\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "55008d8ec3f16e8ab587766037c419bd3e103d2a", "filename": "clippy_lints/src/transmute/utils.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,104 @@\n+use crate::utils::{is_normalizable, last_path_segment, snippet};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, cast::CastKind, Ty};\n+use rustc_span::DUMMY_SP;\n+use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n+\n+/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// not available , use\n+/// the type's `ToString` implementation. In weird cases it could lead to types\n+/// with invalid `'_`\n+/// lifetime, but it should be rare.\n+pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n+    let seg = last_path_segment(path);\n+    if_chain! {\n+        if let Some(ref params) = seg.args;\n+        if !params.parenthesized;\n+        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).nth(1);\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n+        then {\n+            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n+        }\n+    }\n+\n+    to_ref_ty.to_string()\n+}\n+\n+// check if the component types of the transmuted collection and the result have different ABI,\n+// size or alignment\n+pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+    let empty_param_env = ty::ParamEnv::empty();\n+    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n+    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n+        return false;\n+    }\n+    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n+    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n+    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n+        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n+    } else {\n+        // no idea about layout, so don't lint\n+        false\n+    }\n+}\n+\n+/// Check if the type conversion can be expressed as a pointer cast, instead of\n+/// a transmute. In certain cases, including some invalid casts from array\n+/// references to pointers, this may cause additional errors to be emitted and/or\n+/// ICE error messages. This function will panic if that occurs.\n+pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> bool {\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n+    matches!(\n+        check_cast(cx, e, from_ty, to_ty),\n+        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n+    )\n+}\n+\n+/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n+/// the cast. In certain cases, including some invalid casts from array references\n+/// to pointers, this may cause additional errors to be emitted and/or ICE error\n+/// messages. This function will panic if that occurs.\n+fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n+    let hir_id = e.hir_id;\n+    let local_def_id = hir_id.owner;\n+\n+    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n+\n+        // If we already have errors, we can't be sure we can pointer cast.\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n+\n+        if let Ok(check) = CastCheck::new(\n+            &fn_ctxt, e, from_ty, to_ty,\n+            // We won't show any error to the user, so we don't care what the span is here.\n+            DUMMY_SP, DUMMY_SP,\n+        ) {\n+            let res = check.do_check(&fn_ctxt);\n+\n+            // do_check's documentation says that it might return Ok and create\n+            // errors in the fcx instead of returing Err in some cases. Those cases\n+            // should be filtered out before getting here.\n+            assert!(\n+                !fn_ctxt.errors_reported_since_creation(),\n+                \"`fn_ctxt` contained errors after cast check!\"\n+            );\n+\n+            res.ok()\n+        } else {\n+            None\n+        }\n+    })\n+}"}, {"sha": "d6d77f2c834569ebec9b106b23047b8b4e5e0249", "filename": "clippy_lints/src/transmute/wrong_transmute.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,22 @@\n+use super::WRONG_TRANSMUTE;\n+use crate::utils::span_lint;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `wrong_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Float(_) | ty::Char, ty::Ref(..) | ty::RawPtr(_)) => {\n+            span_lint(\n+                cx,\n+                WRONG_TRANSMUTE,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "2ba2b646f004fba256c2d05cf061ce2f2bdd6e80", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -27,7 +27,7 @@ declare_clippy_lint! {\n \n declare_lint_pass!(TransmutingNull => [TRANSMUTING_NULL]);\n \n-const LINT_MSG: &str = \"transmuting a known null pointer into a reference.\";\n+const LINT_MSG: &str = \"transmuting a known null pointer into a reference\";\n \n impl<'tcx> LateLintPass<'tcx> for TransmutingNull {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {"}, {"sha": "a7a511b21cf59020af650c10296ce43f9eecc7d8", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,114 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    self as hir, GenericArg, GenericBounds, GenericParamKind, HirId, Lifetime, MutTy, Mutability, Node, QPath,\n+    SyntheticTyParamKind, TyKind,\n+};\n+use rustc_lint::LateContext;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{match_path, paths, snippet, span_lint_and_sugg};\n+\n+use super::BORROWED_BOX;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, mut_ty: &MutTy<'_>) -> bool {\n+    match mut_ty.ty.kind {\n+        TyKind::Path(ref qpath) => {\n+            let hir_id = mut_ty.ty.hir_id;\n+            let def = cx.qpath_res(qpath, hir_id);\n+            if_chain! {\n+                if let Some(def_id) = def.opt_def_id();\n+                if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let [ref bx] = *path.segments;\n+                if let Some(ref params) = bx.args;\n+                if !params.parenthesized;\n+                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                });\n+                then {\n+                    if is_any_trait(inner) {\n+                        // Ignore `Box<Any>` types; see issue #1884 for details.\n+                        return false;\n+                    }\n+\n+                    let ltopt = if lt.is_elided() {\n+                        String::new()\n+                    } else {\n+                        format!(\"{} \", lt.name.ident().as_str())\n+                    };\n+\n+                    if mut_ty.mutbl == Mutability::Mut {\n+                        // Ignore `&mut Box<T>` types; see issue #2907 for\n+                        // details.\n+                        return false;\n+                    }\n+\n+                    // When trait objects or opaque types have lifetime or auto-trait bounds,\n+                    // we need to add parentheses to avoid a syntax error due to its ambiguity.\n+                    // Originally reported as the issue #3128.\n+                    let inner_snippet = snippet(cx, inner.span, \"..\");\n+                    let suggestion = match &inner.kind {\n+                        TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        TyKind::Path(qpath)\n+                            if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n+                                .map_or(false, |bounds| bounds.len() > 1) =>\n+                        {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BORROWED_BOX,\n+                        hir_ty.span,\n+                        \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                        \"try\",\n+                        suggestion,\n+                        // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n+                        // because the trait impls of it will break otherwise;\n+                        // and there may be other cases that result in invalid code.\n+                        // For example, type coercion doesn't work nicely.\n+                        Applicability::Unspecified,\n+                    );\n+                    return true;\n+                }\n+            };\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if given type is `Any` trait.\n+fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::TraitObject(ref traits, _) = t.kind;\n+        if !traits.is_empty();\n+        // Only Send/Sync can be used as additional traits, so it is enough to\n+        // check only the first trait.\n+        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n+    if_chain! {\n+        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n+        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n+        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n+        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n+        then {\n+            Some(generic_param.bounds)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "6aa98e435e1605df715f9389304be86a09d947a5", "filename": "clippy_lints/src/types/box_vec.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,25 @@\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_ty_param_diagnostic_item, span_lint_and_help};\n+\n+use super::BOX_VEC;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if Some(def_id) == cx.tcx.lang_items().owned_box()\n+        && is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some()\n+    {\n+        span_lint_and_help(\n+            cx,\n+            BOX_VEC,\n+            hir_ty.span,\n+            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+            None,\n+            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "47eb4ede4e422cb32017a6269fbefa0eac0c5695", "filename": "clippy_lints/src/types/linked_list.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,22 @@\n+use rustc_hir::{self as hir, def_id::DefId};\n+use rustc_lint::LateContext;\n+\n+use crate::utils::{match_def_path, paths, span_lint_and_help};\n+\n+use super::LINKEDLIST;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, def_id: DefId) -> bool {\n+    if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n+        span_lint_and_help(\n+            cx,\n+            LINKEDLIST,\n+            hir_ty.span,\n+            \"you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\",\n+            None,\n+            \"a `VecDeque` might work\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "13da768b0ca3e8ec6d467da4917d81279f745d80", "filename": "clippy_lints/src/types/mod.rs", "status": "renamed", "additions": 122, "deletions": 1433, "changes": 1555, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,25 +1,31 @@\n #![allow(rustc::default_hash_types)]\n \n+mod borrowed_box;\n+mod box_vec;\n+mod linked_list;\n+mod option_option;\n+mod rc_buffer;\n+mod redundant_allocation;\n+mod utils;\n+mod vec_box;\n+\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n use if_chain::if_chain;\n-use rustc_ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt,\n-    StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, MutTy, Node, QPath, Stmt, StmtKind, TraitFn, TraitItem,\n+    TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults, UintTy};\n-use rustc_semver::RustcVersion;\n+use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -30,13 +36,10 @@ use rustc_typeck::hir_ty_to_ty;\n \n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n-use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n-    is_type_diagnostic_item, last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args,\n-    multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt,\n-    snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg,\n-    span_lint_and_then, unsext,\n+    clip, comparisons, differing_macro_contexts, higher, indent_of, int_bits, is_isize_or_usize,\n+    is_type_diagnostic_item, match_path, multispan_sugg, reindent_multiline, sext, snippet, snippet_opt,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -287,56 +290,6 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n }\n \n-/// Checks if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext<'_>, qpath: &QPath<'_>, path: &[&str]) -> Option<Span> {\n-    let last = last_path_segment(qpath);\n-    if_chain! {\n-        if let Some(ref params) = last.args;\n-        if !params.parenthesized;\n-        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        });\n-        if let TyKind::Path(ref qpath) = ty.kind;\n-        if let Some(did) = cx.qpath_res(qpath, ty.hir_id).opt_def_id();\n-        if match_def_path(cx, did, path);\n-        then {\n-            return Some(ty.span);\n-        }\n-    }\n-    None\n-}\n-\n-fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if match_type_parameter(cx, qpath, &paths::STRING).is_some() {\n-        return Some(\"str\");\n-    }\n-    if match_type_parameter(cx, qpath, &paths::OS_STRING).is_some() {\n-        return Some(\"std::ffi::OsStr\");\n-    }\n-    if match_type_parameter(cx, qpath, &paths::PATH_BUF).is_some() {\n-        return Some(\"std::path::Path\");\n-    }\n-    None\n-}\n-\n-fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n-    let last = last_path_segment(qpath);\n-    if_chain! {\n-        if let Some(ref params) = last.args;\n-        if !params.parenthesized;\n-        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        });\n-        if let TyKind::Rptr(..) = ty.kind;\n-        then {\n-            return Some(ty.span);\n-        }\n-    }\n-    None\n-}\n-\n impl Types {\n     pub fn new(vec_box_size_threshold: u64) -> Self {\n         Self { vec_box_size_threshold }\n@@ -355,9 +308,7 @@ impl Types {\n     /// Recursively check for `TypePass` lints in the given type. Stop at the first\n     /// lint found.\n     ///\n-    /// The parameter `is_local` distinguishes the context of the type; types from\n-    /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-    #[allow(clippy::too_many_lines)]\n+    /// The parameter `is_local` distinguishes the context of the type.\n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n         if hir_ty.span.from_expansion() {\n             return;\n@@ -367,222 +318,16 @@ impl Types {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Box<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n-                            span_lint_and_help(\n-                                cx,\n-                                BOX_VEC,\n-                                hir_ty.span,\n-                                \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                None,\n-                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-                        if let Some(span) = match_type_parameter(cx, qpath, &paths::RC) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Rc<T>>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if match_type_parameter(cx, qpath, &paths::BOX).is_some() {\n-                            let box_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n-                                _ => return,\n-                            };\n-                            let inner_span = match &last_path_segment(&box_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Box<T>>`\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<{}>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Rc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n-                            let vec_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n-                                _ => return,\n-                            };\n-                            let inner_span = match &last_path_segment(&vec_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Arc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if match_type_parameter(cx, qpath, &paths::VEC).is_some() {\n-                            let vec_ty = match &last_path_segment(qpath).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => match &ty.kind {\n-                                    TyKind::Path(qpath) => qpath,\n-                                    _ => return,\n-                                },\n-                                _ => return,\n-                            };\n-                            let inner_span = match &last_path_segment(&vec_ty).args.unwrap().args[0] {\n-                                GenericArg::Type(ty) => ty.span,\n-                                _ => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Arc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n-                        if_chain! {\n-                            // Get the _ part of Vec<_>\n-                            if let Some(ref last) = last_path_segment(qpath).args;\n-                            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            // ty is now _ at this point\n-                            if let TyKind::Path(ref ty_qpath) = ty.kind;\n-                            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n-                            if let Some(def_id) = res.opt_def_id();\n-                            if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                            // At this point, we know ty is Box<T>, now get T\n-                            if let Some(ref last) = last_path_segment(ty_qpath).args;\n-                            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n-                            if !ty_ty.has_escaping_bound_vars();\n-                            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n-                            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n-                            if ty_ty_size <= self.vec_box_size_threshold;\n-                            then {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    VEC_BOX,\n-                                    hir_ty.span,\n-                                    \"`Vec<T>` is already on the heap, the boxing is unnecessary.\",\n-                                    \"try\",\n-                                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                                return; // don't recurse into the type\n-                            }\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n-                        if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n-                            span_lint(\n-                                cx,\n-                                OPTION_OPTION,\n-                                hir_ty.span,\n-                                \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                                 enum if you need to distinguish all 3 cases\",\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n-                        span_lint_and_help(\n-                            cx,\n-                            LINKEDLIST,\n-                            hir_ty.span,\n-                            \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                            None,\n-                            \"a `VecDeque` might work\",\n-                        );\n-                        return; // don't recurse into the type\n+                    let mut triggered = false;\n+                    triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n+                    triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= linked_list::check(cx, hir_ty, def_id);\n+\n+                    if triggered {\n+                        return;\n                     }\n                 }\n                 match *qpath {\n@@ -627,8 +372,11 @@ impl Types {\n                     QPath::LangItem(..) => {},\n                 }\n             },\n-            TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n-            // recurse\n+            TyKind::Rptr(ref lt, ref mut_ty) => {\n+                if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n+                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                }\n+            },\n             TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n                 self.check_ty(cx, ty, is_local)\n             },\n@@ -640,115 +388,6 @@ impl Types {\n             _ => {},\n         }\n     }\n-\n-    fn check_ty_rptr(\n-        &mut self,\n-        cx: &LateContext<'_>,\n-        hir_ty: &hir::Ty<'_>,\n-        is_local: bool,\n-        lt: &Lifetime,\n-        mut_ty: &MutTy<'_>,\n-    ) {\n-        match mut_ty.ty.kind {\n-            TyKind::Path(ref qpath) => {\n-                let hir_id = mut_ty.ty.hir_id;\n-                let def = cx.qpath_res(qpath, hir_id);\n-                if_chain! {\n-                    if let Some(def_id) = def.opt_def_id();\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                    if let QPath::Resolved(None, ref path) = *qpath;\n-                    if let [ref bx] = *path.segments;\n-                    if let Some(ref params) = bx.args;\n-                    if !params.parenthesized;\n-                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                        GenericArg::Type(ty) => Some(ty),\n-                        _ => None,\n-                    });\n-                    then {\n-                        if is_any_trait(inner) {\n-                            // Ignore `Box<Any>` types; see issue #1884 for details.\n-                            return;\n-                        }\n-\n-                        let ltopt = if lt.is_elided() {\n-                            String::new()\n-                        } else {\n-                            format!(\"{} \", lt.name.ident().as_str())\n-                        };\n-\n-                        if mut_ty.mutbl == Mutability::Mut {\n-                            // Ignore `&mut Box<T>` types; see issue #2907 for\n-                            // details.\n-                            return;\n-                        }\n-\n-                        // When trait objects or opaque types have lifetime or auto-trait bounds,\n-                        // we need to add parentheses to avoid a syntax error due to its ambiguity.\n-                        // Originally reported as the issue #3128.\n-                        let inner_snippet = snippet(cx, inner.span, \"..\");\n-                        let suggestion = match &inner.kind {\n-                            TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            TyKind::Path(qpath)\n-                                if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n-                                    .map_or(false, |bounds| bounds.len() > 1) =>\n-                            {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n-                        };\n-                        span_lint_and_sugg(\n-                            cx,\n-                            BORROWED_BOX,\n-                            hir_ty.span,\n-                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                            \"try\",\n-                            suggestion,\n-                            // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n-                            // because the trait impls of it will break otherwise;\n-                            // and there may be other cases that result in invalid code.\n-                            // For example, type coercion doesn't work nicely.\n-                            Applicability::Unspecified,\n-                        );\n-                        return; // don't recurse into the type\n-                    }\n-                };\n-                self.check_ty(cx, &mut_ty.ty, is_local);\n-            },\n-            _ => self.check_ty(cx, &mut_ty.ty, is_local),\n-        }\n-    }\n-}\n-\n-// Returns true if given type is `Any` trait.\n-fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::TraitObject(ref traits, _) = t.kind;\n-        if !traits.is_empty();\n-        // Only Send/Sync can be used as additional traits, so it is enough to\n-        // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n-    if_chain! {\n-        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n-        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n-        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n-        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n-        then {\n-            Some(generic_param.bounds)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n declare_clippy_lint! {\n@@ -955,7 +594,10 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                     .iter()\n                     .filter(|arg| {\n                         if is_unit(cx.typeck_results().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n+                            !matches!(\n+                                &arg.kind,\n+                                ExprKind::Match(.., MatchSource::TryDesugar) | ExprKind::Path(..)\n+                            )\n                         } else {\n                             false\n                         }\n@@ -1029,850 +671,107 @@ fn lint_unit_args(cx: &LateContext<'_>, expr: &Expr<'_>, args_to_recover: &[&Exp\n                     if_chain! {\n                         if let ExprKind::Block(block, _) = arg.kind;\n                         if block.expr.is_none();\n-                        if let Some(last_stmt) = block.stmts.iter().last();\n-                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n-                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n-                        then {\n-                            Some((\n-                                last_stmt.span,\n-                                snip,\n-                            ))\n-                        }\n-                        else {\n-                            None\n-                        }\n-                    }\n-                })\n-                .for_each(|(span, sugg)| {\n-                    db.span_suggestion(\n-                        span,\n-                        \"remove the semicolon from the last statement in the block\",\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    or = \"or \";\n-                    applicability = Applicability::MaybeIncorrect;\n-                });\n-\n-            let arg_snippets: Vec<String> = args_to_recover\n-                .iter()\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n-                .iter()\n-                .filter(|arg| !is_empty_block(arg))\n-                .filter_map(|arg| snippet_opt(cx, arg.span))\n-                .collect();\n-\n-            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n-                let sugg = fmt_stmts_and_call(\n-                    cx,\n-                    expr,\n-                    &call_snippet,\n-                    &arg_snippets,\n-                    &arg_snippets_without_empty_blocks,\n-                );\n-\n-                if arg_snippets_without_empty_blocks.is_empty() {\n-                    db.multipart_suggestion(\n-                        &format!(\"use {}unit literal{} instead\", singular, plural),\n-                        args_to_recover\n-                            .iter()\n-                            .map(|arg| (arg.span, \"()\".to_string()))\n-                            .collect::<Vec<_>>(),\n-                        applicability,\n-                    );\n-                } else {\n-                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n-                    let empty_or_s = if plural { \"s\" } else { \"\" };\n-                    let it_or_them = if plural { \"them\" } else { \"it\" };\n-                    db.span_suggestion(\n-                        expr.span,\n-                        &format!(\n-                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n-                            or, empty_or_s, it_or_them\n-                        ),\n-                        sugg,\n-                        applicability,\n-                    );\n-                }\n-            }\n-        },\n-    );\n-}\n-\n-fn is_empty_block(expr: &Expr<'_>) -> bool {\n-    matches!(\n-        expr.kind,\n-        ExprKind::Block(\n-            Block {\n-                stmts: &[],\n-                expr: None,\n-                ..\n-            },\n-            _,\n-        )\n-    )\n-}\n-\n-fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n-    use rustc_span::hygiene::DesugaringKind;\n-    if let ExprKind::Call(ref callee, _) = expr.kind {\n-        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_unit(ty: Ty<'_>) -> bool {\n-    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n-}\n-\n-fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from any numerical to a float type where\n-    /// the receiving type cannot store all values from the original type without\n-    /// rounding errors. This possible rounding is to be expected, so this lint is\n-    /// `Allow` by default.\n-    ///\n-    /// Basically, this warns on casting any integer with 32 or more bits to `f32`\n-    /// or any 64-bit integer to `f64`.\n-    ///\n-    /// **Why is this bad?** It's not bad at all. But in some applications it can be\n-    /// helpful to know where precision loss can take place. This lint can help find\n-    /// those places in the code.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = u64::MAX;\n-    /// x as f64;\n-    /// ```\n-    pub CAST_PRECISION_LOSS,\n-    pedantic,\n-    \"casts that cause loss of precision, e.g., `x as f32` where `x: u64`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from a signed to an unsigned numerical\n-    /// type. In this case, negative values wrap around to large positive values,\n-    /// which can be quite surprising in practice. However, as the cast works as\n-    /// defined, this lint is `Allow` by default.\n-    ///\n-    /// **Why is this bad?** Possibly surprising results. You can activate this lint\n-    /// as a one-time check to see where numerical wrapping can arise.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let y: i8 = -1;\n-    /// y as u128; // will return 18446744073709551615\n-    /// ```\n-    pub CAST_SIGN_LOSS,\n-    pedantic,\n-    \"casts from signed types to unsigned types, e.g., `x as u32` where `x: i32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts between numerical types that may\n-    /// truncate large values. This is expected behavior, so the cast is `Allow` by\n-    /// default.\n-    ///\n-    /// **Why is this bad?** In some problem domains, it is good practice to avoid\n-    /// truncation. This lint can be activated to help assess where additional\n-    /// checks could be beneficial.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn as_u8(x: u64) -> u8 {\n-    ///     x as u8\n-    /// }\n-    /// ```\n-    pub CAST_POSSIBLE_TRUNCATION,\n-    pedantic,\n-    \"casts that may cause truncation of the value, e.g., `x as u8` where `x: u32`, or `x as i32` where `x: f32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts from an unsigned type to a signed type of\n-    /// the same size. Performing such a cast is a 'no-op' for the compiler,\n-    /// i.e., nothing is changed at the bit level, and the binary representation of\n-    /// the value is reinterpreted. This can cause wrapping if the value is too big\n-    /// for the target signed type. However, the cast works as defined, so this lint\n-    /// is `Allow` by default.\n-    ///\n-    /// **Why is this bad?** While such a cast is not bad in itself, the results can\n-    /// be surprising when this is not the intended behavior, as demonstrated by the\n-    /// example below.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// u32::MAX as i32; // will yield a value of `-1`\n-    /// ```\n-    pub CAST_POSSIBLE_WRAP,\n-    pedantic,\n-    \"casts that may cause wrapping around the value, e.g., `x as i32` where `x: u32` and `x > i32::MAX`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts between numerical types that may\n-    /// be replaced by safe conversion functions.\n-    ///\n-    /// **Why is this bad?** Rust's `as` keyword will perform many kinds of\n-    /// conversions, including silently lossy conversions. Conversion functions such\n-    /// as `i32::from` will only perform lossless conversions. Using the conversion\n-    /// functions prevents conversions from turning into silent lossy conversions if\n-    /// the types of the input expressions ever change, and make it easier for\n-    /// people reading the code to know that the conversion is lossless.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn as_u64(x: u8) -> u64 {\n-    ///     x as u64\n-    /// }\n-    /// ```\n-    ///\n-    /// Using `::from` would look like this:\n-    ///\n-    /// ```rust\n-    /// fn as_u64(x: u8) -> u64 {\n-    ///     u64::from(x)\n-    /// }\n-    /// ```\n-    pub CAST_LOSSLESS,\n-    pedantic,\n-    \"casts using `as` that are known to be lossless, e.g., `x as u64` where `x: u8`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts to the same type, casts of int literals to integer types\n-    /// and casts of float literals to float types.\n-    ///\n-    /// **Why is this bad?** It's just unnecessary.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let _ = 2i32 as i32;\n-    /// let _ = 0.5 as f32;\n-    /// ```\n-    ///\n-    /// Better:\n-    ///\n-    /// ```rust\n-    /// let _ = 2_i32;\n-    /// let _ = 0.5_f32;\n-    /// ```\n-    pub UNNECESSARY_CAST,\n-    complexity,\n-    \"cast to the same type, e.g., `x as i32` where `x: i32`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts, using `as` or `pointer::cast`,\n-    /// from a less-strictly-aligned pointer to a more-strictly-aligned pointer\n-    ///\n-    /// **Why is this bad?** Dereferencing the resulting pointer may be undefined\n-    /// behavior.\n-    ///\n-    /// **Known problems:** Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n-    /// on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n-    /// u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let _ = (&1u8 as *const u8) as *const u16;\n-    /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n-    ///\n-    /// (&1u8 as *const u8).cast::<u16>();\n-    /// (&mut 1u8 as *mut u8).cast::<u16>();\n-    /// ```\n-    pub CAST_PTR_ALIGNMENT,\n-    pedantic,\n-    \"cast from a pointer to a more-strictly-aligned pointer\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of function pointers to something other than usize\n-    ///\n-    /// **Why is this bad?**\n-    /// Casting a function pointer to anything other than usize/isize is not portable across\n-    /// architectures, because you end up losing bits if the target type is too small or end up with a\n-    /// bunch of extra bits that waste space and add more instructions to the final binary than\n-    /// strictly necessary for the problem\n-    ///\n-    /// Casting to isize also doesn't make sense since there are no signed addresses.\n-    ///\n-    /// **Example**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn fun() -> i32 { 1 }\n-    /// let a = fun as i64;\n-    ///\n-    /// // Good\n-    /// fn fun2() -> i32 { 1 }\n-    /// let a = fun2 as usize;\n-    /// ```\n-    pub FN_TO_NUMERIC_CAST,\n-    style,\n-    \"casting a function pointer to a numeric type other than usize\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of a function pointer to a numeric type not wide enough to\n-    /// store address.\n-    ///\n-    /// **Why is this bad?**\n-    /// Such a cast discards some bits of the function's address. If this is intended, it would be more\n-    /// clearly expressed by casting to usize first, then casting the usize to the intended type (with\n-    /// a comment) to perform the truncation.\n-    ///\n-    /// **Example**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn fn1() -> i16 {\n-    ///     1\n-    /// };\n-    /// let _ = fn1 as i32;\n-    ///\n-    /// // Better: Cast to usize first, then comment with the reason for the truncation\n-    /// fn fn2() -> i16 {\n-    ///     1\n-    /// };\n-    /// let fn_ptr = fn2 as usize;\n-    /// let fn_ptr_truncated = fn_ptr as i32;\n-    /// ```\n-    pub FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-    style,\n-    \"casting a function pointer to a numeric type not wide enough to store the address\"\n-}\n-\n-/// Returns the size in bits of an integral type.\n-/// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n-    match typ.kind() {\n-        ty::Int(i) => match i {\n-            IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        },\n-        ty::Uint(i) => match i {\n-            UintTy::Usize => tcx.data_layout.pointer_size.bits(),\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        },\n-        _ => 0,\n-    }\n-}\n-\n-fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n-}\n-\n-fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n-    let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n-    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n-    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n-    let from_nbits_str = if arch_dependent {\n-        \"64\".to_owned()\n-    } else if is_isize_or_usize(cast_from) {\n-        \"32 or 64\".to_owned()\n-    } else {\n-        int_ty_to_nbits(cast_from, cx.tcx).to_string()\n-    };\n-    span_lint(\n-        cx,\n-        CAST_PRECISION_LOSS,\n-        expr.span,\n-        &format!(\n-            \"casting `{0}` to `{1}` causes a loss of precision {2}(`{0}` is {3} bits wide, \\\n-             but `{1}`'s mantissa is only {4} bits wide)\",\n-            cast_from,\n-            if cast_to_f64 { \"f64\" } else { \"f32\" },\n-            if arch_dependent { arch_dependent_str } else { \"\" },\n-            from_nbits_str,\n-            mantissa_nbits\n-        ),\n-    );\n-}\n-\n-fn should_strip_parens(op: &Expr<'_>, snip: &str) -> bool {\n-    if let ExprKind::Binary(_, _, _) = op.kind {\n-        if snip.starts_with('(') && snip.ends_with(')') {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n-    if in_constant(cx, expr.hir_id) {\n-        return;\n-    }\n-    // The suggestion is to use a function call, so if the original expression\n-    // has parens on the outside, they are no longer needed.\n-    let mut applicability = Applicability::MachineApplicable;\n-    let opt = snippet_opt(cx, op.span);\n-    let sugg = opt.as_ref().map_or_else(\n-        || {\n-            applicability = Applicability::HasPlaceholders;\n-            \"..\"\n-        },\n-        |snip| {\n-            if should_strip_parens(op, snip) {\n-                &snip[1..snip.len() - 1]\n-            } else {\n-                snip.as_str()\n-            }\n-        },\n-    );\n-\n-    span_lint_and_sugg(\n-        cx,\n-        CAST_LOSSLESS,\n-        expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may become silently lossy if you later change the type\",\n-            cast_from, cast_to\n-        ),\n-        \"try\",\n-        format!(\"{}::from({})\", cast_to, sugg),\n-        applicability,\n-    );\n-}\n-\n-enum ArchSuffix {\n-    _32,\n-    _64,\n-    None,\n-}\n-\n-fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    if !cast_from.is_signed() || cast_to.is_signed() {\n-        return;\n-    }\n-\n-    // don't lint for positive constants\n-    let const_val = constant(cx, &cx.typeck_results(), op);\n-    if_chain! {\n-        if let Some((Constant::Int(n), _)) = const_val;\n-        if let ty::Int(ity) = *cast_from.kind();\n-        if sext(cx.tcx, n, ity) >= 0;\n-        then {\n-            return\n-        }\n-    }\n-\n-    // don't lint for the result of methods that always return non-negative values\n-    if let ExprKind::MethodCall(ref path, _, _, _) = op.kind {\n-        let mut method_name = path.ident.name.as_str();\n-        let allowed_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n-\n-        if_chain! {\n-            if method_name == \"unwrap\";\n-            if let Some(arglist) = method_chain_args(op, &[\"unwrap\"]);\n-            if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n-            then {\n-                method_name = inner_path.ident.name.as_str();\n-            }\n-        }\n-\n-        if allowed_methods.iter().any(|&name| method_name == name) {\n-            return;\n-        }\n-    }\n-\n-    span_lint(\n-        cx,\n-        CAST_SIGN_LOSS,\n-        expr.span,\n-        &format!(\n-            \"casting `{}` to `{}` may lose the sign of the value\",\n-            cast_from, cast_to\n-        ),\n-    );\n-}\n-\n-fn check_truncation_and_wrapping(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n-    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n-    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n-    let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-    let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n-        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n-            (true, true) | (false, false) => (\n-                to_nbits < from_nbits,\n-                ArchSuffix::None,\n-                to_nbits == from_nbits && cast_unsigned_to_signed,\n-                ArchSuffix::None,\n-            ),\n-            (true, false) => (\n-                to_nbits <= 32,\n-                if to_nbits == 32 {\n-                    ArchSuffix::_64\n-                } else {\n-                    ArchSuffix::None\n-                },\n-                to_nbits <= 32 && cast_unsigned_to_signed,\n-                ArchSuffix::_32,\n-            ),\n-            (false, true) => (\n-                from_nbits == 64,\n-                ArchSuffix::_32,\n-                cast_unsigned_to_signed,\n-                if from_nbits == 64 {\n-                    ArchSuffix::_64\n-                } else {\n-                    ArchSuffix::_32\n-                },\n-            ),\n-        };\n-    if span_truncation {\n-        span_lint(\n-            cx,\n-            CAST_POSSIBLE_TRUNCATION,\n-            expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may truncate the value{}\",\n-                cast_from,\n-                cast_to,\n-                match suffix_truncation {\n-                    ArchSuffix::_32 => arch_32_suffix,\n-                    ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\",\n-                }\n-            ),\n-        );\n-    }\n-    if span_wrap {\n-        span_lint(\n-            cx,\n-            CAST_POSSIBLE_WRAP,\n-            expr.span,\n-            &format!(\n-                \"casting `{}` to `{}` may wrap around the value{}\",\n-                cast_from,\n-                cast_to,\n-                match suffix_wrap {\n-                    ArchSuffix::_32 => arch_32_suffix,\n-                    ArchSuffix::_64 => arch_64_suffix,\n-                    ArchSuffix::None => \"\",\n-                }\n-            ),\n-        );\n-    }\n-}\n-\n-fn check_lossless(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n-    let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-    let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-    if !is_isize_or_usize(cast_from) && !is_isize_or_usize(cast_to) && from_nbits < to_nbits && !cast_signed_to_unsigned\n-    {\n-        span_lossless_lint(cx, expr, op, cast_from, cast_to);\n-    }\n-}\n-\n-declare_lint_pass!(Casts => [\n-    CAST_PRECISION_LOSS,\n-    CAST_SIGN_LOSS,\n-    CAST_POSSIBLE_TRUNCATION,\n-    CAST_POSSIBLE_WRAP,\n-    CAST_LOSSLESS,\n-    UNNECESSARY_CAST,\n-    CAST_PTR_ALIGNMENT,\n-    FN_TO_NUMERIC_CAST,\n-    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-]);\n-\n-// Check if the given type is either `core::ffi::c_void` or\n-// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-/// Returns the mantissa bits wide of a fp type.\n-/// Will return 0 if the type is not a fp\n-fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.kind() {\n-        ty::Float(FloatTy::F32) => 23,\n-        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n-        _ => 0,\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for Casts {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-        if let ExprKind::Cast(ref ex, cast_to) = expr.kind {\n-            if is_hir_ty_cfg_dependant(cx, cast_to) {\n-                return;\n-            }\n-            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n-            lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let Some(lit) = get_numeric_literal(ex) {\n-                let literal_str = snippet_opt(cx, ex.span).unwrap_or_default();\n-\n-                if_chain! {\n-                    if let LitKind::Int(n, _) = lit.node;\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if cast_to.is_floating_point();\n-                    if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n-                    let from_nbits = 128 - n.leading_zeros();\n-                    let to_nbits = fp_ty_mantissa_nbits(cast_to);\n-                    if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n-                    then {\n-                        let literal_str = if is_unary_neg(ex) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                        return;\n-                    }\n-                }\n-\n-                match lit.node {\n-                    LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n-                    _ => {\n-                        if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n-                            span_lint(\n-                                cx,\n-                                UNNECESSARY_CAST,\n-                                expr.span,\n-                                &format!(\n-                                    \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n-                                    cast_from, cast_to\n-                                ),\n-                            );\n+                        if let Some(last_stmt) = block.stmts.iter().last();\n+                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n+                        then {\n+                            Some((\n+                                last_stmt.span,\n+                                snip,\n+                            ))\n                         }\n-                    },\n-                }\n-            }\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n-                lint_numeric_casts(cx, expr, ex, cast_from, cast_to);\n-            }\n+                        else {\n+                            None\n+                        }\n+                    }\n+                })\n+                .for_each(|(span, sugg)| {\n+                    db.span_suggestion(\n+                        span,\n+                        \"remove the semicolon from the last statement in the block\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    or = \"or \";\n+                    applicability = Applicability::MaybeIncorrect;\n+                });\n \n-            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-        } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n-            if_chain! {\n-            if method_path.ident.name == sym!(cast);\n-            if let Some(generic_args) = method_path.args;\n-            if let [GenericArg::Type(cast_to)] = generic_args.args;\n-            // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n-            if !is_hir_ty_cfg_dependant(cx, cast_to);\n-            then {\n-                let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(&args[0]), cx.typeck_results().expr_ty(expr));\n-                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-            }\n-            }\n-        }\n-    }\n-}\n+            let arg_snippets: Vec<String> = args_to_recover\n+                .iter()\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n+            let arg_snippets_without_empty_blocks: Vec<String> = args_to_recover\n+                .iter()\n+                .filter(|arg| !is_empty_block(arg))\n+                .filter_map(|arg| snippet_opt(cx, arg.span))\n+                .collect();\n \n-fn is_unary_neg(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n-}\n+            if let Some(call_snippet) = snippet_opt(cx, expr.span) {\n+                let sugg = fmt_stmts_and_call(\n+                    cx,\n+                    expr,\n+                    &call_snippet,\n+                    &arg_snippets,\n+                    &arg_snippets_without_empty_blocks,\n+                );\n \n-fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n-    match expr.kind {\n-        ExprKind::Lit(ref lit) => Some(lit),\n-        ExprKind::Unary(UnOp::Neg, e) => {\n-            if let ExprKind::Lit(ref lit) = e.kind {\n-                Some(lit)\n-            } else {\n-                None\n+                if arg_snippets_without_empty_blocks.is_empty() {\n+                    db.multipart_suggestion(\n+                        &format!(\"use {}unit literal{} instead\", singular, plural),\n+                        args_to_recover\n+                            .iter()\n+                            .map(|arg| (arg.span, \"()\".to_string()))\n+                            .collect::<Vec<_>>(),\n+                        applicability,\n+                    );\n+                } else {\n+                    let plural = arg_snippets_without_empty_blocks.len() > 1;\n+                    let empty_or_s = if plural { \"s\" } else { \"\" };\n+                    let it_or_them = if plural { \"them\" } else { \"it\" };\n+                    db.span_suggestion(\n+                        expr.span,\n+                        &format!(\n+                            \"{}move the expression{} in front of the call and replace {} with the unit literal `()`\",\n+                            or, empty_or_s, it_or_them\n+                        ),\n+                        sugg,\n+                        applicability,\n+                    );\n+                }\n             }\n         },\n-        _ => None,\n-    }\n+    );\n }\n \n-fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n-    span_lint_and_sugg(\n-        cx,\n-        UNNECESSARY_CAST,\n-        expr.span,\n-        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n-        \"try\",\n-        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n-        Applicability::MachineApplicable,\n-    );\n+fn is_empty_block(expr: &Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: &[],\n+                expr: None,\n+                ..\n+            },\n+            _,\n+        )\n+    )\n }\n \n-fn lint_numeric_casts<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &Expr<'tcx>,\n-    cast_expr: &Expr<'_>,\n-    cast_from: Ty<'tcx>,\n-    cast_to: Ty<'tcx>,\n-) {\n-    match (cast_from.is_integral(), cast_to.is_integral()) {\n-        (true, false) => {\n-            let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n-                32\n-            } else {\n-                64\n-            };\n-            if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n-                span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n-            }\n-            if from_nbits < to_nbits {\n-                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n-            }\n-        },\n-        (false, true) => {\n-            span_lint(\n-                cx,\n-                CAST_POSSIBLE_TRUNCATION,\n-                expr.span,\n-                &format!(\"casting `{}` to `{}` may truncate the value\", cast_from, cast_to),\n-            );\n-            if !cast_to.is_signed() {\n-                span_lint(\n-                    cx,\n-                    CAST_SIGN_LOSS,\n-                    expr.span,\n-                    &format!(\n-                        \"casting `{}` to `{}` may lose the sign of the value\",\n-                        cast_from, cast_to\n-                    ),\n-                );\n-            }\n-        },\n-        (true, true) => {\n-            check_loss_of_sign(cx, expr, cast_expr, cast_from, cast_to);\n-            check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n-            check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n-        },\n-        (false, false) => {\n-            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind(), &cast_to.kind()) {\n-                span_lint(\n-                    cx,\n-                    CAST_POSSIBLE_TRUNCATION,\n-                    expr.span,\n-                    \"casting `f64` to `f32` may truncate the value\",\n-                );\n-            }\n-            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind(), &cast_to.kind()) {\n-                span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n-            }\n-        },\n+fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n+    use rustc_span::hygiene::DesugaringKind;\n+    if let ExprKind::Call(ref callee, _) = expr.kind {\n+        callee.span.is_desugaring(DesugaringKind::QuestionMark)\n+    } else {\n+        false\n     }\n }\n \n-fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n-    if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n-        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-        if from_layout.align.abi < to_layout.align.abi;\n-        // with c_void, we inherently need to trust the user\n-        if !is_c_void(cx, from_ptr_ty.ty);\n-        // when casting from a ZST, we don't know enough to properly lint\n-        if !from_layout.is_zst();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_PTR_ALIGNMENT,\n-                expr.span,\n-                &format!(\n-                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                    cast_from,\n-                    cast_to,\n-                    from_layout.align.abi.bytes(),\n-                    to_layout.align.abi.bytes(),\n-                ),\n-            );\n-        }\n-    }\n+fn is_unit(ty: Ty<'_>) -> bool {\n+    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n }\n \n-fn lint_fn_to_numeric_cast(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    cast_expr: &Expr<'_>,\n-    cast_from: Ty<'_>,\n-    cast_to: Ty<'_>,\n-) {\n-    // We only want to check casts to `ty::Uint` or `ty::Int`\n-    match cast_to.kind() {\n-        ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n-        _ => return,\n-    }\n-    match cast_from.kind() {\n-        ty::FnDef(..) | ty::FnPtr(_) => {\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n-\n-            let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n-            if to_nbits < cx.tcx.data_layout.pointer_size.bits() {\n-                span_lint_and_sugg(\n-                    cx,\n-                    FN_TO_NUMERIC_CAST_WITH_TRUNCATION,\n-                    expr.span,\n-                    &format!(\n-                        \"casting function pointer `{}` to `{}`, which truncates the value\",\n-                        from_snippet, cast_to\n-                    ),\n-                    \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n-                    applicability,\n-                );\n-            } else if *cast_to.kind() != ty::Uint(UintTy::Usize) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    FN_TO_NUMERIC_CAST,\n-                    expr.span,\n-                    &format!(\"casting function pointer `{}` to `{}`\", from_snippet, cast_to),\n-                    \"try\",\n-                    format!(\"{} as usize\", from_snippet),\n-                    applicability,\n-                );\n-            }\n-        },\n-        _ => {},\n-    }\n+fn is_unit_literal(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n }\n \n declare_clippy_lint! {\n@@ -2040,69 +939,6 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for expressions where a character literal is cast\n-    /// to `u8` and suggests using a byte literal instead.\n-    ///\n-    /// **Why is this bad?** In general, casting values to smaller types is\n-    /// error-prone and should be avoided where possible. In the particular case of\n-    /// converting a character literal to u8, it is easy to avoid by just using a\n-    /// byte literal instead. As an added bonus, `b'a'` is even slightly shorter\n-    /// than `'a' as u8`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// 'x' as u8\n-    /// ```\n-    ///\n-    /// A better version, using the byte literal:\n-    ///\n-    /// ```rust,ignore\n-    /// b'x'\n-    /// ```\n-    pub CHAR_LIT_AS_U8,\n-    complexity,\n-    \"casting a character literal to `u8` truncates\"\n-}\n-\n-declare_lint_pass!(CharLitAsU8 => [CHAR_LIT_AS_U8]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if !expr.span.from_expansion();\n-            if let ExprKind::Cast(e, _) = &expr.kind;\n-            if let ExprKind::Lit(l) = &e.kind;\n-            if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n-\n-                span_lint_and_then(\n-                    cx,\n-                    CHAR_LIT_AS_U8,\n-                    expr.span,\n-                    \"casting a character literal to `u8` truncates\",\n-                    |diag| {\n-                        diag.note(\"`char` is four bytes wide, but `u8` is a single byte\");\n-\n-                        if c.is_ascii() {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"use a byte literal instead\",\n-                                format!(\"b{}\", snippet),\n-                                applicability,\n-                            );\n-                        }\n-                });\n-            }\n-        }\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for comparisons where one side of the relation is\n     /// either the minimum or maximum value for its type and warns if it involves a\n@@ -2830,150 +1666,3 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n         NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for casts of `&T` to `&mut T` anywhere in the code.\n-    ///\n-    /// **Why is this bad?** It\u2019s basically guaranteed to be undefined behaviour.\n-    /// `UnsafeCell` is the only way to obtain aliasable data that is considered\n-    /// mutable.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// fn x(r: &i32) {\n-    ///     unsafe {\n-    ///         *(r as *const _ as *mut _) += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// Instead consider using interior mutability types.\n-    ///\n-    /// ```rust\n-    /// use std::cell::UnsafeCell;\n-    ///\n-    /// fn x(r: &UnsafeCell<i32>) {\n-    ///     unsafe {\n-    ///         *r.get() += 1;\n-    ///     }\n-    /// }\n-    /// ```\n-    pub CAST_REF_TO_MUT,\n-    correctness,\n-    \"a cast of reference to a mutable pointer\"\n-}\n-\n-declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RefToMut {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Unary(UnOp::Deref, e) = &expr.kind;\n-            if let ExprKind::Cast(e, t) = &e.kind;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n-            if let ExprKind::Cast(e, t) = &e.kind;\n-            if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n-            then {\n-                span_lint(\n-                    cx,\n-                    CAST_REF_TO_MUT,\n-                    expr.span,\n-                    \"casting `&T` to `&mut T` may cause undefined behavior, consider instead using an `UnsafeCell`\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-const PTR_AS_PTR_MSRV: RustcVersion = RustcVersion::new(1, 38, 0);\n-\n-declare_clippy_lint! {\n-    /// **What it does:**\n-    /// Checks for `as` casts between raw pointers without changing its mutability,\n-    /// namely `*const T` to `*const U` and `*mut T` to `*mut U`.\n-    ///\n-    /// **Why is this bad?**\n-    /// Though `as` casts between raw pointers is not terrible, `pointer::cast` is safer because\n-    /// it cannot accidentally change the pointer's mutability nor cast the pointer to other types like `usize`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let ptr: *const u32 = &42_u32;\n-    /// let mut_ptr: *mut u32 = &mut 42_u32;\n-    /// let _ = ptr as *const i32;\n-    /// let _ = mut_ptr as *mut i32;\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let ptr: *const u32 = &42_u32;\n-    /// let mut_ptr: *mut u32 = &mut 42_u32;\n-    /// let _ = ptr.cast::<i32>();\n-    /// let _ = mut_ptr.cast::<i32>();\n-    /// ```\n-    pub PTR_AS_PTR,\n-    pedantic,\n-    \"casting using `as` from and to raw pointers that doesn't change its mutability, where `pointer::cast` could take the place of `as`\"\n-}\n-\n-pub struct PtrAsPtr {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl PtrAsPtr {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl_lint_pass!(PtrAsPtr => [PTR_AS_PTR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for PtrAsPtr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if !meets_msrv(self.msrv.as_ref(), &PTR_AS_PTR_MSRV) {\n-            return;\n-        }\n-\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Cast(cast_expr, cast_to_hir_ty) = expr.kind;\n-            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(cast_expr), cx.typeck_results().expr_ty(expr));\n-            if let ty::RawPtr(TypeAndMut { mutbl: from_mutbl, .. }) = cast_from.kind();\n-            if let ty::RawPtr(TypeAndMut { ty: to_pointee_ty, mutbl: to_mutbl }) = cast_to.kind();\n-            if matches!((from_mutbl, to_mutbl),\n-                (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n-            // The `U` in `pointer::cast` have to be `Sized`\n-            // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-            if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);\n-                let turbofish = match &cast_to_hir_ty.kind {\n-                        TyKind::Infer => Cow::Borrowed(\"\"),\n-                        TyKind::Ptr(mut_ty) if matches!(mut_ty.ty.kind, TyKind::Infer) => Cow::Borrowed(\"\"),\n-                        _ => Cow::Owned(format!(\"::<{}>\", to_pointee_ty)),\n-                    };\n-                span_lint_and_sugg(\n-                    cx,\n-                    PTR_AS_PTR,\n-                    expr.span,\n-                    \"`as` casting between raw pointers without changing its mutability\",\n-                    \"try `pointer::cast`, a safer alternative\",\n-                    format!(\"{}.cast{}()\", cast_expr_sugg.maybe_par(), turbofish),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}", "previous_filename": "clippy_lints/src/types.rs"}, {"sha": "dc5db963b4e98a98a4a52294c4ad4dc0d46d5ff3", "filename": "clippy_lints/src/types/option_option.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,24 @@\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_ty_param_diagnostic_item, span_lint};\n+\n+use super::OPTION_OPTION;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::option_type, def_id)\n+        && is_ty_param_diagnostic_item(cx, qpath, sym::option_type).is_some()\n+    {\n+        span_lint(\n+            cx,\n+            OPTION_OPTION,\n+            hir_ty.span,\n+            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                                 enum if you need to distinguish all 3 cases\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e34b95147e10a6d4cf2fb2c06734b9d1459a71d2", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,98 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, snippet_with_applicability, span_lint_and_sugg,\n+};\n+\n+use super::RC_BUFFER;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Rc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Rc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Arc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Arc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n+    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n+        Some(\"str\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n+        Some(\"std::ffi::OsStr\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n+        Some(\"std::path::Path\")\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "5da6db179c46ee1a7e98a7ca614939865a4bbe96", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,84 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item, snippet_with_applicability,\n+    span_lint_and_sugg,\n+};\n+\n+use super::{utils, REDUNDANT_ALLOCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+        if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Box<&T>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            return true;\n+        }\n+    }\n+\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Rc<T>>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            true\n+        } else if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Box<T>>`\",\n+                \"try\",\n+                format!(\n+                    \"Rc<{}>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            utils::match_borrows_parameter(cx, qpath).map_or(false, |span| {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    REDUNDANT_ALLOCATION,\n+                    hir_ty.span,\n+                    \"usage of `Rc<&T>`\",\n+                    \"try\",\n+                    snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                    applicability,\n+                );\n+                true\n+            })\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "4d64748f998a40deac3d0d667aba6a3d69f851e8", "filename": "clippy_lints/src/types/utils.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Futils.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,24 @@\n+use rustc_hir::{GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use crate::utils::last_path_segment;\n+\n+use if_chain::if_chain;\n+\n+pub(super) fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n+    let last = last_path_segment(qpath);\n+    if_chain! {\n+        if let Some(ref params) = last.args;\n+        if !params.parenthesized;\n+        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        });\n+        if let TyKind::Rptr(..) = ty.kind;\n+        then {\n+            return Some(ty.span);\n+        }\n+    }\n+    None\n+}"}, {"sha": "2530cc133c6784ec04da443d68894b6b5b2bc0fd", "filename": "clippy_lints/src/types/vec_box.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,64 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n+\n+use super::VEC_BOX;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+    box_size_threshold: u64,\n+) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n+        if_chain! {\n+            // Get the _ part of Vec<_>\n+            if let Some(ref last) = last_path_segment(qpath).args;\n+            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            // ty is now _ at this point\n+            if let TyKind::Path(ref ty_qpath) = ty.kind;\n+            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n+            if let Some(def_id) = res.opt_def_id();\n+            if Some(def_id) == cx.tcx.lang_items().owned_box();\n+            // At this point, we know ty is Box<T>, now get T\n+            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n+            if !ty_ty.has_escaping_bound_vars();\n+            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n+            if ty_ty_size <= box_size_threshold;\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    VEC_BOX,\n+                    hir_ty.span,\n+                    \"`Vec<T>` is already on the heap, the boxing is unnecessary\",\n+                    \"try\",\n+                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "f0523cec6211d7a8eb74a5dec59288a4421a3663", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -262,12 +262,17 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             // FIXME: this span manipulation should not be necessary\n             // @flip1995 found an ast lowering issue in\n             // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n-            match cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_ty.hir_id)) {\n-                Some(Node::Expr(Expr {\n-                    kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                    ..\n-                })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n-                _ => span_lint(cx, hir_ty.span),\n+            let hir = cx.tcx.hir();\n+            let id = hir.get_parent_node(hir_ty.hir_id);\n+\n+            if !hir.opt_span(id).map_or(false, in_macro) {\n+                match hir.find(id) {\n+                    Some(Node::Expr(Expr {\n+                        kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n+                        ..\n+                    })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n+                    _ => span_lint(cx, hir_ty.span),\n+                }\n             }\n         }\n     }"}, {"sha": "11d96e15ff1512914717e6d8af61c62f42e7ff64", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for ZeroDiv {\n                     \"constant division of `0.0` with `0.0` will always result in NaN\",\n                     None,\n                     &format!(\n-                        \"Consider using `{}::NAN` if you would like a constant representing NaN\",\n+                        \"consider using `{}::NAN` if you would like a constant representing NaN\",\n                         float_type,\n                     ),\n                 );"}, {"sha": "adf7077e650fd301e2500b1f21bf1ad92c7583ac", "filename": "clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -3,9 +3,9 @@ use rustc_hir::{self as hir, HirId, ItemKind, Node};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{Adt, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n use rustc_target::abi::LayoutOf as _;\n use rustc_typeck::hir_ty_to_ty;\n-use rustc_span::sym;\n \n use crate::utils::{is_normalizable, is_type_diagnostic_item, match_type, paths, span_lint_and_help};\n "}, {"sha": "9e07f140cf1bedd2fa896981ea4b7776856ec01f", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -17,3 +17,7 @@ rustc-semver=\"1.1.0\"\n \n [features]\n internal-lints = []\n+\n+[package.metadata.rust-analyzer]\n+# This crate uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "a6636e391374e13d4c75fe0a6effc0e08495ad6f", "filename": "clippy_utils/src/camel_case.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fcamel_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fcamel_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fcamel_case.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -25,11 +25,7 @@ pub fn until(s: &str) -> usize {\n             return i;\n         }\n     }\n-    if up {\n-        last_i\n-    } else {\n-        s.len()\n-    }\n+    if up { last_i } else { s.len() }\n }\n \n /// Returns index of the last camel-case component of `s`."}, {"sha": "8013c4e4fcbe417b369ea1de6be89036ad69e620", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -9,7 +9,7 @@\n //!  - or-fun-call\n //!  - option-if-let-else\n \n-use crate::{is_ctor_or_promotable_const_function, is_type_diagnostic_item, match_type, paths};\n+use crate::{is_ctor_or_promotable_const_function, is_type_diagnostic_item};\n use rustc_hir::def::{DefKind, Res};\n \n use rustc_hir::intravisit;\n@@ -101,7 +101,7 @@ fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, ex\n                 ExprKind::Index(obj, _) => {\n                     let ty = self.cx.typeck_results().expr_ty(obj);\n                     is_type_diagnostic_item(self.cx, ty, sym::hashmap_type)\n-                        || match_type(self.cx, ty, &paths::BTREEMAP)\n+                        || is_type_diagnostic_item(self.cx, ty, sym::BTreeMap)\n                 },\n                 ExprKind::MethodCall(..) => true,\n                 _ => false,"}, {"sha": "e28ad27d9a6f8d9f97b88b761defca6766733536", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::differing_macro_contexts;\n+use crate::{differing_macro_contexts, snippet_opt};\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -9,6 +9,7 @@ use rustc_hir::{\n     GenericArg, GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n     PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::LateContext;\n use rustc_middle::ich::StableHashingContextProvider;\n use rustc_middle::ty::TypeckResults;\n@@ -110,8 +111,54 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     /// Checks whether two blocks are the same.\n     fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n-        over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n-            && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+        match (left.stmts, left.expr, right.stmts, right.expr) {\n+            ([], None, [], None) => {\n+                // For empty blocks, check to see if the tokens are equal. This will catch the case where a macro\n+                // expanded to nothing, or the cfg attribute was used.\n+                let (left, right) = match (\n+                    snippet_opt(self.inner.cx, left.span),\n+                    snippet_opt(self.inner.cx, right.span),\n+                ) {\n+                    (Some(left), Some(right)) => (left, right),\n+                    _ => return true,\n+                };\n+                let mut left_pos = 0;\n+                let left = tokenize(&left)\n+                    .map(|t| {\n+                        let end = left_pos + t.len;\n+                        let s = &left[left_pos..end];\n+                        left_pos = end;\n+                        (t, s)\n+                    })\n+                    .filter(|(t, _)| {\n+                        !matches!(\n+                            t.kind,\n+                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n+                        )\n+                    })\n+                    .map(|(_, s)| s);\n+                let mut right_pos = 0;\n+                let right = tokenize(&right)\n+                    .map(|t| {\n+                        let end = right_pos + t.len;\n+                        let s = &right[right_pos..end];\n+                        right_pos = end;\n+                        (t, s)\n+                    })\n+                    .filter(|(t, _)| {\n+                        !matches!(\n+                            t.kind,\n+                            TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n+                        )\n+                    })\n+                    .map(|(_, s)| s);\n+                left.eq(right)\n+            },\n+            _ => {\n+                over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n+                    && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+            },\n+        }\n     }\n \n     #[allow(clippy::similar_names)]\n@@ -131,7 +178,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n             }\n         }\n \n-        let is_eq = match (&reduce_exprkind(&left.kind), &reduce_exprkind(&right.kind)) {\n+        let is_eq = match (\n+            &reduce_exprkind(self.inner.cx, &left.kind),\n+            &reduce_exprkind(self.inner.cx, &right.kind),\n+        ) {\n             (&ExprKind::AddrOf(lb, l_mut, ref le), &ExprKind::AddrOf(rb, r_mut, ref re)) => {\n                 lb == rb && l_mut == r_mut && self.eq_expr(le, re)\n             },\n@@ -360,11 +410,30 @@ impl HirEqInterExpr<'_, '_, '_> {\n }\n \n /// Some simple reductions like `{ return }` => `return`\n-fn reduce_exprkind<'hir>(kind: &'hir ExprKind<'hir>) -> &ExprKind<'hir> {\n+fn reduce_exprkind<'hir>(cx: &LateContext<'_>, kind: &'hir ExprKind<'hir>) -> &'hir ExprKind<'hir> {\n     if let ExprKind::Block(block, _) = kind {\n         match (block.stmts, block.expr) {\n+            // From an `if let` expression without an `else` block. The arm for the implicit wild pattern is an empty\n+            // block with an empty span.\n+            ([], None) if block.span.is_empty() => &ExprKind::Tup(&[]),\n             // `{}` => `()`\n-            ([], None) => &ExprKind::Tup(&[]),\n+            ([], None) => match snippet_opt(cx, block.span) {\n+                // Don't reduce if there are any tokens contained in the braces\n+                Some(snip)\n+                    if tokenize(&snip)\n+                        .map(|t| t.kind)\n+                        .filter(|t| {\n+                            !matches!(\n+                                t,\n+                                TokenKind::LineComment { .. } | TokenKind::BlockComment { .. } | TokenKind::Whitespace\n+                            )\n+                        })\n+                        .ne([TokenKind::OpenBrace, TokenKind::CloseBrace].iter().cloned()) =>\n+                {\n+                    kind\n+                },\n+                _ => &ExprKind::Tup(&[]),\n+            },\n             ([], Some(expr)) => match expr.kind {\n                 // `{ return .. }` => `return ..`\n                 ExprKind::Ret(..) => &expr.kind,"}, {"sha": "d81b89dd001ceb1e40d07986dab784110036e388", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 185, "deletions": 14, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -13,6 +13,7 @@ extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_infer;\n+extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n extern crate rustc_mir;\n@@ -61,27 +62,29 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Expr, ExprKind, FnDecl, HirId, ImplItem, ImplItemKind, Item, ItemKind,\n-    MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+    def, Arm, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, Item,\n+    ItemKind, LangItem, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef,\n+    TyKind, Unsafety,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, layout::IntegerExt, DefIdTree, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n-use rustc_span::hygiene::{ExpnKind, MacroKind};\n+use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n+use rustc_span::{BytePos, Pos, Span, SyntaxContext, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n \n use crate::consts::{constant, Constant};\n+use std::collections::HashMap;\n \n pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Option<RustcVersion> {\n     if let Ok(version) = RustcVersion::parse(msrv) {\n@@ -229,13 +232,68 @@ pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangI\n     }\n }\n \n+/// Checks if the first type parameter is a lang item.\n+pub fn is_ty_param_lang_item(cx: &LateContext<'_>, qpath: &QPath<'tcx>, item: LangItem) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let ty = get_qpath_generic_tys(qpath).next()?;\n+\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        cx.qpath_res(qpath, ty.hir_id)\n+            .opt_def_id()\n+            .map_or(false, |id| {\n+                cx.tcx.lang_items().require(item).map_or(false, |lang_id| id == lang_id)\n+            })\n+            .then(|| ty)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Checks if the first type parameter is a diagnostic item.\n+pub fn is_ty_param_diagnostic_item(\n+    cx: &LateContext<'_>,\n+    qpath: &QPath<'tcx>,\n+    item: Symbol,\n+) -> Option<&'tcx hir::Ty<'tcx>> {\n+    let ty = get_qpath_generic_tys(qpath).next()?;\n+\n+    if let TyKind::Path(qpath) = &ty.kind {\n+        cx.qpath_res(qpath, ty.hir_id)\n+            .opt_def_id()\n+            .map_or(false, |id| cx.tcx.is_diagnostic_item(item, id))\n+            .then(|| ty)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Return `true` if the passed `typ` is `isize` or `usize`.\n+pub fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n+    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+}\n+\n /// Checks if the method call given in `expr` belongs to the given trait.\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n \n+/// Checks if the method call given in `expr` belongs to a trait or other container with a given\n+/// diagnostic item\n+pub fn is_diagnostic_assoc_item(cx: &LateContext<'_>, def_id: DefId, diag_item: Symbol) -> bool {\n+    cx.tcx\n+        .opt_associated_item(def_id)\n+        .and_then(|associated_item| match associated_item.container {\n+            ty::TraitContainer(assoc_def_id) => Some(assoc_def_id),\n+            ty::ImplContainer(assoc_def_id) => match cx.tcx.type_of(assoc_def_id).kind() {\n+                ty::Adt(adt, _) => Some(adt.did),\n+                ty::Slice(_) => cx.tcx.get_diagnostic_item(sym::slice), // this isn't perfect but it works\n+                _ => None,\n+            },\n+        })\n+        .map_or(false, |assoc_def_id| cx.tcx.is_diagnostic_item(diag_item, assoc_def_id))\n+}\n+\n /// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n@@ -254,6 +312,27 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     }\n }\n \n+pub fn get_qpath_generics(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n+    match path {\n+        QPath::Resolved(_, p) => p.segments.last().and_then(|s| s.args),\n+        QPath::TypeRelative(_, s) => s.args,\n+        QPath::LangItem(..) => None,\n+    }\n+}\n+\n+pub fn get_qpath_generic_tys(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n+    get_qpath_generics(path)\n+        .map_or([].as_ref(), |a| a.args)\n+        .iter()\n+        .filter_map(|a| {\n+            if let hir::GenericArg::Type(ty) = a {\n+                Some(ty)\n+            } else {\n+                None\n+            }\n+        })\n+}\n+\n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n         QPath::Resolved(_, ref path) => path.segments.get(0),\n@@ -455,6 +534,18 @@ pub fn has_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n+/// Checks whether a type can be partially moved.\n+pub fn can_partially_move_ty(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    if has_drop(cx, ty) || is_copy(cx, ty) {\n+        return false;\n+    }\n+    match ty.kind() {\n+        ty::Param(_) => false,\n+        ty::Adt(def, subs) => def.all_fields().any(|f| !is_copy(cx, f.ty(cx.tcx, subs))),\n+        _ => true,\n+    }\n+}\n+\n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n pub fn method_calls<'tcx>(\n@@ -745,6 +836,35 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n     reindent_multiline(snip, true, indent)\n }\n \n+/// Same as `snippet_with_applicability`, but first walks the span up to the given context. This\n+/// will result in the macro call, rather then the expansion, if the span is from a child context.\n+/// If the span is not from a child context, it will be used directly instead.\n+///\n+/// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR node\n+/// would result in `box []`. If given the context of the address of expression, this function will\n+/// correctly get a snippet of `vec![]`.\n+pub fn snippet_with_context(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    outer: SyntaxContext,\n+    default: &'a str,\n+    applicability: &mut Applicability,\n+) -> Cow<'a, str> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    let span = if outer_span.ctxt() == outer {\n+        outer_span\n+    } else {\n+        // The span is from a macro argument, and the outer context is the macro using the argument\n+        if *applicability != Applicability::Unspecified {\n+            *applicability = Applicability::MaybeIncorrect;\n+        }\n+        // TODO: get the argument span.\n+        span\n+    };\n+\n+    snippet_with_applicability(cx, span, default, applicability)\n+}\n+\n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n /// line.\n ///\n@@ -923,6 +1043,21 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n+/// Gets the parent node if it's an impl block.\n+pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n+    let map = tcx.hir();\n+    match map.parent_iter(id).next() {\n+        Some((\n+            _,\n+            Node::Item(Item {\n+                kind: ItemKind::Impl(imp),\n+                ..\n+            }),\n+        )) => Some(imp),\n+        _ => None,\n+    }\n+}\n+\n /// Returns the base type for HIR references and pointers.\n pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n     match ty.kind {\n@@ -1359,13 +1494,49 @@ pub fn match_function_call<'tcx>(\n     None\n }\n \n+// FIXME: Per https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/infer/at/struct.At.html#method.normalize\n+// this function can be removed once the `normalizie` method does not panic when normalization does\n+// not succeed\n /// Checks if `Ty` is normalizable. This function is useful\n /// to avoid crashes on `layout_of`.\n pub fn is_normalizable<'tcx>(cx: &LateContext<'tcx>, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n-    cx.tcx.infer_ctxt().enter(|infcx| {\n+    is_normalizable_helper(cx, param_env, ty, &mut HashMap::new())\n+}\n+\n+fn is_normalizable_helper<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    cache: &mut HashMap<Ty<'tcx>, bool>,\n+) -> bool {\n+    if let Some(&cached_result) = cache.get(ty) {\n+        return cached_result;\n+    }\n+    // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n+    cache.insert(ty, false);\n+    let result = cx.tcx.infer_ctxt().enter(|infcx| {\n         let cause = rustc_middle::traits::ObligationCause::dummy();\n-        infcx.at(&cause, param_env).normalize(ty).is_ok()\n-    })\n+        if infcx.at(&cause, param_env).normalize(ty).is_ok() {\n+            match ty.kind() {\n+                ty::Adt(def, substs) => def.variants.iter().all(|variant| {\n+                    variant\n+                        .fields\n+                        .iter()\n+                        .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n+                }),\n+                _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n+                    GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n+                        is_normalizable_helper(cx, param_env, inner_ty, cache)\n+                    },\n+                    _ => true, // if inner_ty == ty, we've already checked it\n+                }),\n+            }\n+        } else {\n+            false\n+        }\n+    });\n+    cache.insert(ty, result);\n+    result\n }\n \n pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n@@ -1546,12 +1717,12 @@ pub fn is_trait_impl_item(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n /// ```\n pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     use rustc_trait_selection::traits;\n-    let predicates =\n-        cx.tcx\n-            .predicates_of(did)\n-            .predicates\n-            .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+    let predicates = cx\n+        .tcx\n+        .predicates_of(did)\n+        .predicates\n+        .iter()\n+        .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)"}, {"sha": "560614efc749e1b1fd29102de9a7322d6284d31b", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -12,11 +12,9 @@ pub(super) const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub(super) const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n pub const BINARY_HEAP: [&str; 4] = [\"alloc\", \"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n-pub const BOX: [&str; 3] = [\"alloc\", \"boxed\", \"Box\"];\n pub const BTREEMAP: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREESET: [&str; 5] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\"];\n-pub const CLONE_TRAIT: [&str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n@@ -43,9 +41,6 @@ pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n-pub const FN: [&str; 3] = [\"core\", \"ops\", \"Fn\"];\n-pub const FN_MUT: [&str; 3] = [\"core\", \"ops\", \"FnMut\"];\n-pub const FN_ONCE: [&str; 3] = [\"core\", \"ops\", \"FnOnce\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR: [&str; 5] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\"];\n pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n@@ -89,7 +84,6 @@ pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n-pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub(super) const PANICKING_PANIC: [&str; 3] = [\"core\", \"panicking\", \"panic\"];\n@@ -113,7 +107,6 @@ pub const PTR_SLICE_FROM_RAW_PARTS_MUT: [&str; 3] = [\"core\", \"ptr\", \"slice_from_\n pub const PTR_SWAP_NONOVERLAPPING: [&str; 3] = [\"core\", \"ptr\", \"swap_nonoverlapping\"];\n pub const PUSH_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"push_str\"];\n pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n-pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n@@ -141,7 +134,6 @@ pub const STD_CONVERT_IDENTITY: [&str; 3] = [\"std\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n-pub const STRING: [&str; 3] = [\"alloc\", \"string\", \"String\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n@@ -160,9 +152,7 @@ pub const SYMBOL_TO_IDENT_STRING: [&str; 4] = [\"rustc_span\", \"symbol\", \"Symbol\",\n pub const SYM_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"sym\"];\n #[cfg(feature = \"internal-lints\")]\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n-pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];\n-pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];"}, {"sha": "df6143edbcaf09a98ef6eb3bfcb88a8eb6123681", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -36,11 +36,7 @@ fn extract_clone_suggestions<'tcx>(\n         abort: false,\n     };\n     visitor.visit_body(body);\n-    if visitor.abort {\n-        None\n-    } else {\n-        Some(visitor.spans)\n-    }\n+    if visitor.abort { None } else { Some(visitor.spans) }\n }\n \n struct PtrCloneVisitor<'a, 'tcx> {"}, {"sha": "575853996c0add3de34a8c79bd9e386237c328da", "filename": "doc/adding_lints.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -18,6 +18,7 @@ because that's clearly a non-descriptive name.\n   - [Lint passes](#lint-passes)\n   - [Emitting a lint](#emitting-a-lint)\n   - [Adding the lint logic](#adding-the-lint-logic)\n+  - [Specifying the lint's minimum supported Rust version (msrv)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n   - [Author lint](#author-lint)\n   - [Documentation](#documentation)\n   - [Running rustfmt](#running-rustfmt)"}, {"sha": "c56e84e2e32a22569c954c869506e56a0787b71d", "filename": "doc/basics.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -11,8 +11,9 @@ the codebase take a look at [Adding Lints] or [Common Tools].\n   - [Get the Code](#get-the-code)\n   - [Building and Testing](#building-and-testing)\n   - [`cargo dev`](#cargo-dev)\n-  - [Common Abbreviations](#common-abbreviations)\n+  - [lintcheck](#lintcheck)\n   - [PR](#pr)\n+  - [Common Abbreviations](#common-abbreviations)\n \n ## Get the Code\n \n@@ -91,6 +92,16 @@ cargo dev new_lint\n cargo dev ra_setup\n ```\n \n+## lintcheck\n+`cargo lintcheck` will build and run clippy on a fixed set of crates and generate a log of the results.  \n+You can `git diff` the updated log against its previous version and \n+see what impact your lint made on a small set of crates.  \n+If you add a new lint, please audit the resulting warnings and make sure \n+there are no false positives and that the suggestions are valid.\n+\n+Refer to the tools [README] for more details.\n+\n+[README]: https://github.com/rust-lang/rust-clippy/blob/master/lintcheck/README.md\n ## PR\n \n We follow a rustc no merge-commit policy."}, {"sha": "3439b1e2c43d4fb7f188ca9db44fb3bdaf117da4", "filename": "lintcheck-logs/lintcheck_crates_logs.txt", "status": "modified", "additions": 3655, "deletions": 3398, "changes": 7053, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck-logs%2Flintcheck_crates_logs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck-logs%2Flintcheck_crates_logs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck-logs%2Flintcheck_crates_logs.txt?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "8db6d28e5acae1d4865fd6982179c743f645bc83", "filename": "lintcheck/Cargo.toml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,25 @@\n+[package]\n+name = \"lintcheck\"\n+version = \"0.0.1\"\n+authors = [\"The Rust Clippy Developers\"]\n+description = \"tool to monitor impact of changes in Clippys lints on a part of the ecosystem\"\n+readme = \"README.md\"\n+license = \"MIT OR Apache-2.0\"\n+repository = \"https://github.com/rust-lang/rust-clippy\"\n+categories = [\"development-tools\"]\n+edition = \"2018\"\n+publish = false\n+\n+[dependencies]\n+clap = \"2.33\"\n+flate2 = {version = \"1.0.19\"}\n+fs_extra = {version = \"1.2.0\"}\n+rayon = {version = \"1.5.0\"}\n+serde = {version = \"1.0\", features = [\"derive\"]}\n+serde_json = {version = \"1.0\"}\n+tar = {version = \"0.4.30\"}\n+toml = {version = \"0.5\"}\n+ureq = {version = \"2.0.0-rc3\"}\n+\n+[features]\n+deny-warnings = []"}, {"sha": "52bbcc0a8317dd47e2afbe4ccd2e854deaac7d10", "filename": "lintcheck/README.md", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2FREADME.md?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,27 +1,19 @@\n-# Clippy Dev Tool\n-\n-The Clippy Dev Tool is a tool to ease Clippy development, similar to `rustc`s\n-`x.py`.\n-\n-Functionalities (incomplete):\n-\n-## `lintcheck`\n+## `cargo lintcheck`\n \n Runs clippy on a fixed set of crates read from\n-`clippy_dev/lintcheck_crates.toml` and saves logs of the lint warnings into the\n+`lintcheck/lintcheck_crates.toml` and saves logs of the lint warnings into the\n repo.  We can then check the diff and spot new or disappearing warnings.\n \n From the repo root, run:\n \n ```\n-cargo run --target-dir clippy_dev/target --package clippy_dev \\\n---bin clippy_dev --manifest-path clippy_dev/Cargo.toml --features lintcheck -- lintcheck\n+cargo run --target-dir lintcheck/target --manifest-path lintcheck/Cargo.toml\n ```\n \n or\n \n ```\n-cargo dev-lintcheck\n+cargo lintcheck\n ```\n \n By default the logs will be saved into\n@@ -75,3 +67,11 @@ is checked.\n \n **Note:** `-Wclippy::all` is always enabled by default, unless `-Aclippy::all`\n is explicitly specified in the options.\n+\n+### Fix mode\n+You can run `./lintcheck/target/debug/lintcheck --fix` which will run Clippy with `-Zunstable-options --fix` and\n+print a warning if Clippys suggestions fail to apply (if the resulting code does not build).  \n+This lets us spot bad suggestions or false positives automatically in some cases.  \n+\n+Please note that the target dir should be cleaned afterwards since clippy will modify \n+the downloaded sources which can lead to unexpected results when running lintcheck again afterwards.", "previous_filename": "clippy_dev/README.md"}, {"sha": "dfee28f1a87128e0e4ef92472e72ba5968e55a7d", "filename": "lintcheck/lintcheck_crates.toml", "status": "renamed", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Flintcheck_crates.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Flintcheck_crates.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Flintcheck_crates.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -14,10 +14,22 @@ bitflags = {name = \"bitflags\", versions = ['1.2.1']}\n libc = {name = \"libc\", versions = ['0.2.81']}\n log = {name = \"log\", versions = ['0.4.11']}\n proc-macro2 = {name = \"proc-macro2\", versions = ['1.0.24']}\n-puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n quote = {name = \"quote\", versions = ['1.0.7']}\n rand = {name = \"rand\", versions = ['0.7.3']}\n rand_core = {name = \"rand_core\", versions = ['0.6.0']}\n regex = {name = \"regex\", versions = ['1.3.2']}\n syn = {name = \"syn\", versions = ['1.0.54']}\n unicode-xid = {name = \"unicode-xid\", versions = ['0.2.1']}\n+# some more of dtolnays crates\n+anyhow = {name = \"anyhow\", versions = ['1.0.38']}\n+async-trait = {name = \"async-trait\", versions = ['0.1.42']}\n+cxx = {name = \"cxx\", versions = ['1.0.32']}\n+ryu = {name = \"ryu\", version = ['1.0.5']}\n+serde_yaml = {name = \"serde_yaml\", versions = ['0.8.17']}\n+thiserror = {name = \"thiserror\", versions = ['1.0.24']}\n+# some embark crates, there are other interesting crates but\n+# unfortunately adding them increases lintcheck runtime drastically\n+cfg-expr = {name = \"cfg-expr\", versions = ['0.7.1']}\n+puffin = {name = \"puffin\", git_url = \"https://github.com/EmbarkStudios/puffin\", git_hash = \"02dd4a3\"}\n+rpmalloc = {name = \"rpmalloc\", versions = ['0.2.0']}\n+tame-oidc = {name = \"tame-oidc\", versions = ['0.1.0']}", "previous_filename": "clippy_dev/lintcheck_crates.toml"}, {"sha": "581b47647eb189c9f1164a1c6cf789f1fd519e6a", "filename": "lintcheck/src/main.rs", "status": "renamed", "additions": 441, "deletions": 137, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,24 +1,33 @@\n // Run clippy on a fixed set of crates and collect the warnings.\n-// This helps observing the impact clippy changs have on a set of real-world code.\n+// This helps observing the impact clippy changes have on a set of real-world code (and not just our\n+// testsuite).\n //\n // When a new lint is introduced, we can search the results for new warnings and check for false\n // positives.\n \n-#![cfg(feature = \"lintcheck\")]\n-#![allow(clippy::filter_map)]\n+#![allow(clippy::filter_map, clippy::collapsible_else_if)]\n \n-use crate::clippy_project_root;\n-\n-use std::collections::HashMap;\n+use std::ffi::OsStr;\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::{env, fmt, fs::write, path::PathBuf};\n-\n-use clap::ArgMatches;\n+use std::{collections::HashMap, io::ErrorKind};\n+use std::{\n+    env, fmt,\n+    fs::write,\n+    path::{Path, PathBuf},\n+};\n+\n+use clap::{App, Arg, ArgMatches};\n use rayon::prelude::*;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n \n+const CLIPPY_DRIVER_PATH: &str = \"target/debug/clippy-driver\";\n+const CARGO_CLIPPY_PATH: &str = \"target/debug/cargo-clippy\";\n+\n+const LINTCHECK_DOWNLOADS: &str = \"target/lintcheck/downloads\";\n+const LINTCHECK_SOURCES: &str = \"target/lintcheck/sources\";\n+\n /// List of sources to check, loaded from a .toml file\n #[derive(Debug, Serialize, Deserialize)]\n struct SourceList {\n@@ -86,7 +95,7 @@ impl std::fmt::Display for ClippyWarning {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(\n             f,\n-            r#\"{}-{}/{}:{}:{} {} \"{}\"\"#,\n+            r#\"target/lintcheck/sources/{}-{}/{}:{}:{} {} \"{}\"\"#,\n             &self.crate_name, &self.crate_version, &self.file, &self.line, &self.column, &self.linttype, &self.message\n         )\n     }\n@@ -99,15 +108,13 @@ impl CrateSource {\n     fn download_and_extract(&self) -> Crate {\n         match self {\n             CrateSource::CratesIo { name, version, options } => {\n-                let extract_dir = PathBuf::from(\"target/lintcheck/crates\");\n-                let krate_download_dir = PathBuf::from(\"target/lintcheck/downloads\");\n+                let extract_dir = PathBuf::from(LINTCHECK_SOURCES);\n+                let krate_download_dir = PathBuf::from(LINTCHECK_DOWNLOADS);\n \n                 // url to download the crate from crates.io\n                 let url = format!(\"https://crates.io/api/v1/crates/{}/{}/download\", name, version);\n                 println!(\"Downloading and extracting {} {} from {}\", name, version, url);\n-                let _ = std::fs::create_dir(\"target/lintcheck/\");\n-                let _ = std::fs::create_dir(&krate_download_dir);\n-                let _ = std::fs::create_dir(&extract_dir);\n+                create_dirs(&krate_download_dir, &extract_dir);\n \n                 let krate_file_path = krate_download_dir.join(format!(\"{}-{}.crate.tar.gz\", name, version));\n                 // don't download/extract if we already have done so\n@@ -140,7 +147,7 @@ impl CrateSource {\n                 options,\n             } => {\n                 let repo_path = {\n-                    let mut repo_path = PathBuf::from(\"target/lintcheck/crates\");\n+                    let mut repo_path = PathBuf::from(LINTCHECK_SOURCES);\n                     // add a -git suffix in case we have the same crate from crates.io and a git repo\n                     repo_path.push(format!(\"{}-git\", name));\n                     repo_path\n@@ -182,25 +189,23 @@ impl CrateSource {\n                 use fs_extra::dir;\n \n                 // simply copy the entire directory into our target dir\n-                let copy_dest = PathBuf::from(\"target/lintcheck/crates/\");\n+                let copy_dest = PathBuf::from(format!(\"{}/\", LINTCHECK_SOURCES));\n \n                 // the source path of the crate we copied,  ${copy_dest}/crate_name\n                 let crate_root = copy_dest.join(name); // .../crates/local_crate\n \n-                if !crate_root.exists() {\n-                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n-\n-                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).expect(&format!(\n-                        \"Failed to copy from {}, to  {}\",\n-                        path.display(),\n-                        crate_root.display()\n-                    ));\n-                } else {\n+                if crate_root.exists() {\n                     println!(\n                         \"Not copying {} to {}, destination already exists\",\n                         path.display(),\n                         crate_root.display()\n                     );\n+                } else {\n+                    println!(\"Copying {} to {}\", path.display(), copy_dest.display());\n+\n+                    dir::copy(path, &copy_dest, &dir::CopyOptions::new()).unwrap_or_else(|_| {\n+                        panic!(\"Failed to copy from {}, to  {}\", path.display(), crate_root.display())\n+                    });\n                 }\n \n                 Crate {\n@@ -219,16 +224,17 @@ impl Crate {\n     /// issued\n     fn run_clippy_lints(\n         &self,\n-        cargo_clippy_path: &PathBuf,\n+        cargo_clippy_path: &Path,\n         target_dir_index: &AtomicUsize,\n         thread_limit: usize,\n         total_crates_to_lint: usize,\n+        fix: bool,\n     ) -> Vec<ClippyWarning> {\n         // advance the atomic index by one\n         let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n         // \"loop\" the index within 0..thread_limit\n-        let target_dir_index = index % thread_limit;\n-        let perc = ((index * 100) as f32 / total_crates_to_lint as f32) as u8;\n+        let thread_index = index % thread_limit;\n+        let perc = (index * 100) / total_crates_to_lint;\n \n         if thread_limit == 1 {\n             println!(\n@@ -238,15 +244,26 @@ impl Crate {\n         } else {\n             println!(\n                 \"{}/{} {}% Linting {} {} in target dir {:?}\",\n-                index, total_crates_to_lint, perc, &self.name, &self.version, target_dir_index\n+                index, total_crates_to_lint, perc, &self.name, &self.version, thread_index\n             );\n         }\n \n         let cargo_clippy_path = std::fs::canonicalize(cargo_clippy_path).unwrap();\n \n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n-        let mut args = vec![\"--\", \"--message-format=json\", \"--\", \"--cap-lints=warn\"];\n+        let mut args = if fix {\n+            vec![\n+                \"-Zunstable-options\",\n+                \"--fix\",\n+                \"-Zunstable-options\",\n+                \"--allow-no-vcs\",\n+                \"--\",\n+                \"--cap-lints=warn\",\n+            ]\n+        } else {\n+            vec![\"--\", \"--message-format=json\", \"--\", \"--cap-lints=warn\"]\n+        };\n \n         if let Some(options) = &self.options {\n             for opt in options {\n@@ -260,7 +277,7 @@ impl Crate {\n             // use the looping index to create individual target dirs\n             .env(\n                 \"CARGO_TARGET_DIR\",\n-                shared_target_dir.join(format!(\"_{:?}\", target_dir_index)),\n+                shared_target_dir.join(format!(\"_{:?}\", thread_index)),\n             )\n             // lint warnings will look like this:\n             // src/cargo/ops/cargo_compile.rs:127:35: warning: usage of `FromIterator::from_iter`\n@@ -276,17 +293,97 @@ impl Crate {\n                 );\n             });\n         let stdout = String::from_utf8_lossy(&all_output.stdout);\n+        let stderr = String::from_utf8_lossy(&all_output.stderr);\n+\n+        if fix {\n+            if let Some(stderr) = stderr\n+                .lines()\n+                .find(|line| line.contains(\"failed to automatically apply fixes suggested by rustc to crate\"))\n+            {\n+                let subcrate = &stderr[63..];\n+                println!(\n+                    \"ERROR: failed to apply some suggetion to {} / to (sub)crate {}\",\n+                    self.name, subcrate\n+                );\n+            }\n+            // fast path, we don't need the warnings anyway\n+            return Vec::new();\n+        }\n+\n         let output_lines = stdout.lines();\n         let warnings: Vec<ClippyWarning> = output_lines\n             .into_iter()\n             // get all clippy warnings and ICEs\n             .filter(|line| filter_clippy_warnings(&line))\n             .map(|json_msg| parse_json_message(json_msg, &self))\n             .collect();\n+\n         warnings\n     }\n }\n \n+#[derive(Debug)]\n+struct LintcheckConfig {\n+    // max number of jobs to spawn (default 1)\n+    max_jobs: usize,\n+    // we read the sources to check from here\n+    sources_toml_path: PathBuf,\n+    // we save the clippy lint results here\n+    lintcheck_results_path: PathBuf,\n+    // whether to just run --fix and not collect all the warnings\n+    fix: bool,\n+}\n+\n+impl LintcheckConfig {\n+    fn from_clap(clap_config: &ArgMatches) -> Self {\n+        // first, check if we got anything passed via the LINTCHECK_TOML env var,\n+        // if not, ask clap if we got any value for --crates-toml  <foo>\n+        // if not, use the default \"lintcheck/lintcheck_crates.toml\"\n+        let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n+            clap_config\n+                .value_of(\"crates-toml\")\n+                .clone()\n+                .unwrap_or(\"lintcheck/lintcheck_crates.toml\")\n+                .to_string()\n+        });\n+\n+        let sources_toml_path = PathBuf::from(sources_toml);\n+\n+        // for the path where we save the lint results, get the filename without extension (so for\n+        // wasd.toml, use \"wasd\"...)\n+        let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n+        let lintcheck_results_path = PathBuf::from(format!(\"lintcheck-logs/{}_logs.txt\", filename.display()));\n+\n+        // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n+        // use half of that for the physical core count\n+        // by default use a single thread\n+        let max_jobs = match clap_config.value_of(\"threads\") {\n+            Some(threads) => {\n+                let threads: usize = threads\n+                    .parse()\n+                    .unwrap_or_else(|_| panic!(\"Failed to parse '{}' to a digit\", threads));\n+                if threads == 0 {\n+                    // automatic choice\n+                    // Rayon seems to return thread count so half that for core count\n+                    (rayon::current_num_threads() / 2) as usize\n+                } else {\n+                    threads\n+                }\n+            },\n+            // no -j passed, use a single thread\n+            None => 1,\n+        };\n+        let fix: bool = clap_config.is_present(\"fix\");\n+\n+        LintcheckConfig {\n+            max_jobs,\n+            sources_toml_path,\n+            lintcheck_results_path,\n+            fix,\n+        }\n+    }\n+}\n+\n /// takes a single json-formatted clippy warnings and returns true (we are interested in that line)\n /// or false (we aren't)\n fn filter_clippy_warnings(line: &str) -> bool {\n@@ -310,19 +407,6 @@ fn filter_clippy_warnings(line: &str) -> bool {\n     false\n }\n \n-/// get the path to lintchecks crate sources .toml file, check LINTCHECK_TOML first but if it's\n-/// empty use the default path\n-fn lintcheck_config_toml(toml_path: Option<&str>) -> PathBuf {\n-    PathBuf::from(\n-        env::var(\"LINTCHECK_TOML\").unwrap_or(\n-            toml_path\n-                .clone()\n-                .unwrap_or(\"clippy_dev/lintcheck_crates.toml\")\n-                .to_string(),\n-        ),\n-    )\n-}\n-\n /// Builds clippy inside the repo to make sure we have a clippy executable we can use.\n fn build_clippy() {\n     let status = Command::new(\"cargo\")\n@@ -336,10 +420,7 @@ fn build_clippy() {\n }\n \n /// Read a `toml` file and return a list of `CrateSources` that we want to check with clippy\n-fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n-    let toml_path = lintcheck_config_toml(toml_path);\n-    // save it so that we can use the name of the sources.toml as name for the logfile later.\n-    let toml_filename = toml_path.file_stem().unwrap().to_str().unwrap().to_string();\n+fn read_crates(toml_path: &Path) -> Vec<CrateSource> {\n     let toml_content: String =\n         std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n@@ -399,20 +480,39 @@ fn read_crates(toml_path: Option<&str>) -> (String, Vec<CrateSource>) {\n     // sort the crates\n     crate_sources.sort();\n \n-    (toml_filename, crate_sources)\n+    crate_sources\n }\n \n /// Parse the json output of clippy and return a `ClippyWarning`\n fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n     let jmsg: Value = serde_json::from_str(&json_message).unwrap_or_else(|e| panic!(\"Failed to parse json:\\n{:?}\", e));\n \n+    let file: String = jmsg[\"message\"][\"spans\"][0][\"file_name\"]\n+        .to_string()\n+        .trim_matches('\"')\n+        .into();\n+\n+    let file = if file.contains(\".cargo\") {\n+        // if we deal with macros, a filename may show the origin of a macro which can be inside a dep from\n+        // the registry.\n+        // don't show the full path in that case.\n+\n+        // /home/matthias/.cargo/registry/src/github.com-1ecc6299db9ec823/syn-1.0.63/src/custom_keyword.rs\n+        let path = PathBuf::from(file);\n+        let mut piter = path.iter();\n+        // consume all elements until we find \".cargo\", so that \"/home/matthias\" is skipped\n+        let _: Option<&OsStr> = piter.find(|x| x == &std::ffi::OsString::from(\".cargo\"));\n+        // collect the remaining segments\n+        let file = piter.collect::<PathBuf>();\n+        format!(\"{}\", file.display())\n+    } else {\n+        file\n+    };\n+\n     ClippyWarning {\n         crate_name: krate.name.to_string(),\n         crate_version: krate.version.to_string(),\n-        file: jmsg[\"message\"][\"spans\"][0][\"file_name\"]\n-            .to_string()\n-            .trim_matches('\"')\n-            .into(),\n+        file,\n         line: jmsg[\"message\"][\"spans\"][0][\"line_start\"]\n             .to_string()\n             .trim_matches('\"')\n@@ -428,7 +528,7 @@ fn parse_json_message(json_message: &str, krate: &Crate) -> ClippyWarning {\n }\n \n /// Generate a short list of occuring lints-types and their count\n-fn gather_stats(clippy_warnings: &[ClippyWarning]) -> String {\n+fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String, usize>) {\n     // count lint type occurrences\n     let mut counter: HashMap<&String, usize> = HashMap::new();\n     clippy_warnings\n@@ -441,63 +541,88 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> String {\n     // to not have a lint with 200 and 2 warnings take the same spot\n     stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n \n-    stats\n+    let stats_string = stats\n         .iter()\n         .map(|(lint, count)| format!(\"{} {}\\n\", lint, count))\n-        .collect::<String>()\n+        .collect::<String>();\n+\n+    (stats_string, counter)\n }\n \n /// check if the latest modification of the logfile is older than the modification date of the\n /// clippy binary, if this is true, we should clean the lintchec shared target directory and recheck\n-fn lintcheck_needs_rerun(toml_path: Option<&str>) -> bool {\n+fn lintcheck_needs_rerun(lintcheck_logs_path: &Path) -> bool {\n+    if !lintcheck_logs_path.exists() {\n+        return true;\n+    }\n+\n     let clippy_modified: std::time::SystemTime = {\n-        let mut times = [\"target/debug/clippy-driver\", \"target/debug/cargo-clippy\"]\n-            .iter()\n-            .map(|p| {\n-                std::fs::metadata(p)\n-                    .expect(\"failed to get metadata of file\")\n-                    .modified()\n-                    .expect(\"failed to get modification date\")\n-            });\n-        // the lates modification of either of the binaries\n+        let mut times = [CLIPPY_DRIVER_PATH, CARGO_CLIPPY_PATH].iter().map(|p| {\n+            std::fs::metadata(p)\n+                .expect(\"failed to get metadata of file\")\n+                .modified()\n+                .expect(\"failed to get modification date\")\n+        });\n+        // the oldest modification of either of the binaries\n         std::cmp::max(times.next().unwrap(), times.next().unwrap())\n     };\n \n-    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_config_toml(toml_path))\n+    let logs_modified: std::time::SystemTime = std::fs::metadata(lintcheck_logs_path)\n         .expect(\"failed to get metadata of file\")\n         .modified()\n         .expect(\"failed to get modification date\");\n \n-    // if clippys modification time is bigger (older) than the logs mod time, we need to rerun lintcheck\n-    clippy_modified > logs_modified\n+    // time is represented in seconds since X\n+    // logs_modified 2 and clippy_modified 5 means clippy binary is older and we need to recheck\n+    logs_modified < clippy_modified\n+}\n+\n+fn is_in_clippy_root() -> bool {\n+    if let Ok(pb) = std::env::current_dir() {\n+        if let Some(file) = pb.file_name() {\n+            return file == PathBuf::from(\"rust-clippy\");\n+        }\n+    }\n+\n+    false\n }\n \n /// lintchecks `main()` function\n-pub fn run(clap_config: &ArgMatches) {\n+///\n+/// # Panics\n+///\n+/// This function panics if the clippy binaries don't exist\n+/// or if lintcheck is executed from the wrong directory (aka none-repo-root)\n+pub fn main() {\n+    // assert that we launch lintcheck from the repo root (via cargo lintcheck)\n+    if !is_in_clippy_root() {\n+        eprintln!(\"lintcheck needs to be run from clippys repo root!\\nUse `cargo lintcheck` alternatively.\");\n+        std::process::exit(3);\n+    }\n+\n+    let clap_config = &get_clap_config();\n+\n+    let config = LintcheckConfig::from_clap(clap_config);\n+\n     println!(\"Compiling clippy...\");\n     build_clippy();\n     println!(\"Done compiling\");\n \n-    let clap_toml_path = clap_config.value_of(\"crates-toml\");\n-\n     // if the clippy bin is newer than our logs, throw away target dirs to force clippy to\n     // refresh the logs\n-    if lintcheck_needs_rerun(clap_toml_path) {\n+    if lintcheck_needs_rerun(&config.lintcheck_results_path) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n-        match std::fs::metadata(&shared_target_dir) {\n-            Ok(metadata) => {\n-                if metadata.is_dir() {\n-                    println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n-                    std::fs::remove_dir_all(&shared_target_dir)\n-                        .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n-                }\n-            },\n-            Err(_) => { // dir probably does not exist, don't remove anything\n-            },\n+        // if we get an Err here, the shared target dir probably does simply not exist\n+        if let Ok(metadata) = std::fs::metadata(&shared_target_dir) {\n+            if metadata.is_dir() {\n+                println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n+                std::fs::remove_dir_all(&shared_target_dir)\n+                    .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n+            }\n         }\n     }\n \n-    let cargo_clippy_path: PathBuf = PathBuf::from(\"target/debug/cargo-clippy\")\n+    let cargo_clippy_path: PathBuf = PathBuf::from(CARGO_CLIPPY_PATH)\n         .canonicalize()\n         .expect(\"failed to canonicalize path to clippy binary\");\n \n@@ -508,7 +633,7 @@ pub fn run(clap_config: &ArgMatches) {\n         cargo_clippy_path.display()\n     );\n \n-    let clippy_ver = std::process::Command::new(\"target/debug/cargo-clippy\")\n+    let clippy_ver = std::process::Command::new(CARGO_CLIPPY_PATH)\n         .arg(\"--version\")\n         .output()\n         .map(|o| String::from_utf8_lossy(&o.stdout).into_owned())\n@@ -517,20 +642,23 @@ pub fn run(clap_config: &ArgMatches) {\n     // download and extract the crates, then run clippy on them and collect clippys warnings\n     // flatten into one big list of warnings\n \n-    let (filename, crates) = read_crates(clap_toml_path);\n+    let crates = read_crates(&config.sources_toml_path);\n+    let old_stats = read_stats_from_file(&config.lintcheck_results_path);\n+\n+    let counter = AtomicUsize::new(1);\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n         if !crates.iter().any(|krate| {\n             let name = match krate {\n-                CrateSource::CratesIo { name, .. } => name,\n-                CrateSource::Git { name, .. } => name,\n-                CrateSource::Path { name, .. } => name,\n+                CrateSource::CratesIo { name, .. } | CrateSource::Git { name, .. } | CrateSource::Path { name, .. } => {\n+                    name\n+                },\n             };\n             name == only_one_crate\n         }) {\n             eprintln!(\n-                \"ERROR: could not find crate '{}' in clippy_dev/lintcheck_crates.toml\",\n+                \"ERROR: could not find crate '{}' in lintcheck/lintcheck_crates.toml\",\n                 only_one_crate\n             );\n             std::process::exit(1);\n@@ -541,52 +669,51 @@ pub fn run(clap_config: &ArgMatches) {\n             .into_iter()\n             .map(|krate| krate.download_and_extract())\n             .filter(|krate| krate.name == only_one_crate)\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1))\n-            .flatten()\n+            .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1, config.fix))\n             .collect()\n     } else {\n-        let counter = std::sync::atomic::AtomicUsize::new(0);\n-\n-        // Ask rayon for thread count. Assume that half of that is the number of physical cores\n-        // Use one target dir for each core so that we can run N clippys in parallel.\n-        // We need to use different target dirs because cargo would lock them for a single build otherwise,\n-        // killing the parallelism. However this also means that deps will only be reused half/a\n-        // quarter of the time which might result in a longer wall clock runtime\n-\n-        // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n-        // order to achive some kind of parallelism\n-\n-        // by default, use a single thread\n-        let num_cpus = match clap_config.value_of(\"threads\") {\n-            Some(threads) => {\n-                let threads: usize = threads\n-                    .parse()\n-                    .expect(&format!(\"Failed to parse '{}' to a digit\", threads));\n-                if threads == 0 {\n-                    // automatic choice\n-                    // Rayon seems to return thread count so half that for core count\n-                    (rayon::current_num_threads() / 2) as usize\n-                } else {\n-                    threads\n-                }\n-            },\n-            // no -j passed, use a single thread\n-            None => 1,\n-        };\n-\n-        let num_crates = crates.len();\n-\n-        // check all crates (default)\n-        crates\n-            .into_par_iter()\n-            .map(|krate| krate.download_and_extract())\n-            .map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates))\n-            .flatten()\n-            .collect()\n+        if config.max_jobs > 1 {\n+            // run parallel with rayon\n+\n+            // Ask rayon for thread count. Assume that half of that is the number of physical cores\n+            // Use one target dir for each core so that we can run N clippys in parallel.\n+            // We need to use different target dirs because cargo would lock them for a single build otherwise,\n+            // killing the parallelism. However this also means that deps will only be reused half/a\n+            // quarter of the time which might result in a longer wall clock runtime\n+\n+            // This helps when we check many small crates with dep-trees that don't have a lot of branches in\n+            // order to achive some kind of parallelism\n+\n+            // by default, use a single thread\n+            let num_cpus = config.max_jobs;\n+            let num_crates = crates.len();\n+\n+            // check all crates (default)\n+            crates\n+                .into_par_iter()\n+                .map(|krate| krate.download_and_extract())\n+                .flat_map(|krate| {\n+                    krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates, config.fix)\n+                })\n+                .collect()\n+        } else {\n+            // run sequential\n+            let num_crates = crates.len();\n+            crates\n+                .into_iter()\n+                .map(|krate| krate.download_and_extract())\n+                .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates, config.fix))\n+                .collect()\n+        }\n     };\n \n+    // if we are in --fix mode, don't change the log files, terminate here\n+    if config.fix {\n+        return;\n+    }\n+\n     // generate some stats\n-    let stats_formatted = gather_stats(&clippy_warnings);\n+    let (stats_formatted, new_stats) = gather_stats(&clippy_warnings);\n \n     // grab crashes/ICEs, save the crate name and the ice message\n     let ices: Vec<(&String, &String)> = clippy_warnings\n@@ -595,9 +722,9 @@ pub fn run(clap_config: &ArgMatches) {\n         .map(|w| (&w.crate_name, &w.message))\n         .collect();\n \n-    let mut all_msgs: Vec<String> = clippy_warnings.iter().map(|warning| warning.to_string()).collect();\n+    let mut all_msgs: Vec<String> = clippy_warnings.iter().map(ToString::to_string).collect();\n     all_msgs.sort();\n-    all_msgs.push(\"\\n\\n\\n\\nStats\\n\\n\".into());\n+    all_msgs.push(\"\\n\\n\\n\\nStats:\\n\".into());\n     all_msgs.push(stats_formatted);\n \n     // save the text into lintcheck-logs/logs.txt\n@@ -607,7 +734,184 @@ pub fn run(clap_config: &ArgMatches) {\n     ices.iter()\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n-    let file = format!(\"lintcheck-logs/{}_logs.txt\", filename);\n-    println!(\"Writing logs to {}\", file);\n-    write(file, text).unwrap();\n+    println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n+    write(&config.lintcheck_results_path, text).unwrap();\n+\n+    print_stats(old_stats, new_stats);\n+}\n+\n+/// read the previous stats from the lintcheck-log file\n+fn read_stats_from_file(file_path: &Path) -> HashMap<String, usize> {\n+    let file_content: String = match std::fs::read_to_string(file_path).ok() {\n+        Some(content) => content,\n+        None => {\n+            return HashMap::new();\n+        },\n+    };\n+\n+    let lines: Vec<String> = file_content.lines().map(ToString::to_string).collect();\n+\n+    // search for the beginning \"Stats:\" and the end \"ICEs:\" of the section we want\n+    let start = lines.iter().position(|line| line == \"Stats:\").unwrap();\n+    let end = lines.iter().position(|line| line == \"ICEs:\").unwrap();\n+\n+    let stats_lines = &lines[start + 1..end];\n+\n+    stats_lines\n+        .iter()\n+        .map(|line| {\n+            let mut spl = line.split(' ');\n+            (\n+                spl.next().unwrap().to_string(),\n+                spl.next().unwrap().parse::<usize>().unwrap(),\n+            )\n+        })\n+        .collect::<HashMap<String, usize>>()\n+}\n+\n+/// print how lint counts changed between runs\n+fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>) {\n+    let same_in_both_hashmaps = old_stats\n+        .iter()\n+        .filter(|(old_key, old_val)| new_stats.get::<&String>(&old_key) == Some(old_val))\n+        .map(|(k, v)| (k.to_string(), *v))\n+        .collect::<Vec<(String, usize)>>();\n+\n+    let mut old_stats_deduped = old_stats;\n+    let mut new_stats_deduped = new_stats;\n+\n+    // remove duplicates from both hashmaps\n+    same_in_both_hashmaps.iter().for_each(|(k, v)| {\n+        assert!(old_stats_deduped.remove(k) == Some(*v));\n+        assert!(new_stats_deduped.remove(k) == Some(*v));\n+    });\n+\n+    println!(\"\\nStats:\");\n+\n+    // list all new counts  (key is in new stats but not in old stats)\n+    new_stats_deduped\n+        .iter()\n+        .filter(|(new_key, _)| old_stats_deduped.get::<str>(&new_key).is_none())\n+        .for_each(|(new_key, new_value)| {\n+            println!(\"{} 0 => {}\", new_key, new_value);\n+        });\n+\n+    // list all changed counts (key is in both maps but value differs)\n+    new_stats_deduped\n+        .iter()\n+        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(&new_key).is_some())\n+        .for_each(|(new_key, new_val)| {\n+            let old_val = old_stats_deduped.get::<str>(&new_key).unwrap();\n+            println!(\"{} {} => {}\", new_key, old_val, new_val);\n+        });\n+\n+    // list all gone counts (key is in old status but not in new stats)\n+    old_stats_deduped\n+        .iter()\n+        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(&old_key).is_none())\n+        .for_each(|(old_key, old_value)| {\n+            println!(\"{} {} => 0\", old_key, old_value);\n+        });\n+}\n+\n+/// Create necessary directories to run the lintcheck tool.\n+///\n+/// # Panics\n+///\n+/// This function panics if creating one of the dirs fails.\n+fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n+    std::fs::create_dir(\"target/lintcheck/\").unwrap_or_else(|err| {\n+        if err.kind() != ErrorKind::AlreadyExists {\n+            panic!(\"cannot create lintcheck target dir\");\n+        }\n+    });\n+    std::fs::create_dir(&krate_download_dir).unwrap_or_else(|err| {\n+        if err.kind() != ErrorKind::AlreadyExists {\n+            panic!(\"cannot create crate download dir\");\n+        }\n+    });\n+    std::fs::create_dir(&extract_dir).unwrap_or_else(|err| {\n+        if err.kind() != ErrorKind::AlreadyExists {\n+            panic!(\"cannot create crate extraction dir\");\n+        }\n+    });\n+}\n+\n+fn get_clap_config<'a>() -> ArgMatches<'a> {\n+    App::new(\"lintcheck\")\n+        .about(\"run clippy on a set of crates and check output\")\n+        .arg(\n+            Arg::with_name(\"only\")\n+                .takes_value(true)\n+                .value_name(\"CRATE\")\n+                .long(\"only\")\n+                .help(\"only process a single crate of the list\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"crates-toml\")\n+                .takes_value(true)\n+                .value_name(\"CRATES-SOURCES-TOML-PATH\")\n+                .long(\"crates-toml\")\n+                .help(\"set the path for a crates.toml where lintcheck should read the sources from\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"threads\")\n+                .takes_value(true)\n+                .value_name(\"N\")\n+                .short(\"j\")\n+                .long(\"jobs\")\n+                .help(\"number of threads to use, 0 automatic choice\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"fix\")\n+                .long(\"--fix\")\n+                .help(\"runs cargo clippy --fix and checks if all suggestions apply\"),\n+        )\n+        .get_matches()\n+}\n+\n+/// Returns the path to the Clippy project directory\n+///\n+/// # Panics\n+///\n+/// Panics if the current directory could not be retrieved, there was an error reading any of the\n+/// Cargo.toml files or ancestor directory is the clippy root directory\n+#[must_use]\n+pub fn clippy_project_root() -> PathBuf {\n+    let current_dir = std::env::current_dir().unwrap();\n+    for path in current_dir.ancestors() {\n+        let result = std::fs::read_to_string(path.join(\"Cargo.toml\"));\n+        if let Err(err) = &result {\n+            if err.kind() == std::io::ErrorKind::NotFound {\n+                continue;\n+            }\n+        }\n+\n+        let content = result.unwrap();\n+        if content.contains(\"[package]\\nname = \\\"clippy\\\"\") {\n+            return path.to_path_buf();\n+        }\n+    }\n+    panic!(\"error: Can't determine root of project. Please run inside a Clippy working dir.\");\n+}\n+\n+#[test]\n+fn lintcheck_test() {\n+    let args = [\n+        \"run\",\n+        \"--target-dir\",\n+        \"lintcheck/target\",\n+        \"--manifest-path\",\n+        \"./lintcheck/Cargo.toml\",\n+        \"--\",\n+        \"--crates-toml\",\n+        \"lintcheck/test_sources.toml\",\n+    ];\n+    let status = std::process::Command::new(\"cargo\")\n+        .args(&args)\n+        .current_dir(\"..\") // repo root\n+        .status();\n+    //.output();\n+\n+    assert!(status.unwrap().success());\n }", "previous_filename": "clippy_dev/src/lintcheck.rs"}, {"sha": "4b0eb71ef4bfe1fa01c103e0c3e8be283ba18b1e", "filename": "lintcheck/test_sources.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Ftest_sources.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/lintcheck%2Ftest_sources.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Ftest_sources.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,4 @@\n+[crates]\n+cc = {name = \"cc\", versions = ['1.0.67']}\n+home = {name = \"home\", git_url = \"https://github.com/brson/home\", git_hash = \"32044e53dfbdcd32bafad3109d1fbab805fc0f40\"}\n+rustc_tools_util = {name = \"rustc_tools_util\", versions = ['0.2.0']}"}, {"sha": "0d95c86aef0308ac39fd81f24cfdfe5cea4ac0d2", "filename": "mini-macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/mini-macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/mini-macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mini-macro%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,13 +1,7 @@\n [package]\n name = \"clippy-mini-macro-test\"\n version = \"0.2.0\"\n-authors = [\n-\t\"Manish Goregaokar <manishsmail@gmail.com>\",\n-\t\"Andre Bogus <bogusandre@gmail.com>\",\n-\t\"Georg Brandl <georg@python.org>\",\n-\t\"Martin Carton <cartonmartin@gmail.com>\",\n-\t\"Oliver Schneider <clippy-iethah7aipeen8neex1a@oli-obk.de>\"\n-]\n+authors = [\"The Rust Clippy Developers\"]\n license = \"MIT OR Apache-2.0\"\n description = \"A macro to test clippy's procedural macro checks\"\n repository = \"https://github.com/rust-lang/rust-clippy\""}, {"sha": "c52a7f2e74321884b633f1e0b89f3932fc3ee83f", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-02-25\"\n+channel = \"nightly-2021-03-11\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "2972bc6d51ca8e75a32af8fdcc5811765954a456", "filename": "rustc_tools_util/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rustc_tools_util%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rustc_tools_util%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tools_util%2FCargo.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"rustc_tools_util\"\n version = \"0.2.0\"\n-authors = [\"Matthias Kr\u00fcger <matthias.krueger@famsik.de>\"]\n+authors = [\"The Rust Clippy Developers\"]\n description = \"small helper to generate version information for git packages\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "4b415a31b272eab0995e7f6d8dec936ccdb0146a", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -4,3 +4,4 @@ match_block_trailing_comma = true\n wrap_comments = true\n edition = \"2018\"\n error_on_line_overflow = true\n+version = \"Two\""}, {"sha": "30272c9b8006870747e1ce53704ce7c2f4248e4c", "filename": "src/driver.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -11,8 +11,12 @@\n extern crate rustc_driver;\n extern crate rustc_errors;\n extern crate rustc_interface;\n+extern crate rustc_session;\n+extern crate rustc_span;\n \n use rustc_interface::interface;\n+use rustc_session::Session;\n+use rustc_span::symbol::Symbol;\n use rustc_tools_util::VersionInfo;\n \n use std::borrow::Cow;\n@@ -59,20 +63,53 @@ fn test_arg_value() {\n     assert_eq!(arg_value(args, \"--foo\", |_| true), None);\n }\n \n+fn track_clippy_args(sess: &Session, args_env_var: &Option<String>) {\n+    sess.parse_sess.env_depinfo.borrow_mut().insert((\n+        Symbol::intern(\"CLIPPY_ARGS\"),\n+        args_env_var.as_deref().map(Symbol::intern),\n+    ));\n+}\n+\n struct DefaultCallbacks;\n impl rustc_driver::Callbacks for DefaultCallbacks {}\n \n-struct ClippyCallbacks;\n+/// This is different from `DefaultCallbacks` that it will inform Cargo to track the value of\n+/// `CLIPPY_ARGS` environment variable.\n+struct RustcCallbacks {\n+    clippy_args_var: Option<String>,\n+}\n+\n+impl rustc_driver::Callbacks for RustcCallbacks {\n+    fn config(&mut self, config: &mut interface::Config) {\n+        let previous = config.register_lints.take();\n+        let clippy_args_var = self.clippy_args_var.take();\n+        config.register_lints = Some(Box::new(move |sess, lint_store| {\n+            if let Some(ref previous) = previous {\n+                (previous)(sess, lint_store);\n+            }\n+\n+            track_clippy_args(sess, &clippy_args_var);\n+        }));\n+    }\n+}\n+\n+struct ClippyCallbacks {\n+    clippy_args_var: Option<String>,\n+}\n+\n impl rustc_driver::Callbacks for ClippyCallbacks {\n     fn config(&mut self, config: &mut interface::Config) {\n         let previous = config.register_lints.take();\n+        let clippy_args_var = self.clippy_args_var.take();\n         config.register_lints = Some(Box::new(move |sess, mut lint_store| {\n             // technically we're ~guaranteed that this is none but might as well call anything that\n             // is there already. Certainly it can't hurt.\n             if let Some(previous) = &previous {\n                 (previous)(sess, lint_store);\n             }\n \n+            track_clippy_args(sess, &clippy_args_var);\n+\n             let conf = clippy_lints::read_conf(&[], &sess);\n             clippy_lints::register_plugins(&mut lint_store, &sess, &conf);\n             clippy_lints::register_pre_expansion_lints(&mut lint_store);\n@@ -277,7 +314,9 @@ pub fn main() {\n         };\n \n         let mut no_deps = false;\n-        let clippy_args = env::var(\"CLIPPY_ARGS\")\n+        let clippy_args_var = env::var(\"CLIPPY_ARGS\").ok();\n+        let clippy_args = clippy_args_var\n+            .as_deref()\n             .unwrap_or_default()\n             .split(\"__CLIPPY_HACKERY__\")\n             .filter_map(|s| match s {\n@@ -305,11 +344,10 @@ pub fn main() {\n             args.extend(clippy_args);\n         }\n \n-        let mut clippy = ClippyCallbacks;\n-        let mut default = DefaultCallbacks;\n-        let callbacks: &mut (dyn rustc_driver::Callbacks + Send) =\n-            if clippy_enabled { &mut clippy } else { &mut default };\n-\n-        rustc_driver::RunCompiler::new(&args, callbacks).run()\n+        if clippy_enabled {\n+            rustc_driver::RunCompiler::new(&args, &mut ClippyCallbacks { clippy_args_var }).run()\n+        } else {\n+            rustc_driver::RunCompiler::new(&args, &mut RustcCallbacks { clippy_args_var }).run()\n+        }\n     }))\n }"}, {"sha": "7bb80b1196e5900dd2169a91e6d7ab5977c918d6", "filename": "src/main.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -92,12 +92,6 @@ impl ClippyCmd {\n             panic!(\"Usage of `--fix` requires `-Z unstable-options`\");\n         }\n \n-        // Run the dogfood tests directly on nightly cargo. This is required due\n-        // to a bug in rustup.rs when running cargo on custom toolchains. See issue #3118.\n-        if env::var_os(\"CLIPPY_DOGFOOD\").is_some() && cfg!(windows) {\n-            args.insert(0, \"+nightly\".to_string());\n-        }\n-\n         let mut clippy_args: Vec<String> = old_args.collect();\n         if cargo_subcommand == \"fix\" && !clippy_args.iter().any(|arg| arg == \"--no-deps\") {\n             clippy_args.push(\"--no-deps\".into());"}, {"sha": "d92530f073f56285738fcc93d9c4eaef779691d0", "filename": "tests/dogfood.rs", "status": "modified", "additions": 84, "deletions": 38, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -3,7 +3,7 @@\n #![feature(once_cell)]\n \n use std::lazy::SyncLazy;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::process::Command;\n \n mod cargo;\n@@ -23,7 +23,7 @@ fn dogfood_clippy() {\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n-        .arg(\"clippy-preview\")\n+        .arg(\"clippy\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")\n         .arg(\"--\")\n@@ -45,40 +45,53 @@ fn dogfood_clippy() {\n     assert!(output.status.success());\n }\n \n-#[test]\n-fn dogfood_subprojects() {\n-    fn test_no_deps_ignores_path_deps_in_workspaces() {\n-        fn clean(cwd: &Path, target_dir: &Path) {\n-            Command::new(\"cargo\")\n-                .current_dir(cwd)\n-                .env(\"CARGO_TARGET_DIR\", target_dir)\n-                .arg(\"clean\")\n-                .args(&[\"-p\", \"subcrate\"])\n-                .args(&[\"-p\", \"path_dep\"])\n-                .output()\n-                .unwrap();\n-        }\n-\n-        if cargo::is_rustc_test_suite() {\n-            return;\n-        }\n-        let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n-        let target_dir = root.join(\"target\").join(\"dogfood\");\n-        let cwd = root.join(\"clippy_workspace_tests\");\n+fn test_no_deps_ignores_path_deps_in_workspaces() {\n+    if cargo::is_rustc_test_suite() {\n+        return;\n+    }\n+    let root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+    let target_dir = root.join(\"target\").join(\"dogfood\");\n+    let cwd = root.join(\"clippy_workspace_tests\");\n+\n+    // Make sure we start with a clean state\n+    Command::new(\"cargo\")\n+        .current_dir(&cwd)\n+        .env(\"CARGO_TARGET_DIR\", &target_dir)\n+        .arg(\"clean\")\n+        .args(&[\"-p\", \"subcrate\"])\n+        .args(&[\"-p\", \"path_dep\"])\n+        .output()\n+        .unwrap();\n+\n+    // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n+    // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n+    let output = Command::new(&*CLIPPY_PATH)\n+        .current_dir(&cwd)\n+        .env(\"CLIPPY_DOGFOOD\", \"1\")\n+        .env(\"CARGO_INCREMENTAL\", \"0\")\n+        .arg(\"clippy\")\n+        .args(&[\"-p\", \"subcrate\"])\n+        .arg(\"--\")\n+        .arg(\"--no-deps\")\n+        .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n+        .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n+        .output()\n+        .unwrap();\n+    println!(\"status: {}\", output.status);\n+    println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+    println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n \n-        // Make sure we start with a clean state\n-        clean(&cwd, &target_dir);\n+    assert!(output.status.success());\n \n-        // `path_dep` is a path dependency of `subcrate` that would trigger a denied lint.\n-        // Make sure that with the `--no-deps` argument Clippy does not run on `path_dep`.\n+    let lint_path_dep = || {\n+        // Test that without the `--no-deps` argument, `path_dep` is linted.\n         let output = Command::new(&*CLIPPY_PATH)\n             .current_dir(&cwd)\n             .env(\"CLIPPY_DOGFOOD\", \"1\")\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .arg(\"clippy\")\n             .args(&[\"-p\", \"subcrate\"])\n             .arg(\"--\")\n-            .arg(\"--no-deps\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n             .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n             .output()\n@@ -87,12 +100,18 @@ fn dogfood_subprojects() {\n         println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n         println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n \n-        assert!(output.status.success());\n+        assert!(!output.status.success());\n+        assert!(\n+            String::from_utf8(output.stderr)\n+                .unwrap()\n+                .contains(\"error: empty `loop {}` wastes CPU cycles\")\n+        );\n+    };\n \n-        // Make sure we start with a clean state\n-        clean(&cwd, &target_dir);\n+    // Make sure Cargo is aware of the removal of `--no-deps`.\n+    lint_path_dep();\n \n-        // Test that without the `--no-deps` argument, `path_dep` is linted.\n+    let successful_build = || {\n         let output = Command::new(&*CLIPPY_PATH)\n             .current_dir(&cwd)\n             .env(\"CLIPPY_DOGFOOD\", \"1\")\n@@ -101,16 +120,32 @@ fn dogfood_subprojects() {\n             .args(&[\"-p\", \"subcrate\"])\n             .arg(\"--\")\n             .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .args(&[\"--cfg\", r#\"feature=\"primary_package_test\"\"#])\n             .output()\n             .unwrap();\n         println!(\"status: {}\", output.status);\n         println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n         println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n \n-        assert!(!output.status.success());\n-    }\n+        assert!(output.status.success());\n+\n+        output\n+    };\n \n+    // Trigger a sucessful build, so Cargo would like to cache the build result.\n+    successful_build();\n+\n+    // Make sure there's no spurious rebuild when nothing changes.\n+    let stderr = String::from_utf8(successful_build().stderr).unwrap();\n+    assert!(!stderr.contains(\"Compiling\"));\n+    assert!(!stderr.contains(\"Checking\"));\n+    assert!(stderr.contains(\"Finished\"));\n+\n+    // Make sure Cargo is aware of the new `--cfg` flag.\n+    lint_path_dep();\n+}\n+\n+#[test]\n+fn dogfood_subprojects() {\n     // run clippy on remaining subprojects and fail the test if lint warnings are reported\n     if cargo::is_rustc_test_suite() {\n         return;\n@@ -124,19 +159,30 @@ fn dogfood_subprojects() {\n         \"clippy_workspace_tests/subcrate\",\n         \"clippy_workspace_tests/subcrate/src\",\n         \"clippy_dev\",\n+        \"clippy_lints\",\n+        \"clippy_utils\",\n         \"rustc_tools_util\",\n     ] {\n-        let output = Command::new(&*CLIPPY_PATH)\n+        let mut command = Command::new(&*CLIPPY_PATH);\n+        command\n             .current_dir(root_dir.join(d))\n             .env(\"CLIPPY_DOGFOOD\", \"1\")\n             .env(\"CARGO_INCREMENTAL\", \"0\")\n             .arg(\"clippy\")\n+            .arg(\"--all-targets\")\n+            .arg(\"--all-features\")\n             .arg(\"--\")\n             .args(&[\"-D\", \"clippy::all\"])\n             .args(&[\"-D\", \"clippy::pedantic\"])\n-            .arg(\"-Cdebuginfo=0\") // disable debuginfo to generate less data in the target dir\n-            .output()\n-            .unwrap();\n+            .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n+\n+        // internal lints only exist if we build with the internal-lints feature\n+        if cfg!(feature = \"internal-lints\") {\n+            command.args(&[\"-D\", \"clippy::internal\"]);\n+        }\n+\n+        let output = command.output().unwrap();\n+\n         println!(\"status: {}\", output.status);\n         println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n         println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));"}, {"sha": "3f754c255b749b2ff2687ceb70252c6beacc1e8f", "filename": "tests/lint_message_convention.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flint_message_convention.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,108 @@\n+use std::ffi::OsStr;\n+use std::path::PathBuf;\n+\n+use regex::RegexSet;\n+\n+#[derive(Debug)]\n+struct Message {\n+    path: PathBuf,\n+    bad_lines: Vec<String>,\n+}\n+\n+impl Message {\n+    fn new(path: PathBuf) -> Self {\n+        let content: String = std::fs::read_to_string(&path).unwrap();\n+        // we don't want the first letter after \"error: \", \"help: \" ... to be capitalized\n+        // also no puncutation (except for \"?\" ?) at the end of a line\n+        let regex_set: RegexSet = RegexSet::new(&[\n+            r\"error: [A-Z]\",\n+            r\"help: [A-Z]\",\n+            r\"warning: [A-Z]\",\n+            r\"note: [A-Z]\",\n+            r\"try this: [A-Z]\",\n+            r\"error: .*[.!]$\",\n+            r\"help: .*[.!]$\",\n+            r\"warning: .*[.!]$\",\n+            r\"note: .*[.!]$\",\n+            r\"try this: .*[.!]$\",\n+        ])\n+        .unwrap();\n+\n+        // sometimes the first character is capitalized and it is legal (like in \"C-like enum variants\") or\n+        // we want to ask a question ending in \"?\"\n+        let exceptions_set: RegexSet = RegexSet::new(&[\n+            r\".*C-like enum variant discriminant is not portable to 32-bit targets\",\n+            r\".*did you mean `unix`?\",\n+            r\".*the arguments may be inverted...\",\n+            r\".*Intel x86 assembly syntax used\",\n+            r\".*AT&T x86 assembly syntax used\",\n+            r\".*remove .*the return type...\",\n+            r\"note: Clippy version: .*\",\n+            r\"the compiler unexpectedly panicked. this is a bug.\",\n+        ])\n+        .unwrap();\n+\n+        let bad_lines = content\n+            .lines()\n+            .filter(|line| regex_set.matches(line).matched_any())\n+            // ignore exceptions\n+            .filter(|line| !exceptions_set.matches(line).matched_any())\n+            .map(ToOwned::to_owned)\n+            .collect::<Vec<String>>();\n+\n+        Message { path, bad_lines }\n+    }\n+}\n+\n+#[test]\n+fn lint_message_convention() {\n+    // disable the test inside the rustc test suite\n+    if option_env!(\"RUSTC_TEST_SUITE\").is_some() {\n+        return;\n+    }\n+\n+    // make sure that lint messages:\n+    // * are not capitalized\n+    // * don't have puncuation at the end of the last sentence\n+\n+    // these directories have interesting tests\n+    let test_dirs = [\"ui\", \"ui-cargo\", \"ui-internal\", \"ui-toml\"]\n+        .iter()\n+        .map(PathBuf::from)\n+        .map(|p| {\n+            let base = PathBuf::from(\"tests\");\n+            base.join(p)\n+        });\n+\n+    // gather all .stderr files\n+    let tests = test_dirs\n+        .flat_map(|dir| {\n+            std::fs::read_dir(dir)\n+                .expect(\"failed to read dir\")\n+                .map(|direntry| direntry.unwrap().path())\n+        })\n+        .filter(|file| matches!(file.extension().map(OsStr::to_str), Some(Some(\"stderr\"))));\n+\n+    // get all files that have any \"bad lines\" in them\n+    let bad_tests: Vec<Message> = tests\n+        .map(Message::new)\n+        .filter(|message| !message.bad_lines.is_empty())\n+        .collect();\n+\n+    bad_tests.iter().for_each(|message| {\n+        eprintln!(\n+            \"error: the test '{}' contained the following nonconforming lines :\",\n+            message.path.display()\n+        );\n+        message.bad_lines.iter().for_each(|line| eprintln!(\"{}\", line));\n+        eprintln!(\"\\n\\n\");\n+    });\n+\n+    eprintln!(\n+        \"\\n\\n\\nLint message should not start with a capital letter and should not have punctuation at the end of the message unless multiple sentences are needed.\"\n+    );\n+    eprintln!(\"Check out the rustc-dev-guide for more information:\");\n+    eprintln!(\"https://rustc-dev-guide.rust-lang.org/diagnostics.html#diagnostic-structure\\n\\n\\n\");\n+\n+    assert!(bad_tests.is_empty());\n+}"}, {"sha": "735909887acb189ac97b01a63708ae738989a2b1", "filename": "tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -16,7 +16,8 @@ enum Flags {\n     FIN,\n }\n \n-struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n-                         // `GccLlvmSomething`\n+// linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+// `GccLlvmSomething`\n+struct GCCLLVMSomething;\n \n fn main() {}"}, {"sha": "38e30683d5797334698914c934ab473821dae750", "filename": "tests/ui-toml/upper_case_acronyms_aggressive/upper_case_acronyms.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupper_case_acronyms_aggressive%2Fupper_case_acronyms.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -61,9 +61,9 @@ LL |     FIN,\n    |     ^^^ help: consider making the acronym lowercase, except the initial letter: `Fin`\n \n error: name `GCCLLVMSomething` contains a capitalized acronym\n-  --> $DIR/upper_case_acronyms.rs:19:8\n+  --> $DIR/upper_case_acronyms.rs:21:8\n    |\n-LL | struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+LL | struct GCCLLVMSomething;\n    |        ^^^^^^^^^^^^^^^^ help: consider making the acronym lowercase, except the initial letter: `GccllvmSomething`\n \n error: aborting due to 11 previous errors"}, {"sha": "cf194de3c55375f2aba1422fcf45527846678180", "filename": "tests/ui-toml/vec_box_sized/test.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,18 +1,18 @@\n-error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary\n   --> $DIR/test.rs:9:12\n    |\n LL | struct Foo(Vec<Box<u8>>);\n    |            ^^^^^^^^^^^^ help: try: `Vec<u8>`\n    |\n    = note: `-D clippy::vec-box` implied by `-D warnings`\n \n-error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary\n   --> $DIR/test.rs:10:12\n    |\n LL | struct Bar(Vec<Box<u32>>);\n    |            ^^^^^^^^^^^^^ help: try: `Vec<u32>`\n \n-error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary\n   --> $DIR/test.rs:13:18\n    |\n LL | struct FooBarBaz(Vec<Box<C>>);"}, {"sha": "e40668ed339f2ef40bf41e80d0fab5c881427110", "filename": "tests/ui/assign_ops2.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fassign_ops2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fassign_ops2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassign_ops2.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -5,7 +5,7 @@ LL |     a += a + 1;\n    |     ^^^^^^^^^^\n    |\n    = note: `-D clippy::misrefactored-assign-op` implied by `-D warnings`\n-help: Did you mean `a = a + 1` or `a = a + a + 1`? Consider replacing it with\n+help: did you mean `a = a + 1` or `a = a + a + 1`? Consider replacing it with\n    |\n LL |     a += 1;\n    |     ^^^^^^\n@@ -20,7 +20,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a += 1 + a;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a + 1` or `a = a + 1 + a`? Consider replacing it with\n+help: did you mean `a = a + 1` or `a = a + 1 + a`? Consider replacing it with\n    |\n LL |     a += 1;\n    |     ^^^^^^\n@@ -35,7 +35,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a -= a - 1;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a - 1` or `a = a - (a - 1)`? Consider replacing it with\n+help: did you mean `a = a - 1` or `a = a - (a - 1)`? Consider replacing it with\n    |\n LL |     a -= 1;\n    |     ^^^^^^\n@@ -50,7 +50,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a *= a * 99;\n    |     ^^^^^^^^^^^\n    |\n-help: Did you mean `a = a * 99` or `a = a * a * 99`? Consider replacing it with\n+help: did you mean `a = a * 99` or `a = a * a * 99`? Consider replacing it with\n    |\n LL |     a *= 99;\n    |     ^^^^^^^\n@@ -65,7 +65,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a *= 42 * a;\n    |     ^^^^^^^^^^^\n    |\n-help: Did you mean `a = a * 42` or `a = a * 42 * a`? Consider replacing it with\n+help: did you mean `a = a * 42` or `a = a * 42 * a`? Consider replacing it with\n    |\n LL |     a *= 42;\n    |     ^^^^^^^\n@@ -80,7 +80,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a /= a / 2;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a / 2` or `a = a / (a / 2)`? Consider replacing it with\n+help: did you mean `a = a / 2` or `a = a / (a / 2)`? Consider replacing it with\n    |\n LL |     a /= 2;\n    |     ^^^^^^\n@@ -95,7 +95,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a %= a % 5;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a % 5` or `a = a % (a % 5)`? Consider replacing it with\n+help: did you mean `a = a % 5` or `a = a % (a % 5)`? Consider replacing it with\n    |\n LL |     a %= 5;\n    |     ^^^^^^\n@@ -110,7 +110,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a &= a & 1;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a & 1` or `a = a & a & 1`? Consider replacing it with\n+help: did you mean `a = a & 1` or `a = a & a & 1`? Consider replacing it with\n    |\n LL |     a &= 1;\n    |     ^^^^^^\n@@ -125,7 +125,7 @@ error: variable appears on both sides of an assignment operation\n LL |     a *= a * a;\n    |     ^^^^^^^^^^\n    |\n-help: Did you mean `a = a * a` or `a = a * a * a`? Consider replacing it with\n+help: did you mean `a = a * a` or `a = a * a * a`? Consider replacing it with\n    |\n LL |     a *= a;\n    |     ^^^^^^"}, {"sha": "d4470d3f40708517027b62f158c11c692b70ecaf", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -23,11 +23,7 @@ macro_rules! try_err {\n         pub fn try_err_fn() -> Result<i32, i32> {\n             let err: i32 = 1;\n             // To avoid warnings during rustfix\n-            if true {\n-                Err(err)?\n-            } else {\n-                Ok(2)\n-            }\n+            if true { Err(err)? } else { Ok(2) }\n         }\n     };\n }"}, {"sha": "7dc3f4ebd4d4681d47b4af94635ee7644f3a2452", "filename": "tests/ui/auxiliary/option_helpers.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Foption_helpers.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -48,4 +48,8 @@ impl IteratorFalsePositives {\n     pub fn skip_while(self) -> IteratorFalsePositives {\n         self\n     }\n+\n+    pub fn count(self) -> usize {\n+        self.foo as usize\n+    }\n }"}, {"sha": "a5fcff7e0e44363f02087f6c87fdfacc46638734", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n   --> $DIR/await_holding_lock.rs:7:9\n    |\n LL |     let guard = x.lock().unwrap();\n@@ -13,7 +13,7 @@ LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n   --> $DIR/await_holding_lock.rs:28:9\n    |\n LL |     let guard = x.lock().unwrap();\n@@ -31,7 +31,7 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n   --> $DIR/await_holding_lock.rs:41:13\n    |\n LL |         let guard = x.lock().unwrap();\n@@ -45,7 +45,7 @@ LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n   --> $DIR/await_holding_lock.rs:53:13\n    |\n LL |         let guard = x.lock().unwrap();"}, {"sha": "55e41dbca96f834046b43c624e377ddcb6bbb6d3", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:7:9\n    |\n LL |     let b = x.borrow();\n@@ -13,7 +13,7 @@ LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:12:9\n    |\n LL |     let b = x.borrow_mut();\n@@ -27,7 +27,7 @@ LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:33:9\n    |\n LL |     let b = x.borrow_mut();\n@@ -45,7 +45,7 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:45:9\n    |\n LL |     let b = x.borrow_mut();\n@@ -63,7 +63,7 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:60:13\n    |\n LL |         let b = x.borrow_mut();\n@@ -77,7 +77,7 @@ LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await.\n+error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n   --> $DIR/await_holding_refcell_ref.rs:72:13\n    |\n LL |         let b = x.borrow_mut();"}, {"sha": "e6e40a9948c91880affcb75cc99c6d8f25627624", "filename": "tests/ui/blocks_in_if_conditions.fixed", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -4,9 +4,7 @@\n #![warn(clippy::nonminimal_bool)]\n \n macro_rules! blocky {\n-    () => {{\n-        true\n-    }};\n+    () => {{ true }};\n }\n \n macro_rules! blocky_too {\n@@ -34,20 +32,12 @@ fn condition_has_block() -> i32 {\n }\n \n fn condition_has_block_with_single_expression() -> i32 {\n-    if true {\n-        6\n-    } else {\n-        10\n-    }\n+    if true { 6 } else { 10 }\n }\n \n fn condition_is_normal() -> i32 {\n     let x = 3;\n-    if x == 3 {\n-        6\n-    } else {\n-        10\n-    }\n+    if x == 3 { 6 } else { 10 }\n }\n \n fn condition_is_unsafe_block() {\n@@ -61,14 +51,15 @@ fn condition_is_unsafe_block() {\n \n fn block_in_assert() {\n     let opt = Some(42);\n-    assert!(opt\n-        .as_ref()\n-        .map(|val| {\n-            let mut v = val * 2;\n-            v -= 1;\n-            v * 3\n-        })\n-        .is_some());\n+    assert!(\n+        opt.as_ref()\n+            .map(|val| {\n+                let mut v = val * 2;\n+                v -= 1;\n+                v * 3\n+            })\n+            .is_some()\n+    );\n }\n \n fn main() {}"}, {"sha": "69387ff5782b33d6451be91fe14c4a019dd1adf5", "filename": "tests/ui/blocks_in_if_conditions.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -4,9 +4,7 @@\n #![warn(clippy::nonminimal_bool)]\n \n macro_rules! blocky {\n-    () => {{\n-        true\n-    }};\n+    () => {{ true }};\n }\n \n macro_rules! blocky_too {\n@@ -34,20 +32,12 @@ fn condition_has_block() -> i32 {\n }\n \n fn condition_has_block_with_single_expression() -> i32 {\n-    if { true } {\n-        6\n-    } else {\n-        10\n-    }\n+    if { true } { 6 } else { 10 }\n }\n \n fn condition_is_normal() -> i32 {\n     let x = 3;\n-    if true && x == 3 {\n-        6\n-    } else {\n-        10\n-    }\n+    if true && x == 3 { 6 } else { 10 }\n }\n \n fn condition_is_unsafe_block() {\n@@ -61,14 +51,15 @@ fn condition_is_unsafe_block() {\n \n fn block_in_assert() {\n     let opt = Some(42);\n-    assert!(opt\n-        .as_ref()\n-        .map(|val| {\n-            let mut v = val * 2;\n-            v -= 1;\n-            v * 3\n-        })\n-        .is_some());\n+    assert!(\n+        opt.as_ref()\n+            .map(|val| {\n+                let mut v = val * 2;\n+                v -= 1;\n+                v * 3\n+            })\n+            .is_some()\n+    );\n }\n \n fn main() {}"}, {"sha": "9328492733fd8ce480d45612373267aee5f2024b", "filename": "tests/ui/blocks_in_if_conditions.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fblocks_in_if_conditions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n error: in an `if` condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a `let`\n-  --> $DIR/blocks_in_if_conditions.rs:26:5\n+  --> $DIR/blocks_in_if_conditions.rs:24:5\n    |\n LL | /     if {\n LL | |         let x = 3;\n@@ -17,15 +17,15 @@ LL |     }; if res {\n    |\n \n error: omit braces around single expression condition\n-  --> $DIR/blocks_in_if_conditions.rs:37:8\n+  --> $DIR/blocks_in_if_conditions.rs:35:8\n    |\n-LL |     if { true } {\n+LL |     if { true } { 6 } else { 10 }\n    |        ^^^^^^^^ help: try: `true`\n \n error: this boolean expression can be simplified\n-  --> $DIR/blocks_in_if_conditions.rs:46:8\n+  --> $DIR/blocks_in_if_conditions.rs:40:8\n    |\n-LL |     if true && x == 3 {\n+LL |     if true && x == 3 { 6 } else { 10 }\n    |        ^^^^^^^^^^^^^^ help: try: `x == 3`\n    |\n    = note: `-D clippy::nonminimal-bool` implied by `-D warnings`"}, {"sha": "9b789334baeecb8db138d49f08db25a68509af78", "filename": "tests/ui/box_vec.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fbox_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fbox_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_vec.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -5,7 +5,7 @@ LL | pub fn test(foo: Box<Vec<bool>>) {\n    |                  ^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::box-vec` implied by `-D warnings`\n-   = help: `Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\n+   = help: `Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\n \n error: aborting due to previous error\n "}, {"sha": "369676308348ff4e4c361343c512959e32dce9ed", "filename": "tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -66,14 +66,16 @@ fn main() {\n     }\n     if x.is_ok() {\n         x = Err(());\n-        x.unwrap(); // not unnecessary because of mutation of x\n-                    // it will always panic but the lint is not smart enough to see this (it only\n-                    // checks if conditions).\n+        // not unnecessary because of mutation of x\n+        // it will always panic but the lint is not smart enough to see this (it only\n+        // checks if conditions).\n+        x.unwrap();\n     } else {\n         x = Ok(());\n-        x.unwrap_err(); // not unnecessary because of mutation of x\n-                        // it will always panic but the lint is not smart enough to see this (it\n-                        // only checks if conditions).\n+        // not unnecessary because of mutation of x\n+        // it will always panic but the lint is not smart enough to see this (it\n+        // only checks if conditions).\n+        x.unwrap_err();\n     }\n \n     assert!(x.is_ok(), \"{:?}\", x.unwrap_err()); // ok, it's a common test pattern"}, {"sha": "f44a3901fb48700973b336506e229b7dbe5220c9", "filename": "tests/ui/cmp_owned/without_suggestion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,5 @@\n #[allow(clippy::unnecessary_operation)]\n+#[allow(clippy::implicit_clone)]\n \n fn main() {\n     let x = &Baz;"}, {"sha": "2ea3d8fac0d1ad09139b754c4c67a6af409833a4", "filename": "tests/ui/cmp_owned/without_suggestion.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned%2Fwithout_suggestion.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,19 +1,19 @@\n error: this creates an owned instance just for comparison\n-  --> $DIR/without_suggestion.rs:6:5\n+  --> $DIR/without_suggestion.rs:7:5\n    |\n LL |     y.to_owned() == *x;\n    |     ^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating\n    |\n    = note: `-D clippy::cmp-owned` implied by `-D warnings`\n \n error: this creates an owned instance just for comparison\n-  --> $DIR/without_suggestion.rs:10:5\n+  --> $DIR/without_suggestion.rs:11:5\n    |\n LL |     y.to_owned() == **x;\n    |     ^^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating\n \n error: this creates an owned instance just for comparison\n-  --> $DIR/without_suggestion.rs:17:9\n+  --> $DIR/without_suggestion.rs:18:9\n    |\n LL |         self.to_owned() == *other\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ try implementing the comparison without allocating"}, {"sha": "be25a80dde0a199f80741787c8254b1e71e649af", "filename": "tests/ui/comparison_chain.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcomparison_chain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcomparison_chain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcomparison_chain.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -9,7 +9,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::comparison-chain` implied by `-D warnings`\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:27:5\n@@ -23,7 +23,7 @@ LL | |         c()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:35:5\n@@ -37,7 +37,7 @@ LL | |         c()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:43:5\n@@ -51,7 +51,7 @@ LL | |         c()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:117:5\n@@ -63,7 +63,7 @@ LL | |         b()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:123:5\n@@ -77,7 +77,7 @@ LL | |         c()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: `if` chain can be rewritten with `match`\n   --> $DIR/comparison_chain.rs:131:5\n@@ -91,7 +91,7 @@ LL | |         c()\n LL | |     }\n    | |_____^\n    |\n-   = help: Consider rewriting the `if` chain to use `cmp` and `match`.\n+   = help: consider rewriting the `if` chain to use `cmp` and `match`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "67308263dadda67c160f9f436fa9fcb1c81542d1", "filename": "tests/ui/crashes/ice-6256.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6256.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -8,6 +8,7 @@ impl dyn TT {\n     fn func(&self) {}\n }\n \n+#[rustfmt::skip]\n fn main() {\n     let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n                                    //[nll]~^ ERROR: borrowed data escapes outside of closure"}, {"sha": "d35d459168f23dc12f4ec7f55b460c52f68c9585", "filename": "tests/ui/crashes/ice-6256.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6256.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6256.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6256.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,13 +1,13 @@\n error[E0308]: mismatched types\n-  --> $DIR/ice-6256.rs:12:28\n+  --> $DIR/ice-6256.rs:13:28\n    |\n LL |     let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n    |                            ^^^^ lifetime mismatch\n    |\n    = note: expected reference `&(dyn TT + 'static)`\n               found reference `&dyn TT`\n-note: the anonymous lifetime #1 defined on the body at 12:13...\n-  --> $DIR/ice-6256.rs:12:13\n+note: the anonymous lifetime #1 defined on the body at 13:13...\n+  --> $DIR/ice-6256.rs:13:13\n    |\n LL |     let f = |x: &dyn TT| x.func(); //[default]~ ERROR: mismatched types\n    |             ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "0e2ab1a39b82f98c0faefe4187c36f3c52b5a78f", "filename": "tests/ui/crashes/ice-6792.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6792.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6792.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6792.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,20 @@\n+//! This is a reproducer for the ICE 6792: https://github.com/rust-lang/rust-clippy/issues/6792.\n+//! The ICE is caused by using `TyCtxt::type_of(assoc_type_id)`.\n+\n+trait Trait {\n+    type Ty;\n+\n+    fn broken() -> Self::Ty;\n+}\n+\n+struct Foo {}\n+\n+impl Trait for Foo {\n+    type Ty = Foo;\n+\n+    fn broken() -> Self::Ty {\n+        Self::Ty {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "12a4a0d25ef5d79cb30f741bcc60a7d27489c481", "filename": "tests/ui/crashes/ice-6793.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6793.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,23 @@\n+//! This is a reproducer for the ICE 6793: https://github.com/rust-lang/rust-clippy/issues/6793.\n+//! The ICE is caused by using `TyCtxt::type_of(assoc_type_id)`, which is the same as the ICE 6792.\n+\n+trait Trait {\n+    type Ty: 'static + Clone;\n+\n+    fn broken() -> Self::Ty;\n+}\n+\n+#[derive(Clone)]\n+struct MyType {\n+    x: i32,\n+}\n+\n+impl Trait for MyType {\n+    type Ty = MyType;\n+\n+    fn broken() -> Self::Ty {\n+        Self::Ty { x: 1 }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "d789f60c5d5a0dd5a21aad82437bb58d6d29fd77", "filename": "tests/ui/crashes/ice-6840.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6840.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fcrashes%2Fice-6840.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6840.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,31 @@\n+//! This is a reproducer for the ICE 6840: https://github.com/rust-lang/rust-clippy/issues/6840.\n+//! The ICE is caused by `TyCtxt::layout_of` and `is_normalizable` not being strict enough\n+#![allow(dead_code)]\n+use std::collections::HashMap;\n+\n+pub trait Rule {\n+    type DependencyKey;\n+}\n+\n+pub struct RuleEdges<R: Rule> {\n+    dependencies: R::DependencyKey,\n+}\n+\n+type RuleDependencyEdges<R> = HashMap<u32, RuleEdges<R>>;\n+\n+// reproducer from the GitHub issue ends here\n+//   but check some additional variants\n+type RuleDependencyEdgesArray<R> = HashMap<u32, [RuleEdges<R>; 8]>;\n+type RuleDependencyEdgesSlice<R> = HashMap<u32, &'static [RuleEdges<R>]>;\n+type RuleDependencyEdgesRef<R> = HashMap<u32, &'static RuleEdges<R>>;\n+type RuleDependencyEdgesRaw<R> = HashMap<u32, *const RuleEdges<R>>;\n+type RuleDependencyEdgesTuple<R> = HashMap<u32, (RuleEdges<R>, RuleEdges<R>)>;\n+\n+// and an additional checks to make sure fix doesn't have stack-overflow issue\n+//   on self-containing types\n+pub struct SelfContaining {\n+    inner: Box<SelfContaining>,\n+}\n+type SelfContainingEdges = HashMap<u32, SelfContaining>;\n+\n+fn main() {}"}, {"sha": "d74e2611ee1fdad6c0596fe35ed44ef353317c6a", "filename": "tests/ui/dbg_macro.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdbg_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdbg_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,11 +1,7 @@\n #![warn(clippy::dbg_macro)]\n \n fn foo(n: u32) -> u32 {\n-    if let Some(n) = dbg!(n.checked_sub(4)) {\n-        n\n-    } else {\n-        n\n-    }\n+    if let Some(n) = dbg!(n.checked_sub(4)) { n } else { n }\n }\n \n fn factorial(n: u32) -> u32 {"}, {"sha": "bdf372af2907502aa13ea597e68e166bf259fd3a", "filename": "tests/ui/dbg_macro.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdbg_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdbg_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdbg_macro.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,17 +1,17 @@\n error: `dbg!` macro is intended as a debugging tool\n   --> $DIR/dbg_macro.rs:4:22\n    |\n-LL |     if let Some(n) = dbg!(n.checked_sub(4)) {\n+LL |     if let Some(n) = dbg!(n.checked_sub(4)) { n } else { n }\n    |                      ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::dbg-macro` implied by `-D warnings`\n help: ensure to avoid having uses of it in version control\n    |\n-LL |     if let Some(n) = n.checked_sub(4) {\n+LL |     if let Some(n) = n.checked_sub(4) { n } else { n }\n    |                      ^^^^^^^^^^^^^^^^\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:12:8\n+  --> $DIR/dbg_macro.rs:8:8\n    |\n LL |     if dbg!(n <= 1) {\n    |        ^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |     if n <= 1 {\n    |        ^^^^^^\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:13:9\n+  --> $DIR/dbg_macro.rs:9:9\n    |\n LL |         dbg!(1)\n    |         ^^^^^^^\n@@ -33,7 +33,7 @@ LL |         1\n    |\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:15:9\n+  --> $DIR/dbg_macro.rs:11:9\n    |\n LL |         dbg!(n * factorial(n - 1))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |         n * factorial(n - 1)\n    |\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:20:5\n+  --> $DIR/dbg_macro.rs:16:5\n    |\n LL |     dbg!(42);\n    |     ^^^^^^^^\n@@ -55,7 +55,7 @@ LL |     42;\n    |     ^^\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:21:5\n+  --> $DIR/dbg_macro.rs:17:5\n    |\n LL |     dbg!(dbg!(dbg!(42)));\n    |     ^^^^^^^^^^^^^^^^^^^^\n@@ -66,7 +66,7 @@ LL |     dbg!(dbg!(42));\n    |     ^^^^^^^^^^^^^^\n \n error: `dbg!` macro is intended as a debugging tool\n-  --> $DIR/dbg_macro.rs:22:14\n+  --> $DIR/dbg_macro.rs:18:14\n    |\n LL |     foo(3) + dbg!(factorial(4));\n    |              ^^^^^^^^^^^^^^^^^^"}, {"sha": "4c80cabc72305df9371c2854536d7195c7157279", "filename": "tests/ui/default_trait_access.fixed", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdefault_trait_access.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdefault_trait_access.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -48,25 +48,7 @@ fn main() {\n \n     println!(\n         \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}], [{:?}]\",\n-        s1,\n-        s2,\n-        s3,\n-        s4,\n-        s5,\n-        s6,\n-        s7,\n-        s8,\n-        s9,\n-        s10,\n-        s11,\n-        s12,\n-        s13,\n-        s14,\n-        s15,\n-        s16,\n-        s17,\n-        s18,\n-        s19,\n+        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,\n     );\n }\n "}, {"sha": "a68b6455c04165f683f4678aae1978a876b4725f", "filename": "tests/ui/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -48,25 +48,7 @@ fn main() {\n \n     println!(\n         \"[{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}] [{:?}], [{:?}]\",\n-        s1,\n-        s2,\n-        s3,\n-        s4,\n-        s5,\n-        s6,\n-        s7,\n-        s8,\n-        s9,\n-        s10,\n-        s11,\n-        s12,\n-        s13,\n-        s14,\n-        s15,\n-        s16,\n-        s17,\n-        s18,\n-        s19,\n+        s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19,\n     );\n }\n "}, {"sha": "234db33ba12421b4cb83803ecb794bf48aa097bd", "filename": "tests/ui/dlist.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdlist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdlist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdlist.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:9:16\n    |\n LL |     type Baz = LinkedList<u8>;\n@@ -7,39 +7,39 @@ LL |     type Baz = LinkedList<u8>;\n    = note: `-D clippy::linkedlist` implied by `-D warnings`\n    = help: a `VecDeque` might work\n \n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:10:15\n    |\n LL |     fn foo(_: LinkedList<u8>);\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:11:23\n    |\n LL |     const BAR: Option<LinkedList<u8>>;\n    |                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:22:15\n    |\n LL |     fn foo(_: LinkedList<u8>) {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:25:39\n    |\n LL | pub fn test(my_favourite_linked_list: LinkedList<u8>) {\n    |                                       ^^^^^^^^^^^^^^\n    |\n    = help: a `VecDeque` might work\n \n-error: I see you're using a LinkedList! Perhaps you meant some other data structure?\n+error: you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\n   --> $DIR/dlist.rs:29:29\n    |\n LL | pub fn test_ret() -> Option<LinkedList<u8>> {"}, {"sha": "17e72353f80391975c7ce7a018d82154f83bfea2", "filename": "tests/ui/doc_panics.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdoc_panics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdoc_panics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_panics.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -30,11 +30,7 @@ pub fn inner_body(opt: Option<u32>) {\n \n /// This needs to be documented\n pub fn unreachable_and_panic() {\n-    if true {\n-        unreachable!()\n-    } else {\n-        panic!()\n-    }\n+    if true { unreachable!() } else { panic!() }\n }\n \n /// This is documented\n@@ -84,11 +80,7 @@ pub fn todo_documented() {\n ///\n /// We still need to do this part\n pub fn unreachable_amd_panic_documented() {\n-    if true {\n-        unreachable!()\n-    } else {\n-        panic!()\n-    }\n+    if true { unreachable!() } else { panic!() }\n }\n \n /// This is okay because it is private"}, {"sha": "2fa88a2f6ec4bd76ddeec0207af7165209e47965", "filename": "tests/ui/doc_panics.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdoc_panics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdoc_panics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_panics.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -67,19 +67,15 @@ error: docs for function which may panic missing `# Panics` section\n   --> $DIR/doc_panics.rs:32:1\n    |\n LL | / pub fn unreachable_and_panic() {\n-LL | |     if true {\n-LL | |         unreachable!()\n-LL | |     } else {\n-LL | |         panic!()\n-LL | |     }\n+LL | |     if true { unreachable!() } else { panic!() }\n LL | | }\n    | |_^\n    |\n note: first possible panic found here\n-  --> $DIR/doc_panics.rs:36:9\n+  --> $DIR/doc_panics.rs:33:39\n    |\n-LL |         panic!()\n-   |         ^^^^^^^^\n+LL |     if true { unreachable!() } else { panic!() }\n+   |                                       ^^^^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors"}, {"sha": "01de0be7caea96cb907223cb49ddce57233d6eef", "filename": "tests/ui/drop_forget_copy.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdrop_forget_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdrop_forget_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_forget_copy.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact.\n+error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:33:5\n    |\n LL |     drop(s1);\n@@ -11,7 +11,7 @@ note: argument has type SomeStruct\n LL |     drop(s1);\n    |          ^^\n \n-error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact.\n+error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:34:5\n    |\n LL |     drop(s2);\n@@ -23,7 +23,7 @@ note: argument has type SomeStruct\n LL |     drop(s2);\n    |          ^^\n \n-error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact.\n+error: calls to `std::mem::drop` with a value that implements `Copy`. Dropping a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:36:5\n    |\n LL |     drop(s4);\n@@ -35,7 +35,7 @@ note: argument has type SomeStruct\n LL |     drop(s4);\n    |          ^^\n \n-error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact.\n+error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:39:5\n    |\n LL |     forget(s1);\n@@ -48,7 +48,7 @@ note: argument has type SomeStruct\n LL |     forget(s1);\n    |            ^^\n \n-error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact.\n+error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:40:5\n    |\n LL |     forget(s2);\n@@ -60,7 +60,7 @@ note: argument has type SomeStruct\n LL |     forget(s2);\n    |            ^^\n \n-error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact.\n+error: calls to `std::mem::forget` with a value that implements `Copy`. Forgetting a copy leaves the original intact\n   --> $DIR/drop_forget_copy.rs:42:5\n    |\n LL |     forget(s4);"}, {"sha": "531849f0680ae7ce424443ae6a2d9c13c34985e1", "filename": "tests/ui/drop_ref.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdrop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fdrop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_ref.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:11:5\n    |\n LL |     drop(&SomeStruct);\n@@ -11,7 +11,7 @@ note: argument has type `&SomeStruct`\n LL |     drop(&SomeStruct);\n    |          ^^^^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:14:5\n    |\n LL |     drop(&owned1);\n@@ -23,7 +23,7 @@ note: argument has type `&SomeStruct`\n LL |     drop(&owned1);\n    |          ^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:15:5\n    |\n LL |     drop(&&owned1);\n@@ -35,7 +35,7 @@ note: argument has type `&&SomeStruct`\n LL |     drop(&&owned1);\n    |          ^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:16:5\n    |\n LL |     drop(&mut owned1);\n@@ -47,7 +47,7 @@ note: argument has type `&mut SomeStruct`\n LL |     drop(&mut owned1);\n    |          ^^^^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:20:5\n    |\n LL |     drop(reference1);\n@@ -59,7 +59,7 @@ note: argument has type `&SomeStruct`\n LL |     drop(reference1);\n    |          ^^^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:23:5\n    |\n LL |     drop(reference2);\n@@ -71,7 +71,7 @@ note: argument has type `&mut SomeStruct`\n LL |     drop(reference2);\n    |          ^^^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:26:5\n    |\n LL |     drop(reference3);\n@@ -83,7 +83,7 @@ note: argument has type `&SomeStruct`\n LL |     drop(reference3);\n    |          ^^^^^^^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:31:5\n    |\n LL |     drop(&val);\n@@ -95,7 +95,7 @@ note: argument has type `&T`\n LL |     drop(&val);\n    |          ^^^^\n \n-error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing.\n+error: calls to `std::mem::drop` with a reference instead of an owned value. Dropping a reference does nothing\n   --> $DIR/drop_ref.rs:39:5\n    |\n LL |     std::mem::drop(&SomeStruct);"}, {"sha": "2be2283e3fdd2f2a0e8704f7352de4c2a13a295a", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -16,10 +16,25 @@\n \n use std::path::PathBuf;\n \n+macro_rules! mac {\n+    () => {\n+        foobar()\n+    };\n+}\n+\n+macro_rules! closure_mac {\n+    () => {\n+        |n| foo(n)\n+    };\n+}\n+\n fn main() {\n     let a = Some(1u8).map(foo);\n     meta(foo);\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n+    true.then(|| mac!()); // don't lint function in macro expansion\n+    Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n+    let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n     all(&[1, 2, 3], &2, |x, y| below(x, y)); //is adjusted\n     unsafe {"}, {"sha": "f0373f9ccf67336f4c50d47fd8b3ae621477da0c", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -16,10 +16,25 @@\n \n use std::path::PathBuf;\n \n+macro_rules! mac {\n+    () => {\n+        foobar()\n+    };\n+}\n+\n+macro_rules! closure_mac {\n+    () => {\n+        |n| foo(n)\n+    };\n+}\n+\n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n     meta(|a| foo(a));\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n+    true.then(|| mac!()); // don't lint function in macro expansion\n+    Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n+    let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n     unsafe {"}, {"sha": "57ed65279666a64b29e7058b8055880865d70233", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,80 +1,86 @@\n-error: redundant closure found\n-  --> $DIR/eta.rs:20:27\n+error: redundant closure\n+  --> $DIR/eta.rs:32:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n-   |                           ^^^^^^^^^^ help: remove closure as shown: `foo`\n+   |                           ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:21:10\n+error: redundant closure\n+  --> $DIR/eta.rs:33:10\n    |\n LL |     meta(|a| foo(a));\n-   |          ^^^^^^^^^^ help: remove closure as shown: `foo`\n+   |          ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:37:40\n+   |\n+LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n+   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:24:21\n+  --> $DIR/eta.rs:39:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:31:27\n+error: redundant closure\n+  --> $DIR/eta.rs:46:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n-   |                           ^^^^^^^^^^^^^^ help: remove closure as shown: `generic`\n+   |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:74:51\n+error: redundant closure\n+  --> $DIR/eta.rs:89:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n-   |                                                   ^^^^^^^^^^^ help: remove closure as shown: `TestStruct::foo`\n+   |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:76:51\n+error: redundant closure\n+  --> $DIR/eta.rs:91:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n-   |                                                   ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `TestTrait::trait_foo`\n+   |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:79:42\n+error: redundant closure\n+  --> $DIR/eta.rs:94:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n-   |                                          ^^^^^^^^^^^^^ help: remove closure as shown: `std::vec::Vec::clear`\n+   |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:84:29\n+error: redundant closure\n+  --> $DIR/eta.rs:99:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n-   |                             ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `std::string::ToString::to_string`\n+   |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:86:27\n+error: redundant closure\n+  --> $DIR/eta.rs:101:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n-   |                           ^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_uppercase`\n+   |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:89:65\n+error: redundant closure\n+  --> $DIR/eta.rs:104:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n-   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_ascii_uppercase`\n+   |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:172:27\n+error: redundant closure\n+  --> $DIR/eta.rs:187:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n-   |                           ^^^^^^^^^^^^^^ help: remove closure as shown: `foo_ptr`\n+   |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n-error: redundant closure found\n-  --> $DIR/eta.rs:177:27\n+error: redundant closure\n+  --> $DIR/eta.rs:192:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n-   |                           ^^^^^^^^^^^^^^ help: remove closure as shown: `closure`\n+   |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "4cbacffe87bf47ce06072b8e263ba772e609258b", "filename": "tests/ui/explicit_counter_loop.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fexplicit_counter_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fexplicit_counter_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_counter_loop.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,42 +1,42 @@\n-error: the variable `_index` is used as a loop counter.\n+error: the variable `_index` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:6:5\n    |\n LL |     for _v in &vec {\n    |     ^^^^^^^^^^^^^^ help: consider using: `for (_index, _v) in vec.iter().enumerate()`\n    |\n    = note: `-D clippy::explicit-counter-loop` implied by `-D warnings`\n \n-error: the variable `_index` is used as a loop counter.\n+error: the variable `_index` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:12:5\n    |\n LL |     for _v in &vec {\n    |     ^^^^^^^^^^^^^^ help: consider using: `for (_index, _v) in vec.iter().enumerate()`\n \n-error: the variable `_index` is used as a loop counter.\n+error: the variable `_index` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:17:5\n    |\n LL |     for _v in &mut vec {\n    |     ^^^^^^^^^^^^^^^^^^ help: consider using: `for (_index, _v) in vec.iter_mut().enumerate()`\n \n-error: the variable `_index` is used as a loop counter.\n+error: the variable `_index` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:22:5\n    |\n LL |     for _v in vec {\n    |     ^^^^^^^^^^^^^ help: consider using: `for (_index, _v) in vec.into_iter().enumerate()`\n \n-error: the variable `count` is used as a loop counter.\n+error: the variable `count` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:61:9\n    |\n LL |         for ch in text.chars() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `for (count, ch) in text.chars().enumerate()`\n \n-error: the variable `count` is used as a loop counter.\n+error: the variable `count` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:72:9\n    |\n LL |         for ch in text.chars() {\n    |         ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `for (count, ch) in text.chars().enumerate()`\n \n-error: the variable `count` is used as a loop counter.\n+error: the variable `count` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:130:9\n    |\n LL |         for _i in 3..10 {"}, {"sha": "a938d234fa07b0cad80a8eb012c655eb452684b7", "filename": "tests/ui/fallible_impl_from.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffallible_impl_from.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffallible_impl_from.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffallible_impl_from.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -13,7 +13,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::fallible_impl_from)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n   --> $DIR/fallible_impl_from.rs:7:13\n    |\n@@ -32,7 +32,7 @@ LL | |     }\n LL | | }\n    | |_^\n    |\n-   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n   --> $DIR/fallible_impl_from.rs:29:13\n    |\n@@ -52,7 +52,7 @@ LL | |     }\n LL | | }\n    | |_^\n    |\n-   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n   --> $DIR/fallible_impl_from.rs:37:17\n    |\n@@ -79,7 +79,7 @@ LL | |     }\n LL | | }\n    | |_^\n    |\n-   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail.\n+   = help: `From` is intended for infallible conversions only. Use `TryFrom` if there's a possibility for the conversion to fail\n note: potential failure(s)\n   --> $DIR/fallible_impl_from.rs:55:12\n    |"}, {"sha": "ddc982c93fe6d9838affcb89844978ce09fee1fb", "filename": "tests/ui/filter_map_next.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffilter_map_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffilter_map_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead\n   --> $DIR/filter_map_next.rs:7:26\n    |\n LL |       let _: Option<u32> = vec![1, 2, 3, 4, 5, 6]"}, {"sha": "3bb062ffd7a32ab6f20b66770a58963c4ec1e564", "filename": "tests/ui/filter_map_next_fixable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffilter_map_next_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffilter_map_next_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_next_fixable.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead.\n+error: called `filter_map(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find_map(..)` instead\n   --> $DIR/filter_map_next_fixable.rs:8:32\n    |\n LL |     let element: Option<i32> = a.iter().filter_map(|s| s.parse().ok()).next();"}, {"sha": "ad5d1a09c0345b54e36642758d86e70d409e1695", "filename": "tests/ui/float_cmp.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -21,19 +21,11 @@ where\n }\n \n fn eq_fl(x: f32, y: f32) -> bool {\n-    if x.is_nan() {\n-        y.is_nan()\n-    } else {\n-        x == y\n-    } // no error, inside \"eq\" fn\n+    if x.is_nan() { y.is_nan() } else { x == y } // no error, inside \"eq\" fn\n }\n \n fn fl_eq(x: f32, y: f32) -> bool {\n-    if x.is_nan() {\n-        y.is_nan()\n-    } else {\n-        x == y\n-    } // no error, inside \"eq\" fn\n+    if x.is_nan() { y.is_nan() } else { x == y } // no error, inside \"eq\" fn\n }\n \n struct X {"}, {"sha": "cb5b68b2e958500d00ffe8a2c7d9f3a61fc54d9d", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:66:5\n+  --> $DIR/float_cmp.rs:58:5\n    |\n LL |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE as f64 - 2.0).abs() > error_margin`\n@@ -8,39 +8,39 @@ LL |     ONE as f64 != 2.0;\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:71:5\n+  --> $DIR/float_cmp.rs:63:5\n    |\n LL |     x == 1.0;\n    |     ^^^^^^^^ help: consider comparing them within some margin of error: `(x - 1.0).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:74:5\n+  --> $DIR/float_cmp.rs:66:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(twice(x) - twice(ONE as f64)).abs() > error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:94:5\n+  --> $DIR/float_cmp.rs:86:5\n    |\n LL |     NON_ZERO_ARRAY[i] == NON_ZERO_ARRAY[j];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` arrays\n-  --> $DIR/float_cmp.rs:99:5\n+  --> $DIR/float_cmp.rs:91:5\n    |\n LL |     a1 == a2;\n    |     ^^^^^^^^\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:100:5\n+  --> $DIR/float_cmp.rs:92:5\n    |\n LL |     a1[0] == a2[0];\n    |     ^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(a1[0] - a2[0]).abs() < error_margin`"}, {"sha": "86ce3bf3bd9924a835f0620bb8cab0fe7662ec53", "filename": "tests/ui/float_cmp_const.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp_const.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -8,11 +8,7 @@ const ONE: f32 = 1.0;\n const TWO: f32 = 2.0;\n \n fn eq_one(x: f32) -> bool {\n-    if x.is_nan() {\n-        false\n-    } else {\n-        x == ONE\n-    } // no error, inside \"eq\" fn\n+    if x.is_nan() { false } else { x == ONE } // no error, inside \"eq\" fn\n }\n \n fn main() {"}, {"sha": "d8182cf855b082190869047a6c6904f27f735917", "filename": "tests/ui/float_cmp_const.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloat_cmp_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp_const.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:20:5\n+  --> $DIR/float_cmp_const.rs:16:5\n    |\n LL |     1f32 == ONE;\n    |     ^^^^^^^^^^^ help: consider comparing them within some margin of error: `(1f32 - ONE).abs() < error_margin`\n@@ -8,55 +8,55 @@ LL |     1f32 == ONE;\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:21:5\n+  --> $DIR/float_cmp_const.rs:17:5\n    |\n LL |     TWO == ONE;\n    |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:22:5\n+  --> $DIR/float_cmp_const.rs:18:5\n    |\n LL |     TWO != ONE;\n    |     ^^^^^^^^^^ help: consider comparing them within some margin of error: `(TWO - ONE).abs() > error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:23:5\n+  --> $DIR/float_cmp_const.rs:19:5\n    |\n LL |     ONE + ONE == TWO;\n    |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE + ONE - TWO).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:25:5\n+  --> $DIR/float_cmp_const.rs:21:5\n    |\n LL |     x as f32 == ONE;\n    |     ^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(x as f32 - ONE).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:28:5\n+  --> $DIR/float_cmp_const.rs:24:5\n    |\n LL |     v == ONE;\n    |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant\n-  --> $DIR/float_cmp_const.rs:29:5\n+  --> $DIR/float_cmp_const.rs:25:5\n    |\n LL |     v != ONE;\n    |     ^^^^^^^^ help: consider comparing them within some margin of error: `(v - ONE).abs() > error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` constant arrays\n-  --> $DIR/float_cmp_const.rs:61:5\n+  --> $DIR/float_cmp_const.rs:57:5\n    |\n LL |     NON_ZERO_ARRAY == NON_ZERO_ARRAY2;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "cea727257c430fa49215513fc2b50a7661b50202", "filename": "tests/ui/floating_point_abs.fixed", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -42,43 +42,23 @@ fn fake_nabs3(a: A) -> A {\n }\n \n fn not_fake_abs1(num: f64) -> f64 {\n-    if num > 0.0 {\n-        num\n-    } else {\n-        -num - 1f64\n-    }\n+    if num > 0.0 { num } else { -num - 1f64 }\n }\n \n fn not_fake_abs2(num: f64) -> f64 {\n-    if num > 0.0 {\n-        num + 1.0\n-    } else {\n-        -(num + 1.0)\n-    }\n+    if num > 0.0 { num + 1.0 } else { -(num + 1.0) }\n }\n \n fn not_fake_abs3(num1: f64, num2: f64) -> f64 {\n-    if num1 > 0.0 {\n-        num2\n-    } else {\n-        -num2\n-    }\n+    if num1 > 0.0 { num2 } else { -num2 }\n }\n \n fn not_fake_abs4(a: A) -> f64 {\n-    if a.a > 0.0 {\n-        a.b\n-    } else {\n-        -a.b\n-    }\n+    if a.a > 0.0 { a.b } else { -a.b }\n }\n \n fn not_fake_abs5(a: A) -> f64 {\n-    if a.a > 0.0 {\n-        a.a\n-    } else {\n-        -a.b\n-    }\n+    if a.a > 0.0 { a.a } else { -a.b }\n }\n \n fn main() {"}, {"sha": "ba8a8f18fa23139a8f08b1767b13ceb6ebec874a", "filename": "tests/ui/floating_point_abs.rs", "status": "modified", "additions": 12, "deletions": 60, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -7,59 +7,31 @@ struct A {\n }\n \n fn fake_abs1(num: f64) -> f64 {\n-    if num >= 0.0 {\n-        num\n-    } else {\n-        -num\n-    }\n+    if num >= 0.0 { num } else { -num }\n }\n \n fn fake_abs2(num: f64) -> f64 {\n-    if 0.0 < num {\n-        num\n-    } else {\n-        -num\n-    }\n+    if 0.0 < num { num } else { -num }\n }\n \n fn fake_abs3(a: A) -> f64 {\n-    if a.a > 0.0 {\n-        a.a\n-    } else {\n-        -a.a\n-    }\n+    if a.a > 0.0 { a.a } else { -a.a }\n }\n \n fn fake_abs4(num: f64) -> f64 {\n-    if 0.0 >= num {\n-        -num\n-    } else {\n-        num\n-    }\n+    if 0.0 >= num { -num } else { num }\n }\n \n fn fake_abs5(a: A) -> f64 {\n-    if a.a < 0.0 {\n-        -a.a\n-    } else {\n-        a.a\n-    }\n+    if a.a < 0.0 { -a.a } else { a.a }\n }\n \n fn fake_nabs1(num: f64) -> f64 {\n-    if num < 0.0 {\n-        num\n-    } else {\n-        -num\n-    }\n+    if num < 0.0 { num } else { -num }\n }\n \n fn fake_nabs2(num: f64) -> f64 {\n-    if 0.0 >= num {\n-        num\n-    } else {\n-        -num\n-    }\n+    if 0.0 >= num { num } else { -num }\n }\n \n fn fake_nabs3(a: A) -> A {\n@@ -70,43 +42,23 @@ fn fake_nabs3(a: A) -> A {\n }\n \n fn not_fake_abs1(num: f64) -> f64 {\n-    if num > 0.0 {\n-        num\n-    } else {\n-        -num - 1f64\n-    }\n+    if num > 0.0 { num } else { -num - 1f64 }\n }\n \n fn not_fake_abs2(num: f64) -> f64 {\n-    if num > 0.0 {\n-        num + 1.0\n-    } else {\n-        -(num + 1.0)\n-    }\n+    if num > 0.0 { num + 1.0 } else { -(num + 1.0) }\n }\n \n fn not_fake_abs3(num1: f64, num2: f64) -> f64 {\n-    if num1 > 0.0 {\n-        num2\n-    } else {\n-        -num2\n-    }\n+    if num1 > 0.0 { num2 } else { -num2 }\n }\n \n fn not_fake_abs4(a: A) -> f64 {\n-    if a.a > 0.0 {\n-        a.b\n-    } else {\n-        -a.b\n-    }\n+    if a.a > 0.0 { a.b } else { -a.b }\n }\n \n fn not_fake_abs5(a: A) -> f64 {\n-    if a.a > 0.0 {\n-        a.a\n-    } else {\n-        -a.b\n-    }\n+    if a.a > 0.0 { a.a } else { -a.b }\n }\n \n fn main() {"}, {"sha": "35af70201fada7fc081d2992ac97ac8c380fd56d", "filename": "tests/ui/floating_point_abs.stderr", "status": "modified", "additions": 21, "deletions": 49, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffloating_point_abs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_abs.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,77 +1,49 @@\n error: manual implementation of `abs` method\n   --> $DIR/floating_point_abs.rs:10:5\n    |\n-LL | /     if num >= 0.0 {\n-LL | |         num\n-LL | |     } else {\n-LL | |         -num\n-LL | |     }\n-   | |_____^ help: try: `num.abs()`\n+LL |     if num >= 0.0 { num } else { -num }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.abs()`\n    |\n    = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n \n error: manual implementation of `abs` method\n-  --> $DIR/floating_point_abs.rs:18:5\n+  --> $DIR/floating_point_abs.rs:14:5\n    |\n-LL | /     if 0.0 < num {\n-LL | |         num\n-LL | |     } else {\n-LL | |         -num\n-LL | |     }\n-   | |_____^ help: try: `num.abs()`\n+LL |     if 0.0 < num { num } else { -num }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.abs()`\n \n error: manual implementation of `abs` method\n-  --> $DIR/floating_point_abs.rs:26:5\n+  --> $DIR/floating_point_abs.rs:18:5\n    |\n-LL | /     if a.a > 0.0 {\n-LL | |         a.a\n-LL | |     } else {\n-LL | |         -a.a\n-LL | |     }\n-   | |_____^ help: try: `a.a.abs()`\n+LL |     if a.a > 0.0 { a.a } else { -a.a }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `a.a.abs()`\n \n error: manual implementation of `abs` method\n-  --> $DIR/floating_point_abs.rs:34:5\n+  --> $DIR/floating_point_abs.rs:22:5\n    |\n-LL | /     if 0.0 >= num {\n-LL | |         -num\n-LL | |     } else {\n-LL | |         num\n-LL | |     }\n-   | |_____^ help: try: `num.abs()`\n+LL |     if 0.0 >= num { -num } else { num }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.abs()`\n \n error: manual implementation of `abs` method\n-  --> $DIR/floating_point_abs.rs:42:5\n+  --> $DIR/floating_point_abs.rs:26:5\n    |\n-LL | /     if a.a < 0.0 {\n-LL | |         -a.a\n-LL | |     } else {\n-LL | |         a.a\n-LL | |     }\n-   | |_____^ help: try: `a.a.abs()`\n+LL |     if a.a < 0.0 { -a.a } else { a.a }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `a.a.abs()`\n \n error: manual implementation of negation of `abs` method\n-  --> $DIR/floating_point_abs.rs:50:5\n+  --> $DIR/floating_point_abs.rs:30:5\n    |\n-LL | /     if num < 0.0 {\n-LL | |         num\n-LL | |     } else {\n-LL | |         -num\n-LL | |     }\n-   | |_____^ help: try: `-num.abs()`\n+LL |     if num < 0.0 { num } else { -num }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `-num.abs()`\n \n error: manual implementation of negation of `abs` method\n-  --> $DIR/floating_point_abs.rs:58:5\n+  --> $DIR/floating_point_abs.rs:34:5\n    |\n-LL | /     if 0.0 >= num {\n-LL | |         num\n-LL | |     } else {\n-LL | |         -num\n-LL | |     }\n-   | |_____^ help: try: `-num.abs()`\n+LL |     if 0.0 >= num { num } else { -num }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `-num.abs()`\n \n error: manual implementation of negation of `abs` method\n-  --> $DIR/floating_point_abs.rs:67:12\n+  --> $DIR/floating_point_abs.rs:39:12\n    |\n LL |         a: if a.a >= 0.0 { -a.a } else { a.a },\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `-a.a.abs()`"}, {"sha": "52b94875aec4d9cf483dee622a0f0cf31cfaf637", "filename": "tests/ui/for_loops_over_fallibles.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffor_loops_over_fallibles.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ffor_loops_over_fallibles.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffor_loops_over_fallibles.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: for loop over `option`, which is an `Option`. This is more readably written as an `if let` statement.\n+error: for loop over `option`, which is an `Option`. This is more readably written as an `if let` statement\n   --> $DIR/for_loops_over_fallibles.rs:9:14\n    |\n LL |     for x in option {\n@@ -7,15 +7,15 @@ LL |     for x in option {\n    = note: `-D clippy::for-loops-over-fallibles` implied by `-D warnings`\n    = help: consider replacing `for x in option` with `if let Some(x) = option`\n \n-error: for loop over `result`, which is a `Result`. This is more readably written as an `if let` statement.\n+error: for loop over `result`, which is a `Result`. This is more readably written as an `if let` statement\n   --> $DIR/for_loops_over_fallibles.rs:14:14\n    |\n LL |     for x in result {\n    |              ^^^^^^\n    |\n    = help: consider replacing `for x in result` with `if let Ok(x) = result`\n \n-error: for loop over `option.ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement.\n+error: for loop over `option.ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement\n   --> $DIR/for_loops_over_fallibles.rs:18:14\n    |\n LL |     for x in option.ok_or(\"x not found\") {\n@@ -31,15 +31,15 @@ LL |     for x in v.iter().next() {\n    |\n    = note: `#[deny(clippy::iter_next_loop)]` on by default\n \n-error: for loop over `v.iter().next().and(Some(0))`, which is an `Option`. This is more readably written as an `if let` statement.\n+error: for loop over `v.iter().next().and(Some(0))`, which is an `Option`. This is more readably written as an `if let` statement\n   --> $DIR/for_loops_over_fallibles.rs:29:14\n    |\n LL |     for x in v.iter().next().and(Some(0)) {\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider replacing `for x in v.iter().next().and(Some(0))` with `if let Some(x) = v.iter().next().and(Some(0))`\n \n-error: for loop over `v.iter().next().ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement.\n+error: for loop over `v.iter().next().ok_or(\"x not found\")`, which is a `Result`. This is more readably written as an `if let` statement\n   --> $DIR/for_loops_over_fallibles.rs:33:14\n    |\n LL |     for x in v.iter().next().ok_or(\"x not found\") {"}, {"sha": "73409388ed16ad0ae9adf9006788a747a26dac31", "filename": "tests/ui/forget_ref.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fforget_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fforget_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fforget_ref.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:10:5\n    |\n LL |     forget(&SomeStruct);\n@@ -11,7 +11,7 @@ note: argument has type `&SomeStruct`\n LL |     forget(&SomeStruct);\n    |            ^^^^^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:13:5\n    |\n LL |     forget(&owned);\n@@ -23,7 +23,7 @@ note: argument has type `&SomeStruct`\n LL |     forget(&owned);\n    |            ^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:14:5\n    |\n LL |     forget(&&owned);\n@@ -35,7 +35,7 @@ note: argument has type `&&SomeStruct`\n LL |     forget(&&owned);\n    |            ^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:15:5\n    |\n LL |     forget(&mut owned);\n@@ -47,7 +47,7 @@ note: argument has type `&mut SomeStruct`\n LL |     forget(&mut owned);\n    |            ^^^^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:19:5\n    |\n LL |     forget(&*reference1);\n@@ -59,7 +59,7 @@ note: argument has type `&SomeStruct`\n LL |     forget(&*reference1);\n    |            ^^^^^^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:22:5\n    |\n LL |     forget(reference2);\n@@ -71,7 +71,7 @@ note: argument has type `&mut SomeStruct`\n LL |     forget(reference2);\n    |            ^^^^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:25:5\n    |\n LL |     forget(reference3);\n@@ -83,7 +83,7 @@ note: argument has type `&SomeStruct`\n LL |     forget(reference3);\n    |            ^^^^^^^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:30:5\n    |\n LL |     forget(&val);\n@@ -95,7 +95,7 @@ note: argument has type `&T`\n LL |     forget(&val);\n    |            ^^^^\n \n-error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing.\n+error: calls to `std::mem::forget` with a reference instead of an owned value. Forgetting a reference does nothing\n   --> $DIR/forget_ref.rs:38:5\n    |\n LL |     std::mem::forget(&SomeStruct);"}, {"sha": "62a25ce2d128c4670a68164511230f27c5718f9c", "filename": "tests/ui/if_let_some_result.fixed", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -3,19 +3,11 @@\n #![warn(clippy::if_let_some_result)]\n \n fn str_to_int(x: &str) -> i32 {\n-    if let Ok(y) = x.parse() {\n-        y\n-    } else {\n-        0\n-    }\n+    if let Ok(y) = x.parse() { y } else { 0 }\n }\n \n fn str_to_int_ok(x: &str) -> i32 {\n-    if let Ok(y) = x.parse() {\n-        y\n-    } else {\n-        0\n-    }\n+    if let Ok(y) = x.parse() { y } else { 0 }\n }\n \n #[rustfmt::skip]"}, {"sha": "234ff5e9e80e2c384c2849d3f2e6b884d8d878ee", "filename": "tests/ui/if_let_some_result.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -3,19 +3,11 @@\n #![warn(clippy::if_let_some_result)]\n \n fn str_to_int(x: &str) -> i32 {\n-    if let Some(y) = x.parse().ok() {\n-        y\n-    } else {\n-        0\n-    }\n+    if let Some(y) = x.parse().ok() { y } else { 0 }\n }\n \n fn str_to_int_ok(x: &str) -> i32 {\n-    if let Ok(y) = x.parse() {\n-        y\n-    } else {\n-        0\n-    }\n+    if let Ok(y) = x.parse() { y } else { 0 }\n }\n \n #[rustfmt::skip]"}, {"sha": "0646dd27f35e8ebd6072a2d7fd145a22abe1d2dc", "filename": "tests/ui/if_let_some_result.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fif_let_some_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_some_result.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,17 +1,17 @@\n error: matching on `Some` with `ok()` is redundant\n   --> $DIR/if_let_some_result.rs:6:5\n    |\n-LL |     if let Some(y) = x.parse().ok() {\n+LL |     if let Some(y) = x.parse().ok() { y } else { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::if-let-some-result` implied by `-D warnings`\n help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n-LL |     if let Ok(y) = x.parse() {\n+LL |     if let Ok(y) = x.parse() { y } else { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: matching on `Some` with `ok()` is redundant\n-  --> $DIR/if_let_some_result.rs:24:9\n+  --> $DIR/if_let_some_result.rs:16:9\n    |\n LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "19101522163f951c656b2e0c0445fa289f624912", "filename": "tests/ui/implicit_clone.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,108 @@\n+#![warn(clippy::implicit_clone)]\n+#![allow(clippy::redundant_clone)]\n+use std::borrow::Borrow;\n+use std::ffi::{OsStr, OsString};\n+use std::path::PathBuf;\n+\n+fn return_owned_from_slice(slice: &[u32]) -> Vec<u32> {\n+    slice.to_owned()\n+}\n+\n+pub fn own_same<T>(v: T) -> T\n+where\n+    T: ToOwned<Owned = T>,\n+{\n+    v.to_owned()\n+}\n+\n+pub fn own_same_from_ref<T>(v: &T) -> T\n+where\n+    T: ToOwned<Owned = T>,\n+{\n+    v.to_owned()\n+}\n+\n+pub fn own_different<T, U>(v: T) -> U\n+where\n+    T: ToOwned<Owned = U>,\n+{\n+    v.to_owned()\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Kitten {}\n+impl Kitten {\n+    // badly named method\n+    fn to_vec(self) -> Kitten {\n+        Kitten {}\n+    }\n+}\n+impl Borrow<BorrowedKitten> for Kitten {\n+    fn borrow(&self) -> &BorrowedKitten {\n+        static VALUE: BorrowedKitten = BorrowedKitten {};\n+        &VALUE\n+    }\n+}\n+\n+struct BorrowedKitten {}\n+impl ToOwned for BorrowedKitten {\n+    type Owned = Kitten;\n+    fn to_owned(&self) -> Kitten {\n+        Kitten {}\n+    }\n+}\n+\n+mod weird {\n+    #[allow(clippy::ptr_arg)]\n+    pub fn to_vec(v: &Vec<u32>) -> Vec<u32> {\n+        v.clone()\n+    }\n+}\n+\n+fn main() {\n+    let vec = vec![5];\n+    let _ = return_owned_from_slice(&vec);\n+    let _ = vec.to_owned();\n+    let _ = vec.to_vec();\n+\n+    let vec_ref = &vec;\n+    let _ = return_owned_from_slice(&vec_ref);\n+    let _ = vec_ref.to_owned();\n+    let _ = vec_ref.to_vec();\n+\n+    // we expect no lint for this\n+    let _ = weird::to_vec(&vec);\n+\n+    // we expect no lints for this\n+    let slice: &[u32] = &[1, 2, 3, 4, 5];\n+    let _ = return_owned_from_slice(slice);\n+    let _ = slice.to_owned();\n+    let _ = slice.to_vec();\n+\n+    let str = \"hello world\".to_string();\n+    let _ = str.to_owned();\n+\n+    // testing w/ an arbitrary type\n+    let kitten = Kitten {};\n+    let _ = kitten.to_owned();\n+    let _ = own_same_from_ref(&kitten);\n+    // this shouln't lint\n+    let _ = kitten.to_vec();\n+\n+    // we expect no lints for this\n+    let borrowed = BorrowedKitten {};\n+    let _ = borrowed.to_owned();\n+\n+    let pathbuf = PathBuf::new();\n+    let _ = pathbuf.to_owned();\n+    let _ = pathbuf.to_path_buf();\n+\n+    let os_string = OsString::from(\"foo\");\n+    let _ = os_string.to_owned();\n+    let _ = os_string.to_os_string();\n+\n+    // we expect no lints for this\n+    let os_str = OsStr::new(\"foo\");\n+    let _ = os_str.to_owned();\n+    let _ = os_str.to_os_string();\n+}"}, {"sha": "e6f7527b67219d2409f514246af6e3911826e0af", "filename": "tests/ui/implicit_clone.stderr", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,64 @@\n+error: implicitly cloning a `Vec` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:65:17\n+   |\n+LL |     let _ = vec.to_owned();\n+   |                 ^^^^^^^^ help: consider using: `clone`\n+   |\n+   = note: `-D clippy::implicit-clone` implied by `-D warnings`\n+\n+error: implicitly cloning a `Vec` by calling `to_vec` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:66:17\n+   |\n+LL |     let _ = vec.to_vec();\n+   |                 ^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `Vec` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:70:21\n+   |\n+LL |     let _ = vec_ref.to_owned();\n+   |                     ^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `Vec` by calling `to_vec` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:71:21\n+   |\n+LL |     let _ = vec_ref.to_vec();\n+   |                     ^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `String` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:83:17\n+   |\n+LL |     let _ = str.to_owned();\n+   |                 ^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `Kitten` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:87:20\n+   |\n+LL |     let _ = kitten.to_owned();\n+   |                    ^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `PathBuf` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:97:21\n+   |\n+LL |     let _ = pathbuf.to_owned();\n+   |                     ^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `PathBuf` by calling `to_path_buf` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:98:21\n+   |\n+LL |     let _ = pathbuf.to_path_buf();\n+   |                     ^^^^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `OsString` by calling `to_owned` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:101:23\n+   |\n+LL |     let _ = os_string.to_owned();\n+   |                       ^^^^^^^^ help: consider using: `clone`\n+\n+error: implicitly cloning a `OsString` by calling `to_os_string` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:102:23\n+   |\n+LL |     let _ = os_string.to_os_string();\n+   |                       ^^^^^^^^^^^^ help: consider using: `clone`\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "59f7ad9c1062490f66039c203abba078c53fbbbe", "filename": "tests/ui/implicit_return.fixed", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -14,11 +14,7 @@ fn test_end_of_fn() -> bool {\n \n #[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n-    if true {\n-        return true\n-    } else {\n-        return false\n-    }\n+    if true { return true } else { return false }\n }\n \n #[rustfmt::skip]"}, {"sha": "2c1bc046515089a7ea73f93969df248168a7164b", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -14,11 +14,7 @@ fn test_end_of_fn() -> bool {\n \n #[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n-    if true {\n-        true\n-    } else {\n-        false\n-    }\n+    if true { true } else { false }\n }\n \n #[rustfmt::skip]"}, {"sha": "3608319e5bd2cc5e770cac96b0fcad9c839f4c6c", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -7,61 +7,61 @@ LL |     true\n    = note: `-D clippy::implicit-return` implied by `-D warnings`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:18:9\n+  --> $DIR/implicit_return.rs:17:15\n    |\n-LL |         true\n-   |         ^^^^ help: add `return` as shown: `return true`\n+LL |     if true { true } else { false }\n+   |               ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:20:9\n+  --> $DIR/implicit_return.rs:17:29\n    |\n-LL |         false\n-   |         ^^^^^ help: add `return` as shown: `return false`\n+LL |     if true { true } else { false }\n+   |                             ^^^^^ help: add `return` as shown: `return false`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:27:17\n+  --> $DIR/implicit_return.rs:23:17\n    |\n LL |         true => false,\n    |                 ^^^^^ help: add `return` as shown: `return false`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:28:20\n+  --> $DIR/implicit_return.rs:24:20\n    |\n LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:43:9\n+  --> $DIR/implicit_return.rs:39:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:51:13\n+  --> $DIR/implicit_return.rs:47:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:60:13\n+  --> $DIR/implicit_return.rs:56:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:78:18\n+  --> $DIR/implicit_return.rs:74:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:79:16\n+  --> $DIR/implicit_return.rs:75:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:87:5\n+  --> $DIR/implicit_return.rs:83:5\n    |\n LL |     format!(\"test {}\", \"test\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`"}, {"sha": "76ecec3348400f98e02de0356d316a619061c261", "filename": "tests/ui/indexing_slicing_index.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Findexing_slicing_index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Findexing_slicing_index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_index.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,51 +1,51 @@\n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:10:5\n    |\n LL |     x[index];\n    |     ^^^^^^^^\n    |\n    = note: `-D clippy::indexing-slicing` implied by `-D warnings`\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:22:5\n    |\n LL |     v[0];\n    |     ^^^^\n    |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:23:5\n    |\n LL |     v[10];\n    |     ^^^^^\n    |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:24:5\n    |\n LL |     v[1 << 3];\n    |     ^^^^^^^^^\n    |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:30:5\n    |\n LL |     v[N];\n    |     ^^^^\n    |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n-error: indexing may panic.\n+error: indexing may panic\n   --> $DIR/indexing_slicing_index.rs:31:5\n    |\n LL |     v[M];\n    |     ^^^^\n    |\n-   = help: Consider using `.get(n)` or `.get_mut(n)` instead\n+   = help: consider using `.get(n)` or `.get_mut(n)` instead\n \n error: aborting due to 6 previous errors\n "}, {"sha": "f70722b92a5b8186738a754850e171e3e8e93c42", "filename": "tests/ui/indexing_slicing_slice.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Findexing_slicing_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Findexing_slicing_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Findexing_slicing_slice.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,51 +1,51 @@\n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:12:6\n    |\n LL |     &x[index..];\n    |      ^^^^^^^^^^\n    |\n    = note: `-D clippy::indexing-slicing` implied by `-D warnings`\n-   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+   = help: consider using `.get(n..)` or .get_mut(n..)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:13:6\n    |\n LL |     &x[..index];\n    |      ^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:14:6\n    |\n LL |     &x[index_from..index_to];\n    |      ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+   = help: consider using `.get(n..m)` or `.get_mut(n..m)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:15:6\n    |\n LL |     &x[index_from..][..index_to]; // Two lint reports, one for [index_from..] and another for [..index_to].\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:15:6\n    |\n LL |     &x[index_from..][..index_to]; // Two lint reports, one for [index_from..] and another for [..index_to].\n    |      ^^^^^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+   = help: consider using `.get(n..)` or .get_mut(n..)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:16:6\n    |\n LL |     &x[5..][..10]; // Two lint reports, one for out of bounds [5..] and another for slicing [..10].\n    |      ^^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n   --> $DIR/indexing_slicing_slice.rs:16:8\n@@ -55,21 +55,21 @@ LL |     &x[5..][..10]; // Two lint reports, one for out of bounds [5..] and ano\n    |\n    = note: `-D clippy::out-of-bounds-indexing` implied by `-D warnings`\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:17:6\n    |\n LL |     &x[0..][..3];\n    |      ^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:18:6\n    |\n LL |     &x[1..][..5];\n    |      ^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n   --> $DIR/indexing_slicing_slice.rs:25:12\n@@ -83,43 +83,43 @@ error: range is out of bounds\n LL |     &y[..=4];\n    |           ^\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:31:6\n    |\n LL |     &v[10..100];\n    |      ^^^^^^^^^^\n    |\n-   = help: Consider using `.get(n..m)` or `.get_mut(n..m)` instead\n+   = help: consider using `.get(n..m)` or `.get_mut(n..m)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:32:6\n    |\n LL |     &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n    |      ^^^^^^^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: range is out of bounds\n   --> $DIR/indexing_slicing_slice.rs:32:8\n    |\n LL |     &x[10..][..100]; // Two lint reports, one for [10..] and another for [..100].\n    |        ^^\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:33:6\n    |\n LL |     &v[10..];\n    |      ^^^^^^^\n    |\n-   = help: Consider using `.get(n..)` or .get_mut(n..)` instead\n+   = help: consider using `.get(n..)` or .get_mut(n..)` instead\n \n-error: slicing may panic.\n+error: slicing may panic\n   --> $DIR/indexing_slicing_slice.rs:34:6\n    |\n LL |     &v[..100];\n    |      ^^^^^^^^\n    |\n-   = help: Consider using `.get(..n)`or `.get_mut(..n)` instead\n+   = help: consider using `.get(..n)`or `.get_mut(..n)` instead\n \n error: aborting due to 16 previous errors\n "}, {"sha": "cbb7f881424956b51d75bab6d1eee7d188625714", "filename": "tests/ui/integer_division.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Finteger_division.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Finteger_division.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finteger_division.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -5,23 +5,23 @@ LL |     let n = 1 / 2;\n    |             ^^^^^\n    |\n    = note: `-D clippy::integer-division` implied by `-D warnings`\n-   = help: division of integers may cause loss of precision. consider using floats.\n+   = help: division of integers may cause loss of precision. consider using floats\n \n error: integer division\n   --> $DIR/integer_division.rs:6:13\n    |\n LL |     let o = 1 / two;\n    |             ^^^^^^^\n    |\n-   = help: division of integers may cause loss of precision. consider using floats.\n+   = help: division of integers may cause loss of precision. consider using floats\n \n error: integer division\n   --> $DIR/integer_division.rs:7:13\n    |\n LL |     let p = two / 4;\n    |             ^^^^^^^\n    |\n-   = help: division of integers may cause loss of precision. consider using floats.\n+   = help: division of integers may cause loss of precision. consider using floats\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b11dadda6c24ed753f23663492f5a675a6f82702", "filename": "tests/ui/iter_count.fixed", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_count.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,86 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::iter_count)]\n+#![allow(\n+    unused_variables,\n+    array_into_iter,\n+    unused_mut,\n+    clippy::into_iter_on_ref,\n+    clippy::unnecessary_operation\n+)]\n+\n+extern crate option_helpers;\n+\n+use option_helpers::IteratorFalsePositives;\n+use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n+\n+/// Struct to generate false positives for things with `.iter()`.\n+#[derive(Copy, Clone)]\n+struct HasIter;\n+\n+impl HasIter {\n+    fn iter(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+\n+    fn iter_mut(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+\n+    fn into_iter(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+}\n+\n+fn main() {\n+    let mut vec = vec![0, 1, 2, 3];\n+    let mut boxed_slice: Box<[u8]> = Box::new([0, 1, 2, 3]);\n+    let mut vec_deque: VecDeque<_> = vec.iter().cloned().collect();\n+    let mut hash_set = HashSet::new();\n+    let mut hash_map = HashMap::new();\n+    let mut b_tree_map = BTreeMap::new();\n+    let mut b_tree_set = BTreeSet::new();\n+    let mut linked_list = LinkedList::new();\n+    let mut binary_heap = BinaryHeap::new();\n+    hash_set.insert(1);\n+    hash_map.insert(1, 2);\n+    b_tree_map.insert(1, 2);\n+    b_tree_set.insert(1);\n+    linked_list.push_back(1);\n+    binary_heap.push(1);\n+\n+    &vec[..].len();\n+    vec.len();\n+    boxed_slice.len();\n+    vec_deque.len();\n+    hash_set.len();\n+    hash_map.len();\n+    b_tree_map.len();\n+    b_tree_set.len();\n+    linked_list.len();\n+    binary_heap.len();\n+\n+    vec.len();\n+    &vec[..].len();\n+    vec_deque.len();\n+    hash_map.len();\n+    b_tree_map.len();\n+    linked_list.len();\n+\n+    &vec[..].len();\n+    vec.len();\n+    vec_deque.len();\n+    hash_set.len();\n+    hash_map.len();\n+    b_tree_map.len();\n+    b_tree_set.len();\n+    linked_list.len();\n+    binary_heap.len();\n+\n+    // Make sure we don't lint for non-relevant types.\n+    let false_positive = HasIter;\n+    false_positive.iter().count();\n+    false_positive.iter_mut().count();\n+    false_positive.into_iter().count();\n+}"}, {"sha": "7d49c6a3dbbb939d90144b60e51123e85293d620", "filename": "tests/ui/iter_count.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_count.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,86 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::iter_count)]\n+#![allow(\n+    unused_variables,\n+    array_into_iter,\n+    unused_mut,\n+    clippy::into_iter_on_ref,\n+    clippy::unnecessary_operation\n+)]\n+\n+extern crate option_helpers;\n+\n+use option_helpers::IteratorFalsePositives;\n+use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n+\n+/// Struct to generate false positives for things with `.iter()`.\n+#[derive(Copy, Clone)]\n+struct HasIter;\n+\n+impl HasIter {\n+    fn iter(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+\n+    fn iter_mut(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+\n+    fn into_iter(self) -> IteratorFalsePositives {\n+        IteratorFalsePositives { foo: 0 }\n+    }\n+}\n+\n+fn main() {\n+    let mut vec = vec![0, 1, 2, 3];\n+    let mut boxed_slice: Box<[u8]> = Box::new([0, 1, 2, 3]);\n+    let mut vec_deque: VecDeque<_> = vec.iter().cloned().collect();\n+    let mut hash_set = HashSet::new();\n+    let mut hash_map = HashMap::new();\n+    let mut b_tree_map = BTreeMap::new();\n+    let mut b_tree_set = BTreeSet::new();\n+    let mut linked_list = LinkedList::new();\n+    let mut binary_heap = BinaryHeap::new();\n+    hash_set.insert(1);\n+    hash_map.insert(1, 2);\n+    b_tree_map.insert(1, 2);\n+    b_tree_set.insert(1);\n+    linked_list.push_back(1);\n+    binary_heap.push(1);\n+\n+    &vec[..].iter().count();\n+    vec.iter().count();\n+    boxed_slice.iter().count();\n+    vec_deque.iter().count();\n+    hash_set.iter().count();\n+    hash_map.iter().count();\n+    b_tree_map.iter().count();\n+    b_tree_set.iter().count();\n+    linked_list.iter().count();\n+    binary_heap.iter().count();\n+\n+    vec.iter_mut().count();\n+    &vec[..].iter_mut().count();\n+    vec_deque.iter_mut().count();\n+    hash_map.iter_mut().count();\n+    b_tree_map.iter_mut().count();\n+    linked_list.iter_mut().count();\n+\n+    &vec[..].into_iter().count();\n+    vec.into_iter().count();\n+    vec_deque.into_iter().count();\n+    hash_set.into_iter().count();\n+    hash_map.into_iter().count();\n+    b_tree_map.into_iter().count();\n+    b_tree_set.into_iter().count();\n+    linked_list.into_iter().count();\n+    binary_heap.into_iter().count();\n+\n+    // Make sure we don't lint for non-relevant types.\n+    let false_positive = HasIter;\n+    false_positive.iter().count();\n+    false_positive.iter_mut().count();\n+    false_positive.into_iter().count();\n+}"}, {"sha": "f3fb98e65b9906aa35381897f64948aa21635d42", "filename": "tests/ui/iter_count.stderr", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiter_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_count.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,154 @@\n+error: called `.iter().count()` on a `slice`\n+  --> $DIR/iter_count.rs:53:6\n+   |\n+LL |     &vec[..].iter().count();\n+   |      ^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec[..].len()`\n+   |\n+   = note: `-D clippy::iter-count` implied by `-D warnings`\n+\n+error: called `.iter().count()` on a `Vec`\n+  --> $DIR/iter_count.rs:54:5\n+   |\n+LL |     vec.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^ help: try: `vec.len()`\n+\n+error: called `.iter().count()` on a `slice`\n+  --> $DIR/iter_count.rs:55:5\n+   |\n+LL |     boxed_slice.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `boxed_slice.len()`\n+\n+error: called `.iter().count()` on a `VecDeque`\n+  --> $DIR/iter_count.rs:56:5\n+   |\n+LL |     vec_deque.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec_deque.len()`\n+\n+error: called `.iter().count()` on a `HashSet`\n+  --> $DIR/iter_count.rs:57:5\n+   |\n+LL |     hash_set.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `hash_set.len()`\n+\n+error: called `.iter().count()` on a `HashMap`\n+  --> $DIR/iter_count.rs:58:5\n+   |\n+LL |     hash_map.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `hash_map.len()`\n+\n+error: called `.iter().count()` on a `BTreeMap`\n+  --> $DIR/iter_count.rs:59:5\n+   |\n+LL |     b_tree_map.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `b_tree_map.len()`\n+\n+error: called `.iter().count()` on a `BTreeSet`\n+  --> $DIR/iter_count.rs:60:5\n+   |\n+LL |     b_tree_set.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `b_tree_set.len()`\n+\n+error: called `.iter().count()` on a `LinkedList`\n+  --> $DIR/iter_count.rs:61:5\n+   |\n+LL |     linked_list.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `linked_list.len()`\n+\n+error: called `.iter().count()` on a `BinaryHeap`\n+  --> $DIR/iter_count.rs:62:5\n+   |\n+LL |     binary_heap.iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `binary_heap.len()`\n+\n+error: called `.iter_mut().count()` on a `Vec`\n+  --> $DIR/iter_count.rs:64:5\n+   |\n+LL |     vec.iter_mut().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.len()`\n+\n+error: called `.iter_mut().count()` on a `slice`\n+  --> $DIR/iter_count.rs:65:6\n+   |\n+LL |     &vec[..].iter_mut().count();\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec[..].len()`\n+\n+error: called `.iter_mut().count()` on a `VecDeque`\n+  --> $DIR/iter_count.rs:66:5\n+   |\n+LL |     vec_deque.iter_mut().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec_deque.len()`\n+\n+error: called `.iter_mut().count()` on a `HashMap`\n+  --> $DIR/iter_count.rs:67:5\n+   |\n+LL |     hash_map.iter_mut().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `hash_map.len()`\n+\n+error: called `.iter_mut().count()` on a `BTreeMap`\n+  --> $DIR/iter_count.rs:68:5\n+   |\n+LL |     b_tree_map.iter_mut().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `b_tree_map.len()`\n+\n+error: called `.iter_mut().count()` on a `LinkedList`\n+  --> $DIR/iter_count.rs:69:5\n+   |\n+LL |     linked_list.iter_mut().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `linked_list.len()`\n+\n+error: called `.into_iter().count()` on a `slice`\n+  --> $DIR/iter_count.rs:71:6\n+   |\n+LL |     &vec[..].into_iter().count();\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec[..].len()`\n+\n+error: called `.into_iter().count()` on a `Vec`\n+  --> $DIR/iter_count.rs:72:5\n+   |\n+LL |     vec.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.len()`\n+\n+error: called `.into_iter().count()` on a `VecDeque`\n+  --> $DIR/iter_count.rs:73:5\n+   |\n+LL |     vec_deque.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec_deque.len()`\n+\n+error: called `.into_iter().count()` on a `HashSet`\n+  --> $DIR/iter_count.rs:74:5\n+   |\n+LL |     hash_set.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `hash_set.len()`\n+\n+error: called `.into_iter().count()` on a `HashMap`\n+  --> $DIR/iter_count.rs:75:5\n+   |\n+LL |     hash_map.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `hash_map.len()`\n+\n+error: called `.into_iter().count()` on a `BTreeMap`\n+  --> $DIR/iter_count.rs:76:5\n+   |\n+LL |     b_tree_map.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `b_tree_map.len()`\n+\n+error: called `.into_iter().count()` on a `BTreeSet`\n+  --> $DIR/iter_count.rs:77:5\n+   |\n+LL |     b_tree_set.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `b_tree_set.len()`\n+\n+error: called `.into_iter().count()` on a `LinkedList`\n+  --> $DIR/iter_count.rs:78:5\n+   |\n+LL |     linked_list.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `linked_list.len()`\n+\n+error: called `.into_iter().count()` on a `BinaryHeap`\n+  --> $DIR/iter_count.rs:79:5\n+   |\n+LL |     binary_heap.into_iter().count();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `binary_heap.len()`\n+\n+error: aborting due to 25 previous errors\n+"}, {"sha": "d792aea11dfa0e74d6748f801463918fb8e06591", "filename": "tests/ui/iterator_step_by_zero.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiterator_step_by_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fiterator_step_by_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiterator_step_by_zero.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,42 +1,42 @@\n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:3:13\n    |\n LL |     let _ = vec![\"A\", \"B\", \"B\"].iter().step_by(0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::iterator-step-by-zero` implied by `-D warnings`\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:4:13\n    |\n LL |     let _ = \"XXX\".chars().step_by(0);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:5:13\n    |\n LL |     let _ = (0..1).step_by(0);\n    |             ^^^^^^^^^^^^^^^^^\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:14:13\n    |\n LL |     let _ = (1..).step_by(0);\n    |             ^^^^^^^^^^^^^^^^\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:15:13\n    |\n LL |     let _ = (1..=2).step_by(0);\n    |             ^^^^^^^^^^^^^^^^^^\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:18:13\n    |\n LL |     let _ = x.step_by(0);\n    |             ^^^^^^^^^^^^\n \n-error: Iterator::step_by(0) will panic at runtime\n+error: `Iterator::step_by(0)` will panic at runtime\n   --> $DIR/iterator_step_by_zero.rs:22:13\n    |\n LL |     let _ = v1.iter().step_by(2 / 3);"}, {"sha": "6b3636a482e957e25bfc3ce178268b931c67a397", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -34,6 +34,24 @@ impl PubAllowed {\n     }\n }\n \n+pub struct PubAllowedFn;\n+\n+impl PubAllowedFn {\n+    #[allow(clippy::len_without_is_empty)]\n+    pub fn len(&self) -> isize {\n+        1\n+    }\n+}\n+\n+#[allow(clippy::len_without_is_empty)]\n+pub struct PubAllowedStruct;\n+\n+impl PubAllowedStruct {\n+    pub fn len(&self) -> isize {\n+        1\n+    }\n+}\n+\n pub trait PubTraitsToo {\n     fn len(&self) -> isize;\n }\n@@ -68,6 +86,18 @@ impl HasWrongIsEmpty {\n     }\n }\n \n+pub struct MismatchedSelf;\n+\n+impl MismatchedSelf {\n+    pub fn len(self) -> isize {\n+        1\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        false\n+    }\n+}\n+\n struct NotPubOne;\n \n impl NotPubOne {\n@@ -142,4 +172,19 @@ pub trait DependsOnFoo: Foo {\n     fn len(&mut self) -> usize;\n }\n \n+pub struct MultipleImpls;\n+\n+// issue #1562\n+impl MultipleImpls {\n+    pub fn len(&self) -> usize {\n+        1\n+    }\n+}\n+\n+impl MultipleImpls {\n+    pub fn is_empty(&self) -> bool {\n+        false\n+    }\n+}\n+\n fn main() {}"}, {"sha": "f106506faf49edf27df75a9a63cde93233fe49bf", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,54 +1,64 @@\n-error: item `PubOne` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:6:1\n+error: struct `PubOne` has a public `len` method, but no `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:7:5\n    |\n-LL | / impl PubOne {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::len-without-is-empty` implied by `-D warnings`\n \n error: trait `PubTraitsToo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:37:1\n+  --> $DIR/len_without_is_empty.rs:55:1\n    |\n LL | / pub trait PubTraitsToo {\n LL | |     fn len(&self) -> isize;\n LL | | }\n    | |_^\n \n-error: item `HasIsEmpty` has a public `len` method but a private `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:49:1\n-   |\n-LL | / impl HasIsEmpty {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+error: struct `HasIsEmpty` has a public `len` method, but a private `is_empty` method\n+  --> $DIR/len_without_is_empty.rs:68:5\n+   |\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:72:5\n+   |\n+LL |     fn is_empty(&self) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: item `HasWrongIsEmpty` has a public `len` method but no corresponding `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:61:1\n-   |\n-LL | / impl HasWrongIsEmpty {\n-LL | |     pub fn len(&self) -> isize {\n-LL | |         1\n-LL | |     }\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+error: struct `HasWrongIsEmpty` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:80:5\n+   |\n+LL |     pub fn len(&self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:84:5\n+   |\n+LL |     pub fn is_empty(&self, x: u32) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(&self) -> bool`\n+\n+error: struct `MismatchedSelf` has a public `len` method, but the `is_empty` method has an unexpected signature\n+  --> $DIR/len_without_is_empty.rs:92:5\n+   |\n+LL |     pub fn len(self) -> isize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: `is_empty` defined here\n+  --> $DIR/len_without_is_empty.rs:96:5\n+   |\n+LL |     pub fn is_empty(&self) -> bool {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected signature: `(self) -> bool`\n \n error: trait `DependsOnFoo` has a `len` method but no (possibly inherited) `is_empty` method\n-  --> $DIR/len_without_is_empty.rs:141:1\n+  --> $DIR/len_without_is_empty.rs:171:1\n    |\n LL | / pub trait DependsOnFoo: Foo {\n LL | |     fn len(&mut self) -> usize;\n LL | | }\n    | |_^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "9222aaf6c789c20b96f3c3effc69655187c21c26", "filename": "tests/ui/manual_map_option.fixed", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,14 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n-#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::map_identity,\n+    clippy::unit_arg,\n+    clippy::match_ref_pats,\n+    dead_code\n+)]\n \n fn main() {\n     Some(0).map(|_| 2);\n@@ -67,4 +74,58 @@ fn main() {\n         Some(Some((x, 1))) => Some(x),\n         _ => None,\n     };\n+\n+    // #6795\n+    fn f1() -> Result<(), ()> {\n+        let _ = match Some(Ok(())) {\n+            Some(x) => Some(x?),\n+            None => None,\n+        };\n+        Ok(())\n+    }\n+\n+    for &x in Some(Some(true)).iter() {\n+        let _ = match x {\n+            Some(x) => Some(if x { continue } else { x }),\n+            None => None,\n+        };\n+    }\n+\n+    // #6797\n+    let x1 = (Some(String::new()), 0);\n+    let x2 = x1.0;\n+    match x2 {\n+        Some(x) => Some((x, x1.1)),\n+        None => None,\n+    };\n+\n+    struct S1 {\n+        x: Option<String>,\n+        y: u32,\n+    }\n+    impl S1 {\n+        fn f(self) -> Option<(String, u32)> {\n+            match self.x {\n+                Some(x) => Some((x, self.y)),\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    // #6811\n+    Some(0).map(|x| vec![x]);\n+\n+    option_env!(\"\").map(String::from);\n+\n+    // #6819\n+    async fn f2(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn f3() {\n+        match Some(0) {\n+            Some(x) => Some(f2(x).await),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "1ccb450619c69127897206289409c6fd2b32d5b4", "filename": "tests/ui/manual_map_option.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,7 +1,14 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::manual_map)]\n-#![allow(clippy::no_effect, clippy::map_identity, clippy::unit_arg, clippy::match_ref_pats)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::map_identity,\n+    clippy::unit_arg,\n+    clippy::match_ref_pats,\n+    dead_code\n+)]\n \n fn main() {\n     match Some(0) {\n@@ -119,4 +126,64 @@ fn main() {\n         Some(Some((x, 1))) => Some(x),\n         _ => None,\n     };\n+\n+    // #6795\n+    fn f1() -> Result<(), ()> {\n+        let _ = match Some(Ok(())) {\n+            Some(x) => Some(x?),\n+            None => None,\n+        };\n+        Ok(())\n+    }\n+\n+    for &x in Some(Some(true)).iter() {\n+        let _ = match x {\n+            Some(x) => Some(if x { continue } else { x }),\n+            None => None,\n+        };\n+    }\n+\n+    // #6797\n+    let x1 = (Some(String::new()), 0);\n+    let x2 = x1.0;\n+    match x2 {\n+        Some(x) => Some((x, x1.1)),\n+        None => None,\n+    };\n+\n+    struct S1 {\n+        x: Option<String>,\n+        y: u32,\n+    }\n+    impl S1 {\n+        fn f(self) -> Option<(String, u32)> {\n+            match self.x {\n+                Some(x) => Some((x, self.y)),\n+                None => None,\n+            }\n+        }\n+    }\n+\n+    // #6811\n+    match Some(0) {\n+        Some(x) => Some(vec![x]),\n+        None => None,\n+    };\n+\n+    match option_env!(\"\") {\n+        Some(x) => Some(String::from(x)),\n+        None => None,\n+    };\n+\n+    // #6819\n+    async fn f2(x: u32) -> u32 {\n+        x\n+    }\n+\n+    async fn f3() {\n+        match Some(0) {\n+            Some(x) => Some(f2(x).await),\n+            None => None,\n+        };\n+    }\n }"}, {"sha": "d9f86eecd93f6cb357711f6a1c8da23777233949", "filename": "tests/ui/manual_map_option.stderr", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmanual_map_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_map_option.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:7:5\n+  --> $DIR/manual_map_option.rs:14:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(_) => Some(2),\n@@ -10,7 +10,7 @@ LL | |     };\n    = note: `-D clippy::manual-map` implied by `-D warnings`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:12:5\n+  --> $DIR/manual_map_option.rs:19:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => Some(x + 1),\n@@ -19,7 +19,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + 1)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:17:5\n+  --> $DIR/manual_map_option.rs:24:5\n    |\n LL | /     match Some(\"\") {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -28,7 +28,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(\"\").map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:22:5\n+  --> $DIR/manual_map_option.rs:29:5\n    |\n LL | /     if let Some(x) = Some(0) {\n LL | |         Some(!x)\n@@ -38,7 +38,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| !x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:29:5\n+  --> $DIR/manual_map_option.rs:36:5\n    |\n LL | /     match Some(0) {\n LL | |         Some(x) => { Some(std::convert::identity(x)) }\n@@ -47,7 +47,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(std::convert::identity)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:34:5\n+  --> $DIR/manual_map_option.rs:41:5\n    |\n LL | /     match Some(&String::new()) {\n LL | |         Some(x) => Some(str::len(x)),\n@@ -56,7 +56,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(&String::new()).map(|x| str::len(x))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:44:5\n+  --> $DIR/manual_map_option.rs:51:5\n    |\n LL | /     match &Some([0, 1]) {\n LL | |         Some(x) => Some(x[0]),\n@@ -65,7 +65,7 @@ LL | |     };\n    | |_____^ help: try this: `Some([0, 1]).as_ref().map(|x| x[0])`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:49:5\n+  --> $DIR/manual_map_option.rs:56:5\n    |\n LL | /     match &Some(0) {\n LL | |         &Some(x) => Some(x * 2),\n@@ -74,7 +74,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x * 2)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:54:5\n+  --> $DIR/manual_map_option.rs:61:5\n    |\n LL | /     match Some(String::new()) {\n LL | |         Some(ref x) => Some(x.is_empty()),\n@@ -83,7 +83,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:59:5\n+  --> $DIR/manual_map_option.rs:66:5\n    |\n LL | /     match &&Some(String::new()) {\n LL | |         Some(x) => Some(x.len()),\n@@ -92,7 +92,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:64:5\n+  --> $DIR/manual_map_option.rs:71:5\n    |\n LL | /     match &&Some(0) {\n LL | |         &&Some(x) => Some(x + x),\n@@ -101,7 +101,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(0).map(|x| x + x)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:77:9\n+  --> $DIR/manual_map_option.rs:84:9\n    |\n LL | /         match &mut Some(String::new()) {\n LL | |             Some(x) => Some(x.push_str(\"\")),\n@@ -110,7 +110,7 @@ LL | |         };\n    | |_________^ help: try this: `Some(String::new()).as_mut().map(|x| x.push_str(\"\"))`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:83:5\n+  --> $DIR/manual_map_option.rs:90:5\n    |\n LL | /     match &mut Some(String::new()) {\n LL | |         Some(ref x) => Some(x.len()),\n@@ -119,7 +119,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.len())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:88:5\n+  --> $DIR/manual_map_option.rs:95:5\n    |\n LL | /     match &mut &Some(String::new()) {\n LL | |         Some(x) => Some(x.is_empty()),\n@@ -128,7 +128,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(String::new()).as_ref().map(|x| x.is_empty())`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:93:5\n+  --> $DIR/manual_map_option.rs:100:5\n    |\n LL | /     match Some((0, 1, 2)) {\n LL | |         Some((x, y, z)) => Some(x + y + z),\n@@ -137,7 +137,7 @@ LL | |     };\n    | |_____^ help: try this: `Some((0, 1, 2)).map(|(x, y, z)| x + y + z)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:98:5\n+  --> $DIR/manual_map_option.rs:105:5\n    |\n LL | /     match Some([1, 2, 3]) {\n LL | |         Some([first, ..]) => Some(first),\n@@ -146,13 +146,31 @@ LL | |     };\n    | |_____^ help: try this: `Some([1, 2, 3]).map(|[first, ..]| first)`\n \n error: manual implementation of `Option::map`\n-  --> $DIR/manual_map_option.rs:103:5\n+  --> $DIR/manual_map_option.rs:110:5\n    |\n LL | /     match &Some((String::new(), \"test\")) {\n LL | |         Some((x, y)) => Some((y, x)),\n LL | |         None => None,\n LL | |     };\n    | |_____^ help: try this: `Some((String::new(), \"test\")).as_ref().map(|(x, y)| (y, x))`\n \n-error: aborting due to 17 previous errors\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:168:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         Some(x) => Some(vec![x]),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).map(|x| vec![x])`\n+\n+error: manual implementation of `Option::map`\n+  --> $DIR/manual_map_option.rs:173:5\n+   |\n+LL | /     match option_env!(\"\") {\n+LL | |         Some(x) => Some(String::from(x)),\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `option_env!(\"\").map(String::from)`\n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "da4e3020d5b83d6f20c9788b67d7901fa7c95a51", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -120,6 +120,35 @@ fn match_same_arms() {\n         },\n     }\n \n+    // False positive #1390\n+    macro_rules! empty {\n+        ($e:expr) => {};\n+    }\n+    match 0 {\n+        0 => {\n+            empty!(0);\n+        },\n+        1 => {\n+            empty!(1);\n+        },\n+        x => {\n+            empty!(x);\n+        },\n+    };\n+\n+    // still lint if the tokens are the same\n+    match 0 {\n+        0 => {\n+            empty!(0);\n+        },\n+        1 => {\n+            empty!(0);\n+        },\n+        x => {\n+            empty!(x);\n+        },\n+    }\n+\n     match_expr_like_matches_macro_priority();\n }\n "}, {"sha": "95f9494cdc99e9f82f202a00698a7e2592571e70", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -141,8 +141,31 @@ LL |         Ok(3) => println!(\"ok\"),\n    |         ^^^^^\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error: this `match` has identical arm bodies\n+  --> $DIR/match_same_arms2.rs:144:14\n+   |\n+LL |           1 => {\n+   |  ______________^\n+LL | |             empty!(0);\n+LL | |         },\n+   | |_________^\n+   |\n+note: same as this\n+  --> $DIR/match_same_arms2.rs:141:14\n+   |\n+LL |           0 => {\n+   |  ______________^\n+LL | |             empty!(0);\n+LL | |         },\n+   | |_________^\n+help: consider refactoring into `0 | 1`\n+  --> $DIR/match_same_arms2.rs:141:9\n+   |\n+LL |         0 => {\n+   |         ^\n+\n error: match expression looks like `matches!` macro\n-  --> $DIR/match_same_arms2.rs:133:16\n+  --> $DIR/match_same_arms2.rs:162:16\n    |\n LL |       let _ans = match x {\n    |  ________________^\n@@ -154,5 +177,5 @@ LL | |     };\n    |\n    = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "4643e09e2702835ac9803b6050b49f1ba7267171", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -8,7 +8,7 @@ LL | |     }\n    |\n    = note: `-D clippy::new-ret-no-self` implied by `-D warnings`\n \n-error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead\n   --> $DIR/methods.rs:126:13\n    |\n LL |       let _ = v.iter().filter(|&x| {"}, {"sha": "852f48e32d678aa91a2fd32a591fa917212747d3", "filename": "tests/ui/methods_fixable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmethods_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmethods_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods_fixable.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead.\n+error: called `filter(..).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(..)` instead\n   --> $DIR/methods_fixable.rs:10:13\n    |\n LL |     let _ = v.iter().filter(|&x| *x < 0).next();"}, {"sha": "ea39f5b5577beb12803a059f1b3c9322098e55c6", "filename": "tests/ui/mismatched_target_os_unix.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmismatched_target_os_unix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmismatched_target_os_unix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_target_os_unix.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -7,7 +7,7 @@ LL | #[cfg(linux)]\n    |       help: try: `target_os = \"linux\"`\n    |\n    = note: `-D clippy::mismatched-target-os` implied by `-D warnings`\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:9:1\n@@ -17,7 +17,7 @@ LL | #[cfg(freebsd)]\n    |       |\n    |       help: try: `target_os = \"freebsd\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:12:1\n@@ -27,7 +27,7 @@ LL | #[cfg(dragonfly)]\n    |       |\n    |       help: try: `target_os = \"dragonfly\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:15:1\n@@ -37,7 +37,7 @@ LL | #[cfg(openbsd)]\n    |       |\n    |       help: try: `target_os = \"openbsd\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:18:1\n@@ -47,7 +47,7 @@ LL | #[cfg(netbsd)]\n    |       |\n    |       help: try: `target_os = \"netbsd\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:21:1\n@@ -57,7 +57,7 @@ LL | #[cfg(macos)]\n    |       |\n    |       help: try: `target_os = \"macos\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:24:1\n@@ -67,7 +67,7 @@ LL | #[cfg(ios)]\n    |       |\n    |       help: try: `target_os = \"ios\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:27:1\n@@ -77,7 +77,7 @@ LL | #[cfg(android)]\n    |       |\n    |       help: try: `target_os = \"android\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:30:1\n@@ -87,7 +87,7 @@ LL | #[cfg(emscripten)]\n    |       |\n    |       help: try: `target_os = \"emscripten\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:33:1\n@@ -97,7 +97,7 @@ LL | #[cfg(fuchsia)]\n    |       |\n    |       help: try: `target_os = \"fuchsia\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:36:1\n@@ -107,7 +107,7 @@ LL | #[cfg(haiku)]\n    |       |\n    |       help: try: `target_os = \"haiku\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:39:1\n@@ -117,7 +117,7 @@ LL | #[cfg(illumos)]\n    |       |\n    |       help: try: `target_os = \"illumos\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:42:1\n@@ -127,7 +127,7 @@ LL | #[cfg(l4re)]\n    |       |\n    |       help: try: `target_os = \"l4re\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:45:1\n@@ -137,7 +137,7 @@ LL | #[cfg(redox)]\n    |       |\n    |       help: try: `target_os = \"redox\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:48:1\n@@ -147,7 +147,7 @@ LL | #[cfg(solaris)]\n    |       |\n    |       help: try: `target_os = \"solaris\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:51:1\n@@ -157,15 +157,15 @@ LL | #[cfg(vxworks)]\n    |       |\n    |       help: try: `target_os = \"vxworks\"`\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n \n error: operating system used in target family position\n   --> $DIR/mismatched_target_os_unix.rs:55:1\n    |\n LL | #[cfg(all(not(any(solaris, linux)), freebsd))]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Did you mean `unix`?\n+   = help: did you mean `unix`?\n help: try\n    |\n LL | #[cfg(all(not(any(target_os = \"solaris\", linux)), freebsd))]"}, {"sha": "6e0400ac935bb1e1df78e3336e75e2d3ec76b094", "filename": "tests/ui/missing_inline_executable.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmissing_inline_executable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmissing_inline_executable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_inline_executable.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,5 @@\n+#![warn(clippy::missing_inline_in_public_items)]\n+\n+pub fn foo() {}\n+\n+fn main() {}"}, {"sha": "3c68fb905f12d2db85b8509c0f2d2551fc111696", "filename": "tests/ui/missing_inline_proc_macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmissing_inline_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fmissing_inline_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing_inline_proc_macro.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -0,0 +1,23 @@\n+#![warn(clippy::missing_inline_in_public_items)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+fn _foo() {}\n+\n+#[proc_macro]\n+pub fn function_like(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attribute(_: TokenStream, _: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+#[proc_macro_derive(Derive)]\n+pub fn derive(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "af6c7bf15ea6cae887be6438d552479692858860", "filename": "tests/ui/needless_collect.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused, clippy::suspicious_map)]\n+#![allow(unused, clippy::suspicious_map, clippy::iter_count)]\n \n use std::collections::{BTreeSet, HashMap, HashSet};\n "}, {"sha": "6ae14f370b14b540c1d1a38eecc47a9aca3b1463", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused, clippy::suspicious_map)]\n+#![allow(unused, clippy::suspicious_map, clippy::iter_count)]\n \n use std::collections::{BTreeSet, HashMap, HashSet};\n "}, {"sha": "76e789d90525495e6200688688b566237c98586a", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -6,7 +6,7 @@ LL | |     indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>\n    | |____^\n    |\n    = note: `-D clippy::needless-collect` implied by `-D warnings`\n-help: Use the original Iterator instead of collecting it and then producing a new one\n+help: use the original Iterator instead of collecting it and then producing a new one\n    |\n LL |     \n LL |     sample.iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n@@ -19,7 +19,7 @@ LL | /     let indirect_len = sample.iter().collect::<VecDeque<_>>();\n LL | |     indirect_len.len();\n    | |____^\n    |\n-help: Take the original Iterator's count instead of collecting it and finding the length\n+help: take the original Iterator's count instead of collecting it and finding the length\n    |\n LL |     \n LL |     sample.iter().count();\n@@ -32,7 +32,7 @@ LL | /     let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n LL | |     indirect_empty.is_empty();\n    | |____^\n    |\n-help: Check if the original Iterator has anything instead of collecting it and seeing if it's empty\n+help: check if the original Iterator has anything instead of collecting it and seeing if it's empty\n    |\n LL |     \n LL |     sample.iter().next().is_none();\n@@ -45,7 +45,7 @@ LL | /     let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n LL | |     indirect_contains.contains(&&5);\n    | |____^\n    |\n-help: Check if the original Iterator contains an element instead of collecting then checking\n+help: check if the original Iterator contains an element instead of collecting then checking\n    |\n LL |     \n LL |     sample.iter().any(|x| x == &5);\n@@ -58,7 +58,7 @@ LL | /     let non_copy_contains = sample.into_iter().collect::<Vec<_>>();\n LL | |     non_copy_contains.contains(&a);\n    | |____^\n    |\n-help: Check if the original Iterator contains an element instead of collecting then checking\n+help: check if the original Iterator contains an element instead of collecting then checking\n    |\n LL |     \n LL |     sample.into_iter().any(|x| x == a);"}, {"sha": "bda0801e51c7f8663f648edd0eac8bae30898863", "filename": "tests/ui/needless_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -105,11 +105,7 @@ fn fn_bound_3_cannot_elide() {\n \n // No error; multiple input refs.\n fn fn_bound_4<'a, F: FnOnce() -> &'a ()>(cond: bool, x: &'a (), f: F) -> &'a () {\n-    if cond {\n-        x\n-    } else {\n-        f()\n-    }\n+    if cond { x } else { f() }\n }\n \n struct X {"}, {"sha": "33a6de1618d12c1a509df271c43b8f57e11d9282", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -43,109 +43,109 @@ LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:120:5\n+  --> $DIR/needless_lifetimes.rs:116:5\n    |\n LL |     fn self_and_out<'s>(&'s self) -> &'s u8 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:129:5\n+  --> $DIR/needless_lifetimes.rs:125:5\n    |\n LL |     fn distinct_self_and_in<'s, 't>(&'s self, _x: &'t u8) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:148:1\n+  --> $DIR/needless_lifetimes.rs:144:1\n    |\n LL | fn struct_with_lt<'a>(_foo: Foo<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:178:1\n+  --> $DIR/needless_lifetimes.rs:174:1\n    |\n LL | fn trait_obj_elided2<'a>(_arg: &'a dyn Drop) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:184:1\n+  --> $DIR/needless_lifetimes.rs:180:1\n    |\n LL | fn alias_with_lt<'a>(_foo: FooAlias<'a>) -> &'a str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:203:1\n+  --> $DIR/needless_lifetimes.rs:199:1\n    |\n LL | fn named_input_elided_output<'a>(_arg: &'a str) -> &str {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:211:1\n+  --> $DIR/needless_lifetimes.rs:207:1\n    |\n LL | fn trait_bound_ok<'a, T: WithLifetime<'static>>(_: &'a u8, _: T) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:247:1\n+  --> $DIR/needless_lifetimes.rs:243:1\n    |\n LL | fn out_return_type_lts<'a>(e: &'a str) -> Cow<'a> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:254:9\n+  --> $DIR/needless_lifetimes.rs:250:9\n    |\n LL |         fn needless_lt<'a>(x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:258:9\n+  --> $DIR/needless_lifetimes.rs:254:9\n    |\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:271:9\n+  --> $DIR/needless_lifetimes.rs:267:9\n    |\n LL |         fn baz<'a>(&'a self) -> impl Foo + 'a {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:300:5\n+  --> $DIR/needless_lifetimes.rs:296:5\n    |\n LL |     fn impl_trait_elidable_nested_named_lifetimes<'a>(i: &'a i32, f: impl for<'b> Fn(&'b i32) -> &'b i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:303:5\n+  --> $DIR/needless_lifetimes.rs:299:5\n    |\n LL |     fn impl_trait_elidable_nested_anonymous_lifetimes<'a>(i: &'a i32, f: impl Fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:312:5\n+  --> $DIR/needless_lifetimes.rs:308:5\n    |\n LL |     fn generics_elidable<'a, T: Fn(&i32) -> &i32>(i: &'a i32, f: T) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:324:5\n+  --> $DIR/needless_lifetimes.rs:320:5\n    |\n LL |     fn where_clause_elidadable<'a, T>(i: &'a i32, f: T) -> &'a i32\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:339:5\n+  --> $DIR/needless_lifetimes.rs:335:5\n    |\n LL |     fn pointer_fn_elidable<'a>(i: &'a i32, f: fn(&i32) -> &i32) -> &'a i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:352:5\n+  --> $DIR/needless_lifetimes.rs:348:5\n    |\n LL |     fn nested_fn_pointer_3<'a>(_: &'a i32) -> fn(fn(&i32) -> &i32) -> i32 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n-  --> $DIR/needless_lifetimes.rs:355:5\n+  --> $DIR/needless_lifetimes.rs:351:5\n    |\n LL |     fn nested_fn_pointer_4<'a>(_: &'a i32) -> impl Fn(fn(&i32)) {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "983c56031d8f5301879a48ce16497a35ce065c5d", "filename": "tests/ui/needless_question_mark.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_question_mark.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_question_mark.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_question_mark.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,84 +1,84 @@\n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:23:12\n    |\n LL |     return Some(to.magic?);\n    |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n    |\n    = note: `-D clippy::needless-question-mark` implied by `-D warnings`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:31:12\n    |\n LL |     return Some(to.magic?)\n    |            ^^^^^^^^^^^^^^^ help: try: `to.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:36:5\n    |\n LL |     Some(to.magic?)\n    |     ^^^^^^^^^^^^^^^ help: try: `to.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:41:21\n    |\n LL |     to.and_then(|t| Some(t.magic?))\n    |                     ^^^^^^^^^^^^^^ help: try: `t.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:50:9\n    |\n LL |         Some(t.magic?)\n    |         ^^^^^^^^^^^^^^ help: try: `t.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:55:12\n    |\n LL |     return Ok(tr.magic?);\n    |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:62:12\n    |\n LL |     return Ok(tr.magic?)\n    |            ^^^^^^^^^^^^^ help: try: `tr.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:66:5\n    |\n LL |     Ok(tr.magic?)\n    |     ^^^^^^^^^^^^^ help: try: `tr.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:70:21\n    |\n LL |     tr.and_then(|t| Ok(t.magic?))\n    |                     ^^^^^^^^^^^^ help: try: `t.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:78:9\n    |\n LL |         Ok(t.magic?)\n    |         ^^^^^^^^^^^^ help: try: `t.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:85:16\n    |\n LL |         return Ok(t.magic?);\n    |                ^^^^^^^^^^^^ help: try: `t.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:138:9\n    |\n LL |         Ok(to.magic?) // should be triggered\n    |         ^^^^^^^^^^^^^ help: try: `to.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:154:9\n    |\n LL |         Some(to.magic?) // should be triggered\n    |         ^^^^^^^^^^^^^^^ help: try: `to.magic`\n \n-error: Question mark operator is useless here\n+error: question mark operator is useless here\n   --> $DIR/needless_question_mark.rs:162:9\n    |\n LL |         Ok(to.magic?) // should be triggered"}, {"sha": "c898cd64a93925e0b5ef45fc640825bff9ff8f6d", "filename": "tests/ui/needless_range_loop.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_range_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_range_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:10:14\n    |\n LL |     for i in 0..vec.len() {\n@@ -10,7 +10,7 @@ help: consider using an iterator\n LL |     for <item> in &vec {\n    |         ^^^^^^    ^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:19:14\n    |\n LL |     for i in 0..vec.len() {\n@@ -21,7 +21,7 @@ help: consider using an iterator\n LL |     for <item> in &vec {\n    |         ^^^^^^    ^^^^\n \n-error: the loop variable `j` is only used to index `STATIC`.\n+error: the loop variable `j` is only used to index `STATIC`\n   --> $DIR/needless_range_loop.rs:24:14\n    |\n LL |     for j in 0..4 {\n@@ -32,7 +32,7 @@ help: consider using an iterator\n LL |     for <item> in &STATIC {\n    |         ^^^^^^    ^^^^^^^\n \n-error: the loop variable `j` is only used to index `CONST`.\n+error: the loop variable `j` is only used to index `CONST`\n   --> $DIR/needless_range_loop.rs:28:14\n    |\n LL |     for j in 0..4 {\n@@ -54,7 +54,7 @@ help: consider using an iterator\n LL |     for (i, <item>) in vec.iter().enumerate() {\n    |         ^^^^^^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec2`.\n+error: the loop variable `i` is only used to index `vec2`\n   --> $DIR/needless_range_loop.rs:40:14\n    |\n LL |     for i in 0..vec.len() {\n@@ -65,7 +65,7 @@ help: consider using an iterator\n LL |     for <item> in vec2.iter().take(vec.len()) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:44:14\n    |\n LL |     for i in 5..vec.len() {\n@@ -76,7 +76,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter().skip(5) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:48:14\n    |\n LL |     for i in 0..MAX_LEN {\n@@ -87,7 +87,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter().take(MAX_LEN) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:52:14\n    |\n LL |     for i in 0..=MAX_LEN {\n@@ -98,7 +98,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter().take(MAX_LEN + 1) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:56:14\n    |\n LL |     for i in 5..10 {\n@@ -109,7 +109,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter().take(10).skip(5) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop.rs:60:14\n    |\n LL |     for i in 5..=10 {"}, {"sha": "2e1f0fd0299b4cfb168785cc34b2bc11cfdf4110", "filename": "tests/ui/needless_range_loop2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_range_loop2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fneedless_range_loop2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_range_loop2.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,4 +1,4 @@\n-error: the loop variable `i` is only used to index `ns`.\n+error: the loop variable `i` is only used to index `ns`\n   --> $DIR/needless_range_loop2.rs:10:14\n    |\n LL |     for i in 3..10 {\n@@ -10,7 +10,7 @@ help: consider using an iterator\n LL |     for <item> in ns.iter().take(10).skip(3) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `ms`.\n+error: the loop variable `i` is only used to index `ms`\n   --> $DIR/needless_range_loop2.rs:31:14\n    |\n LL |     for i in 0..ms.len() {\n@@ -21,7 +21,7 @@ help: consider using an iterator\n LL |     for <item> in &mut ms {\n    |         ^^^^^^    ^^^^^^^\n \n-error: the loop variable `i` is only used to index `ms`.\n+error: the loop variable `i` is only used to index `ms`\n   --> $DIR/needless_range_loop2.rs:37:14\n    |\n LL |     for i in 0..ms.len() {\n@@ -32,7 +32,7 @@ help: consider using an iterator\n LL |     for <item> in &mut ms {\n    |         ^^^^^^    ^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop2.rs:61:14\n    |\n LL |     for i in x..x + 4 {\n@@ -43,7 +43,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter_mut().skip(x).take(4) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `vec`.\n+error: the loop variable `i` is only used to index `vec`\n   --> $DIR/needless_range_loop2.rs:68:14\n    |\n LL |     for i in x..=x + 4 {\n@@ -54,7 +54,7 @@ help: consider using an iterator\n LL |     for <item> in vec.iter_mut().skip(x).take(4 + 1) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `arr`.\n+error: the loop variable `i` is only used to index `arr`\n   --> $DIR/needless_range_loop2.rs:74:14\n    |\n LL |     for i in 0..3 {\n@@ -65,7 +65,7 @@ help: consider using an iterator\n LL |     for <item> in &arr {\n    |         ^^^^^^    ^^^^\n \n-error: the loop variable `i` is only used to index `arr`.\n+error: the loop variable `i` is only used to index `arr`\n   --> $DIR/needless_range_loop2.rs:78:14\n    |\n LL |     for i in 0..2 {\n@@ -76,7 +76,7 @@ help: consider using an iterator\n LL |     for <item> in arr.iter().take(2) {\n    |         ^^^^^^    ^^^^^^^^^^^^^^^^^^\n \n-error: the loop variable `i` is only used to index `arr`.\n+error: the loop variable `i` is only used to index `arr`\n   --> $DIR/needless_range_loop2.rs:82:14\n    |\n LL |     for i in 1..3 {"}, {"sha": "64347cae5da385f2888cb9287f36b95f8746bd98", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -62,9 +62,15 @@ fn or_fun_call() {\n     let mut map = HashMap::<u64, String>::new();\n     map.entry(42).or_insert_with(String::new);\n \n+    let mut map_vec = HashMap::<u64, Vec<i32>>::new();\n+    map_vec.entry(42).or_insert_with(Vec::new);\n+\n     let mut btree = BTreeMap::<u64, String>::new();\n     btree.entry(42).or_insert_with(String::new);\n \n+    let mut btree_vec = BTreeMap::<u64, Vec<i32>>::new();\n+    btree_vec.entry(42).or_insert_with(Vec::new);\n+\n     let stringy = Some(String::from(\"\"));\n     let _ = stringy.unwrap_or_else(|| \"\".to_owned());\n "}, {"sha": "7faab0017b2e8f7485c8f07d2a82575c9453ca2d", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -62,9 +62,15 @@ fn or_fun_call() {\n     let mut map = HashMap::<u64, String>::new();\n     map.entry(42).or_insert(String::new());\n \n+    let mut map_vec = HashMap::<u64, Vec<i32>>::new();\n+    map_vec.entry(42).or_insert(vec![]);\n+\n     let mut btree = BTreeMap::<u64, String>::new();\n     btree.entry(42).or_insert(String::new());\n \n+    let mut btree_vec = BTreeMap::<u64, Vec<i32>>::new();\n+    btree_vec.entry(42).or_insert(vec![]);\n+\n     let stringy = Some(String::from(\"\"));\n     let _ = stringy.unwrap_or(\"\".to_owned());\n "}, {"sha": "1e2bfd490e099b942a2a0687ccf08f5eb6d8aeef", "filename": "tests/ui/or_fun_call.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -67,40 +67,52 @@ LL |     map.entry(42).or_insert(String::new());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-  --> $DIR/or_fun_call.rs:66:21\n+  --> $DIR/or_fun_call.rs:66:23\n+   |\n+LL |     map_vec.entry(42).or_insert(vec![]);\n+   |                       ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n+\n+error: use of `or_insert` followed by a function call\n+  --> $DIR/or_fun_call.rs:69:21\n    |\n LL |     btree.entry(42).or_insert(String::new());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(String::new)`\n \n+error: use of `or_insert` followed by a function call\n+  --> $DIR/or_fun_call.rs:72:25\n+   |\n+LL |     btree_vec.entry(42).or_insert(vec![]);\n+   |                         ^^^^^^^^^^^^^^^^^ help: try this: `or_insert_with(Vec::new)`\n+\n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:69:21\n+  --> $DIR/or_fun_call.rs:75:21\n    |\n LL |     let _ = stringy.unwrap_or(\"\".to_owned());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:77:21\n+  --> $DIR/or_fun_call.rs:83:21\n    |\n LL |     let _ = Some(1).unwrap_or(map[&1]);\n    |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n \n error: use of `unwrap_or` followed by a function call\n-  --> $DIR/or_fun_call.rs:79:21\n+  --> $DIR/or_fun_call.rs:85:21\n    |\n LL |     let _ = Some(1).unwrap_or(map[&1]);\n    |                     ^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| map[&1])`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:103:35\n+  --> $DIR/or_fun_call.rs:109:35\n    |\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n error: use of `or` followed by a function call\n-  --> $DIR/or_fun_call.rs:107:10\n+  --> $DIR/or_fun_call.rs:113:10\n    |\n LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 19 previous errors\n "}, {"sha": "d302b16d4b72ac801147a2056717b8f58a699b54", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,30 +1,30 @@\n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n   --> $DIR/ptr_arg.rs:7:14\n    |\n LL | fn do_vec(x: &Vec<i64>) {\n    |              ^^^^^^^^^ help: change this to: `&[i64]`\n    |\n    = note: `-D clippy::ptr-arg` implied by `-D warnings`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do.\n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:16:14\n    |\n LL | fn do_str(x: &String) {\n    |              ^^^^^^^ help: change this to: `&str`\n \n-error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:25:15\n    |\n LL | fn do_path(x: &PathBuf) {\n    |               ^^^^^^^^ help: change this to: `&Path`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n   --> $DIR/ptr_arg.rs:38:18\n    |\n LL |     fn do_vec(x: &Vec<i64>);\n    |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n   --> $DIR/ptr_arg.rs:51:14\n    |\n LL | fn cloned(x: &Vec<u8>) -> Vec<u8> {\n@@ -43,7 +43,7 @@ help: change `x.clone()` to\n LL |     x.to_owned()\n    |\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do.\n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:60:18\n    |\n LL | fn str_cloned(x: &String) -> String {\n@@ -66,7 +66,7 @@ help: change `x.clone()` to\n LL |     x.to_string()\n    |\n \n-error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:68:19\n    |\n LL | fn path_cloned(x: &PathBuf) -> PathBuf {\n@@ -89,7 +89,7 @@ help: change `x.clone()` to\n LL |     x.to_path_buf()\n    |\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do.\n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:76:44\n    |\n LL | fn false_positive_capacity(x: &Vec<u8>, y: &String) {\n@@ -108,13 +108,13 @@ help: change `y.as_str()` to\n LL |     let c = y;\n    |             ^\n \n-error: using a reference to `Cow` is not recommended.\n+error: using a reference to `Cow` is not recommended\n   --> $DIR/ptr_arg.rs:90:25\n    |\n LL | fn test_cow_with_ref(c: &Cow<[i32]>) {}\n    |                         ^^^^^^^^^^^ help: change this to: `&[i32]`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices\n   --> $DIR/ptr_arg.rs:143:21\n    |\n LL |     fn foo_vec(vec: &Vec<u8>) {\n@@ -133,7 +133,7 @@ help: change `vec.clone()` to\n LL |         let _ = vec.to_owned().clone();\n    |                 ^^^^^^^^^^^^^^\n \n-error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:148:23\n    |\n LL |     fn foo_path(path: &PathBuf) {\n@@ -152,7 +152,7 @@ help: change `path.clone()` to\n LL |         let _ = path.to_path_buf().clone();\n    |                 ^^^^^^^^^^^^^^^^^^\n \n-error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do.\n+error: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n   --> $DIR/ptr_arg.rs:153:21\n    |\n LL |     fn foo_str(str: &PathBuf) {"}, {"sha": "ec309109ed52b485d015f5309c87fe93264776ed", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n+#![allow(clippy::implicit_clone)]\n use std::ffi::OsString;\n use std::path::Path;\n \n@@ -58,11 +59,7 @@ fn main() {\n #[derive(Clone)]\n struct Alpha;\n fn with_branch(a: Alpha, b: bool) -> (Alpha, Alpha) {\n-    if b {\n-        (a.clone(), a)\n-    } else {\n-        (Alpha, a)\n-    }\n+    if b { (a.clone(), a) } else { (Alpha, a) }\n }\n \n fn cannot_double_move(a: Alpha) -> (Alpha, Alpha) {"}, {"sha": "b57027456e094fcdf95584cef10c1e3eca75f6e2", "filename": "tests/ui/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n // rustfix-only-machine-applicable\n \n+#![allow(clippy::implicit_clone)]\n use std::ffi::OsString;\n use std::path::Path;\n \n@@ -58,11 +59,7 @@ fn main() {\n #[derive(Clone)]\n struct Alpha;\n fn with_branch(a: Alpha, b: bool) -> (Alpha, Alpha) {\n-    if b {\n-        (a.clone(), a.clone())\n-    } else {\n-        (Alpha, a)\n-    }\n+    if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n }\n \n fn cannot_double_move(a: Alpha) -> (Alpha, Alpha) {"}, {"sha": "821e7934be8d018c44dc016539a0b979557b7f50", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,168 +1,168 @@\n error: redundant clone\n-  --> $DIR/redundant_clone.rs:8:42\n+  --> $DIR/redundant_clone.rs:9:42\n    |\n LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n    |                                          ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::redundant-clone` implied by `-D warnings`\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:8:14\n+  --> $DIR/redundant_clone.rs:9:14\n    |\n LL |     let _s = [\"lorem\", \"ipsum\"].join(\" \").to_string();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:11:15\n+  --> $DIR/redundant_clone.rs:12:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:11:14\n+  --> $DIR/redundant_clone.rs:12:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:14:15\n+  --> $DIR/redundant_clone.rs:15:15\n    |\n LL |     let _s = s.to_string();\n    |               ^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:14:14\n+  --> $DIR/redundant_clone.rs:15:14\n    |\n LL |     let _s = s.to_string();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:17:15\n+  --> $DIR/redundant_clone.rs:18:15\n    |\n LL |     let _s = s.to_owned();\n    |               ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:17:14\n+  --> $DIR/redundant_clone.rs:18:14\n    |\n LL |     let _s = s.to_owned();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:19:42\n+  --> $DIR/redundant_clone.rs:20:42\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n    |                                          ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:19:14\n+  --> $DIR/redundant_clone.rs:20:14\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_owned();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:21:42\n+  --> $DIR/redundant_clone.rs:22:42\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n    |                                          ^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:21:14\n+  --> $DIR/redundant_clone.rs:22:14\n    |\n LL |     let _s = Path::new(\"/a/b/\").join(\"c\").to_path_buf();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:23:29\n+  --> $DIR/redundant_clone.rs:24:29\n    |\n LL |     let _s = OsString::new().to_owned();\n    |                             ^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:23:14\n+  --> $DIR/redundant_clone.rs:24:14\n    |\n LL |     let _s = OsString::new().to_owned();\n    |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:25:29\n+  --> $DIR/redundant_clone.rs:26:29\n    |\n LL |     let _s = OsString::new().to_os_string();\n    |                             ^^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:25:14\n+  --> $DIR/redundant_clone.rs:26:14\n    |\n LL |     let _s = OsString::new().to_os_string();\n    |              ^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:32:19\n+  --> $DIR/redundant_clone.rs:33:19\n    |\n LL |     let _t = tup.0.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:32:14\n+  --> $DIR/redundant_clone.rs:33:14\n    |\n LL |     let _t = tup.0.clone();\n    |              ^^^^^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:62:22\n+  --> $DIR/redundant_clone.rs:62:25\n    |\n-LL |         (a.clone(), a.clone())\n-   |                      ^^^^^^^^ help: remove this\n+LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n+   |                         ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:62:21\n+  --> $DIR/redundant_clone.rs:62:24\n    |\n-LL |         (a.clone(), a.clone())\n-   |                     ^\n+LL |     if b { (a.clone(), a.clone()) } else { (Alpha, a) }\n+   |                        ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:122:15\n+  --> $DIR/redundant_clone.rs:119:15\n    |\n LL |     let _s = s.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:122:14\n+  --> $DIR/redundant_clone.rs:119:14\n    |\n LL |     let _s = s.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:123:15\n+  --> $DIR/redundant_clone.rs:120:15\n    |\n LL |     let _t = t.clone();\n    |               ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:123:14\n+  --> $DIR/redundant_clone.rs:120:14\n    |\n LL |     let _t = t.clone();\n    |              ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:133:19\n+  --> $DIR/redundant_clone.rs:130:19\n    |\n LL |         let _f = f.clone();\n    |                   ^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/redundant_clone.rs:133:18\n+  --> $DIR/redundant_clone.rs:130:18\n    |\n LL |         let _f = f.clone();\n    |                  ^\n \n error: redundant clone\n-  --> $DIR/redundant_clone.rs:145:14\n+  --> $DIR/redundant_clone.rs:142:14\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |              ^^^^^^^^ help: remove this\n    |\n note: cloned value is neither consumed nor mutated\n-  --> $DIR/redundant_clone.rs:145:13\n+  --> $DIR/redundant_clone.rs:142:13\n    |\n LL |     let y = x.clone().join(\"matthias\");\n    |             ^^^^^^^^^"}, {"sha": "96065699d321a057f9a8e28bf07ad3e4551ee282", "filename": "tests/ui/suspicious_operation_groupings.stderr", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fsuspicious_operation_groupings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_operation_groupings.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,166 +1,166 @@\n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:14:9\n    |\n LL |         self.x == other.y && self.y == other.y && self.z == other.z\n-   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+   |         ^^^^^^^^^^^^^^^^^ help: did you mean: `self.x == other.x`\n    |\n    = note: `-D clippy::suspicious-operation-groupings` implied by `-D warnings`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:14:9\n    |\n LL |         self.x == other.y && self.y == other.y && self.z == other.z\n-   |         ^^^^^^^^^^^^^^^^^ help: I think you meant: `self.x == other.x`\n+   |         ^^^^^^^^^^^^^^^^^ help: did you mean: `self.x == other.x`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:27:20\n    |\n LL |     s1.a < s2.a && s1.a < s2.b\n-   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+   |                    ^^^^^^^^^^^ help: did you mean: `s1.b < s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:75:33\n    |\n LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d\n-   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                 ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:80:19\n    |\n LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n-   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                   ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:80:19\n    |\n LL |     s1.a * s2.a + s1.b * s2.c + s1.c * s2.c\n-   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                   ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:85:19\n    |\n LL |     s1.a * s2.a + s2.b * s2.b + s1.c * s2.c\n-   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                   ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:90:19\n    |\n LL |     s1.a * s2.a + s1.b * s1.b + s1.c * s2.c\n-   |                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                   ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:95:5\n    |\n LL |     s1.a * s1.a + s1.b * s2.b + s1.c * s2.c\n-   |     ^^^^^^^^^^^ help: I think you meant: `s1.a * s2.a`\n+   |     ^^^^^^^^^^^ help: did you mean: `s1.a * s2.a`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:100:33\n    |\n LL |     s1.a * s2.a + s1.b * s2.b + s1.c * s1.c\n-   |                                 ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                 ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:113:20\n    |\n LL |     (s1.a * s2.a + s1.b * s1.b)\n-   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                    ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:118:34\n    |\n LL |     (s1.a * s2.a + s1.b * s2.b + s1.c * s2.b + s1.d * s2.d)\n-   |                                  ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                  ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:123:38\n    |\n LL |     (s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)\n-   |                                      ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                      ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:128:39\n    |\n LL |     ((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d))\n-   |                                       ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                       ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:133:42\n    |\n LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n-   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                          ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:133:42\n    |\n LL |     (((s1.a * s2.a) + (s1.b * s2.b)) + ((s1.c * s2.b) + (s1.d * s2.d)))\n-   |                                          ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                          ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:138:40\n    |\n LL |     (((s1.a * s2.a) + (s1.b * s2.b) + (s1.c * s2.b)) + (s1.d * s2.d))\n-   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                        ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:143:40\n    |\n LL |     ((s1.a * s2.a) + ((s1.b * s2.b) + (s1.c * s2.b) + (s1.d * s2.d)))\n-   |                                        ^^^^^^^^^^^ help: I think you meant: `s1.c * s2.c`\n+   |                                        ^^^^^^^^^^^ help: did you mean: `s1.c * s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:148:20\n    |\n LL |     (s1.a * s2.a + s2.b * s2.b) / 2\n-   |                    ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                    ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:153:35\n    |\n LL |     i32::swap_bytes(s1.a * s2.a + s2.b * s2.b)\n-   |                                   ^^^^^^^^^^^ help: I think you meant: `s1.b * s2.b`\n+   |                                   ^^^^^^^^^^^ help: did you mean: `s1.b * s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:158:29\n    |\n LL |     s1.a > 0 && s1.b > 0 && s1.d == s2.c && s1.d == s2.d\n-   |                             ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+   |                             ^^^^^^^^^^^^ help: did you mean: `s1.c == s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:163:17\n    |\n LL |     s1.a > 0 && s1.d == s2.c && s1.b > 0 && s1.d == s2.d\n-   |                 ^^^^^^^^^^^^ help: I think you meant: `s1.c == s2.c`\n+   |                 ^^^^^^^^^^^^ help: did you mean: `s1.c == s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:172:77\n    |\n LL |     (n1.inner.0).0 == (n2.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.1).0\n-   |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: I think you meant: `(n1.inner.2).0 == (n2.inner.2).0`\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean: `(n1.inner.2).0 == (n2.inner.2).0`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:186:25\n    |\n LL |         s1.a <= s2.a && s1.a <= s2.b\n-   |                         ^^^^^^^^^^^^ help: I think you meant: `s1.b <= s2.b`\n+   |                         ^^^^^^^^^^^^ help: did you mean: `s1.b <= s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:192:23\n    |\n LL |     if s1.a < s2.a && s1.a < s2.b {\n-   |                       ^^^^^^^^^^^ help: I think you meant: `s1.b < s2.b`\n+   |                       ^^^^^^^^^^^ help: did you mean: `s1.b < s2.b`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:199:48\n    |\n LL |     -(-(-s1.a * -s2.a) + (-(-s1.b * -s2.b) + -(-s1.c * -s2.b) + -(-s1.d * -s2.d)))\n-   |                                                ^^^^^^^^^^^^^ help: I think you meant: `-s1.c * -s2.c`\n+   |                                                ^^^^^^^^^^^^^ help: did you mean: `-s1.c * -s2.c`\n \n-error: This sequence of operators looks suspiciously like a bug.\n+error: this sequence of operators looks suspiciously like a bug\n   --> $DIR/suspicious_operation_groupings.rs:204:27\n    |\n LL |     -(if -s1.a < -s2.a && -s1.a < -s2.b { s1.c } else { s2.a })\n-   |                           ^^^^^^^^^^^^^ help: I think you meant: `-s1.b < -s2.b`\n+   |                           ^^^^^^^^^^^^^ help: did you mean: `-s1.b < -s2.b`\n \n error: aborting due to 27 previous errors\n "}, {"sha": "b8cfd987394976da96c02ed4d70624068bbe68b6", "filename": "tests/ui/toplevel_ref_arg_non_rustfix.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftoplevel_ref_arg_non_rustfix.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,12 +1,12 @@\n-error: `ref` directly on a function argument is ignored. Consider using a reference type instead.\n+error: `ref` directly on a function argument is ignored. Consider using a reference type instead\n   --> $DIR/toplevel_ref_arg_non_rustfix.rs:9:15\n    |\n LL | fn the_answer(ref mut x: u8) {\n    |               ^^^^^^^^^\n    |\n    = note: `-D clippy::toplevel-ref-arg` implied by `-D warnings`\n \n-error: `ref` directly on a function argument is ignored. Consider using a reference type instead.\n+error: `ref` directly on a function argument is ignored. Consider using a reference type instead\n   --> $DIR/toplevel_ref_arg_non_rustfix.rs:15:24\n    |\n LL |         fn fun_example(ref _x: usize) {}"}, {"sha": "1848fc2490a00c64a3860145700864745c51d558", "filename": "tests/ui/transmuting_null.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ftransmuting_null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Ftransmuting_null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmuting_null.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,18 +1,18 @@\n-error: transmuting a known null pointer into a reference.\n+error: transmuting a known null pointer into a reference\n   --> $DIR/transmuting_null.rs:10:23\n    |\n LL |         let _: &u64 = std::mem::transmute(0 as *const u64);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmuting-null` implied by `-D warnings`\n \n-error: transmuting a known null pointer into a reference.\n+error: transmuting a known null pointer into a reference\n   --> $DIR/transmuting_null.rs:11:23\n    |\n LL |         let _: &u64 = std::mem::transmute(std::ptr::null::<u64>());\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: transmuting a known null pointer into a reference.\n+error: transmuting a known null pointer into a reference\n   --> $DIR/transmuting_null.rs:21:23\n    |\n LL |         let _: &u64 = std::mem::transmute(ZPTR);"}, {"sha": "938cc3c785978f6b929bc6bd1d1d3eac799c32e6", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -27,6 +27,30 @@ impl Bar {\n     }\n }\n \n+fn baz<T: Debug>(t: T) {\n+    foo(t);\n+}\n+\n+trait Tr {\n+    type Args;\n+    fn do_it(args: Self::Args);\n+}\n+\n+struct A;\n+impl Tr for A {\n+    type Args = ();\n+    fn do_it(_: Self::Args) {}\n+}\n+\n+struct B;\n+impl Tr for B {\n+    type Args = <A as Tr>::Args;\n+\n+    fn do_it(args: Self::Args) {\n+        A::do_it(args)\n+    }\n+}\n+\n fn bad() {\n     foo({\n         1;\n@@ -59,7 +83,7 @@ fn bad() {\n     None.or(Some(foo(2)));\n     // in this case, the suggestion can be inlined, no need for a surrounding block\n     // foo(()); foo(()) instead of { foo(()); foo(()) }\n-    foo(foo(()))\n+    foo(foo(()));\n }\n \n fn ok() {\n@@ -71,6 +95,10 @@ fn ok() {\n     b.bar({ 1 });\n     b.bar(());\n     question_mark();\n+    let named_unit_arg = ();\n+    foo(named_unit_arg);\n+    baz(());\n+    B::do_it(());\n }\n \n fn question_mark() -> Result<(), ()> {"}, {"sha": "354fd51cd6b608954dd7e84888206744824cd4de", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:31:5\n+  --> $DIR/unit_arg.rs:55:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:34:5\n+  --> $DIR/unit_arg.rs:58:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:35:5\n+  --> $DIR/unit_arg.rs:59:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:40:5\n+  --> $DIR/unit_arg.rs:64:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL |     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:43:5\n+  --> $DIR/unit_arg.rs:67:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:44:5\n+  --> $DIR/unit_arg.rs:68:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL |     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:48:5\n+  --> $DIR/unit_arg.rs:72:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -140,7 +140,7 @@ LL |         foo(2);\n  ...\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:59:13\n+  --> $DIR/unit_arg.rs:83:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -154,19 +154,19 @@ LL |     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:62:5\n+  --> $DIR/unit_arg.rs:86:5\n    |\n-LL |     foo(foo(()))\n+LL |     foo(foo(()));\n    |     ^^^^^^^^^^^^\n    |\n help: move the expression in front of the call and replace it with the unit literal `()`\n    |\n LL |     foo(());\n-LL |     foo(())\n+LL |     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:95:5\n+  --> $DIR/unit_arg.rs:123:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}, {"sha": "cc94bd5cd9e16bcc03ab9b8d765384e19ea3089a", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -2,195 +2,195 @@ error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:35:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:36:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:37:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:39:13\n    |\n LL |     let _ = opt.and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `opt.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:40:13\n    |\n LL |     let _ = opt.or_else(|| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:41:13\n    |\n LL |     let _ = opt.or_else(|| None);\n-   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:42:13\n    |\n LL |     let _ = opt.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `opt.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:43:13\n    |\n LL |     let _ = opt.ok_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `opt.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:44:13\n    |\n LL |     let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `nested_tuple_opt.unwrap_or(Some((1, 2)))`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `nested_tuple_opt.unwrap_or(Some((1, 2)))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:47:13\n    |\n LL |     let _ = Some(10).unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:48:13\n    |\n LL |     let _ = Some(10).and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `Some(10).and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:49:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:50:13\n    |\n LL |     let _ = None.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `None.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:51:35\n    |\n LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `None.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:52:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| None);\n-   |                            ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n+   |                            ^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:55:13\n    |\n LL |     let _ = deep.0.unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:56:13\n    |\n LL |     let _ = deep.0.and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `deep.0.and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:57:13\n    |\n LL |     let _ = deep.0.or_else(|| None);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `deep.0.or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:58:13\n    |\n LL |     let _ = deep.0.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:59:13\n    |\n LL |     let _ = deep.0.ok_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `deep.0.ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:79:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| Some(3));\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(Some(3))`\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:80:13\n    |\n LL |     let _ = deep.0.or_else(|| Some(3));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(Some(3))`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `deep.0.or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:81:13\n    |\n LL |     let _ = opt.or_else(|| Some(3));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(Some(3))`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:87:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:88:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:89:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:111:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(2))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(2))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:112:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(astronomers_pi))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(astronomers_pi))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:113:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `res.and(Err(ext_str.some_field))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(ext_str.some_field))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:115:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(2))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(2))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:116:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(astronomers_pi))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(astronomers_pi))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:117:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `res.or(Ok(ext_str.some_field))`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(ext_str.some_field))`\n \n error: aborting due to 32 previous errors\n "}, {"sha": "75674b0a9d20ae128c8f26f427ef381364d8b779", "filename": "tests/ui/unnecessary_lazy_eval_unfixable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -2,21 +2,21 @@ error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:12:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|()| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:16:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|e::E| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:17:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "54f22e3ee6a4acab5cc6d94444eb4c8b082c0d8d", "filename": "tests/ui/unnecessary_wraps.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -22,29 +22,17 @@ fn func2(a: bool, b: bool) -> Option<i32> {\n     if a && b {\n         return Some(10);\n     }\n-    if a {\n-        Some(20)\n-    } else {\n-        Some(30)\n-    }\n+    if a { Some(20) } else { Some(30) }\n }\n \n // public fns should not be linted\n pub fn func3(a: bool) -> Option<i32> {\n-    if a {\n-        Some(1)\n-    } else {\n-        Some(1)\n-    }\n+    if a { Some(1) } else { Some(1) }\n }\n \n // should not be linted\n fn func4(a: bool) -> Option<i32> {\n-    if a {\n-        Some(1)\n-    } else {\n-        None\n-    }\n+    if a { Some(1) } else { None }\n }\n \n // should be linted\n@@ -64,11 +52,7 @@ fn func7() -> Result<i32, ()> {\n \n // should not be linted\n fn func8(a: bool) -> Result<i32, ()> {\n-    if a {\n-        Ok(1)\n-    } else {\n-        Err(())\n-    }\n+    if a { Ok(1) } else { Err(()) }\n }\n \n // should not be linted\n@@ -143,20 +127,12 @@ fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n \n // should not be linted\n fn issue_6640_3() -> Option<()> {\n-    if true {\n-        Some(())\n-    } else {\n-        None\n-    }\n+    if true { Some(()) } else { None }\n }\n \n // should not be linted\n fn issue_6640_4() -> Result<(), ()> {\n-    if true {\n-        Ok(())\n-    } else {\n-        Err(())\n-    }\n+    if true { Ok(()) } else { Err(()) }\n }\n \n fn main() {"}, {"sha": "0e570397e2a298c3dd189fa7be528be194b2dfcf", "filename": "tests/ui/unnecessary_wraps.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_wraps.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Funnecessary_wraps.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_wraps.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -32,8 +32,7 @@ LL | / fn func2(a: bool, b: bool) -> Option<i32> {\n LL | |     if a && b {\n LL | |         return Some(10);\n LL | |     }\n-...  |\n-LL | |     }\n+LL | |     if a { Some(20) } else { Some(30) }\n LL | | }\n    | |_^\n    |\n@@ -45,14 +44,11 @@ help: ...and then change returning expressions\n    |\n LL |         return 10;\n LL |     }\n-LL |     if a {\n-LL |         20\n-LL |     } else {\n-LL |         30\n+LL |     if a { 20 } else { 30 }\n    |\n \n error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:51:1\n+  --> $DIR/unnecessary_wraps.rs:39:1\n    |\n LL | / fn func5() -> Option<i32> {\n LL | |     Some(1)\n@@ -69,7 +65,7 @@ LL |     1\n    |\n \n error: this function's return value is unnecessarily wrapped by `Result`\n-  --> $DIR/unnecessary_wraps.rs:61:1\n+  --> $DIR/unnecessary_wraps.rs:49:1\n    |\n LL | / fn func7() -> Result<i32, ()> {\n LL | |     Ok(1)\n@@ -86,7 +82,7 @@ LL |     1\n    |\n \n error: this function's return value is unnecessarily wrapped by `Option`\n-  --> $DIR/unnecessary_wraps.rs:93:5\n+  --> $DIR/unnecessary_wraps.rs:77:5\n    |\n LL | /     fn func12() -> Option<i32> {\n LL | |         Some(1)\n@@ -103,7 +99,7 @@ LL |         1\n    |\n \n error: this function's return value is unnecessary\n-  --> $DIR/unnecessary_wraps.rs:120:1\n+  --> $DIR/unnecessary_wraps.rs:104:1\n    |\n LL | / fn issue_6640_1(a: bool, b: bool) -> Option<()> {\n LL | |     if a && b {\n@@ -129,7 +125,7 @@ LL |     } else {\n  ...\n \n error: this function's return value is unnecessary\n-  --> $DIR/unnecessary_wraps.rs:133:1\n+  --> $DIR/unnecessary_wraps.rs:117:1\n    |\n LL | / fn issue_6640_2(a: bool, b: bool) -> Result<(), i32> {\n LL | |     if a && b {"}, {"sha": "735909887acb189ac97b01a63708ae738989a2b1", "filename": "tests/ui/upper_case_acronyms.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fupper_case_acronyms.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679", "patch": "@@ -16,7 +16,8 @@ enum Flags {\n     FIN,\n }\n \n-struct GCCLLVMSomething; // linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n-                         // `GccLlvmSomething`\n+// linted with cfg option, beware that lint suggests `GccllvmSomething` instead of\n+// `GccLlvmSomething`\n+struct GCCLLVMSomething;\n \n fn main() {}"}, {"sha": "a630936e3b1d01ecd6b1d048146ad42e709a8741", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "f3e081dd2032856984d394b41cf2ce84d6896c77", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "e1410d2e652c133008c402b6c337ace873d25439", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "2cbfc5ca2e2705e0bb618bfad420339277493f22", "filename": "tests/ui/used_underscore_binding.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fused_underscore_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fused_underscore_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fused_underscore_binding.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "83435a40aa16fc7bf972192cea76eebd9c39abc1", "filename": "tests/ui/vec_box_sized.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fvec_box_sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fvec_box_sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "45b87aa0f20b9e7f4d90e88d4dfd87b64ee3747e", "filename": "tests/ui/wild_in_or_pats.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fwild_in_or_pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fwild_in_or_pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwild_in_or_pats.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "0931dd32e7af2e5a5568def4a1c6ac039ff76170", "filename": "tests/ui/zero_div_zero.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fzero_div_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fui%2Fzero_div_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.stderr?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}, {"sha": "1eaec4a50a6a6396f51a1d15969be3cd580c3190", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f2a005b4efd3e44ac6a02ea2b9660d28401679/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=f2f2a005b4efd3e44ac6a02ea2b9660d28401679"}]}