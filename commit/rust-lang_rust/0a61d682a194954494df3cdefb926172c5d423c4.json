{"sha": "0a61d682a194954494df3cdefb926172c5d423c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhNjFkNjgyYTE5NDk1NDQ5NGRmM2NkZWZiOTI2MTcyYzVkNDIzYzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-11-17T13:18:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-02T22:35:06Z"}, "message": "introduce placeholder-placeholder errors for trait matching", "tree": {"sha": "83b5757b8b974c0b219506d20e4f695cf38b2255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b5757b8b974c0b219506d20e4f695cf38b2255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a61d682a194954494df3cdefb926172c5d423c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a61d682a194954494df3cdefb926172c5d423c4", "html_url": "https://github.com/rust-lang/rust/commit/0a61d682a194954494df3cdefb926172c5d423c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a61d682a194954494df3cdefb926172c5d423c4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1597f2a0fca681219c1f495ed3bbe01aa889fb43", "url": "https://api.github.com/repos/rust-lang/rust/commits/1597f2a0fca681219c1f495ed3bbe01aa889fb43", "html_url": "https://github.com/rust-lang/rust/commit/1597f2a0fca681219c1f495ed3bbe01aa889fb43"}], "stats": {"total": 372, "additions": 273, "deletions": 99}, "files": [{"sha": "d0cb718f55a25cf2629897da5d16c0c2fcedc687", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -339,6 +339,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     RegionResolutionError::SubSupConflict(\n+                        _,\n                         var_origin,\n                         sub_origin,\n                         sub_r,\n@@ -407,7 +408,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         errors.sort_by_key(|u| match *u {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n-            RegionResolutionError::SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n         });\n         errors\n     }"}, {"sha": "f7ba546fa7f3bc52cc4a5831b9b0a018d366d6d3", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -8,6 +8,7 @@ use util::common::ErrorReported;\n mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n+mod placeholder_error;\n mod outlives_closure;\n mod static_impl_trait;\n mod util;\n@@ -58,19 +59,20 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict()\n+            .or_else(|| self.try_report_placeholder_conflict())\n     }\n \n     pub fn try_report(&self) -> Option<ErrorReported> {\n-        self.try_report_named_anon_conflict()\n+        self.try_report_from_nll()\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n             .or_else(|| self.try_report_static_impl_trait())\n     }\n \n     pub fn get_regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {\n         match (&self.error, self.regions) {\n-            (&Some(ConcreteFailure(ref origin, sub, sup)), None) => (origin.span(), sub, sup),\n-            (&Some(SubSupConflict(_, ref origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => (origin.span(), sub, sup),\n+            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n             (None, Some((span, sub, sup))) => (span, sub, sup),\n             (Some(_), Some(_)) => panic!(\"incorrectly built NiceRegionError\"),\n             _ => panic!(\"trying to report on an incorrect lifetime failure\"),"}, {"sha": "c4c71037d8b35df78022aff8d3fa6883f1773ba0", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -36,7 +36,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///              ...because it cannot outlive this closure\n     /// ```\n     pub(super) fn try_report_outlives_closure(&self) -> Option<ErrorReported> {\n-        if let Some(SubSupConflict(origin,\n+        if let Some(SubSupConflict(_,\n+                                   origin,\n                                    ref sub_origin,\n                                    _,\n                                    ref sup_origin,"}, {"sha": "f5e9f3814b46786919a88fb2d1e31ca57ba302ec", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -0,0 +1,223 @@\n+use hir::def_id::DefId;\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+use infer::lexical_region_resolve::RegionResolutionError;\n+use infer::ValuePairs;\n+use infer::{SubregionOrigin, TypeTrace};\n+use traits::{ObligationCause, ObligationCauseCode};\n+use ty;\n+use ty::error::ExpectedFound;\n+use ty::subst::Substs;\n+use util::common::ErrorReported;\n+use util::ppaux::RegionHighlightMode;\n+\n+impl NiceRegionError<'me, 'gcx, 'tcx> {\n+    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// an anonymous region, emit an descriptive diagnostic error.\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<ErrorReported> {\n+        // Check for the first case: relating two trait-refs, and we\n+        // find a conflict between two placeholders.\n+        match &self.error {\n+            Some(RegionResolutionError::SubSupConflict(\n+                vid,\n+                _,\n+                SubregionOrigin::Subtype(TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                ty::RePlaceholder(sub_placeholder),\n+                _,\n+                ty::RePlaceholder(sup_placeholder),\n+            )) => if expected.def_id == found.def_id {\n+                return Some(self.try_report_two_placeholders_trait(\n+                    Some(*vid),\n+                    cause,\n+                    Some(*sub_placeholder),\n+                    Some(*sup_placeholder),\n+                    expected.def_id,\n+                    expected.substs,\n+                    found.substs,\n+                ));\n+            } else {\n+                // I actually can't see why this would be the case ever.\n+            },\n+\n+            _ => {}\n+        }\n+\n+        None\n+    }\n+\n+    // error[E0308]: implementation of `Foo` does not apply to enough lifetimes\n+    //   --> /home/nmatsakis/tmp/foo.rs:12:5\n+    //    |\n+    // 12 |     all::<&'static u32>();\n+    //    |     ^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+    //    |\n+    //    = note: Due to a where-clause on the function `all`,\n+    //    = note: `T` must implement `...` for any two lifetimes `'1` and `'2`.\n+    //    = note: However, the type `T` only implements `...` for some specific lifetime `'2`.\n+    fn try_report_two_placeholders_trait(\n+        &self,\n+        vid: Option<ty::RegionVid>,\n+        cause: &ObligationCause<'tcx>,\n+        sub_placeholder: Option<ty::PlaceholderRegion>,\n+        sup_placeholder: Option<ty::PlaceholderRegion>,\n+        trait_def_id: DefId,\n+        expected_substs: &'tcx Substs<'tcx>,\n+        actual_substs: &'tcx Substs<'tcx>,\n+    ) -> ErrorReported {\n+        let mut err = self.tcx.sess.struct_span_err(\n+            cause.span(&self.tcx),\n+            &format!(\n+                \"implementation of `{}` is not general enough\",\n+                self.tcx.item_path_str(trait_def_id),\n+            ),\n+        );\n+\n+        match cause.code {\n+            ObligationCauseCode::ItemObligation(def_id) => {\n+                err.note(&format!(\n+                    \"Due to a where-clause on `{}`,\",\n+                    self.tcx.item_path_str(def_id),\n+                ));\n+            }\n+            _ => (),\n+        }\n+\n+        let expected_trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: expected_substs,\n+        };\n+        let actual_trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: actual_substs,\n+        };\n+\n+        // Search the expected and actual trait references to see (a)\n+        // whether the sub/sup placeholders appear in them (sometimes\n+        // you have a trait ref like `T: Foo<fn(&u8)>`, where the\n+        // placeholder was created as part of an inner type) and (b)\n+        // whether the inference variable appears. In each case,\n+        // assign a counter value in each case if so.\n+        let mut counter = 0;\n+        let mut has_sub = None;\n+        let mut has_sup = None;\n+        let mut has_vid = None;\n+\n+        self.tcx\n+            .for_each_free_region(&expected_trait_ref, |r| match r {\n+                ty::RePlaceholder(p) => {\n+                    if Some(*p) == sub_placeholder {\n+                        if has_sub.is_none() {\n+                            has_sub = Some(counter);\n+                            counter += 1;\n+                        }\n+                    } else if Some(*p) == sup_placeholder {\n+                        if has_sup.is_none() {\n+                            has_sup = Some(counter);\n+                            counter += 1;\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            });\n+\n+        self.tcx\n+            .for_each_free_region(&actual_trait_ref, |r| match r {\n+                ty::ReVar(v) if Some(*v) == vid => {\n+                    if has_vid.is_none() {\n+                        has_vid = Some(counter);\n+                        counter += 1;\n+                    }\n+                }\n+                _ => {}\n+            });\n+\n+        maybe_highlight(\n+            sub_placeholder,\n+            has_sub,\n+            RegionHighlightMode::highlighting_placeholder,\n+            || {\n+                maybe_highlight(\n+                    sup_placeholder,\n+                    has_sup,\n+                    RegionHighlightMode::highlighting_placeholder,\n+                    || match (has_sub, has_sup) {\n+                        (Some(n1), Some(n2)) => {\n+                            err.note(&format!(\n+                                \"`{}` must implement `{}` \\\n+                                 for any two lifetimes `'{}` and `'{}`\",\n+                                expected_trait_ref.self_ty(),\n+                                expected_trait_ref,\n+                                std::cmp::min(n1, n2),\n+                                std::cmp::max(n1, n2),\n+                            ));\n+                        }\n+                        (Some(n), _) | (_, Some(n)) => {\n+                            err.note(&format!(\n+                                \"`{}` must implement `{}` \\\n+                                 for any lifetime `'{}`\",\n+                                expected_trait_ref.self_ty(),\n+                                expected_trait_ref,\n+                                n,\n+                            ));\n+                        }\n+                        (None, None) => {\n+                            err.note(&format!(\n+                                \"`{}` must implement `{}`\",\n+                                expected_trait_ref.self_ty(),\n+                                expected_trait_ref,\n+                            ));\n+                        }\n+                    },\n+                )\n+            },\n+        );\n+\n+        maybe_highlight(\n+            vid,\n+            has_vid,\n+            RegionHighlightMode::highlighting_region_vid,\n+            || match has_vid {\n+                Some(n) => {\n+                    err.note(&format!(\n+                        \"but `{}` only implements `{}` for some lifetime `'{}`\",\n+                        actual_trait_ref.self_ty(),\n+                        actual_trait_ref,\n+                        n\n+                    ));\n+                }\n+                None => {\n+                    err.note(&format!(\n+                        \"but `{}` only implements `{}`\",\n+                        actual_trait_ref.self_ty(),\n+                        actual_trait_ref,\n+                    ));\n+                }\n+            },\n+        );\n+\n+        err.emit();\n+        ErrorReported\n+    }\n+}\n+\n+/// If both `thing` and `counter` are `Some`, invoke\n+/// `highlighting_func` with their contents (and the `op`). Else just\n+/// invoke `op`.\n+fn maybe_highlight<T, F, R>(\n+    thing: Option<T>,\n+    counter: Option<usize>,\n+    highlighting_func: impl FnOnce(T, usize, F) -> R,\n+    op: F,\n+) -> R\n+where\n+    F: FnOnce() -> R,\n+{\n+    if let Some(thing) = thing {\n+        if let Some(n) = counter {\n+            return highlighting_func(thing, n, op);\n+        }\n+    }\n+    op()\n+}"}, {"sha": "9fc3bb05cdab1f9e495cd9e706454728b2083ee9", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -11,6 +11,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n         if let Some(ref error) = self.error {\n             if let RegionResolutionError::SubSupConflict(\n+                    _,\n                     var_origin,\n                     sub_origin,\n                     sub_r,"}, {"sha": "dbf8f270ab0c988fb88e6ebb7c4ffddbbd90ad3b", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -73,12 +73,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `a` (but none of the known bounds are sufficient).\n     GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region<'tcx>),\n \n-    /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n+    /// `SubSupConflict(v, v_origin, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n-    /// Could not infer a value for `v` because `sub_r <= v` (due to\n-    /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n+    /// Could not infer a value for `v` (which has origin `v_origin`)\n+    /// because `sub_r <= v` (due to `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(\n+        RegionVid,\n         RegionVariableOrigin,\n         SubregionOrigin<'tcx>,\n         Region<'tcx>,\n@@ -596,6 +597,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                         origin, node_idx, lower_bound.region, upper_bound.region\n                     );\n                     errors.push(RegionResolutionError::SubSupConflict(\n+                        node_idx,\n                         origin,\n                         lower_bound.origin.clone(),\n                         lower_bound.region,"}, {"sha": "20fa1e7a48db18fe7f1e4f830455e6e2a290443d", "filename": "src/test/ui/associated-types/associated-types-eq-hr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -89,14 +89,12 @@ pub fn call_bar() {\n \n pub fn call_tuple_one() {\n     tuple_one::<Tuple>();\n-    //~^ ERROR E0495\n-    //~| ERROR E0495\n+    //~^ ERROR not general enough\n }\n \n pub fn call_tuple_two() {\n     tuple_two::<Tuple>();\n-    //~^ ERROR E0495\n-    //~| ERROR E0495\n+    //~^ ERROR not general enough\n }\n \n pub fn call_tuple_three() {\n@@ -105,7 +103,7 @@ pub fn call_tuple_three() {\n \n pub fn call_tuple_four() {\n     tuple_four::<Tuple>();\n-    //~^ ERROR E0495\n+    //~^ ERROR not general enough\n }\n \n fn main() { }"}, {"sha": "d3eaa894b504345f4a5bd6aab4399a39ee00a721", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -34,67 +34,36 @@ LL | |     // ok for UintStruct, but not IntStruct\n LL | | }\n    | |_^\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:91:5\n    |\n LL |     tuple_one::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:20), 'x) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:21), 'y) })...\n-   = note: ...so that the types are compatible:\n-           expected TheTrait<(&'x isize, &'y isize)>\n-              found TheTrait<(&isize, &isize)>\n+   = note: Due to a where-clause on `tuple_one`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/associated-types-eq-hr.rs:91:5\n-   |\n-LL |     tuple_one::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U2, name: BrNamed(crate0:DefIndex(1:20), 'x) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U2, name: BrNamed(crate0:DefIndex(1:21), 'y) })...\n-   = note: ...so that the types are compatible:\n-           expected TheTrait<(&'x isize, &'y isize)>\n-              found TheTrait<(&isize, &isize)>\n-\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/associated-types-eq-hr.rs:97:5\n-   |\n-LL |     tuple_two::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:23), 'x) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:24), 'y) })...\n-   = note: ...so that the types are compatible:\n-           expected TheTrait<(&'x isize, &'y isize)>\n-              found TheTrait<(&isize, &isize)>\n-\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/associated-types-eq-hr.rs:97:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n LL |     tuple_two::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U2, name: BrNamed(crate0:DefIndex(1:23), 'x) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U2, name: BrNamed(crate0:DefIndex(1:24), 'y) })...\n-   = note: ...so that the types are compatible:\n-           expected TheTrait<(&'x isize, &'y isize)>\n-              found TheTrait<(&isize, &isize)>\n+   = note: Due to a where-clause on `tuple_two`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/associated-types-eq-hr.rs:107:5\n+error: implementation of `TheTrait` is not general enough\n+  --> $DIR/associated-types-eq-hr.rs:105:5\n    |\n LL |     tuple_four::<Tuple>();\n    |     ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:28), 'x) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:29), 'y) })...\n-   = note: ...so that the types are compatible:\n-           expected TheTrait<(&'x isize, &'y isize)>\n-              found TheTrait<(&isize, &isize)>\n+   = note: Due to a where-clause on `tuple_four`,\n+   = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `Tuple` only implements `TheTrait<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-Some errors occurred: E0271, E0495.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "5b52bf3cd04b969f2b18021c3e36e2b9d4d1d124", "filename": "src/test/ui/generator/auto-trait-regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -47,6 +47,5 @@ fn main() {\n         assert_foo(a);\n     };\n     assert_foo(gen);\n-    //~^ ERROR E0495\n-    //~| ERROR E0495\n+    //~^ ERROR not general enough\n }"}, {"sha": "6f748a740328af6e4722cc865b447e2c53394d46", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -20,31 +20,15 @@ LL |     assert_foo(gen);\n    = note: lifetime RePlaceholder(Placeholder { universe: U35, name: BrAnon(1) })...\n    = note: ...does not necessarily outlive the static lifetime\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` due to conflicting requirements\n+error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:49:5\n    |\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U47, name: BrAnon(2) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U47, name: BrAnon(1) })...\n-   = note: ...so that the types are compatible:\n-           expected Foo\n-              found Foo\n+   = note: `A<'0, '1>` must implement `Foo` for any two lifetimes `'0` and `'1`\n+   = note: but `A<'_, '2>` only implements `Foo` for some lifetime `'2`\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` due to conflicting requirements\n-  --> $DIR/auto-trait-regions.rs:49:5\n-   |\n-LL |     assert_foo(gen);\n-   |     ^^^^^^^^^^\n-   |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U51, name: BrAnon(2) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U51, name: BrAnon(1) })...\n-   = note: ...so that the types are compatible:\n-           expected Foo\n-              found Foo\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors occurred: E0308, E0495.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2ee398e3dd3b220687552a49b0c466d8945dc857", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -1,15 +1,12 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-conflate-regions.rs:28:10\n    |\n LL | fn b() { want_foo2::<SomeStruct>(); } //~ ERROR\n    |          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:11), 'a) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U1, name: BrNamed(crate0:DefIndex(1:12), 'b) })...\n-   = note: ...so that the types are compatible:\n-           expected Foo<(&'a isize, &'b isize)>\n-              found Foo<(&isize, &isize)>\n+   = note: Due to a where-clause on `want_foo2`,\n+   = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>` for any two lifetimes `'0` and `'1`\n+   = note: but `SomeStruct` only implements `Foo<(&'2 isize, &'2 isize)>` for some lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "da3f8ad1b89570c29a63b6a2538388158050a0e6", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.rs?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -25,5 +25,5 @@ fn main() {\n     //     yielding `fn(&!b u32)`, in a fresh universe U1\n     //   - So we get `?a = !b` but the universe U0 assigned to `?a` cannot name `!b`.\n \n-    foo::<()>(); //~ ERROR cannot infer\n+    foo::<()>(); //~ ERROR not general enough\n }"}, {"sha": "6a61181e2407cb915276d937d745f75b346a2779", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a61d682a194954494df3cdefb926172c5d423c4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr?ref=0a61d682a194954494df3cdefb926172c5d423c4", "patch": "@@ -1,15 +1,12 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error: implementation of `Trait` is not general enough\n   --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n    |\n-LL |     foo::<()>(); //~ ERROR cannot infer\n+LL |     foo::<()>(); //~ ERROR not general enough\n    |     ^^^^^^^^^\n    |\n-   = note: first, the lifetime cannot outlive lifetime RePlaceholder(Placeholder { universe: U3, name: BrNamed(crate0:DefIndex(1:11), 'b) })...\n-   = note: ...but the lifetime must also be valid for lifetime RePlaceholder(Placeholder { universe: U3, name: BrNamed(crate0:DefIndex(1:11), 'b) })...\n-   = note: ...so that the types are compatible:\n-           expected Trait<for<'b> fn(std::cell::Cell<&'b u32>)>\n-              found Trait<fn(std::cell::Cell<&u32>)>\n+   = note: Due to a where-clause on `foo`,\n+   = note: `()` must implement `Trait<for<'b> fn(std::cell::Cell<&'b u32>)>`\n+   = note: but `()` only implements `Trait<fn(std::cell::Cell<&'0 u32>)>` for some lifetime `'0`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}]}