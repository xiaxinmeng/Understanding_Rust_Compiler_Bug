{"sha": "e712ad8f7342203504abae1b04545160610f3fc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MTJhZDhmNzM0MjIwMzUwNGFiYWUxYjA0NTQ1MTYwNjEwZjNmYzk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-11T23:27:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-12T00:21:53Z"}, "message": "rewrite lookup_method(), lookup_method_inner(), and lookup_method_inner_()", "tree": {"sha": "057bf763b3364b72563e85780d4c5dbe50042a1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/057bf763b3364b72563e85780d4c5dbe50042a1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e712ad8f7342203504abae1b04545160610f3fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e712ad8f7342203504abae1b04545160610f3fc9", "html_url": "https://github.com/rust-lang/rust/commit/e712ad8f7342203504abae1b04545160610f3fc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e712ad8f7342203504abae1b04545160610f3fc9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6943d8201215e60b74df7d3be8f48a52b3c2b7", "html_url": "https://github.com/rust-lang/rust/commit/3e6943d8201215e60b74df7d3be8f48a52b3c2b7"}], "stats": {"total": 615, "additions": 313, "deletions": 302}, "files": [{"sha": "52f93f9190940ea8ca9be960e05acb7f6b2c0e23", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e712ad8f7342203504abae1b04545160610f3fc9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712ad8f7342203504abae1b04545160610f3fc9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e712ad8f7342203504abae1b04545160610f3fc9", "patch": "@@ -100,6 +100,15 @@ impl extensions<T:copy> for option<T> {\n         { map_default(self, def, f) }\n     #[doc = \"Performs an operation on the contained value or does nothing\"]\n     fn iter(f: fn(T)) { iter(self, f) }\n+\n+    #[doc = \"Performs an operation on the contained value or does nothing\"]\n+    fn each(f: fn(T) -> bool) {\n+        alt self {\n+          none { /* ok */ }\n+          some(e) { f(e); }\n+        }\n+    }\n+\n     #[doc = \"\n     Gets the value out of an option\n "}, {"sha": "c40e6f185b875b2bb00421888743ef47a1531ecd", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e712ad8f7342203504abae1b04545160610f3fc9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712ad8f7342203504abae1b04545160610f3fc9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=e712ad8f7342203504abae1b04545160610f3fc9", "patch": "@@ -807,10 +807,11 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n }\n \n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n+    if substs.len() == 0u { ret typ; }\n     let tb = get(typ);\n+    if !tb.has_params { ret typ; }\n     alt tb.struct {\n       ty_param(idx, _) { substs[idx] }\n-      _ if !tb.has_params { typ }\n       s { mk_t(cx, fold_sty(s) {|t| substitute_type_params(cx, substs, t)}) }\n     }\n }"}, {"sha": "6e262358795cfcda5ac5e34b1a2ea10eb6079de4", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 302, "deletions": 301, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/e712ad8f7342203504abae1b04545160610f3fc9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e712ad8f7342203504abae1b04545160610f3fc9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=e712ad8f7342203504abae1b04545160610f3fc9", "patch": "@@ -229,7 +229,7 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n         });\n         fcx.write_ty_substs(id, tpt.ty, substs);\n     } else if ty_param_count > 0u {\n-        let vars = vec::from_fn(ty_param_count, {|_i| next_ty_var(fcx)});\n+        let vars = fcx.next_ty_vars(ty_param_count);\n         fcx.write_ty_substs(id, tpt.ty, vars);\n     } else {\n         fcx.write_ty(id, tpt.ty);\n@@ -491,7 +491,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n           ast::ty_infer {\n             alt mode {\n-              m_check_tyvar(fcx) { ret next_ty_var(fcx); }\n+              m_check_tyvar(fcx) { ret fcx.next_ty_var(); }\n               _ { tcx.sess.span_bug(ast_ty.span,\n                                     \"found `ty_infer` in unexpected place\"); }\n             }\n@@ -597,35 +597,6 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n \n type next_region_param_id = { mut id: uint };\n \n-// fn replace_inferred(tcx: ty::ctxt, ty: ty::t,\n-//                     rop: fn() -> ty::region) -> ty::t {\n-//     let tb = ty::get(ty);\n-//     if !tb.has_rptrs { ret ty; }\n-//     alt tb.struct {\n-//       // Replace re_inferred that are nested underneath\n-//       // a top-level region ptr with the region ptr itself.\n-//       ty::ty_rptr(ty::re_inferred, ty1) {\n-//         let r = rop();\n-//         ty::mk_rptr(r, replace_inferred(tcx, ty1) {|| r })\n-//       }\n-//       ty::ty_rptr(r, ty1) {\n-//         ty::mk_rptr(r, replace_inferred(tcx, ty1) {|| r })\n-//       }\n-//\n-//       // Do not replace inferred ptrs that appear within fn(...) types, as\n-//       // those are bound by the function.\n-//       ty::ty_fn(f) {\n-//         ty\n-//       }\n-//\n-//       // Otherwise just map.\n-//       sty {\n-//         ty::fold_sty_to_ty(tcx, sty) {|t|\n-//           replace_inferred(tcx, with_r, t) }\n-//       }\n-//     }\n-// }\n-\n fn replace_default_region(tcx: ty::ctxt,\n                           with_region: ty::region,\n                           ty: ty::t) -> ty::t {\n@@ -818,11 +789,13 @@ fn write_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id,\n }\n fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n                    +substs: [ty::t]) {\n-    let ty = if ty::type_has_params(ty) {\n-        ty::substitute_type_params(tcx, substs, ty)\n-    } else { ty };\n-    write_ty_to_tcx(tcx, node_id, ty);\n-    write_substs_to_tcx(tcx, node_id, substs);\n+    if substs.len() == 0u {\n+        write_ty_to_tcx(tcx, node_id, ty);\n+    } else {\n+        let ty = ty::substitute_type_params(tcx, substs, ty);\n+        write_ty_to_tcx(tcx, node_id, ty);\n+        write_substs_to_tcx(tcx, node_id, substs);\n+    }\n }\n \n impl methods for @fn_ctxt {\n@@ -889,6 +862,17 @@ impl methods for @fn_ctxt {\n     fn opt_node_ty_substs(id: ast::node_id) -> option<[ty::t]> {\n         self.node_type_substs.find(id)\n     }\n+    fn next_ty_var_id() -> ty_vid {\n+        let id = *self.next_var_id;\n+        *self.next_var_id += 1u;\n+        ret ty_vid(id);\n+    }\n+    fn next_ty_var() -> ty::t {\n+        ty::mk_var(self.ccx.tcx, self.next_ty_var_id())\n+    }\n+    fn next_ty_vars(n: uint) -> [ty::t] {\n+        vec::from_fn(n) {|_i| self.next_ty_var() }\n+    }\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n@@ -955,9 +939,7 @@ fn fixup_self_full(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n \n     ty::fold_ty(cx, mty) {|t|\n         alt ty::get(t).struct {\n-          ty::ty_self(tps) if vec::len(tps) == 0u {\n-            selfty\n-          }\n+          ty::ty_self(tps) if vec::len(tps) == 0u { selfty }\n           ty::ty_self(tps) {\n             // Move the substs into the type param system of the\n             // context.\n@@ -2196,286 +2178,303 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n-fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n-    if did.crate == ast::local_crate {\n+// determine the `self` type, using fresh variables for all variables declared\n+// on the impl declaration e.g., `impl<A,B> for [(A,B)]` would return ($0, $1)\n+// where $0 and $1 are freshly instantiated type variables.\n+fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n+    let tcx = fcx.ccx.tcx;\n+\n+    let {n_tps, raw_ty} = if did.crate == ast::local_crate {\n         alt check tcx.items.get(did.node) {\n           ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                _}, _) {\n-            {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n+            {n_tps: vec::len(ts),\n+             raw_ty: ast_ty_to_ty(tcx, m_check, st)}\n           }\n         }\n     } else {\n         let ity = ty::lookup_item_type(tcx, did);\n-        {n_tps: vec::len(*ity.bounds), ty: ity.ty}\n-    }\n+        {n_tps: vec::len(*ity.bounds),\n+         raw_ty: ity.ty}\n+    };\n+\n+    let substs = fcx.next_ty_vars(n_tps);\n+    let substd_ty = ty::substitute_type_params(tcx, substs, raw_ty);\n+    {substs: substs, ty: substd_ty}\n }\n \n type self_subst = {selfty: ty::t,\n                    fcx: @fn_ctxt,\n                    sp: span};\n \n-/*\n-  Takes arguments describing a method, and returns either its origin,\n-  or <none> if it's unbound.\n-\n-  expr: the entire method reference\n-  node_id: the method's ID\n-  name: the method's name\n-  ty: the type of the base expression\n-  tps: the ty substitutions that are part of the field expr\n-    (for example: in foo.bar<int,char>(), tps would be\n-     [int, char])\n-  include_private: true if we're inside the same class and should\n-     search private methods\n- */\n-fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n-                 name: ast::ident, ty: ty::t, tps: [ty::t],\n-                 include_private: bool)\n-    -> option<method_origin> {\n-    alt lookup_method_inner(fcx, expr, name, ty, include_private) {\n-      some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n-        let tcx = fcx.ccx.tcx;\n-        let mut substs = substs;\n-        let n_tps = vec::len(substs), n_tys = vec::len(tps);\n-        let has_self = ty::type_has_vars(fty);\n-        /* If either the method was declared to have ty params,\n-         or ty arguments were provided, or both... */\n-        if method_n_tps + n_tps > 0u {\n-          /* If no type arguments were given,\n-             or a different number of them were given than the\n-             method's declared types... */\n-            if n_tys == 0u || n_tys != method_n_tps {\n-                if n_tys != 0u {\n-                    tcx.sess.span_err\n-                        (expr.span, \"incorrect number of type \\\n-                                     parameters given for this method\");\n+enum lookup = {\n+    fcx: @fn_ctxt,\n+    expr: @ast::expr, // expr for a.b in a.b()\n+    node_id: ast::node_id, // node id of call (not always expr.id)\n+    m_name: ast::ident, // b in a.b(...)\n+    self_ty: ty::t, // type of a in a.b(...)\n+    supplied_tps: [ty::t], // Xs in a.b::<Xs>(...)\n+    include_private: bool\n+};\n+\n+impl methods for lookup {\n+    // Entrypoint:\n+    fn method() -> option<method_origin> {\n+        // First, see whether this is an interface-bounded parameter\n+        let pass1 = alt ty::get(self.self_ty).struct {\n+          ty::ty_param(n, did) {\n+            self.method_from_param(n, did)\n+          }\n+          ty::ty_iface(did, tps) {\n+            self.method_from_iface(did, tps)\n+          }\n+          ty::ty_class(did, tps) {\n+            self.method_from_class(did, tps)\n+          }\n+          _ {\n+            none\n+          }\n+        };\n \n+        alt pass1 {\n+          some(r) { some(r) }\n+          none { self.method_from_scope() }\n+        }\n+    }\n+\n+    fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n+\n+    fn method_from_param(n: uint, did: ast::def_id) -> option<method_origin> {\n+        let tcx = self.tcx();\n+        let mut iface_bnd_idx = 0u; // count only iface bounds\n+        let bounds = tcx.ty_param_bounds.get(did.node);\n+        for vec::each(*bounds) {|bound|\n+            let (iid, bound_tps) = alt bound {\n+              ty::bound_copy | ty::bound_send { cont; /* ok */ }\n+              ty::bound_iface(bound_t) {\n+                alt check ty::get(bound_t).struct {\n+                  ty::ty_iface(i, tps) { (i, tps) }\n                 }\n-                /* If not enough types were given, make some ty vars */\n-                substs += vec::from_fn(method_n_tps, {|_i|\n-                    ty::mk_var(tcx, next_ty_var_id(fcx))\n-                });\n-            } else {\n-             /* If the right number of types were given, just add them on */\n-                substs += tps;\n-            }\n-            /*\n-              For a class method, \"substs\" here begins with the class ty\n-              params\n-             */\n-            fcx.write_ty_substs(node_id, fty, substs);\n-        } else {\n-            if n_tys > 0u {\n-                tcx.sess.span_err(expr.span, \"this method does not take type \\\n-                                              parameters\");\n+              }\n+            };\n+\n+            let ifce_methods = ty::iface_methods(tcx, iid);\n+            alt vec::position(*ifce_methods, {|m| m.ident == self.m_name}) {\n+              none {\n+                /* check next bound */\n+                iface_bnd_idx += 1u;\n+              }\n+\n+              some(pos) {\n+                  ret some(self.write_mty_from_m(\n+                      some(self.self_ty), bound_tps, ifce_methods[pos],\n+                      method_param(iid, pos, n, iface_bnd_idx)));\n+              }\n             }\n-            fcx.write_ty(node_id, fty);\n-        }\n-        if has_self && !option::is_none(self_sub) {\n-            let fty = fcx.node_ty(node_id);\n-            let fty = fixup_self_param(\n-                fcx, fty, substs, option::get(self_sub), expr.span);\n-            fcx.write_ty(node_id, fty);\n         }\n-        if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n-            let fty = fcx.node_ty(node_id);\n-            let self_region = region_of(fcx, expr);\n-            let fty = replace_self_region(fcx.ccx.tcx, self_region, fty);\n-            fcx.write_ty(node_id, fty);\n-        }\n-        some(origin)\n-      }\n-      none { none }\n+        ret none;\n     }\n-}\n \n-enum method_kind {\n-    cls(ast::def_id), // *method* id (in both cases)\n-    an_iface(ast::def_id)\n-}\n+    fn method_from_iface(\n+        did: ast::def_id, iface_tps: [ty::t]) -> option<method_origin> {\n \n-fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n-     tps: [ty::t], parent: method_kind, name: ast::ident, sp: span,\n-                        include_private: bool)\n-    -> option<{method_ty: ty::t,\n-               n_tps: uint,\n-               substs: [ty::t],\n-               origin: method_origin,\n-               self_sub: option<ty::t>}> {\n-    let mut i = 0u;\n-    for ms.each {|m|\n-       if m.ident == name {\n-          let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n-          if ty::type_has_vars(fty) {\n-               tcx.sess.span_fatal(\n-                    sp, \"can not call a method that contains a \\\n-                                    self type through a boxed iface\");\n-          } else if (*m.tps).len() > 0u  &&\n-               alt parent { an_iface(_) { true } cls(_) { false } } {\n-                   tcx.sess.span_fatal(\n-                        sp, \"can not call a generic method through a \\\n-                                    boxed iface\");\n-          } else if m.privacy == ast::priv && !include_private {\n-                   tcx.sess.span_fatal(\n-                        sp, \"Call to private method not allowed outside \\\n-                          its defining class\");\n-          }\n-          #debug(\"lookup_method_inner_: %s has %u ty params, by its \\\n-            declaration\", name, vec::len(*m.tps));\n-          ret some({method_ty: fty,\n-                    n_tps: vec::len(*m.tps),\n-                    substs: tps,\n-                    origin: alt parent {\n-                      cls(parent_id)          {\n-                        // look up method named <name>\n-                        // its id is did\n-                        let m_declared = ty::lookup_class_method_by_name(tcx,\n-                                      parent_id, name, sp);\n-                        method_static(m_declared)\n-                      }\n-                      an_iface(did) { method_iface(did, i) }\n-                      },\n-                    self_sub: none});\n-       }\n-       i += 1u;\n-    }\n-    ret none;\n-}\n+        let ms = *ty::iface_methods(self.tcx(), did);\n+        for ms.eachi {|i, m|\n+            if m.ident != self.m_name { cont; }\n \n-fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n-                       name: ast::ident, ty: ty::t,\n-                       include_private: bool)\n-    -> option<{method_ty: ty::t,\n-               n_tps: uint,\n-               substs: [ty::t],\n-               origin: method_origin,\n-               self_sub: option<ty::t>}> {\n-    let tcx = fcx.ccx.tcx;\n+            let m_fty = ty::mk_fn(self.tcx(), m.fty);\n \n-    #debug[\"lookup_method_inner: expr=%s name=%s ty=%s\",\n-           expr_to_str(expr), name, fcx.ty_to_str(ty)];\n-\n-    // First, see whether this is an interface-bounded parameter\n-    alt ty::get(ty).struct {\n-      ty::ty_param(n, did) {\n-        let mut bound_n = 0u;\n-        for vec::each(*tcx.ty_param_bounds.get(did.node)) {|bound|\n-            alt bound {\n-              ty::bound_iface(t) {\n-                let (iid, tps) = alt check ty::get(t).struct {\n-                  ty::ty_iface(i, tps) { (i, tps) }\n-                };\n-                let ifce_methods = ty::iface_methods(tcx, iid);\n-                alt vec::position(*ifce_methods, {|m| m.ident == name}) {\n-                  some(pos) {\n-                    let m = ifce_methods[pos];\n-                    ret some({method_ty: ty::mk_fn(tcx, {proto: ast::proto_box\n-                                                         with m.fty}),\n-                              n_tps: vec::len(*m.tps),\n-                              substs: tps,\n-                              origin: method_param(iid, pos, n, bound_n),\n-                              self_sub: some(ty)\n-                             });\n-                  }\n-                  _ {}\n-                }\n-                bound_n += 1u;\n-              }\n-              _ {}\n+            if ty::type_has_vars(m_fty) {\n+                self.tcx().sess.span_fatal(\n+                    self.expr.span,\n+                    \"can not call a method that contains a \\\n+                     self type through a boxed iface\");\n             }\n+\n+            if (*m.tps).len() > 0u {\n+                self.tcx().sess.span_fatal(\n+                    self.expr.span,\n+                    \"can not call a generic method through a \\\n+                     boxed iface\");\n+            }\n+\n+            ret some(self.write_mty_from_m(\n+                none, iface_tps, m,\n+                method_iface(did, i)));\n         }\n-      }\n-      ty::ty_iface(did, tps) {\n-        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n-              an_iface(did), name, expr.span, include_private) {\n-           some(r) { ret some(r); }\n-           none {  }\n-        }\n-      }\n-      ty::ty_class(did, tps) {\n-        alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did),\n-                                /* Need to include class tps so that the\n-                                    indices for ty params work out right */\n-                         tps, cls(did), name, expr.span, include_private) {\n-          some(r) { ret some(r); }\n-          none    { }\n+\n+        ret none;\n+    }\n+\n+    fn method_from_class(did: ast::def_id, class_tps: [ty::t])\n+        -> option<method_origin> {\n+\n+        let ms = *ty::iface_methods(self.tcx(), did);\n+\n+        for ms.each {|m|\n+            if m.ident != self.m_name { cont; }\n+\n+            if m.privacy == ast::priv && !self.include_private {\n+                self.tcx().sess.span_fatal(\n+                    self.expr.span,\n+                    \"Call to private method not allowed outside \\\n+                     its defining class\");\n+            }\n+\n+            // look up method named <name>.\n+            let m_declared = ty::lookup_class_method_by_name(\n+                self.tcx(), did, self.m_name, self.expr.span);\n+\n+            ret some(self.write_mty_from_m(\n+                none, class_tps, m,\n+                method_static(m_declared)));\n         }\n-      }\n-      _ {}\n+\n+        ret none;\n     }\n \n-    fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n+    fn ty_from_did(did: ast::def_id) -> ty::t {\n         if did.crate == ast::local_crate {\n-            alt check tcx.items.get(did.node) {\n+            alt check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n-                let mt = ty_of_method(tcx, m_check, m);\n-                ty::mk_fn(tcx, {proto: ast::proto_box with mt.fty})\n+                let mt = ty_of_method(self.tcx(), m_check, m);\n+                ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n               }\n             }\n         } else {\n-            alt check ty::get(csearch::get_type(tcx, did).ty).struct {\n+            alt check ty::get(csearch::get_type(self.tcx(), did).ty).struct {\n               ty::ty_fn(fty) {\n-                ty::mk_fn(tcx, {proto: ast::proto_box with fty})\n+                ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n               }\n             }\n         }\n     }\n \n-    let mut result = none, complained = false;\n-    std::list::iter(fcx.ccx.impl_map.get(expr.id)) {|impls|\n-        if option::is_none(result) {\n+    fn method_from_scope() -> option<method_origin> {\n+        let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n+\n+        for std::list::each(impls_vecs) {|impls|\n+            let mut results = [];\n             for vec::each(*impls) {|im|\n-                alt vec::find(im.methods, {|m| m.ident == name}) {\n-                  some(m) {\n-                    let mut {n_tps, ty: self_ty} = impl_self_ty(tcx, im.did);\n-                    let mut {vars, ty: self_ty} = if n_tps > 0u {\n-                        bind_params(fcx, self_ty, n_tps)\n-                    } else {\n-                        {vars: [], ty: self_ty}\n-                    };\n+                // Check whether this impl has a method with the right name.\n+                for im.methods.find({|m| m.ident == self.m_name}).each {|m|\n+\n+                    // determine the `self` with fresh variables for\n+                    // each parameter:\n+                    let {substs: self_substs, ty: self_ty} =\n+                        impl_self_ty(self.fcx, im.did);\n \n                     // Here \"self\" refers to the callee side...\n-                    //let next_rid = count_region_params(self_ty);\n-                    //self_ty = instantiate_bound_regions(\n-                    //    fcx.ccx.tcx,\n-                    //    ty::re_bound(ty::br_param(next_rid)),\n-                    //    self_ty);\n-                    self_ty = universally_quantify_regions(\n-                        fcx, region_env(), self_ty);\n+                    let self_ty = universally_quantify_regions(\n+                        self.fcx, region_env(), self_ty);\n \n                     // ... and \"ty\" refers to the caller side.\n                     let ty = universally_quantify_regions(\n-                        fcx, region_env(), ty);\n+                        self.fcx, region_env(), self.self_ty);\n \n-                    alt unify::unify(fcx, self_ty, ty) {\n+                    // if we can assign the caller to the callee, that's a\n+                    // potential match.  Collect those in the vector.\n+                    alt unify::unify(self.fcx, self_ty, ty) {\n+                      result::err(_) { /* keep looking */ }\n                       result::ok(_) {\n-                        if option::is_some(result) {\n-                            // FIXME[impl] score specificity?\n-                            if !complained {\n-                                tcx.sess.span_err(expr.span,\n-                                                  \"multiple applicable \\\n-                                                   methods in scope\");\n-                                complained = true;\n-                            }\n-                        } else {\n-                            result = some({\n-                                method_ty: ty_from_did(tcx, m.did),\n-                                n_tps: m.n_tps,\n-                                substs: vars,\n-                                origin: method_static(m.did),\n-                                self_sub: none\n-                            });\n-                        }\n+                        results += [(self_substs, m.n_tps, m.did)];\n                       }\n-                      result::err(_) {}\n                     }\n-                  }\n-                  _ {}\n                 }\n             }\n+\n+            if results.len() >= 1u {\n+                if results.len() > 1u {\n+                    self.tcx().sess.span_err(\n+                        self.expr.span,\n+                        \"multiple applicable methods in scope\");\n+                }\n+\n+                let (self_substs, n_tps, did) = results[0];\n+                let fty = self.ty_from_did(did);\n+                ret some(self.write_mty_from_fty(\n+                    none, self_substs, n_tps, fty,\n+                    method_static(did)));\n+            }\n+        }\n+\n+        ret none;\n+    }\n+\n+    fn write_mty_from_m(self_ty_sub: option<ty::t>,\n+                        self_substs: [ty::t],\n+                        m: ty::method,\n+                        origin: method_origin) -> method_origin {\n+        let tcx = self.fcx.ccx.tcx;\n+\n+        // a bit hokey, but the method unbound has a bare protocol, whereas\n+        // a.b has a protocol like fn@() (perhaps eventually fn&()):\n+        let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n+\n+        ret self.write_mty_from_fty(self_ty_sub, self_substs,\n+                                    (*m.tps).len(), fty, origin);\n+    }\n+\n+    fn write_mty_from_fty(self_ty_sub: option<ty::t>,\n+                          self_substs: [ty::t],\n+                          n_tps_m: uint,\n+                          fty: ty::t,\n+                          origin: method_origin) -> method_origin {\n+\n+        let tcx = self.fcx.ccx.tcx;\n+        let has_self = ty::type_has_vars(fty);\n+\n+        // Here I will use the \"c_\" prefix to refer to the method's\n+        // owner.  You can read it as class, but it may also be an iface.\n+\n+        let n_tps_supplied = self.supplied_tps.len();\n+        let m_substs = {\n+            if n_tps_supplied == 0u {\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else if n_tps_m == 0u {\n+                tcx.sess.span_err(\n+                    self.expr.span,\n+                    \"this method does not take type parameters\");\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else if n_tps_supplied != n_tps_m {\n+                tcx.sess.span_err(\n+                    self.expr.span,\n+                    \"incorrect number of type \\\n+                     parameters given for this method\");\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else {\n+                self.supplied_tps\n+            }\n+        };\n+\n+        let all_substs = self_substs + m_substs;\n+        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n+\n+        // FIXME--this treatment of self and regions seems wrong.  As a rule\n+        // of thumb, one ought to substitute all type parameters at once, and\n+        // we are not doing so here.  The danger you open up has to do with\n+        // the possibility that one of the substs in `all_substs` maps to a\n+        // self type.  Right now I think this is impossible but it may not be\n+        // forever, and it's just sloppy to substitute in multiple steps.\n+        // Probably the self parameter ought to be part of the all_substs.\n+\n+        if has_self && !option::is_none(self_ty_sub) {\n+            let fty = self.fcx.node_ty(self.node_id);\n+            let fty = fixup_self_param(\n+                self.fcx, fty, all_substs, self_ty_sub.get(),\n+                self.expr.span);\n+            self.fcx.write_ty(self.node_id, fty);\n         }\n+\n+        if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n+            let fty = self.fcx.node_ty(self.node_id);\n+            let self_region = region_of(self.fcx, self.expr);\n+            let fty = replace_self_region(self.tcx(), self_region, fty);\n+            self.fcx.write_ty(self.node_id, fty);\n+        }\n+\n+        ret origin;\n     }\n-    result\n }\n \n // Only for fields! Returns <none> for methods>\n@@ -2620,7 +2619,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             // since we don't know them.\n             arg_tys = vec::from_fn(supplied_arg_count) {|_i|\n                 {mode: ast::expl(ast::by_ref),\n-                 ty: next_ty_var(fcx)}\n+                 ty: fcx.next_ty_var()}\n             };\n         }\n \n@@ -2726,7 +2725,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let (if_t, if_bot) =\n             alt elsopt {\n               some(els) {\n-                let if_t = next_ty_var(fcx);\n+                let if_t = fcx.next_ty_var();\n                 let thn_bot = check_block(fcx, thn);\n                 let thn_t = fcx.node_ty(thn.node.id);\n                 demand::simple(fcx, thn.span, if_t, thn_t);\n@@ -2754,7 +2753,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         opname: str, args: [option<@ast::expr>])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n-        alt lookup_method(fcx, op_ex, callee_id, opname, self_t, [], false) {\n+        let lkup = lookup({fcx: fcx,\n+                           expr: op_ex,\n+                           node_id: callee_id,\n+                           m_name: opname,\n+                           self_ty: self_t,\n+                           supplied_tps: [],\n+                           include_private: false});\n+        alt lkup.method() {\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n                 let method_ty = fcx.node_ty(callee_id);\n@@ -2781,7 +2787,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             // result [ML T] where TL <: T and TR <: T.  In other words, the\n             // result type is (generally) the LUB of (TL, TR) and takes the\n             // mutability from the LHS.\n-            let t_var = next_ty_var(fcx);\n+            let t_var = fcx.next_ty_var();\n             let const_vec_t = ty::mk_vec(tcx, {ty: t_var,\n                                                mutbl: ast::m_const});\n             demand::simple(fcx, lhs.span, const_vec_t, lhs_t);\n@@ -2803,7 +2809,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n \n           (_, _) if ty::is_binopable(tcx, lhs_t, op) {\n-            let tvar = next_ty_var(fcx);\n+            let tvar = fcx.next_ty_var();\n             demand::simple(fcx, expr.span, tvar, lhs_t);\n             let rhs_bot = check_expr_with(fcx, rhs, tvar);\n             let rhs_t = alt op {\n@@ -2879,7 +2885,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           ast::expr_vec(args, mutbl) {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev,\n                                                vec::len(args), vst);\n-            let t: ty::t = next_ty_var(fcx);\n+            let t: ty::t = fcx.next_ty_var();\n             for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n           }\n@@ -2916,7 +2922,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_binary(ast::gt, lhs, rhs) |\n       ast::expr_binary(ast::ge, lhs, rhs) {\n         let tcx = fcx.ccx.tcx;\n-        let tvar = next_ty_var(fcx);\n+        let tvar = fcx.next_ty_var();\n         bot |= check_expr_with(fcx, lhs, tvar);\n         bot |= check_expr_with(fcx, rhs, tvar);\n         fcx.write_ty(id, ty::mk_bool(tcx));\n@@ -3098,7 +3104,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           bot = !may_break(body);\n       }\n       ast::expr_alt(discrim, arms, _) {\n-        let pattern_ty = next_ty_var(fcx);\n+        let pattern_ty = fcx.next_ty_var();\n         bot = check_expr_with(fcx, discrim, pattern_ty);\n \n         let parent_region = tcx.region_map.rvalue_to_region.get(discrim.id);\n@@ -3118,7 +3124,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             for arm.pats.each {|p| check_pat(pcx, p, pattern_ty);}\n         }\n         // Now typecheck the blocks.\n-        let mut result_ty = next_ty_var(fcx);\n+        let mut result_ty = fcx.next_ty_var();\n         let mut arm_non_bot = false;\n         for arms.each {|arm|\n             alt arm.guard {\n@@ -3278,7 +3284,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         fcx.write_ty(id, t_1);\n       }\n       ast::expr_vec(args, mutbl) {\n-        let t: ty::t = next_ty_var(fcx);\n+        let t: ty::t = fcx.next_ty_var();\n         for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mutbl: mutbl});\n         fcx.write_ty(id, typ);\n@@ -3394,8 +3400,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         if !handled {\n             let tps = vec::map(tys, {|ty| ast_ty_to_ty_crate(fcx.ccx, ty)});\n-            alt lookup_method(fcx, expr, expr.id, field, expr_t, tps,\n-                              self_ref(fcx, base.id)) {\n+            let lkup = lookup({fcx: fcx,\n+                               expr: expr,\n+                               node_id: expr.id,\n+                               m_name: field,\n+                               self_ty: expr_t,\n+                               supplied_tps: tps,\n+                               include_private: self_ref(fcx, base.id)});\n+            alt lkup.method() {\n               some(origin) {\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n@@ -3406,7 +3418,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n-                fcx.write_ty(id, next_ty_var(fcx));\n+                fcx.write_ty(id, fcx.next_ty_var());\n               }\n             }\n         }\n@@ -3450,7 +3462,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let p_ty = fcx.expr_ty(p);\n \n-        alt lookup_method(fcx, p, alloc_id, \"alloc\", p_ty, [], false) {\n+        let lkup = lookup({fcx: fcx,\n+                           expr: p,\n+                           node_id: alloc_id,\n+                           m_name: \"alloc\",\n+                           self_ty: p_ty,\n+                           supplied_tps: [],\n+                           include_private: false});\n+        alt lkup.method() {\n           some(origin) {\n             fcx.ccx.method_map.insert(alloc_id, origin);\n \n@@ -3511,16 +3530,6 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     }\n }\n \n-fn next_ty_var_id(fcx: @fn_ctxt) -> ty_vid {\n-    let id = *fcx.next_var_id;\n-    *fcx.next_var_id += 1u;\n-    ret ty_vid(id);\n-}\n-\n-fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n-    ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n-}\n-\n fn next_region_var_id(fcx: @fn_ctxt) -> region_vid {\n     let id = *fcx.next_region_var_id;\n     *fcx.next_region_var_id += 1u;\n@@ -3531,11 +3540,6 @@ fn next_region_var(fcx: @fn_ctxt) -> ty::region {\n     ret ty::re_var(next_region_var_id(fcx));\n }\n \n-fn bind_params(fcx: @fn_ctxt, tp: ty::t, count: uint)\n-    -> {vars: [ty::t], ty: ty::t} {\n-    let vars = vec::from_fn(count, {|_i| next_ty_var(fcx)});\n-    {vars: vars, ty: ty::substitute_type_params(fcx.ccx.tcx, vars, tp)}\n-}\n \n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: ast::initializer) -> bool {\n@@ -4175,11 +4179,8 @@ mod vtable {\n                           _ { false }\n                         };\n                         if match {\n-                            let {n_tps, ty: self_ty} =\n-                                impl_self_ty(tcx, im.did);\n-                            let {vars, ty: self_ty} = if n_tps > 0u {\n-                                bind_params(fcx, self_ty, n_tps)\n-                            } else { {vars: [], ty: self_ty} };\n+                            let {substs: vars, ty: self_ty} =\n+                                impl_self_ty(fcx, im.did);\n                             let im_bs =\n                                 ty::lookup_item_type(tcx, im.did).bounds;\n                             alt unify::unify(fcx, ty, self_ty) {"}]}