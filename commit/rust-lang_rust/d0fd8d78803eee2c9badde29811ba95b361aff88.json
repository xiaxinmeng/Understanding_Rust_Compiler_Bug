{"sha": "d0fd8d78803eee2c9badde29811ba95b361aff88", "node_id": "C_kwDOAAsO6NoAKGQwZmQ4ZDc4ODAzZWVlMmM5YmFkZGUyOTgxMWJhOTViMzYxYWZmODg", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-03-31T07:35:17Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-05T06:01:03Z"}, "message": "macros: translatable struct attrs and warnings\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "858c2a206685b2dae7ae21a9769bde2fadd4ab34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858c2a206685b2dae7ae21a9769bde2fadd4ab34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0fd8d78803eee2c9badde29811ba95b361aff88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0fd8d78803eee2c9badde29811ba95b361aff88", "html_url": "https://github.com/rust-lang/rust/commit/d0fd8d78803eee2c9badde29811ba95b361aff88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0fd8d78803eee2c9badde29811ba95b361aff88/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0de7df2048497cd701ee9a88ec44e9ac00e282e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0de7df2048497cd701ee9a88ec44e9ac00e282e", "html_url": "https://github.com/rust-lang/rust/commit/f0de7df2048497cd701ee9a88ec44e9ac00e282e"}], "stats": {"total": 1001, "additions": 727, "deletions": 274}, "files": [{"sha": "336e7a66857082ca6bd51e282cfb2bef34a30273", "filename": "compiler/rustc_error_messages/locales/en-US/diagnostics.ftl", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -1,2 +1,87 @@\n-parser-struct-literal-body-without-path = struct literal body without path\n+parser-struct-literal-body-without-path =\n+    struct literal body without path\n     .suggestion = you might have forgotten to add the struct literal inside the block\n+\n+typeck-field-multiply-specified-in-initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous-use-label = first use of `{$ident}`\n+\n+typeck-unrecognized-atomic-operation =\n+    unrecognized atomic operation function: `{$op}`\n+    .label = unrecognized atomic operation\n+\n+typeck-wrong-number-of-generic-arguments-to-intrinsic =\n+    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n+    .label = expected {$expected} {$descr} {$expected ->\n+        [one] parameter\n+        *[other] parameters\n+    }\n+\n+typeck-unrecognized-intrinsic-function =\n+    unrecognized intrinsic function: `{$name}`\n+    .label = unrecognized intrinsic\n+\n+typeck-lifetimes-or-bounds-mismatch-on-trait =\n+    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n+    .label = lifetimes do not match {$item_kind} in trait\n+    .generics-label = lifetimes in impl do not match this {$item_kind} in trait\n+\n+typeck-drop-impl-on-wrong-item =\n+    the `Drop` trait may only be implemented for structs, enums, and unions\n+    .label = must be a struct, enum, or union\n+\n+typeck-field-already-declared =\n+    field `{$field_name}` is already declared\n+    .label = field already declared\n+    .previous-decl-label = `{$field_name}` first declared here\n+\n+typeck-copy-impl-on-type-with-dtor =\n+    the trait `Copy` may not be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n+\n+typeck-multiple-relaxed-default-bounds =\n+    type parameter has more than one relaxed default bound, only one is supported\n+\n+typeck-copy-impl-on-non-adt =\n+    the trait `Copy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+typeck-trait-object-declared-with-no-traits =\n+    at least one trait is required for an object type\n+\n+typeck-ambiguous-lifetime-bound =\n+    ambiguous lifetime bound, explicit lifetime bound required\n+\n+typeck-assoc-type-binding-not-allowed =\n+    associated type bindings are not allowed here\n+    .label = associated type not allowed here\n+\n+typeck-functional-record-update-on-non-struct =\n+    functional record update syntax requires a struct\n+\n+typeck-typeof-reserved-keyword-used =\n+    `typeof` is a reserved keyword but unimplemented\n+    .label = reserved keyword\n+\n+typeck-return-stmt-outside-of-fn-body =\n+    return statement outside of function body\n+    .encl-body-label = the return is part of this body...\n+    .encl-fn-label = ...not the enclosing function body\n+\n+typeck-yield-expr-outside-of-generator =\n+    yield expression outside of generator literal\n+\n+typeck-struct-expr-non-exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n+\n+typeck-method-call-on-unknown-type =\n+    the type of this value must be known to call a method on a raw pointer on it\n+\n+typeck-value-of-associated-struct-already-specified =\n+    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n+    .label = re-bound here\n+    .previous-bound-label = `{$item_name}` bound here first\n+\n+typeck-address-of-temporary-taken = cannot take address of a temporary\n+    .label = temporary value"}, {"sha": "6a763d4d1404b1e6bc6183a4645c3b6bbf40f5dc", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -261,7 +261,7 @@ pub trait Emitter {\n         message: &'a DiagnosticMessage,\n         args: &'a FluentArgs<'_>,\n     ) -> Cow<'_, str> {\n-        trace!(?message);\n+        trace!(?message, ?args);\n         let (identifier, attr) = match message {\n             DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n@@ -283,7 +283,13 @@ pub trait Emitter {\n         let mut err = vec![];\n         let translated = bundle.format_pattern(value, Some(&args), &mut err);\n         trace!(?translated, ?err);\n-        debug_assert!(err.is_empty());\n+        debug_assert!(\n+            err.is_empty(),\n+            \"identifier: {:?}, args: {:?}, errors: {:?}\",\n+            identifier,\n+            args,\n+            err\n+        );\n         translated\n     }\n "}, {"sha": "c927fcb2109cb95ba6c4c27e537732a8c3d649ca", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -777,6 +777,17 @@ impl Handler {\n         result\n     }\n \n+    /// Construct a builder at the `Warn` level with the `msg` and the `code`.\n+    pub fn struct_warn_with_code(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        let mut result = self.struct_warn(msg);\n+        result.code(code);\n+        result\n+    }\n+\n     /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n     pub fn struct_span_fatal(\n         &self,"}, {"sha": "2693aea9bba8642e5e48206dd1fc38bdda089edb", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -63,9 +63,14 @@ decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_fo\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);\n decl_derive!(\n     [SessionDiagnostic, attributes(\n-        message,\n-        lint,\n+        // struct attributes\n+        warning,\n         error,\n+        // nested parts of struct attributes\n+        code,\n+        slug,\n+        // field attributes\n+        message,\n         label,\n         suggestion,\n         suggestion_short,"}, {"sha": "05c013dcea7594c3c1045875727efbc49753244c", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "modified", "additions": 267, "deletions": 114, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -16,11 +16,11 @@ use std::collections::{BTreeSet, HashMap};\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(SessionDiagnostic)]\n-/// #[code = \"E0505\"]\n-/// #[error = \"cannot move out of {name} because it is borrowed\"]\n+/// #[error(code = \"E0505\", slug = \"move-out-of-borrow-error\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n+///     #[message]\n ///     #[label = \"cannot move out of borrow\"]\n ///     pub span: Span,\n ///     #[label = \"`{ty}` first borrowed here\"]\n@@ -79,13 +79,6 @@ impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n     }\n }\n \n-/// Equivalent to `rustc:errors::diagnostic::DiagnosticId`, except stores the quoted expression to\n-/// initialise the code with.\n-enum DiagnosticId {\n-    Error(proc_macro2::TokenStream),\n-    Lint(proc_macro2::TokenStream),\n-}\n-\n #[derive(Debug)]\n enum SessionDiagnosticDeriveError {\n     SynError(syn::Error),\n@@ -100,7 +93,7 @@ impl SessionDiagnosticDeriveError {\n                 // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n                 // error has already been emitted to the compiler.\n                 quote! {\n-                    unreachable!()\n+                    { unreachable!(); }\n                 }\n             }\n         }\n@@ -152,24 +145,33 @@ impl<'a> SessionDiagnosticDerive<'a> {\n         }\n \n         Self {\n-            builder: SessionDiagnosticDeriveBuilder { diag, sess, fields: fields_map, kind: None },\n+            builder: SessionDiagnosticDeriveBuilder {\n+                diag,\n+                sess,\n+                fields: fields_map,\n+                kind: None,\n+                code: None,\n+                slug: None,\n+            },\n             structure,\n         }\n     }\n+\n     fn into_tokens(self) -> proc_macro2::TokenStream {\n         let SessionDiagnosticDerive { mut structure, mut builder } = self;\n \n         let ast = structure.ast();\n         let attrs = &ast.attrs;\n \n-        let implementation = {\n+        let (implementation, param_ty) = {\n             if let syn::Data::Struct(..) = ast.data {\n                 let preamble = {\n                     let preamble = attrs.iter().map(|attr| {\n                         builder\n                             .generate_structure_code(attr)\n                             .unwrap_or_else(|v| v.to_compile_error())\n                     });\n+\n                     quote! {\n                         #(#preamble)*;\n                     }\n@@ -213,58 +215,94 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                     // it can be referred to by Fluent messages.\n                     if field.attrs.is_empty() {\n                         let diag = &builder.diag;\n-                        let ident = &field_binding.binding;\n+                        let ident = field_binding.ast().ident.as_ref().unwrap();\n                         quote! { #diag.set_arg(stringify!(#ident), #field_binding.into_diagnostic_arg()); }\n                     } else {\n                         quote! {}\n                     }\n                 });\n \n-                // Finally, putting it altogether.\n-                match builder.kind {\n-                    None => {\n-                        span_err(ast.span().unwrap(), \"`code` not specified\")\n-                        .help(\"use the `#[code = \\\"...\\\"]` attribute to set this diagnostic's error code \")\n-                        .emit();\n-                        SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+                let span = ast.span().unwrap();\n+                let (diag, sess) = (&builder.diag, &builder.sess);\n+                let init = match (builder.kind, builder.slug, builder.code) {\n+                    (None, _, _) => {\n+                        span_err(span, \"diagnostic kind not specified\")\n+                            .help(\"use the `#[error(...)]` attribute to create an error\")\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n-                    Some((kind, _)) => match kind {\n-                        DiagnosticId::Lint(_lint) => todo!(),\n-                        DiagnosticId::Error(code) => {\n-                            let (diag, sess) = (&builder.diag, &builder.sess);\n-                            quote! {\n-                                let mut #diag = #sess.struct_err_with_code(\"\", rustc_errors::DiagnosticId::Error(#code));\n-                                #preamble\n-                                match self {\n-                                    #attrs\n-                                }\n-                                match self {\n-                                    #args\n-                                }\n-                                #diag\n-                            }\n+                    (Some((kind, _)), None, _) => {\n+                        span_err(span, \"`slug` not specified\")\n+                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((kind, _)), _, None) => {\n+                        span_err(span, \"`code` not specified\")\n+                            .help(&format!(\"use the `#[{}(code = \\\"...\\\")]` attribute to set this diagnostic's error code\", kind.descr()))\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _)), Some((code, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_err_with_code(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                                rustc_errors::DiagnosticId::Error(#code.to_string())\n+                            );\n                         }\n-                    },\n-                }\n+                    }\n+                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _)), Some((code, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_warn_with_code(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                                rustc_errors::DiagnosticId::Error(#code.to_string())\n+                            );\n+                        }\n+                    }\n+                };\n+\n+                let implementation = quote! {\n+                    #init\n+                    #preamble\n+                    match self {\n+                        #attrs\n+                    }\n+                    match self {\n+                        #args\n+                    }\n+                    #diag\n+                };\n+                let param_ty = match builder.kind {\n+                    Some((SessionDiagnosticKind::Error, _)) => {\n+                        quote! { rustc_errors::ErrorGuaranteed }\n+                    }\n+                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n+                    _ => unreachable!(),\n+                };\n+\n+                (implementation, param_ty)\n             } else {\n                 span_err(\n                     ast.span().unwrap(),\n                     \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n                 )\n                 .emit();\n-                SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+\n+                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n+                (implementation, param_ty)\n             }\n         };\n \n         let sess = &builder.sess;\n         structure.gen_impl(quote! {\n-            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess>\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n                     for @Self\n             {\n                 fn into_diagnostic(\n                     self,\n                     #sess: &'__session_diagnostic_sess rustc_session::Session\n-                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, rustc_errors::ErrorGuaranteed> {\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n                     use rustc_errors::IntoDiagnosticArg;\n                     #implementation\n                 }\n@@ -282,96 +320,208 @@ struct FieldInfo<'a> {\n     span: &'a proc_macro2::Span,\n }\n \n+/// What kind of session diagnostic is being derived - an error or a warning?\n+#[derive(Copy, Clone)]\n+enum SessionDiagnosticKind {\n+    /// `#[error(..)]`\n+    Error,\n+    /// `#[warn(..)]`\n+    Warn,\n+}\n+\n+impl SessionDiagnosticKind {\n+    /// Returns human-readable string corresponding to the kind.\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            SessionDiagnosticKind::Error => \"error\",\n+            SessionDiagnosticKind::Warn => \"warning\",\n+        }\n+    }\n+}\n+\n /// Tracks persistent information required for building up the individual calls to diagnostic\n /// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n /// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n /// double mut borrow later on.\n struct SessionDiagnosticDeriveBuilder<'a> {\n     /// Name of the session parameter that's passed in to the `as_error` method.\n     sess: syn::Ident,\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: syn::Ident,\n \n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: HashMap<String, &'a syn::Field>,\n \n-    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: syn::Ident,\n-\n-    /// Whether this is a lint or an error. This dictates how the diag will be initialised. `Span`\n-    /// stores at what `Span` the kind was first set at (for error reporting purposes, if the kind\n-    /// was multiply specified).\n-    kind: Option<(DiagnosticId, proc_macro2::Span)>,\n+    /// Kind of diagnostic requested via the struct attribute.\n+    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n+    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n+    /// has the actual diagnostic message.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// Error codes are a mandatory part of the struct attribute. Slugs may replace error codes\n+    /// in future but it is desirable to mandate error codes until such a time.\n+    code: Option<(String, proc_macro::Span)>,\n }\n \n impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n+    /// attributes like `#[error(..)#`, such as the diagnostic kind, slug and code.\n+    ///\n+    /// Returns a `proc_macro2::TokenStream` so that the `Err(..)` variant can be transformed into\n+    /// the same type via `to_compile_error`.\n     fn generate_structure_code(\n         &mut self,\n         attr: &syn::Attribute,\n     ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n-        Ok(match attr.parse_meta()? {\n-            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                let formatted_str = self.build_format(&s.value(), attr.span());\n-                let name = attr.path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_str();\n-                match name {\n-                    \"message\" => {\n-                        let diag = &self.diag;\n-                        quote! {\n-                            #diag.set_primary_message(#formatted_str);\n+        let span = attr.span().unwrap();\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+\n+        let nested = match attr.parse_meta()? {\n+            syn::Meta::List(syn::MetaList { nested, .. }) => nested,\n+            syn::Meta::Path(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+            syn::Meta::NameValue(..) => throw_span_err!(\n+                span,\n+                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n+            ),\n+        };\n+\n+        let kind = match name.as_str() {\n+            \"error\" => SessionDiagnosticKind::Error,\n+            \"warning\" => SessionDiagnosticKind::Warn,\n+            other => throw_span_err!(\n+                span,\n+                &format!(\"`#[{}(...)]` is not a valid `SessionDiagnostic` struct attribute\", other)\n+            ),\n+        };\n+        self.set_kind_once(kind, span)?;\n+\n+        for attr in nested {\n+            let span = attr.span().unwrap();\n+            let meta = match attr {\n+                syn::NestedMeta::Meta(meta) => meta,\n+                syn::NestedMeta::Lit(_) => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` struct attribute\",\n+                        name\n+                    )\n+                ),\n+            };\n+\n+            let path = meta.path();\n+            let nested_name = path.segments.last().unwrap().ident.to_string();\n+            match &meta {\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    match nested_name.as_str() {\n+                        \"slug\" => {\n+                            self.set_slug_once(s.value(), s.span().unwrap());\n+                        }\n+                        \"code\" => {\n+                            self.set_code_once(s.value(), s.span().unwrap());\n+                        }\n+                        other => {\n+                            let diag = span_err(\n+                                span,\n+                                &format!(\n+                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                                    name, other\n+                                ),\n+                            );\n+                            diag.emit();\n                         }\n                     }\n-                    attr @ \"error\" | attr @ \"lint\" => {\n-                        self.set_kind_once(\n-                            if attr == \"error\" {\n-                                DiagnosticId::Error(formatted_str)\n-                            } else if attr == \"lint\" {\n-                                DiagnosticId::Lint(formatted_str)\n-                            } else {\n-                                unreachable!()\n-                            },\n-                            s.span(),\n-                        )?;\n-                        // This attribute is only allowed to be applied once, and the attribute\n-                        // will be set in the initialisation code.\n-                        quote! {}\n-                    }\n-                    other => throw_span_err!(\n-                        attr.span().unwrap(),\n+                }\n+                syn::Meta::NameValue(..) => {\n+                    span_err(\n+                        span,\n                         &format!(\n-                            \"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            other\n-                        )\n-                    ),\n+                            \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .help(\"value must be a string\")\n+                    .emit();\n+                }\n+                syn::Meta::Path(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                syn::Meta::List(..) => {\n+                    span_err(\n+                        span,\n+                        &format!(\n+                            \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n+                            name, nested_name\n+                        ),\n+                    )\n+                    .emit();\n                 }\n             }\n-            _ => todo!(\"unhandled meta kind\"),\n-        })\n+        }\n+\n+        Ok(quote! {})\n     }\n \n     #[must_use]\n     fn set_kind_once(\n         &mut self,\n-        kind: DiagnosticId,\n-        span: proc_macro2::Span,\n+        kind: SessionDiagnosticKind,\n+        span: proc_macro::Span,\n     ) -> Result<(), SessionDiagnosticDeriveError> {\n-        if self.kind.is_none() {\n-            self.kind = Some((kind, span));\n-            Ok(())\n-        } else {\n-            let kind_str = |kind: &DiagnosticId| match kind {\n-                DiagnosticId::Lint(..) => \"lint\",\n-                DiagnosticId::Error(..) => \"error\",\n-            };\n+        match self.kind {\n+            None => {\n+                self.kind = Some((kind, span));\n+                Ok(())\n+            }\n+            Some((prev_kind, prev_span)) => {\n+                let existing = prev_kind.descr();\n+                let current = kind.descr();\n+\n+                let msg = if current == existing {\n+                    format!(\"`{}` specified multiple times\", existing)\n+                } else {\n+                    format!(\"`{}` specified when `{}` was already specified\", current, existing)\n+                };\n+                throw_span_err!(span, &msg, |diag| diag\n+                    .span_note(prev_span, \"previously specified here\"));\n+            }\n+        }\n+    }\n \n-            let existing_kind = kind_str(&self.kind.as_ref().unwrap().0);\n-            let this_kind = kind_str(&kind);\n+    fn set_code_once(&mut self, code: String, span: proc_macro::Span) {\n+        match self.code {\n+            None => {\n+                self.code = Some((code, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"`code` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+    }\n \n-            let msg = if this_kind == existing_kind {\n-                format!(\"`{}` specified multiple times\", existing_kind)\n-            } else {\n-                format!(\"`{}` specified when `{}` was already specified\", this_kind, existing_kind)\n-            };\n-            throw_span_err!(span.unwrap(), &msg);\n+    fn set_slug_once(&mut self, slug: String, span: proc_macro::Span) {\n+        match self.slug {\n+            None => {\n+                self.slug = Some((slug, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"`slug` specified multiple times\")\n+                    .span_note(prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n         }\n     }\n \n@@ -413,26 +563,29 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n \n-        // At this point, we need to dispatch based on the attribute key + the\n-        // type.\n         let meta = attr.parse_meta()?;\n         match meta {\n+            syn::Meta::Path(_) => match name {\n+                \"message\" => {\n+                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                        return Ok(quote! {\n+                            #diag.set_span(*#field_binding);\n+                        });\n+                    } else {\n+                        throw_span_err!(\n+                            attr.span().unwrap(),\n+                            \"the `#[message]` attribute can only be applied to fields of type `Span`\"\n+                        );\n+                    }\n+                }\n+                other => throw_span_err!(\n+                    attr.span().unwrap(),\n+                    &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n+                ),\n+            },\n             syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n                 let formatted_str = self.build_format(&s.value(), attr.span());\n                 match name {\n-                    \"message\" => {\n-                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                            return Ok(quote! {\n-                                #diag.set_span(*#field_binding);\n-                                #diag.set_primary_message(#formatted_str);\n-                            });\n-                        } else {\n-                            throw_span_err!(\n-                                attr.span().unwrap(),\n-                                \"the `#[message = \\\"...\\\"]` attribute can only be applied to fields of type `Span`\"\n-                            );\n-                        }\n-                    }\n                     \"label\" => {\n                         if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n                             return Ok(quote! {\n@@ -441,7 +594,7 @@ impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n                         } else {\n                             throw_span_err!(\n                                 attr.span().unwrap(),\n-                                \"The `#[label = ...]` attribute can only be applied to fields of type `Span`\"\n+                                \"the `#[label = ...]` attribute can only be applied to fields of type `Span`\"\n                             );\n                         }\n                     }"}, {"sha": "74c0f67e6332f6686c3c303f00a1638ab03fe4de", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -21,7 +21,7 @@ use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n use rustc_errors::{\n     fallback_fluent_bundle, fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage,\n-    ErrorGuaranteed, FluentBundle, MultiSpan,\n+    EmissionGuarantee, ErrorGuaranteed, FluentBundle, MultiSpan,\n };\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n@@ -209,10 +209,10 @@ pub struct PerfStats {\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n-pub trait SessionDiagnostic<'a> {\n+pub trait SessionDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     /// Write out as a diagnostic out of `sess`.\n     #[must_use]\n-    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, ErrorGuaranteed>;\n+    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, T>;\n }\n \n impl Session {\n@@ -343,6 +343,13 @@ impl Session {\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n+    pub fn struct_warn_with_code(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n+        self.diagnostic().struct_warn_with_code(msg, code)\n+    }\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -409,6 +416,9 @@ impl Session {\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n         err.into_diagnostic(self).emit()\n     }\n+    pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n+        warning.into_diagnostic(self).emit()\n+    }\n     #[inline]\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()"}, {"sha": "20355dfa331ab8fed4aeaf4fcae6cbc854bdf8a6", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -3,9 +3,9 @@ use rustc_macros::SessionDiagnostic;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0062\"]\n+#[error(code = \"E0062\", slug = \"typeck-field-multiply-specified-in-initializer\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n-    #[message = \"field `{ident}` specified more than once\"]\n+    #[message]\n     #[label = \"used more than once\"]\n     pub span: Span,\n     #[label = \"first use of `{ident}`\"]\n@@ -14,19 +14,18 @@ pub struct FieldMultiplySpecifiedInInitializer {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0092\"]\n+#[error(code = \"E0092\", slug = \"typeck-unrecognized-atomic-operation\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n-    #[message = \"unrecognized atomic operation function: `{op}`\"]\n+    #[message]\n     #[label = \"unrecognized atomic operation\"]\n     pub span: Span,\n     pub op: &'a str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0094\"]\n+#[error(code = \"E0094\", slug = \"typeck-wrong-number-of-generic-arguments-to-intrinsic\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n-    #[message = \"intrinsic has wrong number of {descr} \\\n-                         parameters: found {found}, expected {expected}\"]\n+    #[message]\n     #[label = \"expected {expected} {descr} parameter{expected_pluralize}\"]\n     pub span: Span,\n     pub found: usize,\n@@ -36,18 +35,18 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0093\"]\n+#[error(code = \"E0093\", slug = \"typeck-unrecognized-intrinsic-function\")]\n pub struct UnrecognizedIntrinsicFunction {\n-    #[message = \"unrecognized intrinsic function: `{name}`\"]\n+    #[message]\n     #[label = \"unrecognized intrinsic\"]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0195\"]\n+#[error(code = \"E0195\", slug = \"typeck-lifetimes-or-bounds-mismatch-on-trait\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n-    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n+    #[message]\n     #[label = \"lifetimes do not match {item_kind} in trait\"]\n     pub span: Span,\n     #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n@@ -57,89 +56,88 @@ pub struct LifetimesOrBoundsMismatchOnTrait {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0120\"]\n+#[error(code = \"E0120\", slug = \"typeck-drop-impl-on-wrong-item\")]\n pub struct DropImplOnWrongItem {\n-    #[message = \"the `Drop` trait may only be implemented for structs, enums, and unions\"]\n+    #[message]\n     #[label = \"must be a struct, enum, or union\"]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0124\"]\n+#[error(code = \"E0124\", slug = \"typeck-field-already-declared\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n-    #[message = \"field `{field_name}` is already declared\"]\n+    #[message]\n     #[label = \"field already declared\"]\n     pub span: Span,\n     #[label = \"`{field_name}` first declared here\"]\n     pub prev_span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0184\"]\n+#[error(code = \"E0184\", slug = \"typeck-copy-impl-on-type-with-dtor\")]\n pub struct CopyImplOnTypeWithDtor {\n-    #[message = \"the trait `Copy` may not be implemented for this type; the \\\n-                              type has a destructor\"]\n+    #[message]\n     #[label = \"Copy not allowed on types with destructors\"]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0203\"]\n+#[error(code = \"E0203\", slug = \"typeck-multiple-relaxed-default-bounds\")]\n pub struct MultipleRelaxedDefaultBounds {\n-    #[message = \"type parameter has more than one relaxed default bound, only one is supported\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0206\"]\n+#[error(code = \"E0206\", slug = \"typeck-copy-impl-on-non-adt\")]\n pub struct CopyImplOnNonAdt {\n-    #[message = \"the trait `Copy` may not be implemented for this type\"]\n+    #[message]\n     #[label = \"type is not a structure or enumeration\"]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0224\"]\n+#[error(code = \"E0224\", slug = \"typeck-trait-object-declared-with-no-traits\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n-    #[message = \"at least one trait is required for an object type\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0227\"]\n+#[error(code = \"E0227\", slug = \"typeck-ambiguous-lifetime-bound\")]\n pub struct AmbiguousLifetimeBound {\n-    #[message = \"ambiguous lifetime bound, explicit lifetime bound required\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0229\"]\n+#[error(code = \"E0229\", slug = \"typeck-assoc-type-binding-not-allowed\")]\n pub struct AssocTypeBindingNotAllowed {\n-    #[message = \"associated type bindings are not allowed here\"]\n+    #[message]\n     #[label = \"associated type not allowed here\"]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0436\"]\n+#[error(code = \"E0436\", slug = \"typeck-functional-record-update-on-non-struct\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n-    #[message = \"functional record update syntax requires a struct\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0516\"]\n+#[error(code = \"E0516\", slug = \"typeck-typeof-reserved-keyword-used\")]\n pub struct TypeofReservedKeywordUsed {\n-    #[message = \"`typeof` is a reserved keyword but unimplemented\"]\n+    #[message]\n     #[label = \"reserved keyword\"]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0572\"]\n+#[error(code = \"E0572\", slug = \"typeck-return-stmt-outside-of-fn-body\")]\n pub struct ReturnStmtOutsideOfFnBody {\n-    #[message = \"return statement outside of function body\"]\n+    #[message]\n     pub span: Span,\n     #[label = \"the return is part of this body...\"]\n     pub encl_body_span: Option<Span>,\n@@ -148,31 +146,31 @@ pub struct ReturnStmtOutsideOfFnBody {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0627\"]\n+#[error(code = \"E0627\", slug = \"typeck-yield-expr-outside-of-generator\")]\n pub struct YieldExprOutsideOfGenerator {\n-    #[message = \"yield expression outside of generator literal\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0639\"]\n+#[error(code = \"E0639\", slug = \"typeck-struct-expr-non-exhaustive\")]\n pub struct StructExprNonExhaustive {\n-    #[message = \"cannot create non-exhaustive {what} using struct expression\"]\n+    #[message]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0699\"]\n+#[error(code = \"E0699\", slug = \"typeck-method-call-on-unknown-type\")]\n pub struct MethodCallOnUnknownType {\n-    #[message = \"the type of this value must be known to call a method on a raw pointer on it\"]\n+    #[message]\n     pub span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0719\"]\n+#[error(code = \"E0719\", slug = \"typeck-value-of-associated-struct-already-specified\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n-    #[message = \"the value of the associated type `{item_name}` (from trait `{def_path}`) is already specified\"]\n+    #[message]\n     #[label = \"re-bound here\"]\n     pub span: Span,\n     #[label = \"`{item_name}` bound here first\"]\n@@ -182,9 +180,9 @@ pub struct ValueOfAssociatedStructAlreadySpecified {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0745\"]\n+#[error(code = \"E0745\", slug = \"typeck-address-of-temporary-taken\")]\n pub struct AddressOfTemporaryTaken {\n-    #[message = \"cannot take address of a temporary\"]\n+    #[message]\n     #[label = \"temporary value\"]\n     pub span: Span,\n }"}, {"sha": "32248fb01e9108fb02286d61fe6c0af5945ffbd6", "filename": "src/test/ui-fulldeps/session-derive-errors.rs", "status": "modified", "additions": 111, "deletions": 64, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -26,128 +26,176 @@ use rustc_errors::Applicability;\n extern crate rustc_session;\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"hello-world\")]\n struct Hello {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[warning(code = \"E0123\", slug = \"hello-world\")]\n+struct HelloWarn {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n enum SessionDiagnosticOnEnum {\n     Foo,\n     Bar,\n }\n \n #[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n #[error = \"E0123\"]\n-#[label = \"This is in the wrong place\"]\n-//~^ ERROR `#[label = ...]` is not a valid `SessionDiagnostic` struct attribute\n-struct WrongPlace {}\n+//~^ ERROR `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n+struct WrongStructAttrStyle {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[nonsense(code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^^ ERROR diagnostic kind not specified\n+//~^^^ ERROR cannot find attribute `nonsense` in this scope\n+struct InvalidStructAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(\"E0123\")]\n+//~^ ERROR `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n+//~^^ ERROR `slug` not specified\n+struct InvalidLitNestedAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr1 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr2 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+struct InvalidNestedStructAttr3 {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct WrongPlaceField {\n     #[suggestion = \"this is the wrong kind of attribute\"]\n     //~^ ERROR `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n-#[error = \"E0456\"] //~ ERROR `error` specified multiple times\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[error(code = \"E0456\", slug = \"bar\")] //~ ERROR `error` specified multiple times\n struct ErrorSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[error = \"E0123\"]\n-#[lint = \"some_useful_lint\"] //~ ERROR `lint` specified when `error` was already specified\n-struct LintSpecifiedAfterError {}\n+#[error(code = \"E0123\", slug = \"foo\")]\n+#[warning(code = \"E0293\", slug = \"bar\")]\n+//~^ ERROR `warning` specified when `error` was already specified\n+struct WarnSpecifiedAfterError {}\n \n #[derive(SessionDiagnostic)]\n-#[message = \"Some lint message\"]\n-#[error = \"E0123\"]\n-struct LintButHasErrorCode {}\n+#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")] //~ ERROR `code` specified multiple times\n+struct CodeSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-struct ErrorCodeNotProvided {} //~ ERROR `code` not specified\n+#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")] //~ ERROR `slug` specified multiple times\n+struct SlugSpecifiedTwice {}\n \n-// FIXME: Uncomment when emitting lints is supported.\n-/*\n #[derive(SessionDiagnostic)]\n-#[message = \"Hello, world!\"]\n-#[lint = \"clashing_extern_declarations\"]\n-#[lint = \"improper_ctypes\"] // FIXME: ERROR `lint` specified multiple times\n-struct LintSpecifiedTwice {}\n+struct KindNotProvided {} //~ ERROR diagnostic kind not specified\n \n #[derive(SessionDiagnostic)]\n-#[lint = \"Some lint message\"]\n-#[message = \"Some error message\"]\n-#[error = \"E0123\"] // ERROR `error` specified when `lint` was already specified\n-struct ErrorSpecifiedAfterLint {}\n-*/\n+#[error(code = \"E0456\")] //~ ERROR `slug` not specified\n+struct SlugNotProvided {}\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(slug = \"foo\")] //~ ERROR `code` not specified\n+struct CodeNotProvided {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct MessageWrongType {\n+    #[message]\n+    //~^ ERROR `#[message]` attribute can only be applied to fields of type `Span`\n+    foo: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct InvalidPathFieldAttr {\n+    #[nonsense]\n+    //~^ ERROR `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n+    //~^^ ERROR cannot find attribute `nonsense` in this scope\n+    foo: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithField {\n     name: String,\n-    #[message = \"This error has a field, and references {name}\"]\n+    #[label = \"This error has a field, and references {name}\"]\n     span: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithMessageAppliedToField {\n-    #[message = \"this message is applied to a String field\"]\n-    //~^ ERROR the `#[message = \"...\"]` attribute can only be applied to fields of type `Span`\n+    #[label = \"this message is applied to a String field\"]\n+    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n     name: String,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This error has a field, and references {name}\"]\n-//~^ ERROR `name` doesn't refer to a field on this type\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithNonexistentField {\n-    descr: String,\n+    #[label = \"This error has a field, and references {name}\"]\n+    //~^ ERROR `name` doesn't refer to a field on this type\n+    foo: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This is missing a closing brace: {name\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n //~^ ERROR invalid format string: expected `'}'`\n struct ErrorMissingClosingBrace {\n+    #[label = \"This is missing a closing brace: {name\"]\n+    foo: Span,\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"This is missing an opening brace: name}\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n //~^ ERROR invalid format string: unmatched `}`\n struct ErrorMissingOpeningBrace {\n+    #[label = \"This is missing an opening brace: name}\"]\n+    foo: Span,\n     name: String,\n     val: usize,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct LabelOnSpan {\n     #[label = \"See here\"]\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct LabelOnNonSpan {\n     #[label = \"See here\"]\n-    //~^ ERROR The `#[label = ...]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label = ...]` attribute can only be applied to fields of type `Span`\n     id: u32,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct Suggest {\n     #[suggestion(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n     #[suggestion_short(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n@@ -157,85 +205,84 @@ struct Suggest {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithoutCode {\n     #[suggestion(message = \"This is a suggestion\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"This is nonsense\")]\n     //~^ ERROR `nonsense` is not a valid key for `#[suggestion(...)]`\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"This is a suggestion\")]\n     //~^ ERROR `msg` is not a valid key for `#[suggestion(...)]`\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithoutMsg {\n     #[suggestion(code = \"This is suggested code\")]\n     //~^ ERROR missing suggestion message\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithTypesSwapped {\n     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithSpanOnly {\n     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n     suggestion: (Span, Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n     //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n     suggestion: (Applicability, Applicability, Span),\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct WrongKindOfAnnotation {\n     #[label(\"wrong kind of annotation for label\")]\n     //~^ ERROR invalid annotation list `#[label(...)]`\n     z: Span,\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n-#[message = \"Something something else\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct OptionsInErrors {\n     #[label = \"Label message\"]\n     label: Option<Span>,\n@@ -244,11 +291,11 @@ struct OptionsInErrors {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0456\"]\n+#[error(code = \"E0456\", slug = \"foo\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n-    #[message = \"cannot move {ty} out of borrow\"]\n+    #[message]\n     #[label = \"cannot move out of borrow\"]\n     span: Span,\n     #[label = \"`{ty}` first borrowed here\"]\n@@ -258,9 +305,9 @@ struct MoveOutOfBorrowError<'tcx> {\n }\n \n #[derive(SessionDiagnostic)]\n-#[error = \"E0123\"]\n+#[error(code = \"E0123\", slug = \"foo\")]\n struct ErrorWithLifetime<'a> {\n-    #[message = \"Some message that references {name}\"]\n+    #[label = \"Some message that references {name}\"]\n     span: Span,\n     name: &'a str,\n }"}, {"sha": "d10750035257e7d4f7db05f7263589671d9a0dbb", "filename": "src/test/ui-fulldeps/session-derive-errors.stderr", "status": "modified", "additions": 182, "deletions": 44, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/d0fd8d78803eee2c9badde29811ba95b361aff88/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d0fd8d78803eee2c9badde29811ba95b361aff88/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr?ref=d0fd8d78803eee2c9badde29811ba95b361aff88", "patch": "@@ -1,111 +1,237 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n-  --> $DIR/session-derive-errors.rs:34:1\n+  --> $DIR/session-derive-errors.rs:37:1\n    |\n-LL | / #[error = \"E0123\"]\n+LL | / #[error(code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | | enum SessionDiagnosticOnEnum {\n LL | |     Foo,\n LL | |     Bar,\n LL | | }\n    | |_^\n \n-error: `#[label = ...]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:43:1\n+error: `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:46:1\n    |\n-LL | #[label = \"This is in the wrong place\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error = \"E0123\"]\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:51:1\n+   |\n+LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: diagnostic kind not specified\n+  --> $DIR/session-derive-errors.rs:51:1\n+   |\n+LL | / #[nonsense(code = \"E0123\", slug = \"foo\")]\n+LL | |\n+LL | |\n+LL | |\n+LL | | struct InvalidStructAttr {}\n+   | |___________________________^\n+   |\n+   = help: use the `#[error(...)]` attribute to create an error\n+\n+error: `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:58:9\n+   |\n+LL | #[error(\"E0123\")]\n+   |         ^^^^^^^\n+\n+error: `slug` not specified\n+  --> $DIR/session-derive-errors.rs:58:1\n+   |\n+LL | / #[error(\"E0123\")]\n+LL | |\n+LL | |\n+LL | | struct InvalidLitNestedAttr {}\n+   | |______________________________^\n+   |\n+   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n+\n+error: `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:64:9\n+   |\n+LL | #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^\n+\n+error: `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:69:9\n+   |\n+LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:74:9\n+   |\n+LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+  --> $DIR/session-derive-errors.rs:79:9\n+   |\n+LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+   |         ^^^^^^^^^^^^\n+   |\n+   = help: value must be a string\n \n error: `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:50:5\n+  --> $DIR/session-derive-errors.rs:86:5\n    |\n LL |     #[suggestion = \"this is the wrong kind of attribute\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `error` specified multiple times\n-  --> $DIR/session-derive-errors.rs:58:11\n+  --> $DIR/session-derive-errors.rs:93:1\n+   |\n+LL | #[error(code = \"E0456\", slug = \"bar\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:92:1\n    |\n-LL | #[error = \"E0456\"]\n-   |           ^^^^^^^\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `lint` specified when `error` was already specified\n-  --> $DIR/session-derive-errors.rs:64:10\n+error: `warning` specified when `error` was already specified\n+  --> $DIR/session-derive-errors.rs:98:1\n    |\n-LL | #[lint = \"some_useful_lint\"]\n-   |          ^^^^^^^^^^^^^^^^^^\n+LL | #[warning(code = \"E0293\", slug = \"bar\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:97:1\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `code` specified multiple times\n+  --> $DIR/session-derive-errors.rs:103:32\n+   |\n+LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+   |                                ^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:103:16\n+   |\n+LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+   |                ^^^^^^^\n+\n+error: `slug` specified multiple times\n+  --> $DIR/session-derive-errors.rs:107:46\n+   |\n+LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n+   |                                              ^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/session-derive-errors.rs:107:32\n+   |\n+LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n+   |                                ^^^^^\n+\n+error: diagnostic kind not specified\n+  --> $DIR/session-derive-errors.rs:111:1\n+   |\n+LL | struct KindNotProvided {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use the `#[error(...)]` attribute to create an error\n+\n+error: `slug` not specified\n+  --> $DIR/session-derive-errors.rs:114:1\n+   |\n+LL | / #[error(code = \"E0456\")]\n+LL | | struct SlugNotProvided {}\n+   | |_________________________^\n+   |\n+   = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n \n error: `code` not specified\n-  --> $DIR/session-derive-errors.rs:73:1\n+  --> $DIR/session-derive-errors.rs:118:1\n+   |\n+LL | / #[error(slug = \"foo\")]\n+LL | | struct CodeNotProvided {}\n+   | |_________________________^\n    |\n-LL | struct ErrorCodeNotProvided {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use the `#[error(code = \"...\")]` attribute to set this diagnostic's error code\n+\n+error: the `#[message]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:124:5\n+   |\n+LL |     #[message]\n+   |     ^^^^^^^^^^\n+\n+error: `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n+  --> $DIR/session-derive-errors.rs:132:5\n    |\n-   = help: use the `#[code = \"...\"]` attribute to set this diagnostic's error code \n+LL |     #[nonsense]\n+   |     ^^^^^^^^^^^\n \n-error: the `#[message = \"...\"]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/session-derive-errors.rs:101:5\n+error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:149:5\n    |\n-LL |     #[message = \"this message is applied to a String field\"]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label = \"this message is applied to a String field\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/session-derive-errors.rs:108:1\n+  --> $DIR/session-derive-errors.rs:157:5\n    |\n-LL | #[message = \"This error has a field, and references {name}\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label = \"This error has a field, and references {name}\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/session-derive-errors.rs:116:1\n+  --> $DIR/session-derive-errors.rs:163:20\n    |\n LL | #[derive(SessionDiagnostic)]\n    |          ----------------- in this derive macro expansion\n-LL | #[error = \"E0123\"]\n-   |               - because of this opening brace\n-LL | #[message = \"This is missing a closing brace: {name\"]\n-   | ^ expected `'}'` in format string\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |               -    ^ expected `'}'` in format string\n+   |               |\n+   |               because of this opening brace\n    |\n    = note: if you intended to print `{`, you can escape it using `{{`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/session-derive-errors.rs:125:1\n+  --> $DIR/session-derive-errors.rs:173:20\n    |\n LL | #[derive(SessionDiagnostic)]\n    |          ----------------- in this derive macro expansion\n-LL | #[error = \"E0123\"]\n-LL | #[message = \"This is missing an opening brace: name}\"]\n-   | ^ unmatched `}` in format string\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |                    ^ unmatched `}` in format string\n    |\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: The `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/session-derive-errors.rs:144:5\n+error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/session-derive-errors.rs:192:5\n    |\n LL |     #[label = \"See here\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: `nonsense` is not a valid key for `#[suggestion(...)]`\n-  --> $DIR/session-derive-errors.rs:169:18\n+  --> $DIR/session-derive-errors.rs:217:18\n    |\n LL |     #[suggestion(nonsense = \"This is nonsense\")]\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `msg` is not a valid key for `#[suggestion(...)]`\n-  --> $DIR/session-derive-errors.rs:177:18\n+  --> $DIR/session-derive-errors.rs:225:18\n    |\n LL |     #[suggestion(msg = \"This is a suggestion\")]\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing suggestion message\n-  --> $DIR/session-derive-errors.rs:185:7\n+  --> $DIR/session-derive-errors.rs:233:7\n    |\n LL |     #[suggestion(code = \"This is suggested code\")]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: provide a suggestion message using `#[suggestion(message = \"...\")]`\n \n error: wrong field type for suggestion\n-  --> $DIR/session-derive-errors.rs:200:5\n+  --> $DIR/session-derive-errors.rs:248:5\n    |\n LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n LL | |\n@@ -115,26 +241,38 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/session-derive-errors.rs:215:5\n+  --> $DIR/session-derive-errors.rs:263:5\n    |\n LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/session-derive-errors.rs:223:5\n+  --> $DIR/session-derive-errors.rs:271:5\n    |\n LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n error: invalid annotation list `#[label(...)]`\n-  --> $DIR/session-derive-errors.rs:231:7\n+  --> $DIR/session-derive-errors.rs:279:7\n    |\n LL |     #[label(\"wrong kind of annotation for label\")]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 18 previous errors\n+error: cannot find attribute `nonsense` in this scope\n+  --> $DIR/session-derive-errors.rs:51:3\n+   |\n+LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n+   |   ^^^^^^^^\n+\n+error: cannot find attribute `nonsense` in this scope\n+  --> $DIR/session-derive-errors.rs:132:7\n+   |\n+LL |     #[nonsense]\n+   |       ^^^^^^^^\n+\n+error: aborting due to 34 previous errors\n "}]}