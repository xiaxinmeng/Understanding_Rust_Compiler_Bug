{"sha": "2b87f031e79d870f6b148339e21e5c2a3112d4af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODdmMDMxZTc5ZDg3MGY2YjE0ODMzOWUyMWU1YzJhMzExMmQ0YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-31T18:45:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-31T18:45:19Z"}, "message": "Auto merge of #34986 - nikomatsakis:issue-34349, r=arielb1\n\nAvoid writing a temporary closure kind\n\nWe used to write a temporary closure kind into the inference table, but\nthis could lead to obligations being incorrectled resolved before\ninference had completed. This result could then be cached, leading to\nfurther trouble. This patch avoids writing any closure kind until the\ncomputation is complete.\n\nFixes #34349.\n\nr? @arielb1 -- what do you think?", "tree": {"sha": "ed68fddbe6d643688cee083c3ff9b535391a195c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed68fddbe6d643688cee083c3ff9b535391a195c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b87f031e79d870f6b148339e21e5c2a3112d4af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b87f031e79d870f6b148339e21e5c2a3112d4af", "html_url": "https://github.com/rust-lang/rust/commit/2b87f031e79d870f6b148339e21e5c2a3112d4af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b87f031e79d870f6b148339e21e5c2a3112d4af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379ac50809d1ab3616ce9070b36c719076ff2cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/379ac50809d1ab3616ce9070b36c719076ff2cfd", "html_url": "https://github.com/rust-lang/rust/commit/379ac50809d1ab3616ce9070b36c719076ff2cfd"}, {"sha": "63eb4d9114b05695bca2639628019ca61bae7366", "url": "https://api.github.com/repos/rust-lang/rust/commits/63eb4d9114b05695bca2639628019ca61bae7366", "html_url": "https://github.com/rust-lang/rust/commit/63eb4d9114b05695bca2639628019ca61bae7366"}], "stats": {"total": 176, "additions": 123, "deletions": 53}, "files": [{"sha": "18b80a9636b45e0c2d91a605167bb4b127f2df96", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2b87f031e79d870f6b148339e21e5c2a3112d4af", "patch": "@@ -271,10 +271,19 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> Self\n+    {\n+        ExprUseVisitor::with_options(delegate, infcx, mc::MemCategorizationOptions::default())\n+    }\n+\n+    pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n+                        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        options: mc::MemCategorizationOptions)\n+               -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::new(infcx),\n+            mc: mc::MemCategorizationContext::with_options(infcx, options),\n             delegate: delegate\n         }\n     }"}, {"sha": "0bc3c1ae899dd267d235e507c18eaded12278d50", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2b87f031e79d870f6b148339e21e5c2a3112d4af", "patch": "@@ -259,6 +259,18 @@ impl ast_node for hir::Pat {\n #[derive(Copy, Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    options: MemCategorizationOptions,\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct MemCategorizationOptions {\n+    // If true, then when analyzing a closure upvar, if the closure\n+    // has a missing kind, we treat it like a Fn closure. When false,\n+    // we ICE if the closure has a missing kind. Should be false\n+    // except during closure kind inference. It is used by the\n+    // mem-categorization code to be able to have stricter assertions\n+    // (which are always true except during upvar inference).\n+    pub during_closure_kind_inference: bool,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -362,7 +374,16 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext { infcx: infcx }\n+        MemCategorizationContext::with_options(infcx, MemCategorizationOptions::default())\n+    }\n+\n+    pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        options: MemCategorizationOptions)\n+                        -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        MemCategorizationContext {\n+            infcx: infcx,\n+            options: options,\n+        }\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -584,10 +605,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n                           None => {\n-                              span_bug!(\n-                                  span,\n-                                  \"No closure kind for {:?}\",\n-                                  closure_id);\n+                              if !self.options.during_closure_kind_inference {\n+                                  span_bug!(\n+                                      span,\n+                                      \"No closure kind for {:?}\",\n+                                      closure_id);\n+                              }\n+\n+                              // during closure kind inference, we\n+                              // don't know the closure kind yet, but\n+                              // it's ok because we detect that we are\n+                              // accessing an upvar and handle that\n+                              // case specially anyhow. Use Fn\n+                              // arbitrarily.\n+                              self.cat_upvar(id, span, var_id, fn_node_id, ty::ClosureKind::Fn)\n                           }\n                       }\n                   }"}, {"sha": "030491b521d95679e38b0f72cfdc975a7ba468ae", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 44, "deletions": 46, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=2b87f031e79d870f6b148339e21e5c2a3112d4af", "patch": "@@ -47,11 +47,11 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty};\n use rustc::infer::UpvarRegion;\n-use std::collections::HashSet;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::util::nodemap::NodeMap;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -60,9 +60,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze_fn(&self, body: &hir::Block) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_block(body);\n-        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n         adjust.visit_block(body);\n \n         // it's our job to process these.\n@@ -72,9 +71,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze_const(&self, body: &hir::Expr) {\n         let mut seed = SeedBorrowKind::new(self);\n         seed.visit_expr(body);\n-        let closures_with_inferred_kinds = seed.closures_with_inferred_kinds;\n \n-        let mut adjust = AdjustBorrowKind::new(self, &closures_with_inferred_kinds);\n+        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n         adjust.visit_expr(body);\n \n         // it's our job to process these.\n@@ -87,7 +85,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    closures_with_inferred_kinds: HashSet<ast::NodeId>,\n+    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n@@ -106,7 +104,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>) -> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-        SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n+        SeedBorrowKind { fcx: fcx, temp_closure_kinds: NodeMap() }\n     }\n \n     fn check_closure(&mut self,\n@@ -116,11 +114,8 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n     {\n         let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n         if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n-            self.closures_with_inferred_kinds.insert(expr.id);\n-            self.fcx.tables.borrow_mut().closure_kinds\n-                                        .insert(closure_def_id, ty::ClosureKind::Fn);\n-            debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n-                   closure_def_id);\n+            self.temp_closure_kinds.insert(expr.id, ty::ClosureKind::Fn);\n+            debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n         }\n \n         self.fcx.tcx.with_freevars(expr.id, |freevars| {\n@@ -154,14 +149,14 @@ impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n \n struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    closures_with_inferred_kinds: &'a HashSet<ast::NodeId>,\n+    temp_closure_kinds: NodeMap<ty::ClosureKind>,\n }\n \n impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           closures_with_inferred_kinds: &'a HashSet<ast::NodeId>)\n+           temp_closure_kinds: NodeMap<ty::ClosureKind>)\n            -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-        AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n+        AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n     }\n \n     fn analyze_closure(&mut self,\n@@ -176,7 +171,12 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n \n         {\n-            let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n+            let mut euv =\n+                euv::ExprUseVisitor::with_options(self,\n+                                                  self.fcx,\n+                                                  mc::MemCategorizationOptions {\n+                                                      during_closure_kind_inference: true\n+                                                  });\n             euv.walk_fn(decl, body);\n         }\n \n@@ -211,10 +211,14 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n-        // Now we must process and remove any deferred resolutions,\n-        // since we have a concrete closure kind.\n+        // If we are also inferred the closure kind here, update the\n+        // main table and process any deferred resolutions.\n         let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n-        if self.closures_with_inferred_kinds.contains(&id) {\n+        if let Some(&kind) = self.temp_closure_kinds.get(&id) {\n+            self.fcx.tables.borrow_mut().closure_kinds\n+                                        .insert(closure_def_id, kind);\n+            debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n+\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in &mut deferred_call_resolutions {\n@@ -259,7 +263,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn adjust_upvar_borrow_kind_for_consume(&self,\n+    fn adjust_upvar_borrow_kind_for_consume(&mut self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n     {\n@@ -350,7 +354,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&self, cmt: mc::cmt<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: mc::cmt<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\",\n                cmt);\n \n@@ -381,7 +385,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&self,\n+    fn try_adjust_upvar_deref(&mut self,\n                               note: &mc::Note,\n                               borrow_kind: ty::BorrowKind)\n                               -> bool\n@@ -430,7 +434,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     /// moving from left to right as needed (but never right to left).\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n-    fn adjust_upvar_borrow_kind(&self,\n+    fn adjust_upvar_borrow_kind(&mut self,\n                                 upvar_id: ty::UpvarId,\n                                 upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n@@ -460,36 +464,30 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn adjust_closure_kind(&self,\n+    fn adjust_closure_kind(&mut self,\n                            closure_id: ast::NodeId,\n                            new_kind: ty::ClosureKind) {\n         debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?})\",\n                closure_id, new_kind);\n \n-        if !self.closures_with_inferred_kinds.contains(&closure_id) {\n-            return;\n-        }\n-\n-        let closure_def_id = self.fcx.tcx.map.local_def_id(closure_id);\n-        let closure_kinds = &mut self.fcx.tables.borrow_mut().closure_kinds;\n-        let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n+        if let Some(&existing_kind) = self.temp_closure_kinds.get(&closure_id) {\n+            debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+                   closure_id, existing_kind, new_kind);\n \n-        debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n-               closure_id, existing_kind, new_kind);\n-\n-        match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::FnOnce, _) => {\n-                // no change needed\n-            }\n+            match (existing_kind, new_kind) {\n+                (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+                (ty::ClosureKind::FnOnce, _) => {\n+                    // no change needed\n+                }\n \n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-                // new kind is stronger than the old kind\n-                closure_kinds.insert(closure_def_id, new_kind);\n+                (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n+                (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+                (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+                    // new kind is stronger than the old kind\n+                    self.temp_closure_kinds.insert(closure_id, new_kind);\n+                }\n             }\n         }\n     }"}, {"sha": "591753181db1203a8afba29ebacb62fafeee36ea", "filename": "src/test/compile-fail/issue-34349.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b87f031e79d870f6b148339e21e5c2a3112d4af/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34349.rs?ref=2b87f031e79d870f6b148339e21e5c2a3112d4af", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a regression test for a problem encountered around upvar\n+// inference and trait caching: in particular, we were entering a\n+// temporary closure kind during inference, and then caching results\n+// based on that temporary kind, which led to no error being reported\n+// in this particular test.\n+\n+fn main() {\n+    let inc = || {};\n+    inc();\n+\n+    fn apply<F>(f: F) where F: Fn() {\n+        f()\n+    }\n+\n+    let mut farewell = \"goodbye\".to_owned();\n+    let diary = || { //~ ERROR E0525\n+        farewell.push_str(\"!!!\");\n+        println!(\"Then I screamed {}.\", farewell);\n+    };\n+\n+    apply(diary);\n+}"}]}