{"sha": "7f85945b054ff5b991ae1be021882ba15f56d416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmODU5NDViMDU0ZmY1Yjk5MWFlMWJlMDIxODgyYmExNWY1NmQ0MTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-07T19:57:19Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-07T19:57:19Z"}, "message": "rustc: Translate function calls with alias parameters (though the callee can't use them yet)", "tree": {"sha": "748f32d5d7ce31cf53dfbf895efcadc4de9b1b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/748f32d5d7ce31cf53dfbf895efcadc4de9b1b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f85945b054ff5b991ae1be021882ba15f56d416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f85945b054ff5b991ae1be021882ba15f56d416", "html_url": "https://github.com/rust-lang/rust/commit/7f85945b054ff5b991ae1be021882ba15f56d416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f85945b054ff5b991ae1be021882ba15f56d416/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a614acb4dcb94181609add10bc58a4156d4d4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a614acb4dcb94181609add10bc58a4156d4d4d", "html_url": "https://github.com/rust-lang/rust/commit/15a614acb4dcb94181609add10bc58a4156d4d4d"}], "stats": {"total": 57, "additions": 49, "deletions": 8}, "files": [{"sha": "947233a465e48f49eb244fdb4d3a7f7c2dd17101", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f85945b054ff5b991ae1be021882ba15f56d416/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f85945b054ff5b991ae1be021882ba15f56d416/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7f85945b054ff5b991ae1be021882ba15f56d416", "patch": "@@ -1351,6 +1351,10 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     fail;\n }\n \n+// The additional bool returned indicates whether it's mem (that is\n+// represented as an alloca or heap, hence needs a 'load' to be used as an\n+// immediate).\n+\n fn trans_lval(@block_ctxt cx, @ast.expr e) -> tup(result, bool) {\n     alt (e.node) {\n         case (ast.expr_name(?n, ?dopt, _)) {\n@@ -1396,20 +1400,56 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n }\n \n \n-impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es)\n+impure fn trans_args(@block_ctxt cx, &vec[@ast.expr] es, @typeck.ty fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n \n+    let vec[typeck.arg] args = vec();   // FIXME: typestate bug\n+    alt (fn_ty.struct) {\n+        case (typeck.ty_fn(?a, _)) { args = a; }\n+        case (_) { fail; }\n+    }\n+\n+    auto i = 0u;\n     for (@ast.expr e in es) {\n-        auto res = trans_expr(bcx, e);\n-        // Until here we've been treating structures by pointer;\n-        // we are now passing it as an arg, so need to load it.\n+        auto mode = args.(i).mode;\n+\n+        auto re;\n         if (typeck.type_is_structural(typeck.expr_ty(e))) {\n-            res.val = res.bcx.build.Load(res.val);\n+            re = trans_expr(bcx, e);\n+            if (mode == ast.val) {\n+                // Until here we've been treating structures by pointer;\n+                // we are now passing it as an arg, so need to load it.\n+                re.val = re.bcx.build.Load(re.val);\n+            }\n+        } else {\n+            if (mode == ast.alias) {\n+                let tup(result, bool /* is a pointer? */) pair;\n+                if (typeck.is_lval(e)) {\n+                    pair = trans_lval(bcx, e);\n+                } else {\n+                    pair = tup(trans_expr(bcx, e), false);\n+                }\n+\n+                if (!pair._1) {\n+                    // Have to synthesize a pointer here...\n+                    auto llty = val_ty(pair._0.val);\n+                    auto llptr = pair._0.bcx.build.Alloca(llty);\n+                    pair._0.bcx.build.Store(pair._0.val, llptr);\n+                    re = res(pair._0.bcx, llptr);\n+                } else {\n+                    re = pair._0;\n+                }\n+            } else {\n+                re = trans_expr(bcx, e);\n+            }\n         }\n-        vs += res.val;\n-        bcx = res.bcx;\n+\n+        vs += re.val;\n+        bcx = re.bcx;\n+\n+        i += 1u;\n     }\n \n     ret tup(bcx, vs);\n@@ -1419,7 +1459,8 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                      vec[@ast.expr] args) -> result {\n     auto f_res = trans_lval(cx, f);\n     check (! f_res._1);\n-    auto args_res = trans_args(f_res._0.bcx, args);\n+    auto fn_ty = typeck.expr_ty(f);\n+    auto args_res = trans_args(f_res._0.bcx, args, fn_ty);\n     ret res(args_res._0,\n             args_res._0.build.FastCall(f_res._0.val, args_res._1));\n }"}]}