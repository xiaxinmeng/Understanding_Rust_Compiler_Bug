{"sha": "998f2ae7627053a9363a05a1ab79359882dce39f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5OGYyYWU3NjI3MDUzYTkzNjNhMDVhMWFiNzkzNTk4ODJkY2UzOWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-20T19:02:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-20T19:02:41Z"}, "message": "remove job tokens", "tree": {"sha": "6be2e60ebae8c03d117edec200aa942d810b3e31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6be2e60ebae8c03d117edec200aa942d810b3e31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/998f2ae7627053a9363a05a1ab79359882dce39f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/998f2ae7627053a9363a05a1ab79359882dce39f", "html_url": "https://github.com/rust-lang/rust/commit/998f2ae7627053a9363a05a1ab79359882dce39f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/998f2ae7627053a9363a05a1ab79359882dce39f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4b0d3cd56ab68f4fa23f7c1f6c76f7f6148153e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b0d3cd56ab68f4fa23f7c1f6c76f7f6148153e", "html_url": "https://github.com/rust-lang/rust/commit/c4b0d3cd56ab68f4fa23f7c1f6c76f7f6148153e"}], "stats": {"total": 127, "additions": 61, "deletions": 66}, "files": [{"sha": "4cfb681d87519d7da99d74e2e32e7e575a04caa3", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=998f2ae7627053a9363a05a1ab79359882dce39f", "patch": "@@ -148,14 +148,14 @@ impl AnalysisImpl {\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.root(file_id).lines(file_id)\n     }\n-    pub fn world_symbols(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n+    pub fn world_symbols(&self, query: Query) -> Vec<(FileId, FileSymbol)> {\n         let mut buf = Vec::new();\n         if query.libs {\n             self.data.libs.iter().for_each(|it| it.symbols(&mut buf));\n         } else {\n             self.data.root.symbols(&mut buf);\n         }\n-        query.search(&buf, token)\n+        query.search(&buf)\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let root = self.root(file_id);\n@@ -205,7 +205,6 @@ impl AnalysisImpl {\n         &self,\n         file_id: FileId,\n         offset: TextUnit,\n-        token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n         let module_tree = root.module_tree();\n@@ -227,7 +226,7 @@ impl AnalysisImpl {\n                 return vec;\n             } else {\n                 // If that fails try the index based approach.\n-                return self.index_resolve(name_ref, token);\n+                return self.index_resolve(name_ref);\n             }\n         }\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n@@ -258,7 +257,7 @@ impl AnalysisImpl {\n         vec![]\n     }\n \n-    pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit, _token: &JobToken) -> Vec<(FileId, TextRange)> {\n+    pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit) -> Vec<(FileId, TextRange)> {\n         let root = self.root(file_id);\n         let file = root.syntax(file_id);\n         let syntax = file.syntax();\n@@ -380,7 +379,6 @@ impl AnalysisImpl {\n         &self,\n         file_id: FileId,\n         offset: TextUnit,\n-        token: &JobToken,\n     ) -> Option<(FnDescriptor, Option<usize>)> {\n         let root = self.root(file_id);\n         let file = root.syntax(file_id);\n@@ -391,7 +389,7 @@ impl AnalysisImpl {\n         let name_ref = calling_node.name_ref()?;\n \n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-        let file_symbols = self.index_resolve(name_ref, token);\n+        let file_symbols = self.index_resolve(name_ref);\n         for (_, fs) in file_symbols {\n             if fs.kind == FN_DEF {\n                 if let Some(fn_def) = find_node_at_offset(syntax, fs.node_range.start()) {\n@@ -442,12 +440,12 @@ impl AnalysisImpl {\n         None\n     }\n \n-    fn index_resolve(&self, name_ref: ast::NameRef, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n+    fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();\n         query.limit(4);\n-        self.world_symbols(query, token)\n+        self.world_symbols(query)\n     }\n \n     fn resolve_module("}, {"sha": "7e9798c29edadbca1d75ff29a593e133a5e295db", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=998f2ae7627053a9363a05a1ab79359882dce39f", "patch": "@@ -219,47 +219,46 @@ impl Analysis {\n         let file = self.imp.file_syntax(file_id);\n         ra_editor::file_structure(&file)\n     }\n-    pub fn symbol_search(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n-        self.imp.world_symbols(query, token)\n+    pub fn symbol_search(&self, query: Query) -> Vec<(FileId, FileSymbol)> {\n+        self.imp.world_symbols(query)\n     }\n     pub fn approximately_resolve_symbol(\n         &self,\n         file_id: FileId,\n-        offset: TextUnit,\n-        token: &JobToken,\n+        offset: TextUnit\n     ) -> Vec<(FileId, FileSymbol)> {\n         self.imp\n-            .approximately_resolve_symbol(file_id, offset, token)\n+            .approximately_resolve_symbol(file_id, offset)\n     }\n-    pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit, token: &JobToken) -> Vec<(FileId, TextRange)> {\n-        self.imp.find_all_refs(file_id, offset, token)\n+    pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit, ) -> Vec<(FileId, TextRange)> {\n+        self.imp.find_all_refs(file_id, offset)\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         self.imp.parent_module(file_id)\n     }\n-    pub fn crate_for(&self, file_id: FileId) -> Vec<CrateId> {\n-        self.imp.crate_for(file_id)\n+    pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n+        Ok(self.imp.crate_for(file_id))\n     }\n-    pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.imp.crate_root(crate_id)\n+    pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n+        Ok(self.imp.crate_root(crate_id))\n     }\n-    pub fn runnables(&self, file_id: FileId) -> Vec<Runnable> {\n+    pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n         let file = self.imp.file_syntax(file_id);\n-        ra_editor::runnables(&file)\n+        Ok(ra_editor::runnables(&file))\n     }\n-    pub fn highlight(&self, file_id: FileId) -> Vec<HighlightedRange> {\n+    pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n         let file = self.imp.file_syntax(file_id);\n-        ra_editor::highlight(&file)\n+        Ok(ra_editor::highlight(&file))\n     }\n-    pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n+    pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let file = self.imp.file_syntax(file_id);\n-        ra_editor::scope_completion(&file, offset)\n+        Ok(ra_editor::scope_completion(&file, offset))\n     }\n-    pub fn assists(&self, file_id: FileId, range: TextRange) -> Vec<SourceChange> {\n-        self.imp.assists(file_id, range)\n+    pub fn assists(&self, file_id: FileId, range: TextRange) -> Cancelable<Vec<SourceChange>> {\n+        Ok(self.imp.assists(file_id, range))\n     }\n-    pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n-        self.imp.diagnostics(file_id)\n+    pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n+        Ok(self.imp.diagnostics(file_id))\n     }\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n         let file = self.imp.file_syntax(file_id);\n@@ -270,9 +269,8 @@ impl Analysis {\n         &self,\n         file_id: FileId,\n         offset: TextUnit,\n-        token: &JobToken,\n     ) -> Option<(FnDescriptor, Option<usize>)> {\n-        self.imp.resolve_callable(file_id, offset, token)\n+        self.imp.resolve_callable(file_id, offset)\n     }\n }\n "}, {"sha": "19f9ea47d76d19d963e1da754851c31287d78d34", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=998f2ae7627053a9363a05a1ab79359882dce39f", "patch": "@@ -1,4 +1,4 @@\n-use crate::{FileId, JobToken, Query};\n+use crate::{FileId, Query};\n use fst::{self, Streamer};\n use ra_editor::{file_symbols, FileSymbol};\n use ra_syntax::{\n@@ -59,7 +59,6 @@ impl Query {\n     pub(crate) fn search(\n         self,\n         indices: &[Arc<SymbolIndex>],\n-        token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n@@ -69,7 +68,7 @@ impl Query {\n         let mut stream = op.union();\n         let mut res = Vec::new();\n         while let Some((_, indexed_values)) = stream.next() {\n-            if res.len() >= self.limit || token.is_canceled() {\n+            if res.len() >= self.limit {\n                 break;\n             }\n             for indexed_value in indexed_values {"}, {"sha": "9e76a51c1d4fd5722c40a91eaa2f19fd87349e02", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/998f2ae7627053a9363a05a1ab79359882dce39f/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=998f2ae7627053a9363a05a1ab79359882dce39f", "patch": "@@ -161,7 +161,7 @@ pub fn handle_document_symbol(\n pub fn handle_workspace_symbol(\n     world: ServerWorld,\n     params: req::WorkspaceSymbolParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<Vec<SymbolInformation>>> {\n     let all_symbols = params.query.contains(\"#\");\n     let libs = params.query.contains(\"*\");\n@@ -181,22 +181,21 @@ pub fn handle_workspace_symbol(\n         q.limit(128);\n         q\n     };\n-    let mut res = exec_query(&world, query, &token)?;\n+    let mut res = exec_query(&world, query)?;\n     if res.is_empty() && !all_symbols {\n         let mut query = Query::new(params.query);\n         query.limit(128);\n-        res = exec_query(&world, query, &token)?;\n+        res = exec_query(&world, query)?;\n     }\n \n     return Ok(Some(res));\n \n     fn exec_query(\n         world: &ServerWorld,\n         query: Query,\n-        token: &JobToken,\n     ) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for (file_id, symbol) in world.analysis().symbol_search(query, token) {\n+        for (file_id, symbol) in world.analysis().symbol_search(query) {\n             let line_index = world.analysis().file_line_index(file_id);\n             let info = SymbolInformation {\n                 name: symbol.name.to_string(),\n@@ -214,15 +213,15 @@ pub fn handle_workspace_symbol(\n pub fn handle_goto_definition(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n     let mut res = Vec::new();\n     for (file_id, symbol) in world\n         .analysis()\n-        .approximately_resolve_symbol(file_id, offset, &token)\n+        .approximately_resolve_symbol(file_id, offset)\n     {\n         let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n@@ -255,14 +254,14 @@ pub fn handle_runnables(\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.map(|it| it.conv_with(&line_index));\n     let mut res = Vec::new();\n-    for runnable in world.analysis().runnables(file_id) {\n+    for runnable in world.analysis().runnables(file_id)? {\n         if let Some(offset) = offset {\n             if !contains_offset_nonstrict(runnable.range, offset) {\n                 continue;\n             }\n         }\n \n-        let args = runnable_args(&world, file_id, &runnable.kind);\n+        let args = runnable_args(&world, file_id, &runnable.kind)?;\n \n         let r = req::Runnable {\n             range: runnable.range.conv_with(&line_index),\n@@ -282,9 +281,9 @@ pub fn handle_runnables(\n     }\n     return Ok(res);\n \n-    fn runnable_args(world: &ServerWorld, file_id: FileId, kind: &RunnableKind) -> Vec<String> {\n-        let spec = if let Some(&crate_id) = world.analysis().crate_for(file_id).first() {\n-            let file_id = world.analysis().crate_root(crate_id);\n+    fn runnable_args(world: &ServerWorld, file_id: FileId, kind: &RunnableKind) -> Result<Vec<String>> {\n+        let spec = if let Some(&crate_id) = world.analysis().crate_for(file_id)?.first() {\n+            let file_id = world.analysis().crate_root(crate_id)?;\n             let path = world.path_map.get_path(file_id);\n             world\n                 .workspaces\n@@ -319,7 +318,7 @@ pub fn handle_runnables(\n                 }\n             }\n         }\n-        res\n+        Ok(res)\n     }\n \n     fn spec_args(pkg_name: &str, tgt_name: &str, tgt_kind: TargetKind, buf: &mut Vec<String>) {\n@@ -356,7 +355,7 @@ pub fn handle_decorations(\n     _token: JobToken,\n ) -> Result<Vec<Decoration>> {\n     let file_id = params.try_conv_with(&world)?;\n-    Ok(highlight(&world, file_id))\n+    highlight(&world, file_id)\n }\n \n pub fn handle_completion(\n@@ -367,7 +366,7 @@ pub fn handle_completion(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n-    let items = match world.analysis().completions(file_id, offset) {\n+    let items = match world.analysis().completions(file_id, offset)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -427,7 +426,7 @@ pub fn handle_folding_range(\n pub fn handle_signature_help(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<req::SignatureHelp>> {\n     use languageserver_types::{ParameterInformation, SignatureInformation};\n \n@@ -436,7 +435,7 @@ pub fn handle_signature_help(\n     let offset = params.position.conv_with(&line_index);\n \n     if let Some((descriptor, active_param)) =\n-        world.analysis().resolve_callable(file_id, offset, &token)\n+        world.analysis().resolve_callable(file_id, offset)\n     {\n         let parameters: Vec<ParameterInformation> = descriptor\n             .params\n@@ -466,15 +465,15 @@ pub fn handle_signature_help(\n pub fn handle_prepare_rename(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<PrepareRenameResponse>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n \n     // We support renaming references like handle_rename does.\n     // In the future we may want to reject the renaming of things like keywords here too.\n-    let refs = world.analysis().find_all_refs(file_id, offset, &token);\n+    let refs = world.analysis().find_all_refs(file_id, offset);\n     if refs.is_empty() {\n         return Ok(None);\n     }\n@@ -488,7 +487,7 @@ pub fn handle_prepare_rename(\n pub fn handle_rename(\n     world: ServerWorld,\n     params: RenameParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<WorkspaceEdit>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n@@ -498,7 +497,7 @@ pub fn handle_rename(\n         return Ok(None);\n     }\n \n-    let refs = world.analysis().find_all_refs(file_id, offset, &token);\n+    let refs = world.analysis().find_all_refs(file_id, offset);\n     if refs.is_empty() {\n         return Ok(None);\n     }\n@@ -525,13 +524,13 @@ pub fn handle_rename(\n pub fn handle_references(\n     world: ServerWorld,\n     params: req::ReferenceParams,\n-    token: JobToken,\n+    _token: JobToken,\n ) -> Result<Option<Vec<Location>>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n \n-    let refs = world.analysis().find_all_refs(file_id, offset, &token);\n+    let refs = world.analysis().find_all_refs(file_id, offset);\n \n     Ok(Some(refs.into_iter()\n         .filter_map(|r| to_location(r.0, r.1, &world, &line_index).ok())\n@@ -547,10 +546,10 @@ pub fn handle_code_action(\n     let line_index = world.analysis().file_line_index(file_id);\n     let range = params.range.conv_with(&line_index);\n \n-    let assists = world.analysis().assists(file_id, range).into_iter();\n+    let assists = world.analysis().assists(file_id, range)?.into_iter();\n     let fixes = world\n         .analysis()\n-        .diagnostics(file_id)\n+        .diagnostics(file_id)?\n         .into_iter()\n         .filter_map(|d| Some((d.range, d.fix?)))\n         .filter(|(range, _fix)| contains_offset_nonstrict(*range, range.start()))\n@@ -579,7 +578,7 @@ pub fn publish_diagnostics(\n     let line_index = world.analysis().file_line_index(file_id);\n     let diagnostics = world\n         .analysis()\n-        .diagnostics(file_id)\n+        .diagnostics(file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n             range: d.range.conv_with(&line_index),\n@@ -600,19 +599,20 @@ pub fn publish_decorations(\n     let uri = world.file_id_to_uri(file_id)?;\n     Ok(req::PublishDecorationsParams {\n         uri,\n-        decorations: highlight(&world, file_id),\n+        decorations: highlight(&world, file_id)?,\n     })\n }\n \n-fn highlight(world: &ServerWorld, file_id: FileId) -> Vec<Decoration> {\n+fn highlight(world: &ServerWorld, file_id: FileId) -> Result<Vec<Decoration>> {\n     let line_index = world.analysis().file_line_index(file_id);\n-    world\n+    let res = world\n         .analysis()\n-        .highlight(file_id)\n+        .highlight(file_id)?\n         .into_iter()\n         .map(|h| Decoration {\n             range: h.range.conv_with(&line_index),\n             tag: h.tag,\n         })\n-        .collect()\n+        .collect();\n+    Ok(res)\n }"}]}