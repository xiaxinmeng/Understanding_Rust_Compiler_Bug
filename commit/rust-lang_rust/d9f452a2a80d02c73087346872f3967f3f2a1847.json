{"sha": "d9f452a2a80d02c73087346872f3967f3f2a1847", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZjQ1MmEyYTgwZDAyYzczMDg3MzQ2ODcyZjM5NjdmM2YyYTE4NDc=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-23T04:06:22Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-23T04:07:20Z"}, "message": "Some work on supporting forwarding slots in vtables (issue #539).", "tree": {"sha": "7a9882daf05d655f46721f8b800b182a1178b6f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a9882daf05d655f46721f8b800b182a1178b6f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9f452a2a80d02c73087346872f3967f3f2a1847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f452a2a80d02c73087346872f3967f3f2a1847", "html_url": "https://github.com/rust-lang/rust/commit/d9f452a2a80d02c73087346872f3967f3f2a1847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9f452a2a80d02c73087346872f3967f3f2a1847/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "523a0884511e11fa686badfca7c1aa7445761d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/523a0884511e11fa686badfca7c1aa7445761d7e", "html_url": "https://github.com/rust-lang/rust/commit/523a0884511e11fa686badfca7c1aa7445761d7e"}], "stats": {"total": 112, "additions": 70, "deletions": 42}, "files": [{"sha": "1b85fa5b46b550eb525bf3960814a671d5fc9195", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d9f452a2a80d02c73087346872f3967f3f2a1847/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f452a2a80d02c73087346872f3967f3f2a1847/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d9f452a2a80d02c73087346872f3967f3f2a1847", "patch": "@@ -6519,17 +6519,20 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n // itself.\n fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n                   &vec[ast::ty_param] ty_params, ast::node_id oid,\n-                  ast::node_id id) -> result {\n+                  ast::node_id type_id) -> result {\n \n     // Right now, we're assuming that anon objs don't take ty params, even\n     // though the AST supports it.  It's nonsensical to write an expression\n     // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n-    // nevertheless, such an expression will parse.  FIXME for the future:\n-    // support typarams (issue #n).\n+    // nevertheless, such an expression will parse.  Idea for the future:\n+    // support typarams.\n \n     assert (vec::len(ty_params) == 0u);\n     auto ccx = bcx.fcx.lcx.ccx;\n \n+    // Fields.\n+    // FIXME (part of issue #538): Where do we fill in the field *values* from\n+    // the outer object?\n     let vec[ast::anon_obj_field] additional_fields = [];\n     let vec[result] additional_field_vals = [];\n     let vec[ty::t] additional_field_tys = [];\n@@ -6544,63 +6547,86 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         }\n     }\n \n-    // If with_obj (the object being extended) exists, translate it, producing\n-    // a result.\n-    let option::t[result] with_obj_val = none;\n-    let ty::t with_obj_ty = ty::mk_type(ccx.tcx);\n-    alt (anon_obj.with_obj) {\n-        case (none) { }\n-        case (some(?e)) {\n-            // Translating with_obj returns a ValueRef (pointer to a 2-word\n-            // value) wrapped in a result.\n-            with_obj_val  = some[result](trans_expr(bcx, e));\n-            with_obj_ty = ty::expr_ty(ccx.tcx, e);\n-        }\n-    }\n-    // FIXME (part of issue #538): much of the following code is copypasta\n-    // from trans_obj for translating the anonymous wrapper object.\n-    // Eventually we might want to abstract this code out of trans_anon_obj\n-    // and trans_obj.\n+    // Get the type of the eventual entire anonymous object, possibly with\n+    // extensions.\n+    auto outer_obj_ty = ty::node_id_to_type(ccx.tcx, type_id);\n+    auto llouter_obj_ty = type_of(ccx, sp, outer_obj_ty);\n \n-    auto self_ty = ty::node_id_to_type(ccx.tcx, id);\n-    auto llself_ty = type_of(ccx, sp, self_ty);\n     // Allocate the object that we're going to return.  It's a two-word pair\n     // containing a vtable pointer and a body pointer.\n+    auto pair = alloca(bcx, llouter_obj_ty);\n \n-    auto pair = alloca(bcx, llself_ty);\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-\n     auto pair_vtbl =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     auto pair_box =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n-    // Make a vtable for the outer object.  create_vtbl() wants an ast::_obj\n-    // and all we have is an ast::anon_obj, so we need to roll our own.\n \n-    fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) -> ast::obj_field {\n+    // Create a vtable for the anonymous object.\n+\n+    // create_vtbl() wants an ast::_obj and all we have is an ast::anon_obj,\n+    // so we need to roll our own.\n+    fn anon_obj_field_to_obj_field(&ast::anon_obj_field f) \n+        -> ast::obj_field {\n         ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n     }\n     let ast::_obj wrapper_obj = rec(\n-        fields = vec::map(anon_obj_field_to_obj_field, additional_fields),\n+        fields = vec::map(anon_obj_field_to_obj_field, \n+                          additional_fields),\n         methods = anon_obj.methods,\n         dtor = none[@ast::method]);\n-    auto vtbl = create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n-                            ty_params);\n \n-    bcx.build.Store(vtbl, pair_vtbl);\n-    // FIXME (part of issue #538): Where do we fill in the field *values* from\n-    // the outer object?\n \n-    // FIXME (part of issue #539): This vtable needs to contain \"forwarding\n-    // slots\" for the methods that exist in the with_obj, as well.  How do we\n-    // do that?\n+    // If with_obj (the object being extended) exists, translate it, producing\n+    // a result.\n+    let option::t[result] with_obj_val = none;\n+    let ty::t with_obj_ty = ty::mk_type(ccx.tcx);\n+    let TypeRef llwith_obj_ty;\n+    auto vtbl;\n+    alt (anon_obj.with_obj) {\n+        case (none) { \n+            // If there's no with_obj -- that is, if we aren't extending our\n+            // object with any fields -- then we just pass the outer object to\n+            // create_vtbl().  This vtable won't need to have any forwarding\n+            // slots.\n+            vtbl = create_vtbl(bcx.fcx.lcx, llouter_obj_ty, outer_obj_ty,\n+                               wrapper_obj, ty_params, none);\n+        }\n+        case (some(?e)) {\n+            // Translating with_obj returns a ValueRef (pointer to a 2-word\n+            // value) wrapped in a result.\n+            with_obj_val  = some[result](trans_expr(bcx, e));\n+\n+            // TODO: What makes more sense to get the type of an expr --\n+            // calling ty::expr_ty(ccx.tcx, e) on it or calling\n+            // ty::node_id_to_type(ccx.tcx, id) on its id?\n+            with_obj_ty = ty::expr_ty(ccx.tcx, e);\n+            //with_obj_ty = ty::node_id_to_type(ccx.tcx, e.id);\n+\n+            llwith_obj_ty = type_of(ccx, sp, with_obj_ty);\n+\n+            // If there's a with_obj, we pass it as the main argument to\n+            // create_vtbl(), but we're also passing along the additional\n+            // methods as the last argument.  Part of what create_vtbl() will\n+            // do is take the set difference of methods defined on the\n+            // original and methods being added.  For every method defined on\n+            // the original that does *not* have one with a matching name and\n+            // type being added, we'll need to create a forwarding slot.  And,\n+            // of course, we need to create a normal vtable entry for every\n+            // method being added.\n+            vtbl = create_vtbl(bcx.fcx.lcx, llwith_obj_ty, with_obj_ty,\n+                               wrapper_obj, ty_params, \n+                               some(anon_obj.methods));\n+        }\n+    }\n+\n+    bcx.build.Store(vtbl, pair_vtbl);\n \n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, fields, and a pointer to our with_obj.\n-\n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n \n     if (vec::len[ast::ty_param](ty_params) == 0u &&\n@@ -7330,11 +7356,13 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     finish_fn(fcx, lltop);\n }\n \n-\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n-               &ast::_obj ob, &vec[ast::ty_param] ty_params) -> ValueRef {\n+               &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+               option::t[vec[@ast::method]] additional_methods) -> ValueRef {\n+    // FIXME (issue #539): Implement forwarding slots.\n+    \n     auto dtor = C_null(T_ptr(T_i8()));\n     alt (ob.dtor) {\n         case (some(?d)) {\n@@ -7364,10 +7392,10 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn =\n             decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n-        // Every method on an object gets its def_id inserted into the\n+\n+        // Every method on an object gets its node_id inserted into the\n         // crate-wide item_ids map, together with the ValueRef that points to\n         // where that method's definition will be in the executable.\n-\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n         trans_fn(mcx, m.span, m.node.meth, llfn,\n@@ -7459,7 +7487,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n \n-    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n+    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params, none);\n     bcx.build.Store(vtbl, pair_vtbl);\n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,"}]}