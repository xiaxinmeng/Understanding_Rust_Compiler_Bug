{"sha": "21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZGFlOGUxZTA5MTZhZmQyZjc4OWEyZjFhZmZkZmU1ODBkOWNhMGU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-03T23:13:35Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:21Z"}, "message": "More fallout from removing FromIterator on ~[T]\n\nA few methods in slice that used to return ~[T] now return Vec<T>:\n\n- VectorVector.concat/connect_vec() returns Vec<T>\n- slice::unzip() returns (Vec<T>, Vec<U>)\n- ImmutableCloneableVector.partitioned() returns (Vec<T>, Vec<T>)\n- OwnedVector.partition() returns (Vec<T>, Vec<T>)", "tree": {"sha": "aeb73142fbdb6e19ce00251f9f75311d2862c423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeb73142fbdb6e19ce00251f9f75311d2862c423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "html_url": "https://github.com/rust-lang/rust/commit/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4af84313d67e3062e43c0123093278b1887cac64", "url": "https://api.github.com/repos/rust-lang/rust/commits/4af84313d67e3062e43c0123093278b1887cac64", "html_url": "https://github.com/rust-lang/rust/commit/4af84313d67e3062e43c0123093278b1887cac64"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "f7813c31d4d7be3042b0d415a5f4b70ccad7b481", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "patch": "@@ -83,7 +83,7 @@ impl ToStrRadix for $T {\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n+        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n     }\n }\n "}, {"sha": "814ea0e4274f50323a9a9bf132c83b4d5ce17765", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "patch": "@@ -84,7 +84,7 @@ impl ToStrRadix for $T {\n         });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n-        unsafe { str::raw::from_utf8_owned(buf.move_iter().collect()) }\n+        unsafe { str::raw::from_utf8(buf.as_slice()).to_owned() }\n     }\n }\n "}, {"sha": "a93f209459aba3cd56f69fa24f5a90890a041b11", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "patch": "@@ -127,31 +127,31 @@ pub trait VectorVector<T> {\n     // FIXME #5898: calling these .concat and .connect conflicts with\n     // StrVector::con{cat,nect}, since they have generic contents.\n     /// Flattens a vector of vectors of T into a single vector of T.\n-    fn concat_vec(&self) -> ~[T];\n+    fn concat_vec(&self) -> Vec<T>;\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n-    fn connect_vec(&self, sep: &T) -> ~[T];\n+    fn connect_vec(&self, sep: &T) -> Vec<T>;\n }\n \n impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n-    fn concat_vec(&self) -> ~[T] {\n+    fn concat_vec(&self) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self.iter() {\n             result.push_all(v.as_slice())\n         }\n-        result.move_iter().collect()\n+        result\n     }\n \n-    fn connect_vec(&self, sep: &T) -> ~[T] {\n+    fn connect_vec(&self, sep: &T) -> Vec<T> {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self.iter() {\n             if first { first = false } else { result.push(sep.clone()) }\n             result.push_all(v.as_slice())\n         }\n-        result.move_iter().collect()\n+        result\n     }\n }\n \n@@ -185,7 +185,7 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n pub struct ElementSwaps {\n-    sdir: ~[SizeDirection],\n+    sdir: Vec<SizeDirection>,\n     /// If true, emit the last swap that returns the sequence to initial state\n     emit_reset: bool,\n     swaps_made : uint,\n@@ -199,9 +199,7 @@ impl ElementSwaps {\n         // element (equal to the original index).\n         ElementSwaps{\n             emit_reset: true,\n-            sdir: range(0, length)\n-                    .map(|i| SizeDirection{ size: i, dir: Neg })\n-                    .collect::<~[_]>(),\n+            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n             swaps_made: 0\n         }\n     }\n@@ -228,12 +226,12 @@ impl Iterator<(uint, uint)> for ElementSwaps {\n         let max = self.sdir.iter().map(|&x| x).enumerate()\n                            .filter(|&(i, sd)|\n                                 new_pos(i, sd.dir) < self.sdir.len() &&\n-                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                                self.sdir.get(new_pos(i, sd.dir)).size < sd.size)\n                            .max_by(|&(_, sd)| sd.size);\n         match max {\n             Some((i, sd)) => {\n                 let j = new_pos(i, sd.dir);\n-                self.sdir.swap(i, j);\n+                self.sdir.as_mut_slice().swap(i, j);\n \n                 // Swap the direction of each larger SizeDirection\n                 for x in self.sdir.mut_iter() {\n@@ -368,7 +366,7 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n pub trait ImmutableCloneableVector<T> {\n     /// Partitions the vector into two vectors `(A,B)`, where all\n     /// elements of `A` satisfy `f` and all elements of `B` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n+    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n \n     /// Create an iterator that yields every possible permutation of the\n     /// vector in succession.\n@@ -377,7 +375,7 @@ pub trait ImmutableCloneableVector<T> {\n \n impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n     #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -389,7 +387,7 @@ impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n             }\n         }\n \n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n+        (lefts, rights)\n     }\n \n     fn permutations(self) -> Permutations<T> {\n@@ -426,7 +424,7 @@ pub trait OwnedVector<T> {\n      * Partitions the vector into two vectors `(A,B)`, where all\n      * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -446,7 +444,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: |&T| -> bool) -> (Vec<T>, Vec<T>) {\n         let mut lefts  = Vec::new();\n         let mut rights = Vec::new();\n \n@@ -458,7 +456,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             }\n         }\n \n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n+        (lefts, rights)\n     }\n }\n \n@@ -1250,6 +1248,7 @@ mod tests {\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n+        let (left, right) = (left.as_slice(), right.as_slice());\n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));\n         assert_eq!((3, 6), (left[2], right[2]));\n@@ -1455,43 +1454,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_partition() {\n-        assert_eq!((box []).partition(|x: &int| *x < 3), (box [], box []));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 4), (box [1, 2, 3], box []));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 2), (box [1], box [2, 3]));\n-        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n-    }\n-\n-    #[test]\n-    fn test_partitioned() {\n-        assert_eq!(([]).partitioned(|x: &int| *x < 3), (box [], box []))\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (box [1, 2, 3], box []));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (box [1], box [2, 3]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n-    }\n-\n-    #[test]\n-    fn test_concat() {\n-        let v: [~[int], ..0] = [];\n-        assert_eq!(v.concat_vec(), box []);\n-        assert_eq!([box [1], box [2,3]].concat_vec(), box [1, 2, 3]);\n-\n-        assert_eq!([&[1], &[2,3]].concat_vec(), box [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_connect() {\n-        let v: [~[int], ..0] = [];\n-        assert_eq!(v.connect_vec(&0), box []);\n-        assert_eq!([box [1], box [2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n-        assert_eq!([box [1], box [2], box [3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n-\n-        assert_eq!(v.connect_vec(&0), box []);\n-        assert_eq!([&[1], &[2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n-        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n-    }\n-\n     #[test]\n     fn test_shift() {\n         let mut x = vec![1, 2, 3];"}, {"sha": "9d83a5848fbf33b89259c57fade5270945eb3c34", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dae8e1e0916afd2f789a2f1affdfe580d9ca0e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=21dae8e1e0916afd2f789a2f1affdfe580d9ca0e", "patch": "@@ -1649,4 +1649,42 @@ mod tests {\n         unsafe { v.set_len(0); }\n         assert_eq!(v.mut_iter().len(), 0);\n     }\n+\n+    #[test]\n+    fn test_partition() {\n+        assert_eq!(vec![].partition(|x: &int| *x < 3), (vec![], vec![]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(vec![1, 2, 3].partition(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n+    #[test]\n+    fn test_partitioned() {\n+        assert_eq!(([]).partitioned(|x: &int| *x < 3), (vec![], vec![]))\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));\n+    }\n+\n+    #[test]\n+    fn test_concat() {\n+        let v: [Vec<int>, ..0] = [];\n+        assert_eq!(v.concat_vec(), vec![]);\n+        assert_eq!([vec![1], vec![2,3]].concat_vec(), vec![1, 2, 3]);\n+\n+        assert_eq!([&[1], &[2,3]].concat_vec(), vec![1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_connect() {\n+        let v: [~[int], ..0] = [];\n+        assert_eq!(v.connect_vec(&0), vec![]);\n+        assert_eq!([vec![1], vec![2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([vec![1], vec![2], vec![3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+\n+        let v: [&[int], ..0] = [];\n+        assert_eq!(v.connect_vec(&0), vec![]);\n+        assert_eq!([&[1], &[2, 3]].connect_vec(&0), vec![1, 0, 2, 3]);\n+        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+    }\n }"}]}