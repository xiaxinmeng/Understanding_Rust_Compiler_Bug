{"sha": "f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MWQzMGQ3Mjk1NTA3ZDUwNzVhNjFkOGJmOWYxN2JlOGFkM2ZiZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T07:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T07:01:32Z"}, "message": "auto merge of #8616 : kballard/rust/url-parse-errors, r=catamorphism\n\nFixes issue #8612.", "tree": {"sha": "e372180e6be3e1072c52267da1f471d1964d6534", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e372180e6be3e1072c52267da1f471d1964d6534"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "html_url": "https://github.com/rust-lang/rust/commit/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1132496dddbdd88f321a7919eec3d65136b3f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1132496dddbdd88f321a7919eec3d65136b3f75", "html_url": "https://github.com/rust-lang/rust/commit/f1132496dddbdd88f321a7919eec3d65136b3f75"}, {"sha": "4d97b6e445bf9d4138b1fe26f8be302d1bce07fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d97b6e445bf9d4138b1fe26f8be302d1bce07fb", "html_url": "https://github.com/rust-lang/rust/commit/4d97b6e445bf9d4138b1fe26f8be302d1bce07fb"}], "stats": {"total": 61, "additions": 33, "deletions": 28}, "files": [{"sha": "579e17e9f8f05712f5f141a2ee545bc15e75f8e2", "filename": "src/libextra/url.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51d30d7295507d5075a61d8bf9f17be8ad3fbe9/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=f51d30d7295507d5075a61d8bf9f17be8ad3fbe9", "patch": "@@ -61,6 +61,7 @@ impl Url {\n }\n \n impl UserInfo {\n+    #[inline]\n     pub fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n@@ -460,11 +461,14 @@ fn get_authority(rawurl: &str) ->\n               }\n               InHost => {\n                 pos = i;\n-                // can't be sure whether this is an ipv6 address or a port\n                 if input == Unreserved {\n-                    return Err(~\"Illegal characters in authority.\");\n+                    // must be port\n+                    host = rawurl.slice(begin, i).to_owned();\n+                    st = InPort;\n+                } else {\n+                    // can't be sure whether this is an ipv6 address or a port\n+                    st = Ip6Port;\n                 }\n-                st = Ip6Port;\n               }\n               Ip6Port => {\n                 if input == Unreserved {\n@@ -514,25 +518,12 @@ fn get_authority(rawurl: &str) ->\n           }\n           _ => ()\n         }\n-        end = i;\n     }\n \n-    let end = end; // make end immutable so it can be captured\n-\n-    let host_is_end_plus_one: &fn() -> bool = || {\n-        let xs = ['?', '#', '/'];\n-        end+1 == len\n-            && !xs.iter().any(|x| *x == (rawurl[end] as char))\n-    };\n-\n     // finish up\n     match st {\n       Start => {\n-        if host_is_end_plus_one() {\n-            host = rawurl.slice(begin, end+1).to_owned();\n-        } else {\n-            host = rawurl.slice(begin, end).to_owned();\n-        }\n+        host = rawurl.slice(begin, end).to_owned();\n       }\n       PassHostPort | Ip6Port => {\n         if input != Digit {\n@@ -552,8 +543,7 @@ fn get_authority(rawurl: &str) ->\n       }\n     }\n \n-    let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { rawurl.slice(end, len).to_owned() };\n+    let rest = rawurl.slice(end, len).to_owned();\n     return Ok((userinfo, host, port, rest));\n }\n \n@@ -806,18 +796,17 @@ mod tests {\n \n     #[test]\n     fn test_url_parse() {\n-        let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n+        let url = ~\"http://user:pass@rust-lang.org:8080/doc?s=v#something\";\n \n         let up = from_str(url);\n         let u = up.unwrap();\n-        assert!(u.scheme == ~\"http\");\n-        let userinfo = u.user.get_ref();\n-        assert!(userinfo.user == ~\"user\");\n-        assert!(userinfo.pass.get_ref() == &~\"pass\");\n-        assert!(u.host == ~\"rust-lang.org\");\n-        assert!(u.path == ~\"/doc\");\n-        assert!(u.query == ~[(~\"s\", ~\"v\")]);\n-        assert!(u.fragment.get_ref() == &~\"something\");\n+        assert_eq!(&u.scheme, &~\"http\");\n+        assert_eq!(&u.user, &Some(UserInfo::new(~\"user\", Some(~\"pass\"))));\n+        assert_eq!(&u.host, &~\"rust-lang.org\");\n+        assert_eq!(&u.port, &Some(~\"8080\"));\n+        assert_eq!(&u.path, &~\"/doc\");\n+        assert_eq!(&u.query, &~[(~\"s\", ~\"v\")]);\n+        assert_eq!(&u.fragment, &Some(~\"something\"));\n     }\n \n     #[test]\n@@ -828,6 +817,22 @@ mod tests {\n         assert!(url.path == ~\"/\");\n     }\n \n+    #[test]\n+    fn test_url_host_with_port() {\n+        let urlstr = ~\"scheme://host:1234\";\n+        let url = from_str(urlstr).unwrap();\n+        assert_eq!(&url.scheme, &~\"scheme\");\n+        assert_eq!(&url.host, &~\"host\");\n+        assert_eq!(&url.port, &Some(~\"1234\"));\n+        assert_eq!(&url.path, &~\"\"); // is empty path really correct? Other tests think so\n+        let urlstr = ~\"scheme://host:1234/\";\n+        let url = from_str(urlstr).unwrap();\n+        assert_eq!(&url.scheme, &~\"scheme\");\n+        assert_eq!(&url.host, &~\"host\");\n+        assert_eq!(&url.port, &Some(~\"1234\"));\n+        assert_eq!(&url.path, &~\"/\");\n+    }\n+\n     #[test]\n     fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";"}]}