{"sha": "5385a3d6a779b2e85d47c3fc317796ea3755c11a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzODVhM2Q2YTc3OWIyZTg1ZDQ3YzNmYzMxNzc5NmVhMzc1NWMxMWE=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2021-02-13T06:45:53Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2021-02-13T06:45:53Z"}, "message": "spell the real selftype", "tree": {"sha": "94d3dabb29f619128def3bdde7f29294e1a5bc43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94d3dabb29f619128def3bdde7f29294e1a5bc43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5385a3d6a779b2e85d47c3fc317796ea3755c11a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5385a3d6a779b2e85d47c3fc317796ea3755c11a", "html_url": "https://github.com/rust-lang/rust/commit/5385a3d6a779b2e85d47c3fc317796ea3755c11a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5385a3d6a779b2e85d47c3fc317796ea3755c11a/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed40b95925ddbe3596eebbca64f776f0f7c57d95", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed40b95925ddbe3596eebbca64f776f0f7c57d95", "html_url": "https://github.com/rust-lang/rust/commit/ed40b95925ddbe3596eebbca64f776f0f7c57d95"}], "stats": {"total": 69, "additions": 33, "deletions": 36}, "files": [{"sha": "21613bbc6f2e44ed608da38c361a7caf250356f3", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 32, "deletions": 35, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5385a3d6a779b2e85d47c3fc317796ea3755c11a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5385a3d6a779b2e85d47c3fc317796ea3755c11a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=5385a3d6a779b2e85d47c3fc317796ea3755c11a", "patch": "@@ -9,7 +9,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ItemKind, Node};\n+use rustc_hir::{def::Res, ItemKind, Node, PathSegment};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -516,10 +516,11 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n-    #[derive(Debug)]\n     struct ProhibitOpaqueVisitor<'tcx> {\n         opaque_identity_ty: Ty<'tcx>,\n         generics: &'tcx ty::Generics,\n+        tcx: TyCtxt<'tcx>,\n+        selftys: Vec<(Span, Option<String>)>,\n     }\n \n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n@@ -536,6 +537,29 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n+    impl Visitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+            hir::intravisit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+        }\n+\n+        fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n+            match arg.kind {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n+                    [PathSegment { res: Some(Res::SelfTy(_, impl_ref)), .. }] => {\n+                        let impl_ty_name =\n+                            impl_ref.map(|(def_id, _)| self.tcx.def_path_str(def_id));\n+                        self.selftys.push((path.span, impl_ty_name));\n+                    }\n+                    _ => {}\n+                },\n+                _ => {}\n+            }\n+            hir::intravisit::walk_ty(self, arg);\n+        }\n+    }\n+\n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n         ..\n@@ -547,18 +571,19 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n             ),\n             generics: tcx.generics_of(def_id),\n+            tcx,\n+            selftys: vec![],\n         };\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n         debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n-            prohibit_opaque, visitor\n+            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor.opaque_identity_ty={:?}, visitor.generics={:?}\",\n+            prohibit_opaque, visitor.opaque_identity_ty, visitor.generics\n         );\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n-            let mut visitor = SelfTySpanVisitor { tcx, selfty_spans: vec![] };\n             visitor.visit_item(&item);\n             let is_async = match item.kind {\n                 ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n@@ -576,11 +601,11 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 if is_async { \"async fn\" } else { \"impl Trait\" },\n             );\n \n-            for span in visitor.selfty_spans {\n+            for (span, name) in visitor.selftys {\n                 err.span_suggestion(\n                     span,\n                     \"consider spelling out the type instead\",\n-                    format!(\"{:?}\", ty),\n+                    name.unwrap_or_else(|| format!(\"{:?}\", ty)),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -1591,31 +1616,3 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n     }\n     err.emit();\n }\n-\n-struct SelfTySpanVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    selfty_spans: Vec<Span>,\n-}\n-\n-impl Visitor<'tcx> for SelfTySpanVisitor<'tcx> {\n-    type Map = rustc_middle::hir::map::Map<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n-        hir::intravisit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n-    }\n-\n-    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n-        match arg.kind {\n-            hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n-                [segment]\n-                    if segment.res.map(|res| matches!(res, Res::SelfTy(_, _))).unwrap_or(false) =>\n-                {\n-                    self.selfty_spans.push(path.span);\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n-        }\n-        hir::intravisit::walk_ty(self, arg);\n-    }\n-}"}, {"sha": "92b66147106e1eae7ecf4b851d1f1975cf9af1c6", "filename": "src/test/ui/async-await/issues/issue-78600.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5385a3d6a779b2e85d47c3fc317796ea3755c11a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5385a3d6a779b2e85d47c3fc317796ea3755c11a/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr?ref=5385a3d6a779b2e85d47c3fc317796ea3755c11a", "patch": "@@ -4,7 +4,7 @@ error[E0760]: `async fn` return type cannot contain a projection or `Self` that\n LL |     async fn new(i: &'a i32) -> Result<Self, ()> {\n    |                                 ^^^^^^^----^^^^^\n    |                                        |\n-   |                                        help: consider spelling out the type instead: `std::result::Result<S<'a>, ()>`\n+   |                                        help: consider spelling out the type instead: `S<'a>`\n \n error: aborting due to previous error\n "}]}