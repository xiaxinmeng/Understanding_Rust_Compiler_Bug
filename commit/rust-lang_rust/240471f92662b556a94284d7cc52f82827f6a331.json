{"sha": "240471f92662b556a94284d7cc52f82827f6a331", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0MDQ3MWY5MjY2MmI1NTZhOTQyODRkN2NjNTJmODI4MjdmNmEzMzE=", "commit": {"author": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2016-08-21T21:18:58Z"}, "committer": {"name": "Yati Sagade", "email": "yati.sagade@gmail.com", "date": "2017-04-08T21:30:34Z"}, "message": "Needless continue: This is a complete rewrite of this lint as an early-pass lint.\n\nThe previous version had troubles computing suggestions without macro expansions\ncreeping in. This fixes it by using original_sp, which works on AST nodes.", "tree": {"sha": "b296944a85b01917ec938634c50cd0d449ce76fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b296944a85b01917ec938634c50cd0d449ce76fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/240471f92662b556a94284d7cc52f82827f6a331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/240471f92662b556a94284d7cc52f82827f6a331", "html_url": "https://github.com/rust-lang/rust/commit/240471f92662b556a94284d7cc52f82827f6a331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/240471f92662b556a94284d7cc52f82827f6a331/comments", "author": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yati-sagade", "id": 966274, "node_id": "MDQ6VXNlcjk2NjI3NA==", "avatar_url": "https://avatars.githubusercontent.com/u/966274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yati-sagade", "html_url": "https://github.com/yati-sagade", "followers_url": "https://api.github.com/users/yati-sagade/followers", "following_url": "https://api.github.com/users/yati-sagade/following{/other_user}", "gists_url": "https://api.github.com/users/yati-sagade/gists{/gist_id}", "starred_url": "https://api.github.com/users/yati-sagade/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yati-sagade/subscriptions", "organizations_url": "https://api.github.com/users/yati-sagade/orgs", "repos_url": "https://api.github.com/users/yati-sagade/repos", "events_url": "https://api.github.com/users/yati-sagade/events{/privacy}", "received_events_url": "https://api.github.com/users/yati-sagade/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0432f1efd31f8cd58faea180d8e44a786bc6fc4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0432f1efd31f8cd58faea180d8e44a786bc6fc4c", "html_url": "https://github.com/rust-lang/rust/commit/0432f1efd31f8cd58faea180d8e44a786bc6fc4c"}], "stats": {"total": 472, "additions": 472, "deletions": 0}, "files": [{"sha": "e02f9cd1b7b68511b81a00a0e228ce30d777842f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/240471f92662b556a94284d7cc52f82827f6a331/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/240471f92662b556a94284d7cc52f82827f6a331/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=240471f92662b556a94284d7cc52f82827f6a331", "patch": "@@ -405,6 +405,7 @@ All notable changes to this project will be documented in this file.\n [`mutex_integer`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_integer\n [`needless_bool`]: https://github.com/Manishearth/rust-clippy/wiki#needless_bool\n [`needless_borrow`]: https://github.com/Manishearth/rust-clippy/wiki#needless_borrow\n+[`needless_continue`]: https://github.com/Manishearth/rust-clippy/wiki#needless_continue\n [`needless_lifetimes`]: https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes\n [`needless_pass_by_value`]: https://github.com/Manishearth/rust-clippy/wiki#needless_pass_by_value\n [`needless_range_loop`]: https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop"}, {"sha": "ef85b029617dc642769bbe0277e5adafa40f191d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/240471f92662b556a94284d7cc52f82827f6a331/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/240471f92662b556a94284d7cc52f82827f6a331/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=240471f92662b556a94284d7cc52f82827f6a331", "patch": "@@ -107,6 +107,7 @@ pub mod mutex_atomic;\n pub mod needless_bool;\n pub mod needless_borrow;\n pub mod needless_pass_by_value;\n+pub mod needless_continue;\n pub mod needless_update;\n pub mod neg_multiply;\n pub mod new_without_default;\n@@ -219,6 +220,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box approx_const::Pass);\n     reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n+    reg.register_early_lint_pass(box needless_continue::NeedlessContinue);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n     reg.register_early_lint_pass(box items_after_statements::ItemsAfterStatements);\n@@ -461,6 +463,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         needless_bool::NEEDLESS_BOOL,\n         needless_borrow::NEEDLESS_BORROW,\n         needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        needless_continue::NEEDLESS_CONTINUE,\n         needless_update::NEEDLESS_UPDATE,\n         neg_multiply::NEG_MULTIPLY,\n         new_without_default::NEW_WITHOUT_DEFAULT,"}, {"sha": "042f45cefcf10f66495ff08fa10054ec370fadf2", "filename": "clippy_lints/src/needless_continue.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/240471f92662b556a94284d7cc52f82827f6a331/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/240471f92662b556a94284d7cc52f82827f6a331/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=240471f92662b556a94284d7cc52f82827f6a331", "patch": "@@ -0,0 +1,468 @@\n+//! Checks for continue statements in loops that are redundant.\n+//!\n+//! For example, the lint would catch\n+//!\n+//! ```\n+//! while condition() {\n+//!     update_condition();\n+//!     if x {\n+//!         // ...\n+//!     } else {\n+//!         continue;\n+//!     }\n+//!     println!(\"Hello, world\");\n+//! }\n+//! ```\n+//!\n+//! And suggest something like this:\n+//!\n+//! ```\n+//! while condition() {\n+//!     update_condition();\n+//!     if x {\n+//!         // ...\n+//!         println!(\"Hello, world\");\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This lint is **warn** by default.\n+use std;\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::codemap::{original_sp,DUMMY_SP};\n+\n+use utils::{in_macro, span_help_and_lint, snippet_block, snippet};\n+use self::LintType::*;\n+\n+/// **What it does:** The lint checks for `if`-statements appearing in loops\n+/// that contain a `continue` statement in either their main blocks or their\n+/// `else`-blocks, when omitting the `else`-block possibly with some\n+/// rearrangement of code can make the code easier to understand.\n+///\n+/// **Why is this bad?** Having explicit `else` blocks for `if` statements\n+/// containing `continue` in their THEN branch adds unnecessary branching and\n+/// nesting to the code. Having an else block containing just `continue` can\n+/// also be better written by grouping the statements following the whole `if`\n+/// statement within the THEN block and omitting the else block completely.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// while condition() {\n+///     update_condition();\n+///     if x {\n+///         // ...\n+///     } else {\n+///         continue;\n+///     }\n+///     println!(\"Hello, world\");\n+/// }\n+/// ```\n+///\n+/// Could be rewritten as\n+///\n+/// ```rust\n+/// while condition() {\n+///     update_condition();\n+///     if x {\n+///         // ...\n+///         println!(\"Hello, world\");\n+///     }\n+/// }\n+/// ```\n+///\n+/// As another example, the following code\n+///\n+/// ```rust\n+/// loop {\n+///     if waiting() {\n+///         continue;\n+///     } else {\n+///         // Do something useful\n+///     }\n+/// }\n+/// ```\n+/// Could be rewritten as\n+///\n+/// ```rust\n+/// loop {\n+///     if waiting() {\n+///         continue;\n+///     }\n+///     // Do something useful\n+/// }\n+/// ```\n+declare_lint! {\n+    pub NEEDLESS_CONTINUE,\n+    Warn,\n+    \"`continue` statements that can be replaced by a rearrangement of code\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct NeedlessContinue;\n+\n+impl LintPass for NeedlessContinue {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NEEDLESS_CONTINUE)\n+    }\n+}\n+\n+impl EarlyLintPass for NeedlessContinue {\n+    fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n+        if !in_macro(ctx, expr.span) {\n+            check_and_warn(ctx, expr);\n+        }\n+    }\n+}\n+\n+/// Given an Expr, returns true if either of the following is true\n+///\n+/// - The Expr is a `continue` node.\n+/// - The Expr node is a block with the first statement being a `continue`.\n+///\n+fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n+    let mut found = false;\n+    match else_expr.node {\n+        ast::ExprKind::Block(ref else_block) => {\n+            found = is_first_block_stmt_continue(else_block);\n+        },\n+        ast::ExprKind::Continue(_) => { found = true },\n+        _ => { },\n+    };\n+    found\n+}\n+\n+fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n+    let mut ret = false;\n+    block.stmts.get(0).map(|stmt| {\n+        if_let_chain! {[\n+            let ast::StmtKind::Semi(ref e) = stmt.node,\n+            let ast::ExprKind::Continue(_) = e.node,\n+        ], {\n+            ret = true;\n+        }}\n+    }).unwrap_or(());\n+    ret\n+}\n+\n+/// If `expr` is a loop expression (while/while let/for/loop), calls `func` with\n+/// the AST object representing the loop block of `expr`.\n+fn with_loop_block<F>(expr: &ast::Expr, mut func: F) where F: FnMut(&ast::Block) {\n+    match expr.node {\n+        ast::ExprKind::While(_, ref loop_block, _)       |\n+        ast::ExprKind::WhileLet(_, _, ref loop_block, _) |\n+        ast::ExprKind::ForLoop( _, _, ref loop_block, _) |\n+        ast::ExprKind::Loop(ref loop_block, _)           => func(loop_block),\n+        _ => {},\n+    }\n+}\n+\n+/// If `stmt` is an if expression node with an else branch, calls func with the\n+/// following:\n+///\n+/// - The if Expr,\n+/// - The if condition Expr,\n+/// - The then block of this if Expr, and\n+/// - The else expr.\n+///\n+fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n+        where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr) {\n+    match stmt.node {\n+        ast::StmtKind::Semi(ref e) |\n+        ast::StmtKind::Expr(ref e) => {\n+            if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.node {\n+                func(e, cond, if_block, else_expr);\n+            }\n+        },\n+        _ => { },\n+    }\n+}\n+\n+/// A type to distinguish between the two distinct cases this lint handles.\n+enum LintType {\n+    ContinueInsideElseBlock,\n+    ContinueInsideThenBlock,\n+}\n+\n+/// Data we pass around for construction of help messages.\n+struct LintData<'a> {\n+    if_expr:     &'a ast::Expr,    // The `if` expr encountered in the above loop.\n+    if_cond:     &'a ast::Expr,    // The condition expression for the above `if`.\n+    if_block:    &'a ast::Block,   // The `then` block of the `if` statement.\n+    else_expr:   &'a ast::Expr,    /* The `else` block of the `if` statement.\n+                                      Note that we only work with `if` exprs that\n+                                      have an `else` branch. */\n+    stmt_idx:    usize,            /* The 0-based index of the `if` statement in\n+                                      the containing loop block. */\n+    block_stmts: &'a [ast::Stmt],  // The statements of the loop block.\n+}\n+\n+const MSG_REDUNDANT_ELSE_BLOCK: &'static str = \"This else block is redundant.\\n\";\n+\n+const MSG_ELSE_BLOCK_NOT_NEEDED: &'static str = \"There is no need for an explicit `else` block for this `if` expression\\n\";\n+\n+const DROP_ELSE_BLOCK_AND_MERGE_MSG: &'static str =\n+    \"Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\\n\";\n+\n+const DROP_ELSE_BLOCK_MSG: &'static str =\n+    \"Consider dropping the else clause, and moving out the code in the else block, like so:\\n\";\n+\n+\n+fn emit_warning<'a>(ctx: &EarlyContext,\n+                    data: &'a LintData,\n+                    header: &str,\n+                    typ: LintType) {\n+\n+    // snip    is the whole *help* message that appears after the warning.\n+    // message is the warning message.\n+    // expr    is the expression which the lint warning message refers to.\n+    let (snip, message, expr) = match typ {\n+        ContinueInsideElseBlock => {\n+            (suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+             MSG_REDUNDANT_ELSE_BLOCK,\n+             data.else_expr)\n+        },\n+        ContinueInsideThenBlock => {\n+            (suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+             MSG_ELSE_BLOCK_NOT_NEEDED,\n+             data.if_expr)\n+        }\n+    };\n+    span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message,\n+                       &format!(\"{}\", snip));\n+}\n+\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n+                                                data: &'a LintData,\n+                                                header: &str) -> String {\n+    let cond_code = &snippet(ctx, data.if_cond.span, \"..\").into_owned();\n+\n+    let if_code   = &format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n+                                    /*  ^^^^--- Four spaces of indentation. */\n+    // region B\n+    let else_code = &snippet(ctx, data.else_expr.span, \"..\").into_owned();\n+    let else_code = erode_block(&else_code);\n+    let else_code = trim_indent(&else_code, false);\n+\n+    let mut ret = String::from(header);\n+    ret.push_str(&if_code);\n+    ret.push_str(&else_code);\n+    ret.push_str(\"\\n...\");\n+    ret\n+}\n+\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n+                                                   data: &'a LintData,\n+                                                   header: &str) -> String\n+{\n+    let cond_code = &snippet(ctx, data.if_cond.span, \"..\").into_owned();\n+    let mut if_code   = format!(\"if {} {{\\n\", cond_code);\n+\n+    // Region B\n+    let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n+    let block_code = erode_block(block_code);\n+    let block_code = trim_indent(&block_code, false);\n+    let block_code = left_pad_lines_with_spaces(&block_code, 4usize);\n+\n+    if_code.push_str(&block_code);\n+\n+    // Region C\n+    // These is the code in the loop block that follows the if/else construction\n+    // we are complaining about. We want to pull all of this code into the\n+    // `then` block of the `if` statement.\n+    let to_annex = data.block_stmts[data.stmt_idx+1..]\n+                   .iter()\n+                   .map(|stmt| {\n+                        original_sp(ctx.sess().codemap(), stmt.span, DUMMY_SP)\n+                    })\n+                   .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n+                   .collect::<Vec<_>>().join(\"\\n\");\n+\n+    let mut ret = String::from(header);\n+    ret.push_str(&align_snippets(&[&if_code,\n+                                   \"\\n// Merged code follows...\",\n+                                   &to_annex]));\n+    ret.push_str(\"\\n}\\n\");\n+    ret\n+}\n+\n+fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n+    with_loop_block(expr, |loop_block| {\n+        for (i, stmt) in loop_block.stmts.iter().enumerate() {\n+            with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n+                let data = &LintData {\n+                    stmt_idx:    i,\n+                    if_expr:     if_expr,\n+                    if_cond:     cond,\n+                    if_block:    then_block,\n+                    else_expr:   else_expr,\n+                    block_stmts: &loop_block.stmts,\n+                };\n+                if needless_continue_in_else(else_expr) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, ContinueInsideElseBlock);\n+                } else if is_first_block_stmt_continue(then_block) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, ContinueInsideThenBlock);\n+                }\n+            });\n+        }\n+    });\n+}\n+\n+/// Eats at `s` from the end till a closing brace `}` is encountered, and then\n+/// continues eating till a non-whitespace character is found.\n+/// e.g., the string\n+///\n+/// \"\n+/// {\n+///     let x = 5;\n+/// }\n+/// \"\n+///\n+/// is transformed to\n+///\n+/// \"\n+/// {\n+///     let x = 5;\"\n+///\n+fn erode_from_back(s: &str) -> String {\n+    let mut ret = String::from(s);\n+    while ret.pop().map_or(false, |c| c != '}') { }\n+    while let Some(c) = ret.pop() {\n+        if !c.is_whitespace() {\n+            ret.push(c);\n+            break;\n+        }\n+    }\n+    ret\n+}\n+\n+fn erode_from_front(s: &str) -> String {\n+    s.chars()\n+     .skip_while(|c| c.is_whitespace())\n+     .skip_while(|c| *c == '{')\n+     .skip_while(|c| *c == '\\n')\n+     .collect::<String>()\n+}\n+\n+fn erode_block(s: &str) -> String {\n+    erode_from_back(&erode_from_front(s))\n+}\n+\n+fn is_all_whitespace(s: &str) -> bool { s.chars().all(|c| c.is_whitespace()) }\n+\n+/// Returns true if a string is empty or just spaces.\n+fn is_null(s: &str) -> bool { s.is_empty() || is_all_whitespace(s) }\n+\n+/// Returns the indentation level of a string. It just returns the count of\n+/// whitespace characters in the string before a non-whitespace character\n+/// is encountered.\n+fn indent_level(s: &str) -> usize {\n+    s.chars()\n+     .enumerate()\n+     .find(|&(_, c)| !c.is_whitespace())\n+     .map_or(0usize, |(i, _)| i)\n+}\n+\n+/// Trims indentation from a snippet such that the line with the minimum\n+/// indentation has no indentation after the trasformation.\n+fn trim_indent(s: &str, skip_first_line: bool) -> String {\n+    let min_indent_level = s.lines()\n+                            .filter(|line| !is_null(line))\n+                            .skip(skip_first_line as usize)\n+                            .map(indent_level)\n+                            .min()\n+                            .unwrap_or(0usize);\n+    let ret = s.lines().map(|line| {\n+        if is_null(line) {\n+            String::from(line)\n+        } else {\n+            line.chars()\n+                .enumerate()\n+                .skip_while(|&(i, c)| c.is_whitespace() && i < min_indent_level)\n+                .map(|pair| pair.1)\n+                .collect::<String>()\n+        }\n+    }).collect::<Vec<String>>();\n+    ret.join(\"\\n\")\n+}\n+\n+/// Add `n` spaces to the left of `s`.\n+fn left_pad_with_spaces(s: &str, n: usize) -> String {\n+    let mut new_s = std::iter::repeat(' '/* <-space */).take(n).collect::<String>();\n+    new_s.push_str(s);\n+    new_s\n+}\n+\n+/// Add `n` spaces to the left of each line in `s` and return the result\n+/// in a new String.\n+fn left_pad_lines_with_spaces(s: &str, n: usize) -> String {\n+    s.lines()\n+     .map(|line| left_pad_with_spaces(line, n))\n+     .collect::<Vec<_>>()\n+     .join(\"\\n\")\n+}\n+\n+/// Remove upto `n` whitespace characters from the beginning of `s`.\n+fn remove_whitespace_from_left(s: &str, n: usize) -> String {\n+    s.chars()\n+     .enumerate()\n+     .skip_while(|&(i, c)| i < n && c.is_whitespace())\n+     .map(|(_, c)| c)\n+     .collect::<String>()\n+}\n+\n+/// Aligns two snippets such that the indentation level of the last non-empty,\n+/// non-space line of the first snippet matches the first non-empty, non-space\n+/// line of the second.\n+fn align_two_snippets(s: &str, t: &str) -> String {\n+    // indent level of the last nonempty, non-whitespace line of s.\n+    let target_ilevel = s.lines()\n+                         .rev()\n+                         .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n+                         .next()\n+                         .map_or(0usize, indent_level);\n+\n+    // We want to align the first nonempty, non-all-whitespace line of t to\n+    // have the same indent level as target_ilevel\n+    let level = t.lines()\n+                 .skip_while(|line| line.is_empty() || is_all_whitespace(line))\n+                 .next()\n+                 .map_or(0usize, indent_level);\n+\n+    let add_or_not_remove = target_ilevel > level; /* when true, we add spaces,\n+                                                      otherwise eat. */\n+\n+    let delta = if add_or_not_remove {\n+        target_ilevel - level\n+    } else {\n+        level - target_ilevel\n+    };\n+\n+    let new_t = t.lines()\n+                 .filter(|line| !is_null(line))\n+                 .map(|line| if add_or_not_remove {\n+                     left_pad_with_spaces(line, delta)\n+                 } else {\n+                     remove_whitespace_from_left(line, delta)\n+                 })\n+                 .collect::<Vec<_>>().join(\"\\n\");\n+\n+    format!(\"{}\\n{}\", s, new_t)\n+}\n+\n+fn align_snippets(xs: &[&str]) -> String {\n+    match xs.len() {\n+        0 => String::from(\"\"),\n+        _ => {\n+            let mut ret = String::new();\n+            ret.push_str(xs[0]);\n+            for x in xs.iter().skip(1usize) {\n+                ret = align_two_snippets(&ret, x);\n+            }\n+            ret\n+        }\n+    }\n+}\n+"}]}