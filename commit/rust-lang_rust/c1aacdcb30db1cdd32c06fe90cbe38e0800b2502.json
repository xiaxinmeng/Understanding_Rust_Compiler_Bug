{"sha": "c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYWFjZGNiMzBkYjFjZGQzMmMwNmZlOTBjYmUzOGUwODAwYjI1MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T05:08:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-12T05:08:09Z"}, "message": "Auto merge of #45864 - nikomatsakis:issue-30046-infer-fn-once-in-closures, r=eddyb\n\nadjust closure kind based on the guarantor's upvar note\n\nFixes #30046.\n\nr? @eddyb", "tree": {"sha": "2b69b4471eb50bac9a01731db677164bd91b2cab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b69b4471eb50bac9a01731db677164bd91b2cab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "html_url": "https://github.com/rust-lang/rust/commit/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9f854201430f2b3defe9d4c8048238ad05d26e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9f854201430f2b3defe9d4c8048238ad05d26e2", "html_url": "https://github.com/rust-lang/rust/commit/e9f854201430f2b3defe9d4c8048238ad05d26e2"}, {"sha": "629efae761d0a473ddeeb9a4f2e5c408d9ce99dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/629efae761d0a473ddeeb9a4f2e5c408d9ce99dc", "html_url": "https://github.com/rust-lang/rust/commit/629efae761d0a473ddeeb9a4f2e5c408d9ce99dc"}], "stats": {"total": 148, "additions": 87, "deletions": 61}, "files": [{"sha": "4071f81ea51430c2057f97df455743ccf39a8cbe", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "patch": "@@ -88,7 +88,7 @@ use std::fmt;\n use std::rc::Rc;\n use util::nodemap::ItemLocalSet;\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum Categorization<'tcx> {\n     Rvalue(ty::Region<'tcx>),              // temporary val, argument is its scope\n     StaticItem,\n@@ -109,7 +109,7 @@ pub struct Upvar {\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum PointerKind<'tcx> {\n     /// `Box<T>`\n     Unique,\n@@ -177,7 +177,7 @@ pub enum Note {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -750,12 +750,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         let kind = match self.node_ty(fn_hir_id)?.sty {\n             ty::TyGenerator(..) => ty::ClosureKind::FnOnce,\n-            _ => {\n+            ty::TyClosure(..) => {\n                 match self.tables.closure_kinds().get(fn_hir_id) {\n                     Some(&(kind, _)) => kind,\n                     None => span_bug!(span, \"missing closure kind\"),\n                 }\n             }\n+            ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n         };\n \n         let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n@@ -1499,41 +1500,6 @@ impl<'tcx> cmt_<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for cmt_<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{{{:?} id:{} m:{:?} ty:{:?}}}\",\n-               self.cat,\n-               self.id,\n-               self.mutbl,\n-               self.ty)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for Categorization<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Categorization::StaticItem => write!(f, \"static\"),\n-            Categorization::Rvalue(r) => { write!(f, \"rvalue({:?})\", r) }\n-            Categorization::Local(id) => {\n-               let name = ty::tls::with(|tcx| tcx.hir.name(id));\n-               write!(f, \"local({})\", name)\n-            }\n-            Categorization::Upvar(upvar) => {\n-                write!(f, \"upvar({:?})\", upvar)\n-            }\n-            Categorization::Deref(ref cmt, ptr) => {\n-                write!(f, \"{:?}-{:?}->\", cmt.cat, ptr)\n-            }\n-            Categorization::Interior(ref cmt, interior) => {\n-                write!(f, \"{:?}.{:?}\", cmt.cat, interior)\n-            }\n-            Categorization::Downcast(ref cmt, _) => {\n-                write!(f, \"{:?}->(enum)\", cmt.cat)\n-            }\n-        }\n-    }\n-}\n-\n pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     match ptr {\n         Unique => \"Box\",\n@@ -1547,27 +1513,6 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl<'tcx> fmt::Debug for PointerKind<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Unique => write!(f, \"Box\"),\n-            BorrowedPtr(ty::ImmBorrow, ref r) |\n-            Implicit(ty::ImmBorrow, ref r) => {\n-                write!(f, \"&{:?}\", r)\n-            }\n-            BorrowedPtr(ty::MutBorrow, ref r) |\n-            Implicit(ty::MutBorrow, ref r) => {\n-                write!(f, \"&{:?} mut\", r)\n-            }\n-            BorrowedPtr(ty::UniqueImmBorrow, ref r) |\n-            Implicit(ty::UniqueImmBorrow, ref r) => {\n-                write!(f, \"&{:?} uniq\", r)\n-            }\n-            UnsafePtr(_) => write!(f, \"*\")\n-        }\n-    }\n-}\n-\n impl fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "a6a81485b23df83c9a483507e3c36e6abec85639", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "patch": "@@ -289,10 +289,14 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         let guarantor = cmt.guarantor();\n         debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor={:?}\",\n                guarantor);\n+        debug!(\"adjust_upvar_borrow_kind_for_consume: guarantor.cat={:?}\",\n+               guarantor.cat);\n         match guarantor.cat {\n             Categorization::Deref(_, mc::BorrowedPtr(..)) |\n             Categorization::Deref(_, mc::Implicit(..)) => {\n-                match cmt.note {\n+                debug!(\"adjust_upvar_borrow_kind_for_consume: found deref with note {:?}\",\n+                       cmt.note);\n+                match guarantor.note {\n                     mc::NoteUpvarRef(upvar_id) => {\n                         debug!(\"adjust_upvar_borrow_kind_for_consume: \\\n                                 setting upvar_id={:?} to by value\","}, {"sha": "d902ebc9dc9d263043aecf7f6ca68abf1129a31b", "filename": "src/test/run-pass/unboxed-closures-move-from-projection-issue-30046.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Frun-pass%2Funboxed-closures-move-from-projection-issue-30046.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Frun-pass%2Funboxed-closures-move-from-projection-issue-30046.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-move-from-projection-issue-30046.rs?ref=c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+fn foo<F>(f: F)\n+    where F: FnOnce()\n+{\n+}\n+\n+fn main() {\n+    // Test that this closure is inferred to `FnOnce`\n+    // because it moves from `y.as<Option::Some>.0`:\n+    let x = Some(vec![1, 2, 3]);\n+    foo(|| {\n+        match x {\n+            Some(y) => { }\n+            None => { }\n+        }\n+    });\n+\n+    // Test that this closure is inferred to `FnOnce`\n+    // because it moves from `y.0`:\n+    let y = (vec![1, 2, 3], 0);\n+    foo(|| {\n+        let x = y.0;\n+    });\n+}"}, {"sha": "14ef3b5f178ac47ac3e4cfe6a9e7217544aaae01", "filename": "src/test/ui/unboxed-closures-infer-fn-once-move-from-projection.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.rs?ref=c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+fn foo<F>(f: F)\n+    where F: Fn()\n+{\n+}\n+\n+fn main() {\n+    // Test that this closure is inferred to `FnOnce` because it moves\n+    // from `y.0`. This affects the error output (the error is that\n+    // the closure implements `FnOnce`, not that it moves from inside\n+    // a `Fn` closure.)\n+    let y = (vec![1, 2, 3], 0);\n+    let c = || drop(y.0);\n+    foo(c);\n+}"}, {"sha": "d968c409396311938a5f0f245bcec3ab34433504", "filename": "src/test/ui/unboxed-closures-infer-fn-once-move-from-projection.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1aacdcb30db1cdd32c06fe90cbe38e0800b2502/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures-infer-fn-once-move-from-projection.stderr?ref=c1aacdcb30db1cdd32c06fe90cbe38e0800b2502", "patch": "@@ -0,0 +1,16 @@\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n+  --> $DIR/unboxed-closures-infer-fn-once-move-from-projection.rs:24:13\n+   |\n+24 |     let c = || drop(y.0);\n+   |             ^^^^^^^^^^^^\n+25 |     foo(c);\n+   |     --- the requirement to implement `Fn` derives from here\n+   |\n+note: closure is `FnOnce` because it moves the variable `y` out of its environment\n+  --> $DIR/unboxed-closures-infer-fn-once-move-from-projection.rs:24:21\n+   |\n+24 |     let c = || drop(y.0);\n+   |                     ^\n+\n+error: aborting due to previous error\n+"}]}