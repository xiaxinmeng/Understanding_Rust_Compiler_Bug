{"sha": "5a65f51d666855d7685850808cc06e49c3d21c72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNjVmNTFkNjY2ODU1ZDc2ODU4NTA4MDhjYzA2ZTQ5YzNkMjFjNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-08T21:09:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-08T21:09:38Z"}, "message": "auto merge of #6214 : sanxiyn/rust/simd-2, r=graydon\n\nAt the moment this only includes type checking and there is no code generation support yet. I wanted to get the design reviewed first.\r\n\r\nFrom discussion with @graydon at #5841, re-implemented as `#[simd]` attribute on structs.\r\n\r\nProgressing towards #3499.", "tree": {"sha": "9a148101702e2778b517fb90b4410d9cbdd0c364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a148101702e2778b517fb90b4410d9cbdd0c364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a65f51d666855d7685850808cc06e49c3d21c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a65f51d666855d7685850808cc06e49c3d21c72", "html_url": "https://github.com/rust-lang/rust/commit/5a65f51d666855d7685850808cc06e49c3d21c72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a65f51d666855d7685850808cc06e49c3d21c72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65ded84d204339eb9ac69b53c5e32a0128805f5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ded84d204339eb9ac69b53c5e32a0128805f5f", "html_url": "https://github.com/rust-lang/rust/commit/65ded84d204339eb9ac69b53c5e32a0128805f5f"}, {"sha": "eb5fa061136a1f4eb4d7c3c58f396edea43c234d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5fa061136a1f4eb4d7c3c58f396edea43c234d", "html_url": "https://github.com/rust-lang/rust/commit/eb5fa061136a1f4eb4d7c3c58f396edea43c234d"}], "stats": {"total": 217, "additions": 193, "deletions": 24}, "files": [{"sha": "0b96e649178a130ddd037a98f10685b81984996e", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -30,6 +30,8 @@ pub mod weak_task;\n pub mod exchange_alloc;\n #[path = \"unstable/intrinsics.rs\"]\n pub mod intrinsics;\n+#[path = \"unstable/simd.rs\"]\n+pub mod simd;\n #[path = \"unstable/extfmt.rs\"]\n pub mod extfmt;\n #[path = \"unstable/lang.rs\"]"}, {"sha": "a05f6e8af5a64108f8872d11dc88cc003744936c", "filename": "src/libcore/unstable/simd.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibcore%2Funstable%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibcore%2Funstable%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsimd.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! SIMD vectors\n+\n+#[allow(non_camel_case_types)];\n+\n+#[simd]\n+pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+\n+#[simd]\n+pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+\n+#[simd]\n+pub struct i32x4(i32, i32, i32, i32);\n+\n+#[simd]\n+pub struct i64x2(i64, i64);\n+\n+#[simd]\n+pub struct u8x16(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8);\n+\n+#[simd]\n+pub struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);\n+\n+#[simd]\n+pub struct u32x4(u32, u32, u32, u32);\n+\n+#[simd]\n+pub struct u64x2(u64, u64);\n+\n+#[simd]\n+pub struct f32x4(f32, f32, f32, f32);\n+\n+#[simd]\n+pub struct f64x2(f64, f64);"}, {"sha": "29fd90edce898a50d0a07e0d13159def75bbfdc7", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -963,20 +963,28 @@ pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n }\n \n pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n-                 Index: ValueRef) {\n+                     Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return; }\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n         count_insn(cx, \"insertelement\");\n-        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n+        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname())\n     }\n }\n \n pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n-                     Mask: ValueRef) {\n+                     Mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return; }\n+        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n         count_insn(cx, \"shufflevector\");\n-        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n+        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname())\n+    }\n+}\n+\n+pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n+    unsafe {\n+        let Undef = llvm::LLVMGetUndef(T_vector(val_ty(EltVal), NumElts));\n+        let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n+        ShuffleVector(cx, VecVal, Undef, C_null(T_vector(T_i32(), NumElts)))\n     }\n }\n "}, {"sha": "b004ba9d41f34df2dfb210a4e81b39aac00d2f31", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -984,6 +984,12 @@ pub fn T_array(t: TypeRef, n: uint) -> TypeRef {\n     }\n }\n \n+pub fn T_vector(t: TypeRef, n: uint) -> TypeRef {\n+    unsafe {\n+        return llvm::LLVMVectorType(t, n as c_uint);\n+    }\n+}\n+\n // Interior vector.\n pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n     return T_struct(~[T_int(targ_cfg), // fill"}, {"sha": "b8e0b58f86634c00726ecc66d8c21e8c2fdaab13", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -155,9 +155,15 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n         }\n \n         ty::ty_struct(did, _) => {\n-            let repr = adt::represent_type(cx, t);\n-            let packed = ty::lookup_packed(cx.tcx, did);\n-            T_struct(adt::sizing_fields_of(cx, repr), packed)\n+            if ty::type_is_simd(cx.tcx, t) {\n+                let et = ty::simd_type(cx.tcx, t);\n+                let n = ty::simd_size(cx.tcx, t);\n+                T_vector(type_of(cx, et), n)\n+            } else {\n+                let repr = adt::represent_type(cx, t);\n+                let packed = ty::lookup_packed(cx.tcx, did);\n+                T_struct(adt::sizing_fields_of(cx, repr), packed)\n+            }\n         }\n \n         ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n@@ -263,14 +269,19 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n       ty::ty_struct(did, ref substs) => {\n-        // Only create the named struct, but don't fill it in. We fill it\n-        // in *after* placing it into the type cache. This prevents\n-        // infinite recursion with recursive struct types.\n-\n-        common::T_named_struct(llvm_type_name(cx,\n-                                              a_struct,\n-                                              did,\n-                                              /*bad*/ copy substs.tps))\n+        if ty::type_is_simd(cx.tcx, t) {\n+          let et = ty::simd_type(cx.tcx, t);\n+          let n = ty::simd_size(cx.tcx, t);\n+          T_vector(type_of(cx, et), n)\n+        } else {\n+          // Only create the named struct, but don't fill it in. We fill it\n+          // in *after* placing it into the type cache. This prevents\n+          // infinite recursion with recursive struct types.\n+          T_named_struct(llvm_type_name(cx,\n+                                        a_struct,\n+                                        did,\n+                                        /*bad*/ copy substs.tps))\n+        }\n       }\n       ty::ty_self(*) => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n@@ -289,10 +300,12 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       }\n \n       ty::ty_struct(did, _) => {\n-        let repr = adt::represent_type(cx, t);\n-        let packed = ty::lookup_packed(cx.tcx, did);\n-        common::set_struct_body(llty, adt::fields_of(cx, repr),\n-                                packed);\n+        if !ty::type_is_simd(cx.tcx, t) {\n+          let repr = adt::represent_type(cx, t);\n+          let packed = ty::lookup_packed(cx.tcx, did);\n+          common::set_struct_body(llty, adt::fields_of(cx, repr),\n+                                  packed);\n+        }\n       }\n       _ => ()\n     }"}, {"sha": "a49768075dcc981548602787c08f0dcf14bb5200", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -1567,6 +1567,13 @@ pub fn type_is_sequence(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_struct(did, _) => lookup_simd(cx, did),\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_str(ty: t) -> bool {\n     match get(ty).sty {\n       ty_estr(_) => true,\n@@ -1583,6 +1590,26 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     }\n }\n \n+pub fn simd_type(cx: ctxt, ty: t) -> t {\n+    match get(ty).sty {\n+        ty_struct(did, ref substs) => {\n+            let fields = lookup_struct_fields(cx, did);\n+            lookup_field_type(cx, did, fields[0].id, substs)\n+        }\n+        _ => fail!(~\"simd_type called on invalid type\")\n+    }\n+}\n+\n+pub fn simd_size(cx: ctxt, ty: t) -> uint {\n+    match get(ty).sty {\n+        ty_struct(did, _) => {\n+            let fields = lookup_struct_fields(cx, did);\n+            fields.len()\n+        }\n+        _ => fail!(~\"simd_size called on invalid type\")\n+    }\n+}\n+\n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n       ty_tup(ref ts) => return ts[i],\n@@ -2381,6 +2408,14 @@ pub fn type_is_signed(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_machine(ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_int(ast::ty_i) | ty_uint(ast::ty_u) | ty_float(ast::ty_f) => false,\n+        ty_int(*) | ty_uint(*) | ty_float(*) => true,\n+        _ => false\n+    }\n+}\n+\n // Whether a type is Plain Old Data -- meaning it does not contain pointers\n // that the cycle collector might care about.\n pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n@@ -3896,7 +3931,7 @@ pub fn has_attr(tcx: ctxt, did: def_id, attr: &str) -> bool {\n                     attrs: ref attrs,\n                     _\n                 }, _)) => attr::attrs_contains_name(*attrs, attr),\n-            _ => tcx.sess.bug(fmt!(\"lookup_packed: %? is not an item\",\n+            _ => tcx.sess.bug(fmt!(\"has_attr: %? is not an item\",\n                                    did))\n         }\n     } else {\n@@ -3908,11 +3943,16 @@ pub fn has_attr(tcx: ctxt, did: def_id, attr: &str) -> bool {\n     }\n }\n \n-/// Determine whether an item is annotated with `#[packed]` or not\n+/// Determine whether an item is annotated with `#[packed]`\n pub fn lookup_packed(tcx: ctxt, did: def_id) -> bool {\n     has_attr(tcx, did, \"packed\")\n }\n \n+/// Determine whether an item is annotated with `#[simd]`\n+pub fn lookup_simd(tcx: ctxt, did: def_id) -> bool {\n+    has_attr(tcx, did, \"simd\")\n+}\n+\n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n pub fn lookup_field_type(tcx: ctxt,"}, {"sha": "6cd10b5bd6f1bf968bfd79aa84ae6f5b6d9c0c9e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -561,8 +561,14 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n }\n \n pub fn check_struct(ccx: @mut CrateCtxt, id: ast::node_id, span: span) {\n+    let tcx = ccx.tcx;\n+\n     // Check that the class is instantiable\n-    check_instantiable(ccx.tcx, span, id);\n+    check_instantiable(tcx, span, id);\n+\n+    if ty::lookup_simd(tcx, local_def(id)) {\n+        check_simd(tcx, span, id);\n+    }\n }\n \n pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n@@ -3034,6 +3040,35 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n+pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::node_id) {\n+    let t = ty::node_id_to_type(tcx, id);\n+    if ty::type_needs_subst(t) {\n+        tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n+        return;\n+    }\n+    match ty::get(t).sty {\n+        ty::ty_struct(did, ref substs) => {\n+            let fields = ty::lookup_struct_fields(tcx, did);\n+            if fields.is_empty() {\n+                tcx.sess.span_err(sp, \"SIMD vector cannot be empty\");\n+                return;\n+            }\n+            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n+            if !vec::all(fields,\n+                         |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n+                tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n+                return;\n+            }\n+            if !ty::type_is_machine(e) {\n+                tcx.sess.span_err(sp, \"SIMD vector element type should be \\\n+                                       machine type\");\n+                return;\n+            }\n+        }\n+        _ => ()\n+    }\n+}\n+\n pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: span,\n                            vs: &[ast::variant],"}, {"sha": "8387b2bc723faf91c83f45c2478cfe4d3b8f0185", "filename": "src/test/compile-fail/simd-type.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-type.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -0,0 +1,13 @@\n+#[simd]\n+struct vec4<T>(T, T, T, T); //~ ERROR SIMD vector cannot be generic\n+\n+#[simd]\n+struct empty; //~ ERROR SIMD vector cannot be empty\n+\n+#[simd]\n+struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n+\n+#[simd]\n+struct int4(int, int, int, int); //~ ERROR SIMD vector element type should be machine type\n+\n+fn main() {}"}, {"sha": "c3bcc9d0b7a020dccdd2cb0449ebc1de8da7984d", "filename": "src/test/run-pass/simd-type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Ftest%2Frun-pass%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a65f51d666855d7685850808cc06e49c3d21c72/src%2Ftest%2Frun-pass%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-type.rs?ref=5a65f51d666855d7685850808cc06e49c3d21c72", "patch": "@@ -0,0 +1,9 @@\n+#[simd]\n+struct RGBA {\n+    r: f32,\n+    g: f32,\n+    b: f32,\n+    a: f32\n+}\n+\n+fn main() {}"}]}