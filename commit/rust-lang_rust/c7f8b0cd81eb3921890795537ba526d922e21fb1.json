{"sha": "c7f8b0cd81eb3921890795537ba526d922e21fb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZjhiMGNkODFlYjM5MjE4OTA3OTU1MzdiYTUyNmQ5MjJlMjFmYjE=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-15T21:42:21Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:51Z"}, "message": "Eagerly evaluate landing pads for cleanup scopes", "tree": {"sha": "08b083fe5d0d5ed0cde085b27e7244b3fdda44c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b083fe5d0d5ed0cde085b27e7244b3fdda44c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7f8b0cd81eb3921890795537ba526d922e21fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7f8b0cd81eb3921890795537ba526d922e21fb1", "html_url": "https://github.com/rust-lang/rust/commit/c7f8b0cd81eb3921890795537ba526d922e21fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7f8b0cd81eb3921890795537ba526d922e21fb1/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31691692a2907059ac2e7499d67b28ce6e788d77", "url": "https://api.github.com/repos/rust-lang/rust/commits/31691692a2907059ac2e7499d67b28ce6e788d77", "html_url": "https://github.com/rust-lang/rust/commit/31691692a2907059ac2e7499d67b28ce6e788d77"}], "stats": {"total": 159, "additions": 54, "deletions": 105}, "files": [{"sha": "4f6165e1dbe8b2ce4330258e23709fb5d18e88ca", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c7f8b0cd81eb3921890795537ba526d922e21fb1", "patch": "@@ -387,7 +387,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let mut self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n+    let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n \n@@ -401,10 +401,8 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     let llfn = callee.reify(bcx.ccx());\n     let llret;\n-    if self_scope.is_some() && !bcx.sess().no_landing_pads() {\n+    if let Some(landing_pad) = self_scope.as_ref().and_then(|c| c.landing_pad) {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad(self_scope.as_mut().unwrap());\n-\n         llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {"}, {"sha": "439058daaf9c4da904e5874d6119028f89c0a57f", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 50, "deletions": 97, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=c7f8b0cd81eb3921890795537ba526d922e21fb1", "patch": "@@ -127,8 +127,8 @@ pub struct CleanupScope<'tcx> {\n     // Cleanup to run upon scope exit.\n     cleanup: DropValue<'tcx>,\n \n-    cached_early_exit: Option<CachedEarlyExit>,\n-    cached_landing_pad: Option<BasicBlockRef>,\n+    // Computed on creation if compiling with landing pads (!sess.no_landing_pads)\n+    pub landing_pad: Option<BasicBlockRef>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -142,12 +142,6 @@ enum UnwindKind {\n     CleanupPad(ValueRef),\n }\n \n-#[derive(Copy, Clone)]\n-struct CachedEarlyExit {\n-    label: UnwindKind,\n-    cleanup_block: BasicBlockRef,\n-}\n-\n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     pub fn trans_scope(\n         &self,\n@@ -171,7 +165,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         debug!(\"schedule_drop_mem(val={:?}, ty={:?}) skip_dtor={}\", Value(val), ty, drop.skip_dtor);\n \n-        Some(CleanupScope::new(drop))\n+        Some(CleanupScope::new(self, drop))\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n@@ -196,7 +190,21 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                ty,\n                drop.skip_dtor);\n \n-        Some(CleanupScope::new(drop))\n+        Some(CleanupScope::new(self, drop))\n+    }\n+\n+}\n+\n+impl<'tcx> CleanupScope<'tcx> {\n+    fn new<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n+        CleanupScope {\n+            cleanup: drop_val,\n+            landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n+                Some(CleanupScope::get_landing_pad(fcx, &drop_val))\n+            } else {\n+                None\n+            },\n+        }\n     }\n \n     /// Creates a landing pad for the top scope, if one does not exist. The\n@@ -207,23 +215,15 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     ///\n     /// (The cleanups and resume instruction are created by\n     /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n-    pub fn get_landing_pad(&'blk self, scope: &mut CleanupScope<'tcx>) -> BasicBlockRef {\n+    fn get_landing_pad<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: &DropValue<'tcx>)\n+        -> BasicBlockRef {\n         debug!(\"get_landing_pad\");\n \n-        // Check if a landing pad block exists; if not, create one.\n-        let mut pad_bcx = match scope.cached_landing_pad {\n-            Some(llbb) => return llbb,\n-            None => {\n-                let name = scope.block_name(\"unwind\");\n-                let pad_bcx = self.build_new_block(&name[..]);\n-                scope.cached_landing_pad = Some(pad_bcx.llbb());\n-                pad_bcx\n-            }\n-        };\n+        let mut pad_bcx = fcx.build_new_block(\"unwind_custom_\");\n \n         let llpersonality = pad_bcx.fcx().eh_personality();\n \n-        let val = if base::wants_msvc_seh(self.ccx.sess()) {\n+        let val = if base::wants_msvc_seh(fcx.ccx.sess()) {\n             // A cleanup pad requires a personality function to be specified, so\n             // we do that here explicitly (happens implicitly below through\n             // creation of the landingpad instruction). We then create a\n@@ -236,8 +236,8 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(self.ccx,\n-                                        &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n+            let llretty = Type::struct_(fcx.ccx,\n+                                        &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)],\n                                         false);\n \n             // The only landing pad clause will be 'cleanup'\n@@ -246,12 +246,12 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             // The landing pad block is a cleanup\n             pad_bcx.set_cleanup(llretval);\n \n-            let addr = match self.landingpad_alloca.get() {\n+            let addr = match fcx.landingpad_alloca.get() {\n                 Some(addr) => addr,\n                 None => {\n                     let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n                     Lifetime::Start.call(&pad_bcx, addr);\n-                    self.landingpad_alloca.set(Some(addr));\n+                    fcx.landingpad_alloca.set(Some(addr));\n                     addr\n                 }\n             };\n@@ -260,7 +260,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         };\n \n         // Generate the cleanup block and branch to it.\n-        let cleanup_llbb = self.trans_cleanups_to_exit_scope(val, scope);\n+        let cleanup_llbb = CleanupScope::trans_cleanups_to_exit_scope(fcx, val, drop_val);\n         val.branch(&mut pad_bcx, cleanup_llbb);\n \n         return pad_bcx.llbb();\n@@ -270,93 +270,46 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// break, continue, or unwind. This function will generate all cleanups\n     /// between the top of the stack and the exit `label` and return a basic\n     /// block that the caller can branch to.\n-    fn trans_cleanups_to_exit_scope(\n-        &'blk self,\n+    fn trans_cleanups_to_exit_scope<'a>(\n+        fcx: &FunctionContext<'a, 'tcx>,\n         label: UnwindKind,\n-        scope: &mut CleanupScope<'tcx>\n+        drop_val: &DropValue<'tcx>\n     ) -> BasicBlockRef {\n         debug!(\"trans_cleanups_to_exit_scope label={:?}`\", label);\n-        let cached_exit = scope.cached_early_exit(label);\n-\n-        // Check if we have already cached the unwinding of this\n-        // scope for this label. If so, we can just branch to the cached block.\n-        let exit_llbb = cached_exit.unwrap_or_else(|| {\n-            // Generate a block that will resume unwinding to the calling function\n-            let bcx = self.build_new_block(\"resume\");\n-            match label {\n-                UnwindKind::LandingPad => {\n-                    let addr = self.landingpad_alloca.get().unwrap();\n-                    let lp = bcx.load(addr);\n-                    Lifetime::End.call(&bcx, addr);\n-                    if !bcx.sess().target.target.options.custom_unwind_resume {\n-                        bcx.resume(lp);\n-                    } else {\n-                        let exc_ptr = bcx.extract_value(lp, 0);\n-                        bcx.call(bcx.fcx().eh_unwind_resume().reify(bcx.ccx()), &[exc_ptr], None);\n-                    }\n-                }\n-                UnwindKind::CleanupPad(_) => {\n-                    bcx.cleanup_ret(bcx.cleanup_pad(None, &[]), None);\n+\n+        // Generate a block that will resume unwinding to the calling function\n+        let bcx = fcx.build_new_block(\"resume\");\n+        match label {\n+            UnwindKind::LandingPad => {\n+                let addr = fcx.landingpad_alloca.get().unwrap();\n+                let lp = bcx.load(addr);\n+                Lifetime::End.call(&bcx, addr);\n+                if !bcx.sess().target.target.options.custom_unwind_resume {\n+                    bcx.resume(lp);\n+                } else {\n+                    let exc_ptr = bcx.extract_value(lp, 0);\n+                    bcx.call(bcx.fcx().eh_unwind_resume().reify(bcx.ccx()), &[exc_ptr], None);\n                 }\n             }\n-            bcx.llbb()\n-        });\n-\n-        let name = scope.block_name(\"clean\");\n-        debug!(\"generating cleanup for {}\", name);\n+            UnwindKind::CleanupPad(_) => {\n+                bcx.cleanup_ret(bcx.cleanup_pad(None, &[]), None);\n+            }\n+        }\n \n-        let mut cleanup = self.build_new_block(&name[..]);\n+        let mut cleanup = fcx.build_new_block(\"clean_custom_\");\n \n         // Insert cleanup instructions into the cleanup block\n-        scope.cleanup.trans(label.get_funclet(&cleanup).as_ref(), &cleanup);\n+        drop_val.trans(label.get_funclet(&cleanup).as_ref(), &cleanup);\n \n         // Insert instruction into cleanup block to branch to the exit\n-        label.branch(&mut cleanup, exit_llbb);\n-\n-        // Cache the work we've done here\n-        // FIXME: Can this get called more than once per scope? If not, no need to cache.\n-        scope.add_cached_early_exit(label, cleanup.llbb());\n+        label.branch(&mut cleanup, bcx.llbb());\n \n         debug!(\"trans_cleanups_to_exit_scope: llbb={:?}\", cleanup.llbb());\n \n         cleanup.llbb()\n     }\n }\n \n-impl<'tcx> CleanupScope<'tcx> {\n-    fn new(drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n-        CleanupScope {\n-            cleanup: drop_val,\n-            cached_early_exit: None,\n-            cached_landing_pad: None,\n-        }\n-    }\n-\n-    fn cached_early_exit(&self, label: UnwindKind) -> Option<BasicBlockRef> {\n-        if let Some(e) = self.cached_early_exit {\n-            if e.label == label {\n-                return Some(e.cleanup_block);\n-            }\n-        }\n-        None\n-    }\n-\n-    fn add_cached_early_exit(&mut self,\n-                             label: UnwindKind,\n-                             blk: BasicBlockRef) {\n-        assert!(self.cached_early_exit.is_none());\n-        self.cached_early_exit = Some(CachedEarlyExit {\n-            label: label,\n-            cleanup_block: blk,\n-        });\n-    }\n-\n-    /// Returns a suitable name to use for the basic block that handles this cleanup scope\n-    fn block_name(&self, prefix: &str) -> String {\n-        format!(\"{}_custom_\", prefix)\n-    }\n-}\n-\n impl UnwindKind {\n     /// Generates a branch going from `bcx` to `to_llbb` where `self` is\n     /// the exit label attached to the start of `bcx`."}, {"sha": "8ad951c5ade666f50f4d85c9b9d73d1fe6151782", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f8b0cd81eb3921890795537ba526d922e21fb1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c7f8b0cd81eb3921890795537ba526d922e21fb1", "patch": "@@ -238,7 +238,7 @@ fn trans_custom_dtor<'blk, 'tcx>(mut bcx: BlockAndBuilder<'blk, 'tcx>,\n     // might well consider changing below to more direct code.\n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    let mut contents_scope = if !shallow_drop {\n+    let contents_scope = if !shallow_drop {\n         bcx.fcx().schedule_drop_adt_contents(v0, t)\n     } else {\n         None\n@@ -269,10 +269,8 @@ fn trans_custom_dtor<'blk, 'tcx>(mut bcx: BlockAndBuilder<'blk, 'tcx>,\n     let callee = Callee::def(bcx.ccx(), dtor_did, vtbl.substs);\n     let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n     let llret;\n-    if contents_scope.is_some() && !bcx.sess().no_landing_pads() {\n+    if let Some(landing_pad) = contents_scope.as_ref().and_then(|c| c.landing_pad) {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad(contents_scope.as_mut().unwrap());\n-\n         llret = bcx.invoke(callee.reify(bcx.ccx()), args, normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {"}]}