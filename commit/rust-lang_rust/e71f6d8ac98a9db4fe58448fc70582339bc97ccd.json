{"sha": "e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MWY2ZDhhYzk4YTlkYjRmZTU4NDQ4ZmM3MDU4MjMzOWJjOTdjY2Q=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:38:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:41:04Z"}, "message": "trans: report as many errors as possible for constants.", "tree": {"sha": "65f7bb87be709437672d4c6ecea85d57e7b4fc21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65f7bb87be709437672d4c6ecea85d57e7b4fc21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "html_url": "https://github.com/rust-lang/rust/commit/e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d735f6bf33a8654e387d248f46e0ad6d98280a05", "url": "https://api.github.com/repos/rust-lang/rust/commits/d735f6bf33a8654e387d248f46e0ad6d98280a05", "html_url": "https://github.com/rust-lang/rust/commit/d735f6bf33a8654e387d248f46e0ad6d98280a05"}], "stats": {"total": 148, "additions": 107, "deletions": 41}, "files": [{"sha": "b404475b5844bba6cb7867b42ad0b3f055edb918", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 46, "deletions": 27, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n+use rustc_const_eval::ErrKind;\n use rustc::middle::lang_items;\n use rustc::ty;\n use rustc::mir::repr as mir;\n@@ -222,41 +223,47 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n \n                 // Don't translate the panic block if success if known.\n-                let lltarget = self.llblock(target);\n                 if const_cond == Some(expected) {\n-                    funclet_br(bcx, lltarget);\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n \n-                if const_cond == Some(!expected) {\n-                    // Do nothing to end up with an unconditional panic.\n+                // Pass the condition through llvm.expect for branch hinting.\n+                let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n+                let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx(), expected)], None);\n+\n+                // Create the failure block and the conditional branch to it.\n+                let lltarget = llblock(self, target);\n+                let panic_block = self.fcx.new_block(\"panic\", None);\n+                if expected {\n+                    bcx.cond_br(cond, lltarget, panic_block.llbb);\n                 } else {\n-                    // Pass the condition through llvm.expect for branch hinting.\n-                    let expect = bcx.ccx().get_intrinsic(&\"llvm.expect.i1\");\n-                    let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx(), expected)], None);\n-\n-                    // Create the failure block and the conditional branch to it.\n-                    // After this point, bcx is the block for the call to panic.\n-                    let panic_block = self.fcx.new_block(\"panic\", None);\n-                    if expected {\n-                        bcx.cond_br(cond, lltarget, panic_block.llbb);\n-                    } else {\n-                        bcx.cond_br(cond, panic_block.llbb, lltarget);\n-                    }\n-                    bcx = panic_block.build();\n+                    bcx.cond_br(cond, panic_block.llbb, lltarget);\n                 }\n \n+                // After this point, bcx is the block for the call to panic.\n+                bcx = panic_block.build();\n+\n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(terminator.span.lo);\n                 let filename = token::intern_and_get_ident(&loc.file.name);\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n \n                 // Put together the arguments to the panic entry point.\n-                let (lang_item, args) = match *msg {\n+                let (lang_item, args, const_err) = match *msg {\n                     mir::AssertMessage::BoundsCheck { ref len, ref index } => {\n-                        let len = self.trans_operand(&mut bcx, len);\n-                        let index = self.trans_operand(&mut bcx, index);\n+                        let len = self.trans_operand(&mut bcx, len).immediate();\n+                        let index = self.trans_operand(&mut bcx, index).immediate();\n+\n+                        let const_err = common::const_to_opt_uint(len).and_then(|len| {\n+                            common::const_to_opt_uint(index).map(|index| {\n+                                ErrKind::IndexOutOfBounds {\n+                                    len: len,\n+                                    index: index\n+                                }\n+                            })\n+                        });\n \n                         let file_line = C_struct(bcx.ccx(), &[filename, line], false);\n                         let align = llalign_of_min(bcx.ccx(), common::val_ty(file_line));\n@@ -265,7 +272,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                         align,\n                                                         \"panic_bounds_check_loc\");\n                         (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line, index.immediate(), len.immediate()])\n+                         vec![file_line, index, len],\n+                         const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = token::intern_and_get_ident(err.description());\n@@ -278,10 +286,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                             msg_file_line,\n                                                             align,\n                                                             \"panic_loc\");\n-                        (lang_items::PanicFnLangItem, vec![msg_file_line])\n+                        (lang_items::PanicFnLangItem,\n+                         vec![msg_file_line],\n+                         Some(ErrKind::Math(err.clone())))\n                     }\n                 };\n \n+                // If we know we always panic, and the error message\n+                // is also constant, then we can produce a warning.\n+                if const_cond == Some(!expected) {\n+                    if let Some(err) = const_err {\n+                        let _ = consts::const_err(bcx.ccx(),\n+                                                  terminator.span,\n+                                                  Err::<(), _>(err),\n+                                                  consts::TrueConst::No);\n+                    }\n+                }\n+\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(terminator.span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx(), def_id,\n@@ -290,15 +311,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Translate the actual panic invoke/call.\n                 if let Some(unwind) = cleanup {\n-                    let uwbcx = self.bcx(unwind);\n-                    let unwind = self.make_landing_pad(uwbcx);\n                     bcx.invoke(llfn,\n                                &args,\n                                self.unreachable_block().llbb,\n-                               unwind.llbb(),\n-                               cleanup_bundle.as_ref());\n+                               llblock(self, unwind),\n+                               cleanup_bundle);\n                 } else {\n-                    bcx.call(llfn, &args, cleanup_bundle.as_ref());\n+                    bcx.call(llfn, &args, cleanup_bundle);\n                     bcx.unreachable();\n                 }\n             }"}, {"sha": "d352a8241acd48a555c06a25b2640af35ba0c640", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "patch": "@@ -270,15 +270,22 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n         let tcx = self.ccx.tcx();\n         let mut bb = mir::START_BLOCK;\n+\n+        // Make sure to evaluate all statemenets to\n+        // report as many errors as we possibly can.\n+        let mut failure = Ok(());\n+\n         loop {\n             let data = self.mir.basic_block_data(bb);\n             for statement in &data.statements {\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n                         let ty = self.mir.lvalue_ty(tcx, dest);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        let value = self.const_rvalue(rvalue, ty, statement.span)?;\n-                        self.store(dest, value, statement.span);\n+                        match self.const_rvalue(rvalue, ty, statement.span) {\n+                            Ok(value) => self.store(dest, value, statement.span),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                     }\n                 }\n             }\n@@ -289,6 +296,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Drop { target, .. } | // No dropping.\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n+                    failure?;\n                     return Ok(self.return_value.unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n                     }))\n@@ -311,7 +319,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 ErrKind::Math(err.clone())\n                             }\n                         };\n-                        consts::const_err(self.ccx, span, Err(err), TrueConst::Yes)?;\n+                        match consts::const_err(self.ccx, span, Err(err), TrueConst::Yes) {\n+                            Ok(()) => {}\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                     }\n                     target\n                 }\n@@ -327,15 +338,21 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                        func, fn_ty)\n                     };\n \n-                    let args = args.iter().map(|arg| {\n-                        self.const_operand(arg, span)\n-                    }).collect::<Result<Vec<_>, _>>()?;\n-                    let value = MirConstContext::trans_def(self.ccx, instance, args)?;\n+                    let mut const_args = Vec::with_capacity(args.len());\n+                    for arg in args {\n+                        match self.const_operand(arg, span) {\n+                            Ok(arg) => const_args.push(arg),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n+                    }\n                     if let Some((ref dest, target)) = *destination {\n-                        self.store(dest, value, span);\n+                        match MirConstContext::trans_def(self.ccx, instance, const_args) {\n+                            Ok(value) => self.store(dest, value, span),\n+                            Err(err) => if failure.is_ok() { failure = Err(err); }\n+                        }\n                         target\n                     } else {\n-                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind)\n+                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind);\n                     }\n                 }\n                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n@@ -425,8 +442,16 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         } else {\n                             span_bug!(span, \"index is not an integer-constant expression\")\n                         };\n-                        (Base::Value(const_get_elt(base.llval, &[iv as u32])),\n-                         ptr::null_mut())\n+\n+                        // Produce an undef instead of a LLVM assertion on OOB.\n+                        let len = common::const_to_uint(tr_base.len(self.ccx));\n+                        let llelem = if iv < len {\n+                            const_get_elt(base.llval, &[iv as u32])\n+                        } else {\n+                            C_undef(type_of::type_of(self.ccx, projected_ty))\n+                        };\n+\n+                        (Base::Value(llelem), ptr::null_mut())\n                     }\n                     _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n                 };\n@@ -497,9 +522,17 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                let fields = operands.iter().map(|operand| {\n-                    Ok(self.const_operand(operand, span)?.llval)\n-                }).collect::<Result<Vec<_>, _>>()?;\n+                // Make sure to evaluate all operands to\n+                // report as many errors as we possibly can.\n+                let mut fields = Vec::with_capacity(operands.len());\n+                let mut failure = Ok(());\n+                for operand in operands {\n+                    match self.const_operand(operand, span) {\n+                        Ok(val) => fields.push(val.llval),\n+                        Err(err) => if failure.is_ok() { failure = Err(err); }\n+                    }\n+                }\n+                failure?;\n \n                 // FIXME Shouldn't need to manually trigger closure instantiations.\n                 if let mir::AggregateKind::Closure(def_id, substs) = *kind {"}, {"sha": "ba351d07016c5e84621b50de01a556de383d9cf5", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "patch": "@@ -27,6 +27,7 @@ use value::Value;\n use Disr;\n \n use super::MirContext;\n+use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n \n@@ -588,6 +589,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             return OperandValue::Pair(val, C_bool(bcx.ccx(), false));\n         }\n \n+        // First try performing the operation on constants, which\n+        // will only succeed if both operands are constant.\n+        // This is necessary to determine when an overflow Assert\n+        // will always panic at runtime, and produce a warning.\n+        match const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n+            Some((val, of)) => {\n+                return OperandValue::Pair(val, C_bool(bcx.ccx(), of));\n+            }\n+            None => {}\n+        }\n+\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {"}, {"sha": "a1d3888e78ea0dc16fe3d9cd6bd454a0764fc51e", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71f6d8ac98a9db4fe58448fc70582339bc97ccd/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=e71f6d8ac98a9db4fe58448fc70582339bc97ccd", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Zforce-overflow-checks=on\n+\n // these errors are not actually \"const_err\", they occur in trans/consts\n // and are unconditional warnings that can't be denied or allowed\n "}]}