{"sha": "5a501f73ff753109c7e73d4981fe011633bd8e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTAxZjczZmY3NTMxMDljN2U3M2Q0OTgxZmUwMTE2MzNiZDhlODQ=", "commit": {"author": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-08-22T19:46:03Z"}, "committer": {"name": "Andreas Liljeqvist", "email": "bonega@gmail.com", "date": "2021-08-22T19:46:03Z"}, "message": "Use custom wrap-around type instead of Range", "tree": {"sha": "4e687cca63f5373b65fc93056107eafcb2756e86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e687cca63f5373b65fc93056107eafcb2756e86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a501f73ff753109c7e73d4981fe011633bd8e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a501f73ff753109c7e73d4981fe011633bd8e84", "html_url": "https://github.com/rust-lang/rust/commit/5a501f73ff753109c7e73d4981fe011633bd8e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a501f73ff753109c7e73d4981fe011633bd8e84/comments", "author": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bonega", "id": 411677, "node_id": "MDQ6VXNlcjQxMTY3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/411677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonega", "html_url": "https://github.com/bonega", "followers_url": "https://api.github.com/users/bonega/followers", "following_url": "https://api.github.com/users/bonega/following{/other_user}", "gists_url": "https://api.github.com/users/bonega/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonega/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonega/subscriptions", "organizations_url": "https://api.github.com/users/bonega/orgs", "repos_url": "https://api.github.com/users/bonega/repos", "events_url": "https://api.github.com/users/bonega/events{/privacy}", "received_events_url": "https://api.github.com/users/bonega/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7481e6d1a415853a96dcec11a052caaa02859b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7481e6d1a415853a96dcec11a052caaa02859b5a", "html_url": "https://github.com/rust-lang/rust/commit/7481e6d1a415853a96dcec11a052caaa02859b5a"}], "stats": {"total": 371, "additions": 255, "deletions": 116}, "files": [{"sha": "2b72b16742630415734e83789c0918d2dd11412f", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -462,15 +462,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             load: &'ll Value,\n             scalar: &abi::Scalar,\n         ) {\n-            let vr = scalar.valid_range.clone();\n+            let vr = scalar.valid_range;\n             match scalar.value {\n                 abi::Int(..) => {\n                     let range = scalar.valid_range_exclusive(bx);\n                     if range.start != range.end {\n                         bx.range_metadata(load, range);\n                     }\n                 }\n-                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                abi::Pointer if vr.start < vr.end && !vr.contains(0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}"}, {"sha": "01a93dd8857c29fd033cf2a209db11a8d27b3a0a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -16,7 +16,9 @@ use rustc_middle::mir::interpret::{\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n-use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use rustc_target::abi::{\n+    AddressSpace, Align, AllocationRange, HasDataLayout, LayoutOf, Primitive, Scalar, Size,\n+};\n use tracing::debug;\n \n pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n@@ -59,7 +61,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n                 Pointer::new(alloc_id, Size::from_bytes(ptr_offset)),\n                 &cx.tcx,\n             ),\n-            &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n+            &Scalar {\n+                value: Primitive::Pointer,\n+                valid_range: AllocationRange { start: 0, end: !0 },\n+            },\n             cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;"}, {"sha": "f0b32c96309d629f90e66a6aaa94c71967404753", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -406,11 +406,11 @@ fn push_debuginfo_type_name<'tcx>(\n             let dataful_discriminant_range =\n                 &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n \n-            let min = dataful_discriminant_range.start();\n-            let min = tag.value.size(&tcx).truncate(*min);\n+            let min = dataful_discriminant_range.start;\n+            let min = tag.value.size(&tcx).truncate(min);\n \n-            let max = dataful_discriminant_range.end();\n-            let max = tag.value.size(&tcx).truncate(*max);\n+            let max = dataful_discriminant_range.end;\n+            let max = tag.value.size(&tcx).truncate(max);\n \n             let dataful_variant_name = def.variants[*dataful_variant].ident.as_str();\n "}, {"sha": "90a29f24b8e0aa81dbc9f59e3f651f7b231b46c6", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -310,15 +310,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                                 let er = scalar.valid_range_exclusive(bx.cx());\n                                 if er.end != er.start\n-                                    && scalar.valid_range.end() >= scalar.valid_range.start()\n+                                    && scalar.valid_range.end >= scalar.valid_range.start\n                                 {\n                                     // We want `table[e as usize \u00b1 k]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`s.\n-                                    if *scalar.valid_range.start() > 0 {\n+                                    if scalar.valid_range.start > 0 {\n                                         let enum_value_lower_bound = bx\n                                             .cx()\n-                                            .const_uint_big(ll_t_in, *scalar.valid_range.start());\n+                                            .const_uint_big(ll_t_in, scalar.valid_range.start);\n                                         let cmp_start = bx.icmp(\n                                             IntPredicate::IntUGE,\n                                             llval,\n@@ -328,7 +328,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n \n                                     let enum_value_upper_bound =\n-                                        bx.cx().const_uint_big(ll_t_in, *scalar.valid_range.end());\n+                                        bx.cx().const_uint_big(ll_t_in, scalar.valid_range.end);\n                                     let cmp_end = bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,"}, {"sha": "82a23da3ed9cad67c159a4e654c4e35e0e948591", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -797,7 +797,7 @@ crate fn repr_nullable_ptr<'tcx>(\n         // Return the nullable type this Option-like enum can be safely represented with.\n         let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n         if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n-            match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n+            match (field_ty_scalar.valid_range.start, field_ty_scalar.valid_range.end) {\n                 (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n                 (1, _) => {\n                     return Some(get_nullable_type(cx, field_ty).unwrap());"}, {"sha": "3b1990a3e675ab5d9730c48ba1a74da329fff2db", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -499,7 +499,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let scalar_unit = |value: Primitive| {\n             let bits = value.size(dl).bits();\n             assert!(bits <= 128);\n-            Scalar { value, valid_range: 0..=(!0 >> (128 - bits)) }\n+            Scalar { value, valid_range: AllocationRange { start: 0, end: (!0 >> (128 - bits)) } }\n         };\n         let scalar = |value: Primitive| tcx.intern_layout(Layout::scalar(self, scalar_unit(value)));\n \n@@ -512,11 +512,14 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             // Basic scalars.\n             ty::Bool => tcx.intern_layout(Layout::scalar(\n                 self,\n-                Scalar { value: Int(I8, false), valid_range: 0..=1 },\n+                Scalar { value: Int(I8, false), valid_range: AllocationRange { start: 0, end: 1 } },\n             )),\n             ty::Char => tcx.intern_layout(Layout::scalar(\n                 self,\n-                Scalar { value: Int(I32, false), valid_range: 0..=0x10FFFF },\n+                Scalar {\n+                    value: Int(I32, false),\n+                    valid_range: AllocationRange { start: 0, end: 0x10FFFF },\n+                },\n             )),\n             ty::Int(ity) => scalar(Int(Integer::from_int_ty(dl, ity), true)),\n             ty::Uint(ity) => scalar(Int(Integer::from_uint_ty(dl, ity), false)),\n@@ -526,7 +529,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range = 1..=*ptr.valid_range.end();\n+                ptr.valid_range = AllocationRange { start: 1, end: ptr.valid_range.end };\n                 tcx.intern_layout(Layout::scalar(self, ptr))\n             }\n \n@@ -544,7 +547,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n+                    data_ptr.valid_range =\n+                        AllocationRange { start: 1, end: data_ptr.valid_range.end };\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -560,7 +564,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     ty::Slice(_) | ty::Str => scalar_unit(Int(dl.ptr_sized_integer(), false)),\n                     ty::Dynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range = 1..=*vtable.valid_range.end();\n+                        vtable.valid_range =\n+                            AllocationRange { start: 1, end: vtable.valid_range.end };\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part)),\n@@ -933,14 +938,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                             if let Bound::Included(start) = start {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(*scalar.valid_range.start() <= start);\n-                                scalar.valid_range = start..=*scalar.valid_range.end();\n+                                assert!(scalar.valid_range.start <= start);\n+                                // scalar.valid_range =\n+                                //     AllocationRange { start, end: scalar.valid_range.end };\n+                                scalar.valid_range.start = start;\n                             }\n                             if let Bound::Included(end) = end {\n                                 // FIXME(eddyb) this might be incorrect - it doesn't\n                                 // account for wrap-around (end < start) ranges.\n-                                assert!(*scalar.valid_range.end() >= end);\n-                                scalar.valid_range = *scalar.valid_range.start()..=end;\n+                                assert!(scalar.valid_range.end >= end);\n+                                // scalar.valid_range =\n+                                //     AllocationRange { start: scalar.valid_range.start, end };\n+                                scalar.valid_range.end = end;\n                             }\n \n                             // Update `largest_niche` if we have introduced a larger niche.\n@@ -1256,7 +1265,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 let tag_mask = !0u128 >> (128 - ity.size().bits());\n                 let tag = Scalar {\n                     value: Int(ity, signed),\n-                    valid_range: (min as u128 & tag_mask)..=(max as u128 & tag_mask),\n+                    valid_range: AllocationRange {\n+                        start: (min as u128 & tag_mask),\n+                        end: (max as u128 & tag_mask),\n+                    },\n                 };\n                 let mut abi = Abi::Aggregate { sized: true };\n                 if tag.value.size(dl) == size {\n@@ -1535,7 +1547,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let tag = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n+        let tag = Scalar {\n+            value: Primitive::Int(discr_int, false),\n+            valid_range: AllocationRange { start: 0, end: max_discr },\n+        };\n         let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n         let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n@@ -2846,8 +2861,8 @@ where\n                 return;\n             }\n \n-            if scalar.valid_range.start() < scalar.valid_range.end() {\n-                if *scalar.valid_range.start() > 0 {\n+            if scalar.valid_range.start < scalar.valid_range.end {\n+                if scalar.valid_range.start > 0 {\n                     attrs.set(ArgAttribute::NonNull);\n                 }\n             }"}, {"sha": "71e616ff560c0cef0ef590cb10133baa6722e2d5", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -7,15 +7,16 @@\n use std::convert::TryFrom;\n use std::fmt::Write;\n use std::num::NonZeroUsize;\n-use std::ops::RangeInclusive;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, LayoutOf, Scalar as ScalarAbi, Size, VariantIdx, Variants};\n+use rustc_target::abi::{\n+    Abi, AllocationRange, LayoutOf, Scalar as ScalarAbi, Size, VariantIdx, Variants,\n+};\n \n use std::hash::Hash;\n \n@@ -181,22 +182,10 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n     }\n }\n \n-// Test if a range that wraps at overflow contains `test`\n-fn wrapping_range_contains(r: &RangeInclusive<u128>, test: u128) -> bool {\n-    let (lo, hi) = r.clone().into_inner();\n-    if lo > hi {\n-        // Wrapped\n-        (..=hi).contains(&test) || (lo..).contains(&test)\n-    } else {\n-        // Normal\n-        r.contains(&test)\n-    }\n-}\n-\n // Formats such that a sentence like \"expected something {}\" to mean\n // \"expected something <in the given range>\" makes sense.\n-fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n-    let (lo, hi) = r.clone().into_inner();\n+fn wrapping_range_format(r: AllocationRange, max_hi: u128) -> String {\n+    let AllocationRange { start: lo, end: hi } = r;\n     assert!(hi <= max_hi);\n     if lo > hi {\n         format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n@@ -634,8 +623,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         scalar_layout: &ScalarAbi,\n     ) -> InterpResult<'tcx> {\n         let value = self.read_scalar(op)?;\n-        let valid_range = &scalar_layout.valid_range;\n-        let (lo, hi) = valid_range.clone().into_inner();\n+        let valid_range = scalar_layout.valid_range;\n+        let AllocationRange { start: lo, end: hi } = valid_range;\n         // Determine the allowed range\n         // `max_hi` is as big as the size fits\n         let max_hi = u128::MAX >> (128 - op.layout.size.bits());\n@@ -684,7 +673,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             Ok(int) => int.assert_bits(op.layout.size),\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n-        if wrapping_range_contains(&valid_range, bits) {\n+        if valid_range.contains(bits) {\n             Ok(())\n         } else {\n             throw_validation_failure!(self.path,"}, {"sha": "07687a4b104cfb9b9605a6452a26e28728f726b4", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -677,32 +677,52 @@ impl Primitive {\n     }\n }\n \n+/// Inclusive wrap-around range of valid values, that is, if\n+/// start > end, it represents `start..=MAX`,\n+/// followed by `0..=end`.\n+///\n+/// That is, for an i8 primitive, a range of `254..=2` means following\n+/// sequence:\n+///\n+///    254 (-2), 255 (-1), 0, 1, 2\n+///\n+/// This is intended specifically to mirror LLVM\u2019s `!range` metadata,\n+/// semantics.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n+pub struct AllocationRange {\n+    pub start: u128,\n+    pub end: u128,\n+}\n+\n+impl AllocationRange {\n+    /// Returns `true` if `v` is contained in the range.\n+    #[inline]\n+    pub fn contains(&self, v: u128) -> bool {\n+        if self.start <= self.end {\n+            self.start <= v && v <= self.end\n+        } else {\n+            self.start <= v || v <= self.end\n+        }\n+    }\n+}\n+\n /// Information about one scalar component of a Rust type.\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub struct Scalar {\n     pub value: Primitive,\n \n-    /// Inclusive wrap-around range of valid values, that is, if\n-    /// start > end, it represents `start..=MAX`,\n-    /// followed by `0..=end`.\n-    ///\n-    /// That is, for an i8 primitive, a range of `254..=2` means following\n-    /// sequence:\n-    ///\n-    ///    254 (-2), 255 (-1), 0, 1, 2\n-    ///\n-    /// This is intended specifically to mirror LLVM\u2019s `!range` metadata,\n-    /// semantics.\n     // FIXME(eddyb) always use the shortest range, e.g., by finding\n     // the largest space between two consecutive valid values and\n     // taking everything else as the (shortest) valid range.\n-    pub valid_range: RangeInclusive<u128>,\n+    pub valid_range: AllocationRange,\n }\n \n impl Scalar {\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.value, Int(I8, false)) && self.valid_range == (0..=1)\n+        matches!(self.value, Int(I8, false))\n+            && matches!(self.valid_range, AllocationRange { start: 0, end: 1 })\n     }\n \n     /// Returns the valid range as a `x..y` range.\n@@ -715,8 +735,8 @@ impl Scalar {\n         let bits = self.value.size(cx).bits();\n         assert!(bits <= 128);\n         let mask = !0u128 >> (128 - bits);\n-        let start = *self.valid_range.start();\n-        let end = *self.valid_range.end();\n+        let start = self.valid_range.start;\n+        let end = self.valid_range.end;\n         assert_eq!(start, start & mask);\n         assert_eq!(end, end & mask);\n         start..(end.wrapping_add(1) & mask)\n@@ -965,20 +985,20 @@ impl Niche {\n     }\n \n     pub fn available<C: HasDataLayout>(&self, cx: &C) -> u128 {\n-        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let Scalar { value, valid_range: v } = self.scalar;\n         let bits = value.size(cx).bits();\n         assert!(bits <= 128);\n         let max_value = !0u128 >> (128 - bits);\n \n         // Find out how many values are outside the valid range.\n-        let niche = v.end().wrapping_add(1)..*v.start();\n+        let niche = v.end.wrapping_add(1)..v.start;\n         niche.end.wrapping_sub(niche.start) & max_value\n     }\n \n     pub fn reserve<C: HasDataLayout>(&self, cx: &C, count: u128) -> Option<(u128, Scalar)> {\n         assert!(count > 0);\n \n-        let Scalar { value, valid_range: ref v } = self.scalar;\n+        let Scalar { value, valid_range: v } = self.scalar;\n         let bits = value.size(cx).bits();\n         assert!(bits <= 128);\n         let max_value = !0u128 >> (128 - bits);\n@@ -988,24 +1008,17 @@ impl Niche {\n         }\n \n         // Compute the range of invalid values being reserved.\n-        let start = v.end().wrapping_add(1) & max_value;\n-        let end = v.end().wrapping_add(count) & max_value;\n+        let start = v.end.wrapping_add(1) & max_value;\n+        let end = v.end.wrapping_add(count) & max_value;\n \n         // If the `end` of our range is inside the valid range,\n         // then we ran out of invalid values.\n         // FIXME(eddyb) abstract this with a wraparound range type.\n-        let valid_range_contains = |x| {\n-            if v.start() <= v.end() {\n-                *v.start() <= x && x <= *v.end()\n-            } else {\n-                *v.start() <= x || x <= *v.end()\n-            }\n-        };\n-        if valid_range_contains(end) {\n+        if v.contains(end) {\n             return None;\n         }\n \n-        Some((start, Scalar { value, valid_range: *v.start()..=end }))\n+        Some((start, Scalar { value, valid_range: AllocationRange { start: v.start, end } }))\n     }\n }\n \n@@ -1214,7 +1227,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n             if zero {\n                 let range = &s.valid_range;\n                 // The range must contain 0.\n-                range.contains(&0) || (*range.start() > *range.end()) // wrap-around allows 0\n+                range.contains(0) || (range.start > range.end) // wrap-around allows 0\n             } else {\n                 // The range must include all values. `valid_range_exclusive` handles\n                 // the wrap-around using target arithmetic; with wrap-around then the full"}, {"sha": "41de900f1640a3afaf4494c7e8d2d697bef028f8", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -52,7 +52,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:41:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range AllocationRange { start: 10, end: 30 }\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "cbe9b6400c35fad07cb6bab1aa9437969b2c5547", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -15,7 +15,10 @@ error: layout_of(E) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 0..=0,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 0,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -91,7 +94,10 @@ error: layout_of(E) = Layout {\n                     I32,\n                     false,\n                 ),\n-                valid_range: 0..=0,\n+                valid_range: AllocationRange {\n+                    start: 0,\n+                    end: 0,\n+                },\n             },\n         },\n     ),\n@@ -138,14 +144,20 @@ error: layout_of(S) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 0..=4294967295,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 4294967295,\n+            },\n         },\n         Scalar {\n             value: Int(\n                 I32,\n                 true,\n             ),\n-            valid_range: 0..=4294967295,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 4294967295,\n+            },\n         },\n     ),\n     largest_niche: None,\n@@ -207,7 +219,10 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 0..=1,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 1,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -276,14 +291,20 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 0..=1,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 1,\n+            },\n         },\n         Scalar {\n             value: Int(\n                 I32,\n                 true,\n             ),\n-            valid_range: 0..=4294967295,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 4294967295,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -296,7 +317,10 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                     I32,\n                     false,\n                 ),\n-                valid_range: 0..=1,\n+                valid_range: AllocationRange {\n+                    start: 0,\n+                    end: 1,\n+                },\n             },\n         },\n     ),\n@@ -326,7 +350,10 @@ error: layout_of(i32) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 0..=4294967295,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 4294967295,\n+            },\n         },\n     ),\n     largest_niche: None,"}, {"sha": "520ba12c39fb1058256e4f99a16443101ab85bef", "filename": "src/test/ui/layout/hexagon-enum.stderr", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -15,7 +15,10 @@ error: layout_of(A) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 0..=0,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 0,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -52,7 +55,10 @@ error: layout_of(A) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 0..=0,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 0,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -65,7 +71,10 @@ error: layout_of(A) = Layout {\n                     I8,\n                     false,\n                 ),\n-                valid_range: 0..=0,\n+                valid_range: AllocationRange {\n+                    start: 0,\n+                    end: 0,\n+                },\n             },\n         },\n     ),\n@@ -103,7 +112,10 @@ error: layout_of(B) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 255..=255,\n+            valid_range: AllocationRange {\n+                start: 255,\n+                end: 255,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -140,7 +152,10 @@ error: layout_of(B) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 255..=255,\n+            valid_range: AllocationRange {\n+                start: 255,\n+                end: 255,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -153,7 +168,10 @@ error: layout_of(B) = Layout {\n                     I8,\n                     false,\n                 ),\n-                valid_range: 255..=255,\n+                valid_range: AllocationRange {\n+                    start: 255,\n+                    end: 255,\n+                },\n             },\n         },\n     ),\n@@ -191,7 +209,10 @@ error: layout_of(C) = Layout {\n                 I16,\n                 false,\n             ),\n-            valid_range: 256..=256,\n+            valid_range: AllocationRange {\n+                start: 256,\n+                end: 256,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -228,7 +249,10 @@ error: layout_of(C) = Layout {\n                 I16,\n                 false,\n             ),\n-            valid_range: 256..=256,\n+            valid_range: AllocationRange {\n+                start: 256,\n+                end: 256,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -241,7 +265,10 @@ error: layout_of(C) = Layout {\n                     I16,\n                     false,\n                 ),\n-                valid_range: 256..=256,\n+                valid_range: AllocationRange {\n+                    start: 256,\n+                    end: 256,\n+                },\n             },\n         },\n     ),\n@@ -279,7 +306,10 @@ error: layout_of(P) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 268435456..=268435456,\n+            valid_range: AllocationRange {\n+                start: 268435456,\n+                end: 268435456,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -316,7 +346,10 @@ error: layout_of(P) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 268435456..=268435456,\n+            valid_range: AllocationRange {\n+                start: 268435456,\n+                end: 268435456,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -329,7 +362,10 @@ error: layout_of(P) = Layout {\n                     I32,\n                     false,\n                 ),\n-                valid_range: 268435456..=268435456,\n+                valid_range: AllocationRange {\n+                    start: 268435456,\n+                    end: 268435456,\n+                },\n             },\n         },\n     ),\n@@ -367,7 +403,10 @@ error: layout_of(T) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 2164260864..=2164260864,\n+            valid_range: AllocationRange {\n+                start: 2164260864,\n+                end: 2164260864,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -404,7 +443,10 @@ error: layout_of(T) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 2164260864..=2164260864,\n+            valid_range: AllocationRange {\n+                start: 2164260864,\n+                end: 2164260864,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -417,7 +459,10 @@ error: layout_of(T) = Layout {\n                     I32,\n                     true,\n                 ),\n-                valid_range: 2164260864..=2164260864,\n+                valid_range: AllocationRange {\n+                    start: 2164260864,\n+                    end: 2164260864,\n+                },\n             },\n         },\n     ),"}, {"sha": "50e37c5411632e9c54c1091ed957fd284d1816ba", "filename": "src/test/ui/layout/thumb-enum.stderr", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a501f73ff753109c7e73d4981fe011633bd8e84/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr?ref=5a501f73ff753109c7e73d4981fe011633bd8e84", "patch": "@@ -15,7 +15,10 @@ error: layout_of(A) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 0..=0,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 0,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -52,7 +55,10 @@ error: layout_of(A) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 0..=0,\n+            valid_range: AllocationRange {\n+                start: 0,\n+                end: 0,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -65,7 +71,10 @@ error: layout_of(A) = Layout {\n                     I8,\n                     false,\n                 ),\n-                valid_range: 0..=0,\n+                valid_range: AllocationRange {\n+                    start: 0,\n+                    end: 0,\n+                },\n             },\n         },\n     ),\n@@ -103,7 +112,10 @@ error: layout_of(B) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 255..=255,\n+            valid_range: AllocationRange {\n+                start: 255,\n+                end: 255,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -140,7 +152,10 @@ error: layout_of(B) = Layout {\n                 I8,\n                 false,\n             ),\n-            valid_range: 255..=255,\n+            valid_range: AllocationRange {\n+                start: 255,\n+                end: 255,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -153,7 +168,10 @@ error: layout_of(B) = Layout {\n                     I8,\n                     false,\n                 ),\n-                valid_range: 255..=255,\n+                valid_range: AllocationRange {\n+                    start: 255,\n+                    end: 255,\n+                },\n             },\n         },\n     ),\n@@ -191,7 +209,10 @@ error: layout_of(C) = Layout {\n                 I16,\n                 false,\n             ),\n-            valid_range: 256..=256,\n+            valid_range: AllocationRange {\n+                start: 256,\n+                end: 256,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -228,7 +249,10 @@ error: layout_of(C) = Layout {\n                 I16,\n                 false,\n             ),\n-            valid_range: 256..=256,\n+            valid_range: AllocationRange {\n+                start: 256,\n+                end: 256,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -241,7 +265,10 @@ error: layout_of(C) = Layout {\n                     I16,\n                     false,\n                 ),\n-                valid_range: 256..=256,\n+                valid_range: AllocationRange {\n+                    start: 256,\n+                    end: 256,\n+                },\n             },\n         },\n     ),\n@@ -279,7 +306,10 @@ error: layout_of(P) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 268435456..=268435456,\n+            valid_range: AllocationRange {\n+                start: 268435456,\n+                end: 268435456,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -316,7 +346,10 @@ error: layout_of(P) = Layout {\n                 I32,\n                 false,\n             ),\n-            valid_range: 268435456..=268435456,\n+            valid_range: AllocationRange {\n+                start: 268435456,\n+                end: 268435456,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -329,7 +362,10 @@ error: layout_of(P) = Layout {\n                     I32,\n                     false,\n                 ),\n-                valid_range: 268435456..=268435456,\n+                valid_range: AllocationRange {\n+                    start: 268435456,\n+                    end: 268435456,\n+                },\n             },\n         },\n     ),\n@@ -367,7 +403,10 @@ error: layout_of(T) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 2164260864..=2164260864,\n+            valid_range: AllocationRange {\n+                start: 2164260864,\n+                end: 2164260864,\n+            },\n         },\n         tag_encoding: Direct,\n         tag_field: 0,\n@@ -404,7 +443,10 @@ error: layout_of(T) = Layout {\n                 I32,\n                 true,\n             ),\n-            valid_range: 2164260864..=2164260864,\n+            valid_range: AllocationRange {\n+                start: 2164260864,\n+                end: 2164260864,\n+            },\n         },\n     ),\n     largest_niche: Some(\n@@ -417,7 +459,10 @@ error: layout_of(T) = Layout {\n                     I32,\n                     true,\n                 ),\n-                valid_range: 2164260864..=2164260864,\n+                valid_range: AllocationRange {\n+                    start: 2164260864,\n+                    end: 2164260864,\n+                },\n             },\n         },\n     ),"}]}