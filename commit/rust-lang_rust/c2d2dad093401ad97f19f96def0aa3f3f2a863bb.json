{"sha": "c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZDJkYWQwOTM0MDFhZDk3ZjE5Zjk2ZGVmMGFhM2YzZjJhODYzYmI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-18T18:46:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-18T20:09:50Z"}, "message": "Remove ast::ty_vec", "tree": {"sha": "5ff3de54979a559df498e5c545fb02b3a348fd1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ff3de54979a559df498e5c545fb02b3a348fd1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "html_url": "https://github.com/rust-lang/rust/commit/c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec898244f7b543dfe4c5a04fd42e638d7c521f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec898244f7b543dfe4c5a04fd42e638d7c521f7b", "html_url": "https://github.com/rust-lang/rust/commit/ec898244f7b543dfe4c5a04fd42e638d7c521f7b"}], "stats": {"total": 162, "additions": 5, "deletions": 157}, "files": [{"sha": "108ba079928ffccf7d798dffbb3da98e5c37d71b", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -217,7 +217,6 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n       '@' { ret ty::mk_box(st.tcx, parse_mt(st, sd)); }\n       '~' { ret ty::mk_uniq(st.tcx, parse_ty(st, sd)); }\n       '*' { ret ty::mk_ptr(st.tcx, parse_mt(st, sd)); }\n-      'V' { ret ty::mk_vec(st.tcx, parse_mt(st, sd)); }\n       'I' { ret ty::mk_ivec(st.tcx, parse_mt(st, sd)); }\n       'R' {\n         assert (next(st) as char == '[');"}, {"sha": "b85e3a716957fbc6ca5edc5fe544293dc11e8cd4", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -128,7 +128,6 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       ty::ty_box(mt) { w.write_char('@'); enc_mt(w, cx, mt); }\n       ty::ty_uniq(t) { w.write_char('~'); enc_ty(w, cx, t); }\n       ty::ty_ptr(mt) { w.write_char('*'); enc_mt(w, cx, mt); }\n-      ty::ty_vec(mt) { w.write_char('V'); enc_mt(w, cx, mt); }\n       ty::ty_ivec(mt) { w.write_char('I'); enc_mt(w, cx, mt); }\n       ty::ty_rec(fields) {\n         w.write_str(\"R[\");"}, {"sha": "0fb044dfc963547eb17724217f9eda45e0cbaa1b", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -364,7 +364,7 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n     alt ty::struct(cx.tcx, seq_t) {\n-      ty::ty_vec(mt) | ty::ty_ivec(mt) {\n+      ty::ty_ivec(mt) {\n         if mt.mut != ast::imm { unsafe = ~[seq_t]; }\n       }\n       ty::ty_str. | ty::ty_istr. {/* no-op */ }\n@@ -584,12 +584,6 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n           ast::expr_index(base, _) {\n             let auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n             alt ty::struct(cx.tcx, auto_unbox.t) {\n-              ty::ty_vec(mt) {\n-                ds +=\n-                    ~[@{mut: mt.mut != ast::imm,\n-                        kind: index,\n-                        outer_t: auto_unbox.t}];\n-              }\n               ty::ty_ivec(mt) {\n                 ds +=\n                     ~[@{mut: mt.mut != ast::imm,\n@@ -666,7 +660,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n             }\n             ret false;\n           }\n-          ty::ty_box(mt) | ty::ty_vec(mt) | ty::ty_ptr(mt) {\n+          ty::ty_box(mt) | ty::ty_ptr(mt) {\n             ret helper(tcx, needle, mt.ty, get_mut(mut, mt));\n           }\n           ty::ty_uniq(t) { ret helper(tcx, needle, t, false); }"}, {"sha": "082d1588a845d7d17c753d4b884784132c02d158", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -130,7 +130,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n         ty::ty_ivec(tm) { ret type_is_gc_relevant(cx, tm.ty); }\n         ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n \n-        ty::ty_str. | ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_vec(_) |\n+        ty::ty_str. | ty::ty_box(_) | ty::ty_uniq(_) |\n         ty::ty_fn(_,_,_,_,_) | ty::ty_native_fn(_,_,_) | ty::ty_obj(_) |\n         ty::ty_param(_,_) | ty::ty_res(_,_,_) { ret true; }\n "}, {"sha": "767f545771df552d2b016de5cea73a54b3f7bcf6", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -343,11 +343,6 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n         s += ~[shape_uniq];\n         add_substr(s, shape_of(ccx, subt));\n       }\n-      ty::ty_vec(mt) {\n-        s += ~[shape_evec];\n-        add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_substr(s, shape_of(ccx, mt.ty));\n-      }\n       ty::ty_ivec(mt) {\n         s += ~[shape_ivec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));"}, {"sha": "5370982c32589532b20f7ef22b08faf50d577780", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -214,7 +214,6 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n       ty::ty_tag(did, _) { llty = type_of_tag(cx, sp, did, t); }\n       ty::ty_box(mt) { llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty))); }\n       ty::ty_uniq(t) { llty = T_ptr(type_of_inner(cx, sp, t)); }\n-      ty::ty_vec(mt) { llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty))); }\n       ty::ty_ivec(mt) {\n         if ty::type_has_dynamic_size(cx.tcx, mt.ty) {\n             llty = T_opaque_ivec();\n@@ -501,7 +500,6 @@ fn simplify_type(ccx: &@crate_ctxt, typ: &ty::t) -> ty::t {\n         alt ty::struct(ccx.tcx, typ) {\n           ty::ty_box(_) { ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n           ty::ty_uniq(_) { ret ty::mk_uniq(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n-          ty::ty_vec(_) { ret ty::mk_imm_vec(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n           ty::ty_fn(_, _, _, _, _) {\n             ret ty::mk_tup(ccx.tcx,\n                            ~[ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n@@ -1318,15 +1316,6 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n                 rslt(cx, C_nil())\n             }\n           }\n-          ty::ty_vec(_) {\n-            let v = cx.build.Load(v0);\n-            let rs = iter_sequence(cx, v, t, bind drop_ty(_, _, _));\n-            if !bcx_ccx(cx).sess.get_opts().do_gc {\n-                trans_non_gc_free(rs.bcx, v)\n-            } else {\n-                rslt(cx, C_nil())\n-            }\n-          }\n           ty::ty_box(body_mt) {\n             let v = cx.build.Load(v0);\n             let body =\n@@ -1430,7 +1419,6 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n     let rs =\n         alt ty::struct(ccx.tcx, t) {\n           ty::ty_str. { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_vec(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n           ty::ty_ivec(tm) {\n             let v1;\n             if ty::type_has_dynamic_size(ccx.tcx, tm.ty) {\n@@ -1981,9 +1969,6 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: &ty::t, f: &val_and_ty_fn)\n \n \n     alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_vec(elt) {\n-        ret iter_sequence_body(cx, v, elt.ty, f, false, false);\n-      }\n       ty::ty_str. {\n         let et = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n         ret iter_sequence_body(cx, v, et, f, true, false);\n@@ -4776,65 +4761,6 @@ fn trans_tup(cx: &@block_ctxt, elts: &[@ast::expr], id: ast::node_id)\n     ret rslt(bcx, tup_val);\n }\n \n-fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n-   result {\n-    let t = node_id_type(bcx_ccx(cx), id);\n-    let unit_ty = t;\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_vec(mt) { unit_ty = mt.ty; }\n-      _ { bcx_ccx(cx).sess.bug(\"non-vec type in trans_vec\"); }\n-    }\n-    let bcx = cx;\n-    let unit_sz = size_of(bcx, unit_ty);\n-    bcx = unit_sz.bcx;\n-    let data_sz =\n-        bcx.build.Mul(C_uint(std::vec::len::<@ast::expr>(args)), unit_sz.val);\n-    // FIXME: pass tydesc properly.\n-\n-    let vec_val =\n-        bcx.build.Call(bcx_ccx(bcx).upcalls.new_vec,\n-                       ~[bcx.fcx.lltaskptr, data_sz,\n-                         C_null(T_ptr(bcx_ccx(bcx).tydesc_type))]);\n-    let llty = type_of(bcx_ccx(bcx), bcx.sp, t);\n-    vec_val = bcx.build.PointerCast(vec_val, llty);\n-    add_clean_temp(bcx, vec_val, t);\n-    let body = bcx.build.GEP(vec_val, ~[C_int(0), C_int(abi::vec_elt_data)]);\n-    let pseudo_tup_ty =\n-        ty::mk_tup(bcx_tcx(cx),\n-                       std::vec::init_elt::<ty::t>(unit_ty,\n-                                                  std::vec::len(args)));\n-    let i: int = 0;\n-    for e: @ast::expr in args {\n-        let src = trans_lval(bcx, e);\n-        bcx = src.res.bcx;\n-        let dst_res = GEP_tup_like(bcx, pseudo_tup_ty, body, ~[0, i]);\n-        bcx = dst_res.bcx;\n-        // Cast the destination type to the source type. This is needed to\n-        // make tags work, for a subtle combination of reasons:\n-        //\n-        // (1) \"dst_res\" above is derived from \"body\", which is in turn\n-        //     derived from \"vec_val\".\n-        // (2) \"vec_val\" has the LLVM type \"llty\".\n-        // (3) \"llty\" is the result of calling type_of() on a vector type.\n-        // (4) For tags, type_of() returns a different type depending on\n-        //     on whether the tag is behind a box or not. Vector types are\n-        //     considered boxes.\n-        // (5) \"src_res\" is derived from \"unit_ty\", which is not behind a box.\n-\n-        let dst_val;\n-        if !ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-            let llunit_ty = type_of(bcx_ccx(cx), bcx.sp, unit_ty);\n-            dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n-        } else { dst_val = dst_res.val; }\n-        bcx = move_val_if_temp(bcx, INIT, dst_val, src, unit_ty).bcx;\n-        i += 1;\n-    }\n-    let fill = bcx.build.GEP(vec_val, ~[C_int(0), C_int(abi::vec_elt_fill)]);\n-    bcx.build.Store(data_sz, fill);\n-    ret rslt(bcx, vec_val);\n-}\n-\n-\n // TODO: Move me to ivec::\n fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n    result {"}, {"sha": "a19b508c4d75fa5da5b7990cefd774ce99e42957", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -89,7 +89,6 @@ export mk_type;\n export mk_uint;\n export mk_uniq;\n export mk_var;\n-export mk_vec;\n export mk_iter_body_fn;\n export mode;\n export mo_val;\n@@ -147,7 +146,6 @@ export ty_uint;\n export ty_uniq;\n export ty_var;\n export ty_var_id;\n-export ty_vec;\n export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n export type_constr;\n@@ -263,7 +261,6 @@ tag sty {\n     ty_tag(def_id, [t]);\n     ty_box(mt);\n     ty_uniq(t);\n-    ty_vec(mt);\n     ty_ivec(mt);\n     ty_ptr(mt);\n     ty_rec([field]);\n@@ -465,7 +462,6 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n       }\n       ty_box(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_uniq(tt) { derive_flags_t(cx, has_params, has_vars, tt); }\n-      ty_vec(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_ivec(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_ptr(m) { derive_flags_mt(cx, has_params, has_vars, m); }\n       ty_rec(flds) {\n@@ -567,14 +563,8 @@ fn mk_mut_ptr(cx: &ctxt, ty: &t) -> t {\n     ret mk_ptr(cx, {ty: ty, mut: ast::mut});\n }\n \n-fn mk_vec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n-\n fn mk_ivec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_ivec(tm)); }\n \n-fn mk_imm_vec(cx: &ctxt, typ: &t) -> t {\n-    ret gen_ty(cx, ty_vec({ty: typ, mut: ast::imm}));\n-}\n-\n fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n@@ -644,7 +634,6 @@ fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n       ty_type. {/* no-op */ }\n       ty_native(_) {/* no-op */ }\n       ty_box(tm) { walk_ty(cx, walker, tm.ty); }\n-      ty_vec(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_ivec(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_ptr(tm) { walk_ty(cx, walker, tm.ty); }\n       ty_tag(tid, subtys) {\n@@ -719,9 +708,6 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n       ty_ptr(tm) {\n         ty = mk_ptr(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n-      ty_vec(tm) {\n-        ty = mk_vec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n-      }\n       ty_ivec(tm) {\n         ty = mk_ivec(cx, {ty: fold_ty(cx, fld, tm.ty), mut: tm.mut});\n       }\n@@ -860,7 +846,6 @@ fn type_is_sequence(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n       ty_istr. { ret true; }\n-      ty_vec(_) { ret true; }\n       ty_ivec(_) { ret true; }\n       _ { ret false; }\n     }\n@@ -877,10 +862,6 @@ fn type_is_str(cx: &ctxt, ty: &t) -> bool {\n fn sequence_is_interior(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n \n-      // TODO: Or-patterns\n-      ty::ty_vec(_) {\n-        ret false;\n-      }\n       ty::ty_str. { ret false; }\n       ty::ty_ivec(_) { ret true; }\n       ty::ty_istr. { ret true; }\n@@ -892,7 +873,6 @@ fn sequence_element_type(cx: &ctxt, ty: &t) -> t {\n     alt struct(cx, ty) {\n       ty_str. { ret mk_mach(cx, ast::ty_u8); }\n       ty_istr. { ret mk_mach(cx, ast::ty_u8); }\n-      ty_vec(mt) { ret mt.ty; }\n       ty_ivec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n@@ -929,7 +909,6 @@ fn type_is_box(cx: &ctxt, ty: &t) -> bool {\n fn type_is_boxed(cx: &ctxt, ty: &t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n-      ty_vec(_) { ret true; }\n       ty_box(_) { ret true; }\n       _ { ret false; }\n     }\n@@ -1068,7 +1047,7 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n \n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n-      ty_box(mt) | ty_vec(mt) {\n+      ty_box(mt) {\n         result = ast::kind_shared;\n       }\n \n@@ -1155,7 +1134,6 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n         ret false;\n       }\n       ty_box(_) { ret false; }\n-      ty_vec(_) { ret false; }\n       ty_ivec(mt) { ret type_has_dynamic_size(cx, mt.ty); }\n       ty_ptr(_) { ret false; }\n       ty_rec(fields) {\n@@ -1272,7 +1250,6 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n         result = false;\n       }\n       ty_box(_) { result = false; }\n-      ty_vec(_) { result = false; }\n       ty_fn(_, _, _, _, _) { result = false; }\n       ty_native_fn(_, _, _) { result = false; }\n       ty_obj(_) { result = false; }\n@@ -1326,7 +1303,7 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n         }\n \n         // Boxed types\n-        ty_str. | ty_istr. | ty_box(_) | ty_vec(_) | ty_ivec(_) |\n+        ty_str. | ty_istr. | ty_box(_) | ty_ivec(_) |\n         ty_fn(_,_,_,_,_) | ty_native_fn(_,_,_) | ty_obj(_) { result = false; }\n \n         // Structural types\n@@ -1489,7 +1466,6 @@ fn hash_type_structure(st: &sty) -> uint {\n         ret h;\n       }\n       ty_box(mt) { ret hash_subty(19u, mt.ty); }\n-      ty_vec(mt) { ret hash_subty(20u, mt.ty); }\n       ty_ivec(mt) { ret hash_subty(21u, mt.ty); }\n       ty_rec(fields) {\n         let h = 26u;\n@@ -1651,9 +1627,6 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_box(mt_a) {\n         alt b { ty_box(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n       }\n-      ty_vec(mt_a) {\n-        alt b { ty_vec(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n-      }\n       ty_ivec(mt_a) {\n         alt b { ty_ivec(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n       }\n@@ -2502,26 +2475,6 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_vec(expected_mt) {\n-            alt struct(cx.tcx, actual) {\n-              ty::ty_vec(actual_mt) {\n-                let mut;\n-                alt unify_mut(expected_mt.mut, actual_mt.mut) {\n-                  none. { ret ures_err(terr_vec_mutability); }\n-                  some(m) { mut = m; }\n-                }\n-                let result = unify_step(cx, expected_mt.ty, actual_mt.ty);\n-                alt result {\n-                  ures_ok(result_sub) {\n-                    let mt = {ty: result_sub, mut: mut};\n-                    ret ures_ok(mk_vec(cx.tcx, mt));\n-                  }\n-                  _ { ret result; }\n-                }\n-              }\n-              _ { ret ures_err(terr_mismatch); }\n-            }\n-          }\n           ty::ty_ivec(expected_mt) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_ivec(actual_mt) {\n@@ -3055,7 +3008,6 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n           ty_ptr(_) { tycat_int }\n           ty_str. { tycat_str }\n           ty_istr. { tycat_str }\n-          ty_vec(_) { tycat_vec }\n           ty_ivec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }\n           ty_tup(_) { tycat_struct }"}, {"sha": "3173bf6b7a3831ab8688b7e6885701062f2fdf27", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -324,9 +324,6 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n       ast::ty_box(mt) {\n         typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n-      ast::ty_vec(mt) {\n-        typ = ty::mk_vec(tcx, ast_mt_to_mt(tcx, getter, mt));\n-      }\n       ast::ty_ivec(mt) {\n         typ = ty::mk_ivec(tcx, ast_mt_to_mt(tcx, getter, mt));\n       }\n@@ -1989,7 +1986,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         let elt_ty;\n         let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n-          ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           ty::ty_ivec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_istr. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n@@ -2295,7 +2291,6 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n                               + ty_to_str(tcx, idx_t));\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n-          ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n           ty::ty_ivec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n           ty::ty_str. {\n             let typ = ty::mk_mach(tcx, ast::ty_u8);\n@@ -2658,14 +2653,6 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n \n fn arg_is_argv_ty(tcx: &ty::ctxt, a: &ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n-      // FIXME: Remove after main takes only ivec\n-      ty::ty_vec(mt) {\n-        if mt.mut != ast::imm { ret false; }\n-        alt ty::struct(tcx, mt.ty) {\n-          ty::ty_str. { ret true; }\n-          _ { ret false; }\n-        }\n-      }\n       ty::ty_ivec(mt) {\n         if mt.mut != ast::imm { ret false; }\n         alt ty::struct(tcx, mt.ty) {"}, {"sha": "468675c070e2b7ce84dd0193520857bd6eaeb5fb", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -439,7 +439,6 @@ tag ty_ {\n     ty_str;\n     ty_istr; // interior string\n     ty_box(mt);\n-    ty_vec(mt);\n     ty_ivec(mt); // interior vector\n     ty_ptr(mt);\n     ty_task;"}, {"sha": "8b1600413c4bff8d951ede5dbc4f66c84daded27", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -284,7 +284,6 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       ast::ty_str. { word(s.s, \"str\"); }\n       ast::ty_istr. { word(s.s, \"istr\"); }\n       ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n-      ast::ty_vec(mt) { word(s.s, \"vec<\"); print_mt(s, mt); word(s.s, \">\"); }\n       ast::ty_ivec(mt) {\n         word(s.s, \"[\");\n         alt mt.mut {"}, {"sha": "6149319ba7bd8fe1b0f42ba5917d0744bc9ad300", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -124,7 +124,6 @@ fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n       ty_str. {/* no-op */ }\n       ty_istr. {/* no-op */ }\n       ty_box(mt) { v.visit_ty(mt.ty, e, v); }\n-      ty_vec(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_ivec(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_ptr(mt) { v.visit_ty(mt.ty, e, v); }\n       ty_port(t) { v.visit_ty(t, e, v); }"}, {"sha": "fa0bcce2e5ba005587f8a0158e2dde78a098b221", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d2dad093401ad97f19f96def0aa3f3f2a863bb/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=c2d2dad093401ad97f19f96def0aa3f3f2a863bb", "patch": "@@ -92,7 +92,6 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       ty_istr. { s += \"istr\"; }\n       ty_box(tm) { s += \"@\" + mt_to_str(cx, tm); }\n       ty_uniq(t) { s += \"~\" + ty_to_str(cx, t); }\n-      ty_vec(tm) { s += \"vec<\" + mt_to_str(cx, tm) + \">\"; }\n       ty_ivec(tm) { s += \"[\" + mt_to_str(cx, tm) + \"]\"; }\n       ty_type. { s += \"type\"; }\n       ty_rec(elems) {"}]}