{"sha": "51e2d76b9839410020c75ac02ad602675b0a5aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZTJkNzZiOTgzOTQxMDAyMGM3NWFjMDJhZDYwMjY3NWIwYTVhYTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-12T20:35:53Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-13T13:24:10Z"}, "message": "Specify desirable namespace when calling resolve\n\nThat way, we are able to get rid of a number of unreachable statements", "tree": {"sha": "989afd660d62db28196a8792cec2affb7bfd50a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/989afd660d62db28196a8792cec2affb7bfd50a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51e2d76b9839410020c75ac02ad602675b0a5aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51e2d76b9839410020c75ac02ad602675b0a5aa9", "html_url": "https://github.com/rust-lang/rust/commit/51e2d76b9839410020c75ac02ad602675b0a5aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51e2d76b9839410020c75ac02ad602675b0a5aa9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1adf0519bcc8286c06e12aa7e5b16298addfea4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1adf0519bcc8286c06e12aa7e5b16298addfea4a", "html_url": "https://github.com/rust-lang/rust/commit/1adf0519bcc8286c06e12aa7e5b16298addfea4a"}], "stats": {"total": 998, "additions": 534, "deletions": 464}, "files": [{"sha": "dad1c93c41b335b230265415685f7f6f451459c1", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -22,7 +22,7 @@ use crate::{\n         U8, USIZE,\n     },\n     nameres::{CrateModuleId, ImportId, ModuleScope, Namespace},\n-    resolve::Resolver,\n+    resolve::{Resolver, TypeNs},\n     traits::{TraitData, TraitItem},\n     ty::{\n         primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n@@ -868,11 +868,9 @@ impl Trait {\n                 }\n                 _ => None,\n             })\n-            .filter_map(|path| {\n-                match resolver.resolve_path_without_assoc_items(db, path).take_types() {\n-                    Some(crate::Resolution::Def(ModuleDef::Trait(t))) => Some(t),\n-                    _ => None,\n-                }\n+            .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n+                Some(TypeNs::Trait(t)) => Some(t),\n+                _ => None,\n             })\n             .collect()\n     }"}, {"sha": "80cf8d9c02a249d722205d0af95a5651cfc61577", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -73,7 +73,7 @@ pub use self::{\n     name::Name,\n     nameres::{ImportId, Namespace, PerNs},\n     path::{Path, PathKind},\n-    resolve::Resolution,\n+    resolve::ScopeDef,\n     source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     source_id::{AstIdMap, ErasedFileAstId},\n     ty::{"}, {"sha": "44a4ddba0a578b23b8f2d467a25d446d69267058", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -279,10 +279,6 @@ impl CrateDefMap {\n         self.root\n     }\n \n-    pub(crate) fn mk_module(&self, module_id: CrateModuleId) -> Module {\n-        Module { krate: self.krate, module_id }\n-    }\n-\n     pub(crate) fn prelude(&self) -> Option<Module> {\n         self.prelude\n     }\n@@ -389,7 +385,7 @@ impl CrateDefMap {\n         };\n \n         for (i, segment) in segments {\n-            let curr = match curr_per_ns.as_ref().take_types() {\n+            let curr = match curr_per_ns.take_types() {\n                 Some(r) => r,\n                 None => {\n                     // we still have path segments left, but the path so far\n@@ -433,7 +429,7 @@ impl CrateDefMap {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n                         None => {\n                             return ResolvePathResult::with(\n-                                PerNs::types((*e).into()),\n+                                PerNs::types(e.into()),\n                                 ReachedFixedPoint::Yes,\n                                 Some(i),\n                             );\n@@ -450,7 +446,7 @@ impl CrateDefMap {\n                     );\n \n                     return ResolvePathResult::with(\n-                        PerNs::types(*s),\n+                        PerNs::types(s),\n                         ReachedFixedPoint::Yes,\n                         Some(i),\n                     );"}, {"sha": "b0f4dff331d1c621693737b97656ab52a96dbe08", "filename": "crates/ra_hir/src/nameres/per_ns.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fper_ns.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -68,20 +68,11 @@ impl<T> PerNs<T> {\n         PerNs { types: None, values: None, macros: self.macros }\n     }\n \n-    pub fn as_ref(&self) -> PerNs<&T> {\n-        PerNs { types: self.types.as_ref(), values: self.values.as_ref(), macros: self.macros }\n-    }\n-\n     pub fn or(self, other: PerNs<T>) -> PerNs<T> {\n         PerNs {\n             types: self.types.or(other.types),\n             values: self.values.or(other.values),\n             macros: self.macros.or(other.macros),\n         }\n     }\n-\n-    /// Map types and values. Leave macros unchanged.\n-    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n-        PerNs { types: self.types.map(&f), values: self.values.map(&f), macros: self.macros }\n-    }\n }"}, {"sha": "d841593f87d7e2f349481eee05b7b1e8a154d38c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 233, "deletions": 172, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -1,7 +1,7 @@\n //! Name resolution.\n use std::sync::Arc;\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     code_model::Crate,\n@@ -14,8 +14,9 @@ use crate::{\n     impl_block::ImplBlock,\n     name::{Name, SELF_PARAM, SELF_TYPE},\n     nameres::{CrateDefMap, CrateModuleId, PerNs},\n-    path::Path,\n-    Adt, Enum, MacroDef, ModuleDef, Struct, Trait,\n+    path::{Path, PathKind},\n+    Adt, BuiltinType, Const, Enum, EnumVariant, Function, MacroDef, ModuleDef, Static, Struct,\n+    Trait, TypeAlias,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -36,69 +37,6 @@ pub(crate) struct ExprScope {\n     scope_id: ScopeId,\n }\n \n-#[derive(Debug, Clone)]\n-pub(crate) struct PathResult {\n-    /// The actual path resolution\n-    // FIXME: `PerNs<Resolution>` type doesn't make sense, as not every\n-    // Resolution variant can appear in every namespace\n-    resolution: PerNs<Resolution>,\n-    /// The first index in the path that we\n-    /// were unable to resolve.\n-    /// When path is fully resolved, this is 0.\n-    remaining_index: usize,\n-}\n-\n-impl PathResult {\n-    /// Returns the remaining index in the result\n-    /// returns None if the path was fully resolved\n-    pub(crate) fn remaining_index(&self) -> Option<usize> {\n-        if self.remaining_index > 0 {\n-            Some(self.remaining_index)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Consumes `PathResult` and returns the contained `PerNs<Resolution>`\n-    /// if the path was fully resolved, meaning we have no remaining items\n-    pub(crate) fn into_fully_resolved(self) -> PerNs<Resolution> {\n-        if self.is_fully_resolved() {\n-            self.resolution\n-        } else {\n-            PerNs::none()\n-        }\n-    }\n-\n-    /// Consumes `PathResult` and returns the resolution and the\n-    /// remaining_index as a tuple.\n-    pub(crate) fn into_inner(self) -> (PerNs<Resolution>, Option<usize>) {\n-        let index = self.remaining_index();\n-        (self.resolution, index)\n-    }\n-\n-    /// Path is fully resolved when `remaining_index` is none\n-    /// and the resolution contains anything\n-    pub(crate) fn is_fully_resolved(&self) -> bool {\n-        !self.resolution.is_none() && self.remaining_index().is_none()\n-    }\n-\n-    fn empty() -> PathResult {\n-        PathResult { resolution: PerNs::none(), remaining_index: 0 }\n-    }\n-\n-    fn from_resolution(res: PerNs<Resolution>) -> PathResult {\n-        PathResult::from_resolution_with_index(res, 0)\n-    }\n-\n-    fn from_resolution_with_index(res: PerNs<Resolution>, remaining_index: usize) -> PathResult {\n-        if res.is_none() {\n-            PathResult::empty()\n-        } else {\n-            PathResult { resolution: res, remaining_index }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone)]\n pub(crate) enum Scope {\n     /// All the items and imported names of a module\n@@ -112,25 +50,41 @@ pub(crate) enum Scope {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum Resolution {\n-    /// An item\n-    Def(ModuleDef),\n+pub enum TypeNs {\n+    SelfType(ImplBlock),\n+    GenericParam(u32),\n+    Adt(Adt),\n+    EnumVariant(EnumVariant),\n+    TypeAlias(TypeAlias),\n+    BuiltinType(BuiltinType),\n+    Trait(Trait),\n+    // Module belong to type ns, but the resovler is used when all module paths\n+    // are fully resolved.\n+    // Module(Module)\n+}\n+\n+#[derive(Debug)]\n+pub enum ValueOrPartial {\n+    ValueNs(ValueNs),\n+    Partial(TypeNs, usize),\n+}\n \n-    // FIXME: there's no way we can syntactically confuse a local with generic\n-    // param, so these two should not be members of the single enum\n-    /// A local binding (only value namespace)\n+#[derive(Debug)]\n+pub enum ValueNs {\n     LocalBinding(PatId),\n-    /// A generic parameter\n-    GenericParam(u32),\n-    SelfType(ImplBlock),\n+    Function(Function),\n+    Const(Const),\n+    Static(Static),\n+    Struct(Struct),\n+    EnumVariant(EnumVariant),\n }\n \n impl Resolver {\n     /// Resolve known trait from std, like `std::futures::Future`\n     pub(crate) fn resolve_known_trait(&self, db: &impl HirDatabase, path: &Path) -> Option<Trait> {\n-        let res = self.resolve_path_segments(db, path).into_fully_resolved().take_types()?;\n+        let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            Resolution::Def(ModuleDef::Trait(it)) => Some(it),\n+            ModuleDef::Trait(it) => Some(it),\n             _ => None,\n         }\n     }\n@@ -141,94 +95,214 @@ impl Resolver {\n         db: &impl HirDatabase,\n         path: &Path,\n     ) -> Option<Struct> {\n-        let res = self.resolve_path_segments(db, path).into_fully_resolved().take_types()?;\n+        let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            Resolution::Def(ModuleDef::Adt(Adt::Struct(it))) => Some(it),\n+            ModuleDef::Adt(Adt::Struct(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n     /// Resolve known enum from std, like `std::result::Result`\n     pub(crate) fn resolve_known_enum(&self, db: &impl HirDatabase, path: &Path) -> Option<Enum> {\n-        let res = self.resolve_path_segments(db, path).into_fully_resolved().take_types()?;\n+        let res = self.resolve_module_path(db, path).take_types()?;\n         match res {\n-            Resolution::Def(ModuleDef::Adt(Adt::Enum(it))) => Some(it),\n+            ModuleDef::Adt(Adt::Enum(it)) => Some(it),\n             _ => None,\n         }\n     }\n \n-    pub(crate) fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n-        let mut resolution = PerNs::none();\n+    /// pub only for source-binder\n+    pub(crate) fn resolve_module_path(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> PerNs<ModuleDef> {\n+        let (item_map, module) = match self.module() {\n+            Some(it) => it,\n+            None => return PerNs::none(),\n+        };\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n+        if segment_index.is_some() {\n+            return PerNs::none();\n+        }\n+        module_res\n+    }\n+\n+    pub(crate) fn resolve_path_in_type_ns(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> Option<(TypeNs, Option<usize>)> {\n+        let first_name = &path.segments.first()?.name;\n+        let skip_to_mod = path.kind != PathKind::Plain;\n         for scope in self.scopes.iter().rev() {\n-            resolution = resolution.or(scope.resolve_name(db, name));\n-            if resolution.is_all() {\n-                return resolution;\n+            match scope {\n+                Scope::ExprScope(_) => continue,\n+                Scope::GenericParams(_) | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n+\n+                Scope::GenericParams(params) => {\n+                    if let Some(param) = params.find_by_name(first_name) {\n+                        let idx = if path.segments.len() == 1 { None } else { Some(1) };\n+                        return Some((TypeNs::GenericParam(param.idx), idx));\n+                    }\n+                }\n+                Scope::ImplBlockScope(impl_) => {\n+                    if first_name == &SELF_TYPE {\n+                        let idx = if path.segments.len() == 1 { None } else { Some(1) };\n+                        return Some((TypeNs::SelfType(*impl_), idx));\n+                    }\n+                }\n+                Scope::ModuleScope(m) => {\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n+                    let res = match module_def.take_types()? {\n+                        ModuleDef::Adt(it) => TypeNs::Adt(it),\n+                        ModuleDef::EnumVariant(it) => TypeNs::EnumVariant(it),\n+\n+                        ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n+                        ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                        ModuleDef::Trait(it) => TypeNs::Trait(it),\n+\n+                        ModuleDef::Function(_)\n+                        | ModuleDef::Const(_)\n+                        | ModuleDef::Static(_)\n+                        | ModuleDef::Module(_) => return None,\n+                    };\n+                    return Some((res, idx));\n+                }\n             }\n         }\n-        resolution\n+        None\n     }\n \n-    pub(crate) fn resolve_path_as_macro(\n+    pub(crate) fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &impl HirDatabase,\n         path: &Path,\n-    ) -> Option<MacroDef> {\n-        let (item_map, module) = self.module()?;\n-        item_map.resolve_path(db, module, path).0.get_macros()\n+    ) -> Option<TypeNs> {\n+        let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n+        if unresolved.is_some() {\n+            return None;\n+        }\n+        Some(res)\n     }\n \n-    /// Returns the resolved path segments\n-    /// Which may be fully resolved, empty or partially resolved.\n-    pub(crate) fn resolve_path_segments(&self, db: &impl HirDatabase, path: &Path) -> PathResult {\n-        if let Some(name) = path.as_ident() {\n-            PathResult::from_resolution(self.resolve_name(db, name))\n-        } else if path.is_self() {\n-            PathResult::from_resolution(self.resolve_name(db, &SELF_PARAM))\n-        } else {\n-            let (item_map, module) = match self.module() {\n-                Some(it) => it,\n-                None => return PathResult::empty(),\n-            };\n-            let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n-\n-            let def = module_res.map(Resolution::Def);\n-\n-            if let Some(index) = segment_index {\n-                PathResult::from_resolution_with_index(def, index)\n-            } else {\n-                PathResult::from_resolution(def)\n+    pub(crate) fn resolve_path_in_value_ns(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> Option<ValueOrPartial> {\n+        let n_segments = path.segments.len();\n+        let tmp = SELF_PARAM;\n+        let first_name = if path.is_self() { &tmp } else { &path.segments.first()?.name };\n+        let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n+        for scope in self.scopes.iter().rev() {\n+            match scope {\n+                Scope::ExprScope(_) | Scope::GenericParams(_) | Scope::ImplBlockScope(_)\n+                    if skip_to_mod =>\n+                {\n+                    continue\n+                }\n+\n+                Scope::ExprScope(scope) if n_segments <= 1 => {\n+                    let entry = scope\n+                        .expr_scopes\n+                        .entries(scope.scope_id)\n+                        .iter()\n+                        .find(|entry| entry.name() == first_name);\n+\n+                    if let Some(e) = entry {\n+                        return Some(ValueOrPartial::ValueNs(ValueNs::LocalBinding(e.pat())));\n+                    }\n+                }\n+                Scope::ExprScope(_) => continue,\n+\n+                Scope::GenericParams(params) if n_segments > 1 => {\n+                    if let Some(param) = params.find_by_name(first_name) {\n+                        let ty = TypeNs::GenericParam(param.idx);\n+                        return Some(ValueOrPartial::Partial(ty, 1));\n+                    }\n+                }\n+                Scope::GenericParams(_) => continue,\n+\n+                Scope::ImplBlockScope(impl_) if n_segments > 1 => {\n+                    if first_name == &SELF_TYPE {\n+                        let ty = TypeNs::SelfType(*impl_);\n+                        return Some(ValueOrPartial::Partial(ty, 1));\n+                    }\n+                }\n+                Scope::ImplBlockScope(_) => continue,\n+\n+                Scope::ModuleScope(m) => {\n+                    let (module_def, idx) = m.crate_def_map.resolve_path(db, m.module_id, path);\n+                    return match idx {\n+                        None => {\n+                            let value = match module_def.take_values()? {\n+                                ModuleDef::Function(it) => ValueNs::Function(it),\n+                                ModuleDef::Adt(Adt::Struct(it)) => ValueNs::Struct(it),\n+                                ModuleDef::EnumVariant(it) => ValueNs::EnumVariant(it),\n+                                ModuleDef::Const(it) => ValueNs::Const(it),\n+                                ModuleDef::Static(it) => ValueNs::Static(it),\n+\n+                                ModuleDef::Adt(Adt::Enum(_))\n+                                | ModuleDef::Adt(Adt::Union(_))\n+                                | ModuleDef::Trait(_)\n+                                | ModuleDef::TypeAlias(_)\n+                                | ModuleDef::BuiltinType(_)\n+                                | ModuleDef::Module(_) => return None,\n+                            };\n+                            Some(ValueOrPartial::ValueNs(value))\n+                        }\n+                        Some(idx) => {\n+                            let ty = match module_def.take_types()? {\n+                                ModuleDef::Adt(it) => TypeNs::Adt(it),\n+                                ModuleDef::Trait(it) => TypeNs::Trait(it),\n+                                ModuleDef::TypeAlias(it) => TypeNs::TypeAlias(it),\n+                                ModuleDef::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                                ModuleDef::Module(_)\n+                                | ModuleDef::Function(_)\n+                                | ModuleDef::EnumVariant(_)\n+                                | ModuleDef::Const(_)\n+                                | ModuleDef::Static(_) => return None,\n+                            };\n+                            Some(ValueOrPartial::Partial(ty, idx))\n+                        }\n+                    };\n+                }\n             }\n         }\n+        None\n     }\n \n-    /// Returns the fully resolved path if we were able to resolve it.\n-    /// otherwise returns `PerNs::none`\n-    pub(crate) fn resolve_path_without_assoc_items(\n+    pub(crate) fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &impl HirDatabase,\n         path: &Path,\n-    ) -> PerNs<Resolution> {\n-        // into_fully_resolved() returns the fully resolved path or PerNs::none() otherwise\n-        self.resolve_path_segments(db, path).into_fully_resolved()\n+    ) -> Option<ValueNs> {\n+        match self.resolve_path_in_value_ns(db, path)? {\n+            ValueOrPartial::ValueNs(it) => Some(it),\n+            ValueOrPartial::Partial(..) => None,\n+        }\n     }\n \n-    pub(crate) fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<Resolution>> {\n-        let mut names = FxHashMap::default();\n+    pub(crate) fn resolve_path_as_macro(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> Option<MacroDef> {\n+        let (item_map, module) = self.module()?;\n+        item_map.resolve_path(db, module, path).0.get_macros()\n+    }\n+\n+    pub(crate) fn process_all_names(\n+        &self,\n+        db: &impl HirDatabase,\n+        f: &mut dyn FnMut(Name, ScopeDef),\n+    ) {\n         for scope in self.scopes.iter().rev() {\n-            scope.collect_names(db, &mut |name, res| {\n-                let current: &mut PerNs<Resolution> = names.entry(name).or_default();\n-                if current.types.is_none() {\n-                    current.types = res.types;\n-                }\n-                if current.values.is_none() {\n-                    current.values = res.values;\n-                }\n-                if current.macros.is_none() {\n-                    current.macros = res.macros;\n-                }\n-            });\n+            scope.process_names(db, f);\n         }\n-        names\n     }\n \n     pub(crate) fn traits_in_scope(&self, db: &impl HirDatabase) -> FxHashSet<Trait> {\n@@ -301,41 +375,28 @@ impl Resolver {\n     }\n }\n \n-impl Scope {\n-    fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n-        match self {\n-            Scope::ModuleScope(m) => {\n-                if name == &SELF_PARAM {\n-                    PerNs::types(Resolution::Def(m.crate_def_map.mk_module(m.module_id).into()))\n-                } else {\n-                    m.crate_def_map\n-                        .resolve_name_in_module(db, m.module_id, name)\n-                        .map(Resolution::Def)\n-                }\n-            }\n-            Scope::GenericParams(gp) => match gp.find_by_name(name) {\n-                Some(gp) => PerNs::types(Resolution::GenericParam(gp.idx)),\n-                None => PerNs::none(),\n-            },\n-            Scope::ImplBlockScope(i) => {\n-                if name == &SELF_TYPE {\n-                    PerNs::types(Resolution::SelfType(*i))\n-                } else {\n-                    PerNs::none()\n-                }\n-            }\n-            Scope::ExprScope(e) => {\n-                let entry =\n-                    e.expr_scopes.entries(e.scope_id).iter().find(|entry| entry.name() == name);\n-                match entry {\n-                    Some(e) => PerNs::values(Resolution::LocalBinding(e.pat())),\n-                    None => PerNs::none(),\n-                }\n-            }\n-        }\n+/// For IDE only\n+pub enum ScopeDef {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+    GenericParam(u32),\n+    SelfType(ImplBlock),\n+    LocalBinding(PatId),\n+    Unknown,\n+}\n+\n+impl From<PerNs<ModuleDef>> for ScopeDef {\n+    fn from(def: PerNs<ModuleDef>) -> Self {\n+        def.take_types()\n+            .or_else(|| def.take_values())\n+            .map(ScopeDef::ModuleDef)\n+            .or_else(|| def.get_macros().map(ScopeDef::MacroDef))\n+            .unwrap_or(ScopeDef::Unknown)\n     }\n+}\n \n-    fn collect_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, PerNs<Resolution>)) {\n+impl Scope {\n+    fn process_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // FIXME: should we provide `self` here?\n@@ -346,32 +407,32 @@ impl Scope {\n                 //     }),\n                 // );\n                 m.crate_def_map[m.module_id].scope.entries().for_each(|(name, res)| {\n-                    f(name.clone(), res.def.map(Resolution::Def));\n+                    f(name.clone(), res.def.into());\n                 });\n                 m.crate_def_map[m.module_id].scope.legacy_macros().for_each(|(name, macro_)| {\n-                    f(name.clone(), PerNs::macros(macro_));\n+                    f(name.clone(), ScopeDef::MacroDef(macro_));\n                 });\n                 m.crate_def_map.extern_prelude().iter().for_each(|(name, def)| {\n-                    f(name.clone(), PerNs::types(Resolution::Def(*def)));\n+                    f(name.clone(), ScopeDef::ModuleDef(*def));\n                 });\n                 if let Some(prelude) = m.crate_def_map.prelude() {\n                     let prelude_def_map = db.crate_def_map(prelude.krate);\n                     prelude_def_map[prelude.module_id].scope.entries().for_each(|(name, res)| {\n-                        f(name.clone(), res.def.map(Resolution::Def));\n+                        f(name.clone(), res.def.into());\n                     });\n                 }\n             }\n             Scope::GenericParams(gp) => {\n                 for param in &gp.params {\n-                    f(param.name.clone(), PerNs::types(Resolution::GenericParam(param.idx)))\n+                    f(param.name.clone(), ScopeDef::GenericParam(param.idx))\n                 }\n             }\n             Scope::ImplBlockScope(i) => {\n-                f(SELF_TYPE, PerNs::types(Resolution::SelfType(*i)));\n+                f(SELF_TYPE, ScopeDef::SelfType(*i));\n             }\n             Scope::ExprScope(e) => {\n                 e.expr_scopes.entries(e.scope_id).iter().for_each(|e| {\n-                    f(e.name().clone(), PerNs::values(Resolution::LocalBinding(e.pat())));\n+                    f(e.name().clone(), ScopeDef::LocalBinding(e.pat()));\n                 });\n             }\n         }"}, {"sha": "cff55b64034babfee85a3a16ec9a766ec8013388", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -15,7 +15,7 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n@@ -27,9 +27,10 @@ use crate::{\n     ids::LocationCtx,\n     name,\n     path::{PathKind, PathSegment},\n+    resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n     AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HasBody, HirFileId, MacroDef,\n-    Module, Name, Path, PerNs, Resolver, Static, Struct, Trait, Ty,\n+    Module, Name, Path, Resolver, Static, Struct, Trait, Ty,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -301,8 +302,41 @@ impl SourceAnalyzer {\n         &self,\n         db: &impl HirDatabase,\n         path: &crate::Path,\n-    ) -> PerNs<crate::Resolution> {\n-        self.resolver.resolve_path_without_assoc_items(db, path)\n+    ) -> Option<PathResolution> {\n+        let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n+            TypeNs::SelfType(it) => PathResolution::SelfType(it),\n+            TypeNs::GenericParam(it) => PathResolution::GenericParam(it),\n+            TypeNs::Adt(it) => PathResolution::Def(it.into()),\n+            TypeNs::EnumVariant(it) => PathResolution::Def(it.into()),\n+            TypeNs::TypeAlias(it) => PathResolution::Def(it.into()),\n+            TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+            TypeNs::Trait(it) => PathResolution::Def(it.into()),\n+        });\n+        let values = self.resolver.resolve_path_in_value_ns_fully(db, &path).and_then(|val| {\n+            let res = match val {\n+                ValueNs::LocalBinding(it) => {\n+                    // We get a `PatId` from resolver, but it actually can only\n+                    // point at `BindPat`, and not at the arbitrary pattern.\n+                    let pat_ptr = self\n+                        .body_source_map\n+                        .as_ref()?\n+                        .pat_syntax(it)?\n+                        .ast // FIXME: ignoring file_id here is definitelly wrong\n+                        .map_a(|ptr| ptr.cast::<ast::BindPat>().unwrap());\n+                    PathResolution::LocalBinding(pat_ptr)\n+                }\n+                ValueNs::Function(it) => PathResolution::Def(it.into()),\n+                ValueNs::Const(it) => PathResolution::Def(it.into()),\n+                ValueNs::Static(it) => PathResolution::Def(it.into()),\n+                ValueNs::Struct(it) => PathResolution::Def(it.into()),\n+                ValueNs::EnumVariant(it) => PathResolution::Def(it.into()),\n+            };\n+            Some(res)\n+        });\n+\n+        let items =\n+            self.resolver.resolve_module_path(db, &path).take_types().map(PathResolution::Def);\n+        types.or(values).or(items)\n     }\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n@@ -319,25 +353,7 @@ impl SourceAnalyzer {\n             }\n         }\n         let hir_path = crate::Path::from_ast(path.clone())?;\n-        let res = self.resolver.resolve_path_without_assoc_items(db, &hir_path);\n-        let res = res.clone().take_types().or_else(|| res.take_values())?;\n-        let res = match res {\n-            crate::Resolution::Def(it) => PathResolution::Def(it),\n-            crate::Resolution::LocalBinding(it) => {\n-                // We get a `PatId` from resolver, but it actually can only\n-                // point at `BindPat`, and not at the arbitrary pattern.\n-                let pat_ptr = self\n-                    .body_source_map\n-                    .as_ref()?\n-                    .pat_syntax(it)?\n-                    .ast // FIXME: ignoring file_id here is definitelly wrong\n-                    .map_a(|ptr| ptr.cast::<ast::BindPat>().unwrap());\n-                PathResolution::LocalBinding(pat_ptr)\n-            }\n-            crate::Resolution::GenericParam(it) => PathResolution::GenericParam(it),\n-            crate::Resolution::SelfType(it) => PathResolution::SelfType(it),\n-        };\n-        Some(res)\n+        self.resolve_hir_path(db, &hir_path)\n     }\n \n     pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n@@ -360,8 +376,8 @@ impl SourceAnalyzer {\n         })\n     }\n \n-    pub fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<crate::Resolution>> {\n-        self.resolver.all_names(db)\n+    pub fn process_all_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, ScopeDef)) {\n+        self.resolver.process_all_names(db, f)\n     }\n \n     pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {"}, {"sha": "3ee083a04ca3d0d1ac78464b0efa9cbcc4b5899c", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 123, "deletions": 133, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -45,11 +45,10 @@ use crate::{\n     name,\n     nameres::Namespace,\n     path::{GenericArg, GenericArgs, PathKind, PathSegment},\n-    resolve::{Resolution, Resolver},\n+    resolve::{Resolver, TypeNs, ValueNs, ValueOrPartial},\n     ty::infer::diagnostics::InferenceDiagnostic,\n     type_ref::{Mutability, TypeRef},\n-    Adt, ConstData, DefWithBody, FnData, Function, HasBody, ImplItem, ModuleDef, Name, Path,\n-    StructField,\n+    Adt, ConstData, DefWithBody, FnData, Function, HasBody, ImplItem, Name, Path, StructField,\n };\n \n mod unify;\n@@ -472,141 +471,138 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let resolved = resolver.resolve_path_segments(self.db, &path);\n+        let value_or_partial = resolver.resolve_path_in_value_ns(self.db, &path)?;\n \n-        let (def, remaining_index) = resolved.into_inner();\n+        let (value, self_subst) = match value_or_partial {\n+            ValueOrPartial::ValueNs(it) => (it, None),\n+            ValueOrPartial::Partial(def, remaining_index) => {\n+                self.resolve_assoc_item(def, path, remaining_index, id)?\n+            }\n+        };\n \n-        log::debug!(\n-            \"path {:?} resolved to {:?} with remaining index {:?}\",\n-            path,\n-            def,\n-            remaining_index\n-        );\n+        let typable: TypableDef = match value {\n+            ValueNs::LocalBinding(pat) => {\n+                let ty = self.result.type_of_pat.get(pat)?.clone();\n+                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+                return Some(ty);\n+            }\n+            ValueNs::Function(it) => it.into(),\n+            ValueNs::Const(it) => it.into(),\n+            ValueNs::Static(it) => it.into(),\n+            ValueNs::Struct(it) => it.into(),\n+            ValueNs::EnumVariant(it) => it.into(),\n+        };\n \n-        // if the remaining_index is None, we expect the path\n-        // to be fully resolved, in this case we continue with\n-        // the default by attempting to `take_values\u00b4 from the resolution.\n-        // Otherwise the path was partially resolved, which means\n-        // we might have resolved into a type for which\n-        // we may find some associated item starting at the\n-        // path.segment pointed to by `remaining_index\u00b4\n-        let mut resolved =\n-            if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n+        let mut ty = self.db.type_for_def(typable, Namespace::Values);\n+        if let Some(self_subst) = self_subst {\n+            ty = ty.subst(&self_subst);\n+        }\n \n-        let remaining_index = remaining_index.unwrap_or_else(|| path.segments.len());\n-        let mut actual_def_ty: Option<Ty> = None;\n+        let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+        let ty = ty.subst(&substs);\n+        let ty = self.insert_type_vars(ty);\n+        let ty = self.normalize_associated_types_in(ty);\n+        Some(ty)\n+    }\n+\n+    fn resolve_assoc_item(\n+        &mut self,\n+        mut def: TypeNs,\n+        path: &Path,\n+        remaining_index: usize,\n+        id: ExprOrPatId,\n+    ) -> Option<(ValueNs, Option<Substs>)> {\n+        assert!(remaining_index < path.segments.len());\n+        let krate = self.resolver.krate()?;\n+\n+        let mut ty = Ty::Unknown;\n \n-        let krate = resolver.krate()?;\n         // resolve intermediate segments\n         for (i, segment) in path.segments[remaining_index..].iter().enumerate() {\n-            let ty = match resolved {\n-                Resolution::Def(def) => {\n-                    // FIXME resolve associated items from traits as well\n-                    let typable: Option<TypableDef> = def.into();\n-                    let typable = typable?;\n-\n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-\n-                    // For example, this substs will take `Gen::*<u32>*::make`\n-                    assert!(remaining_index > 0);\n-                    let substs = Ty::substs_from_path_segment(\n-                        self.db,\n-                        &self.resolver,\n-                        &path.segments[remaining_index + i - 1],\n-                        typable,\n-                    );\n-\n-                    ty.subst(&substs)\n-                }\n-                Resolution::LocalBinding(_) => {\n-                    // can't have a local binding in an associated item path\n-                    return None;\n-                }\n-                Resolution::GenericParam(..) => {\n-                    // FIXME associated item of generic param\n-                    return None;\n-                }\n-                Resolution::SelfType(_) => {\n-                    // FIXME associated item of self type\n-                    return None;\n-                }\n+            let is_last_segment = i == path.segments[remaining_index..].len() - 1;\n+            ty = {\n+                let typable: TypableDef = match def {\n+                    TypeNs::Adt(it) => it.into(),\n+                    TypeNs::TypeAlias(it) => it.into(),\n+                    TypeNs::BuiltinType(it) => it.into(),\n+                    // FIXME associated item of traits, generics, and Self\n+                    TypeNs::Trait(_) | TypeNs::GenericParam(_) | TypeNs::SelfType(_) => {\n+                        return None;\n+                    }\n+                    // FIXME: report error here\n+                    TypeNs::EnumVariant(_) => return None,\n+                };\n+\n+                let ty = self.db.type_for_def(typable, Namespace::Types);\n+\n+                // For example, this substs will take `Gen::*<u32>*::make`\n+                assert!(remaining_index > 0);\n+                let substs = Ty::substs_from_path_segment(\n+                    self.db,\n+                    &self.resolver,\n+                    &path.segments[remaining_index + i - 1],\n+                    typable,\n+                );\n+                ty.subst(&substs)\n             };\n+            if is_last_segment {\n+                break;\n+            }\n \n             // Attempt to find an impl_item for the type which has a name matching\n             // the current segment\n             log::debug!(\"looking for path segment: {:?}\", segment);\n \n-            actual_def_ty = Some(ty.clone());\n-\n-            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, krate, |item| {\n-                let matching_def: Option<crate::ModuleDef> = match item {\n-                    crate::ImplItem::Method(func) => {\n-                        if segment.name == func.name(self.db) {\n-                            Some(func.into())\n-                        } else {\n-                            None\n-                        }\n-                    }\n-\n-                    crate::ImplItem::Const(konst) => {\n-                        let data = konst.data(self.db);\n-                        if segment.name == *data.name() {\n-                            Some(konst.into())\n-                        } else {\n-                            None\n-                        }\n-                    }\n+            let ty = mem::replace(&mut ty, Ty::Unknown);\n+            def = ty.iterate_impl_items(self.db, krate, |item| {\n+                match item {\n+                    crate::ImplItem::Method(_) => None,\n+                    crate::ImplItem::Const(_) => None,\n \n                     // FIXME: Resolve associated types\n-                    crate::ImplItem::TypeAlias(_) => None,\n-                };\n-                match matching_def {\n-                    Some(_) => {\n-                        self.write_assoc_resolution(id, item);\n-                        matching_def\n+                    crate::ImplItem::TypeAlias(_) => {\n+                        // Some(TypeNs::TypeAlias(..))\n+                        None::<TypeNs>\n                     }\n-                    None => None,\n                 }\n             })?;\n-\n-            resolved = Resolution::Def(item);\n         }\n \n-        match resolved {\n-            Resolution::Def(def) => {\n-                let typable: Option<TypableDef> = def.into();\n-                let typable = typable?;\n-                let mut ty = self.db.type_for_def(typable, Namespace::Values);\n-                if let Some(sts) = self.find_self_types(&def, actual_def_ty) {\n-                    ty = ty.subst(&sts);\n+        let segment = path.segments.last().unwrap();\n+        let def = ty.clone().iterate_impl_items(self.db, krate, |item| {\n+            let matching_def: Option<ValueNs> = match item {\n+                crate::ImplItem::Method(func) => {\n+                    if segment.name == func.name(self.db) {\n+                        Some(ValueNs::Function(func))\n+                    } else {\n+                        None\n+                    }\n                 }\n \n-                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                let ty = ty.subst(&substs);\n-                let ty = self.insert_type_vars(ty);\n-                let ty = self.normalize_associated_types_in(ty);\n-                Some(ty)\n-            }\n-            Resolution::LocalBinding(pat) => {\n-                let ty = self.result.type_of_pat.get(pat)?.clone();\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-                Some(ty)\n-            }\n-            Resolution::GenericParam(..) => {\n-                // generic params can't refer to values... yet\n-                None\n-            }\n-            Resolution::SelfType(_) => {\n-                log::error!(\"path expr {:?} resolved to Self type in values ns\", path);\n-                None\n+                crate::ImplItem::Const(konst) => {\n+                    let data = konst.data(self.db);\n+                    if segment.name == *data.name() {\n+                        Some(ValueNs::Const(konst))\n+                    } else {\n+                        None\n+                    }\n+                }\n+                crate::ImplItem::TypeAlias(_) => None,\n+            };\n+            match matching_def {\n+                Some(_) => {\n+                    self.write_assoc_resolution(id, item);\n+                    matching_def\n+                }\n+                None => None,\n             }\n-        }\n+        })?;\n+        let self_types = self.find_self_types(&def, ty);\n+        Some((def, self_types))\n     }\n \n-    fn find_self_types(&self, def: &ModuleDef, actual_def_ty: Option<Ty>) -> Option<Substs> {\n-        let actual_def_ty = actual_def_ty?;\n-\n-        if let crate::ModuleDef::Function(func) = def {\n+    fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n+        if let ValueNs::Function(func) = def {\n             // We only do the infer if parent has generic params\n             let gen = func.generic_params(self.db);\n             if gen.count_parent_params() == 0 {\n@@ -641,30 +637,24 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let typable: Option<TypableDef> =\n+        let def: TypableDef =\n             // FIXME: this should resolve assoc items as well, see this example:\n             // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n-            match resolver.resolve_path_without_assoc_items(self.db, &path).take_types() {\n-                Some(Resolution::Def(def)) => def.into(),\n-                Some(Resolution::LocalBinding(..)) => {\n-                    // this cannot happen\n-                    log::error!(\"path resolved to local binding in type ns\");\n-                    return (Ty::Unknown, None);\n-                }\n-                Some(Resolution::GenericParam(..)) => {\n-                    // generic params can't be used in struct literals\n-                    return (Ty::Unknown, None);\n-                }\n-                Some(Resolution::SelfType(..)) => {\n-                    // FIXME this is allowed in an impl for a struct, handle this\n-                    return (Ty::Unknown, None);\n+            match resolver.resolve_path_in_type_ns_fully(self.db, &path) {\n+                Some(TypeNs::Adt(Adt::Struct(it))) => it.into(),\n+                Some(TypeNs::Adt(Adt::Union(it))) => it.into(),\n+                Some(TypeNs::EnumVariant(it)) => it.into(),\n+                Some(TypeNs::TypeAlias(it)) => it.into(),\n+\n+                Some(TypeNs::SelfType(_)) |\n+                Some(TypeNs::GenericParam(_)) |\n+                Some(TypeNs::BuiltinType(_)) |\n+                Some(TypeNs::Trait(_)) |\n+                Some(TypeNs::Adt(Adt::Enum(_))) |\n+                None => {\n+                    return (Ty::Unknown, None)\n                 }\n-                None => return (Ty::Unknown, None),\n             };\n-        let def = match typable {\n-            None => return (Ty::Unknown, None),\n-            Some(it) => it,\n-        };\n         // FIXME remove the duplication between here and `Ty::from_path`?\n         let substs = Ty::substs_from_path(self.db, resolver, path, def);\n         match def {"}, {"sha": "3fdb2ca92db6e9749947d5c6a1ca39ea3fd8758d", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -19,7 +19,7 @@ use crate::{\n     generics::{GenericDef, WherePredicate},\n     nameres::Namespace,\n     path::{GenericArg, PathSegment},\n-    resolve::{Resolution, Resolver},\n+    resolve::{Resolver, TypeNs},\n     ty::Adt,\n     type_ref::{TypeBound, TypeRef},\n     BuiltinType, Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField,\n@@ -88,16 +88,47 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Ty {\n         // Resolve the path (in type namespace)\n-        let (resolution, remaining_index) = resolver.resolve_path_segments(db, path).into_inner();\n-        let resolution = resolution.take_types();\n-\n-        let def = match resolution {\n-            Some(Resolution::Def(def)) => def,\n-            Some(Resolution::LocalBinding(..)) => {\n-                // this should never happen\n-                panic!(\"path resolved to local binding in type ns\");\n+        let (resolution, remaining_index) = match resolver.resolve_path_in_type_ns(db, path) {\n+            Some(it) => it,\n+            None => return Ty::Unknown,\n+        };\n+\n+        let typable: TypableDef = match resolution {\n+            TypeNs::Trait(trait_) => {\n+                let segment = match remaining_index {\n+                    None => path.segments.last().expect(\"resolved path has at least one element\"),\n+                    Some(i) => &path.segments[i - 1],\n+                };\n+                let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n+                return if let Some(remaining_index) = remaining_index {\n+                    if remaining_index == path.segments.len() - 1 {\n+                        let segment = &path.segments[remaining_index];\n+                        match trait_ref\n+                            .trait_\n+                            .associated_type_by_name_including_super_traits(db, &segment.name)\n+                        {\n+                            Some(associated_ty) => {\n+                                // FIXME handle type parameters on the segment\n+                                Ty::Projection(ProjectionTy {\n+                                    associated_ty,\n+                                    parameters: trait_ref.substs,\n+                                })\n+                            }\n+                            None => {\n+                                // associated type not found\n+                                Ty::Unknown\n+                            }\n+                        }\n+                    } else {\n+                        // FIXME more than one segment remaining, is this possible?\n+                        Ty::Unknown\n+                    }\n+                } else {\n+                    // FIXME dyn Trait without the dyn\n+                    Ty::Unknown\n+                };\n             }\n-            Some(Resolution::GenericParam(idx)) => {\n+            TypeNs::GenericParam(idx) => {\n                 if remaining_index.is_some() {\n                     // e.g. T::Item\n                     return Ty::Unknown;\n@@ -111,57 +142,24 @@ impl Ty {\n                         .clone(),\n                 };\n             }\n-            Some(Resolution::SelfType(impl_block)) => {\n+            TypeNs::SelfType(impl_block) => {\n                 if remaining_index.is_some() {\n                     // e.g. Self::Item\n                     return Ty::Unknown;\n                 }\n                 return impl_block.target_ty(db);\n             }\n-            None => {\n-                // path did not resolve\n-                return Ty::Unknown;\n-            }\n+\n+            TypeNs::Adt(it) => it.into(),\n+            TypeNs::BuiltinType(it) => it.into(),\n+            TypeNs::TypeAlias(it) => it.into(),\n+            // FIXME: report error\n+            TypeNs::EnumVariant(_) => return Ty::Unknown,\n         };\n \n-        if let ModuleDef::Trait(trait_) = def {\n-            let segment = match remaining_index {\n-                None => path.segments.last().expect(\"resolved path has at least one element\"),\n-                Some(i) => &path.segments[i - 1],\n-            };\n-            let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n-            if let Some(remaining_index) = remaining_index {\n-                if remaining_index == path.segments.len() - 1 {\n-                    let segment = &path.segments[remaining_index];\n-                    let associated_ty = match trait_ref\n-                        .trait_\n-                        .associated_type_by_name_including_super_traits(db, &segment.name)\n-                    {\n-                        Some(t) => t,\n-                        None => {\n-                            // associated type not found\n-                            return Ty::Unknown;\n-                        }\n-                    };\n-                    // FIXME handle type parameters on the segment\n-                    Ty::Projection(ProjectionTy { associated_ty, parameters: trait_ref.substs })\n-                } else {\n-                    // FIXME more than one segment remaining, is this possible?\n-                    Ty::Unknown\n-                }\n-            } else {\n-                // FIXME dyn Trait without the dyn\n-                Ty::Unknown\n-            }\n-        } else {\n-            let typable: TypableDef = match def.into() {\n-                None => return Ty::Unknown,\n-                Some(it) => it,\n-            };\n-            let ty = db.type_for_def(typable, Namespace::Types);\n-            let substs = Ty::substs_from_path(db, resolver, path, typable);\n-            ty.subst(&substs)\n-        }\n+        let ty = db.type_for_def(typable, Namespace::Types);\n+        let substs = Ty::substs_from_path(db, resolver, path, typable);\n+        ty.subst(&substs)\n     }\n \n     pub(super) fn substs_from_path_segment(\n@@ -278,8 +276,8 @@ impl TraitRef {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path_without_assoc_items(db, &path).take_types()? {\n-            Resolution::Def(ModuleDef::Trait(tr)) => tr,\n+        let resolved = match resolver.resolve_path_in_type_ns_fully(db, &path)? {\n+            TypeNs::Trait(tr) => tr,\n             _ => return None,\n         };\n         let segment = path.segments.last().expect(\"path should have at least one segment\");"}, {"sha": "0cbe4abf7d14013d5900cf0828680cada5880b0f", "filename": "crates/ra_ide_api/src/completion/complete_macro_in_item_position.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -3,11 +3,11 @@ use crate::completion::{CompletionContext, Completions};\n pub(super) fn complete_macro_in_item_position(acc: &mut Completions, ctx: &CompletionContext) {\n     // Show only macros in top level.\n     if ctx.is_new_item {\n-        for (name, res) in ctx.analyzer.all_names(ctx.db) {\n-            if res.get_macros().is_some() {\n-                acc.add_resolution(ctx, name.to_string(), &res.only_macros());\n+        ctx.analyzer.process_all_names(ctx.db, &mut |name, res| {\n+            if let hir::ScopeDef::MacroDef(mac) = res {\n+                acc.add_macro(ctx, Some(name.to_string()), mac);\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "5ee2864dcd232e2847d77f7a410730733d9dec99", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Adt, Either, Resolution};\n+use hir::{Adt, Either, PathResolution};\n use ra_syntax::AstNode;\n use test_utils::tested_by;\n \n@@ -9,15 +9,15 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def = match ctx.analyzer.resolve_hir_path(ctx.db, &path).take_types() {\n-        Some(Resolution::Def(def)) => def,\n+    let def = match dbg!(ctx.analyzer.resolve_hir_path(ctx.db, &path)) {\n+        Some(PathResolution::Def(def)) => def,\n         _ => return,\n     };\n     match def {\n         hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n-                if let Some(hir::ModuleDef::BuiltinType(..)) = res.def.as_ref().take_types() {\n+                if let Some(hir::ModuleDef::BuiltinType(..)) = res.def.take_types() {\n                     if ctx.use_item_syntax.is_some() {\n                         tested_by!(dont_complete_primitive_in_use);\n                         continue;\n@@ -34,7 +34,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                         }\n                     }\n                 }\n-                acc.add_resolution(ctx, name.to_string(), &res.def.map(hir::Resolution::Def));\n+                acc.add_resolution(ctx, name.to_string(), &res.def.into());\n             }\n         }\n         hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {"}, {"sha": "c17b5b7ee4b4aaeb331a84bad5b4b73e2330b290", "filename": "crates/ra_ide_api/src/completion/complete_pattern.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -7,22 +7,20 @@ pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n-    let names = ctx.analyzer.all_names(ctx.db);\n-    for (name, res) in names.into_iter() {\n-        let r = res.as_ref();\n-        let def = match r.take_types().or_else(|| r.take_values()) {\n-            Some(hir::Resolution::Def(def)) => def,\n-            _ => continue,\n+    ctx.analyzer.process_all_names(ctx.db, &mut |name, res| {\n+        let def = match &res {\n+            hir::ScopeDef::ModuleDef(def) => def,\n+            _ => return,\n         };\n         match def {\n             hir::ModuleDef::Adt(hir::Adt::Enum(..))\n             | hir::ModuleDef::EnumVariant(..)\n             | hir::ModuleDef::Const(..)\n             | hir::ModuleDef::Module(..) => (),\n-            _ => continue,\n+            _ => return,\n         }\n         acc.add_resolution(ctx, name.to_string(), &res)\n-    }\n+    });\n }\n \n #[cfg(test)]"}, {"sha": "c1f48b0263b082734b27072f7ca6aca26cbd8854", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -10,8 +10,9 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n         return;\n     }\n \n-    let names = ctx.analyzer.all_names(ctx.db);\n-    names.into_iter().for_each(|(name, res)| acc.add_resolution(ctx, name.to_string(), &res));\n+    ctx.analyzer.process_all_names(ctx.db, &mut |name, res| {\n+        acc.add_resolution(ctx, name.to_string(), &res)\n+    });\n \n     // auto-import\n     // We fetch ident from the original file, because we need to pre-filter auto-imports"}, {"sha": "31b88749237959ca08faa29abcd12f78a4688726", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e2d76b9839410020c75ac02ad602675b0a5aa9/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=51e2d76b9839410020c75ac02ad602675b0a5aa9", "patch": "@@ -1,5 +1,5 @@\n-//! This modules takes care of rendering various defenitions as completion items.\n-use hir::{Docs, HasSource, HirDisplay, PerNs, Resolution, Ty, TypeWalk};\n+//! This modules takes care of rendering various definitions as completion items.\n+use hir::{Docs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;\n@@ -39,61 +39,77 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         local_name: String,\n-        resolution: &PerNs<Resolution>,\n+        resolution: &ScopeDef,\n     ) {\n         use hir::ModuleDef::*;\n \n-        if let Some(macro_) = resolution.get_macros() {\n-            self.add_macro(ctx, Some(local_name.clone()), macro_);\n-        }\n+        // if let Some(macro_) = resolution.get_macros() {\n+        //     self.add_macro(ctx, Some(local_name.clone()), macro_);\n+        // }\n \n-        let def = resolution.as_ref().take_types().or_else(|| resolution.as_ref().take_values());\n-        let def = match def {\n-            // Only insert once if it is just a macro name\n-            None if resolution.get_macros().is_some() => return,\n-            None => {\n-                self.add(CompletionItem::new(\n-                    CompletionKind::Reference,\n-                    ctx.source_range(),\n-                    local_name,\n-                ));\n-                return;\n-            }\n-            Some(it) => it,\n-        };\n+        // let def = resolution.as_ref().take_types().or_else(|| resolution.as_ref().take_values());\n+        // let def = match def {\n+        //     // Only insert once if it is just a macro name\n+        //     None if resolution.get_macros().is_some() => return,\n+        //     None => {\n+        //         self.add(CompletionItem::new(\n+        //             CompletionKind::Reference,\n+        //             ctx.source_range(),\n+        //             local_name,\n+        //         ));\n+        //         return;\n+        //     }\n+        //     Some(it) => it,\n+        // };\n         let mut completion_kind = CompletionKind::Reference;\n-        let (kind, docs) = match def {\n-            Resolution::Def(Module(it)) => (CompletionItemKind::Module, it.docs(ctx.db)),\n-            Resolution::Def(Function(func)) => {\n+        let (kind, docs) = match resolution {\n+            ScopeDef::ModuleDef(Module(it)) => (CompletionItemKind::Module, it.docs(ctx.db)),\n+            ScopeDef::ModuleDef(Function(func)) => {\n                 return self.add_function_with_name(ctx, Some(local_name), *func);\n             }\n-            Resolution::Def(Adt(hir::Adt::Struct(it))) => {\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(it))) => {\n                 (CompletionItemKind::Struct, it.docs(ctx.db))\n             }\n-            Resolution::Def(Adt(hir::Adt::Union(it))) => {\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Union(it))) => {\n                 (CompletionItemKind::Struct, it.docs(ctx.db))\n             }\n-            Resolution::Def(Adt(hir::Adt::Enum(it))) => (CompletionItemKind::Enum, it.docs(ctx.db)),\n-            Resolution::Def(EnumVariant(it)) => (CompletionItemKind::EnumVariant, it.docs(ctx.db)),\n-            Resolution::Def(Const(it)) => (CompletionItemKind::Const, it.docs(ctx.db)),\n-            Resolution::Def(Static(it)) => (CompletionItemKind::Static, it.docs(ctx.db)),\n-            Resolution::Def(Trait(it)) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n-            Resolution::Def(TypeAlias(it)) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n-            Resolution::Def(BuiltinType(..)) => {\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(it))) => {\n+                (CompletionItemKind::Enum, it.docs(ctx.db))\n+            }\n+            ScopeDef::ModuleDef(EnumVariant(it)) => {\n+                (CompletionItemKind::EnumVariant, it.docs(ctx.db))\n+            }\n+            ScopeDef::ModuleDef(Const(it)) => (CompletionItemKind::Const, it.docs(ctx.db)),\n+            ScopeDef::ModuleDef(Static(it)) => (CompletionItemKind::Static, it.docs(ctx.db)),\n+            ScopeDef::ModuleDef(Trait(it)) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n+            ScopeDef::ModuleDef(TypeAlias(it)) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n+            ScopeDef::ModuleDef(BuiltinType(..)) => {\n                 completion_kind = CompletionKind::BuiltinType;\n                 (CompletionItemKind::BuiltinType, None)\n             }\n-            Resolution::GenericParam(..) => (CompletionItemKind::TypeParam, None),\n-            Resolution::LocalBinding(..) => (CompletionItemKind::Binding, None),\n-            Resolution::SelfType(..) => (\n+            ScopeDef::GenericParam(..) => (CompletionItemKind::TypeParam, None),\n+            ScopeDef::LocalBinding(..) => (CompletionItemKind::Binding, None),\n+            ScopeDef::SelfType(..) => (\n                 CompletionItemKind::TypeParam, // (does this need its own kind?)\n                 None,\n             ),\n+            ScopeDef::MacroDef(mac) => {\n+                self.add_macro(ctx, Some(local_name.clone()), *mac);\n+                return;\n+            }\n+            ScopeDef::Unknown => {\n+                self.add(CompletionItem::new(\n+                    CompletionKind::Reference,\n+                    ctx.source_range(),\n+                    local_name,\n+                ));\n+                return;\n+            }\n         };\n \n         let mut completion_item =\n             CompletionItem::new(completion_kind, ctx.source_range(), local_name);\n-        if let Resolution::LocalBinding(pat_id) = def {\n+        if let ScopeDef::LocalBinding(pat_id) = resolution {\n             let ty = ctx\n                 .analyzer\n                 .type_of_pat_by_id(ctx.db, pat_id.clone())\n@@ -108,7 +124,12 @@ impl Completions {\n         self.add_function_with_name(ctx, None, func)\n     }\n \n-    fn add_macro(&mut self, ctx: &CompletionContext, name: Option<String>, macro_: hir::MacroDef) {\n+    pub(crate) fn add_macro(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        name: Option<String>,\n+        macro_: hir::MacroDef,\n+    ) {\n         let ast_node = macro_.source(ctx.db).ast;\n         if let Some(name) = name {\n             let detail = macro_label(&ast_node);"}]}