{"sha": "40fd785199d80a06c1a1664d64209f78343c0e05", "node_id": "C_kwDOAAsO6NoAKDQwZmQ3ODUxOTlkODBhMDZjMWExNjY0ZDY0MjA5Zjc4MzQzYzBlMDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T10:46:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-15T10:46:43Z"}, "message": "Auto merge of #7978 - smoelius:master, r=llogiq\n\nAdd `unnecessary_to_owned` lint\n\nThis PR adds a lint to check for unnecessary calls to `ToOwned::to_owned` and other similar functions (e.g., `Cow::into_owned`, `ToString::to_string`, etc.).\n\nThe lint checks for expressions of the form `&receiver.to_owned_like()` used in a position requiring type `&T` where one of the following is true:\n* `receiver`'s type is `T` exactly\n* `receiver`'s type implements `Deref<Target = T>`\n* `receiver`'s type implements `AsRef<T>`\n\nThe lint additionally checks for expressions of the form `receiver.to_owned_like()` used as arguments of type `impl AsRef<T>`.\n\nIt would be nice if the lint could also check for expressions used as arguments to functions like the following:\n```\nfn foo<T: AsRef<str>>(x: T) { ... }\n```\nHowever, I couldn't figure out how to determine whether a function input type was instantiated from a parameter with a trait bound.\n\nIf someone could offer me some guidance, I would be happy to add such functionality.\n\nCloses #7933\n\nchangelog: Add [`unnecessary_to_owned`] lint", "tree": {"sha": "fa0c4f45b7d51dc4d4d3b158e78fbcc59d9c56eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa0c4f45b7d51dc4d4d3b158e78fbcc59d9c56eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40fd785199d80a06c1a1664d64209f78343c0e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40fd785199d80a06c1a1664d64209f78343c0e05", "html_url": "https://github.com/rust-lang/rust/commit/40fd785199d80a06c1a1664d64209f78343c0e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40fd785199d80a06c1a1664d64209f78343c0e05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa3648af504389ece9c5e09b848b450edad3ac38", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3648af504389ece9c5e09b848b450edad3ac38", "html_url": "https://github.com/rust-lang/rust/commit/aa3648af504389ece9c5e09b848b450edad3ac38"}, {"sha": "b8913894a13431bea99400dc9f53a1fd9f41a6c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8913894a13431bea99400dc9f53a1fd9f41a6c6", "html_url": "https://github.com/rust-lang/rust/commit/b8913894a13431bea99400dc9f53a1fd9f41a6c6"}], "stats": {"total": 1907, "additions": 1887, "deletions": 20}, "files": [{"sha": "7b5279cda6ea396f48cf49df821ee9b48ab31075", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -3210,6 +3210,7 @@ Released 2018-09-13\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n+[`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unnecessary_wraps`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_wraps\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern"}, {"sha": "3d3999d4cc0d8a99bbc0bd7b408a74834402da8d", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -181,6 +181,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(methods::WRONG_SELF_CONVENTION),"}, {"sha": "766c5ba1bcb0f73e3837ad856f266257b433ebea", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -315,6 +315,7 @@ store.register_lints(&[\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n     methods::USELESS_ASREF,"}, {"sha": "2ea0b696f1feb3ad437c61d8c9c1072de7da606f", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -17,6 +17,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(misc::CMP_OWNED),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),"}, {"sha": "90492ffda3cc6e626706dde8ee340b459ff7bd38", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -12,15 +12,7 @@ use super::IMPLICIT_CLONE;\n pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, span: Span) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if match method_name {\n-            \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n-            \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n-            \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n-            \"to_vec\" => cx.tcx.impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true),\n-            _ => false,\n-        };\n+        if is_clone_like(cx, method_name, method_def_id);\n         let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(recv).peel_refs();\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n@@ -38,3 +30,22 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n         }\n     }\n }\n+\n+/// Returns true if the named method can be used to clone the receiver.\n+/// Note that `to_string` is not flagged by `implicit_clone`. So other lints that call\n+/// `is_clone_like` and that do flag `to_string` must handle it separately. See, e.g.,\n+/// `is_to_owned_like` in `unnecessary_to_owned.rs`.\n+pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir::def_id::DefId) -> bool {\n+    match method_name {\n+        \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n+        \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n+        \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n+        \"to_vec\" => {\n+            cx.tcx\n+                .impl_of_method(method_def_id)\n+                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n+                == Some(true)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "3c43671dd34c9e0f1e44581989f1c1751880ba5f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -56,7 +56,9 @@ mod suspicious_splitn;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n+mod unnecessary_iter_cloned;\n mod unnecessary_lazy_eval;\n+mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n@@ -1885,6 +1887,32 @@ declare_clippy_lint! {\n     \"usages of `str::splitn` that can be replaced with `str::split`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary calls to [`ToOwned::to_owned`](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned)\n+    /// and other `to_owned`-like functions.\n+    ///\n+    /// ### Why is this bad?\n+    /// The unnecessary calls result in useless allocations.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy().to_string());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub UNNECESSARY_TO_OWNED,\n+    perf,\n+    \"unnecessary calls to `to_owned`-like functions\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1964,7 +1992,8 @@ impl_lint_pass!(Methods => [\n     MANUAL_STR_REPEAT,\n     EXTEND_WITH_DRAIN,\n     MANUAL_SPLIT_ONCE,\n-    NEEDLESS_SPLITN\n+    NEEDLESS_SPLITN,\n+    UNNECESSARY_TO_OWNED,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2007,6 +2036,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 single_char_add_str::check(cx, expr, args);\n                 into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {"}, {"sha": "8300df03e9935a9f0219364edc2ebc3a817cd2c4", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,177 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::ForLoop;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+use rustc_span::{sym, Symbol};\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        then {\n+            check_for_loop_iter(cx, parent, method_name, receiver)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is an iterator in a `for` loop and, if so, determines whether the\n+/// iterated-over items could be iterated over by reference. The reason why `check` above does not\n+/// include this code directly is so that it can be called from\n+/// `unnecessary_into_owned::check_into_iter_call_arg`.\n+pub fn check_for_loop_iter(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(grandparent) = get_parent_expr(cx, expr).and_then(|parent| get_parent_expr(cx, parent));\n+        if let Some(ForLoop { pat, body, .. }) = ForLoop::hir(grandparent);\n+        let (clone_or_copy_needed, addr_of_exprs) = clone_or_copy_needed(cx, pat, body);\n+        if !clone_or_copy_needed;\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let snippet = if_chain! {\n+                if let ExprKind::MethodCall(maybe_iter_method_name, _, [collection], _) = receiver.kind;\n+                if maybe_iter_method_name.ident.name == sym::iter;\n+\n+                if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                if implements_trait(cx, receiver_ty, iterator_trait_id, &[]);\n+                if let Some(iter_item_ty) = get_iterator_item_ty(cx, receiver_ty);\n+\n+                if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n+                let collection_ty = cx.typeck_results().expr_ty(collection);\n+                if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n+                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+\n+                if iter_item_ty == into_iter_item_ty;\n+                if let Some(collection_snippet) = snippet_opt(cx, collection.span);\n+                then {\n+                    collection_snippet\n+                } else {\n+                    receiver_snippet\n+                }\n+            };\n+            span_lint_and_then(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                expr.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                |diag| {\n+                    diag.span_suggestion(expr.span, \"use\", snippet, Applicability::MachineApplicable);\n+                    for addr_of_expr in addr_of_exprs {\n+                        match addr_of_expr.kind {\n+                            ExprKind::AddrOf(_, _, referent) => {\n+                                let span = addr_of_expr.span.with_hi(referent.span.lo());\n+                                diag.span_suggestion(span, \"remove this `&`\", String::new(), Applicability::MachineApplicable);\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                }\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n+/// `CloneOrCopyVisitor`.\n+fn clone_or_copy_needed(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, _, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}\n+\n+/// Returns true if the named method is `IntoIterator::into_iter`.\n+pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n+    cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)\n+}"}, {"sha": "c48bacfce0d37739f159b379fac6d10921093dac", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,397 @@\n+use super::implicit_clone::is_clone_like;\n+use super::unnecessary_iter_cloned::{self, is_into_iter};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_span::{sym, Symbol};\n+use std::cmp::max;\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n+    if_chain! {\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let [receiver] = args;\n+        then {\n+            if is_cloned_or_copied(cx, method_name, method_def_id) {\n+                unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n+            } else if is_to_owned_like(cx, method_name, method_def_id) {\n+                // At this point, we know the call is of a `to_owned`-like function. The functions\n+                // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n+                // based on its context, that is, whether it is a referent in an `AddrOf` expression, an\n+                // argument in a `into_iter` call, or an argument in the call of some other function.\n+                if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n+                    return;\n+                }\n+                if check_into_iter_call_arg(cx, expr, method_name, receiver) {\n+                    return;\n+                }\n+                check_other_call_arg(cx, expr, method_name, receiver);\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is a referent in an `AddrOf` expression and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+#[allow(clippy::too_many_lines)]\n+fn check_addr_of_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind;\n+        let adjustments = cx.typeck_results().expr_adjustments(parent).iter().collect::<Vec<_>>();\n+        if let Some(target_ty) = match adjustments[..]\n+        {\n+            // For matching uses of `Cow::from`\n+            [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching uses of arrays\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Pointer(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching everything else\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Deref(Some(OverloadedDeref { .. })),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ] => Some(target_ty),\n+            _ => None,\n+        };\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // Only flag cases where the receiver is copyable or the method is `Cow::into_owned`. This\n+        // restriction is to ensure there is not overlap between `redundant_clone` and this lint.\n+        if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n+            if receiver_ty == target_ty && n_target_refs >= n_receiver_refs {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_TO_OWNED,\n+                    parent.span,\n+                    &format!(\"unnecessary use of `{}`\", method_name),\n+                    \"use\",\n+                    format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_target_refs - n_receiver_refs),\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n+            }\n+            if_chain! {\n+                if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+                if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n+                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                then {\n+                    if n_receiver_refs > 0 {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            parent.span,\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"use\",\n+                            receiver_snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            expr.span.with_lo(receiver.span.hi()),\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"remove this\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    return true;\n+                }\n+            }\n+            if_chain! {\n+                if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+                if implements_trait(cx, receiver_ty, as_ref_trait_id, &[GenericArg::from(target_ty)]);\n+                then {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        parent.span,\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"use\",\n+                        format!(\"{}.as_ref()\", receiver_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks whether `expr` is an argument in an `into_iter` call and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+fn check_into_iter_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        let parent_ty = cx.typeck_results().expr_ty(parent);\n+        if implements_trait(cx, parent_ty, iterator_trait_id, &[]);\n+        if let Some(item_ty) = get_iterator_item_ty(cx, parent_ty);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver) {\n+                return true;\n+            }\n+            let cloned_or_copied = if is_copy(cx, item_ty) {\n+                \"copied\"\n+            } else {\n+                \"cloned\"\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                parent.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{}.iter().{}()\", receiver_snippet, cloned_or_copied),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks whether `expr` is an argument in a function call and, if so, determines whether its call\n+/// of a `to_owned`-like function is unnecessary.\n+fn check_other_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n+        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        if let Some(input) = fn_sig.inputs().get(i);\n+        let (input, n_refs) = peel_mid_ty_refs(input);\n+        if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n+        if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n+        if let [trait_predicate] = trait_predicates\n+            .iter()\n+            .filter(|trait_predicate| trait_predicate.def_id() != sized_def_id)\n+            .collect::<Vec<_>>()[..];\n+        if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+        if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // If the callee has type parameters, they could appear in `projection_predicate.ty` or the\n+        // types of `trait_predicate.trait_ref.substs`.\n+        if if trait_predicate.def_id() == deref_trait_id {\n+            if let [projection_predicate] = projection_predicates[..] {\n+                let normalized_ty =\n+                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.ty);\n+                implements_trait(cx, receiver_ty, deref_trait_id, &[])\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(normalized_ty)\n+            } else {\n+                false\n+            }\n+        } else if trait_predicate.def_id() == as_ref_trait_id {\n+            let composed_substs = compose_substs(\n+                cx,\n+                &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n+                call_substs\n+            );\n+            implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n+        } else {\n+            false\n+        };\n+        // We can't add an `&` when the trait is `Deref` because `Target = &T` won't match\n+        // `Target = T`.\n+        if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n+        let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                maybe_arg.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_refs),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Walks an expression's ancestors until it finds a non-`AddrOf` expression. Returns the first such\n+/// expression found (if any) along with the immediately prior expression.\n+fn skip_addr_of_ancestors(\n+    cx: &LateContext<'tcx>,\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    while let Some(parent) = get_parent_expr(cx, expr) {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind {\n+            expr = parent;\n+        } else {\n+            return Some((parent, expr));\n+        }\n+    }\n+    None\n+}\n+\n+/// Checks whether an expression is a function or method call and, if so, returns its `DefId`,\n+/// `Substs`, and arguments.\n+fn get_callee_substs_and_args(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+    if_chain! {\n+        if let ExprKind::Call(callee, args) = expr.kind;\n+        let callee_ty = cx.typeck_results().expr_ty(callee);\n+        if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n+        then {\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            return Some((*callee_def_id, substs, args));\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, args, _) = expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        then {\n+            let substs = cx.typeck_results().node_substs(expr.hir_id);\n+            return Some((method_def_id, substs, args));\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns the `TraitPredicate`s and `ProjectionPredicate`s for a function's input type.\n+fn get_input_traits_and_projections(\n+    cx: &LateContext<'tcx>,\n+    callee_def_id: DefId,\n+    input: Ty<'tcx>,\n+) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n+    let mut trait_predicates = Vec::new();\n+    let mut projection_predicates = Vec::new();\n+    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n+        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n+        // `as`. The remaining n are trait parameters.\n+        let is_input_substs = |substs: SubstsRef<'tcx>| {\n+            if_chain! {\n+                if let Some(arg) = substs.iter().next();\n+                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n+                if arg_ty == input;\n+                then {\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+        match predicate.kind().skip_binder() {\n+            PredicateKind::Trait(trait_predicate) => {\n+                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                    trait_predicates.push(trait_predicate);\n+                }\n+            },\n+            PredicateKind::Projection(projection_predicate) => {\n+                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                    projection_predicates.push(projection_predicate);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+    (trait_predicates, projection_predicates)\n+}\n+\n+/// Composes two substitutions by applying the latter to the types of the former.\n+fn compose_substs(cx: &LateContext<'tcx>, left: &[GenericArg<'tcx>], right: SubstsRef<'tcx>) -> Vec<GenericArg<'tcx>> {\n+    left.iter()\n+        .map(|arg| {\n+            if let GenericArgKind::Type(arg_ty) = arg.unpack() {\n+                let normalized_ty = cx.tcx.subst_and_normalize_erasing_regions(right, cx.param_env, arg_ty);\n+                GenericArg::from(normalized_ty)\n+            } else {\n+                *arg\n+            }\n+        })\n+        .collect()\n+}\n+\n+/// Returns true if the named method is `Iterator::cloned` or `Iterator::copied`.\n+fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    (method_name.as_str() == \"cloned\" || method_name.as_str() == \"copied\")\n+        && is_diag_trait_item(cx, method_def_id, sym::Iterator)\n+}\n+\n+/// Returns true if the named method can be used to convert the receiver to its \"owned\"\n+/// representation.\n+fn is_to_owned_like(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    is_clone_like(cx, &*method_name.as_str(), method_def_id)\n+        || is_cow_into_owned(cx, method_name, method_def_id)\n+        || is_to_string(cx, method_name, method_def_id)\n+}\n+\n+/// Returns true if the named method is `Cow::into_owned`.\n+fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"into_owned\" && is_diag_item_method(cx, method_def_id, sym::Cow)\n+}\n+\n+/// Returns true if the named method is `ToString::to_string`.\n+fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"to_string\" && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+}"}, {"sha": "fe35ff33d35a4736f49f8a3b656e75b3f82b787d", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n                                     trait_name\n                                 ),\n                                 Some(last_semi),\n-                                &\"probably caused by this trailing semicolon\".to_string(),\n+                                \"probably caused by this trailing semicolon\",\n                             );\n                         },\n                         None => {},"}, {"sha": "6d191d4a59bde9948d4fa84e26aacc9ed5d7268c", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -58,14 +58,20 @@ pub fn contains_adt_constructor<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, adt: &'tc\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| {\n-            cx.tcx.associated_items(iter_did).find_by_name_and_kind(\n-                cx.tcx,\n-                Ident::from_str(\"Item\"),\n-                ty::AssocKind::Type,\n-                iter_did,\n-            )\n-        })\n+        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n+}\n+\n+/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n+/// Do not invoke without first verifying that the type implements the trait.\n+pub fn get_associated_type<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_id: DefId,\n+    name: &str,\n+) -> Option<Ty<'tcx>> {\n+    cx.tcx\n+        .associated_items(trait_id)\n+        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n         .map(|assoc| {\n             let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n             cx.tcx.normalize_erasing_regions(cx.param_env, proj)"}, {"sha": "2066915e1d184a9d6d9d8c96256dddfd057f040c", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n }\n \n pub struct ParamBindingIdCollector {\n-    binding_hir_ids: Vec<hir::HirId>,\n+    pub binding_hir_ids: Vec<hir::HirId>,\n }\n impl<'tcx> ParamBindingIdCollector {\n     fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {"}, {"sha": "e01e9f07bafdaf28d8e2552a7e2110b5af69f736", "filename": "tests/ui/unnecessary_iter_cloned.fixed", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.fixed?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "6ef2966c8b762d373060133bca21c4ab68ba5fd9", "filename": "tests/ui/unnecessary_iter_cloned.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "e44379f8aa04783b35390018a3a5538e11a3c640", "filename": "tests/ui/unnecessary_iter_cloned.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_iter_cloned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.stderr?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,35 @@\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:31:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+help: use\n+   |\n+LL |     for (t, path) in files {\n+   |                      ~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:46:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for (t, path) in files.iter() {\n+   |                      ~~~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "720138db137726cbf6c1844a6ba2d63b8aa0e7c6", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, CString, OsStr, OsString};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n+\n+    require_c_str(&Cow::from(c_str));\n+    require_c_str(c_str);\n+\n+    require_os_str(os_str);\n+    require_os_str(&Cow::from(os_str));\n+    require_os_str(os_str);\n+\n+    require_path(path);\n+    require_path(&Cow::from(path));\n+    require_path(path);\n+\n+    require_str(s);\n+    require_str(&Cow::from(s));\n+    require_str(s);\n+    require_str(x_ref.as_ref());\n+\n+    require_slice(slice);\n+    require_slice(&Cow::from(slice));\n+    require_slice(array.as_ref());\n+    require_slice(array_ref.as_ref());\n+    require_slice(slice);\n+    require_slice(x_ref);\n+\n+    require_x(&Cow::<X>::Owned(x.clone()));\n+    require_x(x_ref);\n+\n+    require_deref_c_str(c_str);\n+    require_deref_os_str(os_str);\n+    require_deref_path(path);\n+    require_deref_str(s);\n+    require_deref_slice(slice);\n+\n+    require_impl_deref_c_str(c_str);\n+    require_impl_deref_os_str(os_str);\n+    require_impl_deref_path(path);\n+    require_impl_deref_str(s);\n+    require_impl_deref_slice(slice);\n+\n+    require_deref_str_slice(s, slice);\n+    require_deref_slice_str(slice, s);\n+\n+    require_as_ref_c_str(c_str);\n+    require_as_ref_os_str(os_str);\n+    require_as_ref_path(path);\n+    require_as_ref_str(s);\n+    require_as_ref_str(&x);\n+    require_as_ref_slice(array);\n+    require_as_ref_slice(array_ref);\n+    require_as_ref_slice(slice);\n+\n+    require_impl_as_ref_c_str(c_str);\n+    require_impl_as_ref_os_str(os_str);\n+    require_impl_as_ref_path(path);\n+    require_impl_as_ref_str(s);\n+    require_impl_as_ref_str(&x);\n+    require_impl_as_ref_slice(array);\n+    require_impl_as_ref_slice(array_ref);\n+    require_impl_as_ref_slice(slice);\n+\n+    require_as_ref_str_slice(s, array);\n+    require_as_ref_str_slice(s, array_ref);\n+    require_as_ref_str_slice(s, slice);\n+    require_as_ref_slice_str(array, s);\n+    require_as_ref_slice_str(array_ref, s);\n+    require_as_ref_slice_str(slice, s);\n+\n+    let _ = x.join(x_ref);\n+\n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x_ref.to_string());\n+\n+    // `X` isn't copy.\n+    require_slice(&x.to_owned());\n+    require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap());\n+    require_os_str(&OsString::from(\"x\"));\n+    require_path(&std::path::PathBuf::from(\"x\"));\n+    require_str(&String::from(\"x\"));\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types {\n+        let path = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n+fn require_string(_: &String) {}"}, {"sha": "60b2e718f5d499aefb887461737c0ab0ea42d68e", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, CString, OsStr, OsString};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n+\n+    require_c_str(&Cow::from(c_str).into_owned());\n+    require_c_str(&c_str.to_owned());\n+\n+    require_os_str(&os_str.to_os_string());\n+    require_os_str(&Cow::from(os_str).into_owned());\n+    require_os_str(&os_str.to_owned());\n+\n+    require_path(&path.to_path_buf());\n+    require_path(&Cow::from(path).into_owned());\n+    require_path(&path.to_owned());\n+\n+    require_str(&s.to_string());\n+    require_str(&Cow::from(s).into_owned());\n+    require_str(&s.to_owned());\n+    require_str(&x_ref.to_string());\n+\n+    require_slice(&slice.to_vec());\n+    require_slice(&Cow::from(slice).into_owned());\n+    require_slice(&array.to_owned());\n+    require_slice(&array_ref.to_owned());\n+    require_slice(&slice.to_owned());\n+    require_slice(&x_ref.to_owned());\n+\n+    require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+    require_x(&x_ref.to_owned());\n+\n+    require_deref_c_str(c_str.to_owned());\n+    require_deref_os_str(os_str.to_owned());\n+    require_deref_path(path.to_owned());\n+    require_deref_str(s.to_owned());\n+    require_deref_slice(slice.to_owned());\n+\n+    require_impl_deref_c_str(c_str.to_owned());\n+    require_impl_deref_os_str(os_str.to_owned());\n+    require_impl_deref_path(path.to_owned());\n+    require_impl_deref_str(s.to_owned());\n+    require_impl_deref_slice(slice.to_owned());\n+\n+    require_deref_str_slice(s.to_owned(), slice.to_owned());\n+    require_deref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    require_as_ref_c_str(c_str.to_owned());\n+    require_as_ref_os_str(os_str.to_owned());\n+    require_as_ref_path(path.to_owned());\n+    require_as_ref_str(s.to_owned());\n+    require_as_ref_str(x.to_owned());\n+    require_as_ref_slice(array.to_owned());\n+    require_as_ref_slice(array_ref.to_owned());\n+    require_as_ref_slice(slice.to_owned());\n+\n+    require_impl_as_ref_c_str(c_str.to_owned());\n+    require_impl_as_ref_os_str(os_str.to_owned());\n+    require_impl_as_ref_path(path.to_owned());\n+    require_impl_as_ref_str(s.to_owned());\n+    require_impl_as_ref_str(x.to_owned());\n+    require_impl_as_ref_slice(array.to_owned());\n+    require_impl_as_ref_slice(array_ref.to_owned());\n+    require_impl_as_ref_slice(slice.to_owned());\n+\n+    require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+    require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    let _ = x.join(&x_ref.to_string());\n+\n+    let _ = slice.to_vec().into_iter();\n+    let _ = slice.to_owned().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+\n+    let _ = IntoIterator::into_iter(slice.to_vec());\n+    let _ = IntoIterator::into_iter(slice.to_owned());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x_ref.to_string());\n+\n+    // `X` isn't copy.\n+    require_slice(&x.to_owned());\n+    require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+    require_os_str(&OsString::from(\"x\").to_os_string());\n+    require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+    require_str(&String::from(\"x\").to_string());\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types.to_vec() {\n+        let path = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n+fn require_string(_: &String) {}"}, {"sha": "1dfc65e22e2bc7c9d023389b9ba02ef74fd14f47", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/40fd785199d80a06c1a1664d64209f78343c0e05/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=40fd785199d80a06c1a1664d64209f78343c0e05", "patch": "@@ -0,0 +1,495 @@\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:150:64\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                                                                ^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::redundant-clone` implied by `-D warnings`\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:150:20\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:151:40\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                                        ^^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:151:21\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:152:48\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                                                ^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:152:19\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:153:35\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                                   ^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:153:18\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                  ^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:59:36\n+   |\n+LL |     require_c_str(&Cow::from(c_str).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:60:19\n+   |\n+LL |     require_c_str(&c_str.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_os_string`\n+  --> $DIR/unnecessary_to_owned.rs:62:20\n+   |\n+LL |     require_os_str(&os_str.to_os_string());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:63:38\n+   |\n+LL |     require_os_str(&Cow::from(os_str).into_owned());\n+   |                                      ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:64:20\n+   |\n+LL |     require_os_str(&os_str.to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_path_buf`\n+  --> $DIR/unnecessary_to_owned.rs:66:18\n+   |\n+LL |     require_path(&path.to_path_buf());\n+   |                  ^^^^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:67:34\n+   |\n+LL |     require_path(&Cow::from(path).into_owned());\n+   |                                  ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:68:18\n+   |\n+LL |     require_path(&path.to_owned());\n+   |                  ^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:70:17\n+   |\n+LL |     require_str(&s.to_string());\n+   |                 ^^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:71:30\n+   |\n+LL |     require_str(&Cow::from(s).into_owned());\n+   |                              ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:72:17\n+   |\n+LL |     require_str(&s.to_owned());\n+   |                 ^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:73:17\n+   |\n+LL |     require_str(&x_ref.to_string());\n+   |                 ^^^^^^^^^^^^^^^^^^ help: use: `x_ref.as_ref()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:75:19\n+   |\n+LL |     require_slice(&slice.to_vec());\n+   |                   ^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:76:36\n+   |\n+LL |     require_slice(&Cow::from(slice).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:77:19\n+   |\n+LL |     require_slice(&array.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `array.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:78:19\n+   |\n+LL |     require_slice(&array_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:79:19\n+   |\n+LL |     require_slice(&slice.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:80:19\n+   |\n+LL |     require_slice(&x_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:82:42\n+   |\n+LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+   |                                          ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:83:15\n+   |\n+LL |     require_x(&x_ref.to_owned());\n+   |               ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:85:25\n+   |\n+LL |     require_deref_c_str(c_str.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:86:26\n+   |\n+LL |     require_deref_os_str(os_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:87:24\n+   |\n+LL |     require_deref_path(path.to_owned());\n+   |                        ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:88:23\n+   |\n+LL |     require_deref_str(s.to_owned());\n+   |                       ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:89:25\n+   |\n+LL |     require_deref_slice(slice.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:91:30\n+   |\n+LL |     require_impl_deref_c_str(c_str.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:92:31\n+   |\n+LL |     require_impl_deref_os_str(os_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:93:29\n+   |\n+LL |     require_impl_deref_path(path.to_owned());\n+   |                             ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:94:28\n+   |\n+LL |     require_impl_deref_str(s.to_owned());\n+   |                            ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:95:30\n+   |\n+LL |     require_impl_deref_slice(slice.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:97:29\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:97:43\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                           ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:98:29\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                             ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:98:47\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                               ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:100:26\n+   |\n+LL |     require_as_ref_c_str(c_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:101:27\n+   |\n+LL |     require_as_ref_os_str(os_str.to_owned());\n+   |                           ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:102:25\n+   |\n+LL |     require_as_ref_path(path.to_owned());\n+   |                         ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:103:24\n+   |\n+LL |     require_as_ref_str(s.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:104:24\n+   |\n+LL |     require_as_ref_str(x.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:105:26\n+   |\n+LL |     require_as_ref_slice(array.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:106:26\n+   |\n+LL |     require_as_ref_slice(array_ref.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:107:26\n+   |\n+LL |     require_as_ref_slice(slice.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:109:31\n+   |\n+LL |     require_impl_as_ref_c_str(c_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:110:32\n+   |\n+LL |     require_impl_as_ref_os_str(os_str.to_owned());\n+   |                                ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:111:30\n+   |\n+LL |     require_impl_as_ref_path(path.to_owned());\n+   |                              ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:112:29\n+   |\n+LL |     require_impl_as_ref_str(s.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:113:29\n+   |\n+LL |     require_impl_as_ref_str(x.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:114:31\n+   |\n+LL |     require_impl_as_ref_slice(array.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:115:31\n+   |\n+LL |     require_impl_as_ref_slice(array_ref.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:116:31\n+   |\n+LL |     require_impl_as_ref_slice(slice.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:120:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:120:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:121:30\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:121:48\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:122:30\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:122:52\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                                                    ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:123:30\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:123:48\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:125:20\n+   |\n+LL |     let _ = x.join(&x_ref.to_string());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:127:13\n+   |\n+LL |     let _ = slice.to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:128:13\n+   |\n+LL |     let _ = slice.to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:129:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:130:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:132:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:133:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:134:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:135:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:196:14\n+   |\n+LL |     for t in file_types.to_vec() {\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for t in file_types {\n+   |              ~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let path = match get_file_path(&t) {\n+LL +         let path = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 76 previous errors\n+"}]}