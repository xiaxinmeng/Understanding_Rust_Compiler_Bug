{"sha": "b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "node_id": "C_kwDOAAsO6NoAKGIyZjZmZDRmOTYxZmM3ZTRmYmZkYjgwY2FlMmU2MDY1Zjg0MzZmMTU", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-03-13T08:42:24Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2023-03-13T08:42:24Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "bcdfaabb2821bb74ce6313de7e2741e4625bf74b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcdfaabb2821bb74ce6313de7e2741e4625bf74b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "html_url": "https://github.com/rust-lang/rust/commit/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15b867b5db35d67e0f1026b55f22ba6b25ad6dcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb", "html_url": "https://github.com/rust-lang/rust/commit/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb"}], "stats": {"total": 15690, "additions": 12635, "deletions": 3055}, "files": [{"sha": "fc77515b63bfdf3b8f64fa6b0f970993ef36ef9e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -572,6 +572,7 @@ dependencies = [\n  \"chalk-recursive\",\n  \"chalk-solve\",\n  \"cov-mark\",\n+ \"either\",\n  \"ena\",\n  \"expect-test\",\n  \"hir-def\",\n@@ -1714,6 +1715,7 @@ name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n  \"cov-mark\",\n+ \"either\",\n  \"expect-test\",\n  \"indexmap\",\n  \"itertools\","}, {"sha": "accb14a51deb9f9254ac5652bf843bf68fca9873", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 67, "deletions": 42, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -76,7 +76,7 @@ impl fmt::Display for FlycheckConfig {\n #[derive(Debug)]\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n-    sender: Sender<Restart>,\n+    sender: Sender<StateChange>,\n     _thread: jod_thread::JoinHandle,\n     id: usize,\n }\n@@ -89,7 +89,7 @@ impl FlycheckHandle {\n         workspace_root: AbsPathBuf,\n     ) -> FlycheckHandle {\n         let actor = FlycheckActor::new(id, sender, config, workspace_root);\n-        let (sender, receiver) = unbounded::<Restart>();\n+        let (sender, receiver) = unbounded::<StateChange>();\n         let thread = jod_thread::Builder::new()\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n@@ -99,12 +99,12 @@ impl FlycheckHandle {\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn restart(&self) {\n-        self.sender.send(Restart::Yes).unwrap();\n+        self.sender.send(StateChange::Restart).unwrap();\n     }\n \n     /// Stop this cargo check worker.\n     pub fn cancel(&self) {\n-        self.sender.send(Restart::No).unwrap();\n+        self.sender.send(StateChange::Cancel).unwrap();\n     }\n \n     pub fn id(&self) -> usize {\n@@ -149,9 +149,9 @@ pub enum Progress {\n     DidFailToRestart(String),\n }\n \n-enum Restart {\n-    Yes,\n-    No,\n+enum StateChange {\n+    Restart,\n+    Cancel,\n }\n \n /// A [`FlycheckActor`] is a single check instance of a workspace.\n@@ -172,7 +172,7 @@ struct FlycheckActor {\n }\n \n enum Event {\n-    Restart(Restart),\n+    RequestStateChange(StateChange),\n     CheckEvent(Option<CargoMessage>),\n }\n \n@@ -191,30 +191,31 @@ impl FlycheckActor {\n         self.send(Message::Progress { id: self.id, progress });\n     }\n \n-    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+    fn next_event(&self, inbox: &Receiver<StateChange>) -> Option<Event> {\n         let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n         if let Ok(msg) = inbox.try_recv() {\n             // give restarts a preference so check outputs don't block a restart or stop\n-            return Some(Event::Restart(msg));\n+            return Some(Event::RequestStateChange(msg));\n         }\n         select! {\n-            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(inbox) -> msg => msg.ok().map(Event::RequestStateChange),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n         }\n     }\n \n-    fn run(mut self, inbox: Receiver<Restart>) {\n+    fn run(mut self, inbox: Receiver<StateChange>) {\n         'event: while let Some(event) = self.next_event(&inbox) {\n             match event {\n-                Event::Restart(Restart::No) => {\n+                Event::RequestStateChange(StateChange::Cancel) => {\n+                    tracing::debug!(flycheck_id = self.id, \"flycheck cancelled\");\n                     self.cancel_check_process();\n                 }\n-                Event::Restart(Restart::Yes) => {\n+                Event::RequestStateChange(StateChange::Restart) => {\n                     // Cancel the previously spawned process\n                     self.cancel_check_process();\n                     while let Ok(restart) = inbox.recv_timeout(Duration::from_millis(50)) {\n                         // restart chained with a stop, so just cancel\n-                        if let Restart::No = restart {\n+                        if let StateChange::Cancel = restart {\n                             continue 'event;\n                         }\n                     }\n@@ -255,10 +256,20 @@ impl FlycheckActor {\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n                     CargoMessage::CompilerArtifact(msg) => {\n+                        tracing::trace!(\n+                            flycheck_id = self.id,\n+                            artifact = msg.target.name,\n+                            \"artifact received\"\n+                        );\n                         self.report_progress(Progress::DidCheckCrate(msg.target.name));\n                     }\n \n                     CargoMessage::Diagnostic(msg) => {\n+                        tracing::trace!(\n+                            flycheck_id = self.id,\n+                            message = msg.message,\n+                            \"diagnostic received\"\n+                        );\n                         self.send(Message::AddDiagnostic {\n                             id: self.id,\n                             workspace_root: self.root.clone(),\n@@ -445,42 +456,56 @@ impl CargoActor {\n         // simply skip a line if it doesn't parse, which just ignores any\n         // erroneous output.\n \n-        let mut error = String::new();\n-        let mut read_at_least_one_message = false;\n+        let mut stdout_errors = String::new();\n+        let mut stderr_errors = String::new();\n+        let mut read_at_least_one_stdout_message = false;\n+        let mut read_at_least_one_stderr_message = false;\n+        let process_line = |line: &str, error: &mut String| {\n+            // Try to deserialize a message from Cargo or Rustc.\n+            let mut deserializer = serde_json::Deserializer::from_str(line);\n+            deserializer.disable_recursion_limit();\n+            if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n+                match message {\n+                    // Skip certain kinds of messages to only spend time on what's useful\n+                    JsonMessage::Cargo(message) => match message {\n+                        cargo_metadata::Message::CompilerArtifact(artifact) if !artifact.fresh => {\n+                            self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                        }\n+                        cargo_metadata::Message::CompilerMessage(msg) => {\n+                            self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n+                        }\n+                        _ => (),\n+                    },\n+                    JsonMessage::Rustc(message) => {\n+                        self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            error.push_str(line);\n+            error.push('\\n');\n+            return false;\n+        };\n         let output = streaming_output(\n             self.stdout,\n             self.stderr,\n             &mut |line| {\n-                read_at_least_one_message = true;\n-\n-                // Try to deserialize a message from Cargo or Rustc.\n-                let mut deserializer = serde_json::Deserializer::from_str(line);\n-                deserializer.disable_recursion_limit();\n-                if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n-                    match message {\n-                        // Skip certain kinds of messages to only spend time on what's useful\n-                        JsonMessage::Cargo(message) => match message {\n-                            cargo_metadata::Message::CompilerArtifact(artifact)\n-                                if !artifact.fresh =>\n-                            {\n-                                self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n-                            }\n-                            cargo_metadata::Message::CompilerMessage(msg) => {\n-                                self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n-                            }\n-                            _ => (),\n-                        },\n-                        JsonMessage::Rustc(message) => {\n-                            self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n-                        }\n-                    }\n+                if process_line(line, &mut stdout_errors) {\n+                    read_at_least_one_stdout_message = true;\n                 }\n             },\n             &mut |line| {\n-                error.push_str(line);\n-                error.push('\\n');\n+                if process_line(line, &mut stderr_errors) {\n+                    read_at_least_one_stderr_message = true;\n+                }\n             },\n         );\n+\n+        let read_at_least_one_message =\n+            read_at_least_one_stdout_message || read_at_least_one_stderr_message;\n+        let mut error = stdout_errors;\n+        error.push_str(&stderr_errors);\n         match output {\n             Ok(_) => Ok((read_at_least_one_message, error)),\n             Err(e) => Err(io::Error::new(e.kind(), format!(\"{e:?}: {error}\"))),"}, {"sha": "200072c172ebe74fb6e70da1aef9b3dfaaea2882", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -300,6 +300,7 @@ impl AttrsWithOwner {\n                 AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             },\n             AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TraitAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::MacroId(it) => match it {\n                 MacroId::Macro2Id(it) => attrs_from_item_tree(it.lookup(db).id, db),\n                 MacroId::MacroRulesId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n@@ -315,26 +316,14 @@ impl AttrsWithOwner {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n                         db.upcast(),\n-                        src.with_value(src.value[it.local_id()].as_ref().either(\n-                            |it| match it {\n-                                ast::TypeOrConstParam::Type(it) => it as _,\n-                                ast::TypeOrConstParam::Const(it) => it as _,\n-                            },\n-                            |it| it as _,\n-                        )),\n+                        src.with_value(&src.value[it.local_id()]),\n                     )\n                 }\n                 GenericParamId::TypeParamId(it) => {\n                     let src = it.parent().child_source(db);\n                     RawAttrs::from_attrs_owner(\n                         db.upcast(),\n-                        src.with_value(src.value[it.local_id()].as_ref().either(\n-                            |it| match it {\n-                                ast::TypeOrConstParam::Type(it) => it as _,\n-                                ast::TypeOrConstParam::Const(it) => it as _,\n-                            },\n-                            |it| it as _,\n-                        )),\n+                        src.with_value(&src.value[it.local_id()]),\n                     )\n                 }\n                 GenericParamId::LifetimeParamId(it) => {\n@@ -404,6 +393,7 @@ impl AttrsWithOwner {\n             AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::TraitAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::MacroId(id) => match id {\n                 MacroId::Macro2Id(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n@@ -412,28 +402,14 @@ impl AttrsWithOwner {\n             },\n             AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n             AttrDefId::GenericParamId(id) => match id {\n-                GenericParamId::ConstParamId(id) => {\n-                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n-                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n-                            ast::AnyHasAttrs::new(id.clone())\n-                        }\n-                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n-                            ast::AnyHasAttrs::new(id.clone())\n-                        }\n-                        Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n-                    })\n-                }\n-                GenericParamId::TypeParamId(id) => {\n-                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n-                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n-                            ast::AnyHasAttrs::new(id.clone())\n-                        }\n-                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n-                            ast::AnyHasAttrs::new(id.clone())\n-                        }\n-                        Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n-                    })\n-                }\n+                GenericParamId::ConstParamId(id) => id\n+                    .parent()\n+                    .child_source(db)\n+                    .map(|source| ast::AnyHasAttrs::new(source[id.local_id()].clone())),\n+                GenericParamId::TypeParamId(id) => id\n+                    .parent()\n+                    .child_source(db)\n+                    .map(|source| ast::AnyHasAttrs::new(source[id.local_id()].clone())),\n                 GenericParamId::LifetimeParamId(id) => id\n                     .parent\n                     .child_source(db)"}, {"sha": "3be477d48774adb80d5c4cf4ae74510b4a38693e", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -24,7 +24,7 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -270,7 +270,7 @@ pub struct Mark {\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n-    pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n+    pub bindings: Arena<Binding>,\n     pub labels: Arena<Label>,\n     /// The patterns for the function's parameters. While the parameter types are\n     /// part of the function signature, the patterns are not (they don't change\n@@ -409,18 +409,6 @@ impl Body {\n             .map(move |&block| (block, db.block_def_map(block).expect(\"block ID without DefMap\")))\n     }\n \n-    pub fn pattern_representative(&self, pat: PatId) -> PatId {\n-        self.or_pats.get(&pat).and_then(|pats| pats.first().copied()).unwrap_or(pat)\n-    }\n-\n-    /// Retrieves all ident patterns this pattern shares the ident with.\n-    pub fn ident_patterns_for<'slf>(&'slf self, pat: &'slf PatId) -> &'slf [PatId] {\n-        match self.or_pats.get(pat) {\n-            Some(pats) => pats,\n-            None => std::slice::from_ref(pat),\n-        }\n-    }\n-\n     pub fn pretty_print(&self, db: &dyn DefDatabase, owner: DefWithBodyId) -> String {\n         pretty::print_body_hir(db, self, owner)\n     }\n@@ -435,13 +423,14 @@ impl Body {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n+        let Self { _c: _, body_expr: _, block_scopes, exprs, labels, params, pats, bindings } =\n+            self;\n         block_scopes.shrink_to_fit();\n-        or_pats.shrink_to_fit();\n         exprs.shrink_to_fit();\n         labels.shrink_to_fit();\n         params.shrink_to_fit();\n         pats.shrink_to_fit();\n+        bindings.shrink_to_fit();\n     }\n }\n \n@@ -451,7 +440,7 @@ impl Default for Body {\n             body_expr: dummy_expr_id(),\n             exprs: Default::default(),\n             pats: Default::default(),\n-            or_pats: Default::default(),\n+            bindings: Default::default(),\n             labels: Default::default(),\n             params: Default::default(),\n             block_scopes: Default::default(),\n@@ -484,6 +473,14 @@ impl Index<LabelId> for Body {\n     }\n }\n \n+impl Index<BindingId> for Body {\n+    type Output = Binding;\n+\n+    fn index(&self, b: BindingId) -> &Binding {\n+        &self.bindings[b]\n+    }\n+}\n+\n // FIXME: Change `node_` prefix to something more reasonable.\n // Perhaps `expr_syntax` and `expr_id`?\n impl BodySourceMap {"}, {"sha": "83ce9b6acbba88643829ee3b9870235ab9b06fbb", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 116, "deletions": 84, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -15,6 +15,7 @@ use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -30,14 +31,14 @@ use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n     expr::{\n-        dummy_expr_id, Array, BindingAnnotation, ClosureKind, Expr, ExprId, FloatTypeWrapper,\n-        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n-        Statement,\n+        dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n+        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n+        RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n-    AdtId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+    AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n pub struct LowerCtx<'a> {\n@@ -87,16 +88,14 @@ pub(super) fn lower(\n         body: Body {\n             exprs: Arena::default(),\n             pats: Arena::default(),\n+            bindings: Arena::default(),\n             labels: Arena::default(),\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n             block_scopes: Vec::new(),\n             _c: Count::new(),\n-            or_pats: Default::default(),\n         },\n         expander,\n-        name_to_pat_grouping: Default::default(),\n-        is_lowering_inside_or_pat: false,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n     }\n@@ -109,13 +108,26 @@ struct ExprCollector<'a> {\n     ast_id_map: Arc<AstIdMap>,\n     body: Body,\n     source_map: BodySourceMap,\n-    // a poor-mans union-find?\n-    name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n-    is_lowering_inside_or_pat: bool,\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n }\n \n+#[derive(Debug, Default)]\n+struct BindingList {\n+    map: FxHashMap<Name, BindingId>,\n+}\n+\n+impl BindingList {\n+    fn find(\n+        &mut self,\n+        ec: &mut ExprCollector<'_>,\n+        name: Name,\n+        mode: BindingAnnotation,\n+    ) -> BindingId {\n+        *self.map.entry(name).or_insert_with_key(|n| ec.alloc_binding(n.clone(), mode))\n+    }\n+}\n+\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n@@ -127,17 +139,16 @@ impl ExprCollector<'_> {\n                 param_list.self_param().filter(|_| attr_enabled.next().unwrap_or(false))\n             {\n                 let ptr = AstPtr::new(&self_param);\n-                let param_pat = self.alloc_pat(\n-                    Pat::Bind {\n-                        name: name![self],\n-                        mode: BindingAnnotation::new(\n-                            self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n-                            false,\n-                        ),\n-                        subpat: None,\n-                    },\n-                    Either::Right(ptr),\n+                let binding_id = self.alloc_binding(\n+                    name![self],\n+                    BindingAnnotation::new(\n+                        self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n+                        false,\n+                    ),\n                 );\n+                let param_pat =\n+                    self.alloc_pat(Pat::Bind { id: binding_id, subpat: None }, Either::Right(ptr));\n+                self.add_definition_to_binding(binding_id, param_pat);\n                 self.body.params.push(param_pat);\n             }\n \n@@ -179,6 +190,9 @@ impl ExprCollector<'_> {\n         id\n     }\n \n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n+    }\n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_pat(pat, src.clone());\n@@ -238,33 +252,32 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n                 Some(ast::BlockModifier::Try(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::TryBlock {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n+                        id,\n+                        statements,\n+                        tail,\n+                    })\n                 }\n-                // FIXME: we need to record these effects somewhere...\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    let res = self.collect_block(e);\n-                    match &mut self.body.exprs[res] {\n-                        Expr::Block { label: block_label, .. } => {\n-                            *block_label = Some(label);\n-                        }\n-                        _ => unreachable!(),\n-                    }\n-                    res\n-                }\n-                Some(ast::BlockModifier::Async(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n-                }\n-                Some(ast::BlockModifier::Const(_)) => {\n-                    let body = self.collect_block(e);\n-                    self.alloc_expr(Expr::Const { body }, syntax_ptr)\n+                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n+                        id,\n+                        statements,\n+                        tail,\n+                        label: Some(label),\n+                    })\n                 }\n+                Some(ast::BlockModifier::Async(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n+                Some(ast::BlockModifier::Const(_)) => self\n+                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n@@ -737,6 +750,19 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        self.collect_block_(block, |id, statements, tail| Expr::Block {\n+            id,\n+            statements,\n+            tail,\n+            label: None,\n+        })\n+    }\n+\n+    fn collect_block_(\n+        &mut self,\n+        block: ast::BlockExpr,\n+        mk_block: impl FnOnce(BlockId, Box<[Statement]>, Option<ExprId>) -> Expr,\n+    ) -> ExprId {\n         let file_local_id = self.ast_id_map.ast_id(&block);\n         let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n         let block_loc =\n@@ -769,15 +795,8 @@ impl ExprCollector<'_> {\n         });\n \n         let syntax_node_ptr = AstPtr::new(&block.into());\n-        let expr_id = self.alloc_expr(\n-            Expr::Block {\n-                id: block_id,\n-                statements: statements.into_boxed_slice(),\n-                tail,\n-                label: None,\n-            },\n-            syntax_node_ptr,\n-        );\n+        let expr_id = self\n+            .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);\n \n         self.expander.def_map = prev_def_map;\n         self.expander.module = prev_local_module;\n@@ -799,13 +818,7 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        let pat_id = self.collect_pat_(pat);\n-        for (_, pats) in self.name_to_pat_grouping.drain() {\n-            let pats = Arc::<[_]>::from(pats);\n-            self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n-        }\n-        self.is_lowering_inside_or_pat = false;\n-        pat_id\n+        self.collect_pat_(pat, &mut BindingList::default())\n     }\n \n     fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n@@ -815,16 +828,18 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n+    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n-                let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n-                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+\n+                let is_simple_ident_pat =\n+                    annotation == BindingAnnotation::Unannotated && subpat.is_none();\n+                let (binding, pattern) = if is_simple_ident_pat {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n                     let (resolved, _) = self.expander.def_map.resolve_path(\n@@ -834,43 +849,47 @@ impl ExprCollector<'_> {\n                         BuiltinShadowMode::Other,\n                     );\n                     match resolved.take_values() {\n-                        Some(ModuleDefId::ConstId(_)) => Pat::Path(name.into()),\n+                        Some(ModuleDefId::ConstId(_)) => (None, Pat::Path(name.into())),\n                         Some(ModuleDefId::EnumVariantId(_)) => {\n                             // this is only really valid for unit variants, but\n                             // shadowing other enum variants with a pattern is\n                             // an error anyway\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         Some(ModuleDefId::AdtId(AdtId::StructId(s)))\n                             if self.db.struct_data(s).variant_data.kind() != StructKind::Record =>\n                         {\n                             // Funnily enough, record structs *can* be shadowed\n                             // by pattern bindings (but unit or tuple structs\n                             // can't).\n-                            Pat::Path(name.into())\n+                            (None, Pat::Path(name.into()))\n                         }\n                         // shadowing statics is an error as well, so we just ignore that case here\n-                        _ => Pat::Bind { name, mode: annotation, subpat },\n+                        _ => {\n+                            let id = binding_list.find(self, name, annotation);\n+                            (Some(id), Pat::Bind { id, subpat })\n+                        }\n                     }\n                 } else {\n-                    Pat::Bind { name, mode: annotation, subpat }\n+                    let id = binding_list.find(self, name, annotation);\n+                    (Some(id), Pat::Bind { id, subpat })\n                 };\n \n                 let ptr = AstPtr::new(&pat);\n                 let pat = self.alloc_pat(pattern, Either::Left(ptr));\n-                if let Some(key) = key {\n-                    self.name_to_pat_grouping.entry(key).or_default().push(pat);\n+                if let Some(binding_id) = binding {\n+                    self.add_definition_to_binding(binding_id, pat);\n                 }\n                 return pat;\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt(p.pat());\n+                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -880,13 +899,12 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                self.is_lowering_inside_or_pat = true;\n-                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -899,7 +917,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat);\n+                        let pat = self.collect_pat_(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -918,9 +936,15 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p)),\n-                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    prefix: prefix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n+                    suffix: suffix\n+                        .into_iter()\n+                        .map(|p| self.collect_pat_(p, binding_list))\n+                        .collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -943,7 +967,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat());\n+                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -960,7 +984,7 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat)\n+                            this.collect_pat_opt_(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n@@ -974,21 +998,25 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat),\n+            Some(pat) => self.collect_pat_(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n+    fn collect_tuple_pat(\n+        &mut self,\n+        args: AstChildren<ast::Pat>,\n+        binding_list: &mut BindingList,\n+    ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p))\n+            .map(|p| self.collect_pat_(p, binding_list))\n             .collect();\n \n         (args, ellipsis)\n@@ -1017,6 +1045,10 @@ impl ExprCollector<'_> {\n             None => Some(()),\n         }\n     }\n+\n+    fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n+        self.body.bindings[binding_id].definitions.push(pat_id);\n+    }\n }\n \n impl From<ast::LiteralKind> for Literal {"}, {"sha": "f8b159797e44afef0110905b6205bc88962c050a", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,7 +5,7 @@ use std::fmt::{self, Write};\n use syntax::ast::HasName;\n \n use crate::{\n-    expr::{Array, BindingAnnotation, ClosureKind, Literal, Movability, Statement},\n+    expr::{Array, BindingAnnotation, BindingId, ClosureKind, Literal, Movability, Statement},\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n };\n@@ -292,18 +292,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*expr);\n                 w!(self, \"?\");\n             }\n-            Expr::TryBlock { body } => {\n-                w!(self, \"try \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Async { body } => {\n-                w!(self, \"async \");\n-                self.print_expr(*body);\n-            }\n-            Expr::Const { body } => {\n-                w!(self, \"const \");\n-                self.print_expr(*body);\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");\n@@ -402,10 +390,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \")\");\n             }\n-            Expr::Unsafe { body } => {\n-                w!(self, \"unsafe \");\n-                self.print_expr(*body);\n-            }\n             Expr::Array(arr) => {\n                 w!(self, \"[\");\n                 if !matches!(arr, Array::ElementList { elements, .. } if elements.is_empty()) {\n@@ -428,25 +412,47 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Literal(lit) => self.print_literal(lit),\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.whitespace();\n-                if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name));\n+                self.print_block(label.as_deref(), statements, tail);\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.print_block(Some(\"unsafe \"), statements, tail);\n+            }\n+            Expr::TryBlock { id: _, statements, tail } => {\n+                self.print_block(Some(\"try \"), statements, tail);\n+            }\n+            Expr::Async { id: _, statements, tail } => {\n+                self.print_block(Some(\"async \"), statements, tail);\n+            }\n+            Expr::Const { id: _, statements, tail } => {\n+                self.print_block(Some(\"const \"), statements, tail);\n+            }\n+        }\n+    }\n+\n+    fn print_block(\n+        &mut self,\n+        label: Option<&str>,\n+        statements: &Box<[Statement]>,\n+        tail: &Option<la_arena::Idx<Expr>>,\n+    ) {\n+        self.whitespace();\n+        if let Some(lbl) = label {\n+            w!(self, \"{}\", lbl);\n+        }\n+        w!(self, \"{{\");\n+        if !statements.is_empty() || tail.is_some() {\n+            self.indented(|p| {\n+                for stmt in &**statements {\n+                    p.print_stmt(stmt);\n                 }\n-                w!(self, \"{{\");\n-                if !statements.is_empty() || tail.is_some() {\n-                    self.indented(|p| {\n-                        for stmt in &**statements {\n-                            p.print_stmt(stmt);\n-                        }\n-                        if let Some(tail) = tail {\n-                            p.print_expr(*tail);\n-                        }\n-                        p.newline();\n-                    });\n+                if let Some(tail) = tail {\n+                    p.print_expr(*tail);\n                 }\n-                w!(self, \"}}\");\n-            }\n+                p.newline();\n+            });\n         }\n+        w!(self, \"}}\");\n     }\n \n     fn print_pat(&mut self, pat: PatId) {\n@@ -518,14 +524,8 @@ impl<'a> Printer<'a> {\n             }\n             Pat::Path(path) => self.print_path(path),\n             Pat::Lit(expr) => self.print_expr(*expr),\n-            Pat::Bind { mode, name, subpat } => {\n-                let mode = match mode {\n-                    BindingAnnotation::Unannotated => \"\",\n-                    BindingAnnotation::Mutable => \"mut \",\n-                    BindingAnnotation::Ref => \"ref \",\n-                    BindingAnnotation::RefMut => \"ref mut \",\n-                };\n-                w!(self, \"{}{}\", mode, name);\n+            Pat::Bind { id, subpat } => {\n+                self.print_binding(*id);\n                 if let Some(pat) = subpat {\n                     self.whitespace();\n                     self.print_pat(*pat);\n@@ -629,4 +629,15 @@ impl<'a> Printer<'a> {\n     fn print_path(&mut self, path: &Path) {\n         print_path(path, self).unwrap();\n     }\n+\n+    fn print_binding(&mut self, id: BindingId) {\n+        let Binding { name, mode, .. } = &self.body.bindings[id];\n+        let mode = match mode {\n+            BindingAnnotation::Unannotated => \"\",\n+            BindingAnnotation::Mutable => \"mut \",\n+            BindingAnnotation::Ref => \"ref \",\n+            BindingAnnotation::RefMut => \"ref mut \",\n+        };\n+        w!(self, \"{}{}\", mode, name);\n+    }\n }"}, {"sha": "12fc1f116d7dac0cbfe98fcaa94d4c63b03ab7ed", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    expr::{Binding, BindingId, Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n \n@@ -23,16 +23,16 @@ pub struct ExprScopes {\n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n     name: Name,\n-    pat: PatId,\n+    binding: BindingId,\n }\n \n impl ScopeEntry {\n     pub fn name(&self) -> &Name {\n         &self.name\n     }\n \n-    pub fn pat(&self) -> PatId {\n-        self.pat\n+    pub fn binding(&self) -> BindingId {\n+        self.binding\n     }\n }\n \n@@ -66,6 +66,7 @@ impl ExprScopes {\n         self.scopes[scope].label.clone()\n     }\n \n+    /// Returns the scopes in ascending order.\n     pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }\n@@ -125,18 +126,23 @@ impl ExprScopes {\n         })\n     }\n \n-    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, binding: BindingId) {\n+        let Binding { name, .. } = &body.bindings[binding];\n+        let entry = ScopeEntry { name: name.clone(), binding };\n+        self.scopes[scope].entries.push(entry);\n+    }\n+\n+    fn add_pat_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n         let pattern = &body[pat];\n-        if let Pat::Bind { name, .. } = pattern {\n-            let entry = ScopeEntry { name: name.clone(), pat };\n-            self.scopes[scope].entries.push(entry);\n+        if let Pat::Bind { id, .. } = pattern {\n+            self.add_bindings(body, scope, *id);\n         }\n \n-        pattern.walk_child_pats(|pat| self.add_bindings(body, scope, pat));\n+        pattern.walk_child_pats(|pat| self.add_pat_bindings(body, scope, pat));\n     }\n \n     fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n-        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+        params.iter().for_each(|pat| self.add_pat_bindings(body, scope, *pat));\n     }\n \n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n@@ -169,7 +175,7 @@ fn compute_block_scopes(\n                 }\n \n                 *scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, *scope, *pat);\n+                scopes.add_pat_bindings(body, *scope, *pat);\n             }\n             Statement::Expr { expr, .. } => {\n                 compute_expr_scopes(*expr, body, scopes, scope);\n@@ -194,10 +200,20 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n+        Expr::Unsafe { id, statements, tail }\n+        | Expr::Async { id, statements, tail }\n+        | Expr::Const { id, statements, tail }\n+        | Expr::TryBlock { id, statements, tail } => {\n+            let mut scope = scopes.new_block_scope(*scope, *id, None);\n+            // Overwrite the old scope for the block expr, so that every block scope can be found\n+            // via the block itself (important for blocks that only contain items, no expressions).\n+            scopes.set_scope(expr, scope);\n+            compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n+        }\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n-            scopes.add_bindings(body, scope, *pat);\n+            scopes.add_pat_bindings(body, scope, *pat);\n             compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::While { condition, body: body_expr, label } => {\n@@ -218,7 +234,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             compute_expr_scopes(*expr, body, scopes, scope);\n             for arm in arms.iter() {\n                 let mut scope = scopes.new_scope(*scope);\n-                scopes.add_bindings(body, scope, arm.pat);\n+                scopes.add_pat_bindings(body, scope, arm.pat);\n                 if let Some(guard) = arm.guard {\n                     scope = scopes.new_scope(scope);\n                     compute_expr_scopes(guard, body, scopes, &mut scope);\n@@ -237,7 +253,7 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n         &Expr::Let { pat, expr } => {\n             compute_expr_scopes(expr, body, scopes, scope);\n             *scope = scopes.new_scope(*scope);\n-            scopes.add_bindings(body, *scope, pat);\n+            scopes.add_pat_bindings(body, *scope, pat);\n         }\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n@@ -439,7 +455,7 @@ fn foo() {\n         let function = find_function(&db, file_id);\n \n         let scopes = db.expr_scopes(function.into());\n-        let (_body, source_map) = db.body_with_source_map(function.into());\n+        let (body, source_map) = db.body_with_source_map(function.into());\n \n         let expr_scope = {\n             let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n@@ -449,7 +465,9 @@ fn foo() {\n         };\n \n         let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n-        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+        let pat_src = source_map\n+            .pat_syntax(*body.bindings[resolved.binding()].definitions.first().unwrap())\n+            .unwrap();\n \n         let local_name = pat_src.value.either(\n             |it| it.syntax_node_ptr().to_node(file.syntax()),"}, {"sha": "77ac221e590c5a88001f7c1637befc39a0d9fbb2", "filename": "crates/hir-def/src/body/tests/block.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -395,3 +395,25 @@ fn foo() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn trailing_expr_macro_expands_stmts() {\n+    check_at(\n+        r#\"\n+macro_rules! foo {\n+    () => { const FOO: u32 = 0;const BAR: u32 = 0; };\n+}\n+fn f() {$0\n+    foo!{}\n+};\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            BAR: v\n+            FOO: v\n+\n+            crate\n+            f: v\n+        \"#]],\n+    )\n+}"}, {"sha": "68b57acca2adca3950a4dfc1ede53fd0ca8cd437", "filename": "crates/hir-def/src/child_by_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,7 +1,7 @@\n //! When *constructing* `hir`, we start at some parent syntax node and recursively\n //! lower the children.\n //!\n-//! This modules allows one to go in the opposite direction: start with a syntax\n+//! This module allows one to go in the opposite direction: start with a syntax\n //! node for a *child*, and get its hir.\n \n use either::Either;\n@@ -145,6 +145,7 @@ impl ChildBySource for ItemScope {\n                 ModuleDefId::StaticId(id) => insert!(map[keys::STATIC].insert(id)),\n                 ModuleDefId::TypeAliasId(id) => insert!(map[keys::TYPE_ALIAS].insert(id)),\n                 ModuleDefId::TraitId(id) => insert!(map[keys::TRAIT].insert(id)),\n+                ModuleDefId::TraitAliasId(id) => insert!(map[keys::TRAIT_ALIAS].insert(id)),\n                 ModuleDefId::AdtId(adt) => match adt {\n                     AdtId::StructId(id) => insert!(map[keys::STRUCT].insert(id)),\n                     AdtId::UnionId(id) => insert!(map[keys::UNION].insert(id)),"}, {"sha": "ee6e269fe558698e5096c81351d303705e3d45e8", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -22,7 +22,7 @@ use crate::{\n     visibility::RawVisibility,\n     AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n     Intern, ItemContainerId, ItemLoc, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId,\n-    StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    StaticId, TraitAliasId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -245,19 +245,11 @@ impl TraitData {\n             attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n         let rustc_has_incoherent_inherent_impls =\n             attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n-        let (items, attribute_calls, diagnostics) = match &tr_def.items {\n-            Some(items) => {\n-                let mut collector = AssocItemCollector::new(\n-                    db,\n-                    module_id,\n-                    tree_id.file_id(),\n-                    ItemContainerId::TraitId(tr),\n-                );\n-                collector.collect(&item_tree, tree_id.tree_id(), items);\n-                collector.finish()\n-            }\n-            None => Default::default(),\n-        };\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n+        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n+        let (items, attribute_calls, diagnostics) = collector.finish();\n+\n         (\n             Arc::new(TraitData {\n                 name,\n@@ -299,6 +291,23 @@ impl TraitData {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitAliasData {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+}\n+\n+impl TraitAliasData {\n+    pub(crate) fn trait_alias_query(db: &dyn DefDatabase, id: TraitAliasId) -> Arc<TraitAliasData> {\n+        let loc = id.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let alias = &item_tree[loc.id.value];\n+        let visibility = item_tree[alias.visibility].clone();\n+\n+        Arc::new(TraitAliasData { name: alias.name.clone(), visibility })\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImplData {\n     pub target_trait: Option<Interned<TraitRef>>,"}, {"sha": "270cfa06e58156eab6397cde8d01706ed1118d61", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{\n         ConstData, FunctionData, ImplData, Macro2Data, MacroRulesData, ProcMacroData, StaticData,\n-        TraitData, TypeAliasData,\n+        TraitAliasData, TraitData, TypeAliasData,\n     },\n     generics::GenericParams,\n     import_map::ImportMap,\n@@ -25,8 +25,8 @@ use crate::{\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n     ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n     LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc, ProcMacroId, ProcMacroLoc,\n-    StaticId, StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc,\n-    UnionId, UnionLoc, VariantId,\n+    StaticId, StaticLoc, StructId, StructLoc, TraitAliasId, TraitAliasLoc, TraitId, TraitLoc,\n+    TypeAliasId, TypeAliasLoc, UnionId, UnionLoc, VariantId,\n };\n \n #[salsa::query_group(InternDatabaseStorage)]\n@@ -46,6 +46,8 @@ pub trait InternDatabase: SourceDatabase {\n     #[salsa::interned]\n     fn intern_trait(&self, loc: TraitLoc) -> TraitId;\n     #[salsa::interned]\n+    fn intern_trait_alias(&self, loc: TraitAliasLoc) -> TraitAliasId;\n+    #[salsa::interned]\n     fn intern_type_alias(&self, loc: TypeAliasLoc) -> TypeAliasId;\n     #[salsa::interned]\n     fn intern_impl(&self, loc: ImplLoc) -> ImplId;\n@@ -125,6 +127,9 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(TraitData::trait_data_with_diagnostics_query)]\n     fn trait_data_with_diagnostics(&self, tr: TraitId) -> (Arc<TraitData>, Arc<[DefDiagnostic]>);\n \n+    #[salsa::invoke(TraitAliasData::trait_alias_query)]\n+    fn trait_alias_data(&self, e: TraitAliasId) -> Arc<TraitAliasData>;\n+\n     #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n     fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n "}, {"sha": "bbea608c55eb5b40894f88ed1b7379b755133835", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -17,6 +17,7 @@ use std::fmt;\n use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n+use smallvec::SmallVec;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -29,6 +30,8 @@ pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, Unar\n \n pub type ExprId = Idx<Expr>;\n \n+pub type BindingId = Idx<Binding>;\n+\n /// FIXME: this is a hacky function which should be removed\n pub(crate) fn dummy_expr_id() -> ExprId {\n     ExprId::from_raw(RawIdx::from(u32::MAX))\n@@ -52,13 +55,21 @@ pub type LabelId = Idx<Label>;\n // We convert float values into bits and that's how we don't need to deal with f32 and f64.\n // For PartialEq, bits comparison should work, as ordering is not important\n // https://github.com/rust-lang/rust-analyzer/issues/12380#issuecomment-1137284360\n-#[derive(Default, Debug, Clone, Eq, PartialEq)]\n+#[derive(Default, Debug, Clone, Copy, Eq, PartialEq)]\n pub struct FloatTypeWrapper(u64);\n \n impl FloatTypeWrapper {\n     pub fn new(value: f64) -> Self {\n         Self(value.to_bits())\n     }\n+\n+    pub fn into_f64(self) -> f64 {\n+        f64::from_bits(self.0)\n+    }\n+\n+    pub fn into_f32(self) -> f32 {\n+        f64::from_bits(self.0) as f32\n+    }\n }\n \n impl fmt::Display for FloatTypeWrapper {\n@@ -101,6 +112,26 @@ pub enum Expr {\n         tail: Option<ExprId>,\n         label: Option<LabelId>,\n     },\n+    TryBlock {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Async {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Const {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Unsafe {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n     Loop {\n         body: ExprId,\n         label: Option<LabelId>,\n@@ -164,15 +195,6 @@ pub enum Expr {\n     Try {\n         expr: ExprId,\n     },\n-    TryBlock {\n-        body: ExprId,\n-    },\n-    Async {\n-        body: ExprId,\n-    },\n-    Const {\n-        body: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -214,9 +236,6 @@ pub enum Expr {\n         exprs: Box<[ExprId]>,\n         is_assignee_expr: bool,\n     },\n-    Unsafe {\n-        body: ExprId,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -282,13 +301,20 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. }\n+            | Expr::TryBlock { statements, tail, .. }\n+            | Expr::Unsafe { statements, tail, .. }\n+            | Expr::Async { statements, tail, .. }\n+            | Expr::Const { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n-                        Statement::Let { initializer, .. } => {\n+                        Statement::Let { initializer, else_branch, .. } => {\n                             if let &Some(expr) = initializer {\n                                 f(expr);\n                             }\n+                            if let &Some(expr) = else_branch {\n+                                f(expr);\n+                            }\n                         }\n                         Statement::Expr { expr: expression, .. } => f(*expression),\n                     }\n@@ -297,10 +323,6 @@ impl Expr {\n                     f(expr);\n                 }\n             }\n-            Expr::TryBlock { body }\n-            | Expr::Unsafe { body }\n-            | Expr::Async { body }\n-            | Expr::Const { body } => f(*body),\n             Expr::Loop { body, .. } => f(*body),\n             Expr::While { condition, body, .. } => {\n                 f(*condition);\n@@ -414,6 +436,13 @@ impl BindingAnnotation {\n     }\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Binding {\n+    pub name: Name,\n+    pub mode: BindingAnnotation,\n+    pub definitions: SmallVec<[PatId; 1]>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct RecordFieldPat {\n     pub name: Name,\n@@ -432,7 +461,7 @@ pub enum Pat {\n     Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),\n-    Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n+    Bind { id: BindingId, subpat: Option<PatId> },\n     TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n     Ref { pat: PatId, mutability: Mutability },\n     Box { inner: PatId },"}, {"sha": "e4912fa8a64a44df362d580b7fe2a0077ceb984c", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -187,6 +187,7 @@ impl GenericParams {\n             GenericDefId::AdtId(AdtId::EnumId(id)) => id_to_generics!(id),\n             GenericDefId::AdtId(AdtId::UnionId(id)) => id_to_generics!(id),\n             GenericDefId::TraitId(id) => id_to_generics!(id),\n+            GenericDefId::TraitAliasId(id) => id_to_generics!(id),\n             GenericDefId::TypeAliasId(id) => id_to_generics!(id),\n             GenericDefId::ImplId(id) => id_to_generics!(id),\n             GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {\n@@ -207,12 +208,10 @@ impl GenericParams {\n     pub(crate) fn fill_bounds(\n         &mut self,\n         lower_ctx: &LowerCtx<'_>,\n-        node: &dyn ast::HasTypeBounds,\n+        type_bounds: Option<ast::TypeBoundList>,\n         target: Either<TypeRef, LifetimeRef>,\n     ) {\n-        for bound in\n-            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n-        {\n+        for bound in type_bounds.iter().flat_map(|type_bound_list| type_bound_list.bounds()) {\n             self.add_where_predicate_from_bound(lower_ctx, bound, None, target.clone());\n         }\n     }\n@@ -233,7 +232,11 @@ impl GenericParams {\n                     };\n                     self.type_or_consts.alloc(param.into());\n                     let type_ref = TypeRef::Path(name.into());\n-                    self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n+                    self.fill_bounds(\n+                        lower_ctx,\n+                        type_param.type_bound_list(),\n+                        Either::Left(type_ref),\n+                    );\n                 }\n                 ast::TypeOrConstParam::Const(const_param) => {\n                     let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n@@ -255,7 +258,11 @@ impl GenericParams {\n             let param = LifetimeParamData { name: name.clone() };\n             self.lifetimes.alloc(param);\n             let lifetime_ref = LifetimeRef::new_name(name);\n-            self.fill_bounds(lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n+            self.fill_bounds(\n+                lower_ctx,\n+                lifetime_param.type_bound_list(),\n+                Either::Right(lifetime_ref),\n+            );\n         }\n     }\n \n@@ -421,6 +428,10 @@ fn file_id_and_params_of(\n             let src = it.lookup(db).source(db);\n             (src.file_id, src.value.generic_param_list())\n         }\n+        GenericDefId::TraitAliasId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n         GenericDefId::TypeAliasId(it) => {\n             let src = it.lookup(db).source(db);\n             (src.file_id, src.value.generic_param_list())\n@@ -435,7 +446,7 @@ fn file_id_and_params_of(\n }\n \n impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n-    type Value = Either<ast::TypeOrConstParam, ast::Trait>;\n+    type Value = Either<ast::TypeOrConstParam, ast::TraitOrAlias>;\n     fn child_source(\n         &self,\n         db: &dyn DefDatabase,\n@@ -447,11 +458,20 @@ impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n \n         let mut params = ArenaMap::default();\n \n-        // For traits the first type index is `Self`, we need to add it before the other params.\n-        if let GenericDefId::TraitId(id) = *self {\n-            let trait_ref = id.lookup(db).source(db).value;\n-            let idx = idx_iter.next().unwrap();\n-            params.insert(idx, Either::Right(trait_ref));\n+        // For traits and trait aliases the first type index is `Self`, we need to add it before\n+        // the other params.\n+        match *self {\n+            GenericDefId::TraitId(id) => {\n+                let trait_ref = id.lookup(db).source(db).value;\n+                let idx = idx_iter.next().unwrap();\n+                params.insert(idx, Either::Right(ast::TraitOrAlias::Trait(trait_ref)));\n+            }\n+            GenericDefId::TraitAliasId(id) => {\n+                let alias = id.lookup(db).source(db).value;\n+                let idx = idx_iter.next().unwrap();\n+                params.insert(idx, Either::Right(ast::TraitOrAlias::TraitAlias(alias)));\n+            }\n+            _ => {}\n         }\n \n         if let Some(generic_params_list) = generic_params_list {"}, {"sha": "4f1f6000db0e353d05341a308a9710a5d16efb69", "filename": "crates/hir-def/src/import_map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -264,6 +264,7 @@ pub enum ImportKind {\n     Const,\n     Static,\n     Trait,\n+    TraitAlias,\n     TypeAlias,\n     BuiltinType,\n     AssociatedItem,\n@@ -459,6 +460,7 @@ fn item_import_kind(item: ItemInNs) -> Option<ImportKind> {\n         ModuleDefId::ConstId(_) => ImportKind::Const,\n         ModuleDefId::StaticId(_) => ImportKind::Static,\n         ModuleDefId::TraitId(_) => ImportKind::Trait,\n+        ModuleDefId::TraitAliasId(_) => ImportKind::TraitAlias,\n         ModuleDefId::TypeAliasId(_) => ImportKind::TypeAlias,\n         ModuleDefId::BuiltinType(_) => ImportKind::BuiltinType,\n         ModuleDefId::MacroId(_) => ImportKind::Macro,"}, {"sha": "991e447033fe70738169f44a26d64fff9b08928d", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -431,6 +431,7 @@ impl PerNs {\n             ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v),\n             ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def, v),\n             ModuleDefId::TraitId(_) => PerNs::types(def, v),\n+            ModuleDefId::TraitAliasId(_) => PerNs::types(def, v),\n             ModuleDefId::TypeAliasId(_) => PerNs::types(def, v),\n             ModuleDefId::BuiltinType(_) => PerNs::types(def, v),\n             ModuleDefId::MacroId(mac) => PerNs::macros(mac, v),"}, {"sha": "9da5b2d47c8773d7d099d38d9d071c38d6341901", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -204,6 +204,7 @@ impl ItemTree {\n                 consts,\n                 statics,\n                 traits,\n+                trait_aliases,\n                 impls,\n                 type_aliases,\n                 mods,\n@@ -226,6 +227,7 @@ impl ItemTree {\n             consts.shrink_to_fit();\n             statics.shrink_to_fit();\n             traits.shrink_to_fit();\n+            trait_aliases.shrink_to_fit();\n             impls.shrink_to_fit();\n             type_aliases.shrink_to_fit();\n             mods.shrink_to_fit();\n@@ -276,6 +278,7 @@ struct ItemTreeData {\n     consts: Arena<Const>,\n     statics: Arena<Static>,\n     traits: Arena<Trait>,\n+    trait_aliases: Arena<TraitAlias>,\n     impls: Arena<Impl>,\n     type_aliases: Arena<TypeAlias>,\n     mods: Arena<Mod>,\n@@ -496,6 +499,7 @@ mod_items! {\n     Const in consts -> ast::Const,\n     Static in statics -> ast::Static,\n     Trait in traits -> ast::Trait,\n+    TraitAlias in trait_aliases -> ast::TraitAlias,\n     Impl in impls -> ast::Impl,\n     TypeAlias in type_aliases -> ast::TypeAlias,\n     Mod in mods -> ast::Module,\n@@ -672,11 +676,18 @@ pub struct Trait {\n     pub generic_params: Interned<GenericParams>,\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n-    /// This is [`None`] if this Trait is a trait alias.\n-    pub items: Option<Box<[AssocItem]>>,\n+    pub items: Box<[AssocItem]>,\n     pub ast_id: FileAstId<ast::Trait>,\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct TraitAlias {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: Interned<GenericParams>,\n+    pub ast_id: FileAstId<ast::TraitAlias>,\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Impl {\n     pub generic_params: Interned<GenericParams>,\n@@ -872,6 +883,7 @@ impl ModItem {\n             | ModItem::Enum(_)\n             | ModItem::Static(_)\n             | ModItem::Trait(_)\n+            | ModItem::TraitAlias(_)\n             | ModItem::Impl(_)\n             | ModItem::Mod(_)\n             | ModItem::MacroRules(_)\n@@ -899,6 +911,7 @@ impl ModItem {\n             ModItem::Const(it) => tree[it.index].ast_id().upcast(),\n             ModItem::Static(it) => tree[it.index].ast_id().upcast(),\n             ModItem::Trait(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::TraitAlias(it) => tree[it.index].ast_id().upcast(),\n             ModItem::Impl(it) => tree[it.index].ast_id().upcast(),\n             ModItem::TypeAlias(it) => tree[it.index].ast_id().upcast(),\n             ModItem::Mod(it) => tree[it.index].ast_id().upcast(),"}, {"sha": "77b186f8e3fe610ae804c1d1d91cf0790abd8786", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -3,7 +3,7 @@\n use std::{collections::hash_map::Entry, sync::Arc};\n \n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n-use syntax::ast::{self, HasModuleItem};\n+use syntax::ast::{self, HasModuleItem, HasTypeBounds};\n \n use crate::{\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n@@ -90,6 +90,13 @@ impl<'a> Ctx<'a> {\n                 _ => None,\n             })\n             .collect();\n+        if let Some(ast::Expr::MacroExpr(expr)) = block.tail_expr() {\n+            if let Some(call) = expr.macro_call() {\n+                if let Some(mod_item) = self.lower_mod_item(&call.into()) {\n+                    self.tree.top_level.push(mod_item);\n+                }\n+            }\n+        }\n \n         self.tree\n     }\n@@ -110,6 +117,7 @@ impl<'a> Ctx<'a> {\n             ast::Item::Const(ast) => self.lower_const(ast).into(),\n             ast::Item::Module(ast) => self.lower_module(ast)?.into(),\n             ast::Item::Trait(ast) => self.lower_trait(ast)?.into(),\n+            ast::Item::TraitAlias(ast) => self.lower_trait_alias(ast)?.into(),\n             ast::Item::Impl(ast) => self.lower_impl(ast)?.into(),\n             ast::Item::Use(ast) => self.lower_use(ast)?.into(),\n             ast::Item::ExternCrate(ast) => self.lower_extern_crate(ast)?.into(),\n@@ -147,7 +155,7 @@ impl<'a> Ctx<'a> {\n     fn lower_struct(&mut self, strukt: &ast::Struct) -> Option<FileItemTreeId<Struct>> {\n         let visibility = self.lower_visibility(strukt);\n         let name = strukt.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Struct, strukt);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, strukt);\n         let fields = self.lower_fields(&strukt.kind());\n         let ast_id = self.source_ast_id_map.ast_id(strukt);\n         let res = Struct { name, visibility, generic_params, fields, ast_id };\n@@ -211,7 +219,7 @@ impl<'a> Ctx<'a> {\n     fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n         let visibility = self.lower_visibility(union);\n         let name = union.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, union);\n         let fields = match union.record_field_list() {\n             Some(record_field_list) => self.lower_fields(&StructKind::Record(record_field_list)),\n             None => Fields::Record(IdxRange::new(self.next_field_idx()..self.next_field_idx())),\n@@ -224,7 +232,7 @@ impl<'a> Ctx<'a> {\n     fn lower_enum(&mut self, enum_: &ast::Enum) -> Option<FileItemTreeId<Enum>> {\n         let visibility = self.lower_visibility(enum_);\n         let name = enum_.name()?.as_name();\n-        let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, enum_);\n         let variants = match &enum_.variant_list() {\n             Some(variant_list) => self.lower_variants(variant_list),\n             None => IdxRange::new(self.next_variant_idx()..self.next_variant_idx()),\n@@ -372,8 +380,7 @@ impl<'a> Ctx<'a> {\n             ast_id,\n             flags,\n         };\n-        res.explicit_generic_params =\n-            self.lower_generic_params(GenericsOwner::Function(&res), func);\n+        res.explicit_generic_params = self.lower_generic_params(HasImplicitSelf::No, func);\n \n         Some(id(self.data().functions.alloc(res)))\n     }\n@@ -386,7 +393,7 @@ impl<'a> Ctx<'a> {\n         let type_ref = type_alias.ty().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n         let bounds = self.lower_type_bounds(type_alias);\n-        let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, type_alias);\n         let ast_id = self.source_ast_id_map.ast_id(type_alias);\n         let res = TypeAlias {\n             name,\n@@ -442,27 +449,49 @@ impl<'a> Ctx<'a> {\n     fn lower_trait(&mut self, trait_def: &ast::Trait) -> Option<FileItemTreeId<Trait>> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n-        let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n+        let generic_params =\n+            self.lower_generic_params(HasImplicitSelf::Yes(trait_def.type_bound_list()), trait_def);\n         let is_auto = trait_def.auto_token().is_some();\n         let is_unsafe = trait_def.unsafe_token().is_some();\n-        let items = trait_def.assoc_item_list().map(|list| {\n-            list.assoc_items()\n-                .filter_map(|item| {\n-                    let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n-                    self.lower_assoc_item(&item).map(|item| {\n-                        self.add_attrs(ModItem::from(item).into(), attrs);\n-                        item\n-                    })\n-                })\n-                .collect()\n-        });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n-        let res = Trait { name, visibility, generic_params, is_auto, is_unsafe, items, ast_id };\n-        Some(id(self.data().traits.alloc(res)))\n+\n+        let items = trait_def\n+            .assoc_item_list()\n+            .into_iter()\n+            .flat_map(|list| list.assoc_items())\n+            .filter_map(|item| {\n+                let attrs = RawAttrs::new(self.db.upcast(), &item, self.hygiene());\n+                self.lower_assoc_item(&item).map(|item| {\n+                    self.add_attrs(ModItem::from(item).into(), attrs);\n+                    item\n+                })\n+            })\n+            .collect();\n+\n+        let def = Trait { name, visibility, generic_params, is_auto, is_unsafe, items, ast_id };\n+        Some(id(self.data().traits.alloc(def)))\n+    }\n+\n+    fn lower_trait_alias(\n+        &mut self,\n+        trait_alias_def: &ast::TraitAlias,\n+    ) -> Option<FileItemTreeId<TraitAlias>> {\n+        let name = trait_alias_def.name()?.as_name();\n+        let visibility = self.lower_visibility(trait_alias_def);\n+        let generic_params = self.lower_generic_params(\n+            HasImplicitSelf::Yes(trait_alias_def.type_bound_list()),\n+            trait_alias_def,\n+        );\n+        let ast_id = self.source_ast_id_map.ast_id(trait_alias_def);\n+\n+        let alias = TraitAlias { name, visibility, generic_params, ast_id };\n+        Some(id(self.data().trait_aliases.alloc(alias)))\n     }\n \n     fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n-        let generic_params = self.lower_generic_params(GenericsOwner::Impl, impl_def);\n+        // Note that trait impls don't get implicit `Self` unlike traits, because here they are a\n+        // type alias rather than a type parameter, so this is handled by the resolver.\n+        let generic_params = self.lower_generic_params(HasImplicitSelf::No, impl_def);\n         // FIXME: If trait lowering fails, due to a non PathType for example, we treat this impl\n         // as if it was an non-trait impl. Ideally we want to create a unique missing ref that only\n         // equals itself.\n@@ -566,42 +595,29 @@ impl<'a> Ctx<'a> {\n \n     fn lower_generic_params(\n         &mut self,\n-        owner: GenericsOwner<'_>,\n+        has_implicit_self: HasImplicitSelf,\n         node: &dyn ast::HasGenericParams,\n     ) -> Interned<GenericParams> {\n         let mut generics = GenericParams::default();\n-        match owner {\n-            GenericsOwner::Function(_)\n-            | GenericsOwner::Struct\n-            | GenericsOwner::Enum\n-            | GenericsOwner::Union\n-            | GenericsOwner::TypeAlias => {\n-                generics.fill(&self.body_ctx, node);\n-            }\n-            GenericsOwner::Trait(trait_def) => {\n-                // traits get the Self type as an implicit first type parameter\n-                generics.type_or_consts.alloc(\n-                    TypeParamData {\n-                        name: Some(name![Self]),\n-                        default: None,\n-                        provenance: TypeParamProvenance::TraitSelf,\n-                    }\n-                    .into(),\n-                );\n-                // add super traits as bounds on Self\n-                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&self.body_ctx, trait_def, Either::Left(self_param));\n-                generics.fill(&self.body_ctx, node);\n-            }\n-            GenericsOwner::Impl => {\n-                // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n-                // type-parameter, but rather is a type-alias for impl's target\n-                // type, so this is handled by the resolver.\n-                generics.fill(&self.body_ctx, node);\n-            }\n+\n+        if let HasImplicitSelf::Yes(bounds) = has_implicit_self {\n+            // Traits and trait aliases get the Self type as an implicit first type parameter.\n+            generics.type_or_consts.alloc(\n+                TypeParamData {\n+                    name: Some(name![Self]),\n+                    default: None,\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                }\n+                .into(),\n+            );\n+            // add super traits as bounds on Self\n+            // i.e., `trait Foo: Bar` is equivalent to `trait Foo where Self: Bar`\n+            let self_param = TypeRef::Path(name![Self].into());\n+            generics.fill_bounds(&self.body_ctx, bounds, Either::Left(self_param));\n         }\n \n+        generics.fill(&self.body_ctx, node);\n+\n         generics.shrink_to_fit();\n         Interned::new(generics)\n     }\n@@ -673,17 +689,10 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     Path::from_known_path(path, generic_args)\n }\n \n-enum GenericsOwner<'a> {\n-    /// We need access to the partially-lowered `Function` for lowering `impl Trait` in argument\n-    /// position.\n-    Function(&'a Function),\n-    Struct,\n-    Enum,\n-    Union,\n-    /// The `TraitDef` is needed to fill the source map for the implicit `Self` parameter.\n-    Trait(&'a ast::Trait),\n-    TypeAlias,\n-    Impl,\n+enum HasImplicitSelf {\n+    /// Inner list is a type bound list for the implicit `Self`.\n+    Yes(Option<ast::TypeBoundList>),\n+    No,\n }\n \n fn lower_abi(abi: ast::Abi) -> Interned<str> {"}, {"sha": "5f29997964b9caa727d66c1ea526686f4cda83fa", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -374,23 +374,24 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"trait {}\", name);\n                 self.print_generic_params(generic_params);\n-                match items {\n-                    Some(items) => {\n-                        self.print_where_clause_and_opening_brace(generic_params);\n-                        self.indented(|this| {\n-                            for item in &**items {\n-                                this.print_mod_item((*item).into());\n-                            }\n-                        });\n-                    }\n-                    None => {\n-                        w!(self, \" = \");\n-                        // FIXME: Print the aliased traits\n-                        self.print_where_clause_and_opening_brace(generic_params);\n+                self.print_where_clause_and_opening_brace(generic_params);\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n                     }\n-                }\n+                });\n                 wln!(self, \"}}\");\n             }\n+            ModItem::TraitAlias(it) => {\n+                let TraitAlias { name, visibility, generic_params, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"trait {}\", name);\n+                self.print_generic_params(generic_params);\n+                w!(self, \" = \");\n+                self.print_where_clause(generic_params);\n+                w!(self, \";\");\n+                wln!(self);\n+            }\n             ModItem::Impl(it) => {\n                 let Impl { target_trait, self_ty, is_negative, items, generic_params, ast_id: _ } =\n                     &self.tree[it];"}, {"sha": "f30be6b64e3ded45ee26afb15fd74eb12d1811b8", "filename": "crates/hir-def/src/keys.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fkeys.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -9,8 +9,8 @@ use syntax::{ast, AstNode, AstPtr};\n use crate::{\n     dyn_map::{DynMap, Policy},\n     ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, Macro2Id,\n-    MacroRulesId, ProcMacroId, StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId,\n-    UnionId,\n+    MacroRulesId, ProcMacroId, StaticId, StructId, TraitAliasId, TraitId, TypeAliasId,\n+    TypeOrConstParamId, UnionId,\n };\n \n pub type Key<K, V> = crate::dyn_map::Key<K, V, AstPtrPolicy<K, V>>;\n@@ -21,6 +21,7 @@ pub const STATIC: Key<ast::Static, StaticId> = Key::new();\n pub const TYPE_ALIAS: Key<ast::TypeAlias, TypeAliasId> = Key::new();\n pub const IMPL: Key<ast::Impl, ImplId> = Key::new();\n pub const TRAIT: Key<ast::Trait, TraitId> = Key::new();\n+pub const TRAIT_ALIAS: Key<ast::TraitAlias, TraitAliasId> = Key::new();\n pub const STRUCT: Key<ast::Struct, StructId> = Key::new();\n pub const UNION: Key<ast::Union, UnionId> = Key::new();\n pub const ENUM: Key<ast::Enum, EnumId> = Key::new();"}, {"sha": "4096e0a38267ee4b809f74a5f5ad68aa9461c146", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -181,15 +181,15 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         let _p = profile::span(\"collect_lang_item\");\n-        if let Some(lang_item) = lang_attr(db, item).and_then(|it| LangItem::from_str(&it)) {\n+        if let Some(lang_item) = lang_attr(db, item) {\n             self.items.entry(lang_item).or_insert_with(|| constructor(item));\n         }\n     }\n }\n \n-pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<SmolStr> {\n+pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<LangItem> {\n     let attrs = db.attrs(item.into());\n-    attrs.by_key(\"lang\").string_value().cloned()\n+    attrs.by_key(\"lang\").string_value().cloned().and_then(|it| LangItem::from_str(&it))\n }\n \n pub enum GenericRequirement {"}, {"sha": "8c2e93f09059756ed1e51f20081d55044ad884e4", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -86,7 +86,7 @@ use crate::{\n     builtin_type::BuiltinType,\n     item_tree::{\n         Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, MacroDef, MacroRules, ModItem,\n-        Static, Struct, Trait, TypeAlias, Union,\n+        Static, Struct, Trait, TraitAlias, TypeAlias, Union,\n     },\n };\n \n@@ -128,7 +128,7 @@ impl ModuleId {\n     }\n }\n \n-/// An ID of a module, **local** to a specific crate\n+/// An ID of a module, **local** to a `DefMap`.\n pub type LocalModuleId = Idx<nameres::ModuleData>;\n \n #[derive(Debug)]\n@@ -261,6 +261,11 @@ pub struct TraitId(salsa::InternId);\n pub type TraitLoc = ItemLoc<Trait>;\n impl_intern!(TraitId, TraitLoc, intern_trait, lookup_intern_trait);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TraitAliasId(salsa::InternId);\n+pub type TraitAliasLoc = ItemLoc<TraitAlias>;\n+impl_intern!(TraitAliasId, TraitAliasLoc, intern_trait_alias, lookup_intern_trait_alias);\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n type TypeAliasLoc = AssocItemLoc<TypeAlias>;\n@@ -453,6 +458,7 @@ pub enum ModuleDefId {\n     ConstId(ConstId),\n     StaticId(StaticId),\n     TraitId(TraitId),\n+    TraitAliasId(TraitAliasId),\n     TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n     MacroId(MacroId),\n@@ -466,6 +472,7 @@ impl_from!(\n     ConstId,\n     StaticId,\n     TraitId,\n+    TraitAliasId,\n     TypeAliasId,\n     BuiltinType\n     for ModuleDefId\n@@ -516,6 +523,7 @@ pub enum GenericDefId {\n     FunctionId(FunctionId),\n     AdtId(AdtId),\n     TraitId(TraitId),\n+    TraitAliasId(TraitAliasId),\n     TypeAliasId(TypeAliasId),\n     ImplId(ImplId),\n     // enum variants cannot have generics themselves, but their parent enums\n@@ -528,6 +536,7 @@ impl_from!(\n     FunctionId,\n     AdtId(StructId, EnumId, UnionId),\n     TraitId,\n+    TraitAliasId,\n     TypeAliasId,\n     ImplId,\n     EnumVariantId,\n@@ -555,6 +564,7 @@ pub enum AttrDefId {\n     StaticId(StaticId),\n     ConstId(ConstId),\n     TraitId(TraitId),\n+    TraitAliasId(TraitAliasId),\n     TypeAliasId(TypeAliasId),\n     MacroId(MacroId),\n     ImplId(ImplId),\n@@ -714,6 +724,7 @@ impl HasModule for GenericDefId {\n             GenericDefId::FunctionId(it) => it.lookup(db).module(db),\n             GenericDefId::AdtId(it) => it.module(db),\n             GenericDefId::TraitId(it) => it.lookup(db).container,\n+            GenericDefId::TraitAliasId(it) => it.lookup(db).container,\n             GenericDefId::TypeAliasId(it) => it.lookup(db).module(db),\n             GenericDefId::ImplId(it) => it.lookup(db).container,\n             GenericDefId::EnumVariantId(it) => it.parent.lookup(db).container,\n@@ -747,6 +758,7 @@ impl ModuleDefId {\n             ModuleDefId::ConstId(id) => id.lookup(db).container.module(db),\n             ModuleDefId::StaticId(id) => id.lookup(db).module(db),\n             ModuleDefId::TraitId(id) => id.lookup(db).container,\n+            ModuleDefId::TraitAliasId(id) => id.lookup(db).container,\n             ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db),\n             ModuleDefId::MacroId(id) => id.module(db),\n             ModuleDefId::BuiltinType(_) => return None,\n@@ -765,6 +777,7 @@ impl AttrDefId {\n             AttrDefId::StaticId(it) => it.lookup(db).module(db).krate,\n             AttrDefId::ConstId(it) => it.lookup(db).module(db).krate,\n             AttrDefId::TraitId(it) => it.lookup(db).container.krate,\n+            AttrDefId::TraitAliasId(it) => it.lookup(db).container.krate,\n             AttrDefId::TypeAliasId(it) => it.lookup(db).module(db).krate,\n             AttrDefId::ImplId(it) => it.lookup(db).container.krate,\n             AttrDefId::ExternBlockId(it) => it.lookup(db).container.krate,"}, {"sha": "0b72ca1eec18f64696f2a1e59abbabb1f0066120", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -143,7 +143,7 @@ macro_rules! assert {\n \n fn main() {\n      {\n-        if !true {\n+        if !(true ) {\n             $crate::panic!(\"{} {:?}\", arg1(a, b, c), arg2);\n         }\n     };"}, {"sha": "b663a2917897ea068f92d84451b80e3aefcbedfb", "filename": "crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -827,6 +827,7 @@ macro_rules! rgb_color {\n /* parse error: expected type */\n /* parse error: expected R_PAREN */\n /* parse error: expected R_ANGLE */\n+/* parse error: expected `::` */\n /* parse error: expected COMMA */\n /* parse error: expected R_ANGLE */\n /* parse error: expected SEMICOLON */"}, {"sha": "7d7240e7e8cb3d72830779197c86875c60caf105", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -342,7 +342,7 @@ impl DefMap {\n     }\n \n     pub(crate) fn block_id(&self) -> Option<BlockId> {\n-        self.block.as_ref().map(|block| block.block)\n+        self.block.map(|block| block.block)\n     }\n \n     pub(crate) fn prelude(&self) -> Option<ModuleId> {\n@@ -354,7 +354,7 @@ impl DefMap {\n     }\n \n     pub fn module_id(&self, local_id: LocalModuleId) -> ModuleId {\n-        let block = self.block.as_ref().map(|b| b.block);\n+        let block = self.block.map(|b| b.block);\n         ModuleId { krate: self.krate, local_id, block }\n     }\n \n@@ -428,9 +428,9 @@ impl DefMap {\n     /// Returns the module containing `local_mod`, either the parent `mod`, or the module containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n-        match &self[local_mod].parent {\n-            Some(parent) => Some(self.module_id(*parent)),\n-            None => self.block.as_ref().map(|block| block.parent),\n+        match self[local_mod].parent {\n+            Some(parent) => Some(self.module_id(parent)),\n+            None => self.block.map(|block| block.parent),\n         }\n     }\n \n@@ -440,11 +440,11 @@ impl DefMap {\n         let mut buf = String::new();\n         let mut arc;\n         let mut current_map = self;\n-        while let Some(block) = &current_map.block {\n+        while let Some(block) = current_map.block {\n             go(&mut buf, current_map, \"block scope\", current_map.root);\n             buf.push('\\n');\n             arc = block.parent.def_map(db);\n-            current_map = &*arc;\n+            current_map = &arc;\n         }\n         go(&mut buf, current_map, \"crate\", current_map.root);\n         return buf;\n@@ -468,10 +468,10 @@ impl DefMap {\n         let mut buf = String::new();\n         let mut arc;\n         let mut current_map = self;\n-        while let Some(block) = &current_map.block {\n+        while let Some(block) = current_map.block {\n             format_to!(buf, \"{:?} in {:?}\\n\", block.block, block.parent);\n             arc = block.parent.def_map(db);\n-            current_map = &*arc;\n+            current_map = &arc;\n         }\n \n         format_to!(buf, \"crate scope\\n\");"}, {"sha": "70acc3442c30626afedf4ce15eb6f8e429d41c27", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -51,7 +51,8 @@ use crate::{\n     AdtId, AstId, AstIdWithPath, ConstLoc, EnumLoc, EnumVariantId, ExternBlockLoc, FunctionId,\n     FunctionLoc, ImplLoc, Intern, ItemContainerId, LocalModuleId, Macro2Id, Macro2Loc,\n     MacroExpander, MacroId, MacroRulesId, MacroRulesLoc, ModuleDefId, ModuleId, ProcMacroId,\n-    ProcMacroLoc, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc, UnresolvedMacro,\n+    ProcMacroLoc, StaticLoc, StructLoc, TraitAliasLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n+    UnresolvedMacro,\n };\n \n static GLOB_RECURSION_LIMIT: Limit = Limit::new(100);\n@@ -666,8 +667,10 @@ impl DefCollector<'_> {\n         macro_: Macro2Id,\n         vis: &RawVisibility,\n     ) {\n-        let vis =\n-            self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        let vis = self\n+            .def_map\n+            .resolve_visibility(self.db, module_id, vis, false)\n+            .unwrap_or(Visibility::Public);\n         self.def_map.modules[module_id].scope.declare(macro_.into());\n         self.update(\n             module_id,\n@@ -831,7 +834,7 @@ impl DefCollector<'_> {\n         let mut def = directive.status.namespaces();\n         let vis = self\n             .def_map\n-            .resolve_visibility(self.db, module_id, &directive.import.visibility)\n+            .resolve_visibility(self.db, module_id, &directive.import.visibility, false)\n             .unwrap_or(Visibility::Public);\n \n         match import.kind {\n@@ -1547,7 +1550,7 @@ impl ModCollector<'_, '_> {\n                 };\n             let resolve_vis = |def_map: &DefMap, visibility| {\n                 def_map\n-                    .resolve_visibility(db, self.module_id, visibility)\n+                    .resolve_visibility(db, self.module_id, visibility, false)\n                     .unwrap_or(Visibility::Public)\n             };\n \n@@ -1707,6 +1710,20 @@ impl ModCollector<'_, '_> {\n                         false,\n                     );\n                 }\n+                ModItem::TraitAlias(id) => {\n+                    let it = &self.item_tree[id];\n+\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        TraitAliasLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n+                            .into(),\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n+                }\n                 ModItem::TypeAlias(id) => {\n                     let it = &self.item_tree[id];\n \n@@ -1823,7 +1840,7 @@ impl ModCollector<'_, '_> {\n     ) -> LocalModuleId {\n         let def_map = &mut self.def_collector.def_map;\n         let vis = def_map\n-            .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+            .resolve_visibility(self.def_collector.db, self.module_id, visibility, false)\n             .unwrap_or(Visibility::Public);\n         let modules = &mut def_map.modules;\n         let origin = match definition {"}, {"sha": "25478481dd0b343afd74a5f19d7d05c3e76e4d93", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -78,6 +78,7 @@ impl DefMap {\n         // pub(path)\n         //     ^^^^ this\n         visibility: &RawVisibility,\n+        within_impl: bool,\n     ) -> Option<Visibility> {\n         let mut vis = match visibility {\n             RawVisibility::Module(path) => {\n@@ -102,7 +103,8 @@ impl DefMap {\n         // `super` to its parent (etc.). However, visibilities must only refer to a module in the\n         // DefMap they're written in, so we restrict them when that happens.\n         if let Visibility::Module(m) = vis {\n-            if self.block_id() != m.block {\n+            // ...unless we're resolving visibility for an associated item in an impl.\n+            if self.block_id() != m.block && !within_impl {\n                 cov_mark::hit!(adjust_vis_in_block_def_map);\n                 vis = Visibility::Module(self.module_id(self.root()));\n                 tracing::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);"}, {"sha": "13e6825f8210e263acda981ec86051c0dac1b721", "filename": "crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -223,6 +223,7 @@ pub type Ty = ();\n                     ModuleDefId::ConstId(it) => drop(db.const_data(it)),\n                     ModuleDefId::StaticId(it) => drop(db.static_data(it)),\n                     ModuleDefId::TraitId(it) => drop(db.trait_data(it)),\n+                    ModuleDefId::TraitAliasId(it) => drop(db.trait_alias_data(it)),\n                     ModuleDefId::TypeAliasId(it) => drop(db.type_alias_data(it)),\n                     ModuleDefId::EnumVariantId(_)\n                     | ModuleDefId::ModuleId(_)"}, {"sha": "f3197d1800f22cf455ca1eb619d7637bd6ae3c25", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -8,7 +8,7 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n-    type_ref::{ConstScalarOrPath, LifetimeRef},\n+    type_ref::{ConstRefOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n use intern::Interned;\n@@ -85,7 +85,7 @@ pub struct AssociatedTypeBinding {\n pub enum GenericArg {\n     Type(TypeRef),\n     Lifetime(LifetimeRef),\n-    Const(ConstScalarOrPath),\n+    Const(ConstRefOrPath),\n }\n \n impl Path {"}, {"sha": "b7542bd777d04018974006f76d2057a9a50c7ec4", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n \n-use crate::type_ref::ConstScalarOrPath;\n+use crate::type_ref::ConstRefOrPath;\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n@@ -212,7 +212,7 @@ pub(super) fn lower_generic_args(\n                 }\n             }\n             ast::GenericArg::ConstArg(arg) => {\n-                let arg = ConstScalarOrPath::from_expr_opt(arg.expr());\n+                let arg = ConstRefOrPath::from_expr_opt(arg.expr());\n                 args.push(GenericArg::Const(arg))\n             }\n         }"}, {"sha": "61e64fc10363114c96c3877a8a8cef2a7a2a3d63", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 196, "deletions": 62, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,5 +1,5 @@\n //! Name resolution fa\u00e7ade.\n-use std::{hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n@@ -12,7 +12,7 @@ use crate::{\n     body::scope::{ExprScopes, ScopeId},\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    expr::{ExprId, LabelId, PatId},\n+    expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n     nameres::DefMap,\n@@ -22,7 +22,8 @@ use crate::{\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n     FunctionId, GenericDefId, GenericParamId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalModuleId, Lookup, Macro2Id, MacroId, MacroRulesId, ModuleDefId, ModuleId, ProcMacroId,\n-    StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, VariantId,\n+    StaticId, StructId, TraitAliasId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId,\n+    VariantId,\n };\n \n #[derive(Debug, Clone)]\n@@ -35,19 +36,34 @@ pub struct Resolver {\n     module_scope: ModuleItemMap,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n struct ModuleItemMap {\n     def_map: Arc<DefMap>,\n     module_id: LocalModuleId,\n }\n \n-#[derive(Debug, Clone)]\n+impl fmt::Debug for ModuleItemMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ModuleItemMap\").field(\"module_id\", &self.module_id).finish()\n+    }\n+}\n+\n+#[derive(Clone)]\n struct ExprScope {\n     owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n \n+impl fmt::Debug for ExprScope {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ExprScope\")\n+            .field(\"owner\", &self.owner)\n+            .field(\"scope_id\", &self.scope_id)\n+            .finish()\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n enum Scope {\n     /// All the items and imported names of a module\n@@ -74,6 +90,7 @@ pub enum TypeNs {\n     TypeAliasId(TypeAliasId),\n     BuiltinType(BuiltinType),\n     TraitId(TraitId),\n+    TraitAliasId(TraitAliasId),\n     // Module belong to type ns, but the resolver is used when all module paths\n     // are fully resolved.\n     // ModuleId(ModuleId)\n@@ -85,10 +102,10 @@ pub enum ResolveValueResult {\n     Partial(TypeNs, usize),\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub enum ValueNs {\n     ImplSelf(ImplId),\n-    LocalBinding(PatId),\n+    LocalBinding(BindingId),\n     FunctionId(FunctionId),\n     ConstId(ConstId),\n     StaticId(StaticId),\n@@ -214,10 +231,12 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n+        let within_impl =\n+            self.scopes().find(|scope| matches!(scope, Scope::ImplDefScope(_))).is_some();\n         match visibility {\n             RawVisibility::Module(_) => {\n                 let (item_map, module) = self.item_scope();\n-                item_map.resolve_visibility(db, module, visibility)\n+                item_map.resolve_visibility(db, module, visibility, within_impl)\n             }\n             RawVisibility::Public => Some(Visibility::Public),\n         }\n@@ -236,69 +255,81 @@ impl Resolver {\n             return self.module_scope.resolve_path_in_value_ns(db, path);\n         }\n \n-        for scope in self.scopes() {\n-            match scope {\n-                Scope::ExprScope(_) if n_segments > 1 => continue,\n-                Scope::ExprScope(scope) => {\n-                    let entry = scope\n-                        .expr_scopes\n-                        .entries(scope.scope_id)\n-                        .iter()\n-                        .find(|entry| entry.name() == first_name);\n-\n-                    if let Some(e) = entry {\n-                        return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n+        if n_segments <= 1 {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(scope) => {\n+                        let entry = scope\n+                            .expr_scopes\n+                            .entries(scope.scope_id)\n+                            .iter()\n+                            .find(|entry| entry.name() == first_name);\n+\n+                        if let Some(e) = entry {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(\n+                                e.binding(),\n+                            )));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { params, def } if n_segments > 1 => {\n-                    if let Some(id) = params.find_type_by_name(first_name, *def) {\n-                        let ty = TypeNs::GenericParam(id);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_const_by_name(first_name, *def) {\n+                            let val = ValueNs::GenericParam(id);\n+                            return Some(ResolveValueResult::ValueNs(val));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { .. } if n_segments != 1 => continue,\n-                Scope::GenericParams { params, def } => {\n-                    if let Some(id) = params.find_const_by_name(first_name, *def) {\n-                        let val = ValueNs::GenericParam(id);\n-                        return Some(ResolveValueResult::ValueNs(val));\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_)));\n+                        }\n                     }\n-                }\n-\n-                &Scope::ImplDefScope(impl_) => {\n-                    if first_name == &name![Self] {\n-                        return Some(if n_segments > 1 {\n-                            ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1)\n-                        } else {\n-                            ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_))\n-                        });\n+                    // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                    Scope::AdtScope(_) => continue,\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n-                // bare `Self` doesn't work in the value namespace in a struct/enum definition\n-                Scope::AdtScope(_) if n_segments == 1 => continue,\n-                Scope::AdtScope(adt) => {\n-                    if first_name == &name![Self] {\n-                        let ty = TypeNs::AdtSelfType(*adt);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+            }\n+        } else {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(_) => continue,\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_type_by_name(first_name, *def) {\n+                            let ty = TypeNs::GenericParam(id);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n                     }\n-                }\n-\n-                Scope::BlockScope(m) => {\n-                    if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n-                        return Some(def);\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1));\n+                        }\n+                    }\n+                    Scope::AdtScope(adt) => {\n+                        if first_name == &name![Self] {\n+                            let ty = TypeNs::AdtSelfType(*adt);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n+                    }\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n             }\n         }\n \n-        if let res @ Some(_) = self.module_scope.resolve_path_in_value_ns(db, path) {\n-            return res;\n+        if let Some(res) = self.module_scope.resolve_path_in_value_ns(db, path) {\n+            return Some(res);\n         }\n \n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back\n         // to resolving to the primitive type, to allow this to still work in the presence of\n         // `use core::u16;`.\n-        if path.kind == PathKind::Plain && path.segments().len() > 1 {\n-            if let Some(builtin) = BuiltinType::by_name(&path.segments()[0]) {\n+        if path.kind == PathKind::Plain && n_segments > 1 {\n+            if let Some(builtin) = BuiltinType::by_name(first_name) {\n                 return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n             }\n         }\n@@ -400,6 +431,8 @@ impl Resolver {\n     }\n \n     pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {\n+        // FIXME(trait_alias): Trait alias brings aliased traits in scope! Note that supertraits of\n+        // aliased traits are NOT brought in scope (unless also aliased).\n         let mut traits = FxHashSet::default();\n \n         for scope in self.scopes() {\n@@ -428,6 +461,15 @@ impl Resolver {\n         traits\n     }\n \n+    pub fn traits_in_scope_from_block_scopes(&self) -> impl Iterator<Item = TraitId> + '_ {\n+        self.scopes()\n+            .filter_map(|scope| match scope {\n+                Scope::BlockScope(m) => Some(m.def_map[m.module_id].scope.traits()),\n+                _ => None,\n+            })\n+            .flatten()\n+    }\n+\n     pub fn module(&self) -> ModuleId {\n         let (def_map, local_id) = self.item_scope();\n         def_map.module_id(local_id)\n@@ -459,14 +501,85 @@ impl Resolver {\n         })\n     }\n \n+    pub fn generic_params(&self) -> Option<&Interned<GenericParams>> {\n+        self.scopes().find_map(|scope| match scope {\n+            Scope::GenericParams { params, .. } => Some(params),\n+            _ => None,\n+        })\n+    }\n+\n     pub fn body_owner(&self) -> Option<DefWithBodyId> {\n         self.scopes().find_map(|scope| match scope {\n             Scope::ExprScope(it) => Some(it.owner),\n             _ => None,\n         })\n     }\n+    /// `expr_id` is required to be an expression id that comes after the top level expression scope in the given resolver\n+    #[must_use]\n+    pub fn update_to_inner_scope(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n+        expr_id: ExprId,\n+    ) -> UpdateGuard {\n+        #[inline(always)]\n+        fn append_expr_scope(\n+            db: &dyn DefDatabase,\n+            resolver: &mut Resolver,\n+            owner: DefWithBodyId,\n+            expr_scopes: &Arc<ExprScopes>,\n+            scope_id: ScopeId,\n+        ) {\n+            resolver.scopes.push(Scope::ExprScope(ExprScope {\n+                owner,\n+                expr_scopes: expr_scopes.clone(),\n+                scope_id,\n+            }));\n+            if let Some(block) = expr_scopes.block(scope_id) {\n+                if let Some(def_map) = db.block_def_map(block) {\n+                    let root = def_map.root();\n+                    resolver\n+                        .scopes\n+                        .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n+                    // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                    // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                    // innermost module scope instead?\n+                }\n+            }\n+        }\n+\n+        let start = self.scopes.len();\n+        let innermost_scope = self.scopes().next();\n+        match innermost_scope {\n+            Some(&Scope::ExprScope(ExprScope { scope_id, ref expr_scopes, owner })) => {\n+                let expr_scopes = expr_scopes.clone();\n+                let scope_chain = expr_scopes\n+                    .scope_chain(expr_scopes.scope_for(expr_id))\n+                    .take_while(|&it| it != scope_id);\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+            _ => {\n+                let expr_scopes = db.expr_scopes(owner);\n+                let scope_chain = expr_scopes.scope_chain(expr_scopes.scope_for(expr_id));\n+\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+        }\n+        self.scopes[start..].reverse();\n+        UpdateGuard(start)\n+    }\n+\n+    pub fn reset_to_guard(&mut self, UpdateGuard(start): UpdateGuard) {\n+        self.scopes.truncate(start);\n+    }\n }\n \n+pub struct UpdateGuard(usize);\n+\n impl Resolver {\n     fn scopes(&self) -> impl Iterator<Item = &Scope> {\n         self.scopes.iter().rev()\n@@ -504,7 +617,7 @@ pub enum ScopeDef {\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n     GenericParam(GenericParamId),\n-    Local(PatId),\n+    Local(BindingId),\n     Label(LabelId),\n }\n \n@@ -556,26 +669,37 @@ impl Scope {\n                     acc.add(&name, ScopeDef::Label(label))\n                 }\n                 scope.expr_scopes.entries(scope.scope_id).iter().for_each(|e| {\n-                    acc.add_local(e.name(), e.pat());\n+                    acc.add_local(e.name(), e.binding());\n                 });\n             }\n         }\n     }\n }\n \n-// needs arbitrary_self_types to be a method... or maybe move to the def?\n pub fn resolver_for_expr(db: &dyn DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n-    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n+    let scope_id = scopes.scope_for(expr_id);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n }\n \n pub fn resolver_for_scope(\n     db: &dyn DefDatabase,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n-    let mut r = owner.resolver(db);\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n+}\n+\n+fn resolver_for_scope_(\n+    db: &dyn DefDatabase,\n+    scopes: Arc<ExprScopes>,\n+    scope_id: Option<ScopeId>,\n+    mut r: Resolver,\n+    owner: DefWithBodyId,\n+) -> Resolver {\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     r.scopes.reserve(scope_chain.len());\n \n@@ -641,6 +765,7 @@ impl ModuleItemMap {\n                 let ty = match module_def.take_types()? {\n                     ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n                     ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+                    ModuleDefId::TraitAliasId(it) => TypeNs::TraitAliasId(it),\n                     ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n                     ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n@@ -678,6 +803,7 @@ fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n \n         ModuleDefId::AdtId(AdtId::EnumId(_) | AdtId::UnionId(_))\n         | ModuleDefId::TraitId(_)\n+        | ModuleDefId::TraitAliasId(_)\n         | ModuleDefId::TypeAliasId(_)\n         | ModuleDefId::BuiltinType(_)\n         | ModuleDefId::MacroId(_)\n@@ -695,6 +821,7 @@ fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n         ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n \n         ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+        ModuleDefId::TraitAliasId(it) => TypeNs::TraitAliasId(it),\n \n         ModuleDefId::FunctionId(_)\n         | ModuleDefId::ConstId(_)\n@@ -732,7 +859,7 @@ impl ScopeNames {\n             self.add(name, ScopeDef::Unknown)\n         }\n     }\n-    fn add_local(&mut self, name: &Name, pat: PatId) {\n+    fn add_local(&mut self, name: &Name, binding: BindingId) {\n         let set = self.map.entry(name.clone()).or_default();\n         // XXX: hack, account for local (and only local) shadowing.\n         //\n@@ -743,7 +870,7 @@ impl ScopeNames {\n             cov_mark::hit!(shadowing_shows_single_completion);\n             return;\n         }\n-        set.push(ScopeDef::Local(pat))\n+        set.push(ScopeDef::Local(binding))\n     }\n }\n \n@@ -779,6 +906,12 @@ impl HasResolver for TraitId {\n     }\n }\n \n+impl HasResolver for TraitAliasId {\n+    fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n+        self.lookup(db).container.resolver(db).push_generic_params_scope(db, self.into())\n+    }\n+}\n+\n impl<T: Into<AdtId> + Copy> HasResolver for T {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let def = self.into();\n@@ -858,6 +991,7 @@ impl HasResolver for GenericDefId {\n             GenericDefId::FunctionId(inner) => inner.resolver(db),\n             GenericDefId::AdtId(adt) => adt.resolver(db),\n             GenericDefId::TraitId(inner) => inner.resolver(db),\n+            GenericDefId::TraitAliasId(inner) => inner.resolver(db),\n             GenericDefId::TypeAliasId(inner) => inner.resolver(db),\n             GenericDefId::ImplId(inner) => inner.resolver(db),\n             GenericDefId::EnumVariantId(inner) => inner.parent.resolver(db),"}, {"sha": "8e30f429a9f806d8a4ea5aeef7037bdc52ce3077", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -116,7 +116,7 @@ pub enum TypeRef {\n     Reference(Box<TypeRef>, Option<LifetimeRef>, Mutability),\n     // FIXME: for full const generics, the latter element (length) here is going to have to be an\n     // expression that is further lowered later in hir_ty.\n-    Array(Box<TypeRef>, ConstScalarOrPath),\n+    Array(Box<TypeRef>, ConstRefOrPath),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/, bool /*is_unsafe*/),\n@@ -188,7 +188,7 @@ impl TypeRef {\n                 // `hir_def::body::lower` to lower this into an `Expr` and then evaluate it at the\n                 // `hir_ty` level, which would allow knowing the type of:\n                 // let v: [u8; 2 + 2] = [0u8; 4];\n-                let len = ConstScalarOrPath::from_expr_opt(inner.expr());\n+                let len = ConstRefOrPath::from_expr_opt(inner.expr());\n                 TypeRef::Array(Box::new(TypeRef::from_ast_opt(ctx, inner.ty())), len)\n             }\n             ast::Type::SliceType(inner) => {\n@@ -378,25 +378,25 @@ impl TypeBound {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum ConstScalarOrPath {\n-    Scalar(ConstScalar),\n+pub enum ConstRefOrPath {\n+    Scalar(ConstRef),\n     Path(Name),\n }\n \n-impl std::fmt::Display for ConstScalarOrPath {\n+impl std::fmt::Display for ConstRefOrPath {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            ConstScalarOrPath::Scalar(s) => s.fmt(f),\n-            ConstScalarOrPath::Path(n) => n.fmt(f),\n+            ConstRefOrPath::Scalar(s) => s.fmt(f),\n+            ConstRefOrPath::Path(n) => n.fmt(f),\n         }\n     }\n }\n \n-impl ConstScalarOrPath {\n+impl ConstRefOrPath {\n     pub(crate) fn from_expr_opt(expr: Option<ast::Expr>) -> Self {\n         match expr {\n             Some(x) => Self::from_expr(x),\n-            None => Self::Scalar(ConstScalar::Unknown),\n+            None => Self::Scalar(ConstRef::Unknown),\n         }\n     }\n \n@@ -407,16 +407,16 @@ impl ConstScalarOrPath {\n             ast::Expr::PathExpr(p) => {\n                 match p.path().and_then(|x| x.segment()).and_then(|x| x.name_ref()) {\n                     Some(x) => Self::Path(x.as_name()),\n-                    None => Self::Scalar(ConstScalar::Unknown),\n+                    None => Self::Scalar(ConstRef::Unknown),\n                 }\n             }\n             ast::Expr::PrefixExpr(prefix_expr) => match prefix_expr.op_kind() {\n                 Some(ast::UnaryOp::Neg) => {\n                     let unsigned = Self::from_expr_opt(prefix_expr.expr());\n                     // Add sign\n                     match unsigned {\n-                        Self::Scalar(ConstScalar::UInt(num)) => {\n-                            Self::Scalar(ConstScalar::Int(-(num as i128)))\n+                        Self::Scalar(ConstRef::UInt(num)) => {\n+                            Self::Scalar(ConstRef::Int(-(num as i128)))\n                         }\n                         other => other,\n                     }\n@@ -425,22 +425,22 @@ impl ConstScalarOrPath {\n             },\n             ast::Expr::Literal(literal) => Self::Scalar(match literal.kind() {\n                 ast::LiteralKind::IntNumber(num) => {\n-                    num.value().map(ConstScalar::UInt).unwrap_or(ConstScalar::Unknown)\n+                    num.value().map(ConstRef::UInt).unwrap_or(ConstRef::Unknown)\n                 }\n                 ast::LiteralKind::Char(c) => {\n-                    c.value().map(ConstScalar::Char).unwrap_or(ConstScalar::Unknown)\n+                    c.value().map(ConstRef::Char).unwrap_or(ConstRef::Unknown)\n                 }\n-                ast::LiteralKind::Bool(f) => ConstScalar::Bool(f),\n-                _ => ConstScalar::Unknown,\n+                ast::LiteralKind::Bool(f) => ConstRef::Bool(f),\n+                _ => ConstRef::Unknown,\n             }),\n-            _ => Self::Scalar(ConstScalar::Unknown),\n+            _ => Self::Scalar(ConstRef::Unknown),\n         }\n     }\n }\n \n /// A concrete constant value\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum ConstScalar {\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ConstRef {\n     Int(i128),\n     UInt(u128),\n     Bool(bool),\n@@ -454,18 +454,18 @@ pub enum ConstScalar {\n     Unknown,\n }\n \n-impl ConstScalar {\n+impl ConstRef {\n     pub fn builtin_type(&self) -> BuiltinType {\n         match self {\n-            ConstScalar::UInt(_) | ConstScalar::Unknown => BuiltinType::Uint(BuiltinUint::U128),\n-            ConstScalar::Int(_) => BuiltinType::Int(BuiltinInt::I128),\n-            ConstScalar::Char(_) => BuiltinType::Char,\n-            ConstScalar::Bool(_) => BuiltinType::Bool,\n+            ConstRef::UInt(_) | ConstRef::Unknown => BuiltinType::Uint(BuiltinUint::U128),\n+            ConstRef::Int(_) => BuiltinType::Int(BuiltinInt::I128),\n+            ConstRef::Char(_) => BuiltinType::Char,\n+            ConstRef::Bool(_) => BuiltinType::Bool,\n         }\n     }\n }\n \n-impl From<Literal> for ConstScalar {\n+impl From<Literal> for ConstRef {\n     fn from(literal: Literal) -> Self {\n         match literal {\n             Literal::Char(c) => Self::Char(c),\n@@ -477,14 +477,14 @@ impl From<Literal> for ConstScalar {\n     }\n }\n \n-impl std::fmt::Display for ConstScalar {\n+impl std::fmt::Display for ConstRef {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match self {\n-            ConstScalar::Int(num) => num.fmt(f),\n-            ConstScalar::UInt(num) => num.fmt(f),\n-            ConstScalar::Bool(flag) => flag.fmt(f),\n-            ConstScalar::Char(c) => write!(f, \"'{c}'\"),\n-            ConstScalar::Unknown => f.write_char('_'),\n+            ConstRef::Int(num) => num.fmt(f),\n+            ConstRef::UInt(num) => num.fmt(f),\n+            ConstRef::Bool(flag) => flag.fmt(f),\n+            ConstRef::Char(c) => write!(f, \"'{c}'\"),\n+            ConstRef::Unknown => f.write_char('_'),\n         }\n     }\n }"}, {"sha": "c9fcaae56cf0cbf86c8d19afa15047194f9cfa46", "filename": "crates/hir-def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     nameres::DefMap,\n     path::{ModPath, PathKind},\n     resolver::HasResolver,\n-    ConstId, FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n+    ConstId, FunctionId, HasModule, LocalFieldId, LocalModuleId, ModuleId, VariantId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -120,7 +120,7 @@ impl Visibility {\n         self,\n         db: &dyn DefDatabase,\n         def_map: &DefMap,\n-        mut from_module: crate::LocalModuleId,\n+        mut from_module: LocalModuleId,\n     ) -> bool {\n         let mut to_module = match self {\n             Visibility::Module(m) => m,\n@@ -142,7 +142,8 @@ impl Visibility {\n                 arc = to_module.def_map(db);\n                 &arc\n             };\n-        let is_block_root = matches!(to_module.block, Some(_) if to_module_def_map[to_module.local_id].parent.is_none());\n+        let is_block_root =\n+            to_module.block.is_some() && to_module_def_map[to_module.local_id].parent.is_none();\n         if is_block_root {\n             to_module = to_module_def_map.containing_module(to_module.local_id).unwrap();\n         }"}, {"sha": "295083a37f2320da449668107e757811ed331003", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -206,7 +206,7 @@ fn assert_expand(\n             let cond = cond.clone();\n             let panic_args = itertools::Itertools::intersperse(panic_args.iter().cloned(), comma);\n             quote! {{\n-                if !#cond {\n+                if !(#cond) {\n                     #DOLLAR_CRATE::panic!(##panic_args);\n                 }\n             }}"}, {"sha": "39fc08ecdcfe3f7f7fed01c7b4ec1d99867a5928", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -771,6 +771,15 @@ impl<T> InFile<Option<T>> {\n     }\n }\n \n+impl<L, R> InFile<Either<L, R>> {\n+    pub fn transpose(self) -> Either<InFile<L>, InFile<R>> {\n+        match self.value {\n+            Either::Left(l) => Either::Left(InFile::new(self.file_id, l)),\n+            Either::Right(r) => Either::Right(InFile::new(self.file_id, r)),\n+        }\n+    }\n+}\n+\n impl<'a> InFile<&'a SyntaxNode> {\n     pub fn ancestors_with_macros(\n         self,\n@@ -806,7 +815,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n     ///\n     /// For attributes and derives, this will point back to the attribute only.\n-    /// For the entire item `InFile::use original_file_range_full`.\n+    /// For the entire item use [`InFile::original_file_range_full`].\n     pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n@@ -821,6 +830,21 @@ impl<'a> InFile<&'a SyntaxNode> {\n         }\n     }\n \n+    /// Falls back to the macro call range if the node cannot be mapped up fully.\n+    pub fn original_file_range_full(self, db: &dyn db::AstDatabase) -> FileRange {\n+        match self.file_id.repr() {\n+            HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n+            HirFileIdRepr::MacroFile(mac_file) => {\n+                if let Some(res) = self.original_file_range_opt(db) {\n+                    return res;\n+                }\n+                // Fall back to whole macro call.\n+                let loc = db.lookup_intern_macro_call(mac_file.macro_call_id);\n+                loc.kind.original_call_range_with_body(db)\n+            }\n+        }\n+    }\n+\n     /// Attempts to map the syntax node back up its macro calls.\n     pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n         match ascend_node_border_tokens(db, self) {"}, {"sha": "4572e33486f0ec24a12fb30c83d4956739159bec", "filename": "crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2FCargo.toml?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -18,6 +18,7 @@ arrayvec = \"0.7.2\"\n bitflags = \"1.3.2\"\n smallvec.workspace = true\n ena = \"0.14.0\"\n+either = \"1.7.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\""}, {"sha": "03e9443599d8c577a1d1e011cb9bf84b2f3e5058", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -152,6 +152,15 @@ impl TyBuilder<()> {\n         TyKind::Tuple(0, Substitution::empty(Interner)).intern(Interner)\n     }\n \n+    // FIXME: rustc's ty is dependent on the adt type, maybe we need to do that as well\n+    pub fn discr_ty() -> Ty {\n+        TyKind::Scalar(chalk_ir::Scalar::Int(chalk_ir::IntTy::I128)).intern(Interner)\n+    }\n+\n+    pub fn bool() -> Ty {\n+        TyKind::Scalar(chalk_ir::Scalar::Bool).intern(Interner)\n+    }\n+\n     pub fn usize() -> Ty {\n         TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)).intern(Interner)\n     }"}, {"sha": "28ae4c349f83cfa34117128903898c5c873ce63c", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -540,8 +540,7 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids = trait_data.associated_types().map(to_assoc_type_id).collect();\n     let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n-    let well_known = lang_attr(db.upcast(), trait_)\n-        .and_then(|name| well_known_trait_from_lang_item(LangItem::from_str(&name)?));\n+    let well_known = lang_attr(db.upcast(), trait_).and_then(well_known_trait_from_lang_item);\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(db, &generic_params, trait_datum_bound),"}, {"sha": "e6aefbf27167aa91084a37280ccb3f833d6b7871", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n     CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n-    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n pub trait TyExt {\n@@ -22,6 +22,7 @@ pub trait TyExt {\n     fn is_floating_point(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n+    fn contains_unknown(&self) -> bool;\n     fn is_ty_var(&self) -> bool;\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n@@ -76,6 +77,10 @@ impl TyExt for Ty {\n         matches!(self.kind(Interner), TyKind::Error)\n     }\n \n+    fn contains_unknown(&self) -> bool {\n+        self.data(Interner).flags.contains(TypeFlags::HAS_ERROR)\n+    }\n+\n     fn is_ty_var(&self) -> bool {\n         matches!(self.kind(Interner), TyKind::InferenceVar(_, _))\n     }"}, {"sha": "5830c48988fe50dd8bb48dd8722170d797a6634a", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 101, "deletions": 402, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,30 +1,25 @@\n //! Constant evaluation details\n \n-use std::{\n-    collections::HashMap,\n-    fmt::{Display, Write},\n-};\n-\n-use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData, IntTy, Scalar};\n+use base_db::CrateId;\n+use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n-    builtin_type::BuiltinInt,\n-    expr::{ArithOp, BinaryOp, Expr, ExprId, Literal, Pat, PatId},\n+    expr::Expr,\n     path::ModPath,\n-    resolver::{resolver_for_expr, ResolveValueResult, Resolver, ValueNs},\n-    src::HasChildSource,\n-    type_ref::ConstScalar,\n-    ConstId, DefWithBodyId, EnumVariantId, Lookup,\n+    resolver::{Resolver, ValueNs},\n+    type_ref::ConstRef,\n+    ConstId, EnumVariantId,\n };\n-use la_arena::{Arena, Idx, RawIdx};\n+use la_arena::{Idx, RawIdx};\n use stdx::never;\n-use syntax::ast::HasName;\n \n use crate::{\n-    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode, to_placeholder_idx,\n-    utils::Generics, Const, ConstData, ConstValue, GenericArg, InferenceResult, Interner, Ty,\n-    TyBuilder, TyKind,\n+    db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n+    to_placeholder_idx, utils::Generics, Const, ConstData, ConstScalar, ConstValue, GenericArg,\n+    Interner, MemoryMap, Ty, TyBuilder,\n };\n \n+use super::mir::{interpret_mir, lower_to_mir, pad16, MirEvalError, MirLowerError};\n+\n /// Extension trait for [`Const`]\n pub trait ConstExt {\n     /// Is a [`Const`] unknown?\n@@ -53,346 +48,24 @@ impl ConstExt for Const {\n     }\n }\n \n-pub struct ConstEvalCtx<'a> {\n-    pub db: &'a dyn HirDatabase,\n-    pub owner: DefWithBodyId,\n-    pub exprs: &'a Arena<Expr>,\n-    pub pats: &'a Arena<Pat>,\n-    pub local_data: HashMap<PatId, ComputedExpr>,\n-    infer: &'a InferenceResult,\n-}\n-\n-impl ConstEvalCtx<'_> {\n-    fn expr_ty(&mut self, expr: ExprId) -> Ty {\n-        self.infer[expr].clone()\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ConstEvalError {\n-    NotSupported(&'static str),\n-    SemanticError(&'static str),\n-    Loop,\n-    IncompleteExpr,\n-    Panic(String),\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum ComputedExpr {\n-    Literal(Literal),\n-    Enum(String, EnumVariantId, Literal),\n-    Tuple(Box<[ComputedExpr]>),\n+    MirLowerError(MirLowerError),\n+    MirEvalError(MirEvalError),\n }\n \n-impl Display for ComputedExpr {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            ComputedExpr::Literal(l) => match l {\n-                Literal::Int(x, _) => {\n-                    if *x >= 10 {\n-                        write!(f, \"{x} ({x:#X})\")\n-                    } else {\n-                        x.fmt(f)\n-                    }\n-                }\n-                Literal::Uint(x, _) => {\n-                    if *x >= 10 {\n-                        write!(f, \"{x} ({x:#X})\")\n-                    } else {\n-                        x.fmt(f)\n-                    }\n-                }\n-                Literal::Float(x, _) => x.fmt(f),\n-                Literal::Bool(x) => x.fmt(f),\n-                Literal::Char(x) => std::fmt::Debug::fmt(x, f),\n-                Literal::String(x) => std::fmt::Debug::fmt(x, f),\n-                Literal::ByteString(x) => std::fmt::Debug::fmt(x, f),\n-            },\n-            ComputedExpr::Enum(name, _, _) => name.fmt(f),\n-            ComputedExpr::Tuple(t) => {\n-                f.write_char('(')?;\n-                for x in &**t {\n-                    x.fmt(f)?;\n-                    f.write_str(\", \")?;\n-                }\n-                f.write_char(')')\n-            }\n+impl From<MirLowerError> for ConstEvalError {\n+    fn from(value: MirLowerError) -> Self {\n+        match value {\n+            MirLowerError::ConstEvalError(e) => *e,\n+            _ => ConstEvalError::MirLowerError(value),\n         }\n     }\n }\n \n-fn scalar_max(scalar: &Scalar) -> i128 {\n-    match scalar {\n-        Scalar::Bool => 1,\n-        Scalar::Char => u32::MAX as i128,\n-        Scalar::Int(x) => match x {\n-            IntTy::Isize => isize::MAX as i128,\n-            IntTy::I8 => i8::MAX as i128,\n-            IntTy::I16 => i16::MAX as i128,\n-            IntTy::I32 => i32::MAX as i128,\n-            IntTy::I64 => i64::MAX as i128,\n-            IntTy::I128 => i128::MAX,\n-        },\n-        Scalar::Uint(x) => match x {\n-            chalk_ir::UintTy::Usize => usize::MAX as i128,\n-            chalk_ir::UintTy::U8 => u8::MAX as i128,\n-            chalk_ir::UintTy::U16 => u16::MAX as i128,\n-            chalk_ir::UintTy::U32 => u32::MAX as i128,\n-            chalk_ir::UintTy::U64 => u64::MAX as i128,\n-            chalk_ir::UintTy::U128 => i128::MAX, // ignore too big u128 for now\n-        },\n-        Scalar::Float(_) => 0,\n-    }\n-}\n-\n-fn is_valid(scalar: &Scalar, value: i128) -> bool {\n-    if value < 0 {\n-        !matches!(scalar, Scalar::Uint(_)) && -scalar_max(scalar) - 1 <= value\n-    } else {\n-        value <= scalar_max(scalar)\n-    }\n-}\n-\n-fn get_name(ctx: &mut ConstEvalCtx<'_>, variant: EnumVariantId) -> String {\n-    let loc = variant.parent.lookup(ctx.db.upcast());\n-    let children = variant.parent.child_source(ctx.db.upcast());\n-    let item_tree = loc.id.item_tree(ctx.db.upcast());\n-\n-    let variant_name = children.value[variant.local_id].name();\n-    let enum_name = item_tree[loc.id.value].name.to_string();\n-    enum_name + \"::\" + &variant_name.unwrap().to_string()\n-}\n-\n-pub fn eval_const(\n-    expr_id: ExprId,\n-    ctx: &mut ConstEvalCtx<'_>,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    let u128_to_i128 = |it: u128| -> Result<i128, ConstEvalError> {\n-        it.try_into().map_err(|_| ConstEvalError::NotSupported(\"u128 is too big\"))\n-    };\n-\n-    let expr = &ctx.exprs[expr_id];\n-    match expr {\n-        Expr::Missing => match ctx.owner {\n-            // evaluate the implicit variant index of an enum variant without expression\n-            // FIXME: This should return the type of the enum representation\n-            DefWithBodyId::VariantId(variant) => {\n-                let prev_idx: u32 = variant.local_id.into_raw().into();\n-                let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n-                let value = match prev_idx {\n-                    Some(local_id) => {\n-                        let prev_variant = EnumVariantId { local_id, parent: variant.parent };\n-                        1 + match ctx.db.const_eval_variant(prev_variant)? {\n-                            ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                            ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                            _ => {\n-                                return Err(ConstEvalError::NotSupported(\n-                                    \"Enum can't contain this kind of value\",\n-                                ))\n-                            }\n-                        }\n-                    }\n-                    _ => 0,\n-                };\n-                Ok(ComputedExpr::Literal(Literal::Int(value, Some(BuiltinInt::I128))))\n-            }\n-            _ => Err(ConstEvalError::IncompleteExpr),\n-        },\n-        Expr::Literal(l) => Ok(ComputedExpr::Literal(l.clone())),\n-        &Expr::UnaryOp { expr, op } => {\n-            let ty = &ctx.expr_ty(expr);\n-            let ev = eval_const(expr, ctx)?;\n-            match op {\n-                hir_def::expr::UnaryOp::Deref => Err(ConstEvalError::NotSupported(\"deref\")),\n-                hir_def::expr::UnaryOp::Not => {\n-                    let v = match ev {\n-                        ComputedExpr::Literal(Literal::Bool(b)) => {\n-                            return Ok(ComputedExpr::Literal(Literal::Bool(!b)))\n-                        }\n-                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-                    };\n-                    let r = match ty.kind(Interner) {\n-                        TyKind::Scalar(Scalar::Uint(x)) => match x {\n-                            chalk_ir::UintTy::U8 => !(v as u8) as i128,\n-                            chalk_ir::UintTy::U16 => !(v as u16) as i128,\n-                            chalk_ir::UintTy::U32 => !(v as u32) as i128,\n-                            chalk_ir::UintTy::U64 => !(v as u64) as i128,\n-                            chalk_ir::UintTy::U128 => {\n-                                return Err(ConstEvalError::NotSupported(\"negation of u128\"))\n-                            }\n-                            chalk_ir::UintTy::Usize => !(v as usize) as i128,\n-                        },\n-                        TyKind::Scalar(Scalar::Int(x)) => match x {\n-                            chalk_ir::IntTy::I8 => !(v as i8) as i128,\n-                            chalk_ir::IntTy::I16 => !(v as i16) as i128,\n-                            chalk_ir::IntTy::I32 => !(v as i32) as i128,\n-                            chalk_ir::IntTy::I64 => !(v as i64) as i128,\n-                            chalk_ir::IntTy::I128 => !v,\n-                            chalk_ir::IntTy::Isize => !(v as isize) as i128,\n-                        },\n-                        _ => return Err(ConstEvalError::NotSupported(\"unreachable?\")),\n-                    };\n-                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n-                }\n-                hir_def::expr::UnaryOp::Neg => {\n-                    let v = match ev {\n-                        ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                        ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                        _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-                    };\n-                    Ok(ComputedExpr::Literal(Literal::Int(\n-                        v.checked_neg().ok_or_else(|| {\n-                            ConstEvalError::Panic(\"overflow in negation\".to_string())\n-                        })?,\n-                        None,\n-                    )))\n-                }\n-            }\n-        }\n-        &Expr::BinaryOp { lhs, rhs, op } => {\n-            let ty = &ctx.expr_ty(lhs);\n-            let lhs = eval_const(lhs, ctx)?;\n-            let rhs = eval_const(rhs, ctx)?;\n-            let op = op.ok_or(ConstEvalError::IncompleteExpr)?;\n-            let v1 = match lhs {\n-                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-            };\n-            let v2 = match rhs {\n-                ComputedExpr::Literal(Literal::Int(v, _)) => v,\n-                ComputedExpr::Literal(Literal::Uint(v, _)) => u128_to_i128(v)?,\n-                _ => return Err(ConstEvalError::NotSupported(\"this kind of operator\")),\n-            };\n-            match op {\n-                BinaryOp::ArithOp(b) => {\n-                    let panic_arith = ConstEvalError::Panic(\n-                        \"attempt to run invalid arithmetic operation\".to_string(),\n-                    );\n-                    let r = match b {\n-                        ArithOp::Add => v1.checked_add(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Mul => v1.checked_mul(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Sub => v1.checked_sub(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Div => v1.checked_div(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Rem => v1.checked_rem(v2).ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Shl => v1\n-                            .checked_shl(v2.try_into().map_err(|_| panic_arith.clone())?)\n-                            .ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::Shr => v1\n-                            .checked_shr(v2.try_into().map_err(|_| panic_arith.clone())?)\n-                            .ok_or_else(|| panic_arith.clone())?,\n-                        ArithOp::BitXor => v1 ^ v2,\n-                        ArithOp::BitOr => v1 | v2,\n-                        ArithOp::BitAnd => v1 & v2,\n-                    };\n-                    if let TyKind::Scalar(s) = ty.kind(Interner) {\n-                        if !is_valid(s, r) {\n-                            return Err(panic_arith);\n-                        }\n-                    }\n-                    Ok(ComputedExpr::Literal(Literal::Int(r, None)))\n-                }\n-                BinaryOp::LogicOp(_) => Err(ConstEvalError::SemanticError(\"logic op on numbers\")),\n-                _ => Err(ConstEvalError::NotSupported(\"bin op on this operators\")),\n-            }\n-        }\n-        Expr::Block { statements, tail, .. } => {\n-            let mut prev_values = HashMap::<PatId, Option<ComputedExpr>>::default();\n-            for statement in &**statements {\n-                match *statement {\n-                    hir_def::expr::Statement::Let { pat: pat_id, initializer, .. } => {\n-                        let pat = &ctx.pats[pat_id];\n-                        match pat {\n-                            Pat::Bind { subpat, .. } if subpat.is_none() => (),\n-                            _ => {\n-                                return Err(ConstEvalError::NotSupported(\"complex patterns in let\"))\n-                            }\n-                        };\n-                        let value = match initializer {\n-                            Some(x) => eval_const(x, ctx)?,\n-                            None => continue,\n-                        };\n-                        if !prev_values.contains_key(&pat_id) {\n-                            let prev = ctx.local_data.insert(pat_id, value);\n-                            prev_values.insert(pat_id, prev);\n-                        } else {\n-                            ctx.local_data.insert(pat_id, value);\n-                        }\n-                    }\n-                    hir_def::expr::Statement::Expr { .. } => {\n-                        return Err(ConstEvalError::NotSupported(\"this kind of statement\"))\n-                    }\n-                }\n-            }\n-            let r = match tail {\n-                &Some(x) => eval_const(x, ctx),\n-                None => Ok(ComputedExpr::Tuple(Box::new([]))),\n-            };\n-            // clean up local data, so caller will receive the exact map that passed to us\n-            for (name, val) in prev_values {\n-                match val {\n-                    Some(x) => ctx.local_data.insert(name, x),\n-                    None => ctx.local_data.remove(&name),\n-                };\n-            }\n-            r\n-        }\n-        Expr::Path(p) => {\n-            let resolver = resolver_for_expr(ctx.db.upcast(), ctx.owner, expr_id);\n-            let pr = resolver\n-                .resolve_path_in_value_ns(ctx.db.upcast(), p.mod_path())\n-                .ok_or(ConstEvalError::SemanticError(\"unresolved path\"))?;\n-            let pr = match pr {\n-                ResolveValueResult::ValueNs(v) => v,\n-                ResolveValueResult::Partial(..) => {\n-                    return match ctx\n-                        .infer\n-                        .assoc_resolutions_for_expr(expr_id)\n-                        .ok_or(ConstEvalError::SemanticError(\"unresolved assoc item\"))?\n-                        .0\n-                    {\n-                        hir_def::AssocItemId::FunctionId(_) => {\n-                            Err(ConstEvalError::NotSupported(\"assoc function\"))\n-                        }\n-                        // FIXME use actual impl for trait assoc const\n-                        hir_def::AssocItemId::ConstId(c) => ctx.db.const_eval(c),\n-                        hir_def::AssocItemId::TypeAliasId(_) => {\n-                            Err(ConstEvalError::NotSupported(\"assoc type alias\"))\n-                        }\n-                    };\n-                }\n-            };\n-            match pr {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let r = ctx\n-                        .local_data\n-                        .get(&pat_id)\n-                        .ok_or(ConstEvalError::NotSupported(\"Unexpected missing local\"))?;\n-                    Ok(r.clone())\n-                }\n-                ValueNs::ConstId(id) => ctx.db.const_eval(id),\n-                ValueNs::GenericParam(_) => {\n-                    Err(ConstEvalError::NotSupported(\"const generic without substitution\"))\n-                }\n-                ValueNs::EnumVariantId(id) => match ctx.db.const_eval_variant(id)? {\n-                    ComputedExpr::Literal(lit) => {\n-                        Ok(ComputedExpr::Enum(get_name(ctx, id), id, lit))\n-                    }\n-                    _ => Err(ConstEvalError::NotSupported(\n-                        \"Enums can't evalute to anything but numbers\",\n-                    )),\n-                },\n-                _ => Err(ConstEvalError::NotSupported(\"path that are not const or local\")),\n-            }\n-        }\n-        // FIXME: Handle the cast target\n-        &Expr::Cast { expr, .. } => match eval_const(expr, ctx)? {\n-            ComputedExpr::Enum(_, _, lit) => Ok(ComputedExpr::Literal(lit)),\n-            _ => Err(ConstEvalError::NotSupported(\"Can't cast these types\")),\n-        },\n-        _ => Err(ConstEvalError::NotSupported(\"This kind of expression\")),\n+impl From<MirEvalError> for ConstEvalError {\n+    fn from(value: MirEvalError) -> Self {\n+        ConstEvalError::MirEvalError(value)\n     }\n }\n \n@@ -449,97 +122,123 @@ pub fn intern_const_scalar(value: ConstScalar, ty: Ty) -> Const {\n         .intern(Interner)\n }\n \n+/// Interns a constant scalar with the given type\n+pub fn intern_const_ref(db: &dyn HirDatabase, value: &ConstRef, ty: Ty, krate: CrateId) -> Const {\n+    let bytes = match value {\n+        ConstRef::Int(i) => {\n+            // FIXME: We should handle failure of layout better.\n+            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::UInt(i) => {\n+            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::Bool(b) => ConstScalar::Bytes(vec![*b as u8], MemoryMap::default()),\n+        ConstRef::Char(c) => {\n+            ConstScalar::Bytes((*c as u32).to_le_bytes().to_vec(), MemoryMap::default())\n+        }\n+        ConstRef::Unknown => ConstScalar::Unknown,\n+    };\n+    intern_const_scalar(bytes, ty)\n+}\n+\n /// Interns a possibly-unknown target usize\n-pub fn usize_const(value: Option<u128>) -> Const {\n-    intern_const_scalar(value.map_or(ConstScalar::Unknown, ConstScalar::UInt), TyBuilder::usize())\n+pub fn usize_const(db: &dyn HirDatabase, value: Option<u128>, krate: CrateId) -> Const {\n+    intern_const_ref(\n+        db,\n+        &value.map_or(ConstRef::Unknown, ConstRef::UInt),\n+        TyBuilder::usize(),\n+        krate,\n+    )\n+}\n+\n+pub fn try_const_usize(c: &Const) -> Option<u128> {\n+    match &c.data(Interner).value {\n+        chalk_ir::ConstValue::BoundVar(_) => None,\n+        chalk_ir::ConstValue::InferenceVar(_) => None,\n+        chalk_ir::ConstValue::Placeholder(_) => None,\n+        chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+            ConstScalar::Bytes(x, _) => Some(u128::from_le_bytes(pad16(&x, false))),\n+            _ => None,\n+        },\n+    }\n }\n \n pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &ConstId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    Err(ConstEvalError::Loop)\n+) -> Result<Const, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n \n-pub(crate) fn const_eval_variant_recover(\n+pub(crate) fn const_eval_discriminant_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n     _: &EnumVariantId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n-    Err(ConstEvalError::Loop)\n+) -> Result<i128, ConstEvalError> {\n+    Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n }\n \n-pub(crate) fn const_eval_variant_query(\n+pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n     const_id: ConstId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n+) -> Result<Const, ConstEvalError> {\n     let def = const_id.into();\n-    let body = db.body(def);\n-    let infer = &db.infer(def);\n-    let result = eval_const(\n-        body.body_expr,\n-        &mut ConstEvalCtx {\n-            db,\n-            owner: const_id.into(),\n-            exprs: &body.exprs,\n-            pats: &body.pats,\n-            local_data: HashMap::default(),\n-            infer,\n-        },\n-    );\n-    result\n+    let body = db.mir_body(def)?;\n+    let c = interpret_mir(db, &body, false)?;\n+    Ok(c)\n }\n \n-pub(crate) fn const_eval_query_variant(\n+pub(crate) fn const_eval_discriminant_variant(\n     db: &dyn HirDatabase,\n     variant_id: EnumVariantId,\n-) -> Result<ComputedExpr, ConstEvalError> {\n+) -> Result<i128, ConstEvalError> {\n     let def = variant_id.into();\n     let body = db.body(def);\n-    let infer = &db.infer(def);\n-    eval_const(\n-        body.body_expr,\n-        &mut ConstEvalCtx {\n-            db,\n-            owner: def,\n-            exprs: &body.exprs,\n-            pats: &body.pats,\n-            local_data: HashMap::default(),\n-            infer,\n-        },\n-    )\n+    if body.exprs[body.body_expr] == Expr::Missing {\n+        let prev_idx: u32 = variant_id.local_id.into_raw().into();\n+        let prev_idx = prev_idx.checked_sub(1).map(RawIdx::from).map(Idx::from_raw);\n+        let value = match prev_idx {\n+            Some(local_id) => {\n+                let prev_variant = EnumVariantId { local_id, parent: variant_id.parent };\n+                1 + db.const_eval_discriminant(prev_variant)?\n+            }\n+            _ => 0,\n+        };\n+        return Ok(value);\n+    }\n+    let mir_body = db.mir_body(def)?;\n+    let c = interpret_mir(db, &mir_body, false)?;\n+    let c = try_const_usize(&c).unwrap() as i128;\n+    Ok(c)\n }\n \n+// FIXME: Ideally constants in const eval should have separate body (issue #7434), and this function should\n+// get an `InferenceResult` instead of an `InferenceContext`. And we should remove `ctx.clone().resolve_all()` here\n+// and make this function private. See the fixme comment on `InferenceContext::resolve_all`.\n pub(crate) fn eval_to_const(\n     expr: Idx<Expr>,\n     mode: ParamLoweringMode,\n     ctx: &mut InferenceContext<'_>,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n+    let db = ctx.db;\n     if let Expr::Path(p) = &ctx.body.exprs[expr] {\n-        let db = ctx.db;\n         let resolver = &ctx.resolver;\n         if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n             return c;\n         }\n     }\n-    let body = ctx.body.clone();\n-    let mut ctx = ConstEvalCtx {\n-        db: ctx.db,\n-        owner: ctx.owner,\n-        exprs: &body.exprs,\n-        pats: &body.pats,\n-        local_data: HashMap::default(),\n-        infer: &ctx.result,\n-    };\n-    let computed_expr = eval_const(expr, &mut ctx);\n-    let const_scalar = match computed_expr {\n-        Ok(ComputedExpr::Literal(literal)) => literal.into(),\n-        _ => ConstScalar::Unknown,\n-    };\n-    intern_const_scalar(const_scalar, TyBuilder::usize())\n+    let infer = ctx.clone().resolve_all();\n+    if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n+        if let Ok(result) = interpret_mir(db, &mir_body, true) {\n+            return result;\n+        }\n+    }\n+    unknown_const(infer[expr].clone())\n }\n \n #[cfg(test)]"}, {"sha": "6a29e8ce52e62bfbd75f91ac2e52f0d8bd7374d3", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 920, "deletions": 35, "changes": 955, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,24 +1,44 @@\n use base_db::fixture::WithFixture;\n-use hir_def::{db::DefDatabase, expr::Literal};\n+use hir_def::db::DefDatabase;\n \n-use crate::{consteval::ComputedExpr, db::HirDatabase, test_db::TestDB};\n+use crate::{\n+    consteval::try_const_usize, db::HirDatabase, test_db::TestDB, Const, ConstScalar, Interner,\n+};\n \n-use super::ConstEvalError;\n+use super::{\n+    super::mir::{MirEvalError, MirLowerError},\n+    ConstEvalError,\n+};\n \n+fn simplify(e: ConstEvalError) -> ConstEvalError {\n+    match e {\n+        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n+            simplify(ConstEvalError::MirEvalError(*e))\n+        }\n+        _ => e,\n+    }\n+}\n+\n+#[track_caller]\n fn check_fail(ra_fixture: &str, error: ConstEvalError) {\n-    assert_eq!(eval_goal(ra_fixture), Err(error));\n+    assert_eq!(eval_goal(ra_fixture).map_err(simplify), Err(error));\n }\n \n+#[track_caller]\n fn check_number(ra_fixture: &str, answer: i128) {\n     let r = eval_goal(ra_fixture).unwrap();\n-    match r {\n-        ComputedExpr::Literal(Literal::Int(r, _)) => assert_eq!(r, answer),\n-        ComputedExpr::Literal(Literal::Uint(r, _)) => assert_eq!(r, answer as u128),\n-        x => panic!(\"Expected number but found {x:?}\"),\n+    match &r.data(Interner).value {\n+        chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+            ConstScalar::Bytes(b, _) => {\n+                assert_eq!(b, &answer.to_le_bytes()[0..b.len()]);\n+            }\n+            x => panic!(\"Expected number but found {:?}\", x),\n+        },\n+        _ => panic!(\"result of const eval wasn't a concrete const\"),\n     }\n }\n \n-fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n+fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n     let (db, file_id) = TestDB::with_single_file(ra_fixture);\n     let module_id = db.module_for_file(file_id);\n     let def_map = module_id.def_map(&db);\n@@ -42,21 +62,18 @@ fn eval_goal(ra_fixture: &str) -> Result<ComputedExpr, ConstEvalError> {\n #[test]\n fn add() {\n     check_number(r#\"const GOAL: usize = 2 + 2;\"#, 4);\n+    check_number(r#\"const GOAL: i32 = -2 + --5;\"#, 3);\n+    check_number(r#\"const GOAL: i32 = 7 - 5;\"#, 2);\n+    check_number(r#\"const GOAL: i32 = 7 + (1 - 5);\"#, 3);\n }\n \n #[test]\n fn bit_op() {\n     check_number(r#\"const GOAL: u8 = !0 & !(!0 >> 1)\"#, 128);\n     check_number(r#\"const GOAL: i8 = !0 & !(!0 >> 1)\"#, 0);\n-    // FIXME: rustc evaluate this to -128\n-    check_fail(\n-        r#\"const GOAL: i8 = 1 << 7\"#,\n-        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n-    );\n-    check_fail(\n-        r#\"const GOAL: i8 = 1 << 8\"#,\n-        ConstEvalError::Panic(\"attempt to run invalid arithmetic operation\".to_string()),\n-    );\n+    check_number(r#\"const GOAL: i8 = 1 << 7\"#, (1i8 << 7) as i128);\n+    // FIXME: report panic here\n+    check_number(r#\"const GOAL: i8 = 1 << 8\"#, 0);\n }\n \n #[test]\n@@ -73,6 +90,803 @@ fn locals() {\n     );\n }\n \n+#[test]\n+fn references() {\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &mut x;\n+        *y = 5;\n+        x\n+    };\n+    \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    struct Foo(i32);\n+    impl Foo {\n+        fn method(&mut self, x: i32) {\n+            self.0 = 2 * self.0 + x;\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let mut x = Foo(3);\n+        x.method(5);\n+        x.0\n+    };\n+    \"#,\n+        11,\n+    );\n+}\n+\n+#[test]\n+fn reference_autoderef() {\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &mut x;\n+        let y: &mut usize = &mut y;\n+        *y = 5;\n+        x\n+    };\n+    \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: usize = {\n+        let x = 3;\n+        let y = &&&&&&&x;\n+        let z: &usize = &y;\n+        *z\n+    };\n+    \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    struct Foo<T> { x: T }\n+    impl<T> Foo<T> {\n+        fn foo(&mut self) -> T { self.x }\n+    }\n+    fn f(i: &mut &mut Foo<Foo<i32>>) -> i32 {\n+        ((**i).x).foo()\n+    }\n+    fn g(i: Foo<Foo<i32>>) -> i32 {\n+        i.x.foo()\n+    }\n+    const GOAL: i32 = f(&mut &mut Foo { x: Foo { x: 3 } }) + g(Foo { x: Foo { x: 5 } });\n+    \"#,\n+        8,\n+    );\n+}\n+\n+#[test]\n+fn overloaded_deref() {\n+    // FIXME: We should support this.\n+    check_fail(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = i32;\n+        fn deref(&self) -> &i32 {\n+            &5\n+        }\n+    }\n+\n+    const GOAL: i32 = {\n+        let x = Foo;\n+        let y = &*x;\n+        *y + *x\n+    };\n+    \"#,\n+        ConstEvalError::MirLowerError(MirLowerError::NotSupported(\n+            \"explicit overloaded deref\".into(),\n+        )),\n+    );\n+}\n+\n+#[test]\n+fn overloaded_deref_autoref() {\n+    check_number(\n+        r#\"\n+    //- minicore: deref_mut\n+    struct Foo;\n+    struct Bar;\n+\n+    impl core::ops::Deref for Foo {\n+        type Target = Bar;\n+        fn deref(&self) -> &Bar {\n+            &Bar\n+        }\n+    }\n+\n+    impl Bar {\n+        fn method(&self) -> i32 {\n+            5\n+        }\n+    }\n+\n+    const GOAL: i32 = Foo.method();\n+    \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn function_call() {\n+    check_number(\n+        r#\"\n+    const fn f(x: usize) -> usize {\n+        2 * x + 5\n+    }\n+    const GOAL: usize = f(3);\n+    \"#,\n+        11,\n+    );\n+    check_number(\n+        r#\"\n+    const fn add(x: usize, y: usize) -> usize {\n+        x + y\n+    }\n+    const GOAL: usize = add(add(1, 2), add(3, add(4, 5)));\n+    \"#,\n+        15,\n+    );\n+}\n+\n+#[test]\n+fn intrinsics() {\n+    check_number(\n+        r#\"\n+    extern \"rust-intrinsic\" {\n+        pub fn size_of<T>() -> usize;\n+    }\n+\n+    const GOAL: usize = size_of::<i32>();\n+    \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn trait_basic() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = 3;\n+        Foo::f(&x)\n+    };\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn trait_method() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let x = 3;\n+        x.f()\n+    };\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn generic_fn() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for () {\n+        fn f(&self) -> u8 {\n+            0\n+        }\n+    }\n+\n+    struct Succ<S>(S);\n+\n+    impl<T: Foo> Foo for Succ<T> {\n+        fn f(&self) -> u8 {\n+            self.0.f() + 1\n+        }\n+    }\n+\n+    const GOAL: u8 = Succ(Succ(())).f();\n+    \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    fn foof<T: Foo>(x: T, y: T) -> u8 {\n+        x.f() + y.f()\n+    }\n+\n+    const GOAL: u8 = foof(2, 5);\n+    \"#,\n+        73,\n+    );\n+    check_number(\n+        r#\"\n+    fn bar<A, B>(a: A, b: B) -> B {\n+        b\n+    }\n+        const GOAL: u8 = bar(\"hello\", 12);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    fn bar<A, B>(a: A, b: B) -> B {\n+        b\n+    }\n+    fn foo<T>(x: [T; 2]) -> T {\n+        bar(x[0], x[1])\n+    }\n+\n+    const GOAL: u8 = foo([2, 5]);\n+    \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn impl_trait() {\n+    check_number(\n+        r#\"\n+    trait Foo {\n+        fn f(&self) -> u8;\n+    }\n+\n+    impl Foo for u8 {\n+        fn f(&self) -> u8 {\n+            *self + 33\n+        }\n+    }\n+\n+    fn foof(x: impl Foo, y: impl Foo) -> impl Foo {\n+        x.f() + y.f()\n+    }\n+\n+    const GOAL: u8 = foof(2, 5).f();\n+    \"#,\n+        106,\n+    );\n+    check_number(\n+        r#\"\n+        struct Foo<T>(T, T, (T, T));\n+        trait S {\n+            fn sum(&self) -> i64;\n+        }\n+        impl S for i64 {\n+            fn sum(&self) -> i64 {\n+                *self\n+            }\n+        }\n+        impl<T: S> S for Foo<T> {\n+            fn sum(&self) -> i64 {\n+                self.0.sum() + self.1.sum() + self.2 .0.sum() + self.2 .1.sum()\n+            }\n+        }\n+\n+        fn foo() -> Foo<impl S> {\n+            Foo(\n+                Foo(1i64, 2, (3, 4)),\n+                Foo(5, 6, (7, 8)),\n+                (\n+                    Foo(9, 10, (11, 12)),\n+                    Foo(13, 14, (15, 16)),\n+                ),\n+            )\n+        }\n+        const GOAL: i64 = foo().sum();\n+    \"#,\n+        136,\n+    );\n+}\n+\n+#[test]\n+fn ifs() {\n+    check_number(\n+        r#\"\n+    const fn f(b: bool) -> u8 {\n+        if b { 1 } else { 10 }\n+    }\n+\n+    const GOAL: u8 = f(true) + f(true) + f(false);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    const fn max(a: i32, b: i32) -> i32 {\n+        if a < b { b } else { a }\n+    }\n+\n+    const GOAL: i32 = max(max(1, max(10, 3)), 0-122);\n+        \"#,\n+        10,\n+    );\n+\n+    check_number(\n+        r#\"\n+    const fn max(a: &i32, b: &i32) -> &i32 {\n+        if *a < *b { b } else { a }\n+    }\n+\n+    const GOAL: i32 = *max(max(&1, max(&10, &3)), &5);\n+        \"#,\n+        10,\n+    );\n+}\n+\n+#[test]\n+fn loops() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        loop {\n+            x = x + 1;\n+            while true {\n+                break;\n+            }\n+            x = x + 1;\n+            if x == 2 {\n+                continue;\n+            }\n+            break;\n+        }\n+        x\n+    };\n+        \"#,\n+        4,\n+    );\n+}\n+\n+#[test]\n+fn for_loops() {\n+    check_number(\n+        r#\"\n+    //- minicore: iterator\n+\n+    struct Range {\n+        start: u8,\n+        end: u8,\n+    }\n+\n+    impl Iterator for Range {\n+        type Item = u8;\n+        fn next(&mut self) -> Option<u8> {\n+            if self.start >= self.end {\n+                None\n+            } else {\n+                let r = self.start;\n+                self.start = self.start + 1;\n+                Some(r)\n+            }\n+        }\n+    }\n+\n+    const GOAL: u8 = {\n+        let mut sum = 0;\n+        let ar = Range { start: 1, end: 11 };\n+        for i in ar {\n+            sum = sum + i;\n+        }\n+        sum\n+    };\n+        \"#,\n+        55,\n+    );\n+}\n+\n+#[test]\n+fn recursion() {\n+    check_number(\n+        r#\"\n+    const fn fact(k: i32) -> i32 {\n+        if k > 0 { fact(k - 1) * k } else { 1 }\n+    }\n+\n+    const GOAL: i32 = fact(5);\n+        \"#,\n+        120,\n+    );\n+}\n+\n+#[test]\n+fn structs() {\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let y = 1;\n+            let x = 3;\n+            let q = Point { y, x };\n+            p.x + p.y + p.x + q.y + q.y + q.x\n+        };\n+        \"#,\n+        17,\n+    );\n+}\n+\n+#[test]\n+fn unions() {\n+    check_number(\n+        r#\"\n+        union U {\n+            f1: i64,\n+            f2: (i32, i32),\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = U { f1: 0x0123ABCD0123DCBA };\n+            let p = unsafe { p.f2 };\n+            p.0 + p.1 + p.1\n+        };\n+        \"#,\n+        0x0123ABCD * 2 + 0x0123DCBA,\n+    );\n+}\n+\n+#[test]\n+fn tuples() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let a = (10, 20, 3, 15);\n+        a.1\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let mut a = (10, 20, 3, 15);\n+        a.1 = 2;\n+        a.0 + a.1 + a.2 + a.3\n+    };\n+        \"#,\n+        30,\n+    );\n+    check_number(\n+        r#\"\n+    struct TupleLike(i32, u8, i64, u16);\n+    const GOAL: u8 = {\n+        let a = TupleLike(10, 20, 3, 15);\n+        a.1\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        match (&(2 + 2), &4) {\n+            (left_val, right_val) => {\n+                if !(*left_val == *right_val) {\n+                    2\n+                } else {\n+                    5\n+                }\n+            }\n+        }\n+    };\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn path_pattern_matching() {\n+    check_number(\n+        r#\"\n+    enum Season {\n+        Spring,\n+        Summer,\n+        Fall,\n+        Winter,\n+    }\n+\n+    use Season::*;\n+\n+    const fn f(x: Season) -> i32 {\n+        match x {\n+            Spring => 1,\n+            Summer => 2,\n+            Fall => 3,\n+            Winter => 4,\n+        }\n+    }\n+    const GOAL: i32 = f(Spring) + 10 * f(Summer) + 100 * f(Fall) + 1000 * f(Winter);\n+        \"#,\n+        4321,\n+    );\n+}\n+\n+#[test]\n+fn pattern_matching_ergonomics() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        match x {\n+            (a, b) => *a + *b\n+        }\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn let_else() {\n+    check_number(\n+        r#\"\n+    const fn f(x: &(u8, u8)) -> u8 {\n+        let (a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    enum SingleVariant {\n+        Var(u8, u8),\n+    }\n+    const fn f(x: &&&&&SingleVariant) -> u8 {\n+        let SingleVariant::Var(a, b) = x;\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&&&&&SingleVariant::Var(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let Some(x) = x else { return 10 };\n+        2 * x\n+    }\n+    const GOAL: i32 = f(Some(1000)) + f(None);\n+        \"#,\n+        2010,\n+    );\n+}\n+\n+#[test]\n+fn function_param_patterns() {\n+    check_number(\n+        r#\"\n+    const fn f((a, b): &(u8, u8)) -> u8 {\n+        *a + *b\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(c @ (a, b): &(u8, u8)) -> u8 {\n+        *a + *b + c.0 + (*c).1\n+    }\n+    const GOAL: u8 = f(&(2, 3));\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(ref a: u8) -> u8 {\n+        *a\n+    }\n+    const GOAL: u8 = f(2);\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    struct Foo(u8);\n+    impl Foo {\n+        const fn f(&self, (a, b): &(u8, u8)) -> u8 {\n+            self.0 + *a + *b\n+        }\n+    }\n+    const GOAL: u8 = Foo(4).f(&(2, 3));\n+        \"#,\n+        9,\n+    );\n+}\n+\n+#[test]\n+fn options() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let x = Some(2);\n+        match x {\n+            Some(y) => 2 * y,\n+            _ => 10,\n+        }\n+    };\n+        \"#,\n+        4,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    fn f(x: Option<Option<i32>>) -> i32 {\n+        if let Some(y) = x && let Some(z) = y {\n+            z\n+        } else if let Some(y) = x {\n+            1\n+        } else {\n+            0\n+        }\n+    }\n+    const GOAL: i32 = f(Some(Some(10))) + f(Some(None)) + f(None);\n+        \"#,\n+        11,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let x = None;\n+        match x {\n+            Some(y) => 2 * y,\n+            _ => 10,\n+        }\n+    };\n+        \"#,\n+        10,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: Option<&u8> = None;\n+        \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn or_pattern() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let (a | a) = 2;\n+        a\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let (Some(a) | Some(a)) = x else { return 2; };\n+        a\n+    }\n+    const GOAL: i32 = f(Some(10)) + f(None);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match (x, y) {\n+            (Some(x), Some(y)) => x * y,\n+            (Some(a), _) | (_, Some(a)) => a,\n+            _ => 10,\n+        }\n+    }\n+    const GOAL: i32 = f(Some(10), Some(20)) + f(Some(30), None) + f(None, Some(40)) + f(None, None);\n+        \"#,\n+        280,\n+    );\n+}\n+\n+#[test]\n+fn array_and_index() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: u8 = {\n+        let a = [10, 20, 3, 15];\n+        let x: &[u8] = &a;\n+        x[1]\n+    };\n+        \"#,\n+        20,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = [1, 2, 3][2];\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = { let a = [1, 2, 3]; let x: &[i32] = &a; x.len() };\"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = [1, 2, 3, 4, 5].len();\"#,\n+        5,\n+    );\n+}\n+\n+#[test]\n+fn byte_string() {\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    const GOAL: u8 = {\n+        let a = b\"hello\";\n+        let x: &[u8] = a;\n+        x[0]\n+    };\n+        \"#,\n+        104,\n+    );\n+}\n+\n #[test]\n fn consts() {\n     check_number(\n@@ -92,41 +906,35 @@ fn enums() {\n         r#\"\n     enum E {\n         F1 = 1,\n-        F2 = 2 * E::F1 as u8,\n-        F3 = 3 * E::F2 as u8,\n+        F2 = 2 * E::F1 as isize, // Rustc expects an isize here\n+        F3 = 3 * E::F2 as isize,\n     }\n-    const GOAL: i32 = E::F3 as u8;\n+    const GOAL: u8 = E::F3 as u8;\n     \"#,\n         6,\n     );\n     check_number(\n         r#\"\n     enum E { F1 = 1, F2, }\n-    const GOAL: i32 = E::F2 as u8;\n+    const GOAL: u8 = E::F2 as u8;\n     \"#,\n         2,\n     );\n     check_number(\n         r#\"\n     enum E { F1, }\n-    const GOAL: i32 = E::F1 as u8;\n+    const GOAL: u8 = E::F1 as u8;\n     \"#,\n         0,\n     );\n     let r = eval_goal(\n         r#\"\n-        enum E { A = 1, }\n+        enum E { A = 1, B }\n         const GOAL: E = E::A;\n         \"#,\n     )\n     .unwrap();\n-    match r {\n-        ComputedExpr::Enum(name, _, Literal::Uint(val, _)) => {\n-            assert_eq!(name, \"E::A\");\n-            assert_eq!(val, 1);\n-        }\n-        x => panic!(\"Expected enum but found {x:?}\"),\n-    }\n+    assert_eq!(try_const_usize(&r), Some(1));\n }\n \n #[test]\n@@ -138,7 +946,19 @@ fn const_loop() {\n     const F2: i32 = 2 * F1;\n     const GOAL: i32 = F3;\n     \"#,\n-        ConstEvalError::Loop,\n+        ConstEvalError::MirLowerError(MirLowerError::Loop),\n+    );\n+}\n+\n+#[test]\n+fn const_transfer_memory() {\n+    check_number(\n+        r#\"\n+    const A1: &i32 = &2;\n+    const A2: &i32 = &5;\n+    const GOAL: i32 = *A1 + *A2;\n+    \"#,\n+        7,\n     );\n }\n \n@@ -157,7 +977,20 @@ fn const_impl_assoc() {\n }\n \n #[test]\n-fn const_generic_subst() {\n+fn const_generic_subst_fn() {\n+    check_number(\n+        r#\"\n+    const fn f<const A: usize>(x: usize) -> usize {\n+        A * x + 5\n+    }\n+    const GOAL: usize = f::<2>(3);\n+    \"#,\n+        11,\n+    );\n+}\n+\n+#[test]\n+fn const_generic_subst_assoc_const_impl() {\n     // FIXME: this should evaluate to 5\n     check_fail(\n         r#\"\n@@ -167,7 +1000,7 @@ fn const_generic_subst() {\n     }\n     const GOAL: usize = Adder::<2, 3>::VAL;\n     \"#,\n-        ConstEvalError::NotSupported(\"const generic without substitution\"),\n+        ConstEvalError::MirEvalError(MirEvalError::TypeError(\"missing generic arg\")),\n     );\n }\n \n@@ -185,6 +1018,58 @@ fn const_trait_assoc() {\n     }\n     const GOAL: usize = U0::VAL;\n     \"#,\n-        ConstEvalError::IncompleteExpr,\n+        ConstEvalError::MirLowerError(MirLowerError::IncompleteExpr),\n+    );\n+}\n+\n+#[test]\n+fn exec_limits() {\n+    check_fail(\n+        r#\"\n+    const GOAL: usize = loop {};\n+    \"#,\n+        ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n+    );\n+    check_fail(\n+        r#\"\n+    const fn f(x: i32) -> i32 {\n+        f(x + 1)\n+    }\n+    const GOAL: i32 = f(0);\n+    \"#,\n+        ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n+    );\n+    // Reasonable code should still work\n+    check_number(\n+        r#\"\n+    const fn nth_odd(n: i32) -> i32 {\n+        2 * n - 1\n+    }\n+    const fn f(n: i32) -> i32 {\n+        let sum = 0;\n+        let i = 0;\n+        while i < n {\n+            i = i + 1;\n+            sum = sum + nth_odd(i);\n+        }\n+        sum\n+    }\n+    const GOAL: i32 = f(10000);\n+    \"#,\n+        10000 * 10000,\n+    );\n+}\n+\n+#[test]\n+fn type_error() {\n+    let e = eval_goal(\n+        r#\"\n+    const GOAL: u8 = {\n+        let x: u16 = 2;\n+        let y: (u8, u8) = x;\n+        y.0\n+    };\n+    \"#,\n     );\n+    assert!(matches!(e, Err(ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_)))));\n }"}, {"sha": "304c78767f129a679b845318bd61889c75b4c490", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -16,10 +16,12 @@ use smallvec::SmallVec;\n \n use crate::{\n     chalk_db,\n-    consteval::{ComputedExpr, ConstEvalError},\n+    consteval::ConstEvalError,\n     method_resolution::{InherentImpls, TraitImpls, TyFingerprint},\n-    Binders, CallableDefId, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner, PolyFnSig,\n-    QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId, ValueTyDefId,\n+    mir::{BorrowckResult, MirBody, MirLowerError},\n+    Binders, CallableDefId, Const, FnDefId, GenericArg, ImplTraitId, InferenceResult, Interner,\n+    PolyFnSig, QuantifiedWhereClause, ReturnTypeImplTraits, Substitution, TraitRef, Ty, TyDefId,\n+    ValueTyDefId,\n };\n use hir_expand::name::Name;\n \n@@ -32,6 +34,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::infer::infer_query)]\n     fn infer_query(&self, def: DefWithBodyId) -> Arc<InferenceResult>;\n \n+    #[salsa::invoke(crate::mir::mir_body_query)]\n+    #[salsa::cycle(crate::mir::mir_body_recover)]\n+    fn mir_body(&self, def: DefWithBodyId) -> Result<Arc<MirBody>, MirLowerError>;\n+\n+    #[salsa::invoke(crate::mir::borrowck_query)]\n+    fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<BorrowckResult>, MirLowerError>;\n+\n     #[salsa::invoke(crate::lower::ty_query)]\n     #[salsa::cycle(crate::lower::ty_recover)]\n     fn ty(&self, def: TyDefId) -> Binders<Ty>;\n@@ -46,13 +55,13 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::const_param_ty_query)]\n     fn const_param_ty(&self, def: ConstParamId) -> Ty;\n \n-    #[salsa::invoke(crate::consteval::const_eval_variant_query)]\n+    #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: ConstId) -> Result<ComputedExpr, ConstEvalError>;\n+    fn const_eval(&self, def: ConstId) -> Result<Const, ConstEvalError>;\n \n-    #[salsa::invoke(crate::consteval::const_eval_query_variant)]\n-    #[salsa::cycle(crate::consteval::const_eval_variant_recover)]\n-    fn const_eval_variant(&self, def: EnumVariantId) -> Result<ComputedExpr, ConstEvalError>;\n+    #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n+    #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]\n+    fn const_eval_discriminant(&self, def: EnumVariantId) -> Result<i128, ConstEvalError>;\n \n     #[salsa::invoke(crate::lower::impl_trait_query)]\n     fn impl_trait(&self, def: ImplId) -> Option<Binders<TraitRef>>;"}, {"sha": "d36b93e3bdde19d71978235ad65005ef2d84a65b", "filename": "crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -178,6 +178,7 @@ impl<'a> DeclValidator<'a> {\n                 AttrDefId::StaticId(sid) => Some(sid.lookup(self.db.upcast()).container.into()),\n                 AttrDefId::ConstId(cid) => Some(cid.lookup(self.db.upcast()).container.into()),\n                 AttrDefId::TraitId(tid) => Some(tid.lookup(self.db.upcast()).container.into()),\n+                AttrDefId::TraitAliasId(taid) => Some(taid.lookup(self.db.upcast()).container.into()),\n                 AttrDefId::ImplId(iid) => Some(iid.lookup(self.db.upcast()).container.into()),\n                 AttrDefId::ExternBlockId(id) => Some(id.lookup(self.db.upcast()).container.into()),\n                 // These warnings should not explore macro definitions at all\n@@ -234,8 +235,8 @@ impl<'a> DeclValidator<'a> {\n         let pats_replacements = body\n             .pats\n             .iter()\n-            .filter_map(|(id, pat)| match pat {\n-                Pat::Bind { name, .. } => Some((id, name)),\n+            .filter_map(|(pat_id, pat)| match pat {\n+                Pat::Bind { id, .. } => Some((pat_id, &body.bindings[*id].name)),\n                 _ => None,\n             })\n             .filter_map(|(id, bind_name)| {"}, {"sha": "2e9066788cf627d9b685ec1ba3ebcdd8b4e9fff5", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,11 +5,11 @@\n use std::fmt;\n use std::sync::Arc;\n \n+use either::Either;\n use hir_def::lang_item::LangItem;\n use hir_def::{resolver::HasResolver, AdtId, AssocItemId, DefWithBodyId, HasModule};\n use hir_def::{ItemContainerId, Lookup};\n use hir_expand::name;\n-use itertools::Either;\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use typed_arena::Arena;\n@@ -84,7 +84,7 @@ impl ExprValidator {\n \n             match expr {\n                 Expr::Match { expr, arms } => {\n-                    self.validate_match(id, *expr, arms, db, self.infer.clone());\n+                    self.validate_match(id, *expr, arms, db);\n                 }\n                 Expr::Call { .. } | Expr::MethodCall { .. } => {\n                     self.validate_call(db, id, expr, &mut filter_map_next_checker);\n@@ -147,16 +147,15 @@ impl ExprValidator {\n \n     fn validate_match(\n         &mut self,\n-        id: ExprId,\n         match_expr: ExprId,\n+        scrutinee_expr: ExprId,\n         arms: &[MatchArm],\n         db: &dyn HirDatabase,\n-        infer: Arc<InferenceResult>,\n     ) {\n         let body = db.body(self.owner);\n \n-        let match_expr_ty = &infer[match_expr];\n-        if match_expr_ty.is_unknown() {\n+        let scrut_ty = &self.infer[scrutinee_expr];\n+        if scrut_ty.is_unknown() {\n             return;\n         }\n \n@@ -166,23 +165,23 @@ impl ExprValidator {\n         let mut m_arms = Vec::with_capacity(arms.len());\n         let mut has_lowering_errors = false;\n         for arm in arms {\n-            if let Some(pat_ty) = infer.type_of_pat.get(arm.pat) {\n+            if let Some(pat_ty) = self.infer.type_of_pat.get(arm.pat) {\n                 // We only include patterns whose type matches the type\n-                // of the match expression. If we had an InvalidMatchArmPattern\n+                // of the scrutinee expression. If we had an InvalidMatchArmPattern\n                 // diagnostic or similar we could raise that in an else\n                 // block here.\n                 //\n                 // When comparing the types, we also have to consider that rustc\n-                // will automatically de-reference the match expression type if\n+                // will automatically de-reference the scrutinee expression type if\n                 // necessary.\n                 //\n                 // FIXME we should use the type checker for this.\n-                if (pat_ty == match_expr_ty\n-                    || match_expr_ty\n+                if (pat_ty == scrut_ty\n+                    || scrut_ty\n                         .as_reference()\n                         .map(|(match_expr_ty, ..)| match_expr_ty == pat_ty)\n                         .unwrap_or(false))\n-                    && types_of_subpatterns_do_match(arm.pat, &body, &infer)\n+                    && types_of_subpatterns_do_match(arm.pat, &body, &self.infer)\n                 {\n                     // If we had a NotUsefulMatchArm diagnostic, we could\n                     // check the usefulness of each pattern as we added it\n@@ -206,16 +205,16 @@ impl ExprValidator {\n             return;\n         }\n \n-        let report = compute_match_usefulness(&cx, &m_arms, match_expr_ty);\n+        let report = compute_match_usefulness(&cx, &m_arms, scrut_ty);\n \n         // FIXME Report unreacheble arms\n         // https://github.com/rust-lang/rust/blob/f31622a50/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200\n \n         let witnesses = report.non_exhaustiveness_witnesses;\n         if !witnesses.is_empty() {\n             self.diagnostics.push(BodyValidationDiagnostic::MissingMatchArms {\n-                match_expr: id,\n-                uncovered_patterns: missing_match_arms(&cx, match_expr_ty, witnesses, arms),\n+                match_expr,\n+                uncovered_patterns: missing_match_arms(&cx, scrut_ty, witnesses, arms),\n             });\n         }\n     }\n@@ -379,7 +378,7 @@ fn missing_match_arms<'p>(\n     arms: &[MatchArm],\n ) -> String {\n     struct DisplayWitness<'a, 'p>(&'a DeconstructedPat<'p>, &'a MatchCheckCtx<'a, 'p>);\n-    impl<'a, 'p> fmt::Display for DisplayWitness<'a, 'p> {\n+    impl fmt::Display for DisplayWitness<'_, '_> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             let DisplayWitness(witness, cx) = *self;\n             let pat = witness.to_pat(cx);"}, {"sha": "859a37804ae7fa8b33b00864f616810f266dc10a", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -146,8 +146,9 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Leaf { subpatterns }\n             }\n \n-            hir_def::expr::Pat::Bind { ref name, subpat, .. } => {\n+            hir_def::expr::Pat::Bind { id, subpat, .. } => {\n                 let bm = self.infer.pat_binding_modes[&pat];\n+                let name = &self.body.bindings[id].name;\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n                     (BindingMode::Ref(_), _) => {"}, {"sha": "d25c0ccf00dcd6ed947fa573fb25f1b0062b5d17", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -94,8 +94,10 @@ fn walk_unsafe(\n                 unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }\n-        Expr::Unsafe { body: child } => {\n-            return walk_unsafe(db, infer, def, body, *child, true, unsafe_expr_cb);\n+        Expr::Unsafe { .. } => {\n+            return expr.walk_child_exprs(|child| {\n+                walk_unsafe(db, infer, def, body, child, true, unsafe_expr_cb);\n+            });\n         }\n         _ => {}\n     }"}, {"sha": "bd3eccfe43dab6d88df9362dadc46e18b291fa60", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 174, "deletions": 13, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,18 +5,19 @@\n use std::fmt::{self, Debug};\n \n use base_db::CrateId;\n-use chalk_ir::BoundVar;\n+use chalk_ir::{BoundVar, TyKind};\n use hir_def::{\n+    adt::VariantData,\n     body,\n     db::DefDatabase,\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n     lang_item::{LangItem, LangItemTarget},\n     path::{Path, PathKind},\n-    type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    HasModule, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    HasModule, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n@@ -25,14 +26,17 @@ use smallvec::SmallVec;\n \n use crate::{\n     db::HirDatabase,\n-    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n+    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx,\n+    layout::layout_of_ty,\n+    lt_from_placeholder_idx,\n     mapping::from_chalk,\n+    mir::pad16,\n     primitive, to_assoc_type_id,\n     utils::{self, generics},\n-    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n-    GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n-    OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar, Substitution, TraitRef,\n-    TraitRefExt, Ty, TyExt, TyKind, WhereClause,\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstScalar, ConstValue,\n+    DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives,\n+    MemoryMap, Mutability, OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar,\n+    Substitution, TraitRef, TraitRefExt, Ty, TyExt, WhereClause,\n };\n \n pub trait HirWrite: fmt::Write {\n@@ -362,20 +366,176 @@ impl HirDisplay for GenericArg {\n impl HirDisplay for Const {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         let data = self.interned();\n-        match data.value {\n+        match &data.value {\n             ConstValue::BoundVar(idx) => idx.hir_fmt(f),\n             ConstValue::InferenceVar(..) => write!(f, \"#c#\"),\n             ConstValue::Placeholder(idx) => {\n-                let id = from_placeholder_idx(f.db, idx);\n+                let id = from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.type_or_consts[id.local_id];\n                 write!(f, \"{}\", param_data.name().unwrap())\n             }\n-            ConstValue::Concrete(c) => write!(f, \"{}\", c.interned),\n+            ConstValue::Concrete(c) => match &c.interned {\n+                ConstScalar::Bytes(b, m) => render_const_scalar(f, &b, m, &data.ty),\n+                ConstScalar::Unknown => f.write_char('_'),\n+            },\n         }\n     }\n }\n \n+pub struct HexifiedConst(pub Const);\n+\n+impl HirDisplay for HexifiedConst {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n+        let data = &self.0.data(Interner);\n+        if let TyKind::Scalar(s) = data.ty.kind(Interner) {\n+            if matches!(s, Scalar::Int(_) | Scalar::Uint(_)) {\n+                if let ConstValue::Concrete(c) = &data.value {\n+                    if let ConstScalar::Bytes(b, m) = &c.interned {\n+                        let value = u128::from_le_bytes(pad16(b, false));\n+                        if value >= 10 {\n+                            render_const_scalar(f, &b, m, &data.ty)?;\n+                            return write!(f, \" ({:#X})\", value);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        self.0.hir_fmt(f)\n+    }\n+}\n+\n+fn render_const_scalar(\n+    f: &mut HirFormatter<'_>,\n+    b: &[u8],\n+    memory_map: &MemoryMap,\n+    ty: &Ty,\n+) -> Result<(), HirDisplayError> {\n+    match ty.kind(Interner) {\n+        chalk_ir::TyKind::Scalar(s) => match s {\n+            Scalar::Bool => write!(f, \"{}\", if b[0] == 0 { false } else { true }),\n+            Scalar::Char => {\n+                let x = u128::from_le_bytes(pad16(b, false)) as u32;\n+                let Ok(c) = char::try_from(x) else {\n+                    return f.write_str(\"<unicode-error>\");\n+                };\n+                write!(f, \"{c:?}\")\n+            }\n+            Scalar::Int(_) => {\n+                let x = i128::from_le_bytes(pad16(b, true));\n+                write!(f, \"{x}\")\n+            }\n+            Scalar::Uint(_) => {\n+                let x = u128::from_le_bytes(pad16(b, false));\n+                write!(f, \"{x}\")\n+            }\n+            Scalar::Float(fl) => match fl {\n+                chalk_ir::FloatTy::F32 => {\n+                    let x = f32::from_le_bytes(b.try_into().unwrap());\n+                    write!(f, \"{x:?}\")\n+                }\n+                chalk_ir::FloatTy::F64 => {\n+                    let x = f64::from_le_bytes(b.try_into().unwrap());\n+                    write!(f, \"{x:?}\")\n+                }\n+            },\n+        },\n+        chalk_ir::TyKind::Ref(_, _, t) => match t.kind(Interner) {\n+            chalk_ir::TyKind::Str => {\n+                let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());\n+                let bytes = memory_map.0.get(&addr).map(|x| &**x).unwrap_or(&[]);\n+                let s = std::str::from_utf8(bytes).unwrap_or(\"<utf8-error>\");\n+                write!(f, \"{s:?}\")\n+            }\n+            _ => f.write_str(\"<ref-not-supported>\"),\n+        },\n+        chalk_ir::TyKind::Tuple(_, subst) => {\n+            // FIXME: Remove this line. If the target data layout is independent\n+            // of the krate, the `db.target_data_layout` and its callers like `layout_of_ty` don't need\n+            // to get krate. Otherwise, we need to get krate from the final callers of the hir display\n+            // infrastructure and have it here as a field on `f`.\n+            let krate = *f.db.crate_graph().crates_in_topological_order().last().unwrap();\n+            let Ok(layout) = layout_of_ty(f.db, ty, krate) else {\n+                return f.write_str(\"<layout-error>\");\n+            };\n+            f.write_str(\"(\")?;\n+            let mut first = true;\n+            for (id, ty) in subst.iter(Interner).enumerate() {\n+                if first {\n+                    first = false;\n+                } else {\n+                    f.write_str(\", \")?;\n+                }\n+                let ty = ty.assert_ty_ref(Interner); // Tuple only has type argument\n+                let offset = layout.fields.offset(id).bytes_usize();\n+                let Ok(layout) = layout_of_ty(f.db, &ty, krate) else {\n+                    f.write_str(\"<layout-error>\")?;\n+                    continue;\n+                };\n+                let size = layout.size.bytes_usize();\n+                render_const_scalar(f, &b[offset..offset + size], memory_map, &ty)?;\n+            }\n+            f.write_str(\")\")\n+        }\n+        chalk_ir::TyKind::Adt(adt, subst) => match adt.0 {\n+            hir_def::AdtId::StructId(s) => {\n+                let data = f.db.struct_data(s);\n+                let Ok(layout) = f.db.layout_of_adt(adt.0, subst.clone()) else {\n+                    return f.write_str(\"<layout-error>\");\n+                };\n+                match data.variant_data.as_ref() {\n+                    VariantData::Record(fields) | VariantData::Tuple(fields) => {\n+                        let field_types = f.db.field_types(s.into());\n+                        let krate = adt.0.module(f.db.upcast()).krate();\n+                        let render_field = |f: &mut HirFormatter<'_>, id: LocalFieldId| {\n+                            let offset = layout\n+                                .fields\n+                                .offset(u32::from(id.into_raw()) as usize)\n+                                .bytes_usize();\n+                            let ty = field_types[id].clone().substitute(Interner, subst);\n+                            let Ok(layout) = layout_of_ty(f.db, &ty, krate) else {\n+                                return f.write_str(\"<layout-error>\");\n+                            };\n+                            let size = layout.size.bytes_usize();\n+                            render_const_scalar(f, &b[offset..offset + size], memory_map, &ty)\n+                        };\n+                        let mut it = fields.iter();\n+                        if matches!(data.variant_data.as_ref(), VariantData::Record(_)) {\n+                            write!(f, \"{} {{\", data.name)?;\n+                            if let Some((id, data)) = it.next() {\n+                                write!(f, \" {}: \", data.name)?;\n+                                render_field(f, id)?;\n+                            }\n+                            for (id, data) in it {\n+                                write!(f, \", {}: \", data.name)?;\n+                                render_field(f, id)?;\n+                            }\n+                            write!(f, \" }}\")?;\n+                        } else {\n+                            let mut it = it.map(|x| x.0);\n+                            write!(f, \"{}(\", data.name)?;\n+                            if let Some(id) = it.next() {\n+                                render_field(f, id)?;\n+                            }\n+                            for id in it {\n+                                write!(f, \", \")?;\n+                                render_field(f, id)?;\n+                            }\n+                            write!(f, \")\")?;\n+                        }\n+                        return Ok(());\n+                    }\n+                    VariantData::Unit => write!(f, \"{}\", data.name),\n+                }\n+            }\n+            hir_def::AdtId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name),\n+            hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n+        },\n+        chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n+        _ => f.write_str(\"<not-supported>\"),\n+    }\n+}\n+\n impl HirDisplay for BoundVar {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"?{}.{}\", self.debruijn.depth(), self.index)\n@@ -614,8 +774,9 @@ impl HirDisplay for Ty {\n                                     {\n                                         return true;\n                                     }\n-                                    if let Some(ConstValue::Concrete(c)) =\n-                                        parameter.constant(Interner).map(|x| x.data(Interner).value)\n+                                    if let Some(ConstValue::Concrete(c)) = parameter\n+                                        .constant(Interner)\n+                                        .map(|x| &x.data(Interner).value)\n                                     {\n                                         if c.interned == ConstScalar::Unknown {\n                                             return true;"}, {"sha": "7de5b4295fcc408e5392ab50e64d785d515b84f9", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 144, "deletions": 71, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -17,11 +17,12 @@ use std::ops::Index;\n use std::sync::Arc;\n \n use chalk_ir::{cast::Cast, ConstValue, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use either::Either;\n use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n-    expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n+    expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n     path::Path,\n@@ -30,10 +31,9 @@ use hir_def::{\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::name;\n-use itertools::Either;\n+use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::always;\n \n use crate::{\n@@ -66,8 +66,10 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n     let mut ctx = InferenceContext::new(db, def, &body, resolver);\n \n     match def {\n+        DefWithBodyId::FunctionId(f) => {\n+            ctx.collect_fn(f);\n+        }\n         DefWithBodyId::ConstId(c) => ctx.collect_const(&db.const_data(c)),\n-        DefWithBodyId::FunctionId(f) => ctx.collect_fn(f),\n         DefWithBodyId::StaticId(s) => ctx.collect_static(&db.static_data(s)),\n         DefWithBodyId::VariantId(v) => {\n             ctx.return_ty = TyBuilder::builtin(match db.enum_data(v.parent).variant_body_type() {\n@@ -144,44 +146,6 @@ impl Default for BindingMode {\n     }\n }\n \n-/// Used to generalize patterns and assignee expressions.\n-trait PatLike: Into<ExprOrPatId> + Copy {\n-    type BindingMode: Copy;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty;\n-}\n-\n-impl PatLike for ExprId {\n-    type BindingMode = ();\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        _: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_assignee_expr(id, expected_ty)\n-    }\n-}\n-\n-impl PatLike for PatId {\n-    type BindingMode = BindingMode;\n-\n-    fn infer(\n-        this: &mut InferenceContext<'_>,\n-        id: Self,\n-        expected_ty: &Ty,\n-        default_bm: Self::BindingMode,\n-    ) -> Ty {\n-        this.infer_pat(id, expected_ty, default_bm)\n-    }\n-}\n-\n #[derive(Debug)]\n pub(crate) struct InferOk<T> {\n     value: T,\n@@ -200,11 +164,45 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n-    NoSuchField { expr: ExprId },\n-    PrivateField { expr: ExprId, field: FieldId },\n-    PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n-    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n-    MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n+    NoSuchField {\n+        expr: ExprId,\n+    },\n+    PrivateField {\n+        expr: ExprId,\n+        field: FieldId,\n+    },\n+    PrivateAssocItem {\n+        id: ExprOrPatId,\n+        item: AssocItemId,\n+    },\n+    UnresolvedField {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        method_with_same_name_exists: bool,\n+    },\n+    UnresolvedMethodCall {\n+        expr: ExprId,\n+        receiver: Ty,\n+        name: Name,\n+        /// Contains the type the field resolves to\n+        field_with_same_name: Option<Ty>,\n+    },\n+    // FIXME: Make this proper\n+    BreakOutsideOfLoop {\n+        expr: ExprId,\n+        is_break: bool,\n+        bad_value_break: bool,\n+    },\n+    MismatchedArgCount {\n+        call_expr: ExprId,\n+        expected: usize,\n+        found: usize,\n+    },\n+    ExpectedFunction {\n+        call_expr: ExprId,\n+        found: Ty,\n+    },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -293,8 +291,10 @@ pub enum Adjust {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n+///\n+/// Mutability is `None` when we are not sure.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct OverloadedDeref(pub Mutability);\n+pub struct OverloadedDeref(pub Option<Mutability>);\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum AutoBorrow {\n@@ -354,7 +354,10 @@ pub struct InferenceResult {\n     /// **Note**: When a pattern type is resolved it may still contain\n     /// unresolved or missing subpatterns or subpatterns of mismatched types.\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n+    pub type_of_binding: ArenaMap<BindingId, Ty>,\n     pub type_of_rpit: ArenaMap<RpitId, Ty>,\n+    /// Type of the result of `.into_iter()` on the for. `ExprId` is the one of the whole for loop.\n+    pub type_of_for_iterator: FxHashMap<ExprId, Ty>,\n     type_mismatches: FxHashMap<ExprOrPatId, TypeMismatch>,\n     /// Interned common types to return references to.\n     standard_types: InternedStandardTypes,\n@@ -389,18 +392,15 @@ impl InferenceResult {\n     pub fn type_mismatch_for_pat(&self, pat: PatId) -> Option<&TypeMismatch> {\n         self.type_mismatches.get(&pat.into())\n     }\n+    pub fn type_mismatches(&self) -> impl Iterator<Item = (ExprOrPatId, &TypeMismatch)> {\n+        self.type_mismatches.iter().map(|(expr_or_pat, mismatch)| (*expr_or_pat, mismatch))\n+    }\n     pub fn expr_type_mismatches(&self) -> impl Iterator<Item = (ExprId, &TypeMismatch)> {\n         self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {\n             ExprOrPatId::ExprId(expr) => Some((expr, mismatch)),\n             _ => None,\n         })\n     }\n-    pub fn pat_type_mismatches(&self) -> impl Iterator<Item = (PatId, &TypeMismatch)> {\n-        self.type_mismatches.iter().filter_map(|(expr_or_pat, mismatch)| match *expr_or_pat {\n-            ExprOrPatId::PatId(pat) => Some((pat, mismatch)),\n-            _ => None,\n-        })\n-    }\n }\n \n impl Index<ExprId> for InferenceResult {\n@@ -419,6 +419,14 @@ impl Index<PatId> for InferenceResult {\n     }\n }\n \n+impl Index<BindingId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, b: BindingId) -> &Ty {\n+        self.type_of_binding.get(b).unwrap_or(&self.standard_types.unknown)\n+    }\n+}\n+\n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n pub(crate) struct InferenceContext<'a> {\n@@ -428,14 +436,19 @@ pub(crate) struct InferenceContext<'a> {\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n+    /// The traits in scope, disregarding block modules. This is used for caching purposes.\n+    traits_in_scope: FxHashSet<TraitId>,\n     pub(crate) result: InferenceResult,\n     /// The return type of the function being inferred, the closure or async block if we're\n     /// currently within one.\n     ///\n     /// We might consider using a nested inference context for checking\n-    /// closures, but currently this is the only field that will change there,\n-    /// so it doesn't make sense.\n+    /// closures so we can swap all shared things out at once.\n     return_ty: Ty,\n+    /// If `Some`, this stores coercion information for returned\n+    /// expressions. If `None`, this is in a context where return is\n+    /// inappropriate, such as a const expression.\n+    return_coercion: Option<CoerceMany>,\n     /// The resume type and the yield type, respectively, of the generator being inferred.\n     resume_yield_tys: Option<(Ty, Ty)>,\n     diverges: Diverges,\n@@ -447,7 +460,7 @@ struct BreakableContext {\n     /// Whether this context contains at least one break expression.\n     may_break: bool,\n     /// The coercion target of the context.\n-    coerce: CoerceMany,\n+    coerce: Option<CoerceMany>,\n     /// The optional label of the context.\n     label: Option<name::Name>,\n     kind: BreakableKind,\n@@ -503,16 +516,22 @@ impl<'a> InferenceContext<'a> {\n             trait_env,\n             return_ty: TyKind::Error.intern(Interner), // set in collect_* calls\n             resume_yield_tys: None,\n+            return_coercion: None,\n             db,\n             owner,\n             body,\n+            traits_in_scope: resolver.traits_in_scope(db.upcast()),\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n         }\n     }\n \n-    fn resolve_all(self) -> InferenceResult {\n+    // FIXME: This function should be private in module. It is currently only used in the consteval, since we need\n+    // `InferenceResult` in the middle of inference. See the fixme comment in `consteval::eval_to_const`. If you\n+    // used this function for another workaround, mention it here. If you really need this function and believe that\n+    // there is no problem in it being `pub(crate)`, remove this comment.\n+    pub(crate) fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n \n         table.fallback_if_possible();\n@@ -528,13 +547,46 @@ impl<'a> InferenceContext<'a> {\n         for ty in result.type_of_pat.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n-        for ty in result.type_of_rpit.iter_mut().map(|x| x.1) {\n+        for ty in result.type_of_binding.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n+        for ty in result.type_of_rpit.values_mut() {\n+            *ty = table.resolve_completely(ty.clone());\n+        }\n+        for ty in result.type_of_for_iterator.values_mut() {\n             *ty = table.resolve_completely(ty.clone());\n         }\n         for mismatch in result.type_mismatches.values_mut() {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n         }\n+        result.diagnostics.retain_mut(|diagnostic| {\n+            if let InferenceDiagnostic::ExpectedFunction { found: ty, .. }\n+            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. }\n+            | InferenceDiagnostic::UnresolvedMethodCall { receiver: ty, .. } = diagnostic\n+            {\n+                *ty = table.resolve_completely(ty.clone());\n+                // FIXME: Remove this when we are on par with rustc in terms of inference\n+                if ty.contains_unknown() {\n+                    return false;\n+                }\n+\n+                if let InferenceDiagnostic::UnresolvedMethodCall { field_with_same_name, .. } =\n+                    diagnostic\n+                {\n+                    let clear = if let Some(ty) = field_with_same_name {\n+                        *ty = table.resolve_completely(ty.clone());\n+                        ty.contains_unknown()\n+                    } else {\n+                        false\n+                    };\n+                    if clear {\n+                        *field_with_same_name = None;\n+                    }\n+                }\n+            }\n+            true\n+        });\n         for (_, subst) in result.method_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }\n@@ -580,7 +632,7 @@ impl<'a> InferenceContext<'a> {\n             let ty = self.insert_type_vars(ty);\n             let ty = self.normalize_associated_types_in(ty);\n \n-            self.infer_pat(*pat, &ty, BindingMode::default());\n+            self.infer_top_pat(*pat, &ty);\n         }\n         let error_ty = &TypeRef::Error;\n         let return_ty = if data.has_async_kw() {\n@@ -632,10 +684,19 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.return_ty = self.normalize_associated_types_in(return_ty);\n+        self.return_coercion = Some(CoerceMany::new(self.return_ty.clone()));\n     }\n \n     fn infer_body(&mut self) {\n-        self.infer_expr_coerce(self.body.body_expr, &Expectation::has_type(self.return_ty.clone()));\n+        match self.return_coercion {\n+            Some(_) => self.infer_return(self.body.body_expr),\n+            None => {\n+                _ = self.infer_expr_coerce(\n+                    self.body.body_expr,\n+                    &Expectation::has_type(self.return_ty.clone()),\n+                )\n+            }\n+        }\n     }\n \n     fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n@@ -662,12 +723,15 @@ impl<'a> InferenceContext<'a> {\n         self.result.type_of_pat.insert(pat, ty);\n     }\n \n+    fn write_binding_ty(&mut self, id: BindingId, ty: Ty) {\n+        self.result.type_of_binding.insert(id, ty);\n+    }\n+\n     fn push_diagnostic(&mut self, diagnostic: InferenceDiagnostic) {\n         self.result.diagnostics.push(diagnostic);\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // FIXME use right resolver for block\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let ty = ctx.lower_ty(type_ref);\n         let ty = self.insert_type_vars(ty);\n@@ -681,11 +745,9 @@ impl<'a> InferenceContext<'a> {\n     /// Replaces ConstScalar::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_const_vars_shallow(&mut self, c: Const) -> Const {\n         let data = c.data(Interner);\n-        match data.value {\n+        match &data.value {\n             ConstValue::Concrete(cc) => match cc.interned {\n-                hir_def::type_ref::ConstScalar::Unknown => {\n-                    self.table.new_const_var(data.ty.clone())\n-                }\n+                crate::ConstScalar::Unknown => self.table.new_const_var(data.ty.clone()),\n                 _ => c,\n             },\n             _ => c,\n@@ -785,12 +847,11 @@ impl<'a> InferenceContext<'a> {\n             Some(path) => path,\n             None => return (self.err_ty(), None),\n         };\n-        let resolver = &self.resolver;\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n-            match resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n@@ -811,7 +872,7 @@ impl<'a> InferenceContext<'a> {\n                 None => return (self.err_ty(), None),\n             }\n         } else {\n-            match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (self.err_ty(), None),\n             }\n@@ -866,7 +927,10 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME potentially resolve assoc type\n                 (self.err_ty(), None)\n             }\n-            TypeNs::AdtId(AdtId::EnumId(_)) | TypeNs::BuiltinType(_) | TypeNs::TraitId(_) => {\n+            TypeNs::AdtId(AdtId::EnumId(_))\n+            | TypeNs::BuiltinType(_)\n+            | TypeNs::TraitId(_)\n+            | TypeNs::TraitAliasId(_) => {\n                 // FIXME diagnostic\n                 (self.err_ty(), None)\n             }\n@@ -1018,6 +1082,15 @@ impl<'a> InferenceContext<'a> {\n         let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n+\n+    fn get_traits_in_scope(&self) -> Either<FxHashSet<TraitId>, &FxHashSet<TraitId>> {\n+        let mut b_traits = self.resolver.traits_in_scope_from_block_scopes().peekable();\n+        if b_traits.peek().is_some() {\n+            Either::Left(self.traits_in_scope.iter().copied().chain(b_traits).collect())\n+        } else {\n+            Either::Right(&self.traits_in_scope)\n+        }\n+    }\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we"}, {"sha": "48c91530266dfbcaa5c13e94848cdc4ebef54249", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -50,11 +50,44 @@ fn success(\n #[derive(Clone, Debug)]\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n+    final_ty: Option<Ty>,\n }\n \n impl CoerceMany {\n     pub(super) fn new(expected: Ty) -> Self {\n-        CoerceMany { expected_ty: expected }\n+        CoerceMany { expected_ty: expected, final_ty: None }\n+    }\n+\n+    /// Returns the \"expected type\" with which this coercion was\n+    /// constructed. This represents the \"downward propagated\" type\n+    /// that was given to us at the start of typing whatever construct\n+    /// we are typing (e.g., the match expression).\n+    ///\n+    /// Typically, this is used as the expected type when\n+    /// type-checking each of the alternative expressions whose types\n+    /// we are trying to merge.\n+    pub(super) fn expected_ty(&self) -> Ty {\n+        self.expected_ty.clone()\n+    }\n+\n+    /// Returns the current \"merged type\", representing our best-guess\n+    /// at the LUB of the expressions we've seen so far (if any). This\n+    /// isn't *final* until you call `self.complete()`, which will return\n+    /// the merged type.\n+    pub(super) fn merged_ty(&self) -> Ty {\n+        self.final_ty.clone().unwrap_or_else(|| self.expected_ty.clone())\n+    }\n+\n+    pub(super) fn complete(self, ctx: &mut InferenceContext<'_>) -> Ty {\n+        if let Some(final_ty) = self.final_ty {\n+            final_ty\n+        } else {\n+            ctx.result.standard_types.never.clone()\n+        }\n+    }\n+\n+    pub(super) fn coerce_forced_unit(&mut self, ctx: &mut InferenceContext<'_>) {\n+        self.coerce(ctx, None, &ctx.result.standard_types.unit.clone())\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -76,51 +109,46 @@ impl CoerceMany {\n         // Special case: two function types. Try to coerce both to\n         // pointers to have a chance at getting a match. See\n         // https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src/librustc_typeck/check/coercion.rs#L877-L916\n-        let sig = match (self.expected_ty.kind(Interner), expr_ty.kind(Interner)) {\n+        let sig = match (self.merged_ty().kind(Interner), expr_ty.kind(Interner)) {\n             (TyKind::FnDef(..) | TyKind::Closure(..), TyKind::FnDef(..) | TyKind::Closure(..)) => {\n                 // FIXME: we're ignoring safety here. To be more correct, if we have one FnDef and one Closure,\n                 // we should be coercing the closure to a fn pointer of the safety of the FnDef\n                 cov_mark::hit!(coerce_fn_reification);\n                 let sig =\n-                    self.expected_ty.callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n+                    self.merged_ty().callable_sig(ctx.db).expect(\"FnDef without callable sig\");\n                 Some(sig)\n             }\n             _ => None,\n         };\n         if let Some(sig) = sig {\n             let target_ty = TyKind::Function(sig.to_fn_ptr()).intern(Interner);\n-            let result1 = ctx.table.coerce_inner(self.expected_ty.clone(), &target_ty);\n+            let result1 = ctx.table.coerce_inner(self.merged_ty(), &target_ty);\n             let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n                 ctx.table.register_infer_ok(result1);\n                 ctx.table.register_infer_ok(result2);\n-                return self.expected_ty = target_ty;\n+                return self.final_ty = Some(target_ty);\n             }\n         }\n \n         // It might not seem like it, but order is important here: If the expected\n         // type is a type variable and the new one is `!`, trying it the other\n         // way around first would mean we make the type variable `!`, instead of\n         // just marking it as possibly diverging.\n-        if ctx.coerce(expr, &expr_ty, &self.expected_ty).is_ok() {\n-            /* self.expected_ty is already correct */\n-        } else if ctx.coerce(expr, &self.expected_ty, &expr_ty).is_ok() {\n-            self.expected_ty = expr_ty;\n+        if let Ok(res) = ctx.coerce(expr, &expr_ty, &self.merged_ty()) {\n+            self.final_ty = Some(res);\n+        } else if let Ok(res) = ctx.coerce(expr, &self.merged_ty(), &expr_ty) {\n+            self.final_ty = Some(res);\n         } else {\n             if let Some(id) = expr {\n                 ctx.result.type_mismatches.insert(\n                     id.into(),\n-                    TypeMismatch { expected: self.expected_ty.clone(), actual: expr_ty },\n+                    TypeMismatch { expected: self.merged_ty().clone(), actual: expr_ty.clone() },\n                 );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n-            /* self.expected_ty is already correct */\n         }\n     }\n-\n-    pub(super) fn complete(self) -> Ty {\n-        self.expected_ty\n-    }\n }\n \n pub fn could_coerce(\n@@ -665,7 +693,7 @@ pub(super) fn auto_deref_adjust_steps(autoderef: &Autoderef<'_, '_>) -> Vec<Adju\n         .iter()\n         .map(|(kind, _source)| match kind {\n             // We do not know what kind of deref we require at this point yet\n-            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+            AutoderefKind::Overloaded => Some(OverloadedDeref(None)),\n             AutoderefKind::Builtin => None,\n         })\n         .zip(targets)"}, {"sha": "535189ff0288bd039b6edbd20cfe72c47a7d23fa", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 491, "deletions": 285, "changes": 776, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -15,7 +15,6 @@ use hir_def::{\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n-    resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n use hir_expand::name::{name, Name};\n@@ -25,7 +24,9 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n+    infer::{\n+        coerce::CoerceMany, find_continuable, pat::contains_explicit_ref_binding, BreakableKind,\n+    },\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -39,8 +40,8 @@ use crate::{\n };\n \n use super::{\n-    coerce::auto_deref_adjust_steps, find_breakable, BindingMode, BreakableContext, Diverges,\n-    Expectation, InferenceContext, InferenceDiagnostic, TypeMismatch,\n+    coerce::auto_deref_adjust_steps, find_breakable, BreakableContext, Diverges, Expectation,\n+    InferenceContext, InferenceDiagnostic, TypeMismatch,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -58,6 +59,10 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    pub(crate) fn infer_expr_no_expect(&mut self, tgt_expr: ExprId) -> Ty {\n+        self.infer_expr_inner(tgt_expr, &Expectation::None)\n+    }\n+\n     /// Infer type of expression with possibly implicit coerce to the expected type.\n     /// Return the type after possible coercion.\n     pub(super) fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n@@ -78,14 +83,38 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    pub(super) fn infer_expr_coerce_never(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(expr, expected);\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            if let Some(adjustments) = self.result.expr_adjustments.get(&expr) {\n+                return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &**adjustments {\n+                    target.clone()\n+                } else {\n+                    self.err_ty()\n+                };\n+            }\n+\n+            let adj_ty = self.table.new_type_var();\n+            self.write_expr_adj(\n+                expr,\n+                vec![Adjustment { kind: Adjust::NeverToAny, target: adj_ty.clone() }],\n+            );\n+            adj_ty\n+        } else {\n+            ty\n+        }\n+    }\n+\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         self.db.unwind_if_cancelled();\n \n         let ty = match &self.body[tgt_expr] {\n             Expr::Missing => self.err_ty(),\n             &Expr::If { condition, then_branch, else_branch } => {\n                 let expected = &expected.adjust_for_branches(&mut self.table);\n-                self.infer_expr(\n+                self.infer_expr_coerce_never(\n                     condition,\n                     &Expectation::HasType(self.result.standard_types.bool_.clone()),\n                 );\n@@ -97,59 +126,39 @@ impl<'a> InferenceContext<'a> {\n                 both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n                 coerce.coerce(self, Some(then_branch), &then_ty);\n-                let else_ty = match else_branch {\n-                    Some(else_branch) => self.infer_expr_inner(else_branch, expected),\n-                    None => TyBuilder::unit(),\n-                };\n+                match else_branch {\n+                    Some(else_branch) => {\n+                        let else_ty = self.infer_expr_inner(else_branch, expected);\n+                        coerce.coerce(self, Some(else_branch), &else_ty);\n+                    }\n+                    None => {\n+                        coerce.coerce_forced_unit(self);\n+                    }\n+                }\n                 both_arms_diverge &= self.diverges;\n-                // FIXME: create a synthetic `else {}` so we have something to refer to here instead of None?\n-                coerce.coerce(self, else_branch, &else_ty);\n \n                 self.diverges = condition_diverges | both_arms_diverge;\n \n-                coerce.complete()\n+                coerce.complete(self)\n             }\n             &Expr::Let { pat, expr } => {\n                 let input_ty = self.infer_expr(expr, &Expectation::none());\n-                self.infer_pat(pat, &input_ty, BindingMode::default());\n+                self.infer_top_pat(pat, &input_ty);\n                 self.result.standard_types.bool_.clone()\n             }\n             Expr::Block { statements, tail, label, id: _ } => {\n-                let old_resolver = mem::replace(\n-                    &mut self.resolver,\n-                    resolver_for_expr(self.db.upcast(), self.owner, tgt_expr),\n-                );\n-                let ty = match label {\n-                    Some(_) => {\n-                        let break_ty = self.table.new_type_var();\n-                        let (breaks, ty) = self.with_breakable_ctx(\n-                            BreakableKind::Block,\n-                            break_ty.clone(),\n-                            *label,\n-                            |this| {\n-                                this.infer_block(\n-                                    tgt_expr,\n-                                    statements,\n-                                    *tail,\n-                                    &Expectation::has_type(break_ty),\n-                                )\n-                            },\n-                        );\n-                        breaks.unwrap_or(ty)\n-                    }\n-                    None => self.infer_block(tgt_expr, statements, *tail, expected),\n-                };\n-                self.resolver = old_resolver;\n-                ty\n+                self.infer_block(tgt_expr, statements, *tail, *label, expected)\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.infer_block(tgt_expr, statements, *tail, None, expected)\n             }\n-            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n-            Expr::Const { body } => {\n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                    this.infer_expr(*body, expected)\n+            Expr::Const { id: _, statements, tail } => {\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+                    this.infer_block(tgt_expr, statements, *tail, None, expected)\n                 })\n                 .1\n             }\n-            Expr::TryBlock { body } => {\n+            Expr::TryBlock { id: _, statements, tail } => {\n                 // The type that is returned from the try block\n                 let try_ty = self.table.new_type_var();\n                 if let Some(ty) = expected.only_has_type(&mut self.table) {\n@@ -160,28 +169,41 @@ impl<'a> InferenceContext<'a> {\n                 let ok_ty =\n                     self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n-                self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n-                    this.infer_expr(*body, &Expectation::has_type(ok_ty));\n-                });\n-\n+                self.infer_block(\n+                    tgt_expr,\n+                    statements,\n+                    *tail,\n+                    None,\n+                    &Expectation::has_type(ok_ty.clone()),\n+                );\n                 try_ty\n             }\n-            Expr::Async { body } => {\n+            Expr::Async { id: _, statements, tail } => {\n                 let ret_ty = self.table.new_type_var();\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n \n                 let (_, inner_ty) =\n-                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                    self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+                        this.infer_block(\n+                            tgt_expr,\n+                            statements,\n+                            *tail,\n+                            None,\n+                            &Expectation::has_type(ret_ty),\n+                        )\n                     });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n \n                 // Use the first type parameter as the output type of future.\n                 // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n-                let impl_trait_id = crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                let impl_trait_id =\n+                    crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, tgt_expr);\n                 let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n@@ -191,7 +213,7 @@ impl<'a> InferenceContext<'a> {\n                 // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n-                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                    self.with_breakable_ctx(BreakableKind::Loop, Some(ty), label, |this| {\n                         this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n@@ -204,7 +226,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(\n                         condition,\n                         &Expectation::HasType(this.result.standard_types.bool_.clone()),\n@@ -220,11 +242,13 @@ impl<'a> InferenceContext<'a> {\n                 let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let into_iter_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n-                let pat_ty =\n-                    self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n+                let pat_ty = self\n+                    .resolve_associated_type(into_iter_ty.clone(), self.resolve_iterator_item());\n+\n+                self.result.type_of_for_iterator.insert(tgt_expr, into_iter_ty);\n \n-                self.infer_pat(pat, &pat_ty, BindingMode::default());\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.infer_top_pat(pat, &pat_ty);\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n@@ -298,20 +322,24 @@ impl<'a> InferenceContext<'a> {\n \n                 // Now go through the argument patterns\n                 for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n-                    self.infer_pat(*arg_pat, &arg_ty, BindingMode::default());\n+                    self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n \n+                // FIXME: lift these out into a struct\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n+                let prev_ret_coercion =\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n-                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n+                    this.infer_return(*body);\n                 });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n+                self.return_coercion = prev_ret_coercion;\n                 self.resume_yield_tys = prev_resume_yield_tys;\n \n                 ty\n@@ -348,7 +376,13 @@ impl<'a> InferenceContext<'a> {\n                         }\n                         (params, ret_ty)\n                     }\n-                    None => (Vec::new(), self.err_ty()), // FIXME diagnostic\n+                    None => {\n+                        self.result.diagnostics.push(InferenceDiagnostic::ExpectedFunction {\n+                            call_expr: tgt_expr,\n+                            found: callee_ty.clone(),\n+                        });\n+                        (Vec::new(), self.err_ty())\n+                    }\n                 };\n                 let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n@@ -381,92 +415,109 @@ impl<'a> InferenceContext<'a> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let expected = expected.adjust_for_branches(&mut self.table);\n-\n-                let result_ty = if arms.is_empty() {\n+                if arms.is_empty() {\n+                    self.diverges = Diverges::Always;\n                     self.result.standard_types.never.clone()\n                 } else {\n-                    expected.coercion_target_type(&mut self.table)\n-                };\n-                let mut coerce = CoerceMany::new(result_ty);\n-\n-                let matchee_diverges = self.diverges;\n-                let mut all_arms_diverge = Diverges::Always;\n-\n-                for arm in arms.iter() {\n-                    self.diverges = Diverges::Maybe;\n-                    let _pat_ty = self.infer_pat(arm.pat, &input_ty, BindingMode::default());\n-                    if let Some(guard_expr) = arm.guard {\n-                        self.infer_expr(\n-                            guard_expr,\n-                            &Expectation::HasType(self.result.standard_types.bool_.clone()),\n-                        );\n+                    let matchee_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                    let mut all_arms_diverge = Diverges::Always;\n+                    for arm in arms.iter() {\n+                        let input_ty = self.resolve_ty_shallow(&input_ty);\n+                        self.infer_top_pat(arm.pat, &input_ty);\n                     }\n \n-                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n-                    all_arms_diverge &= self.diverges;\n-                    coerce.coerce(self, Some(arm.expr), &arm_ty);\n-                }\n+                    let expected = expected.adjust_for_branches(&mut self.table);\n+                    let result_ty = match &expected {\n+                        // We don't coerce to `()` so that if the match expression is a\n+                        // statement it's branches can have any consistent type.\n+                        Expectation::HasType(ty) if *ty != self.result.standard_types.unit => {\n+                            ty.clone()\n+                        }\n+                        _ => self.table.new_type_var(),\n+                    };\n+                    let mut coerce = CoerceMany::new(result_ty);\n+\n+                    for arm in arms.iter() {\n+                        if let Some(guard_expr) = arm.guard {\n+                            self.diverges = Diverges::Maybe;\n+                            self.infer_expr_coerce_never(\n+                                guard_expr,\n+                                &Expectation::HasType(self.result.standard_types.bool_.clone()),\n+                            );\n+                        }\n+                        self.diverges = Diverges::Maybe;\n+\n+                        let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                        all_arms_diverge &= self.diverges;\n+                        coerce.coerce(self, Some(arm.expr), &arm_ty);\n+                    }\n \n-                self.diverges = matchee_diverges | all_arms_diverge;\n+                    self.diverges = matchee_diverges | all_arms_diverge;\n \n-                coerce.complete()\n+                    coerce.complete(self)\n+                }\n             }\n             Expr::Path(p) => {\n-                // FIXME this could be more efficient...\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n-                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n+                let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, tgt_expr);\n+                let ty = self.infer_path(p, tgt_expr.into()).unwrap_or_else(|| self.err_ty());\n+                self.resolver.reset_to_guard(g);\n+                ty\n             }\n             Expr::Continue { label } => {\n                 if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                         is_break: false,\n+                        bad_value_break: false,\n                     });\n                 };\n                 self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n-                    self.infer_expr(expr, &Expectation::none())\n+                    let opt_coerce_to = match find_breakable(&mut self.breakables, label.as_ref()) {\n+                        Some(ctxt) => match &ctxt.coerce {\n+                            Some(coerce) => coerce.expected_ty(),\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                                    expr: tgt_expr,\n+                                    is_break: true,\n+                                    bad_value_break: true,\n+                                });\n+                                self.err_ty()\n+                            }\n+                        },\n+                        None => self.err_ty(),\n+                    };\n+                    self.infer_expr_inner(expr, &Expectation::HasType(opt_coerce_to))\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 match find_breakable(&mut self.breakables, label.as_ref()) {\n-                    Some(ctxt) => {\n-                        // avoiding the borrowck\n-                        let mut coerce = mem::replace(\n-                            &mut ctxt.coerce,\n-                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n-                        );\n-\n-                        // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                        coerce.coerce(self, *expr, &val_ty);\n-\n-                        let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n-                            .expect(\"breakable stack changed during coercion\");\n-                        ctxt.coerce = coerce;\n-                        ctxt.may_break = true;\n-                    }\n+                    Some(ctxt) => match ctxt.coerce.take() {\n+                        Some(mut coerce) => {\n+                            coerce.coerce(self, *expr, &val_ty);\n+\n+                            // Avoiding borrowck\n+                            let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                                .expect(\"breakable stack changed during coercion\");\n+                            ctxt.may_break = true;\n+                            ctxt.coerce = Some(coerce);\n+                        }\n+                        None => ctxt.may_break = true,\n+                    },\n                     None => {\n                         self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                             expr: tgt_expr,\n                             is_break: true,\n+                            bad_value_break: false,\n                         });\n                     }\n                 }\n                 self.result.standard_types.never.clone()\n             }\n-            Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n-                } else {\n-                    let unit = TyBuilder::unit();\n-                    let _ = self.coerce(Some(tgt_expr), &unit, &self.return_ty.clone());\n-                }\n-                self.result.standard_types.never.clone()\n-            }\n+            &Expr::Return { expr } => self.infer_expr_return(expr),\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n                     if let Some(expr) = expr {\n@@ -483,7 +534,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Yeet { expr } => {\n                 if let &Some(expr) = expr {\n-                    self.infer_expr_inner(expr, &Expectation::None);\n+                    self.infer_expr_no_expect(expr);\n                 }\n                 self.result.standard_types.never.clone()\n             }\n@@ -524,71 +575,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 ty\n             }\n-            Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-\n-                let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n-                let mut private_field = None;\n-                let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n-                    let (field_id, parameters) = match derefed_ty.kind(Interner) {\n-                        TyKind::Tuple(_, substs) => {\n-                            return name.as_tuple_index().and_then(|idx| {\n-                                substs\n-                                    .as_slice(Interner)\n-                                    .get(idx)\n-                                    .map(|a| a.assert_ty_ref(Interner))\n-                                    .cloned()\n-                            });\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n-                            let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*s).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n-                            let local_id = self.db.union_data(*u).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*u).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        _ => return None,\n-                    };\n-                    let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n-                        .is_visible_from(self.db.upcast(), self.resolver.module());\n-                    if !is_visible {\n-                        if private_field.is_none() {\n-                            private_field = Some(field_id);\n-                        }\n-                        return None;\n-                    }\n-                    // can't have `write_field_resolution` here because `self.table` is borrowed :(\n-                    self.result.field_resolutions.insert(tgt_expr, field_id);\n-                    let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n-                        .clone()\n-                        .substitute(Interner, &parameters);\n-                    Some(ty)\n-                });\n-                let ty = match ty {\n-                    Some(ty) => {\n-                        let adjustments = auto_deref_adjust_steps(&autoderef);\n-                        self.write_expr_adj(*expr, adjustments);\n-                        let ty = self.insert_type_vars(ty);\n-                        let ty = self.normalize_associated_types_in(ty);\n-                        ty\n-                    }\n-                    _ => {\n-                        // Write down the first private field resolution if we found no field\n-                        // This aids IDE features for private fields like goto def\n-                        if let Some(field) = private_field {\n-                            self.result.field_resolutions.insert(tgt_expr, field);\n-                            self.result\n-                                .diagnostics\n-                                .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n-                        }\n-                        self.err_ty()\n-                    }\n-                };\n-                ty\n-            }\n+            Expr::Field { expr, name } => self.infer_field_access(tgt_expr, *expr, name),\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n@@ -611,7 +598,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation\n-                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::None);\n+                let _inner_ty = self.infer_expr_no_expect(*expr);\n                 // FIXME check the cast...\n                 cast_ty\n             }\n@@ -807,49 +794,7 @@ impl<'a> InferenceContext<'a> {\n \n                 TyKind::Tuple(tys.len(), Substitution::from_iter(Interner, tys)).intern(Interner)\n             }\n-            Expr::Array(array) => {\n-                let elem_ty =\n-                    match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n-                        Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n-                        _ => self.table.new_type_var(),\n-                    };\n-                let mut coerce = CoerceMany::new(elem_ty.clone());\n-\n-                let expected = Expectation::has_type(elem_ty.clone());\n-                let len = match array {\n-                    Array::ElementList { elements, .. } => {\n-                        for &expr in elements.iter() {\n-                            let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n-                            coerce.coerce(self, Some(expr), &cur_elem_ty);\n-                        }\n-                        consteval::usize_const(Some(elements.len() as u128))\n-                    }\n-                    &Array::Repeat { initializer, repeat } => {\n-                        self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n-                        self.infer_expr(\n-                            repeat,\n-                            &Expectation::HasType(\n-                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n-                            ),\n-                        );\n-\n-                        if let Some(g_def) = self.owner.as_generic_def_id() {\n-                            let generics = generics(self.db.upcast(), g_def);\n-                            consteval::eval_to_const(\n-                                repeat,\n-                                ParamLoweringMode::Placeholder,\n-                                self,\n-                                || generics,\n-                                DebruijnIndex::INNERMOST,\n-                            )\n-                        } else {\n-                            consteval::usize_const(None)\n-                        }\n-                    }\n-                };\n-\n-                TyKind::Array(coerce.complete(), len).intern(Interner)\n-            }\n+            Expr::Array(array) => self.infer_expr_array(array, expected),\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => self.result.standard_types.bool_.clone(),\n                 Literal::String(..) => {\n@@ -859,7 +804,11 @@ impl<'a> InferenceContext<'a> {\n                 Literal::ByteString(bs) => {\n                     let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n \n-                    let len = consteval::usize_const(Some(bs.len() as u128));\n+                    let len = consteval::usize_const(\n+                        self.db,\n+                        Some(bs.len() as u128),\n+                        self.resolver.krate(),\n+                    );\n \n                     let array_type = TyKind::Array(byte_type, len).intern(Interner);\n                     TyKind::Ref(Mutability::Not, static_lifetime(), array_type).intern(Interner)\n@@ -904,6 +853,97 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    fn infer_expr_array(\n+        &mut self,\n+        array: &Array,\n+        expected: &Expectation,\n+    ) -> chalk_ir::Ty<Interner> {\n+        let elem_ty = match expected.to_option(&mut self.table).as_ref().map(|t| t.kind(Interner)) {\n+            Some(TyKind::Array(st, _) | TyKind::Slice(st)) => st.clone(),\n+            _ => self.table.new_type_var(),\n+        };\n+\n+        let krate = self.resolver.krate();\n+\n+        let expected = Expectation::has_type(elem_ty.clone());\n+        let (elem_ty, len) = match array {\n+            Array::ElementList { elements, .. } if elements.is_empty() => {\n+                (elem_ty, consteval::usize_const(self.db, Some(0), krate))\n+            }\n+            Array::ElementList { elements, .. } => {\n+                let mut coerce = CoerceMany::new(elem_ty.clone());\n+                for &expr in elements.iter() {\n+                    let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n+                    coerce.coerce(self, Some(expr), &cur_elem_ty);\n+                }\n+                (\n+                    coerce.complete(self),\n+                    consteval::usize_const(self.db, Some(elements.len() as u128), krate),\n+                )\n+            }\n+            &Array::Repeat { initializer, repeat } => {\n+                self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty.clone()));\n+                self.infer_expr(\n+                    repeat,\n+                    &Expectation::HasType(\n+                        TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(Interner),\n+                    ),\n+                );\n+\n+                (\n+                    elem_ty,\n+                    if let Some(g_def) = self.owner.as_generic_def_id() {\n+                        let generics = generics(self.db.upcast(), g_def);\n+                        consteval::eval_to_const(\n+                            repeat,\n+                            ParamLoweringMode::Placeholder,\n+                            self,\n+                            || generics,\n+                            DebruijnIndex::INNERMOST,\n+                        )\n+                    } else {\n+                        consteval::usize_const(self.db, None, krate)\n+                    },\n+                )\n+            }\n+        };\n+\n+        TyKind::Array(elem_ty, len).intern(Interner)\n+    }\n+\n+    pub(super) fn infer_return(&mut self, expr: ExprId) {\n+        let ret_ty = self\n+            .return_coercion\n+            .as_mut()\n+            .expect(\"infer_return called outside function body\")\n+            .expected_ty();\n+        let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty));\n+        let mut coerce_many = self.return_coercion.take().unwrap();\n+        coerce_many.coerce(self, Some(expr), &return_expr_ty);\n+        self.return_coercion = Some(coerce_many);\n+    }\n+\n+    fn infer_expr_return(&mut self, expr: Option<ExprId>) -> Ty {\n+        match self.return_coercion {\n+            Some(_) => {\n+                if let Some(expr) = expr {\n+                    self.infer_return(expr);\n+                } else {\n+                    let mut coerce = self.return_coercion.take().unwrap();\n+                    coerce.coerce_forced_unit(self);\n+                    self.return_coercion = Some(coerce);\n+                }\n+            }\n+            None => {\n+                // FIXME: diagnose return outside of function\n+                if let Some(expr) = expr {\n+                    self.infer_expr_no_expect(expr);\n+                }\n+            }\n+        }\n+        self.result.standard_types.never.clone()\n+    }\n+\n     fn infer_expr_box(&mut self, inner_expr: ExprId, expected: &Expectation) -> Ty {\n         if let Some(box_id) = self.resolve_boxed_box() {\n             let table = &mut self.table;\n@@ -982,8 +1022,11 @@ impl<'a> InferenceContext<'a> {\n                     // type and length). This should not be just an error type,\n                     // because we are to compute the unifiability of this type and\n                     // `rhs_ty` in the end of this function to issue type mismatches.\n-                    _ => TyKind::Array(self.err_ty(), crate::consteval::usize_const(None))\n-                        .intern(Interner),\n+                    _ => TyKind::Array(\n+                        self.err_ty(),\n+                        crate::consteval::usize_const(self.db, None, self.resolver.krate()),\n+                    )\n+                    .intern(Interner),\n                 }\n             }\n             Expr::RecordLit { path, fields, .. } => {\n@@ -1123,65 +1166,211 @@ impl<'a> InferenceContext<'a> {\n         expr: ExprId,\n         statements: &[Statement],\n         tail: Option<ExprId>,\n+        label: Option<LabelId>,\n         expected: &Expectation,\n     ) -> Ty {\n-        for stmt in statements {\n-            match stmt {\n-                Statement::Let { pat, type_ref, initializer, else_branch } => {\n-                    let decl_ty = type_ref\n-                        .as_ref()\n-                        .map(|tr| self.make_ty(tr))\n-                        .unwrap_or_else(|| self.err_ty());\n-\n-                    // Always use the declared type when specified\n-                    let mut ty = decl_ty.clone();\n-\n-                    if let Some(expr) = initializer {\n-                        let actual_ty =\n-                            self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n-                        if decl_ty.is_unknown() {\n-                            ty = actual_ty;\n+        let coerce_ty = expected.coercion_target_type(&mut self.table);\n+        let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, expr);\n+\n+        let (break_ty, ty) =\n+            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n+                for stmt in statements {\n+                    match stmt {\n+                        Statement::Let { pat, type_ref, initializer, else_branch } => {\n+                            let decl_ty = type_ref\n+                                .as_ref()\n+                                .map(|tr| this.make_ty(tr))\n+                                .unwrap_or_else(|| this.table.new_type_var());\n+\n+                            let ty = if let Some(expr) = initializer {\n+                                let ty = if contains_explicit_ref_binding(&this.body, *pat) {\n+                                    this.infer_expr(*expr, &Expectation::has_type(decl_ty.clone()))\n+                                } else {\n+                                    this.infer_expr_coerce(\n+                                        *expr,\n+                                        &Expectation::has_type(decl_ty.clone()),\n+                                    )\n+                                };\n+                                if type_ref.is_some() {\n+                                    decl_ty\n+                                } else {\n+                                    ty\n+                                }\n+                            } else {\n+                                decl_ty\n+                            };\n+\n+                            this.infer_top_pat(*pat, &ty);\n+\n+                            if let Some(expr) = else_branch {\n+                                let previous_diverges =\n+                                    mem::replace(&mut this.diverges, Diverges::Maybe);\n+                                this.infer_expr_coerce(\n+                                    *expr,\n+                                    &Expectation::HasType(this.result.standard_types.never.clone()),\n+                                );\n+                                this.diverges = previous_diverges;\n+                            }\n+                        }\n+                        &Statement::Expr { expr, has_semi } => {\n+                            if has_semi {\n+                                this.infer_expr(expr, &Expectation::none());\n+                            } else {\n+                                this.infer_expr_coerce(\n+                                    expr,\n+                                    &Expectation::HasType(this.result.standard_types.unit.clone()),\n+                                );\n+                            }\n                         }\n                     }\n+                }\n \n-                    if let Some(expr) = else_branch {\n-                        self.infer_expr_coerce(\n-                            *expr,\n-                            &Expectation::HasType(self.result.standard_types.never.clone()),\n-                        );\n+                // FIXME: This should make use of the breakable CoerceMany\n+                if let Some(expr) = tail {\n+                    this.infer_expr_coerce(expr, expected)\n+                } else {\n+                    // Citing rustc: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    if this.diverges.is_always() {\n+                        // we don't even make an attempt at coercion\n+                        this.table.new_maybe_never_var()\n+                    } else if let Some(t) = expected.only_has_type(&mut this.table) {\n+                        if this\n+                            .coerce(Some(expr), &this.result.standard_types.unit.clone(), &t)\n+                            .is_err()\n+                        {\n+                            this.result.type_mismatches.insert(\n+                                expr.into(),\n+                                TypeMismatch {\n+                                    expected: t.clone(),\n+                                    actual: this.result.standard_types.unit.clone(),\n+                                },\n+                            );\n+                        }\n+                        t\n+                    } else {\n+                        this.result.standard_types.unit.clone()\n                     }\n+                }\n+            });\n+        self.resolver.reset_to_guard(g);\n+\n+        break_ty.unwrap_or(ty)\n+    }\n \n-                    self.infer_pat(*pat, &ty, BindingMode::default());\n+    fn lookup_field(\n+        &mut self,\n+        receiver_ty: &Ty,\n+        name: &Name,\n+    ) -> Option<(Ty, Option<FieldId>, Vec<Adjustment>, bool)> {\n+        let mut autoderef = Autoderef::new(&mut self.table, receiver_ty.clone());\n+        let mut private_field = None;\n+        let res = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n+            let (field_id, parameters) = match derefed_ty.kind(Interner) {\n+                TyKind::Tuple(_, substs) => {\n+                    return name.as_tuple_index().and_then(|idx| {\n+                        substs\n+                            .as_slice(Interner)\n+                            .get(idx)\n+                            .map(|a| a.assert_ty_ref(Interner))\n+                            .cloned()\n+                            .map(|ty| (None, ty))\n+                    });\n                 }\n-                Statement::Expr { expr, .. } => {\n-                    self.infer_expr(*expr, &Expectation::none());\n+                TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n+                    let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*s).into(), local_id };\n+                    (field, parameters.clone())\n                 }\n+                TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n+                    let local_id = self.db.union_data(*u).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*u).into(), local_id };\n+                    (field, parameters.clone())\n+                }\n+                _ => return None,\n+            };\n+            let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                .is_visible_from(self.db.upcast(), self.resolver.module());\n+            if !is_visible {\n+                if private_field.is_none() {\n+                    private_field = Some((field_id, parameters));\n+                }\n+                return None;\n             }\n-        }\n+            let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                .clone()\n+                .substitute(Interner, &parameters);\n+            Some((Some(field_id), ty))\n+        });\n \n-        if let Some(expr) = tail {\n-            self.infer_expr_coerce(expr, expected)\n-        } else {\n-            // Citing rustc: if there is no explicit tail expression,\n-            // that is typically equivalent to a tail expression\n-            // of `()` -- except if the block diverges. In that\n-            // case, there is no value supplied from the tail\n-            // expression (assuming there are no other breaks,\n-            // this implies that the type of the block will be\n-            // `!`).\n-            if self.diverges.is_always() {\n-                // we don't even make an attempt at coercion\n-                self.table.new_maybe_never_var()\n-            } else if let Some(t) = expected.only_has_type(&mut self.table) {\n-                if self.coerce(Some(expr), &TyBuilder::unit(), &t).is_err() {\n-                    self.result.type_mismatches.insert(\n-                        expr.into(),\n-                        TypeMismatch { expected: t.clone(), actual: TyBuilder::unit() },\n-                    );\n+        Some(match res {\n+            Some((field_id, ty)) => {\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, field_id, adjustments, true)\n+            }\n+            None => {\n+                let (field_id, subst) = private_field?;\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                    .clone()\n+                    .substitute(Interner, &subst);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+\n+                (ty, Some(field_id), adjustments, false)\n+            }\n+        })\n+    }\n+\n+    fn infer_field_access(&mut self, tgt_expr: ExprId, receiver: ExprId, name: &Name) -> Ty {\n+        let receiver_ty = self.infer_expr_inner(receiver, &Expectation::none());\n+        match self.lookup_field(&receiver_ty, name) {\n+            Some((ty, field_id, adjustments, is_public)) => {\n+                self.write_expr_adj(receiver, adjustments);\n+                if let Some(field_id) = field_id {\n+                    self.result.field_resolutions.insert(tgt_expr, field_id);\n                 }\n-                t\n-            } else {\n-                TyBuilder::unit()\n+                if !is_public {\n+                    if let Some(field) = field_id {\n+                        // FIXME: Merge this diagnostic into UnresolvedField?\n+                        self.result\n+                            .diagnostics\n+                            .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                    }\n+                }\n+                ty\n+            }\n+            None => {\n+                // no field found,\n+                let method_with_same_name_exists = {\n+                    self.get_traits_in_scope();\n+\n+                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n+                    method_resolution::lookup_method(\n+                        self.db,\n+                        &canonicalized_receiver.value,\n+                        self.trait_env.clone(),\n+                        self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n+                        VisibleFromModule::Filter(self.resolver.module()),\n+                        name,\n+                    )\n+                    .is_some()\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedField {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty,\n+                    name: name.clone(),\n+                    method_with_same_name_exists,\n+                });\n+                self.err_ty()\n             }\n         }\n     }\n@@ -1198,13 +1387,11 @@ impl<'a> InferenceContext<'a> {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n         let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n \n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n-\n         let resolved = method_resolution::lookup_method(\n             self.db,\n             &canonicalized_receiver.value,\n             self.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );\n@@ -1223,11 +1410,30 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 (ty, self.db.value_ty(func.into()), substs)\n             }\n-            None => (\n-                receiver_ty,\n-                Binders::empty(Interner, self.err_ty()),\n-                Substitution::empty(Interner),\n-            ),\n+            None => {\n+                let field_with_same_name_exists = match self.lookup_field(&receiver_ty, method_name)\n+                {\n+                    Some((ty, field_id, adjustments, _public)) => {\n+                        self.write_expr_adj(receiver, adjustments);\n+                        if let Some(field_id) = field_id {\n+                            self.result.field_resolutions.insert(tgt_expr, field_id);\n+                        }\n+                        Some(ty)\n+                    }\n+                    None => None,\n+                };\n+                self.result.diagnostics.push(InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr: tgt_expr,\n+                    receiver: receiver_ty.clone(),\n+                    name: method_name.clone(),\n+                    field_with_same_name: field_with_same_name_exists,\n+                });\n+                (\n+                    receiver_ty,\n+                    Binders::empty(Interner, self.err_ty()),\n+                    Substitution::empty(Interner),\n+                )\n+            }\n         };\n         let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);\n@@ -1636,16 +1842,16 @@ impl<'a> InferenceContext<'a> {\n     fn with_breakable_ctx<T>(\n         &mut self,\n         kind: BreakableKind,\n-        ty: Ty,\n+        ty: Option<Ty>,\n         label: Option<LabelId>,\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n             let label = label.map(|label| self.body[label].name.clone());\n-            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n+            BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n-        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n+        (if ctx.may_break { ctx.coerce.map(|ctx| ctx.complete(self)) } else { None }, res)\n     }\n }"}, {"sha": "0f49e837881834fd71668a863df35d9bbfbc9d89", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 221, "deletions": 124, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -4,22 +4,60 @@ use std::iter::repeat_with;\n \n use chalk_ir::Mutability;\n use hir_def::{\n-    expr::{BindingAnnotation, Expr, Literal, Pat, PatId},\n+    body::Body,\n+    expr::{\n+        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n+        RecordFieldPat,\n+    },\n     path::Path,\n-    type_ref::ConstScalar,\n };\n use hir_expand::name::Name;\n \n use crate::{\n-    consteval::intern_const_scalar,\n+    consteval::{try_const_usize, usize_const},\n     infer::{BindingMode, Expectation, InferenceContext, TypeMismatch},\n     lower::lower_to_chalk_mutability,\n     primitive::UintTy,\n-    static_lifetime, ConcreteConst, ConstValue, Interner, Scalar, Substitution, Ty, TyBuilder,\n-    TyExt, TyKind,\n+    static_lifetime, Interner, Scalar, Substitution, Ty, TyBuilder, TyExt, TyKind,\n };\n \n-use super::PatLike;\n+/// Used to generalize patterns and assignee expressions.\n+pub(super) trait PatLike: Into<ExprOrPatId> + Copy {\n+    type BindingMode: Copy;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty;\n+}\n+\n+impl PatLike for ExprId {\n+    type BindingMode = ();\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        (): Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_assignee_expr(id, expected_ty)\n+    }\n+}\n+\n+impl PatLike for PatId {\n+    type BindingMode = BindingMode;\n+\n+    fn infer(\n+        this: &mut InferenceContext<'_>,\n+        id: Self,\n+        expected_ty: &Ty,\n+        default_bm: Self::BindingMode,\n+    ) -> Ty {\n+        this.infer_pat(id, expected_ty, default_bm)\n+    }\n+}\n \n impl<'a> InferenceContext<'a> {\n     /// Infers type for tuple struct pattern or its corresponding assignee expression.\n@@ -112,6 +150,7 @@ impl<'a> InferenceContext<'a> {\n         ellipsis: Option<usize>,\n         subs: &[T],\n     ) -> Ty {\n+        let expected = self.resolve_ty_shallow(expected);\n         let expectations = match expected.as_tuple() {\n             Some(parameters) => &*parameters.as_slice(Interner),\n             _ => &[],\n@@ -145,12 +184,11 @@ impl<'a> InferenceContext<'a> {\n             .intern(Interner)\n     }\n \n-    pub(super) fn infer_pat(\n-        &mut self,\n-        pat: PatId,\n-        expected: &Ty,\n-        mut default_bm: BindingMode,\n-    ) -> Ty {\n+    pub(super) fn infer_top_pat(&mut self, pat: PatId, expected: &Ty) {\n+        self.infer_pat(pat, expected, BindingMode::default());\n+    }\n+\n+    fn infer_pat(&mut self, pat: PatId, expected: &Ty, mut default_bm: BindingMode) -> Ty {\n         let mut expected = self.resolve_ty_shallow(expected);\n \n         if is_non_ref_pat(self.body, pat) {\n@@ -185,30 +223,17 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_tuple_pat_like(&expected, default_bm, *ellipsis, args)\n             }\n             Pat::Or(pats) => {\n-                if let Some((first_pat, rest)) = pats.split_first() {\n-                    let ty = self.infer_pat(*first_pat, &expected, default_bm);\n-                    for pat in rest {\n-                        self.infer_pat(*pat, &expected, default_bm);\n-                    }\n-                    ty\n-                } else {\n-                    self.err_ty()\n+                for pat in pats.iter() {\n+                    self.infer_pat(*pat, &expected, default_bm);\n                 }\n+                expected.clone()\n             }\n-            Pat::Ref { pat, mutability } => {\n-                let mutability = lower_to_chalk_mutability(*mutability);\n-                let expectation = match expected.as_reference() {\n-                    Some((inner_ty, _lifetime, exp_mut)) => {\n-                        if mutability != exp_mut {\n-                            // FIXME: emit type error?\n-                        }\n-                        inner_ty.clone()\n-                    }\n-                    _ => self.result.standard_types.unknown.clone(),\n-                };\n-                let subty = self.infer_pat(*pat, &expectation, default_bm);\n-                TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n-            }\n+            &Pat::Ref { pat, mutability } => self.infer_ref_pat(\n+                pat,\n+                lower_to_chalk_mutability(mutability),\n+                &expected,\n+                default_bm,\n+            ),\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self\n                 .infer_tuple_struct_pat_like(\n                     p.as_deref(),\n@@ -223,100 +248,25 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat, subs)\n             }\n             Pat::Path(path) => {\n-                // FIXME use correct resolver for the surrounding expression\n-                let resolver = self.resolver.clone();\n-                self.infer_path(&resolver, path, pat.into()).unwrap_or_else(|| self.err_ty())\n+                // FIXME update resolver for the surrounding expression\n+                self.infer_path(path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Pat::Bind { mode, name: _, subpat } => {\n-                let mode = if mode == &BindingAnnotation::Unannotated {\n-                    default_bm\n-                } else {\n-                    BindingMode::convert(*mode)\n-                };\n-                self.result.pat_binding_modes.insert(pat, mode);\n-\n-                let inner_ty = match subpat {\n-                    Some(subpat) => self.infer_pat(*subpat, &expected, default_bm),\n-                    None => expected,\n-                };\n-                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n-\n-                let bound_ty = match mode {\n-                    BindingMode::Ref(mutability) => {\n-                        TyKind::Ref(mutability, static_lifetime(), inner_ty.clone())\n-                            .intern(Interner)\n-                    }\n-                    BindingMode::Move => inner_ty.clone(),\n-                };\n-                self.write_pat_ty(pat, bound_ty);\n-                return inner_ty;\n+            Pat::Bind { id, subpat } => {\n+                return self.infer_bind_pat(pat, *id, default_bm, *subpat, &expected);\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let elem_ty = match expected.kind(Interner) {\n-                    TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n-                    _ => self.err_ty(),\n-                };\n-\n-                for &pat_id in prefix.iter().chain(suffix.iter()) {\n-                    self.infer_pat(pat_id, &elem_ty, default_bm);\n-                }\n-\n-                if let &Some(slice_pat_id) = slice {\n-                    let rest_pat_ty = match expected.kind(Interner) {\n-                        TyKind::Array(_, length) => {\n-                            let len = match length.data(Interner).value {\n-                                ConstValue::Concrete(ConcreteConst {\n-                                    interned: ConstScalar::UInt(len),\n-                                }) => len.checked_sub((prefix.len() + suffix.len()) as u128),\n-                                _ => None,\n-                            };\n-                            TyKind::Array(\n-                                elem_ty.clone(),\n-                                intern_const_scalar(\n-                                    len.map_or(ConstScalar::Unknown, |len| ConstScalar::UInt(len)),\n-                                    TyBuilder::usize(),\n-                                ),\n-                            )\n-                        }\n-                        _ => TyKind::Slice(elem_ty.clone()),\n-                    }\n-                    .intern(Interner);\n-                    self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n-                }\n-\n-                match expected.kind(Interner) {\n-                    TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n-                    _ => TyKind::Slice(elem_ty),\n-                }\n-                .intern(Interner)\n+                self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n             }\n             Pat::Wild => expected.clone(),\n             Pat::Range { start, end } => {\n                 let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n                 self.infer_expr(*end, &Expectation::has_type(start_ty))\n             }\n             &Pat::Lit(expr) => {\n-                // FIXME: using `Option` here is a workaround until we can use if-let chains in stable.\n-                let mut pat_ty = None;\n-\n-                // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n-                if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n-                    if let Some((inner, ..)) = expected.as_reference() {\n-                        let inner = self.resolve_ty_shallow(inner);\n-                        if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n-                            let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n-                            let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n-                            let ty = TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty)\n-                                .intern(Interner);\n-                            self.write_expr_ty(expr, ty.clone());\n-                            pat_ty = Some(ty);\n-                        }\n-                    }\n-                }\n-\n-                pat_ty.unwrap_or_else(|| {\n-                    self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n-                })\n+                // Don't emit type mismatches again, the expression lowering already did that.\n+                let ty = self.infer_lit_pat(expr, &expected);\n+                self.write_pat_ty(pat, ty.clone());\n+                return ty;\n             }\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n@@ -345,14 +295,120 @@ impl<'a> InferenceContext<'a> {\n         };\n         // use a new type variable if we got error type here\n         let ty = self.insert_type_vars_shallow(ty);\n-        if !self.unify(&ty, &expected) {\n+        // FIXME: This never check is odd, but required with out we do inference right now\n+        if !expected.is_never() && !self.unify(&ty, &expected) {\n             self.result\n                 .type_mismatches\n                 .insert(pat.into(), TypeMismatch { expected, actual: ty.clone() });\n         }\n         self.write_pat_ty(pat, ty.clone());\n         ty\n     }\n+\n+    fn infer_ref_pat(\n+        &mut self,\n+        pat: PatId,\n+        mutability: Mutability,\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let expectation = match expected.as_reference() {\n+            Some((inner_ty, _lifetime, _exp_mut)) => inner_ty.clone(),\n+            _ => self.result.standard_types.unknown.clone(),\n+        };\n+        let subty = self.infer_pat(pat, &expectation, default_bm);\n+        TyKind::Ref(mutability, static_lifetime(), subty).intern(Interner)\n+    }\n+\n+    fn infer_bind_pat(\n+        &mut self,\n+        pat: PatId,\n+        binding: BindingId,\n+        default_bm: BindingMode,\n+        subpat: Option<PatId>,\n+        expected: &Ty,\n+    ) -> Ty {\n+        let Binding { mode, .. } = self.body.bindings[binding];\n+        let mode = if mode == BindingAnnotation::Unannotated {\n+            default_bm\n+        } else {\n+            BindingMode::convert(mode)\n+        };\n+        self.result.pat_binding_modes.insert(pat, mode);\n+\n+        let inner_ty = match subpat {\n+            Some(subpat) => self.infer_pat(subpat, &expected, default_bm),\n+            None => expected.clone(),\n+        };\n+        let inner_ty = self.insert_type_vars_shallow(inner_ty);\n+\n+        let bound_ty = match mode {\n+            BindingMode::Ref(mutability) => {\n+                TyKind::Ref(mutability, static_lifetime(), inner_ty.clone()).intern(Interner)\n+            }\n+            BindingMode::Move => inner_ty.clone(),\n+        };\n+        self.write_pat_ty(pat, bound_ty.clone());\n+        self.write_binding_ty(binding, bound_ty);\n+        return inner_ty;\n+    }\n+\n+    fn infer_slice_pat(\n+        &mut self,\n+        expected: &Ty,\n+        prefix: &[PatId],\n+        slice: &Option<PatId>,\n+        suffix: &[PatId],\n+        default_bm: BindingMode,\n+    ) -> Ty {\n+        let elem_ty = match expected.kind(Interner) {\n+            TyKind::Array(st, _) | TyKind::Slice(st) => st.clone(),\n+            _ => self.err_ty(),\n+        };\n+\n+        for &pat_id in prefix.iter().chain(suffix.iter()) {\n+            self.infer_pat(pat_id, &elem_ty, default_bm);\n+        }\n+\n+        if let &Some(slice_pat_id) = slice {\n+            let rest_pat_ty = match expected.kind(Interner) {\n+                TyKind::Array(_, length) => {\n+                    let len = try_const_usize(length);\n+                    let len =\n+                        len.and_then(|len| len.checked_sub((prefix.len() + suffix.len()) as u128));\n+                    TyKind::Array(elem_ty.clone(), usize_const(self.db, len, self.resolver.krate()))\n+                }\n+                _ => TyKind::Slice(elem_ty.clone()),\n+            }\n+            .intern(Interner);\n+            self.infer_pat(slice_pat_id, &rest_pat_ty, default_bm);\n+        }\n+\n+        match expected.kind(Interner) {\n+            TyKind::Array(_, const_) => TyKind::Array(elem_ty, const_.clone()),\n+            _ => TyKind::Slice(elem_ty),\n+        }\n+        .intern(Interner)\n+    }\n+\n+    fn infer_lit_pat(&mut self, expr: ExprId, expected: &Ty) -> Ty {\n+        // Like slice patterns, byte string patterns can denote both `&[u8; N]` and `&[u8]`.\n+        if let Expr::Literal(Literal::ByteString(_)) = self.body[expr] {\n+            if let Some((inner, ..)) = expected.as_reference() {\n+                let inner = self.resolve_ty_shallow(inner);\n+                if matches!(inner.kind(Interner), TyKind::Slice(_)) {\n+                    let elem_ty = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(Interner);\n+                    let slice_ty = TyKind::Slice(elem_ty).intern(Interner);\n+                    let ty =\n+                        TyKind::Ref(Mutability::Not, static_lifetime(), slice_ty).intern(Interner);\n+                    self.write_expr_ty(expr, ty.clone());\n+                    return ty;\n+                }\n+            }\n+        }\n+\n+        self.infer_expr(expr, &Expectation::has_type(expected.clone()))\n+    }\n }\n \n fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n@@ -369,11 +425,52 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n         Pat::Lit(expr) => {\n             !matches!(body[*expr], Expr::Literal(Literal::String(..) | Literal::ByteString(..)))\n         }\n-        Pat::Bind {\n-            mode: BindingAnnotation::Mutable | BindingAnnotation::Unannotated,\n-            subpat: Some(subpat),\n-            ..\n-        } => is_non_ref_pat(body, *subpat),\n+        Pat::Bind { id, subpat: Some(subpat), .. }\n+            if matches!(\n+                body.bindings[*id].mode,\n+                BindingAnnotation::Mutable | BindingAnnotation::Unannotated\n+            ) =>\n+        {\n+            is_non_ref_pat(body, *subpat)\n+        }\n         Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Box { .. } | Pat::Missing => false,\n     }\n }\n+\n+pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n+    let mut res = false;\n+    walk_pats(body, pat_id, &mut |pat| {\n+        res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n+    });\n+    res\n+}\n+\n+fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+    let pat = &body[pat_id];\n+    f(pat);\n+    match pat {\n+        Pat::Range { .. }\n+        | Pat::Lit(..)\n+        | Pat::Path(..)\n+        | Pat::ConstBlock(..)\n+        | Pat::Wild\n+        | Pat::Missing => {}\n+        &Pat::Bind { subpat, .. } => {\n+            if let Some(subpat) = subpat {\n+                walk_pats(body, subpat, f);\n+            }\n+        }\n+        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n+        Pat::Slice { prefix, slice, suffix } => {\n+            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n+        }\n+        Pat::Record { args, .. } => {\n+            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n+        }\n+        Pat::Box { inner } => walk_pats(body, *inner, f),\n+    }\n+}"}, {"sha": "2267fedaa8e9261bc1af94492cac41bfe631a685", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 65, "deletions": 82, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -3,7 +3,7 @@\n use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n-    resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    resolver::{ResolveValueResult, TypeNs, ValueNs},\n     AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n@@ -21,55 +21,42 @@ use crate::{\n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn infer_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n-        let ty = self.resolve_value_path(resolver, path, id)?;\n+    pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n+        let ty = self.resolve_value_path(path, id)?;\n         let ty = self.insert_type_vars(ty);\n         let ty = self.normalize_associated_types_in(ty);\n         Some(ty)\n     }\n \n-    fn resolve_value_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n+    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n-            if path.segments().is_empty() {\n-                // This can't actually happen syntax-wise\n-                return None;\n-            }\n+            let Some(last) = path.segments().last() else { return None };\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ctx = crate::lower::TyLoweringContext::new(self.db, resolver);\n+            let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n             let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n-            self.resolve_ty_assoc_item(\n-                ty,\n-                path.segments().last().expect(\"path had at least one segment\").name,\n-                id,\n-            )?\n+            self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?\n         } else {\n+            // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n-                resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n+                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n-                ResolveValueResult::Partial(def, remaining_index) => {\n-                    self.resolve_assoc_item(def, path, remaining_index, id)?\n-                }\n+                ResolveValueResult::Partial(def, remaining_index) => self\n+                    .resolve_assoc_item(def, path, remaining_index, id)\n+                    .map(|(it, substs)| (it, Some(substs)))?,\n             }\n         };\n \n         let typable: ValueTyDefId = match value {\n-            ValueNs::LocalBinding(pat) => {\n-                let ty = self.result.type_of_pat.get(pat)?.clone();\n-                return Some(ty);\n-            }\n+            ValueNs::LocalBinding(pat) => match self.result.type_of_binding.get(pat) {\n+                Some(ty) => return Some(ty.clone()),\n+                None => {\n+                    never!(\"uninferred pattern?\");\n+                    return None;\n+                }\n+            },\n             ValueNs::FunctionId(it) => it.into(),\n             ValueNs::ConstId(it) => it.into(),\n             ValueNs::StaticId(it) => it.into(),\n@@ -91,7 +78,7 @@ impl<'a> InferenceContext<'a> {\n                     let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n                     return Some(ty);\n                 } else {\n-                    // FIXME: diagnostic, invalid Self reference\n+                    // FIXME: report error, invalid Self reference\n                     return None;\n                 }\n             }\n@@ -126,7 +113,7 @@ impl<'a> InferenceContext<'a> {\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n@@ -179,7 +166,7 @@ impl<'a> InferenceContext<'a> {\n         trait_ref: TraitRef,\n         segment: PathSegment<'_>,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let trait_ = trait_ref.hir_trait_id();\n         let item =\n             self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id)).find_map(|item| {\n@@ -215,15 +202,15 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.write_assoc_resolution(id, item, trait_ref.substitution.clone());\n-        Some((def, Some(trait_ref.substitution)))\n+        Some((def, trait_ref.substitution))\n     }\n \n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         if let TyKind::Error = ty.kind(Interner) {\n             return None;\n         }\n@@ -233,78 +220,74 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         let canonical_ty = self.canonicalize(ty.clone());\n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let mut not_visible = None;\n         let res = method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n             |_ty, item, visible| {\n-                let (def, container) = match item {\n-                    AssocItemId::FunctionId(f) => {\n-                        (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::ConstId(c) => {\n-                        (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::TypeAliasId(_) => unreachable!(),\n-                };\n-                let substs = match container {\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        let impl_self_ty =\n-                            self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n-                        self.unify(&impl_self_ty, &ty);\n-                        impl_substs\n-                    }\n-                    ItemContainerId::TraitId(trait_) => {\n-                        // we're picking this method\n-                        let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n-                            .push(ty.clone())\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        self.push_obligation(trait_ref.clone().cast(Interner));\n-                        trait_ref.substitution\n-                    }\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        never!(\"assoc item contained in module/extern block\");\n-                        return None;\n-                    }\n-                };\n-\n                 if visible {\n-                    Some((def, item, Some(substs), true))\n+                    Some((item, true))\n                 } else {\n                     if not_visible.is_none() {\n-                        not_visible = Some((def, item, Some(substs), false));\n+                        not_visible = Some((item, false));\n                     }\n                     None\n                 }\n             },\n         );\n         let res = res.or(not_visible);\n-        if let Some((_, item, Some(ref substs), visible)) = res {\n-            self.write_assoc_resolution(id, item, substs.clone());\n-            if !visible {\n-                self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item })\n+        let (item, visible) = res?;\n+\n+        let (def, container) = match item {\n+            AssocItemId::FunctionId(f) => {\n+                (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n+            }\n+            AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container),\n+            AssocItemId::TypeAliasId(_) => unreachable!(),\n+        };\n+        let substs = match container {\n+            ItemContainerId::ImplId(impl_id) => {\n+                let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                let impl_self_ty = self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n+                self.unify(&impl_self_ty, &ty);\n+                impl_substs\n             }\n+            ItemContainerId::TraitId(trait_) => {\n+                // we're picking this method\n+                let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n+                    .push(ty.clone())\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                self.push_obligation(trait_ref.clone().cast(Interner));\n+                trait_ref.substitution\n+            }\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                never!(\"assoc item contained in module/extern block\");\n+                return None;\n+            }\n+        };\n+\n+        self.write_assoc_resolution(id, item, substs.clone());\n+        if !visible {\n+            self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item });\n         }\n-        res.map(|(def, _, substs, _)| (def, substs))\n+        Some((def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty(\n         &mut self,\n         ty: &Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let ty = self.resolve_ty_shallow(ty);\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n@@ -314,6 +297,6 @@ impl<'a> InferenceContext<'a> {\n         let local_id = enum_data.variant(name)?;\n         let variant = EnumVariantId { parent: enum_id, local_id };\n         self.write_variant_resolution(id, variant.into());\n-        Some((ValueNs::EnumVariantId(variant), Some(subst.clone())))\n+        Some((ValueNs::EnumVariantId(variant), subst.clone()))\n     }\n }"}, {"sha": "504f0743aa947edc3dcc7981fcf77dd88da8b7aa", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -704,14 +704,13 @@ impl<'a> fmt::Debug for InferenceTable<'a> {\n mod resolve {\n     use super::InferenceTable;\n     use crate::{\n-        ConcreteConst, Const, ConstData, ConstValue, DebruijnIndex, GenericArg, InferenceVar,\n-        Interner, Lifetime, Ty, TyVariableKind, VariableKind,\n+        ConcreteConst, Const, ConstData, ConstScalar, ConstValue, DebruijnIndex, GenericArg,\n+        InferenceVar, Interner, Lifetime, Ty, TyVariableKind, VariableKind,\n     };\n     use chalk_ir::{\n         cast::Cast,\n         fold::{TypeFoldable, TypeFolder},\n     };\n-    use hir_def::type_ref::ConstScalar;\n \n     #[derive(chalk_derive::FallibleTypeFolder)]\n     #[has_interner(Interner)]"}, {"sha": "36af78153d43ad439044e02be4383e1e980df7eb", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -6,12 +6,12 @@ use chalk_ir::{\n     DebruijnIndex,\n };\n use hir_def::{\n-    adt::VariantData, attr::Attrs, type_ref::ConstScalar, visibility::Visibility, AdtId,\n-    EnumVariantId, HasModule, Lookup, ModuleId, VariantId,\n+    adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n+    ModuleId, VariantId,\n };\n \n use crate::{\n-    db::HirDatabase, Binders, ConcreteConst, Const, ConstValue, Interner, Substitution, Ty, TyKind,\n+    consteval::try_const_usize, db::HirDatabase, Binders, Interner, Substitution, Ty, TyKind,\n };\n \n /// Checks whether a type is visibly uninhabited from a particular module.\n@@ -69,7 +69,7 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n             TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n             TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n-            TyKind::Array(item_ty, len) => match try_usize_const(len) {\n+            TyKind::Array(item_ty, len) => match try_const_usize(len) {\n                 Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n                 Some(1..) => item_ty.super_visit_with(self, outer_binder),\n             },\n@@ -160,14 +160,3 @@ impl UninhabitedFrom<'_> {\n         }\n     }\n }\n-\n-fn try_usize_const(c: &Const) -> Option<u128> {\n-    let data = &c.data(Interner);\n-    if data.ty.kind(Interner) != &TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)) {\n-        return None;\n-    }\n-    match data.value {\n-        ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(value) }) => Some(value),\n-        _ => None,\n-    }\n-}"}, {"sha": "aea7e9762fdf4bfce6914539a301160ded3968f4", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,10 +1,10 @@\n //! Implementation of the Chalk `Interner` trait, which allows customizing the\n //! representation of the various objects Chalk deals with (types, goals etc.).\n \n-use crate::{chalk_db, tls, GenericArg};\n+use crate::{chalk_db, tls, ConstScalar, GenericArg};\n use base_db::salsa::InternId;\n use chalk_ir::{Goal, GoalData};\n-use hir_def::{type_ref::ConstScalar, TypeAliasId};\n+use hir_def::TypeAliasId;\n use intern::{impl_internable, Interned};\n use smallvec::SmallVec;\n use std::{fmt, sync::Arc};"}, {"sha": "b95bb01fcefeb08f6d020d12a9503d02e3029d54", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n };\n use stdx::never;\n \n-use crate::{db::HirDatabase, Interner, Substitution, Ty};\n+use crate::{consteval::try_const_usize, db::HirDatabase, Interner, Substitution, Ty};\n \n use self::adt::struct_variant_idx;\n pub use self::{\n@@ -122,17 +122,9 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n         }\n         TyKind::Array(element, count) => {\n-            let count = match count.data(Interner).value {\n-                chalk_ir::ConstValue::Concrete(c) => match c.interned {\n-                    hir_def::type_ref::ConstScalar::Int(x) => x as u64,\n-                    hir_def::type_ref::ConstScalar::UInt(x) => x as u64,\n-                    hir_def::type_ref::ConstScalar::Unknown => {\n-                        user_error!(\"unknown const generic parameter\")\n-                    }\n-                    _ => user_error!(\"mismatched type of const generic parameter\"),\n-                },\n-                _ => return Err(LayoutError::HasPlaceholder),\n-            };\n+            let count = try_const_usize(&count).ok_or(LayoutError::UserError(\n+                \"mismatched type of const generic parameter\".to_string(),\n+            ))? as u64;\n             let element = layout_of_ty(db, element, krate)?;\n             let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n "}, {"sha": "b22d0fe8ded1140046b5e555a36a17736438b8aa", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -76,17 +76,8 @@ pub fn layout_of_adt_query(\n             |min, max| Integer::repr_discr(&dl, &repr, min, max).unwrap_or((Integer::I8, false)),\n             variants.iter_enumerated().filter_map(|(id, _)| {\n                 let AdtId::EnumId(e) = def else { return None };\n-                let d = match db\n-                    .const_eval_variant(EnumVariantId { parent: e, local_id: id.0 })\n-                    .ok()?\n-                {\n-                    crate::consteval::ComputedExpr::Literal(l) => match l {\n-                        hir_def::expr::Literal::Int(i, _) => i,\n-                        hir_def::expr::Literal::Uint(i, _) => i as i128,\n-                        _ => return None,\n-                    },\n-                    _ => return None,\n-                };\n+                let d =\n+                    db.const_eval_discriminant(EnumVariantId { parent: e, local_id: id.0 }).ok()?;\n                 Some((id, d))\n             }),\n             // FIXME: The current code for niche-filling relies on variant indices"}, {"sha": "a8971fde3c21edbc0c8e21de6d2d9be570a763aa", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -65,25 +65,17 @@ fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n         })\n         .unwrap();\n     let hir_body = db.body(adt_id.into());\n-    let pat = hir_body\n-        .pats\n-        .iter()\n-        .find(|x| match x.1 {\n-            hir_def::expr::Pat::Bind { name, .. } => name.to_smol_str() == \"goal\",\n-            _ => false,\n-        })\n-        .unwrap()\n-        .0;\n+    let b = hir_body.bindings.iter().find(|x| x.1.name.to_smol_str() == \"goal\").unwrap().0;\n     let infer = db.infer(adt_id.into());\n-    let goal_ty = infer.type_of_pat[pat].clone();\n+    let goal_ty = infer.type_of_binding[b].clone();\n     layout_of_ty(&db, &goal_ty, module_id.krate())\n }\n \n #[track_caller]\n fn check_size_and_align(ra_fixture: &str, minicore: &str, size: u64, align: u64) {\n     let l = eval_goal(ra_fixture, minicore).unwrap();\n-    assert_eq!(l.size.bytes(), size);\n-    assert_eq!(l.align.abi.bytes(), align);\n+    assert_eq!(l.size.bytes(), size, \"size mismatch\");\n+    assert_eq!(l.align.abi.bytes(), align, \"align mismatch\");\n }\n \n #[track_caller]\n@@ -300,4 +292,9 @@ fn enums_with_discriminants() {\n             C, // implicitly becomes 256, so we need two bytes\n         }\n     }\n+    size_and_align! {\n+        enum Goal {\n+            A = 1, // This one is (perhaps surprisingly) zero sized.\n+        }\n+    }\n }"}, {"sha": "9c63d67ab19a4b8109d224977605d4a0210e7410", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -13,6 +13,7 @@ mod builder;\n mod chalk_db;\n mod chalk_ext;\n pub mod consteval;\n+pub mod mir;\n mod infer;\n mod inhabitedness;\n mod interner;\n@@ -34,18 +35,19 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n \n-use std::sync::Arc;\n+use std::{collections::HashMap, hash::Hash, sync::Arc};\n \n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n     visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n     NoSolution, TyData,\n };\n+use either::Either;\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n use hir_expand::name;\n-use itertools::Either;\n use la_arena::{Arena, Idx};\n+use mir::MirEvalError;\n use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n@@ -145,6 +147,49 @@ pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n pub type Guidance = chalk_solve::Guidance<Interner>;\n pub type WhereClause = chalk_ir::WhereClause<Interner>;\n \n+/// A constant can have reference to other things. Memory map job is holding\n+/// the neccessary bits of memory of the const eval session to keep the constant\n+/// meaningful.\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+pub struct MemoryMap(pub HashMap<usize, Vec<u8>>);\n+\n+impl MemoryMap {\n+    fn insert(&mut self, addr: usize, x: Vec<u8>) {\n+        self.0.insert(addr, x);\n+    }\n+\n+    /// This functions convert each address by a function `f` which gets the byte intervals and assign an address\n+    /// to them. It is useful when you want to load a constant with a memory map in a new memory. You can pass an\n+    /// allocator function as `f` and it will return a mapping of old addresses to new addresses.\n+    fn transform_addresses(\n+        &self,\n+        mut f: impl FnMut(&[u8]) -> Result<usize, MirEvalError>,\n+    ) -> Result<HashMap<usize, usize>, MirEvalError> {\n+        self.0.iter().map(|x| Ok((*x.0, f(x.1)?))).collect()\n+    }\n+}\n+\n+/// A concrete constant value\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ConstScalar {\n+    Bytes(Vec<u8>, MemoryMap),\n+    /// Case of an unknown value that rustc might know but we don't\n+    // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n+    // constants\n+    // https://github.com/rust-lang/rust-analyzer/pull/8813#issuecomment-840679177\n+    // https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Handling.20non.20evaluatable.20constants'.20equality/near/238386348\n+    Unknown,\n+}\n+\n+impl Hash for ConstScalar {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        core::mem::discriminant(self).hash(state);\n+        if let ConstScalar::Bytes(b, _) = self {\n+            b.hash(state)\n+        }\n+    }\n+}\n+\n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)"}, {"sha": "23b15087e31658db9ad9c0ce265d59b4675afbea", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -16,6 +16,7 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, fold::TypeFoldable, interner::HasInterner, Mutability, Safety,\n };\n \n+use either::Either;\n use hir_def::{\n     adt::StructKind,\n     body::{Expander, LowerCtx},\n@@ -26,16 +27,13 @@ use hir_def::{\n     lang_item::{lang_attr, LangItem},\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{\n-        ConstScalarOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef,\n-    },\n+    type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n     HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n     TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use intern::Interned;\n-use itertools::Either;\n use la_arena::{Arena, ArenaMap};\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n@@ -44,7 +42,7 @@ use syntax::ast;\n \n use crate::{\n     all_super_traits,\n-    consteval::{intern_const_scalar, path_to_const, unknown_const, unknown_const_as_generic},\n+    consteval::{intern_const_ref, path_to_const, unknown_const, unknown_const_as_generic},\n     db::HirDatabase,\n     make_binders,\n     mapping::{from_chalk_trait_id, ToChalk},\n@@ -524,6 +522,10 @@ impl<'a> TyLoweringContext<'a> {\n                 };\n                 return (ty, None);\n             }\n+            TypeNs::TraitAliasId(_) => {\n+                // FIXME(trait_alias): Implement trait alias.\n+                return (TyKind::Error.intern(Interner), None);\n+            }\n             TypeNs::GenericParam(param_id) => {\n                 let generics = generics(\n                     self.db.upcast(),\n@@ -879,6 +881,7 @@ impl<'a> TyLoweringContext<'a> {\n     ) -> Option<TraitRef> {\n         let resolved =\n             match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path())? {\n+                // FIXME(trait_alias): We need to handle trait alias here.\n                 TypeNs::TraitId(tr) => tr,\n                 _ => return None,\n             };\n@@ -968,7 +971,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // - `Destruct` impls are built-in in 1.62 (current nightlies as of 08-04-2022), so until\n                         //   the builtin impls are supported by Chalk, we ignore them here.\n                         if let Some(lang) = lang_attr(self.db.upcast(), tr.hir_trait_id()) {\n-                            if lang == \"drop\" || lang == \"destruct\" {\n+                            if matches!(lang, LangItem::Drop | LangItem::Destruct) {\n                                 return false;\n                             }\n                         }\n@@ -1444,6 +1447,7 @@ pub(crate) fn trait_environment_query(\n         GenericDefId::FunctionId(f) => Some(f.lookup(db.upcast()).container),\n         GenericDefId::AdtId(_) => None,\n         GenericDefId::TraitId(_) => None,\n+        GenericDefId::TraitAliasId(_) => None,\n         GenericDefId::TypeAliasId(t) => Some(t.lookup(db.upcast()).container),\n         GenericDefId::ImplId(_) => None,\n         GenericDefId::EnumVariantId(_) => None,\n@@ -1583,10 +1587,10 @@ pub(crate) fn generic_defaults_recover(\n         .iter_id()\n         .map(|id| {\n             let val = match id {\n-                itertools::Either::Left(_) => {\n+                Either::Left(_) => {\n                     GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                 }\n-                itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n+                Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n             };\n             crate::make_binders(db, &generic_params, val)\n         })\n@@ -1919,7 +1923,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n     arg: &'a GenericArg,\n     this: &mut T,\n     for_type: impl FnOnce(&mut T, &TypeRef) -> Ty + 'a,\n-    for_const: impl FnOnce(&mut T, &ConstScalarOrPath, Ty) -> Const + 'a,\n+    for_const: impl FnOnce(&mut T, &ConstRefOrPath, Ty) -> Const + 'a,\n ) -> Option<crate::GenericArg> {\n     let kind = match kind_id {\n         Either::Left(_) => ParamKind::Type,\n@@ -1947,7 +1951,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n                 let p = p.mod_path();\n                 if p.kind == PathKind::Plain {\n                     if let [n] = p.segments() {\n-                        let c = ConstScalarOrPath::Path(n.clone());\n+                        let c = ConstRefOrPath::Path(n.clone());\n                         return Some(\n                             GenericArgData::Const(for_const(this, &c, c_ty)).intern(Interner),\n                         );\n@@ -1964,14 +1968,14 @@ pub(crate) fn const_or_path_to_chalk(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     expected_ty: Ty,\n-    value: &ConstScalarOrPath,\n+    value: &ConstRefOrPath,\n     mode: ParamLoweringMode,\n     args: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n ) -> Const {\n     match value {\n-        ConstScalarOrPath::Scalar(s) => intern_const_scalar(*s, expected_ty),\n-        ConstScalarOrPath::Path(n) => {\n+        ConstRefOrPath::Scalar(s) => intern_const_ref(db, s, expected_ty, resolver.krate()),\n+        ConstRefOrPath::Path(n) => {\n             let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n             path_to_const(db, resolver, &path, mode, args, debruijn)\n                 .unwrap_or_else(|| unknown_const(expected_ty))"}, {"sha": "92a17fc3a99728020c4b20047610d129b435bc79", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 59, "deletions": 62, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -579,8 +579,8 @@ impl ReceiverAdjustments {\n                     ty = new_ty.clone();\n                     adjust.push(Adjustment {\n                         kind: Adjust::Deref(match kind {\n-                            // FIXME should we know the mutability here?\n-                            AutoderefKind::Overloaded => Some(OverloadedDeref(Mutability::Not)),\n+                            // FIXME should we know the mutability here, when autoref is `None`?\n+                            AutoderefKind::Overloaded => Some(OverloadedDeref(self.autoref)),\n                             AutoderefKind::Builtin => None,\n                         }),\n                         target: new_ty,\n@@ -660,23 +660,25 @@ pub fn lookup_impl_const(\n     env: Arc<TraitEnvironment>,\n     const_id: ConstId,\n     subs: Substitution,\n-) -> ConstId {\n+) -> (ConstId, Substitution) {\n     let trait_id = match const_id.lookup(db.upcast()).container {\n         ItemContainerId::TraitId(id) => id,\n-        _ => return const_id,\n+        _ => return (const_id, subs),\n     };\n     let substitution = Substitution::from_iter(Interner, subs.iter(Interner));\n     let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_id), substitution };\n \n     let const_data = db.const_data(const_id);\n     let name = match const_data.name.as_ref() {\n         Some(name) => name,\n-        None => return const_id,\n+        None => return (const_id, subs),\n     };\n \n     lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n-        .and_then(|assoc| if let AssocItemId::ConstId(id) = assoc { Some(id) } else { None })\n-        .unwrap_or(const_id)\n+        .and_then(\n+            |assoc| if let (AssocItemId::ConstId(id), s) = assoc { Some((id, s)) } else { None },\n+        )\n+        .unwrap_or((const_id, subs))\n }\n \n /// Looks up the impl method that actually runs for the trait method `func`.\n@@ -687,10 +689,10 @@ pub fn lookup_impl_method(\n     env: Arc<TraitEnvironment>,\n     func: FunctionId,\n     fn_subst: Substitution,\n-) -> FunctionId {\n+) -> (FunctionId, Substitution) {\n     let trait_id = match func.lookup(db.upcast()).container {\n         ItemContainerId::TraitId(id) => id,\n-        _ => return func,\n+        _ => return (func, fn_subst),\n     };\n     let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n     let fn_params = fn_subst.len(Interner) - trait_params;\n@@ -701,25 +703,31 @@ pub fn lookup_impl_method(\n \n     let name = &db.function_data(func).name;\n     lookup_impl_assoc_item_for_trait_ref(trait_ref, db, env, name)\n-        .and_then(|assoc| if let AssocItemId::FunctionId(id) = assoc { Some(id) } else { None })\n-        .unwrap_or(func)\n+        .and_then(|assoc| {\n+            if let (AssocItemId::FunctionId(id), subst) = assoc {\n+                Some((id, subst))\n+            } else {\n+                None\n+            }\n+        })\n+        .unwrap_or((func, fn_subst))\n }\n \n fn lookup_impl_assoc_item_for_trait_ref(\n     trait_ref: TraitRef,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n     name: &Name,\n-) -> Option<AssocItemId> {\n+) -> Option<(AssocItemId, Substitution)> {\n     let self_ty = trait_ref.self_type_parameter(Interner);\n     let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n     let impls = db.trait_impls_in_deps(env.krate);\n     let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n \n     let table = InferenceTable::new(db, env);\n \n-    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n-    impl_data.items.iter().find_map(|&it| match it {\n+    let (impl_data, impl_subst) = find_matching_impl(impls, table, trait_ref)?;\n+    let item = impl_data.items.iter().find_map(|&it| match it {\n         AssocItemId::FunctionId(f) => {\n             (db.function_data(f).name == *name).then_some(AssocItemId::FunctionId(f))\n         }\n@@ -730,14 +738,15 @@ fn lookup_impl_assoc_item_for_trait_ref(\n             .map(|n| n == name)\n             .and_then(|result| if result { Some(AssocItemId::ConstId(c)) } else { None }),\n         AssocItemId::TypeAliasId(_) => None,\n-    })\n+    })?;\n+    Some((item, impl_subst))\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n     mut table: InferenceTable<'_>,\n     actual_trait_ref: TraitRef,\n-) -> Option<Arc<ImplData>> {\n+) -> Option<(Arc<ImplData>, Substitution)> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n@@ -758,7 +767,7 @@ fn find_matching_impl(\n                 .into_iter()\n                 .map(|b| b.cast(Interner));\n             let goal = crate::Goal::all(Interner, wcs);\n-            table.try_obligation(goal).map(|_| impl_data)\n+            table.try_obligation(goal).map(|_| (impl_data, table.resolve_completely(impl_substs)))\n         });\n         if r.is_some() {\n             break r;\n@@ -821,9 +830,9 @@ pub fn iterate_method_candidates_dyn(\n \n             let mut table = InferenceTable::new(db, env.clone());\n             let ty = table.instantiate_canonical(ty.clone());\n-            let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n+            let deref_chain = autoderef_method_receiver(&mut table, ty);\n \n-            let result = deref_chain.into_iter().zip(adj).try_for_each(|(receiver_ty, adj)| {\n+            let result = deref_chain.into_iter().try_for_each(|(receiver_ty, adj)| {\n                 iterate_method_candidates_with_autoref(\n                     &receiver_ty,\n                     adj,\n@@ -867,33 +876,28 @@ fn iterate_method_candidates_with_autoref(\n         return ControlFlow::Continue(());\n     }\n \n-    iterate_method_candidates_by_receiver(\n-        receiver_ty,\n-        first_adjustment.clone(),\n-        db,\n-        env.clone(),\n-        traits_in_scope,\n-        visible_from_module,\n-        name,\n-        &mut callback,\n-    )?;\n+    let mut iterate_method_candidates_by_receiver = move |receiver_ty, first_adjustment| {\n+        iterate_method_candidates_by_receiver(\n+            receiver_ty,\n+            first_adjustment,\n+            db,\n+            env.clone(),\n+            traits_in_scope,\n+            visible_from_module,\n+            name,\n+            &mut callback,\n+        )\n+    };\n+\n+    iterate_method_candidates_by_receiver(receiver_ty, first_adjustment.clone())?;\n \n     let refed = Canonical {\n         value: TyKind::Ref(Mutability::Not, static_lifetime(), receiver_ty.value.clone())\n             .intern(Interner),\n         binders: receiver_ty.binders.clone(),\n     };\n \n-    iterate_method_candidates_by_receiver(\n-        &refed,\n-        first_adjustment.with_autoref(Mutability::Not),\n-        db,\n-        env.clone(),\n-        traits_in_scope,\n-        visible_from_module,\n-        name,\n-        &mut callback,\n-    )?;\n+    iterate_method_candidates_by_receiver(&refed, first_adjustment.with_autoref(Mutability::Not))?;\n \n     let ref_muted = Canonical {\n         value: TyKind::Ref(Mutability::Mut, static_lifetime(), receiver_ty.value.clone())\n@@ -904,12 +908,6 @@ fn iterate_method_candidates_with_autoref(\n     iterate_method_candidates_by_receiver(\n         &ref_muted,\n         first_adjustment.with_autoref(Mutability::Mut),\n-        db,\n-        env,\n-        traits_in_scope,\n-        visible_from_module,\n-        name,\n-        &mut callback,\n     )\n }\n \n@@ -1210,8 +1208,8 @@ pub fn resolve_indexing_op(\n ) -> Option<ReceiverAdjustments> {\n     let mut table = InferenceTable::new(db, env.clone());\n     let ty = table.instantiate_canonical(ty);\n-    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n-    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n+    let deref_chain = autoderef_method_receiver(&mut table, ty);\n+    for (ty, adj) in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, &ty);\n         if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n             return Some(adj);\n@@ -1421,25 +1419,24 @@ fn generic_implements_goal(\n fn autoderef_method_receiver(\n     table: &mut InferenceTable<'_>,\n     ty: Ty,\n-) -> (Vec<Canonical<Ty>>, Vec<ReceiverAdjustments>) {\n-    let (mut deref_chain, mut adjustments): (Vec<_>, Vec<_>) = (Vec::new(), Vec::new());\n+) -> Vec<(Canonical<Ty>, ReceiverAdjustments)> {\n+    let mut deref_chain: Vec<_> = Vec::new();\n     let mut autoderef = autoderef::Autoderef::new(table, ty);\n     while let Some((ty, derefs)) = autoderef.next() {\n-        deref_chain.push(autoderef.table.canonicalize(ty).value);\n-        adjustments.push(ReceiverAdjustments {\n-            autoref: None,\n-            autoderefs: derefs,\n-            unsize_array: false,\n-        });\n+        deref_chain.push((\n+            autoderef.table.canonicalize(ty).value,\n+            ReceiverAdjustments { autoref: None, autoderefs: derefs, unsize_array: false },\n+        ));\n     }\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let (Some((TyKind::Array(parameters, _), binders)), Some(adj)) = (\n-        deref_chain.last().map(|ty| (ty.value.kind(Interner), ty.binders.clone())),\n-        adjustments.last().cloned(),\n-    ) {\n+    if let Some((TyKind::Array(parameters, _), binders, adj)) =\n+        deref_chain.last().map(|(ty, adj)| (ty.value.kind(Interner), ty.binders.clone(), adj))\n+    {\n         let unsized_ty = TyKind::Slice(parameters.clone()).intern(Interner);\n-        deref_chain.push(Canonical { value: unsized_ty, binders });\n-        adjustments.push(ReceiverAdjustments { unsize_array: true, ..adj });\n+        deref_chain.push((\n+            Canonical { value: unsized_ty, binders },\n+            ReceiverAdjustments { unsize_array: true, ..adj.clone() },\n+        ));\n     }\n-    (deref_chain, adjustments)\n+    deref_chain\n }"}, {"sha": "7c1cbbdf53d27f40ecfa8c54b9d1f917b3cbd8ce", "filename": "crates/hir-ty/src/mir.rs", "status": "added", "additions": 863, "deletions": 0, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,863 @@\n+//! MIR definitions and implementation\n+\n+use std::{fmt::Display, iter};\n+\n+use crate::{\n+    infer::PointerCast, Const, ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty,\n+};\n+use chalk_ir::Mutability;\n+use hir_def::{\n+    expr::{BindingId, Expr, ExprId, Ordering, PatId},\n+    DefWithBodyId, FieldId, UnionId, VariantId,\n+};\n+use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n+\n+mod eval;\n+mod lower;\n+mod borrowck;\n+mod pretty;\n+\n+pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n+pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n+pub use lower::{lower_to_mir, mir_body_query, mir_body_recover, MirLowerError};\n+use smallvec::{smallvec, SmallVec};\n+use stdx::impl_from;\n+\n+use super::consteval::{intern_const_scalar, try_const_usize};\n+\n+pub type BasicBlockId = Idx<BasicBlock>;\n+pub type LocalId = Idx<Local>;\n+\n+fn return_slot() -> LocalId {\n+    LocalId::from_raw(RawIdx::from(0))\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Local {\n+    pub ty: Ty,\n+}\n+\n+/// An operand in MIR represents a \"value\" in Rust, the definition of which is undecided and part of\n+/// the memory model. One proposal for a definition of values can be found [on UCG][value-def].\n+///\n+/// [value-def]: https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/value-domain.md\n+///\n+/// The most common way to create values is via loading a place. Loading a place is an operation\n+/// which reads the memory of the place and converts it to a value. This is a fundamentally *typed*\n+/// operation. The nature of the value produced depends on the type of the conversion. Furthermore,\n+/// there may be other effects: if the type has a validity constraint loading the place might be UB\n+/// if the validity constraint is not met.\n+///\n+/// **Needs clarification:** Ralf proposes that loading a place not have side-effects.\n+/// This is what is implemented in miri today. Are these the semantics we want for MIR? Is this\n+/// something we can even decide without knowing more about Rust's memory model?\n+///\n+/// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n+/// currently implements it, but it seems like this may be something to check against in the\n+/// validator.\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Operand {\n+    /// Creates a value by loading the given place.\n+    ///\n+    /// Before drop elaboration, the type of the place must be `Copy`. After drop elaboration there\n+    /// is no such requirement.\n+    Copy(Place),\n+\n+    /// Creates a value by performing loading the place, just like the `Copy` operand.\n+    ///\n+    /// This *may* additionally overwrite the place with `uninit` bytes, depending on how we decide\n+    /// in [UCG#188]. You should not emit MIR that may attempt a subsequent second load of this\n+    /// place without first re-initializing it.\n+    ///\n+    /// [UCG#188]: https://github.com/rust-lang/unsafe-code-guidelines/issues/188\n+    Move(Place),\n+    /// Constants are already semantically values, and remain unchanged.\n+    Constant(Const),\n+}\n+\n+impl Operand {\n+    fn from_concrete_const(data: Vec<u8>, memory_map: MemoryMap, ty: Ty) -> Self {\n+        Operand::Constant(intern_const_scalar(ConstScalar::Bytes(data, memory_map), ty))\n+    }\n+\n+    fn from_bytes(data: Vec<u8>, ty: Ty) -> Self {\n+        Operand::from_concrete_const(data, MemoryMap::default(), ty)\n+    }\n+\n+    fn const_zst(ty: Ty) -> Operand {\n+        Self::from_bytes(vec![], ty)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum ProjectionElem<V, T> {\n+    Deref,\n+    Field(FieldId),\n+    TupleField(usize),\n+    Index(V),\n+    ConstantIndex { offset: u64, min_length: u64, from_end: bool },\n+    Subslice { from: u64, to: u64, from_end: bool },\n+    //Downcast(Option<Symbol>, VariantIdx),\n+    OpaqueCast(T),\n+}\n+\n+type PlaceElem = ProjectionElem<LocalId, Ty>;\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Place {\n+    pub local: LocalId,\n+    pub projection: Vec<PlaceElem>,\n+}\n+\n+impl From<LocalId> for Place {\n+    fn from(local: LocalId) -> Self {\n+        Self { local, projection: vec![] }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum AggregateKind {\n+    /// The type is of the element\n+    Array(Ty),\n+    /// The type is of the tuple\n+    Tuple(Ty),\n+    Adt(VariantId, Substitution),\n+    Union(UnionId, FieldId),\n+    //Closure(LocalDefId, SubstsRef),\n+    //Generator(LocalDefId, SubstsRef, Movability),\n+}\n+\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n+pub struct SwitchTargets {\n+    /// Possible values. The locations to branch to in each case\n+    /// are found in the corresponding indices from the `targets` vector.\n+    values: SmallVec<[u128; 1]>,\n+\n+    /// Possible branch sites. The last element of this vector is used\n+    /// for the otherwise branch, so targets.len() == values.len() + 1\n+    /// should hold.\n+    //\n+    // This invariant is quite non-obvious and also could be improved.\n+    // One way to make this invariant is to have something like this instead:\n+    //\n+    // branches: Vec<(ConstInt, BasicBlock)>,\n+    // otherwise: Option<BasicBlock> // exhaustive if None\n+    //\n+    // However we\u2019ve decided to keep this as-is until we figure a case\n+    // where some other approach seems to be strictly better than other.\n+    targets: SmallVec<[BasicBlockId; 2]>,\n+}\n+\n+impl SwitchTargets {\n+    /// Creates switch targets from an iterator of values and target blocks.\n+    ///\n+    /// The iterator may be empty, in which case the `SwitchInt` instruction is equivalent to\n+    /// `goto otherwise;`.\n+    pub fn new(\n+        targets: impl Iterator<Item = (u128, BasicBlockId)>,\n+        otherwise: BasicBlockId,\n+    ) -> Self {\n+        let (values, mut targets): (SmallVec<_>, SmallVec<_>) = targets.unzip();\n+        targets.push(otherwise);\n+        Self { values, targets }\n+    }\n+\n+    /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,\n+    /// and to `else_` if not.\n+    pub fn static_if(value: u128, then: BasicBlockId, else_: BasicBlockId) -> Self {\n+        Self { values: smallvec![value], targets: smallvec![then, else_] }\n+    }\n+\n+    /// Returns the fallback target that is jumped to when none of the values match the operand.\n+    pub fn otherwise(&self) -> BasicBlockId {\n+        *self.targets.last().unwrap()\n+    }\n+\n+    /// Returns an iterator over the switch targets.\n+    ///\n+    /// The iterator will yield tuples containing the value and corresponding target to jump to, not\n+    /// including the `otherwise` fallback target.\n+    ///\n+    /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n+    pub fn iter(&self) -> impl Iterator<Item = (u128, BasicBlockId)> + '_ {\n+        iter::zip(&self.values, &self.targets).map(|(x, y)| (*x, *y))\n+    }\n+\n+    /// Returns a slice with all possible jump targets (including the fallback target).\n+    pub fn all_targets(&self) -> &[BasicBlockId] {\n+        &self.targets\n+    }\n+\n+    /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n+    /// specific value. This cannot fail, as it'll return the `otherwise`\n+    /// branch if there's not a specific match for the value.\n+    pub fn target_for_value(&self, value: u128) -> BasicBlockId {\n+        self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Terminator {\n+    /// Block has one successor; we continue execution there.\n+    Goto { target: BasicBlockId },\n+\n+    /// Switches based on the computed value.\n+    ///\n+    /// First, evaluates the `discr` operand. The type of the operand must be a signed or unsigned\n+    /// integer, char, or bool, and must match the given type. Then, if the list of switch targets\n+    /// contains the computed value, continues execution at the associated basic block. Otherwise,\n+    /// continues execution at the \"otherwise\" basic block.\n+    ///\n+    /// Target values may not appear more than once.\n+    SwitchInt {\n+        /// The discriminant value being tested.\n+        discr: Operand,\n+\n+        targets: SwitchTargets,\n+    },\n+\n+    /// Indicates that the landing pad is finished and that the process should continue unwinding.\n+    ///\n+    /// Like a return, this marks the end of this invocation of the function.\n+    ///\n+    /// Only permitted in cleanup blocks. `Resume` is not permitted with `-C unwind=abort` after\n+    /// deaggregation runs.\n+    Resume,\n+\n+    /// Indicates that the landing pad is finished and that the process should abort.\n+    ///\n+    /// Used to prevent unwinding for foreign items or with `-C unwind=abort`. Only permitted in\n+    /// cleanup blocks.\n+    Abort,\n+\n+    /// Returns from the function.\n+    ///\n+    /// Like function calls, the exact semantics of returns in Rust are unclear. Returning very\n+    /// likely at least assigns the value currently in the return place (`_0`) to the place\n+    /// specified in the associated `Call` terminator in the calling function, as if assigned via\n+    /// `dest = move _0`. It might additionally do other things, like have side-effects in the\n+    /// aliasing model.\n+    ///\n+    /// If the body is a generator body, this has slightly different semantics; it instead causes a\n+    /// `GeneratorState::Returned(_0)` to be created (as if by an `Aggregate` rvalue) and assigned\n+    /// to the return place.\n+    Return,\n+\n+    /// Indicates a terminator that can never be reached.\n+    ///\n+    /// Executing this terminator is UB.\n+    Unreachable,\n+\n+    /// The behavior of this statement differs significantly before and after drop elaboration.\n+    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n+    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n+    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n+    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n+    /// call?)\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n+    /// `Drop` will be executed if...\n+    ///\n+    /// **Needs clarification**: End of that sentence. This in effect should document the exact\n+    /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:\n+    ///\n+    /// > The drop glue is executed if, among all statements executed within this `Body`, an assignment to\n+    /// > the place or one of its \"parents\" occurred more recently than a move out of it. This does not\n+    /// > consider indirect assignments.\n+    Drop { place: Place, target: BasicBlockId, unwind: Option<BasicBlockId> },\n+\n+    /// Drops the place and assigns a new value to it.\n+    ///\n+    /// This first performs the exact same operation as the pre drop-elaboration `Drop` terminator;\n+    /// it then additionally assigns the `value` to the `place` as if by an assignment statement.\n+    /// This assignment occurs both in the unwind and the regular code paths. The semantics are best\n+    /// explained by the elaboration:\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n+    /// }\n+    /// ```\n+    ///\n+    /// becomes\n+    ///\n+    /// ```ignore (MIR)\n+    /// BB0 {\n+    ///   Drop(P, goto BB1, unwind BB2)\n+    /// }\n+    /// BB1 {\n+    ///   // P is now uninitialized\n+    ///   P <- V\n+    /// }\n+    /// BB2 {\n+    ///   // P is now uninitialized -- its dtor panicked\n+    ///   P <- V\n+    /// }\n+    /// ```\n+    ///\n+    /// Disallowed after drop elaboration.\n+    DropAndReplace {\n+        place: Place,\n+        value: Operand,\n+        target: BasicBlockId,\n+        unwind: Option<BasicBlockId>,\n+    },\n+\n+    /// Roughly speaking, evaluates the `func` operand and the arguments, and starts execution of\n+    /// the referred to function. The operand types must match the argument types of the function.\n+    /// The return place type must match the return type. The type of the `func` operand must be\n+    /// callable, meaning either a function pointer, a function type, or a closure type.\n+    ///\n+    /// **Needs clarification**: The exact semantics of this. Current backends rely on `move`\n+    /// operands not aliasing the return place. It is unclear how this is justified in MIR, see\n+    /// [#71117].\n+    ///\n+    /// [#71117]: https://github.com/rust-lang/rust/issues/71117\n+    Call {\n+        /// The function that\u2019s being called.\n+        func: Operand,\n+        /// Arguments the function is called with.\n+        /// These are owned by the callee, which is free to modify them.\n+        /// This allows the memory occupied by \"by-value\" arguments to be\n+        /// reused across function calls without duplicating the contents.\n+        args: Vec<Operand>,\n+        /// Where the returned value will be written\n+        destination: Place,\n+        /// Where to go after this call returns. If none, the call necessarily diverges.\n+        target: Option<BasicBlockId>,\n+        /// Cleanups to be done if the call unwinds.\n+        cleanup: Option<BasicBlockId>,\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n+        /// operator. True for overloaded function call.\n+        from_hir_call: bool,\n+        // This `Span` is the span of the function, without the dot and receiver\n+        // (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        //fn_span: Span,\n+    },\n+\n+    /// Evaluates the operand, which must have type `bool`. If it is not equal to `expected`,\n+    /// initiates a panic. Initiating a panic corresponds to a `Call` terminator with some\n+    /// unspecified constant as the function to call, all the operands stored in the `AssertMessage`\n+    /// as parameters, and `None` for the destination. Keep in mind that the `cleanup` path is not\n+    /// necessarily executed even in the case of a panic, for example in `-C panic=abort`. If the\n+    /// assertion does not fail, execution continues at the specified basic block.\n+    Assert {\n+        cond: Operand,\n+        expected: bool,\n+        //msg: AssertMessage,\n+        target: BasicBlockId,\n+        cleanup: Option<BasicBlockId>,\n+    },\n+\n+    /// Marks a suspend point.\n+    ///\n+    /// Like `Return` terminators in generator bodies, this computes `value` and then a\n+    /// `GeneratorState::Yielded(value)` as if by `Aggregate` rvalue. That value is then assigned to\n+    /// the return place of the function calling this one, and execution continues in the calling\n+    /// function. When next invoked with the same first argument, execution of this function\n+    /// continues at the `resume` basic block, with the second argument written to the `resume_arg`\n+    /// place. If the generator is dropped before then, the `drop` basic block is invoked.\n+    ///\n+    /// Not permitted in bodies that are not generator bodies, or after generator lowering.\n+    ///\n+    /// **Needs clarification**: What about the evaluation order of the `resume_arg` and `value`?\n+    Yield {\n+        /// The value to return.\n+        value: Operand,\n+        /// Where to resume to.\n+        resume: BasicBlockId,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place,\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n+        drop: Option<BasicBlockId>,\n+    },\n+\n+    /// Indicates the end of dropping a generator.\n+    ///\n+    /// Semantically just a `return` (from the generators drop glue). Only permitted in the same situations\n+    /// as `yield`.\n+    ///\n+    /// **Needs clarification**: Is that even correct? The generator drop code is always confusing\n+    /// to me, because it's not even really in the current body.\n+    ///\n+    /// **Needs clarification**: Are there type system constraints on these terminators? Should\n+    /// there be a \"block type\" like `cleanup` blocks for them?\n+    GeneratorDrop,\n+\n+    /// A block where control flow only ever takes one real path, but borrowck needs to be more\n+    /// conservative.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseEdge {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlockId,\n+        /// A block control flow could conceptually jump to, but won't in\n+        /// practice.\n+        imaginary_target: BasicBlockId,\n+    },\n+\n+    /// A terminator for blocks that only take one path in reality, but where we reserve the right\n+    /// to unwind in borrowck, even if it won't happen in practice. This can arise in infinite loops\n+    /// with no function calls for example.\n+    ///\n+    /// At runtime this is semantically just a goto.\n+    ///\n+    /// Disallowed after drop elaboration.\n+    FalseUnwind {\n+        /// The target normal control flow will take.\n+        real_target: BasicBlockId,\n+        /// The imaginary cleanup block link. This particular path will never be taken\n+        /// in practice, but in order to avoid fragility we want to always\n+        /// consider it in borrowck. We don't want to accept programs which\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `abort_unwinding_calls` passes.\n+        unwind: Option<BasicBlockId>,\n+    },\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    Shared,\n+\n+    /// The immediately borrowed place must be immutable, but projections from\n+    /// it don't need to be. For example, a shallow borrow of `a.b` doesn't\n+    /// conflict with a mutable borrow of `a.b.c`.\n+    ///\n+    /// This is used when lowering matches: when matching on a place we want to\n+    /// ensure that place have the same value from the start of the match until\n+    /// an arm is selected. This prevents this code from compiling:\n+    /// ```compile_fail,E0510\n+    /// let mut x = &Some(0);\n+    /// match *x {\n+    ///     None => (),\n+    ///     Some(_) if { x = &None; false } => (),\n+    ///     Some(_) => (),\n+    /// }\n+    /// ```\n+    /// This can't be a shared borrow because mutably borrowing (*x as Some).0\n+    /// should not prevent `if let None = x { ... }`, for example, because the\n+    /// mutating `(*x as Some).0` can't affect the discriminant of `x`.\n+    /// We can also report errors with this kind of borrow differently.\n+    Shallow,\n+\n+    /// Data must be immutable but not aliasable. This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when the closure is\n+    /// borrowing or mutating a mutable referent, e.g.:\n+    /// ```\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = || *x += 5;\n+    /// ```\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    /// ```compile_fail,E0594\n+    /// struct Env<'a> { x: &'a &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &x }, fn_ptr);  // Closure is pair of env and fn\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// This is then illegal because you cannot mutate an `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    /// ```compile_fail,E0596\n+    /// struct Env<'a> { x: &'a mut &'a mut isize }\n+    /// let mut z = 3;\n+    /// let x: &mut isize = &mut z;\n+    /// let y = (&mut Env { x: &mut x }, fn_ptr); // changed from &x to &mut x\n+    /// fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    /// ```\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    Unique,\n+\n+    /// Data is mutable and not aliasable.\n+    Mut {\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n+        allow_two_phase_borrow: bool,\n+    },\n+}\n+\n+impl BorrowKind {\n+    fn from_hir(m: hir_def::type_ref::Mutability) -> Self {\n+        match m {\n+            hir_def::type_ref::Mutability::Shared => BorrowKind::Shared,\n+            hir_def::type_ref::Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        }\n+    }\n+\n+    fn from_chalk(m: Mutability) -> Self {\n+        match m {\n+            Mutability::Not => BorrowKind::Shared,\n+            Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum UnOp {\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum BinOp {\n+    /// The `+` operator (addition)\n+    Add,\n+    /// The `-` operator (subtraction)\n+    Sub,\n+    /// The `*` operator (multiplication)\n+    Mul,\n+    /// The `/` operator (division)\n+    ///\n+    /// Division by zero is UB, because the compiler should have inserted checks\n+    /// prior to this.\n+    Div,\n+    /// The `%` operator (modulus)\n+    ///\n+    /// Using zero as the modulus (second operand) is UB, because the compiler\n+    /// should have inserted checks prior to this.\n+    Rem,\n+    /// The `^` operator (bitwise xor)\n+    BitXor,\n+    /// The `&` operator (bitwise and)\n+    BitAnd,\n+    /// The `|` operator (bitwise or)\n+    BitOr,\n+    /// The `<<` operator (shift left)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shl,\n+    /// The `>>` operator (shift right)\n+    ///\n+    /// The offset is truncated to the size of the first operand before shifting.\n+    Shr,\n+    /// The `==` operator (equality)\n+    Eq,\n+    /// The `<` operator (less than)\n+    Lt,\n+    /// The `<=` operator (less than or equal to)\n+    Le,\n+    /// The `!=` operator (not equal to)\n+    Ne,\n+    /// The `>=` operator (greater than or equal to)\n+    Ge,\n+    /// The `>` operator (greater than)\n+    Gt,\n+    /// The `ptr.offset` operator\n+    Offset,\n+}\n+\n+impl Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.write_str(match self {\n+            BinOp::Add => \"+\",\n+            BinOp::Sub => \"-\",\n+            BinOp::Mul => \"*\",\n+            BinOp::Div => \"/\",\n+            BinOp::Rem => \"%\",\n+            BinOp::BitXor => \"^\",\n+            BinOp::BitAnd => \"&\",\n+            BinOp::BitOr => \"|\",\n+            BinOp::Shl => \"<<\",\n+            BinOp::Shr => \">>\",\n+            BinOp::Eq => \"==\",\n+            BinOp::Lt => \"<\",\n+            BinOp::Le => \"<=\",\n+            BinOp::Ne => \"!=\",\n+            BinOp::Ge => \">=\",\n+            BinOp::Gt => \">\",\n+            BinOp::Offset => \"`offset`\",\n+        })\n+    }\n+}\n+\n+impl From<hir_def::expr::ArithOp> for BinOp {\n+    fn from(value: hir_def::expr::ArithOp) -> Self {\n+        match value {\n+            hir_def::expr::ArithOp::Add => BinOp::Add,\n+            hir_def::expr::ArithOp::Mul => BinOp::Mul,\n+            hir_def::expr::ArithOp::Sub => BinOp::Sub,\n+            hir_def::expr::ArithOp::Div => BinOp::Div,\n+            hir_def::expr::ArithOp::Rem => BinOp::Rem,\n+            hir_def::expr::ArithOp::Shl => BinOp::Shl,\n+            hir_def::expr::ArithOp::Shr => BinOp::Shr,\n+            hir_def::expr::ArithOp::BitXor => BinOp::BitXor,\n+            hir_def::expr::ArithOp::BitOr => BinOp::BitOr,\n+            hir_def::expr::ArithOp::BitAnd => BinOp::BitAnd,\n+        }\n+    }\n+}\n+\n+impl From<hir_def::expr::CmpOp> for BinOp {\n+    fn from(value: hir_def::expr::CmpOp) -> Self {\n+        match value {\n+            hir_def::expr::CmpOp::Eq { negated: false } => BinOp::Eq,\n+            hir_def::expr::CmpOp::Eq { negated: true } => BinOp::Ne,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: false } => BinOp::Ge,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Greater, strict: true } => BinOp::Gt,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: false } => BinOp::Le,\n+            hir_def::expr::CmpOp::Ord { ordering: Ordering::Less, strict: true } => BinOp::Lt,\n+        }\n+    }\n+}\n+\n+impl From<Operand> for Rvalue {\n+    fn from(x: Operand) -> Self {\n+        Self::Use(x)\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum CastKind {\n+    /// An exposing pointer to address cast. A cast between a pointer and an integer type, or\n+    /// between a function pointer and an integer type.\n+    /// See the docs on `expose_addr` for more details.\n+    PointerExposeAddress,\n+    /// An address-to-pointer cast that picks up an exposed provenance.\n+    /// See the docs on `from_exposed_addr` for more details.\n+    PointerFromExposedAddress,\n+    /// All sorts of pointer-to-pointer casts. Note that reference-to-raw-ptr casts are\n+    /// translated into `&raw mut/const *r`, i.e., they are not actually casts.\n+    Pointer(PointerCast),\n+    /// Cast into a dyn* object.\n+    DynStar,\n+    IntToInt,\n+    FloatToInt,\n+    FloatToFloat,\n+    IntToFloat,\n+    PtrToPtr,\n+    FnPtrToPtr,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum Rvalue {\n+    /// Yields the operand unchanged\n+    Use(Operand),\n+\n+    /// Creates an array where each element is the value of the operand.\n+    ///\n+    /// This is the cause of a bug in the case where the repetition count is zero because the value\n+    /// is not dropped, see [#74836].\n+    ///\n+    /// Corresponds to source code like `[x; 32]`.\n+    ///\n+    /// [#74836]: https://github.com/rust-lang/rust/issues/74836\n+    //Repeat(Operand, ty::Const),\n+\n+    /// Creates a reference of the indicated kind to the place.\n+    ///\n+    /// There is not much to document here, because besides the obvious parts the semantics of this\n+    /// are essentially entirely a part of the aliasing model. There are many UCG issues discussing\n+    /// exactly what the behavior of this operation should be.\n+    ///\n+    /// `Shallow` borrows are disallowed after drop lowering.\n+    Ref(BorrowKind, Place),\n+\n+    /// Creates a pointer/reference to the given thread local.\n+    ///\n+    /// The yielded type is a `*mut T` if the static is mutable, otherwise if the static is extern a\n+    /// `*const T`, and if neither of those apply a `&T`.\n+    ///\n+    /// **Note:** This is a runtime operation that actually executes code and is in this sense more\n+    /// like a function call. Also, eliminating dead stores of this rvalue causes `fn main() {}` to\n+    /// SIGILL for some reason that I (JakobDegen) never got a chance to look into.\n+    ///\n+    /// **Needs clarification**: Are there weird additional semantics here related to the runtime\n+    /// nature of this operation?\n+    //ThreadLocalRef(DefId),\n+\n+    /// Creates a pointer with the indicated mutability to the place.\n+    ///\n+    /// This is generated by pointer casts like `&v as *const _` or raw address of expressions like\n+    /// `&raw v` or `addr_of!(v)`.\n+    ///\n+    /// Like with references, the semantics of this operation are heavily dependent on the aliasing\n+    /// model.\n+    //AddressOf(Mutability, Place),\n+\n+    /// Yields the length of the place, as a `usize`.\n+    ///\n+    /// If the type of the place is an array, this is the array length. For slices (`[T]`, not\n+    /// `&[T]`) this accesses the place's metadata to determine the length. This rvalue is\n+    /// ill-formed for places of other types.\n+    Len(Place),\n+\n+    /// Performs essentially all of the casts that can be performed via `as`.\n+    ///\n+    /// This allows for casts from/to a variety of types.\n+    ///\n+    /// **FIXME**: Document exactly which `CastKind`s allow which types of casts. Figure out why\n+    /// `ArrayToPointer` and `MutToConstPointer` are special.\n+    Cast(CastKind, Operand, Ty),\n+\n+    // FIXME link to `pointer::offset` when it hits stable.\n+    /// * `Offset` has the same semantics as `pointer::offset`, except that the second\n+    ///   parameter may be a `usize` as well.\n+    /// * The comparison operations accept `bool`s, `char`s, signed or unsigned integers, floats,\n+    ///   raw pointers, or function pointers and return a `bool`. The types of the operands must be\n+    ///   matching, up to the usual caveat of the lifetimes in function pointers.\n+    /// * Left and right shift operations accept signed or unsigned integers not necessarily of the\n+    ///   same type and return a value of the same type as their LHS. Like in Rust, the RHS is\n+    ///   truncated as needed.\n+    /// * The `Bit*` operations accept signed integers, unsigned integers, or bools with matching\n+    ///   types and return a value of that type.\n+    /// * The remaining operations accept signed integers, unsigned integers, or floats with\n+    ///   matching types and return a value of that type.\n+    //BinaryOp(BinOp, Box<(Operand, Operand)>),\n+\n+    /// Same as `BinaryOp`, but yields `(T, bool)` with a `bool` indicating an error condition.\n+    ///\n+    /// When overflow checking is disabled and we are generating run-time code, the error condition\n+    /// is false. Otherwise, and always during CTFE, the error condition is determined as described\n+    /// below.\n+    ///\n+    /// For addition, subtraction, and multiplication on integers the error condition is set when\n+    /// the infinite precision result would be unequal to the actual result.\n+    ///\n+    /// For shift operations on integers the error condition is set when the value of right-hand\n+    /// side is greater than or equal to the number of bits in the type of the left-hand side, or\n+    /// when the value of right-hand side is negative.\n+    ///\n+    /// Other combinations of types and operators are unsupported.\n+    CheckedBinaryOp(BinOp, Operand, Operand),\n+\n+    /// Computes a value as described by the operation.\n+    //NullaryOp(NullOp, Ty),\n+\n+    /// Exactly like `BinaryOp`, but less operands.\n+    ///\n+    /// Also does two's-complement arithmetic. Negation requires a signed integer or a float;\n+    /// bitwise not requires a signed integer, unsigned integer, or bool. Both operation kinds\n+    /// return a value with the same type as their operand.\n+    UnaryOp(UnOp, Operand),\n+\n+    /// Computes the discriminant of the place, returning it as an integer of type\n+    /// [`discriminant_ty`]. Returns zero for types without discriminant.\n+    ///\n+    /// The validity requirements for the underlying value are undecided for this rvalue, see\n+    /// [#91095]. Note too that the value of the discriminant is not the same thing as the\n+    /// variant index; use [`discriminant_for_variant`] to convert.\n+    ///\n+    /// [`discriminant_ty`]: crate::ty::Ty::discriminant_ty\n+    /// [#91095]: https://github.com/rust-lang/rust/issues/91095\n+    /// [`discriminant_for_variant`]: crate::ty::Ty::discriminant_for_variant\n+    Discriminant(Place),\n+\n+    /// Creates an aggregate value, like a tuple or struct.\n+    ///\n+    /// This is needed because dataflow analysis needs to distinguish\n+    /// `dest = Foo { x: ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case that `Foo`\n+    /// has a destructor.\n+    ///\n+    /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n+    /// generator lowering, `Generator` aggregate kinds are disallowed too.\n+    Aggregate(AggregateKind, Vec<Operand>),\n+\n+    /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n+    ///\n+    /// This is different from a normal transmute because dataflow analysis will treat the box as\n+    /// initialized but its content as uninitialized. Like other pointer casts, this in general\n+    /// affects alias analysis.\n+    ShallowInitBox(Operand, Ty),\n+\n+    /// A CopyForDeref is equivalent to a read from a place at the\n+    /// codegen level, but is treated specially by drop elaboration. When such a read happens, it\n+    /// is guaranteed (via nature of the mir_opt `Derefer` in rustc_mir_transform/src/deref_separator)\n+    /// that the only use of the returned value is a deref operation, immediately\n+    /// followed by one or more projections. Drop elaboration treats this rvalue as if the\n+    /// read never happened and just projects further. This allows simplifying various MIR\n+    /// optimizations and codegen backends that previously had to handle deref operations anywhere\n+    /// in a place.\n+    CopyForDeref(Place),\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum StatementKind {\n+    Assign(Place, Rvalue),\n+    //FakeRead(Box<(FakeReadCause, Place)>),\n+    //SetDiscriminant {\n+    //    place: Box<Place>,\n+    //    variant_index: VariantIdx,\n+    //},\n+    Deinit(Place),\n+    StorageLive(LocalId),\n+    StorageDead(LocalId),\n+    //Retag(RetagKind, Box<Place>),\n+    //AscribeUserType(Place, UserTypeProjection, Variance),\n+    //Intrinsic(Box<NonDivergingIntrinsic>),\n+    Nop,\n+}\n+impl StatementKind {\n+    fn with_span(self, span: MirSpan) -> Statement {\n+        Statement { kind: self, span }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub struct Statement {\n+    pub kind: StatementKind,\n+    pub span: MirSpan,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct BasicBlock {\n+    /// List of statements in this block.\n+    pub statements: Vec<Statement>,\n+\n+    /// Terminator for this block.\n+    ///\n+    /// N.B., this should generally ONLY be `None` during construction.\n+    /// Therefore, you should generally access it via the\n+    /// `terminator()` or `terminator_mut()` methods. The only\n+    /// exception is that certain passes, such as `simplify_cfg`, swap\n+    /// out the terminator temporarily with `None` while they continue\n+    /// to recurse over the set of basic blocks.\n+    pub terminator: Option<Terminator>,\n+\n+    /// If true, this block lies on an unwind path. This is used\n+    /// during codegen where distinct kinds of basic blocks may be\n+    /// generated (particularly for MSVC cleanup). Unwind blocks must\n+    /// only branch to other unwind blocks.\n+    pub is_cleanup: bool,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct MirBody {\n+    pub basic_blocks: Arena<BasicBlock>,\n+    pub locals: Arena<Local>,\n+    pub start_block: BasicBlockId,\n+    pub owner: DefWithBodyId,\n+    pub arg_count: usize,\n+    pub binding_locals: ArenaMap<BindingId, LocalId>,\n+    pub param_locals: Vec<LocalId>,\n+}\n+\n+fn const_as_usize(c: &Const) -> usize {\n+    try_const_usize(c).unwrap() as usize\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum MirSpan {\n+    ExprId(ExprId),\n+    PatId(PatId),\n+    Unknown,\n+}\n+\n+impl_from!(ExprId, PatId for MirSpan);"}, {"sha": "c8729af86a9eaf11f5ac974ca1d6ae51d6722921", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,223 @@\n+//! MIR borrow checker, which is used in diagnostics like `unused_mut`\n+\n+// Currently it is an ad-hoc implementation, only useful for mutability analysis. Feel free to remove all of these\n+// if needed for implementing a proper borrow checker.\n+\n+use std::sync::Arc;\n+\n+use hir_def::DefWithBodyId;\n+use la_arena::ArenaMap;\n+use stdx::never;\n+\n+use crate::db::HirDatabase;\n+\n+use super::{\n+    BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n+    Rvalue, StatementKind, Terminator,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+/// Stores spans which implies that the local should be mutable.\n+pub enum MutabilityReason {\n+    Mut { spans: Vec<MirSpan> },\n+    Not,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct BorrowckResult {\n+    pub mir_body: Arc<MirBody>,\n+    pub mutability_of_locals: ArenaMap<LocalId, MutabilityReason>,\n+}\n+\n+pub fn borrowck_query(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Result<Arc<BorrowckResult>, MirLowerError> {\n+    let _p = profile::span(\"borrowck_query\");\n+    let body = db.mir_body(def)?;\n+    let r = BorrowckResult { mutability_of_locals: mutability_of_locals(&body), mir_body: body };\n+    Ok(Arc::new(r))\n+}\n+\n+fn is_place_direct(lvalue: &Place) -> bool {\n+    !lvalue.projection.iter().any(|x| *x == ProjectionElem::Deref)\n+}\n+\n+enum ProjectionCase {\n+    /// Projection is a local\n+    Direct,\n+    /// Projection is some field or slice of a local\n+    DirectPart,\n+    /// Projection is deref of something\n+    Indirect,\n+}\n+\n+fn place_case(lvalue: &Place) -> ProjectionCase {\n+    let mut is_part_of = false;\n+    for proj in lvalue.projection.iter().rev() {\n+        match proj {\n+            ProjectionElem::Deref => return ProjectionCase::Indirect, // It's indirect\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Field(_)\n+            | ProjectionElem::TupleField(_)\n+            | ProjectionElem::Index(_) => {\n+                is_part_of = true;\n+            }\n+            ProjectionElem::OpaqueCast(_) => (),\n+        }\n+    }\n+    if is_part_of {\n+        ProjectionCase::DirectPart\n+    } else {\n+        ProjectionCase::Direct\n+    }\n+}\n+\n+/// Returns a map from basic blocks to the set of locals that might be ever initialized before\n+/// the start of the block. Only `StorageDead` can remove something from this map, and we ignore\n+/// `Uninit` and `drop` and similars after initialization.\n+fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> {\n+    let mut result: ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>> =\n+        body.basic_blocks.iter().map(|x| (x.0, ArenaMap::default())).collect();\n+    fn dfs(\n+        body: &MirBody,\n+        b: BasicBlockId,\n+        l: LocalId,\n+        result: &mut ArenaMap<BasicBlockId, ArenaMap<LocalId, bool>>,\n+    ) {\n+        let mut is_ever_initialized = result[b][l]; // It must be filled, as we use it as mark for dfs\n+        let block = &body.basic_blocks[b];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(p, _) => {\n+                    if p.projection.len() == 0 && p.local == l {\n+                        is_ever_initialized = true;\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    if *p == l {\n+                        is_ever_initialized = false;\n+                    }\n+                }\n+                StatementKind::Deinit(_) | StatementKind::Nop | StatementKind::StorageLive(_) => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            return;\n+        };\n+        let targets = match terminator {\n+            Terminator::Goto { target } => vec![*target],\n+            Terminator::SwitchInt { targets, .. } => targets.all_targets().to_vec(),\n+            Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable => vec![],\n+            Terminator::Call { target, cleanup, destination, .. } => {\n+                if destination.projection.len() == 0 && destination.local == l {\n+                    is_ever_initialized = true;\n+                }\n+                target.into_iter().chain(cleanup.into_iter()).copied().collect()\n+            }\n+            Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. } => {\n+                never!(\"We don't emit these MIR terminators yet\");\n+                vec![]\n+            }\n+        };\n+        for target in targets {\n+            if !result[target].contains_idx(l) || !result[target][l] && is_ever_initialized {\n+                result[target].insert(l, is_ever_initialized);\n+                dfs(body, target, l, result);\n+            }\n+        }\n+    }\n+    for &l in &body.param_locals {\n+        result[body.start_block].insert(l, true);\n+        dfs(body, body.start_block, l, &mut result);\n+    }\n+    for l in body.locals.iter().map(|x| x.0) {\n+        if !result[body.start_block].contains_idx(l) {\n+            result[body.start_block].insert(l, false);\n+            dfs(body, body.start_block, l, &mut result);\n+        }\n+    }\n+    result\n+}\n+\n+fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n+    let mut result: ArenaMap<LocalId, MutabilityReason> =\n+        body.locals.iter().map(|x| (x.0, MutabilityReason::Not)).collect();\n+    let mut push_mut_span = |local, span| match &mut result[local] {\n+        MutabilityReason::Mut { spans } => spans.push(span),\n+        x @ MutabilityReason::Not => *x = MutabilityReason::Mut { spans: vec![span] },\n+    };\n+    let ever_init_maps = ever_initialized_map(body);\n+    for (block_id, mut ever_init_map) in ever_init_maps.into_iter() {\n+        let block = &body.basic_blocks[block_id];\n+        for statement in &block.statements {\n+            match &statement.kind {\n+                StatementKind::Assign(place, value) => {\n+                    match place_case(place) {\n+                        ProjectionCase::Direct => {\n+                            if ever_init_map.get(place.local).copied().unwrap_or_default() {\n+                                push_mut_span(place.local, statement.span);\n+                            } else {\n+                                ever_init_map.insert(place.local, true);\n+                            }\n+                        }\n+                        ProjectionCase::DirectPart => {\n+                            // Partial initialization is not supported, so it is definitely `mut`\n+                            push_mut_span(place.local, statement.span);\n+                        }\n+                        ProjectionCase::Indirect => (),\n+                    }\n+                    if let Rvalue::Ref(BorrowKind::Mut { .. }, p) = value {\n+                        if is_place_direct(p) {\n+                            push_mut_span(p.local, statement.span);\n+                        }\n+                    }\n+                }\n+                StatementKind::StorageDead(p) => {\n+                    ever_init_map.insert(*p, false);\n+                }\n+                StatementKind::Deinit(_) | StatementKind::StorageLive(_) | StatementKind::Nop => (),\n+            }\n+        }\n+        let Some(terminator) = &block.terminator else {\n+            never!(\"Terminator should be none only in construction\");\n+            continue;\n+        };\n+        match terminator {\n+            Terminator::Goto { .. }\n+            | Terminator::Resume\n+            | Terminator::Abort\n+            | Terminator::Return\n+            | Terminator::Unreachable\n+            | Terminator::FalseEdge { .. }\n+            | Terminator::FalseUnwind { .. }\n+            | Terminator::GeneratorDrop\n+            | Terminator::SwitchInt { .. }\n+            | Terminator::Drop { .. }\n+            | Terminator::DropAndReplace { .. }\n+            | Terminator::Assert { .. }\n+            | Terminator::Yield { .. } => (),\n+            Terminator::Call { destination, .. } => {\n+                if destination.projection.len() == 0 {\n+                    if ever_init_map.get(destination.local).copied().unwrap_or_default() {\n+                        push_mut_span(destination.local, MirSpan::Unknown);\n+                    } else {\n+                        ever_init_map.insert(destination.local, true);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    result\n+}"}, {"sha": "c5d843d9ebd8975a1098c6e8555ecac18fbc76fd", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "added", "additions": 1253, "deletions": 0, "changes": 1253, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,1253 @@\n+//! This module provides a MIR interpreter, which is used in const eval.\n+\n+use std::{borrow::Cow, collections::HashMap, iter};\n+\n+use base_db::CrateId;\n+use chalk_ir::{\n+    fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n+    DebruijnIndex, TyKind,\n+};\n+use hir_def::{\n+    builtin_type::BuiltinType,\n+    lang_item::{lang_attr, LangItem},\n+    layout::{Layout, LayoutError, RustcEnumVariantIdx, TagEncoding, Variants},\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, Lookup, VariantId,\n+};\n+use intern::Interned;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    consteval::{intern_const_scalar, ConstEvalError},\n+    db::HirDatabase,\n+    from_placeholder_idx,\n+    infer::{normalize, PointerCast},\n+    layout::layout_of_ty,\n+    mapping::from_chalk,\n+    method_resolution::lookup_impl_method,\n+    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, Ty, TyBuilder, TyExt,\n+};\n+\n+use super::{\n+    const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n+    Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n+};\n+\n+pub struct Evaluator<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<u8>,\n+    heap: Vec<u8>,\n+    crate_id: CrateId,\n+    // FIXME: This is a workaround, see the comment on `interpret_mir`\n+    assert_placeholder_ty_is_unused: bool,\n+    /// A general limit on execution, to prevent non terminating programs from breaking r-a main process\n+    execution_limit: usize,\n+    /// An additional limit on stack depth, to prevent stack overflow\n+    stack_depth_limit: usize,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum Address {\n+    Stack(usize),\n+    Heap(usize),\n+}\n+\n+use Address::*;\n+\n+struct Interval {\n+    addr: Address,\n+    size: usize,\n+}\n+\n+impl Interval {\n+    fn new(addr: Address, size: usize) -> Self {\n+        Self { addr, size }\n+    }\n+\n+    fn get<'a>(&self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n+        memory.read_memory(self.addr, self.size)\n+    }\n+}\n+\n+enum IntervalOrOwned {\n+    Owned(Vec<u8>),\n+    Borrowed(Interval),\n+}\n+impl IntervalOrOwned {\n+    pub(crate) fn to_vec(self, memory: &Evaluator<'_>) -> Result<Vec<u8>> {\n+        Ok(match self {\n+            IntervalOrOwned::Owned(o) => o,\n+            IntervalOrOwned::Borrowed(b) => b.get(memory)?.to_vec(),\n+        })\n+    }\n+}\n+\n+macro_rules! from_bytes {\n+    ($ty:tt, $value:expr) => {\n+        ($ty::from_le_bytes(match ($value).try_into() {\n+            Ok(x) => x,\n+            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+        }))\n+    };\n+}\n+\n+impl Address {\n+    fn from_bytes(x: &[u8]) -> Result<Self> {\n+        Ok(Address::from_usize(from_bytes!(usize, x)))\n+    }\n+\n+    fn from_usize(x: usize) -> Self {\n+        if x > usize::MAX / 2 {\n+            Stack(usize::MAX - x)\n+        } else {\n+            Heap(x)\n+        }\n+    }\n+\n+    fn to_bytes(&self) -> Vec<u8> {\n+        usize::to_le_bytes(self.to_usize()).to_vec()\n+    }\n+\n+    fn to_usize(&self) -> usize {\n+        let as_num = match self {\n+            Stack(x) => usize::MAX - *x,\n+            Heap(x) => *x,\n+        };\n+        as_num\n+    }\n+\n+    fn map(&self, f: impl FnOnce(usize) -> usize) -> Address {\n+        match self {\n+            Stack(x) => Stack(f(*x)),\n+            Heap(x) => Heap(f(*x)),\n+        }\n+    }\n+\n+    fn offset(&self, offset: usize) -> Address {\n+        self.map(|x| x + offset)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+pub enum MirEvalError {\n+    ConstEvalError(Box<ConstEvalError>),\n+    LayoutError(LayoutError, Ty),\n+    /// Means that code had type errors (or mismatched args) and we shouldn't generate mir in first place.\n+    TypeError(&'static str),\n+    /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n+    /// then use this type of error.\n+    UndefinedBehavior(&'static str),\n+    Panic,\n+    MirLowerError(FunctionId, MirLowerError),\n+    TypeIsUnsized(Ty, &'static str),\n+    NotSupported(String),\n+    InvalidConst(Const),\n+    InFunction(FunctionId, Box<MirEvalError>),\n+    ExecutionLimitExceeded,\n+    StackOverflow,\n+    TargetDataLayoutNotAvailable,\n+}\n+\n+impl std::fmt::Debug for MirEvalError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::ConstEvalError(arg0) => f.debug_tuple(\"ConstEvalError\").field(arg0).finish(),\n+            Self::LayoutError(arg0, arg1) => {\n+                f.debug_tuple(\"LayoutError\").field(arg0).field(arg1).finish()\n+            }\n+            Self::TypeError(arg0) => f.debug_tuple(\"TypeError\").field(arg0).finish(),\n+            Self::UndefinedBehavior(arg0) => {\n+                f.debug_tuple(\"UndefinedBehavior\").field(arg0).finish()\n+            }\n+            Self::Panic => write!(f, \"Panic\"),\n+            Self::TargetDataLayoutNotAvailable => write!(f, \"TargetDataLayoutNotAvailable\"),\n+            Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n+            Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n+            Self::StackOverflow => write!(f, \"stack overflow\"),\n+            Self::MirLowerError(arg0, arg1) => {\n+                f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n+            }\n+            Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n+            Self::InvalidConst(arg0) => {\n+                let data = &arg0.data(Interner);\n+                f.debug_struct(\"InvalidConst\").field(\"ty\", &data.ty).field(\"value\", &arg0).finish()\n+            }\n+            Self::InFunction(func, e) => {\n+                let mut e = &**e;\n+                let mut stack = vec![*func];\n+                while let Self::InFunction(f, next_e) = e {\n+                    e = &next_e;\n+                    stack.push(*f);\n+                }\n+                f.debug_struct(\"WithStack\").field(\"error\", e).field(\"stack\", &stack).finish()\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirEvalError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl From<ConstEvalError> for MirEvalError {\n+    fn from(value: ConstEvalError) -> Self {\n+        match value {\n+            _ => MirEvalError::ConstEvalError(Box::new(value)),\n+        }\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, MirEvalError>;\n+\n+struct Locals<'a> {\n+    ptr: &'a ArenaMap<LocalId, Address>,\n+    body: &'a MirBody,\n+    subst: &'a Substitution,\n+}\n+\n+pub fn interpret_mir(\n+    db: &dyn HirDatabase,\n+    body: &MirBody,\n+    // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now\n+    // they share their body with their parent, so in MIR lowering we have locals of the parent body, which\n+    // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has\n+    // a zero size, hoping that they are all outside of our current body. Even without a fix for #7434, we can\n+    // (and probably should) do better here, for example by excluding bindings outside of the target expression.\n+    assert_placeholder_ty_is_unused: bool,\n+) -> Result<Const> {\n+    let ty = body.locals[return_slot()].ty.clone();\n+    let mut evaluator =\n+        Evaluator::new(db, body.owner.module(db.upcast()).krate(), assert_placeholder_ty_is_unused);\n+    let bytes = evaluator.interpret_mir_with_no_arg(&body)?;\n+    let memory_map = evaluator.create_memory_map(\n+        &bytes,\n+        &ty,\n+        &Locals { ptr: &ArenaMap::new(), body: &body, subst: &Substitution::empty(Interner) },\n+    )?;\n+    return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n+}\n+\n+impl Evaluator<'_> {\n+    pub fn new<'a>(\n+        db: &'a dyn HirDatabase,\n+        crate_id: CrateId,\n+        assert_placeholder_ty_is_unused: bool,\n+    ) -> Evaluator<'a> {\n+        Evaluator {\n+            stack: vec![0],\n+            heap: vec![0],\n+            db,\n+            crate_id,\n+            assert_placeholder_ty_is_unused,\n+            stack_depth_limit: 100,\n+            execution_limit: 100_000,\n+        }\n+    }\n+\n+    fn place_addr(&self, p: &Place, locals: &Locals<'_>) -> Result<Address> {\n+        Ok(self.place_addr_and_ty(p, locals)?.0)\n+    }\n+\n+    fn ptr_size(&self) -> usize {\n+        match self.db.target_data_layout(self.crate_id) {\n+            Some(x) => x.pointer_size.bytes_usize(),\n+            None => 8,\n+        }\n+    }\n+\n+    fn place_addr_and_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<(Address, Ty)> {\n+        let mut addr = locals.ptr[p.local];\n+        let mut ty: Ty =\n+            self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n+        for proj in &p.projection {\n+            match proj {\n+                ProjectionElem::Deref => {\n+                    ty = match &ty.data(Interner).kind {\n+                        TyKind::Raw(_, inner) | TyKind::Ref(_, _, inner) => inner.clone(),\n+                        _ => {\n+                            return Err(MirEvalError::TypeError(\n+                                \"Overloaded deref in MIR is disallowed\",\n+                            ))\n+                        }\n+                    };\n+                    let x = from_bytes!(usize, self.read_memory(addr, self.ptr_size())?);\n+                    addr = Address::from_usize(x);\n+                }\n+                ProjectionElem::Index(op) => {\n+                    let offset =\n+                        from_bytes!(usize, self.read_memory(locals.ptr[*op], self.ptr_size())?);\n+                    match &ty.data(Interner).kind {\n+                        TyKind::Ref(_, _, inner) => match &inner.data(Interner).kind {\n+                            TyKind::Slice(inner) => {\n+                                ty = inner.clone();\n+                                let ty_size = self.size_of_sized(\n+                                    &ty,\n+                                    locals,\n+                                    \"slice inner type should be sized\",\n+                                )?;\n+                                let value = self.read_memory(addr, self.ptr_size() * 2)?;\n+                                addr = Address::from_bytes(&value[0..8])?.offset(ty_size * offset);\n+                            }\n+                            x => not_supported!(\"MIR index for ref type {x:?}\"),\n+                        },\n+                        TyKind::Array(inner, _) | TyKind::Slice(inner) => {\n+                            ty = inner.clone();\n+                            let ty_size = self.size_of_sized(\n+                                &ty,\n+                                locals,\n+                                \"array inner type should be sized\",\n+                            )?;\n+                            addr = addr.offset(ty_size * offset);\n+                        }\n+                        x => not_supported!(\"MIR index for type {x:?}\"),\n+                    }\n+                }\n+                &ProjectionElem::TupleField(f) => match &ty.data(Interner).kind {\n+                    TyKind::Tuple(_, subst) => {\n+                        let layout = self.layout(&ty)?;\n+                        ty = subst\n+                            .as_slice(Interner)\n+                            .get(f)\n+                            .ok_or(MirEvalError::TypeError(\"not enough tuple fields\"))?\n+                            .assert_ty_ref(Interner)\n+                            .clone();\n+                        let offset = layout.fields.offset(f).bytes_usize();\n+                        addr = addr.offset(offset);\n+                    }\n+                    _ => return Err(MirEvalError::TypeError(\"Only tuple has tuple fields\")),\n+                },\n+                ProjectionElem::Field(f) => match &ty.data(Interner).kind {\n+                    TyKind::Adt(adt, subst) => {\n+                        let layout = self.layout_adt(adt.0, subst.clone())?;\n+                        let variant_layout = match &layout.variants {\n+                            Variants::Single { .. } => &layout,\n+                            Variants::Multiple { variants, .. } => {\n+                                &variants[match f.parent {\n+                                    hir_def::VariantId::EnumVariantId(x) => {\n+                                        RustcEnumVariantIdx(x.local_id)\n+                                    }\n+                                    _ => {\n+                                        return Err(MirEvalError::TypeError(\n+                                            \"Multivariant layout only happens for enums\",\n+                                        ))\n+                                    }\n+                                }]\n+                            }\n+                        };\n+                        ty = self.db.field_types(f.parent)[f.local_id]\n+                            .clone()\n+                            .substitute(Interner, subst);\n+                        let offset = variant_layout\n+                            .fields\n+                            .offset(u32::from(f.local_id.into_raw()) as usize)\n+                            .bytes_usize();\n+                        addr = addr.offset(offset);\n+                    }\n+                    _ => return Err(MirEvalError::TypeError(\"Only adt has fields\")),\n+                },\n+                ProjectionElem::ConstantIndex { .. } => {\n+                    not_supported!(\"constant index\")\n+                }\n+                ProjectionElem::Subslice { .. } => not_supported!(\"subslice\"),\n+                ProjectionElem::OpaqueCast(_) => not_supported!(\"opaque cast\"),\n+            }\n+        }\n+        Ok((addr, ty))\n+    }\n+\n+    fn layout(&self, ty: &Ty) -> Result<Layout> {\n+        layout_of_ty(self.db, ty, self.crate_id)\n+            .map_err(|e| MirEvalError::LayoutError(e, ty.clone()))\n+    }\n+\n+    fn layout_adt(&self, adt: AdtId, subst: Substitution) -> Result<Layout> {\n+        self.db.layout_of_adt(adt, subst.clone()).map_err(|e| {\n+            MirEvalError::LayoutError(e, TyKind::Adt(chalk_ir::AdtId(adt), subst).intern(Interner))\n+        })\n+    }\n+\n+    fn place_ty<'a>(&'a self, p: &Place, locals: &'a Locals<'a>) -> Result<Ty> {\n+        Ok(self.place_addr_and_ty(p, locals)?.1)\n+    }\n+\n+    fn operand_ty<'a>(&'a self, o: &'a Operand, locals: &'a Locals<'a>) -> Result<Ty> {\n+        Ok(match o {\n+            Operand::Copy(p) | Operand::Move(p) => self.place_ty(p, locals)?,\n+            Operand::Constant(c) => c.data(Interner).ty.clone(),\n+        })\n+    }\n+\n+    fn interpret_mir(\n+        &mut self,\n+        body: &MirBody,\n+        args: impl Iterator<Item = Vec<u8>>,\n+        subst: Substitution,\n+    ) -> Result<Vec<u8>> {\n+        if let Some(x) = self.stack_depth_limit.checked_sub(1) {\n+            self.stack_depth_limit = x;\n+        } else {\n+            return Err(MirEvalError::StackOverflow);\n+        }\n+        let mut current_block_idx = body.start_block;\n+        let mut locals = Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst };\n+        let (locals_ptr, stack_size) = {\n+            let mut stack_ptr = self.stack.len();\n+            let addr = body\n+                .locals\n+                .iter()\n+                .map(|(id, x)| {\n+                    let size =\n+                        self.size_of_sized(&x.ty, &locals, \"no unsized local in extending stack\")?;\n+                    let my_ptr = stack_ptr;\n+                    stack_ptr += size;\n+                    Ok((id, Stack(my_ptr)))\n+                })\n+                .collect::<Result<ArenaMap<LocalId, _>>>()?;\n+            let stack_size = stack_ptr - self.stack.len();\n+            (addr, stack_size)\n+        };\n+        locals.ptr = &locals_ptr;\n+        self.stack.extend(iter::repeat(0).take(stack_size));\n+        let mut remain_args = body.arg_count;\n+        for ((_, addr), value) in locals_ptr.iter().skip(1).zip(args) {\n+            self.write_memory(*addr, &value)?;\n+            if remain_args == 0 {\n+                return Err(MirEvalError::TypeError(\"more arguments provided\"));\n+            }\n+            remain_args -= 1;\n+        }\n+        if remain_args > 0 {\n+            return Err(MirEvalError::TypeError(\"not enough arguments provided\"));\n+        }\n+        loop {\n+            let current_block = &body.basic_blocks[current_block_idx];\n+            if let Some(x) = self.execution_limit.checked_sub(1) {\n+                self.execution_limit = x;\n+            } else {\n+                return Err(MirEvalError::ExecutionLimitExceeded);\n+            }\n+            for statement in &current_block.statements {\n+                match &statement.kind {\n+                    StatementKind::Assign(l, r) => {\n+                        let addr = self.place_addr(l, &locals)?;\n+                        let result = self.eval_rvalue(r, &locals)?.to_vec(&self)?;\n+                        self.write_memory(addr, &result)?;\n+                    }\n+                    StatementKind::Deinit(_) => not_supported!(\"de-init statement\"),\n+                    StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n+                }\n+            }\n+            let Some(terminator) = current_block.terminator.as_ref() else {\n+                not_supported!(\"block without terminator\");\n+            };\n+            match terminator {\n+                Terminator::Goto { target } => {\n+                    current_block_idx = *target;\n+                }\n+                Terminator::Call {\n+                    func,\n+                    args,\n+                    destination,\n+                    target,\n+                    cleanup: _,\n+                    from_hir_call: _,\n+                } => {\n+                    let fn_ty = self.operand_ty(func, &locals)?;\n+                    match &fn_ty.data(Interner).kind {\n+                        TyKind::FnDef(def, generic_args) => {\n+                            let def: CallableDefId = from_chalk(self.db, *def);\n+                            let generic_args = self.subst_filler(generic_args, &locals);\n+                            match def {\n+                                CallableDefId::FunctionId(def) => {\n+                                    let arg_bytes = args\n+                                        .iter()\n+                                        .map(|x| {\n+                                            Ok(self\n+                                                .eval_operand(x, &locals)?\n+                                                .get(&self)?\n+                                                .to_owned())\n+                                        })\n+                                        .collect::<Result<Vec<_>>>()?\n+                                        .into_iter();\n+                                    let function_data = self.db.function_data(def);\n+                                    let is_intrinsic = match &function_data.abi {\n+                                        Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+                                        None => match def.lookup(self.db.upcast()).container {\n+                                            hir_def::ItemContainerId::ExternBlockId(block) => {\n+                                                let id = block.lookup(self.db.upcast()).id;\n+                                                id.item_tree(self.db.upcast())[id.value]\n+                                                    .abi\n+                                                    .as_deref()\n+                                                    == Some(\"rust-intrinsic\")\n+                                            }\n+                                            _ => false,\n+                                        },\n+                                    };\n+                                    let result = if is_intrinsic {\n+                                        self.exec_intrinsic(\n+                                            function_data\n+                                                .name\n+                                                .as_text()\n+                                                .unwrap_or_default()\n+                                                .as_str(),\n+                                            arg_bytes,\n+                                            generic_args,\n+                                            &locals,\n+                                        )?\n+                                    } else if let Some(x) = self.detect_lang_function(def) {\n+                                        self.exec_lang_item(x, arg_bytes)?\n+                                    } else {\n+                                        let trait_env = {\n+                                            let Some(d) = body.owner.as_generic_def_id() else {\n+                                                not_supported!(\"trait resolving in non generic def id\");\n+                                            };\n+                                            self.db.trait_environment(d)\n+                                        };\n+                                        let (imp, generic_args) = lookup_impl_method(\n+                                            self.db,\n+                                            trait_env,\n+                                            def,\n+                                            generic_args.clone(),\n+                                        );\n+                                        let generic_args =\n+                                            self.subst_filler(&generic_args, &locals);\n+                                        let def = imp.into();\n+                                        let mir_body = self\n+                                            .db\n+                                            .mir_body(def)\n+                                            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+                                        self.interpret_mir(&mir_body, arg_bytes, generic_args)\n+                                            .map_err(|e| {\n+                                                MirEvalError::InFunction(imp, Box::new(e))\n+                                            })?\n+                                    };\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                                CallableDefId::StructId(id) => {\n+                                    let (size, variant_layout, tag) = self.layout_of_variant(\n+                                        id.into(),\n+                                        generic_args.clone(),\n+                                        &locals,\n+                                    )?;\n+                                    let result = self.make_by_layout(\n+                                        size,\n+                                        &variant_layout,\n+                                        tag,\n+                                        args,\n+                                        &locals,\n+                                    )?;\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                                CallableDefId::EnumVariantId(id) => {\n+                                    let (size, variant_layout, tag) = self.layout_of_variant(\n+                                        id.into(),\n+                                        generic_args.clone(),\n+                                        &locals,\n+                                    )?;\n+                                    let result = self.make_by_layout(\n+                                        size,\n+                                        &variant_layout,\n+                                        tag,\n+                                        args,\n+                                        &locals,\n+                                    )?;\n+                                    let dest_addr = self.place_addr(destination, &locals)?;\n+                                    self.write_memory(dest_addr, &result)?;\n+                                }\n+                            }\n+                            current_block_idx =\n+                                target.expect(\"broken mir, function without target\");\n+                        }\n+                        _ => not_supported!(\"unknown function type\"),\n+                    }\n+                }\n+                Terminator::SwitchInt { discr, targets } => {\n+                    let val = u128::from_le_bytes(pad16(\n+                        self.eval_operand(discr, &locals)?.get(&self)?,\n+                        false,\n+                    ));\n+                    current_block_idx = targets.target_for_value(val);\n+                }\n+                Terminator::Return => {\n+                    let ty = body.locals[return_slot()].ty.clone();\n+                    self.stack_depth_limit += 1;\n+                    return Ok(self\n+                        .read_memory(\n+                            locals.ptr[return_slot()],\n+                            self.size_of_sized(&ty, &locals, \"return type\")?,\n+                        )?\n+                        .to_owned());\n+                }\n+                Terminator::Unreachable => {\n+                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"))\n+                }\n+                _ => not_supported!(\"unknown terminator\"),\n+            }\n+        }\n+    }\n+\n+    fn eval_rvalue<'a>(\n+        &'a mut self,\n+        r: &'a Rvalue,\n+        locals: &'a Locals<'a>,\n+    ) -> Result<IntervalOrOwned> {\n+        use IntervalOrOwned::*;\n+        Ok(match r {\n+            Rvalue::Use(x) => Borrowed(self.eval_operand(x, locals)?),\n+            Rvalue::Ref(_, p) => {\n+                let addr = self.place_addr(p, locals)?;\n+                Owned(addr.to_bytes())\n+            }\n+            Rvalue::Len(_) => not_supported!(\"rvalue len\"),\n+            Rvalue::UnaryOp(op, val) => {\n+                let mut c = self.eval_operand(val, locals)?.get(&self)?;\n+                let mut ty = self.operand_ty(val, locals)?;\n+                while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n+                    ty = z.clone();\n+                    let size = self.size_of_sized(&ty, locals, \"operand of unary op\")?;\n+                    c = self.read_memory(Address::from_bytes(c)?, size)?;\n+                }\n+                let mut c = c.to_vec();\n+                if ty.as_builtin() == Some(BuiltinType::Bool) {\n+                    c[0] = 1 - c[0];\n+                } else {\n+                    match op {\n+                        UnOp::Not => c.iter_mut().for_each(|x| *x = !*x),\n+                        UnOp::Neg => {\n+                            c.iter_mut().for_each(|x| *x = !*x);\n+                            for k in c.iter_mut() {\n+                                let o;\n+                                (*k, o) = k.overflowing_add(1);\n+                                if !o {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                Owned(c)\n+            }\n+            Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let lc = self.eval_operand(lhs, locals)?;\n+                let rc = self.eval_operand(rhs, locals)?;\n+                let mut lc = lc.get(&self)?;\n+                let mut rc = rc.get(&self)?;\n+                let mut ty = self.operand_ty(lhs, locals)?;\n+                while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n+                    ty = z.clone();\n+                    let size = self.size_of_sized(&ty, locals, \"operand of binary op\")?;\n+                    lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n+                    rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n+                }\n+                let is_signed = matches!(ty.as_builtin(), Some(BuiltinType::Int(_)));\n+                let l128 = i128::from_le_bytes(pad16(lc, is_signed));\n+                let r128 = i128::from_le_bytes(pad16(rc, is_signed));\n+                match op {\n+                    BinOp::Ge | BinOp::Gt | BinOp::Le | BinOp::Lt | BinOp::Eq | BinOp::Ne => {\n+                        let r = match op {\n+                            BinOp::Ge => l128 >= r128,\n+                            BinOp::Gt => l128 > r128,\n+                            BinOp::Le => l128 <= r128,\n+                            BinOp::Lt => l128 < r128,\n+                            BinOp::Eq => l128 == r128,\n+                            BinOp::Ne => l128 != r128,\n+                            _ => unreachable!(),\n+                        };\n+                        let r = r as u8;\n+                        Owned(vec![r])\n+                    }\n+                    BinOp::BitAnd\n+                    | BinOp::BitOr\n+                    | BinOp::BitXor\n+                    | BinOp::Add\n+                    | BinOp::Mul\n+                    | BinOp::Div\n+                    | BinOp::Rem\n+                    | BinOp::Sub => {\n+                        let r = match op {\n+                            BinOp::Add => l128.overflowing_add(r128).0,\n+                            BinOp::Mul => l128.overflowing_mul(r128).0,\n+                            BinOp::Div => l128.checked_div(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Rem => l128.checked_rem(r128).ok_or(MirEvalError::Panic)?,\n+                            BinOp::Sub => l128.overflowing_sub(r128).0,\n+                            BinOp::BitAnd => l128 & r128,\n+                            BinOp::BitOr => l128 | r128,\n+                            BinOp::BitXor => l128 ^ r128,\n+                            _ => unreachable!(),\n+                        };\n+                        let r = r.to_le_bytes();\n+                        for &k in &r[lc.len()..] {\n+                            if k != 0 && (k != 255 || !is_signed) {\n+                                return Err(MirEvalError::Panic);\n+                            }\n+                        }\n+                        Owned(r[0..lc.len()].into())\n+                    }\n+                    BinOp::Shl | BinOp::Shr => {\n+                        let shift_amout = if r128 < 0 {\n+                            return Err(MirEvalError::Panic);\n+                        } else if r128 > 128 {\n+                            return Err(MirEvalError::Panic);\n+                        } else {\n+                            r128 as u8\n+                        };\n+                        let r = match op {\n+                            BinOp::Shl => l128 << shift_amout,\n+                            BinOp::Shr => l128 >> shift_amout,\n+                            _ => unreachable!(),\n+                        };\n+                        Owned(r.to_le_bytes()[0..lc.len()].into())\n+                    }\n+                    BinOp::Offset => not_supported!(\"offset binop\"),\n+                }\n+            }\n+            Rvalue::Discriminant(p) => {\n+                let ty = self.place_ty(p, locals)?;\n+                let bytes = self.eval_place(p, locals)?.get(&self)?;\n+                let layout = self.layout(&ty)?;\n+                match layout.variants {\n+                    Variants::Single { .. } => Owned(0u128.to_le_bytes().to_vec()),\n+                    Variants::Multiple { tag, tag_encoding, .. } => {\n+                        let Some(target_data_layout) = self.db.target_data_layout(self.crate_id) else {\n+                            not_supported!(\"missing target data layout\");\n+                        };\n+                        let size = tag.size(&*target_data_layout).bytes_usize();\n+                        let offset = layout.fields.offset(0).bytes_usize(); // The only field on enum variants is the tag field\n+                        match tag_encoding {\n+                            TagEncoding::Direct => {\n+                                let tag = &bytes[offset..offset + size];\n+                                Owned(pad16(tag, false).to_vec())\n+                            }\n+                            TagEncoding::Niche { untagged_variant, niche_start, .. } => {\n+                                let tag = &bytes[offset..offset + size];\n+                                let candidate_discriminant = i128::from_le_bytes(pad16(tag, false))\n+                                    .wrapping_sub(niche_start as i128);\n+                                let enum_id = match ty.kind(Interner) {\n+                                    TyKind::Adt(e, _) => match e.0 {\n+                                        AdtId::EnumId(e) => e,\n+                                        _ => not_supported!(\"Non enum with multi variant layout\"),\n+                                    },\n+                                    _ => not_supported!(\"Non adt with multi variant layout\"),\n+                                };\n+                                let enum_data = self.db.enum_data(enum_id);\n+                                let result = 'b: {\n+                                    for (local_id, _) in enum_data.variants.iter() {\n+                                        if candidate_discriminant\n+                                            == self.db.const_eval_discriminant(EnumVariantId {\n+                                                parent: enum_id,\n+                                                local_id,\n+                                            })?\n+                                        {\n+                                            break 'b candidate_discriminant;\n+                                        }\n+                                    }\n+                                    self.db.const_eval_discriminant(EnumVariantId {\n+                                        parent: enum_id,\n+                                        local_id: untagged_variant.0,\n+                                    })?\n+                                };\n+                                Owned(result.to_le_bytes().to_vec())\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n+            Rvalue::CopyForDeref(_) => not_supported!(\"copy for deref\"),\n+            Rvalue::Aggregate(kind, values) => match kind {\n+                AggregateKind::Array(_) => {\n+                    let mut r = vec![];\n+                    for x in values {\n+                        let value = self.eval_operand(x, locals)?.get(&self)?;\n+                        r.extend(value);\n+                    }\n+                    Owned(r)\n+                }\n+                AggregateKind::Tuple(ty) => {\n+                    let layout = self.layout(&ty)?;\n+                    Owned(self.make_by_layout(\n+                        layout.size.bytes_usize(),\n+                        &layout,\n+                        None,\n+                        values,\n+                        locals,\n+                    )?)\n+                }\n+                AggregateKind::Union(x, f) => {\n+                    let layout = self.layout_adt((*x).into(), Substitution::empty(Interner))?;\n+                    let offset = layout\n+                        .fields\n+                        .offset(u32::from(f.local_id.into_raw()) as usize)\n+                        .bytes_usize();\n+                    let op = self.eval_operand(&values[0], locals)?.get(&self)?;\n+                    let mut result = vec![0; layout.size.bytes_usize()];\n+                    result[offset..offset + op.len()].copy_from_slice(op);\n+                    Owned(result)\n+                }\n+                AggregateKind::Adt(x, subst) => {\n+                    let (size, variant_layout, tag) =\n+                        self.layout_of_variant(*x, subst.clone(), locals)?;\n+                    Owned(self.make_by_layout(size, &variant_layout, tag, values, locals)?)\n+                }\n+            },\n+            Rvalue::Cast(kind, operand, target_ty) => match kind {\n+                CastKind::PointerExposeAddress => not_supported!(\"exposing pointer address\"),\n+                CastKind::PointerFromExposedAddress => {\n+                    not_supported!(\"creating pointer from exposed address\")\n+                }\n+                CastKind::Pointer(cast) => match cast {\n+                    PointerCast::Unsize => {\n+                        let current_ty = self.operand_ty(operand, locals)?;\n+                        match &target_ty.data(Interner).kind {\n+                            TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                match &ty.data(Interner).kind {\n+                                    TyKind::Slice(_) => match &current_ty.data(Interner).kind {\n+                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                                            match &ty.data(Interner).kind {\n+                                                TyKind::Array(_, size) => {\n+                                                    let addr = self\n+                                                        .eval_operand(operand, locals)?\n+                                                        .get(&self)?;\n+                                                    let len = const_as_usize(size);\n+                                                    let mut r = Vec::with_capacity(16);\n+                                                    r.extend(addr.iter().copied());\n+                                                    r.extend(len.to_le_bytes().into_iter());\n+                                                    Owned(r)\n+                                                }\n+                                                _ => {\n+                                                    not_supported!(\"slice unsizing from non arrays\")\n+                                                }\n+                                            }\n+                                        }\n+                                        _ => not_supported!(\"slice unsizing from non pointers\"),\n+                                    },\n+                                    TyKind::Dyn(_) => not_supported!(\"dyn pointer unsize cast\"),\n+                                    _ => not_supported!(\"unknown unsized cast\"),\n+                                }\n+                            }\n+                            _ => not_supported!(\"unsized cast on unknown pointer type\"),\n+                        }\n+                    }\n+                    x => not_supported!(\"pointer cast {x:?}\"),\n+                },\n+                CastKind::DynStar => not_supported!(\"dyn star cast\"),\n+                CastKind::IntToInt => {\n+                    // FIXME: handle signed cast\n+                    let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n+                    let dest_size =\n+                        self.size_of_sized(target_ty, locals, \"destination of int to int cast\")?;\n+                    Owned(current[0..dest_size].to_vec())\n+                }\n+                CastKind::FloatToInt => not_supported!(\"float to int cast\"),\n+                CastKind::FloatToFloat => not_supported!(\"float to float cast\"),\n+                CastKind::IntToFloat => not_supported!(\"float to int cast\"),\n+                CastKind::PtrToPtr => not_supported!(\"ptr to ptr cast\"),\n+                CastKind::FnPtrToPtr => not_supported!(\"fn ptr to ptr cast\"),\n+            },\n+        })\n+    }\n+\n+    fn layout_of_variant(\n+        &mut self,\n+        x: VariantId,\n+        subst: Substitution,\n+        locals: &Locals<'_>,\n+    ) -> Result<(usize, Layout, Option<(usize, usize, i128)>)> {\n+        let adt = x.adt_id();\n+        if let DefWithBodyId::VariantId(f) = locals.body.owner {\n+            if let VariantId::EnumVariantId(x) = x {\n+                if AdtId::from(f.parent) == adt {\n+                    // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n+                    // infinite sized type errors) we use a dummy layout\n+                    let i = self.db.const_eval_discriminant(x)?;\n+                    return Ok((16, self.layout(&TyBuilder::unit())?, Some((0, 16, i))));\n+                }\n+            }\n+        }\n+        let layout = self.layout_adt(adt, subst)?;\n+        Ok(match layout.variants {\n+            Variants::Single { .. } => (layout.size.bytes_usize(), layout, None),\n+            Variants::Multiple { variants, tag, tag_encoding, .. } => {\n+                let cx = self\n+                    .db\n+                    .target_data_layout(self.crate_id)\n+                    .ok_or(MirEvalError::TargetDataLayoutNotAvailable)?;\n+                let enum_variant_id = match x {\n+                    VariantId::EnumVariantId(x) => x,\n+                    _ => not_supported!(\"multi variant layout for non-enums\"),\n+                };\n+                let rustc_enum_variant_idx = RustcEnumVariantIdx(enum_variant_id.local_id);\n+                let mut discriminant = self.db.const_eval_discriminant(enum_variant_id)?;\n+                let variant_layout = variants[rustc_enum_variant_idx].clone();\n+                let have_tag = match tag_encoding {\n+                    TagEncoding::Direct => true,\n+                    TagEncoding::Niche { untagged_variant, niche_variants: _, niche_start } => {\n+                        discriminant = discriminant.wrapping_add(niche_start as i128);\n+                        untagged_variant != rustc_enum_variant_idx\n+                    }\n+                };\n+                (\n+                    layout.size.bytes_usize(),\n+                    variant_layout,\n+                    if have_tag {\n+                        Some((\n+                            layout.fields.offset(0).bytes_usize(),\n+                            tag.size(&*cx).bytes_usize(),\n+                            discriminant,\n+                        ))\n+                    } else {\n+                        None\n+                    },\n+                )\n+            }\n+        })\n+    }\n+\n+    fn make_by_layout(\n+        &mut self,\n+        size: usize, // Not neccessarily equal to variant_layout.size\n+        variant_layout: &Layout,\n+        tag: Option<(usize, usize, i128)>,\n+        values: &Vec<Operand>,\n+        locals: &Locals<'_>,\n+    ) -> Result<Vec<u8>> {\n+        let mut result = vec![0; size];\n+        if let Some((offset, size, value)) = tag {\n+            result[offset..offset + size].copy_from_slice(&value.to_le_bytes()[0..size]);\n+        }\n+        for (i, op) in values.iter().enumerate() {\n+            let offset = variant_layout.fields.offset(i).bytes_usize();\n+            let op = self.eval_operand(op, locals)?.get(&self)?;\n+            result[offset..offset + op.len()].copy_from_slice(op);\n+        }\n+        Ok(result)\n+    }\n+\n+    fn eval_operand(&mut self, x: &Operand, locals: &Locals<'_>) -> Result<Interval> {\n+        Ok(match x {\n+            Operand::Copy(p) | Operand::Move(p) => self.eval_place(p, locals)?,\n+            Operand::Constant(konst) => {\n+                let data = &konst.data(Interner);\n+                match &data.value {\n+                    chalk_ir::ConstValue::BoundVar(b) => {\n+                        let c = locals\n+                            .subst\n+                            .as_slice(Interner)\n+                            .get(b.index)\n+                            .ok_or(MirEvalError::TypeError(\"missing generic arg\"))?\n+                            .assert_const_ref(Interner);\n+                        self.eval_operand(&Operand::Constant(c.clone()), locals)?\n+                    }\n+                    chalk_ir::ConstValue::InferenceVar(_) => {\n+                        not_supported!(\"inference var constant\")\n+                    }\n+                    chalk_ir::ConstValue::Placeholder(_) => not_supported!(\"placeholder constant\"),\n+                    chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n+                        ConstScalar::Bytes(v, memory_map) => {\n+                            let mut v: Cow<'_, [u8]> = Cow::Borrowed(v);\n+                            let patch_map = memory_map.transform_addresses(|b| {\n+                                let addr = self.heap_allocate(b.len());\n+                                self.write_memory(addr, b)?;\n+                                Ok(addr.to_usize())\n+                            })?;\n+                            let size = self.size_of(&data.ty, locals)?.unwrap_or(v.len());\n+                            if size != v.len() {\n+                                // Handle self enum\n+                                if size == 16 && v.len() < 16 {\n+                                    v = Cow::Owned(pad16(&v, false).to_vec());\n+                                } else if size < 16 && v.len() == 16 {\n+                                    v = Cow::Owned(v[0..size].to_vec());\n+                                } else {\n+                                    return Err(MirEvalError::InvalidConst(konst.clone()));\n+                                }\n+                            }\n+                            let addr = self.heap_allocate(size);\n+                            self.write_memory(addr, &v)?;\n+                            self.patch_addresses(&patch_map, addr, &data.ty, locals)?;\n+                            Interval::new(addr, size)\n+                        }\n+                        ConstScalar::Unknown => not_supported!(\"evaluating unknown const\"),\n+                    },\n+                }\n+            }\n+        })\n+    }\n+\n+    fn eval_place(&mut self, p: &Place, locals: &Locals<'_>) -> Result<Interval> {\n+        let addr = self.place_addr(p, locals)?;\n+        Ok(Interval::new(\n+            addr,\n+            self.size_of_sized(&self.place_ty(p, locals)?, locals, \"type of this place\")?,\n+        ))\n+    }\n+\n+    fn read_memory(&self, addr: Address, size: usize) -> Result<&[u8]> {\n+        let (mem, pos) = match addr {\n+            Stack(x) => (&self.stack, x),\n+            Heap(x) => (&self.heap, x),\n+        };\n+        mem.get(pos..pos + size).ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory read\"))\n+    }\n+\n+    fn write_memory(&mut self, addr: Address, r: &[u8]) -> Result<()> {\n+        let (mem, pos) = match addr {\n+            Stack(x) => (&mut self.stack, x),\n+            Heap(x) => (&mut self.heap, x),\n+        };\n+        mem.get_mut(pos..pos + r.len())\n+            .ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory write\"))?\n+            .copy_from_slice(r);\n+        Ok(())\n+    }\n+\n+    fn size_of(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Option<usize>> {\n+        if let DefWithBodyId::VariantId(f) = locals.body.owner {\n+            if let Some((adt, _)) = ty.as_adt() {\n+                if AdtId::from(f.parent) == adt {\n+                    // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n+                    // infinite sized type errors) we use a dummy size\n+                    return Ok(Some(16));\n+                }\n+            }\n+        }\n+        let ty = &self.ty_filler(ty, locals.subst, locals.body.owner)?;\n+        let layout = self.layout(ty);\n+        if self.assert_placeholder_ty_is_unused {\n+            if matches!(layout, Err(MirEvalError::LayoutError(LayoutError::HasPlaceholder, _))) {\n+                return Ok(Some(0));\n+            }\n+        }\n+        let layout = layout?;\n+        Ok(layout.is_sized().then(|| layout.size.bytes_usize()))\n+    }\n+\n+    /// A version of `self.size_of` which returns error if the type is unsized. `what` argument should\n+    /// be something that complete this: `error: type {ty} was unsized. {what} should be sized`\n+    fn size_of_sized(&self, ty: &Ty, locals: &Locals<'_>, what: &'static str) -> Result<usize> {\n+        match self.size_of(ty, locals)? {\n+            Some(x) => Ok(x),\n+            None => Err(MirEvalError::TypeIsUnsized(ty.clone(), what)),\n+        }\n+    }\n+\n+    /// Uses `ty_filler` to fill an entire subst\n+    fn subst_filler(&self, subst: &Substitution, locals: &Locals<'_>) -> Substitution {\n+        Substitution::from_iter(\n+            Interner,\n+            subst.iter(Interner).map(|x| match x.data(Interner) {\n+                chalk_ir::GenericArgData::Ty(ty) => {\n+                    let Ok(ty) = self.ty_filler(ty, locals.subst, locals.body.owner) else {\n+                        return x.clone();\n+                    };\n+                    chalk_ir::GenericArgData::Ty(ty).intern(Interner)\n+                }\n+                _ => x.clone(),\n+            }),\n+        )\n+    }\n+\n+    /// This function substitutes placeholders of the body with the provided subst, effectively plays\n+    /// the rule of monomorphization. In addition to placeholders, it substitutes opaque types (return\n+    /// position impl traits) with their underlying type.\n+    fn ty_filler(&self, ty: &Ty, subst: &Substitution, owner: DefWithBodyId) -> Result<Ty> {\n+        struct Filler<'a> {\n+            db: &'a dyn HirDatabase,\n+            subst: &'a Substitution,\n+            skip_params: usize,\n+        }\n+        impl FallibleTypeFolder<Interner> for Filler<'_> {\n+            type Error = MirEvalError;\n+\n+            fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n+                self\n+            }\n+\n+            fn interner(&self) -> Interner {\n+                Interner\n+            }\n+\n+            fn try_fold_ty(\n+                &mut self,\n+                ty: Ty,\n+                outer_binder: DebruijnIndex,\n+            ) -> std::result::Result<Ty, Self::Error> {\n+                match ty.kind(Interner) {\n+                    TyKind::OpaqueType(id, subst) => {\n+                        let impl_trait_id = self.db.lookup_intern_impl_trait_id((*id).into());\n+                        match impl_trait_id {\n+                            crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                                let infer = self.db.infer(func.into());\n+                                let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n+                                filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n+                            }\n+                            crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n+                                not_supported!(\"async block impl trait\");\n+                            }\n+                        }\n+                    }\n+                    _ => ty.try_super_fold_with(self.as_dyn(), outer_binder),\n+                }\n+            }\n+\n+            fn try_fold_free_placeholder_ty(\n+                &mut self,\n+                idx: chalk_ir::PlaceholderIndex,\n+                _outer_binder: DebruijnIndex,\n+            ) -> std::result::Result<Ty, Self::Error> {\n+                let x = from_placeholder_idx(self.db, idx);\n+                Ok(self\n+                    .subst\n+                    .as_slice(Interner)\n+                    .get((u32::from(x.local_id.into_raw()) as usize) + self.skip_params)\n+                    .and_then(|x| x.ty(Interner))\n+                    .ok_or(MirEvalError::TypeError(\"Generic arg not provided\"))?\n+                    .clone())\n+            }\n+        }\n+        let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n+        Ok(normalize(self.db, owner, ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST)?))\n+    }\n+\n+    fn heap_allocate(&mut self, s: usize) -> Address {\n+        let pos = self.heap.len();\n+        self.heap.extend(iter::repeat(0).take(s));\n+        Address::Heap(pos)\n+    }\n+\n+    pub fn interpret_mir_with_no_arg(&mut self, body: &MirBody) -> Result<Vec<u8>> {\n+        self.interpret_mir(&body, vec![].into_iter(), Substitution::empty(Interner))\n+    }\n+\n+    fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n+        let candidate = lang_attr(self.db.upcast(), def)?;\n+        // filter normal lang functions out\n+        if [LangItem::IntoIterIntoIter, LangItem::IteratorNext].contains(&candidate) {\n+            return None;\n+        }\n+        Some(candidate)\n+    }\n+\n+    fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {\n+        // FIXME: support indirect references\n+        let mut mm = MemoryMap::default();\n+        match ty.kind(Interner) {\n+            TyKind::Ref(_, _, t) => {\n+                let size = self.size_of(t, locals)?;\n+                match size {\n+                    Some(size) => {\n+                        let addr_usize = from_bytes!(usize, bytes);\n+                        mm.insert(\n+                            addr_usize,\n+                            self.read_memory(Address::from_usize(addr_usize), size)?.to_vec(),\n+                        )\n+                    }\n+                    None => {\n+                        let element_size = match t.kind(Interner) {\n+                            TyKind::Str => 1,\n+                            TyKind::Slice(t) => {\n+                                self.size_of_sized(t, locals, \"slice inner type\")?\n+                            }\n+                            _ => return Ok(mm), // FIXME: support other kind of unsized types\n+                        };\n+                        let (addr, meta) = bytes.split_at(bytes.len() / 2);\n+                        let size = element_size * from_bytes!(usize, meta);\n+                        let addr = Address::from_bytes(addr)?;\n+                        mm.insert(addr.to_usize(), self.read_memory(addr, size)?.to_vec());\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+        Ok(mm)\n+    }\n+\n+    fn patch_addresses(\n+        &mut self,\n+        patch_map: &HashMap<usize, usize>,\n+        addr: Address,\n+        ty: &Ty,\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        // FIXME: support indirect references\n+        let my_size = self.size_of_sized(ty, locals, \"value to patch address\")?;\n+        match ty.kind(Interner) {\n+            TyKind::Ref(_, _, t) => {\n+                let size = self.size_of(t, locals)?;\n+                match size {\n+                    Some(_) => {\n+                        let current = from_bytes!(usize, self.read_memory(addr, my_size)?);\n+                        if let Some(x) = patch_map.get(&current) {\n+                            self.write_memory(addr, &x.to_le_bytes())?;\n+                        }\n+                    }\n+                    None => {\n+                        let current = from_bytes!(usize, self.read_memory(addr, my_size / 2)?);\n+                        if let Some(x) = patch_map.get(&current) {\n+                            self.write_memory(addr, &x.to_le_bytes())?;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_intrinsic(\n+        &self,\n+        as_str: &str,\n+        _arg_bytes: impl Iterator<Item = Vec<u8>>,\n+        generic_args: Substitution,\n+        locals: &Locals<'_>,\n+    ) -> Result<Vec<u8>> {\n+        match as_str {\n+            \"size_of\" => {\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n+                };\n+                let size = self.size_of(ty, locals)?;\n+                match size {\n+                    Some(x) => Ok(x.to_le_bytes().to_vec()),\n+                    None => return Err(MirEvalError::TypeError(\"size_of arg is unsized\")),\n+                }\n+            }\n+            _ => not_supported!(\"unknown intrinsic {as_str}\"),\n+        }\n+    }\n+\n+    pub(crate) fn exec_lang_item(\n+        &self,\n+        x: LangItem,\n+        mut args: std::vec::IntoIter<Vec<u8>>,\n+    ) -> Result<Vec<u8>> {\n+        use LangItem::*;\n+        match x {\n+            PanicFmt | BeginPanic => Err(MirEvalError::Panic),\n+            SliceLen => {\n+                let arg = args\n+                    .next()\n+                    .ok_or(MirEvalError::TypeError(\"argument of <[T]>::len() is not provided\"))?;\n+                let ptr_size = arg.len() / 2;\n+                Ok(arg[ptr_size..].into())\n+            }\n+            x => not_supported!(\"Executing lang item {x:?}\"),\n+        }\n+    }\n+}\n+\n+pub fn pad16(x: &[u8], is_signed: bool) -> [u8; 16] {\n+    let is_negative = is_signed && x.last().unwrap_or(&0) > &128;\n+    let fill_with = if is_negative { 255 } else { 0 };\n+    x.iter()\n+        .copied()\n+        .chain(iter::repeat(fill_with))\n+        .take(16)\n+        .collect::<Vec<u8>>()\n+        .try_into()\n+        .expect(\"iterator take is not working\")\n+}"}, {"sha": "435a914088bcf5313376db47a42900d565a4c65f", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "added", "additions": 1577, "deletions": 0, "changes": 1577, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,1577 @@\n+//! This module generates a polymorphic MIR from a hir body\n+\n+use std::{iter, mem, sync::Arc};\n+\n+use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n+use hir_def::{\n+    body::Body,\n+    expr::{\n+        Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n+        RecordLitField,\n+    },\n+    lang_item::{LangItem, LangItemTarget},\n+    layout::LayoutError,\n+    path::Path,\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    DefWithBodyId, EnumVariantId, HasModule,\n+};\n+use hir_expand::name::Name;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    consteval::ConstEvalError, db::HirDatabase, display::HirDisplay, infer::TypeMismatch,\n+    inhabitedness::is_ty_uninhabited_from, layout::layout_of_ty, mapping::ToChalk, static_lifetime,\n+    utils::generics, Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n+};\n+\n+use super::*;\n+\n+mod as_place;\n+\n+#[derive(Debug, Clone, Copy)]\n+struct LoopBlocks {\n+    begin: BasicBlockId,\n+    /// `None` for loops that are not terminating\n+    end: Option<BasicBlockId>,\n+}\n+\n+struct MirLowerCtx<'a> {\n+    result: MirBody,\n+    owner: DefWithBodyId,\n+    current_loop_blocks: Option<LoopBlocks>,\n+    discr_temp: Option<Place>,\n+    db: &'a dyn HirDatabase,\n+    body: &'a Body,\n+    infer: &'a InferenceResult,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum MirLowerError {\n+    ConstEvalError(Box<ConstEvalError>),\n+    LayoutError(LayoutError),\n+    IncompleteExpr,\n+    UnresolvedName(String),\n+    RecordLiteralWithoutPath,\n+    UnresolvedMethod,\n+    UnresolvedField,\n+    MissingFunctionDefinition,\n+    TypeMismatch(TypeMismatch),\n+    /// This should be never happen. Type mismatch should catch everything.\n+    TypeError(&'static str),\n+    NotSupported(String),\n+    ContinueWithoutLoop,\n+    BreakWithoutLoop,\n+    Loop,\n+    /// Something that should never happen and is definitely a bug, but we don't want to panic if it happened\n+    ImplementationError(&'static str),\n+    LangItemNotFound(LangItem),\n+    MutatingRvalue,\n+}\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+macro_rules! implementation_error {\n+    ($x: expr) => {{\n+        ::stdx::never!(\"MIR lower implementation bug: {}\", $x);\n+        return Err(MirLowerError::ImplementationError($x));\n+    }};\n+}\n+\n+impl From<ConstEvalError> for MirLowerError {\n+    fn from(value: ConstEvalError) -> Self {\n+        match value {\n+            ConstEvalError::MirLowerError(e) => e,\n+            _ => MirLowerError::ConstEvalError(Box::new(value)),\n+        }\n+    }\n+}\n+\n+impl From<LayoutError> for MirLowerError {\n+    fn from(value: LayoutError) -> Self {\n+        MirLowerError::LayoutError(value)\n+    }\n+}\n+\n+impl MirLowerError {\n+    fn unresolved_path(db: &dyn HirDatabase, p: &Path) -> Self {\n+        Self::UnresolvedName(p.display(db).to_string())\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, MirLowerError>;\n+\n+impl MirLowerCtx<'_> {\n+    fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n+        if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n+            implementation_error!(\"unsized temporaries\");\n+        }\n+        Ok(self.result.locals.alloc(Local { ty }))\n+    }\n+\n+    fn lower_expr_to_some_operand(\n+        &mut self,\n+        expr_id: ExprId,\n+        current: BasicBlockId,\n+    ) -> Result<Option<(Operand, BasicBlockId)>> {\n+        if !self.has_adjustments(expr_id) {\n+            match &self.body.exprs[expr_id] {\n+                Expr::Literal(l) => {\n+                    let ty = self.expr_ty(expr_id);\n+                    return Ok(Some((self.lower_literal_to_operand(ty, l)?, current)));\n+                }\n+                _ => (),\n+            }\n+        }\n+        let Some((p, current)) = self.lower_expr_as_place(current, expr_id, true)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((Operand::Copy(p), current)))\n+    }\n+\n+    fn lower_expr_to_place_with_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        place: Place,\n+        current: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<BasicBlockId>> {\n+        match adjustments.split_last() {\n+            Some((last, rest)) => match &last.kind {\n+                Adjust::NeverToAny => {\n+                    let temp = self.temp(TyKind::Never.intern(Interner))?;\n+                    self.lower_expr_to_place_with_adjust(expr_id, temp.into(), current, rest)\n+                }\n+                Adjust::Deref(_) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, adjustments)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Borrow(AutoBorrow::Ref(m) | AutoBorrow::RawPtr(m)) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    let bk = BorrowKind::from_chalk(*m);\n+                    self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Adjust::Pointer(cast) => {\n+                    let Some((p, current)) = self.lower_expr_as_place_with_adjust(current, expr_id, true, rest)? else {\n+                            return Ok(None);\n+                        };\n+                    self.push_assignment(\n+                        current,\n+                        place,\n+                        Rvalue::Cast(\n+                            CastKind::Pointer(cast.clone()),\n+                            Operand::Copy(p).into(),\n+                            last.target.clone(),\n+                        ),\n+                        expr_id.into(),\n+                    );\n+                    Ok(Some(current))\n+                }\n+            },\n+            None => self.lower_expr_to_place_without_adjust(expr_id, place, current),\n+        }\n+    }\n+\n+    fn lower_expr_to_place(\n+        &mut self,\n+        expr_id: ExprId,\n+        place: Place,\n+        prev_block: BasicBlockId,\n+    ) -> Result<Option<BasicBlockId>> {\n+        if let Some(adjustments) = self.infer.expr_adjustments.get(&expr_id) {\n+            return self.lower_expr_to_place_with_adjust(expr_id, place, prev_block, adjustments);\n+        }\n+        self.lower_expr_to_place_without_adjust(expr_id, place, prev_block)\n+    }\n+\n+    fn lower_expr_to_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        place: Place,\n+        mut current: BasicBlockId,\n+    ) -> Result<Option<BasicBlockId>> {\n+        match &self.body.exprs[expr_id] {\n+            Expr::Missing => Err(MirLowerError::IncompleteExpr),\n+            Expr::Path(p) => {\n+                let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let pr = resolver\n+                    .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n+                    .ok_or_else(unresolved_name)?;\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => {\n+                        if let Some(assoc) = self\n+                            .infer\n+                            .assoc_resolutions_for_expr(expr_id)\n+                        {\n+                            match assoc.0 {\n+                                hir_def::AssocItemId::ConstId(c) => {\n+                                    self.lower_const(c, current, place, expr_id.into())?;\n+                                    return Ok(Some(current))\n+                                },\n+                                _ => not_supported!(\"associated functions and types\"),\n+                            }\n+                        } else if let Some(variant) = self\n+                            .infer\n+                            .variant_resolution_for_expr(expr_id)\n+                        {\n+                            match variant {\n+                                VariantId::EnumVariantId(e) => ValueNs::EnumVariantId(e),\n+                                VariantId::StructId(s) => ValueNs::StructId(s),\n+                                VariantId::UnionId(_) => implementation_error!(\"Union variant as path\"),\n+                            }\n+                        } else {\n+                            return Err(unresolved_name());\n+                        }\n+                    }\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Operand::Copy(self.result.binding_locals[pat_id].into()).into(),\n+                            expr_id.into(),\n+                        );\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::ConstId(const_id) => {\n+                        self.lower_const(const_id, current, place, expr_id.into())?;\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::EnumVariantId(variant_id) => {\n+                        let ty = self.infer.type_of_expr[expr_id].clone();\n+                        let current = self.lower_enum_variant(\n+                            variant_id,\n+                            current,\n+                            place,\n+                            ty,\n+                            vec![],\n+                            expr_id.into(),\n+                        )?;\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::GenericParam(p) => {\n+                        let Some(def) = self.owner.as_generic_def_id() else {\n+                            not_supported!(\"owner without generic def id\");\n+                        };\n+                        let gen = generics(self.db.upcast(), def);\n+                        let ty = self.expr_ty(expr_id);\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Operand::Constant(\n+                                ConstData {\n+                                    ty,\n+                                    value: chalk_ir::ConstValue::BoundVar(BoundVar::new(\n+                                        DebruijnIndex::INNERMOST,\n+                                        gen.param_idx(p.into()).ok_or(MirLowerError::TypeError(\n+                                            \"fail to lower const generic param\",\n+                                        ))?,\n+                                    )),\n+                                }\n+                                .intern(Interner),\n+                            )\n+                            .into(),\n+                            expr_id.into(),\n+                        );\n+                        Ok(Some(current))\n+                    }\n+                    ValueNs::StructId(_) => {\n+                        // It's probably a unit struct or a zero sized function, so no action is needed.\n+                        Ok(Some(current))\n+                    }\n+                    x => {\n+                        not_supported!(\"unknown name {x:?} in value name space\");\n+                    }\n+                }\n+            }\n+            Expr::If { condition, then_branch, else_branch } => {\n+                let Some((discr, current)) = self.lower_expr_to_some_operand(*condition, current)? else {\n+                    return Ok(None);\n+                };\n+                let start_of_then = self.new_basic_block();\n+                let end_of_then =\n+                    self.lower_expr_to_place(*then_branch, place.clone(), start_of_then)?;\n+                let start_of_else = self.new_basic_block();\n+                let end_of_else = if let Some(else_branch) = else_branch {\n+                    self.lower_expr_to_place(*else_branch, place, start_of_else)?\n+                } else {\n+                    Some(start_of_else)\n+                };\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr,\n+                        targets: SwitchTargets::static_if(1, start_of_then, start_of_else),\n+                    },\n+                );\n+                Ok(self.merge_blocks(end_of_then, end_of_else))\n+            }\n+            Expr::Let { pat, expr } => {\n+                let Some((cond_place, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n+                let (then_target, else_target) = self.pattern_match(\n+                    current,\n+                    None,\n+                    cond_place,\n+                    self.expr_ty_after_adjustments(*expr),\n+                    *pat,\n+                    BindingAnnotation::Unannotated,\n+                )?;\n+                self.write_bytes_to_place(\n+                    then_target,\n+                    place.clone(),\n+                    vec![1],\n+                    TyBuilder::bool(),\n+                    MirSpan::Unknown,\n+                )?;\n+                if let Some(else_target) = else_target {\n+                    self.write_bytes_to_place(\n+                        else_target,\n+                        place,\n+                        vec![0],\n+                        TyBuilder::bool(),\n+                        MirSpan::Unknown,\n+                    )?;\n+                }\n+                Ok(self.merge_blocks(Some(then_target), else_target))\n+            }\n+            Expr::Unsafe { id: _, statements, tail } => {\n+                self.lower_block_to_place(None, statements, current, *tail, place)\n+            }\n+            Expr::Block { id: _, statements, tail, label } => {\n+                self.lower_block_to_place(*label, statements, current, *tail, place)\n+            }\n+            Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin| {\n+                if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n+                    this.set_goto(block, begin);\n+                }\n+                Ok(())\n+            }),\n+            Expr::While { condition, body, label } => {\n+                self.lower_loop(current, *label, |this, begin| {\n+                    let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n+                    let after_cond = this.new_basic_block();\n+                    this.set_terminator(\n+                        to_switch,\n+                        Terminator::SwitchInt {\n+                            discr,\n+                            targets: SwitchTargets::static_if(1, after_cond, end),\n+                        },\n+                    );\n+                    if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n+                        this.set_goto(block, begin);\n+                    }\n+                    Ok(())\n+                })\n+            }\n+            &Expr::For { iterable, pat, body, label } => {\n+                let into_iter_fn = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IntoIterIntoIter))?;\n+                let iter_next_fn = self.resolve_lang_item(LangItem::IteratorNext)?\n+                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IteratorNext))?;\n+                let option_some = self.resolve_lang_item(LangItem::OptionSome)?\n+                    .as_enum_variant().ok_or(MirLowerError::LangItemNotFound(LangItem::OptionSome))?;\n+                let option = option_some.parent;\n+                let into_iter_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(into_iter_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let iter_next_fn_op = Operand::const_zst(\n+                    TyKind::FnDef(\n+                        self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n+                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                    ).intern(Interner));\n+                let &Some(iterator_ty) = &self.infer.type_of_for_iterator.get(&expr_id) else {\n+                    return Err(MirLowerError::TypeError(\"unknown for loop iterator type\"));\n+                };\n+                let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n+                let item_ty = &self.infer.type_of_pat[pat];\n+                let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n+                let iterator_place: Place = self.temp(iterator_ty.clone())?.into();\n+                let option_item_place: Place = self.temp(option_item_ty.clone())?.into();\n+                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty)?.into();\n+                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false)?\n+                else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n+                self.lower_loop(current, label, |this, begin| {\n+                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n+                    else {\n+                        return Ok(());\n+                    };\n+                    let end = this.current_loop_end()?;\n+                    let (current, _) = this.pattern_matching_variant(\n+                        option_item_ty.clone(),\n+                        BindingAnnotation::Unannotated,\n+                        option_item_place.into(),\n+                        option_some.into(),\n+                        current,\n+                        pat.into(),\n+                        Some(end),\n+                        &[pat], &None)?;\n+                    if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n+                        this.set_goto(block, begin);\n+                    }\n+                    Ok(())\n+                })\n+            },\n+            Expr::Call { callee, args, .. } => {\n+                let callee_ty = self.expr_ty_after_adjustments(*callee);\n+                match &callee_ty.data(Interner).kind {\n+                    chalk_ir::TyKind::FnDef(..) => {\n+                        let func = Operand::from_bytes(vec![], callee_ty.clone());\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n+                    }\n+                    TyKind::Scalar(_)\n+                    | TyKind::Tuple(_, _)\n+                    | TyKind::Array(_, _)\n+                    | TyKind::Adt(_, _)\n+                    | TyKind::Str\n+                    | TyKind::Foreign(_)\n+                    | TyKind::Slice(_) => {\n+                        return Err(MirLowerError::TypeError(\"function call on data type\"))\n+                    }\n+                    TyKind::Error => return Err(MirLowerError::MissingFunctionDefinition),\n+                    TyKind::AssociatedType(_, _)\n+                    | TyKind::Raw(_, _)\n+                    | TyKind::Ref(_, _, _)\n+                    | TyKind::OpaqueType(_, _)\n+                    | TyKind::Never\n+                    | TyKind::Closure(_, _)\n+                    | TyKind::Generator(_, _)\n+                    | TyKind::GeneratorWitness(_, _)\n+                    | TyKind::Placeholder(_)\n+                    | TyKind::Dyn(_)\n+                    | TyKind::Alias(_)\n+                    | TyKind::Function(_)\n+                    | TyKind::BoundVar(_)\n+                    | TyKind::InferenceVar(_, _) => not_supported!(\"dynamic function call\"),\n+                }\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let (func_id, generic_args) =\n+                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedMethod)?;\n+                let ty = chalk_ir::TyKind::FnDef(\n+                    CallableDefId::FunctionId(func_id).to_chalk(self.db),\n+                    generic_args,\n+                )\n+                .intern(Interner);\n+                let func = Operand::from_bytes(vec![], ty);\n+                self.lower_call_and_args(\n+                    func,\n+                    iter::once(*receiver).chain(args.iter().copied()),\n+                    place,\n+                    current,\n+                    self.is_uninhabited(expr_id),\n+                )\n+            }\n+            Expr::Match { expr, arms } => {\n+                let Some((cond_place, mut current)) = self.lower_expr_as_place(current, *expr, true)?\n+                else {\n+                    return Ok(None);\n+                };\n+                let cond_ty = self.expr_ty_after_adjustments(*expr);\n+                let mut end = None;\n+                for MatchArm { pat, guard, expr } in arms.iter() {\n+                    if guard.is_some() {\n+                        not_supported!(\"pattern matching with guard\");\n+                    }\n+                    let (then, otherwise) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        BindingAnnotation::Unannotated,\n+                    )?;\n+                    if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n+                        let r = end.get_or_insert_with(|| self.new_basic_block());\n+                        self.set_goto(block, *r);\n+                    }\n+                    match otherwise {\n+                        Some(o) => current = o,\n+                        None => {\n+                            // The current pattern was irrefutable, so there is no need to generate code\n+                            // for the rest of patterns\n+                            break;\n+                        }\n+                    }\n+                }\n+                if self.is_unterminated(current) {\n+                    self.set_terminator(current, Terminator::Unreachable);\n+                }\n+                Ok(end)\n+            }\n+            Expr::Continue { label } => match label {\n+                Some(_) => not_supported!(\"continue with label\"),\n+                None => {\n+                    let loop_data =\n+                        self.current_loop_blocks.ok_or(MirLowerError::ContinueWithoutLoop)?;\n+                    self.set_goto(current, loop_data.begin);\n+                    Ok(None)\n+                }\n+            },\n+            Expr::Break { expr, label } => {\n+                if expr.is_some() {\n+                    not_supported!(\"break with value\");\n+                }\n+                match label {\n+                    Some(_) => not_supported!(\"break with label\"),\n+                    None => {\n+                        let end =\n+                            self.current_loop_end()?;\n+                        self.set_goto(current, end);\n+                        Ok(None)\n+                    }\n+                }\n+            }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    if let Some(c) = self.lower_expr_to_place(*expr, return_slot().into(), current)? {\n+                        current = c;\n+                    } else {\n+                        return Ok(None);\n+                    }\n+                }\n+                self.set_terminator(current, Terminator::Return);\n+                Ok(None)\n+            }\n+            Expr::Yield { .. } => not_supported!(\"yield\"),\n+            Expr::RecordLit { fields, path, .. } => {\n+                let variant_id = self\n+                    .infer\n+                    .variant_resolution_for_expr(expr_id)\n+                    .ok_or_else(|| match path {\n+                        Some(p) => MirLowerError::UnresolvedName(p.display(self.db).to_string()),\n+                        None => MirLowerError::RecordLiteralWithoutPath,\n+                    })?;\n+                let subst = match self.expr_ty(expr_id).kind(Interner) {\n+                    TyKind::Adt(_, s) => s.clone(),\n+                    _ => not_supported!(\"Non ADT record literal\"),\n+                };\n+                let variant_data = variant_id.variant_data(self.db.upcast());\n+                match variant_id {\n+                    VariantId::EnumVariantId(_) | VariantId::StructId(_) => {\n+                        let mut operands = vec![None; variant_data.fields().len()];\n+                        for RecordLitField { name, expr } in fields.iter() {\n+                            let field_id =\n+                                variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n+                            let Some((op, c)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n+                            operands[u32::from(field_id.into_raw()) as usize] = Some(op);\n+                        }\n+                        self.push_assignment(\n+                            current,\n+                            place,\n+                            Rvalue::Aggregate(\n+                                AggregateKind::Adt(variant_id, subst),\n+                                operands.into_iter().map(|x| x).collect::<Option<_>>().ok_or(\n+                                    MirLowerError::TypeError(\"missing field in record literal\"),\n+                                )?,\n+                            ),\n+                            expr_id.into(),\n+                        );\n+                        Ok(Some(current))\n+                    }\n+                    VariantId::UnionId(union_id) => {\n+                        let [RecordLitField { name, expr }] = fields.as_ref() else {\n+                            not_supported!(\"Union record literal with more than one field\");\n+                        };\n+                        let local_id =\n+                            variant_data.field(name).ok_or(MirLowerError::UnresolvedField)?;\n+                        let mut place = place;\n+                        place\n+                            .projection\n+                            .push(PlaceElem::Field(FieldId { parent: union_id.into(), local_id }));\n+                        self.lower_expr_to_place(*expr, place, current)\n+                    }\n+                }\n+            }\n+            Expr::Await { .. } => not_supported!(\"await\"),\n+            Expr::Try { .. } => not_supported!(\"? operator\"),\n+            Expr::Yeet { .. } => not_supported!(\"yeet\"),\n+            Expr::TryBlock { .. } => not_supported!(\"try block\"),\n+            Expr::Async { .. } => not_supported!(\"async block\"),\n+            Expr::Const { .. } => not_supported!(\"anonymous const block\"),\n+            Expr::Cast { expr, type_ref: _ } => {\n+                let Some((x, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                let source_ty = self.infer[*expr].clone();\n+                let target_ty = self.infer[expr_id].clone();\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::Cast(cast_kind(&source_ty, &target_ty)?, x, target_ty),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            }\n+            Expr::Ref { expr, rawness: _, mutability } => {\n+                let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n+                let bk = BorrowKind::from_hir(*mutability);\n+                self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::Box { .. } => not_supported!(\"box expression\"),\n+            Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::expr::UnaryOp::Deref, .. } => {\n+                let Some((p, current)) = self.lower_expr_as_place_without_adjust(current, expr_id, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(current, place, Operand::Copy(p).into(), expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::UnaryOp { expr, op: op @ (hir_def::expr::UnaryOp::Not | hir_def::expr::UnaryOp::Neg) } => {\n+                let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                let operation = match op {\n+                    hir_def::expr::UnaryOp::Not => UnOp::Not,\n+                    hir_def::expr::UnaryOp::Neg => UnOp::Neg,\n+                    _ => unreachable!(),\n+                };\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::UnaryOp(operation, operand),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            },\n+            Expr::BinaryOp { lhs, rhs, op } => {\n+                let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n+                if let hir_def::expr::BinaryOp::Assignment { op } = op {\n+                    if op.is_some() {\n+                        not_supported!(\"assignment with arith op (like +=)\");\n+                    }\n+                    let Some((lhs_place, current)) =\n+                        self.lower_expr_as_place(current, *lhs, false)?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                    let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                        return Ok(None);\n+                    };\n+                    self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n+                    return Ok(Some(current));\n+                }\n+                let Some((lhs_op, current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n+                    return Ok(None);\n+                };\n+                let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                    return Ok(None);\n+                };\n+                self.push_assignment(\n+                    current,\n+                    place,\n+                    Rvalue::CheckedBinaryOp(\n+                        match op {\n+                            hir_def::expr::BinaryOp::LogicOp(op) => match op {\n+                                hir_def::expr::LogicOp::And => BinOp::BitAnd, // FIXME: make these short circuit\n+                                hir_def::expr::LogicOp::Or => BinOp::BitOr,\n+                            },\n+                            hir_def::expr::BinaryOp::ArithOp(op) => BinOp::from(op),\n+                            hir_def::expr::BinaryOp::CmpOp(op) => BinOp::from(op),\n+                            hir_def::expr::BinaryOp::Assignment { .. } => unreachable!(), // handled above\n+                        },\n+                        lhs_op,\n+                        rhs_op,\n+                    ),\n+                    expr_id.into(),\n+                );\n+                Ok(Some(current))\n+            }\n+            Expr::Range { .. } => not_supported!(\"range\"),\n+            Expr::Closure { .. } => not_supported!(\"closure\"),\n+            Expr::Tuple { exprs, is_assignee_expr: _ } => {\n+                let Some(values) = exprs\n+                        .iter()\n+                        .map(|x| {\n+                            let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                return Ok(None);\n+                            };\n+                            current = c;\n+                            Ok(Some(o))\n+                        })\n+                        .collect::<Result<Option<_>>>()?\n+                else {\n+                    return Ok(None);\n+                };\n+                let r = Rvalue::Aggregate(\n+                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n+                    values,\n+                );\n+                self.push_assignment(current, place, r, expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::Array(l) => match l {\n+                Array::ElementList { elements, .. } => {\n+                    let elem_ty = match &self.expr_ty(expr_id).data(Interner).kind {\n+                        TyKind::Array(ty, _) => ty.clone(),\n+                        _ => {\n+                            return Err(MirLowerError::TypeError(\n+                                \"Array expression with non array type\",\n+                            ))\n+                        }\n+                    };\n+                    let Some(values) = elements\n+                            .iter()\n+                            .map(|x| {\n+                                let Some((o, c)) = self.lower_expr_to_some_operand(*x, current)? else {\n+                                    return Ok(None);\n+                                };\n+                                current = c;\n+                                Ok(Some(o))\n+                            })\n+                            .collect::<Result<Option<_>>>()?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                    let r = Rvalue::Aggregate(\n+                        AggregateKind::Array(elem_ty),\n+                        values,\n+                    );\n+                    self.push_assignment(current, place, r, expr_id.into());\n+                    Ok(Some(current))\n+                }\n+                Array::Repeat { .. } => not_supported!(\"array repeat\"),\n+            },\n+            Expr::Literal(l) => {\n+                let ty = self.expr_ty(expr_id);\n+                let op = self.lower_literal_to_operand(ty, l)?;\n+                self.push_assignment(current, place, op.into(), expr_id.into());\n+                Ok(Some(current))\n+            }\n+            Expr::Underscore => not_supported!(\"underscore\"),\n+        }\n+    }\n+\n+    fn push_field_projection(&self, place: &mut Place, expr_id: ExprId) -> Result<()> {\n+        if let Expr::Field { expr, name } = &self.body[expr_id] {\n+            if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n+                let index = name\n+                    .as_tuple_index()\n+                    .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n+                place.projection.push(ProjectionElem::TupleField(index))\n+            } else {\n+                let field =\n+                    self.infer.field_resolution(expr_id).ok_or(MirLowerError::UnresolvedField)?;\n+                place.projection.push(ProjectionElem::Field(field));\n+            }\n+        } else {\n+            not_supported!(\"\")\n+        }\n+        Ok(())\n+    }\n+\n+    fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n+        let size = layout_of_ty(self.db, &ty, self.owner.module(self.db.upcast()).krate())?\n+            .size\n+            .bytes_usize();\n+        let bytes = match l {\n+            hir_def::expr::Literal::String(b) => {\n+                let b = b.as_bytes();\n+                let mut data = vec![];\n+                data.extend(0usize.to_le_bytes());\n+                data.extend(b.len().to_le_bytes());\n+                let mut mm = MemoryMap::default();\n+                mm.insert(0, b.to_vec());\n+                return Ok(Operand::from_concrete_const(data, mm, ty));\n+            }\n+            hir_def::expr::Literal::ByteString(b) => {\n+                let mut data = vec![];\n+                data.extend(0usize.to_le_bytes());\n+                data.extend(b.len().to_le_bytes());\n+                let mut mm = MemoryMap::default();\n+                mm.insert(0, b.to_vec());\n+                return Ok(Operand::from_concrete_const(data, mm, ty));\n+            }\n+            hir_def::expr::Literal::Char(c) => u32::from(*c).to_le_bytes().into(),\n+            hir_def::expr::Literal::Bool(b) => vec![*b as u8],\n+            hir_def::expr::Literal::Int(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::expr::Literal::Uint(x, _) => x.to_le_bytes()[0..size].into(),\n+            hir_def::expr::Literal::Float(f, _) => match size {\n+                8 => f.into_f64().to_le_bytes().into(),\n+                4 => f.into_f32().to_le_bytes().into(),\n+                _ => {\n+                    return Err(MirLowerError::TypeError(\"float with size other than 4 or 8 bytes\"))\n+                }\n+            },\n+        };\n+        Ok(Operand::from_concrete_const(bytes, MemoryMap::default(), ty))\n+    }\n+\n+    fn new_basic_block(&mut self) -> BasicBlockId {\n+        self.result.basic_blocks.alloc(BasicBlock::default())\n+    }\n+\n+    fn lower_const(\n+        &mut self,\n+        const_id: hir_def::ConstId,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        let c = self.db.const_eval(const_id)?;\n+        self.write_const_to_place(c, prev_block, place, span)\n+    }\n+\n+    fn write_const_to_place(\n+        &mut self,\n+        c: Const,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::Constant(c).into(), span);\n+        Ok(())\n+    }\n+\n+    fn write_bytes_to_place(\n+        &mut self,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        cv: Vec<u8>,\n+        ty: Ty,\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        self.push_assignment(prev_block, place, Operand::from_bytes(cv, ty).into(), span);\n+        Ok(())\n+    }\n+\n+    fn lower_enum_variant(\n+        &mut self,\n+        variant_id: EnumVariantId,\n+        prev_block: BasicBlockId,\n+        place: Place,\n+        ty: Ty,\n+        fields: Vec<Operand>,\n+        span: MirSpan,\n+    ) -> Result<BasicBlockId> {\n+        let subst = match ty.kind(Interner) {\n+            TyKind::Adt(_, subst) => subst.clone(),\n+            _ => not_supported!(\"Non ADT enum\"),\n+        };\n+        self.push_assignment(\n+            prev_block,\n+            place,\n+            Rvalue::Aggregate(AggregateKind::Adt(variant_id.into(), subst), fields),\n+            span,\n+        );\n+        Ok(prev_block)\n+    }\n+\n+    fn lower_call_and_args(\n+        &mut self,\n+        func: Operand,\n+        args: impl Iterator<Item = ExprId>,\n+        place: Place,\n+        mut current: BasicBlockId,\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n+        let Some(args) = args\n+            .map(|arg| {\n+                if let Some((temp, c)) = self.lower_expr_to_some_operand(arg, current)? {\n+                    current = c;\n+                    Ok(Some(temp))\n+                } else {\n+                    Ok(None)\n+                }\n+            })\n+            .collect::<Result<Option<Vec<_>>>>()?\n+        else {\n+            return Ok(None);\n+        };\n+        self.lower_call(func, args, place, current, is_uninhabited)\n+    }\n+\n+    fn lower_call(\n+        &mut self,\n+        func: Operand,\n+        args: Vec<Operand>,\n+        place: Place,\n+        current: BasicBlockId,\n+        is_uninhabited: bool,\n+    ) -> Result<Option<BasicBlockId>> {\n+        let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };\n+        self.set_terminator(\n+            current,\n+            Terminator::Call {\n+                func,\n+                args,\n+                destination: place,\n+                target: b,\n+                cleanup: None,\n+                from_hir_call: true,\n+            },\n+        );\n+        Ok(b)\n+    }\n+\n+    fn is_unterminated(&mut self, source: BasicBlockId) -> bool {\n+        self.result.basic_blocks[source].terminator.is_none()\n+    }\n+\n+    fn set_terminator(&mut self, source: BasicBlockId, terminator: Terminator) {\n+        self.result.basic_blocks[source].terminator = Some(terminator);\n+    }\n+\n+    fn set_goto(&mut self, source: BasicBlockId, target: BasicBlockId) {\n+        self.set_terminator(source, Terminator::Goto { target });\n+    }\n+\n+    fn expr_ty(&self, e: ExprId) -> Ty {\n+        self.infer[e].clone()\n+    }\n+\n+    fn expr_ty_after_adjustments(&self, e: ExprId) -> Ty {\n+        let mut ty = None;\n+        if let Some(x) = self.infer.expr_adjustments.get(&e) {\n+            if let Some(x) = x.last() {\n+                ty = Some(x.target.clone());\n+            }\n+        }\n+        ty.unwrap_or_else(|| self.expr_ty(e))\n+    }\n+\n+    fn push_statement(&mut self, block: BasicBlockId, statement: Statement) {\n+        self.result.basic_blocks[block].statements.push(statement);\n+    }\n+\n+    fn push_assignment(\n+        &mut self,\n+        block: BasicBlockId,\n+        place: Place,\n+        rvalue: Rvalue,\n+        span: MirSpan,\n+    ) {\n+        self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n+    }\n+\n+    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n+    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n+    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n+    /// mismatched path block is `None`.\n+    ///\n+    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n+    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n+    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n+    /// so it should be an empty block.\n+    fn pattern_match(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        mut cond_place: Place,\n+        mut cond_ty: Ty,\n+        pattern: PatId,\n+        mut binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        Ok(match &self.body.pats[pattern] {\n+            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n+            Pat::Wild => (current, current_else),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                let subst = match cond_ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => {\n+                        return Err(MirLowerError::TypeError(\n+                            \"non tuple type matched with tuple pattern\",\n+                        ))\n+                    }\n+                };\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args.iter().enumerate().map(|(i, x)| {\n+                        (\n+                            PlaceElem::TupleField(i),\n+                            *x,\n+                            subst.at(Interner, i).assert_ty_ref(Interner).clone(),\n+                        )\n+                    }),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            Pat::Or(pats) => {\n+                let then_target = self.new_basic_block();\n+                let mut finished = false;\n+                for pat in &**pats {\n+                    let (next, next_else) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        binding_mode,\n+                    )?;\n+                    self.set_goto(next, then_target);\n+                    match next_else {\n+                        Some(t) => {\n+                            current = t;\n+                        }\n+                        None => {\n+                            finished = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if !finished {\n+                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                    self.set_goto(current, ce);\n+                }\n+                (then_target, current_else)\n+            }\n+            Pat::Record { .. } => not_supported!(\"record pattern\"),\n+            Pat::Range { .. } => not_supported!(\"range pattern\"),\n+            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n+            Pat::Path(_) => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    &[],\n+                    &None,\n+                )?\n+            }\n+            Pat::Lit(l) => {\n+                let then_target = self.new_basic_block();\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                match &self.body.exprs[*l] {\n+                    Expr::Literal(l) => match l {\n+                        hir_def::expr::Literal::Int(x, _) => {\n+                            self.set_terminator(\n+                                current,\n+                                Terminator::SwitchInt {\n+                                    discr: Operand::Copy(cond_place),\n+                                    targets: SwitchTargets::static_if(\n+                                        *x as u128,\n+                                        then_target,\n+                                        else_target,\n+                                    ),\n+                                },\n+                            );\n+                        }\n+                        hir_def::expr::Literal::Uint(x, _) => {\n+                            self.set_terminator(\n+                                current,\n+                                Terminator::SwitchInt {\n+                                    discr: Operand::Copy(cond_place),\n+                                    targets: SwitchTargets::static_if(*x, then_target, else_target),\n+                                },\n+                            );\n+                        }\n+                        _ => not_supported!(\"non int path literal\"),\n+                    },\n+                    _ => not_supported!(\"expression path literal\"),\n+                }\n+                (then_target, Some(else_target))\n+            }\n+            Pat::Bind { id, subpat } => {\n+                let target_place = self.result.binding_locals[*id];\n+                let mode = self.body.bindings[*id].mode;\n+                if let Some(subpat) = subpat {\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place.clone(),\n+                        cond_ty,\n+                        *subpat,\n+                        binding_mode,\n+                    )?\n+                }\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    binding_mode = mode;\n+                }\n+                self.push_storage_live(*id, current)?;\n+                self.push_assignment(\n+                    current,\n+                    target_place.into(),\n+                    match binding_mode {\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                            Operand::Copy(cond_place).into()\n+                        }\n+                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                        BindingAnnotation::RefMut => Rvalue::Ref(\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            cond_place,\n+                        ),\n+                    },\n+                    pattern.into(),\n+                );\n+                (current, current_else)\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    args,\n+                    ellipsis,\n+                )?\n+            }\n+            Pat::Ref { .. } => not_supported!(\"& pattern\"),\n+            Pat::Box { .. } => not_supported!(\"box pattern\"),\n+            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n+        })\n+    }\n+\n+    fn pattern_matching_variant(\n+        &mut self,\n+        mut cond_ty: Ty,\n+        mut binding_mode: BindingAnnotation,\n+        mut cond_place: Place,\n+        variant: VariantId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: &Option<usize>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+        let subst = match cond_ty.kind(Interner) {\n+            TyKind::Adt(_, s) => s,\n+            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n+        };\n+        let fields_type = self.db.field_types(variant);\n+        Ok(match variant {\n+            VariantId::EnumVariantId(v) => {\n+                let e = self.db.const_eval_discriminant(v)? as u128;\n+                let next = self.new_basic_block();\n+                let tmp = self.discr_temp_place();\n+                self.push_assignment(\n+                    current,\n+                    tmp.clone(),\n+                    Rvalue::Discriminant(cond_place.clone()),\n+                    span,\n+                );\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr: Operand::Copy(tmp),\n+                        targets: SwitchTargets::static_if(e, next, else_target),\n+                    },\n+                );\n+                let enum_data = self.db.enum_data(v.parent);\n+                let fields =\n+                    enum_data.variants[v.local_id].variant_data.fields().iter().map(|(x, _)| {\n+                        (\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                            fields_type[x].clone().substitute(Interner, subst),\n+                        )\n+                    });\n+                self.pattern_match_tuple_like(\n+                    next,\n+                    Some(else_target),\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n+                    (\n+                        PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n+                        fields_type[x].clone().substitute(Interner, subst),\n+                    )\n+                });\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n+                    *ellipsis,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n+    fn pattern_match_tuple_like(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n+        ellipsis: Option<usize>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        if ellipsis.is_some() {\n+            not_supported!(\"tuple like pattern with ellipsis\");\n+        }\n+        for (proj, arg, ty) in args {\n+            let mut cond_place = cond_place.clone();\n+            cond_place.projection.push(proj);\n+            (current, current_else) =\n+                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n+        }\n+        Ok((current, current_else))\n+    }\n+\n+    fn discr_temp_place(&mut self) -> Place {\n+        match &self.discr_temp {\n+            Some(x) => x.clone(),\n+            None => {\n+                let tmp: Place =\n+                    self.temp(TyBuilder::discr_ty()).expect(\"discr_ty is never unsized\").into();\n+                self.discr_temp = Some(tmp.clone());\n+                tmp\n+            }\n+        }\n+    }\n+\n+    fn lower_loop(\n+        &mut self,\n+        prev_block: BasicBlockId,\n+        label: Option<LabelId>,\n+        f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n+    ) -> Result<Option<BasicBlockId>> {\n+        if label.is_some() {\n+            not_supported!(\"loop with label\");\n+        }\n+        let begin = self.new_basic_block();\n+        let prev =\n+            mem::replace(&mut self.current_loop_blocks, Some(LoopBlocks { begin, end: None }));\n+        self.set_goto(prev_block, begin);\n+        f(self, begin)?;\n+        let my = mem::replace(&mut self.current_loop_blocks, prev)\n+            .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n+        Ok(my.end)\n+    }\n+\n+    fn has_adjustments(&self, expr_id: ExprId) -> bool {\n+        !self.infer.expr_adjustments.get(&expr_id).map(|x| x.is_empty()).unwrap_or(true)\n+    }\n+\n+    fn merge_blocks(\n+        &mut self,\n+        b1: Option<BasicBlockId>,\n+        b2: Option<BasicBlockId>,\n+    ) -> Option<BasicBlockId> {\n+        match (b1, b2) {\n+            (None, None) => None,\n+            (None, Some(b)) | (Some(b), None) => Some(b),\n+            (Some(b1), Some(b2)) => {\n+                let bm = self.new_basic_block();\n+                self.set_goto(b1, bm);\n+                self.set_goto(b2, bm);\n+                Some(bm)\n+            }\n+        }\n+    }\n+\n+    fn current_loop_end(&mut self) -> Result<BasicBlockId> {\n+        let r = match self\n+            .current_loop_blocks\n+            .as_mut()\n+            .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+            .end\n+        {\n+            Some(x) => x,\n+            None => {\n+                let s = self.new_basic_block();\n+                self.current_loop_blocks\n+                    .as_mut()\n+                    .ok_or(MirLowerError::ImplementationError(\"Current loop access out of loop\"))?\n+                    .end = Some(s);\n+                s\n+            }\n+        };\n+        Ok(r)\n+    }\n+\n+    fn is_uninhabited(&self, expr_id: ExprId) -> bool {\n+        is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n+    }\n+\n+    /// This function push `StorageLive` statements for each binding in the pattern.\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n+        // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n+        // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n+        // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n+        // allow this:\n+        //\n+        // ```\n+        // let x;\n+        // loop {\n+        //     let y = 2;\n+        //     x = &y;\n+        //     if some_condition {\n+        //         break; // we need to add a StorageDead(y) above this to kill the x borrow\n+        //     }\n+        // }\n+        // use(x)\n+        // ```\n+        // But I think this approach work for mutability analysis, as user can't write code which mutates a binding\n+        // after StorageDead, except loops, which are handled by this hack.\n+        let span = self.body.bindings[b]\n+            .definitions\n+            .first()\n+            .copied()\n+            .map(MirSpan::PatId)\n+            .unwrap_or(MirSpan::Unknown);\n+        let l = self.result.binding_locals[b];\n+        self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n+        self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n+        Ok(())\n+    }\n+\n+    fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n+        let crate_id = self.owner.module(self.db.upcast()).krate();\n+        self.db.lang_item(crate_id, item).ok_or(MirLowerError::LangItemNotFound(item))\n+    }\n+\n+    fn lower_block_to_place(\n+        &mut self,\n+        label: Option<LabelId>,\n+        statements: &[hir_def::expr::Statement],\n+        mut current: BasicBlockId,\n+        tail: Option<ExprId>,\n+        place: Place,\n+    ) -> Result<Option<Idx<BasicBlock>>> {\n+        if label.is_some() {\n+            not_supported!(\"block with label\");\n+        }\n+        for statement in statements.iter() {\n+            match statement {\n+                hir_def::expr::Statement::Let { pat, initializer, else_branch, type_ref: _ } => {\n+                    if let Some(expr_id) = initializer {\n+                        let else_block;\n+                        let Some((init_place, c)) =\n+                        self.lower_expr_as_place(current, *expr_id, true)?\n+                    else {\n+                        return Ok(None);\n+                    };\n+                        current = c;\n+                        (current, else_block) = self.pattern_match(\n+                            current,\n+                            None,\n+                            init_place,\n+                            self.expr_ty_after_adjustments(*expr_id),\n+                            *pat,\n+                            BindingAnnotation::Unannotated,\n+                        )?;\n+                        match (else_block, else_branch) {\n+                            (None, _) => (),\n+                            (Some(else_block), None) => {\n+                                self.set_terminator(else_block, Terminator::Unreachable);\n+                            }\n+                            (Some(else_block), Some(else_branch)) => {\n+                                if let Some((_, b)) =\n+                                    self.lower_expr_as_place(else_block, *else_branch, true)?\n+                                {\n+                                    self.set_terminator(b, Terminator::Unreachable);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                    let Some((_, c)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    current = c;\n+                }\n+            }\n+        }\n+        match tail {\n+            Some(tail) => self.lower_expr_to_place(tail, place, current),\n+            None => Ok(Some(current)),\n+        }\n+    }\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut Place,\n+) {\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        cond_place.projection.push(ProjectionElem::Deref);\n+    }\n+}\n+\n+fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n+    Ok(match (source_ty.kind(Interner), target_ty.kind(Interner)) {\n+        (TyKind::Scalar(s), TyKind::Scalar(t)) => match (s, t) {\n+            (chalk_ir::Scalar::Float(_), chalk_ir::Scalar::Float(_)) => CastKind::FloatToFloat,\n+            (chalk_ir::Scalar::Float(_), _) => CastKind::FloatToInt,\n+            (_, chalk_ir::Scalar::Float(_)) => CastKind::IntToFloat,\n+            (_, _) => CastKind::IntToInt,\n+        },\n+        // Enum to int casts\n+        (TyKind::Scalar(_), TyKind::Adt(..)) | (TyKind::Adt(..), TyKind::Scalar(_)) => {\n+            CastKind::IntToInt\n+        }\n+        (a, b) => not_supported!(\"Unknown cast between {a:?} and {b:?}\"),\n+    })\n+}\n+\n+pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n+    let _p = profile::span(\"mir_body_query\").detail(|| match def {\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n+        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n+        DefWithBodyId::ConstId(it) => {\n+            db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n+        }\n+        DefWithBodyId::VariantId(it) => {\n+            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+        }\n+    });\n+    let body = db.body(def);\n+    let infer = db.infer(def);\n+    let result = lower_to_mir(db, def, &body, &infer, body.body_expr)?;\n+    Ok(Arc::new(result))\n+}\n+\n+pub fn mir_body_recover(\n+    _db: &dyn HirDatabase,\n+    _cycle: &[String],\n+    _def: &DefWithBodyId,\n+) -> Result<Arc<MirBody>> {\n+    Err(MirLowerError::Loop)\n+}\n+\n+pub fn lower_to_mir(\n+    db: &dyn HirDatabase,\n+    owner: DefWithBodyId,\n+    body: &Body,\n+    infer: &InferenceResult,\n+    // FIXME: root_expr should always be the body.body_expr, but since `X` in `[(); X]` doesn't have its own specific body yet, we\n+    // need to take this input explicitly.\n+    root_expr: ExprId,\n+) -> Result<MirBody> {\n+    if let Some((_, x)) = infer.type_mismatches().next() {\n+        return Err(MirLowerError::TypeMismatch(x.clone()));\n+    }\n+    let mut basic_blocks = Arena::new();\n+    let start_block =\n+        basic_blocks.alloc(BasicBlock { statements: vec![], terminator: None, is_cleanup: false });\n+    let mut locals = Arena::new();\n+    // 0 is return local\n+    locals.alloc(Local { ty: infer[root_expr].clone() });\n+    let mut binding_locals: ArenaMap<BindingId, LocalId> = ArenaMap::new();\n+    // 1 to param_len is for params\n+    let param_locals: Vec<LocalId> = if let DefWithBodyId::FunctionId(fid) = owner {\n+        let substs = TyBuilder::placeholder_subst(db, fid);\n+        let callable_sig = db.callable_item_signature(fid.into()).substitute(Interner, &substs);\n+        body.params\n+            .iter()\n+            .zip(callable_sig.params().iter())\n+            .map(|(&x, ty)| {\n+                let local_id = locals.alloc(Local { ty: ty.clone() });\n+                if let Pat::Bind { id, subpat: None } = body[x] {\n+                    if matches!(\n+                        body.bindings[id].mode,\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable\n+                    ) {\n+                        binding_locals.insert(id, local_id);\n+                    }\n+                }\n+                local_id\n+            })\n+            .collect()\n+    } else {\n+        if !body.params.is_empty() {\n+            return Err(MirLowerError::TypeError(\"Unexpected parameter for non function body\"));\n+        }\n+        vec![]\n+    };\n+    // and then rest of bindings\n+    for (id, _) in body.bindings.iter() {\n+        if !binding_locals.contains_idx(id) {\n+            binding_locals.insert(id, locals.alloc(Local { ty: infer[id].clone() }));\n+        }\n+    }\n+    let mir = MirBody {\n+        basic_blocks,\n+        locals,\n+        start_block,\n+        binding_locals,\n+        param_locals,\n+        owner,\n+        arg_count: body.params.len(),\n+    };\n+    let mut ctx = MirLowerCtx {\n+        result: mir,\n+        db,\n+        infer,\n+        body,\n+        owner,\n+        current_loop_blocks: None,\n+        discr_temp: None,\n+    };\n+    let mut current = start_block;\n+    for (&param, local) in body.params.iter().zip(ctx.result.param_locals.clone().into_iter()) {\n+        if let Pat::Bind { id, .. } = body[param] {\n+            if local == ctx.result.binding_locals[id] {\n+                continue;\n+            }\n+        }\n+        let r = ctx.pattern_match(\n+            current,\n+            None,\n+            local.into(),\n+            ctx.result.locals[local].ty.clone(),\n+            param,\n+            BindingAnnotation::Unannotated,\n+        )?;\n+        if let Some(b) = r.1 {\n+            ctx.set_terminator(b, Terminator::Unreachable);\n+        }\n+        current = r.0;\n+    }\n+    if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n+        ctx.result.basic_blocks[b].terminator = Some(Terminator::Return);\n+    }\n+    Ok(ctx.result)\n+}"}, {"sha": "fe8147dcd3e7af51f5865289ebabe903023b45af", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,237 @@\n+//! MIR lowering for places\n+\n+use super::*;\n+use hir_expand::name;\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl MirLowerCtx<'_> {\n+    fn lower_expr_to_some_place_without_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty = self.expr_ty(expr_id);\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    fn lower_expr_to_some_place_with_adjust(\n+        &mut self,\n+        expr_id: ExprId,\n+        prev_block: BasicBlockId,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let ty =\n+            adjustments.last().map(|x| x.target.clone()).unwrap_or_else(|| self.expr_ty(expr_id));\n+        let place = self.temp(ty)?;\n+        let Some(current) = self.lower_expr_to_place_with_adjust(expr_id, place.into(), prev_block, adjustments)? else {\n+            return Ok(None);\n+        };\n+        Ok(Some((place.into(), current)))\n+    }\n+\n+    pub(super) fn lower_expr_as_place_with_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+        adjustments: &[Adjustment],\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_with_adjust(expr_id, current, adjustments)\n+        };\n+        if let Some((last, rest)) = adjustments.split_last() {\n+            match last.kind {\n+                Adjust::Deref(None) => {\n+                    let Some(mut x) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    x.0.projection.push(ProjectionElem::Deref);\n+                    Ok(Some(x))\n+                }\n+                Adjust::Deref(Some(od)) => {\n+                    let Some((r, current)) = self.lower_expr_as_place_with_adjust(\n+                        current,\n+                        expr_id,\n+                        upgrade_rvalue,\n+                        rest,\n+                    )? else {\n+                        return Ok(None);\n+                    };\n+                    self.lower_overloaded_deref(\n+                        current,\n+                        r,\n+                        rest.last()\n+                            .map(|x| x.target.clone())\n+                            .unwrap_or_else(|| self.expr_ty(expr_id)),\n+                        last.target.clone(),\n+                        expr_id.into(),\n+                        match od.0 {\n+                            Some(Mutability::Mut) => true,\n+                            Some(Mutability::Not) => false,\n+                            None => {\n+                                not_supported!(\"implicit overloaded deref with unknown mutability\")\n+                            }\n+                        },\n+                    )\n+                }\n+                Adjust::NeverToAny | Adjust::Borrow(_) | Adjust::Pointer(_) => try_rvalue(self),\n+            }\n+        } else {\n+            self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue)\n+        }\n+    }\n+\n+    pub(super) fn lower_expr_as_place(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        match self.infer.expr_adjustments.get(&expr_id) {\n+            Some(a) => self.lower_expr_as_place_with_adjust(current, expr_id, upgrade_rvalue, a),\n+            None => self.lower_expr_as_place_without_adjust(current, expr_id, upgrade_rvalue),\n+        }\n+    }\n+\n+    pub(super) fn lower_expr_as_place_without_adjust(\n+        &mut self,\n+        current: BasicBlockId,\n+        expr_id: ExprId,\n+        upgrade_rvalue: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let try_rvalue = |this: &mut MirLowerCtx<'_>| {\n+            if !upgrade_rvalue {\n+                return Err(MirLowerError::MutatingRvalue);\n+            }\n+            this.lower_expr_to_some_place_without_adjust(expr_id, current)\n+        };\n+        match &self.body.exprs[expr_id] {\n+            Expr::Path(p) => {\n+                let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n+                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path()) else {\n+                    return Err(MirLowerError::unresolved_path(self.db, p));\n+                };\n+                let pr = match pr {\n+                    ResolveValueResult::ValueNs(v) => v,\n+                    ResolveValueResult::Partial(..) => return try_rvalue(self),\n+                };\n+                match pr {\n+                    ValueNs::LocalBinding(pat_id) => {\n+                        Ok(Some((self.result.binding_locals[pat_id].into(), current)))\n+                    }\n+                    _ => try_rvalue(self),\n+                }\n+            }\n+            Expr::UnaryOp { expr, op } => match op {\n+                hir_def::expr::UnaryOp::Deref => {\n+                    if !matches!(\n+                        self.expr_ty(*expr).kind(Interner),\n+                        TyKind::Ref(..) | TyKind::Raw(..)\n+                    ) {\n+                        let Some(_) = self.lower_expr_as_place(current, *expr, true)? else {\n+                            return Ok(None);\n+                        };\n+                        not_supported!(\"explicit overloaded deref\");\n+                    }\n+                    let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                        return Ok(None);\n+                    };\n+                    r.projection.push(ProjectionElem::Deref);\n+                    Ok(Some((r, current)))\n+                }\n+                _ => try_rvalue(self),\n+            },\n+            Expr::Field { expr, .. } => {\n+                let Some((mut r, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n+                    return Ok(None);\n+                };\n+                self.push_field_projection(&mut r, expr_id)?;\n+                Ok(Some((r, current)))\n+            }\n+            Expr::Index { base, index } => {\n+                let base_ty = self.expr_ty_after_adjustments(*base);\n+                let index_ty = self.expr_ty_after_adjustments(*index);\n+                if index_ty != TyBuilder::usize()\n+                    || !matches!(base_ty.kind(Interner), TyKind::Array(..) | TyKind::Slice(..))\n+                {\n+                    not_supported!(\"overloaded index\");\n+                }\n+                let Some((mut p_base, current)) =\n+                    self.lower_expr_as_place(current, *base, true)? else {\n+                    return Ok(None);\n+                };\n+                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n+                let Some(current) = self.lower_expr_to_place(*index, l_index.into(), current)? else {\n+                    return Ok(None);\n+                };\n+                p_base.projection.push(ProjectionElem::Index(l_index));\n+                Ok(Some((p_base, current)))\n+            }\n+            _ => try_rvalue(self),\n+        }\n+    }\n+\n+    fn lower_overloaded_deref(\n+        &mut self,\n+        current: BasicBlockId,\n+        place: Place,\n+        source_ty: Ty,\n+        target_ty: Ty,\n+        span: MirSpan,\n+        mutability: bool,\n+    ) -> Result<Option<(Place, BasicBlockId)>> {\n+        let (chalk_mut, trait_lang_item, trait_method_name, borrow_kind) = if !mutability {\n+            (Mutability::Not, LangItem::Deref, name![deref], BorrowKind::Shared)\n+        } else {\n+            (\n+                Mutability::Mut,\n+                LangItem::DerefMut,\n+                name![deref_mut],\n+                BorrowKind::Mut { allow_two_phase_borrow: false },\n+            )\n+        };\n+        let ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), source_ty.clone()).intern(Interner);\n+        let target_ty_ref = TyKind::Ref(chalk_mut, static_lifetime(), target_ty).intern(Interner);\n+        let ref_place: Place = self.temp(ty_ref)?.into();\n+        self.push_assignment(current, ref_place.clone(), Rvalue::Ref(borrow_kind, place), span);\n+        let deref_trait = self\n+            .resolve_lang_item(trait_lang_item)?\n+            .as_trait()\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn = self\n+            .db\n+            .trait_data(deref_trait)\n+            .method_by_name(&trait_method_name)\n+            .ok_or(MirLowerError::LangItemNotFound(trait_lang_item))?;\n+        let deref_fn_op = Operand::const_zst(\n+            TyKind::FnDef(\n+                self.db.intern_callable_def(CallableDefId::FunctionId(deref_fn)).into(),\n+                Substitution::from1(Interner, source_ty),\n+            )\n+            .intern(Interner),\n+        );\n+        let mut result: Place = self.temp(target_ty_ref)?.into();\n+        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false)? else {\n+            return Ok(None);\n+        };\n+        result.projection.push(ProjectionElem::Deref);\n+        Ok(Some((result, current)))\n+    }\n+}"}, {"sha": "ffc08b7e346c7f1007c15c18f4d28bb720fa0b0b", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,348 @@\n+//! A pretty-printer for MIR.\n+\n+use std::fmt::{Display, Write};\n+\n+use hir_def::{body::Body, expr::BindingId};\n+use hir_expand::name::Name;\n+use la_arena::ArenaMap;\n+\n+use crate::{\n+    db::HirDatabase,\n+    display::HirDisplay,\n+    mir::{PlaceElem, ProjectionElem, StatementKind, Terminator},\n+};\n+\n+use super::{\n+    AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, Operand, Place, Rvalue, UnOp,\n+};\n+\n+impl MirBody {\n+    pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n+        let hir_body = db.body(self.owner);\n+        let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n+        ctx.for_body();\n+        ctx.result\n+    }\n+}\n+\n+struct MirPrettyCtx<'a> {\n+    body: &'a MirBody,\n+    hir_body: &'a Body,\n+    db: &'a dyn HirDatabase,\n+    result: String,\n+    ident: String,\n+    local_to_binding: ArenaMap<LocalId, BindingId>,\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+impl Write for MirPrettyCtx<'_> {\n+    fn write_str(&mut self, s: &str) -> std::fmt::Result {\n+        let mut it = s.split('\\n'); // note: `.lines()` is wrong here\n+        self.write(it.next().unwrap_or_default());\n+        for line in it {\n+            self.write_line();\n+            self.write(line);\n+        }\n+        Ok(())\n+    }\n+}\n+\n+enum LocalName {\n+    Unknown(LocalId),\n+    Binding(Name, LocalId),\n+}\n+\n+impl Display for LocalName {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            LocalName::Unknown(l) => write!(f, \"_{}\", u32::from(l.into_raw())),\n+            LocalName::Binding(n, l) => write!(f, \"{n}_{}\", u32::from(l.into_raw())),\n+        }\n+    }\n+}\n+\n+impl<'a> MirPrettyCtx<'a> {\n+    fn for_body(&mut self) {\n+        self.with_block(|this| {\n+            this.locals();\n+            wln!(this);\n+            this.blocks();\n+        });\n+    }\n+\n+    fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n+        self.ident += \"    \";\n+        wln!(self, \"{{\");\n+        f(self);\n+        for _ in 0..4 {\n+            self.result.pop();\n+            self.ident.pop();\n+        }\n+        wln!(self, \"}}\");\n+    }\n+\n+    fn new(body: &'a MirBody, hir_body: &'a Body, db: &'a dyn HirDatabase) -> Self {\n+        let local_to_binding = body.binding_locals.iter().map(|(x, y)| (*y, x)).collect();\n+        MirPrettyCtx {\n+            body,\n+            db,\n+            result: String::new(),\n+            ident: String::new(),\n+            local_to_binding,\n+            hir_body,\n+        }\n+    }\n+\n+    fn write_line(&mut self) {\n+        self.result.push('\\n');\n+        self.result += &self.ident;\n+    }\n+\n+    fn write(&mut self, line: &str) {\n+        self.result += line;\n+    }\n+\n+    fn locals(&mut self) {\n+        for (id, local) in self.body.locals.iter() {\n+            wln!(self, \"let {}: {};\", self.local_name(id), local.ty.display(self.db));\n+        }\n+    }\n+\n+    fn local_name(&self, local: LocalId) -> LocalName {\n+        match self.local_to_binding.get(local) {\n+            Some(b) => LocalName::Binding(self.hir_body.bindings[*b].name.clone(), local),\n+            None => LocalName::Unknown(local),\n+        }\n+    }\n+\n+    fn basic_block_id(&self, basic_block_id: BasicBlockId) -> String {\n+        format!(\"'bb{}\", u32::from(basic_block_id.into_raw()))\n+    }\n+\n+    fn blocks(&mut self) {\n+        for (id, block) in self.body.basic_blocks.iter() {\n+            wln!(self);\n+            w!(self, \"{}: \", self.basic_block_id(id));\n+            self.with_block(|this| {\n+                for statement in &block.statements {\n+                    match &statement.kind {\n+                        StatementKind::Assign(l, r) => {\n+                            this.place(l);\n+                            w!(this, \" = \");\n+                            this.rvalue(r);\n+                            wln!(this, \";\");\n+                        }\n+                        StatementKind::StorageDead(p) => {\n+                            wln!(this, \"StorageDead({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::StorageLive(p) => {\n+                            wln!(this, \"StorageLive({})\", this.local_name(*p));\n+                        }\n+                        StatementKind::Deinit(p) => {\n+                            w!(this, \"Deinit(\");\n+                            this.place(p);\n+                            wln!(this, \");\");\n+                        }\n+                        StatementKind::Nop => wln!(this, \"Nop;\"),\n+                    }\n+                }\n+                match &block.terminator {\n+                    Some(terminator) => match terminator {\n+                        Terminator::Goto { target } => {\n+                            wln!(this, \"goto 'bb{};\", u32::from(target.into_raw()))\n+                        }\n+                        Terminator::SwitchInt { discr, targets } => {\n+                            w!(this, \"switch \");\n+                            this.operand(discr);\n+                            w!(this, \" \");\n+                            this.with_block(|this| {\n+                                for (c, b) in targets.iter() {\n+                                    wln!(this, \"{c} => {},\", this.basic_block_id(b));\n+                                }\n+                                wln!(this, \"_ => {},\", this.basic_block_id(targets.otherwise()));\n+                            });\n+                        }\n+                        Terminator::Call { func, args, destination, target, .. } => {\n+                            w!(this, \"Call \");\n+                            this.with_block(|this| {\n+                                w!(this, \"func: \");\n+                                this.operand(func);\n+                                wln!(this, \",\");\n+                                w!(this, \"args: [\");\n+                                this.operand_list(args);\n+                                wln!(this, \"],\");\n+                                w!(this, \"destination: \");\n+                                this.place(destination);\n+                                wln!(this, \",\");\n+                                w!(this, \"target: \");\n+                                match target {\n+                                    Some(t) => w!(this, \"{}\", this.basic_block_id(*t)),\n+                                    None => w!(this, \"<unreachable>\"),\n+                                }\n+                                wln!(this, \",\");\n+                            });\n+                        }\n+                        _ => wln!(this, \"{:?};\", terminator),\n+                    },\n+                    None => wln!(this, \"<no-terminator>;\"),\n+                }\n+            })\n+        }\n+    }\n+\n+    fn place(&mut self, p: &Place) {\n+        fn f(this: &mut MirPrettyCtx<'_>, local: LocalId, projections: &[PlaceElem]) {\n+            let Some((last, head)) = projections.split_last() else {\n+                // no projection\n+                w!(this, \"{}\", this.local_name(local));\n+                return;\n+            };\n+            match last {\n+                ProjectionElem::Deref => {\n+                    w!(this, \"(*\");\n+                    f(this, local, head);\n+                    w!(this, \")\");\n+                }\n+                ProjectionElem::Field(field) => {\n+                    let variant_data = field.parent.variant_data(this.db.upcast());\n+                    let name = &variant_data.fields()[field.local_id].name;\n+                    match field.parent {\n+                        hir_def::VariantId::EnumVariantId(e) => {\n+                            w!(this, \"(\");\n+                            f(this, local, head);\n+                            let variant_name =\n+                                &this.db.enum_data(e.parent).variants[e.local_id].name;\n+                            w!(this, \" as {}).{}\", variant_name, name);\n+                        }\n+                        hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {\n+                            f(this, local, head);\n+                            w!(this, \".{name}\");\n+                        }\n+                    }\n+                }\n+                ProjectionElem::TupleField(x) => {\n+                    f(this, local, head);\n+                    w!(this, \".{}\", x);\n+                }\n+                ProjectionElem::Index(l) => {\n+                    f(this, local, head);\n+                    w!(this, \"[{}]\", this.local_name(*l));\n+                }\n+                x => {\n+                    f(this, local, head);\n+                    w!(this, \".{:?}\", x);\n+                }\n+            }\n+        }\n+        f(self, p.local, &p.projection);\n+    }\n+\n+    fn operand(&mut self, r: &Operand) {\n+        match r {\n+            Operand::Copy(p) | Operand::Move(p) => {\n+                // MIR at the time of writing doesn't have difference between move and copy, so we show them\n+                // equally. Feel free to change it.\n+                self.place(p);\n+            }\n+            Operand::Constant(c) => w!(self, \"Const({})\", c.display(self.db)),\n+        }\n+    }\n+\n+    fn rvalue(&mut self, r: &Rvalue) {\n+        match r {\n+            Rvalue::Use(op) => self.operand(op),\n+            Rvalue::Ref(r, p) => {\n+                match r {\n+                    BorrowKind::Shared => w!(self, \"&\"),\n+                    BorrowKind::Shallow => w!(self, \"&shallow \"),\n+                    BorrowKind::Unique => w!(self, \"&uniq \"),\n+                    BorrowKind::Mut { .. } => w!(self, \"&mut \"),\n+                }\n+                self.place(p);\n+            }\n+            Rvalue::Aggregate(AggregateKind::Tuple(_), x) => {\n+                w!(self, \"(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Array(_), x) => {\n+                w!(self, \"[\");\n+                self.operand_list(x);\n+                w!(self, \"]\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Adt(_, _), x) => {\n+                w!(self, \"Adt(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Aggregate(AggregateKind::Union(_, _), x) => {\n+                w!(self, \"Union(\");\n+                self.operand_list(x);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Len(p) => {\n+                w!(self, \"Len(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::Cast(ck, op, ty) => {\n+                w!(self, \"Discriminant({ck:?}\");\n+                self.operand(op);\n+                w!(self, \"{})\", ty.display(self.db));\n+            }\n+            Rvalue::CheckedBinaryOp(b, o1, o2) => {\n+                self.operand(o1);\n+                w!(self, \" {b} \");\n+                self.operand(o2);\n+            }\n+            Rvalue::UnaryOp(u, o) => {\n+                let u = match u {\n+                    UnOp::Not => \"!\",\n+                    UnOp::Neg => \"-\",\n+                };\n+                w!(self, \"{u} \");\n+                self.operand(o);\n+            }\n+            Rvalue::Discriminant(p) => {\n+                w!(self, \"Discriminant(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+            Rvalue::ShallowInitBox(op, _) => {\n+                w!(self, \"ShallowInitBox(\");\n+                self.operand(op);\n+                w!(self, \")\");\n+            }\n+            Rvalue::CopyForDeref(p) => {\n+                w!(self, \"CopyForDeref(\");\n+                self.place(p);\n+                w!(self, \")\");\n+            }\n+        }\n+    }\n+\n+    fn operand_list(&mut self, x: &[Operand]) {\n+        let mut it = x.iter();\n+        if let Some(first) = it.next() {\n+            self.operand(first);\n+            for op in it {\n+                w!(self, \", \");\n+                self.operand(op);\n+            }\n+        }\n+    }\n+}"}, {"sha": "bcd63d9472a8102c854790ad722f79558e261b50", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -61,22 +61,27 @@ fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n     Some(tracing::subscriber::set_default(subscriber))\n }\n \n+#[track_caller]\n fn check_types(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, false)\n }\n \n+#[track_caller]\n fn check_types_source_code(ra_fixture: &str) {\n     check_impl(ra_fixture, false, true, true)\n }\n \n+#[track_caller]\n fn check_no_mismatches(ra_fixture: &str) {\n     check_impl(ra_fixture, true, false, false)\n }\n \n+#[track_caller]\n fn check(ra_fixture: &str) {\n     check_impl(ra_fixture, false, false, false)\n }\n \n+#[track_caller]\n fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_source: bool) {\n     let _tracing = setup_tracing();\n     let (db, files) = TestDB::with_many_files(ra_fixture);\n@@ -158,7 +163,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n         }\n \n@@ -174,7 +179,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n             if let Some(expected) = adjustments.remove(&range) {\n                 let adjustments = inference_result\n@@ -191,30 +196,11 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n             }\n         }\n \n-        for (pat, mismatch) in inference_result.pat_type_mismatches() {\n-            let node = match pat_node(&body_source_map, pat, &db) {\n-                Some(value) => value,\n-                None => continue,\n-            };\n-            let range = node.as_ref().original_file_range(&db);\n-            let actual = format!(\n-                \"expected {}, got {}\",\n-                mismatch.expected.display_test(&db),\n-                mismatch.actual.display_test(&db)\n-            );\n-            match mismatches.remove(&range) {\n-                Some(annotation) => assert_eq!(actual, annotation),\n-                None => format_to!(unexpected_type_mismatches, \"{:?}: {}\\n\", range.range, actual),\n-            }\n-        }\n-        for (expr, mismatch) in inference_result.expr_type_mismatches() {\n-            let node = match body_source_map.expr_syntax(expr) {\n-                Ok(sp) => {\n-                    let root = db.parse_or_expand(sp.file_id).unwrap();\n-                    sp.map(|ptr| ptr.to_node(&root).syntax().clone())\n-                }\n-                Err(SyntheticSyntax) => continue,\n-            };\n+        for (expr_or_pat, mismatch) in inference_result.type_mismatches() {\n+            let Some(node) = (match expr_or_pat {\n+                hir_def::expr::ExprOrPatId::ExprId(expr) => expr_node(&body_source_map, expr, &db),\n+                hir_def::expr::ExprOrPatId::PatId(pat) => pat_node(&body_source_map, pat, &db),\n+            }) else { continue; };\n             let range = node.as_ref().original_file_range(&db);\n             let actual = format!(\n                 \"expected {}, got {}\","}, {"sha": "b524922b6cf40a61947dd6043a44a382780945f7", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -258,6 +258,7 @@ fn test() {\n \n #[test]\n fn coerce_autoderef_block() {\n+    // FIXME: We should know mutability in overloaded deref\n     check_no_mismatches(\n         r#\"\n //- minicore: deref\n@@ -267,7 +268,7 @@ fn takes_ref_str(x: &str) {}\n fn returns_string() -> String { loop {} }\n fn test() {\n     takes_ref_str(&{ returns_string() });\n-               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(Not))), Borrow(Ref(Not))\n+               // ^^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(None), Deref(Some(OverloadedDeref(None))), Borrow(Ref(Not))\n }\n \"#,\n     );"}, {"sha": "1876be303ad44862802ac0aae149a5502749bfe1", "filename": "crates/hir-ty/src/tests/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -73,3 +73,24 @@ fn test(x: bool) -> &'static str {\n \"#,\n     );\n }\n+\n+#[test]\n+fn non_unit_block_expr_stmt_no_semi() {\n+    check(\n+        r#\"\n+fn test(x: bool) {\n+    if x {\n+        \"notok\"\n+      //^^^^^^^ expected (), got &str\n+    } else {\n+        \"ok\"\n+      //^^^^ expected (), got &str\n+    }\n+    match x { true => true, false => 0 }\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), got bool\n+                                   //^ expected bool, got i32\n+    ()\n+}\n+\"#,\n+    );\n+}"}, {"sha": "e568e7013fac0eefd670ecee7e1dd0c8892a1611", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1167,7 +1167,6 @@ fn test() {\n             123..167 '{     ...o(); }': ()\n             133..134 's': &S\n             137..151 'unsafe { f() }': &S\n-            137..151 'unsafe { f() }': &S\n             146..147 'f': fn f() -> &S\n             146..149 'f()': &S\n             157..158 's': &S\n@@ -1253,6 +1252,7 @@ fn foo<T: Trait>(a: &T) {\n \n #[test]\n fn autoderef_visibility_field() {\n+    // FIXME: We should know mutability in overloaded deref\n     check(\n         r#\"\n //- minicore: deref\n@@ -1274,7 +1274,7 @@ mod a {\n mod b {\n     fn foo() {\n         let x = super::a::Bar::new().0;\n-             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(Not)))\n+             // ^^^^^^^^^^^^^^^^^^^^ adjustments: Deref(Some(OverloadedDeref(None)))\n              // ^^^^^^^^^^^^^^^^^^^^^^ type: char\n     }\n }"}, {"sha": "74bcab6caa94a3ed1c14cc138e0a47f6c7e1c77b", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -476,7 +476,7 @@ fn infer_adt_pattern() {\n             183..184 'x': usize\n             190..191 'x': usize\n             201..205 'E::B': E\n-            209..212 'foo': bool\n+            209..212 'foo': {unknown}\n             216..217 '1': usize\n             227..231 'E::B': E\n             235..237 '10': usize\n@@ -953,9 +953,9 @@ fn main() {\n             42..51 'true | ()': bool\n             49..51 '()': ()\n             57..59 '{}': ()\n-            68..80 '(() | true,)': ((),)\n+            68..80 '(() | true,)': (bool,)\n             69..71 '()': ()\n-            69..78 '() | true': ()\n+            69..78 '() | true': bool\n             74..78 'true': bool\n             74..78 'true': bool\n             84..86 '{}': ()\n@@ -964,19 +964,15 @@ fn main() {\n             96..102 '_ | ()': bool\n             100..102 '()': ()\n             108..110 '{}': ()\n-            119..128 '(() | _,)': ((),)\n+            119..128 '(() | _,)': (bool,)\n             120..122 '()': ()\n-            120..126 '() | _': ()\n+            120..126 '() | _': bool\n             125..126 '_': bool\n             132..134 '{}': ()\n             49..51: expected bool, got ()\n-            68..80: expected (bool,), got ((),)\n             69..71: expected bool, got ()\n-            69..78: expected bool, got ()\n             100..102: expected bool, got ()\n-            119..128: expected (bool,), got ((),)\n             120..122: expected bool, got ()\n-            120..126: expected bool, got ()\n         \"#]],\n     );\n }\n@@ -1092,3 +1088,19 @@ fn my_fn(foo: ...) {}\n \"#,\n     );\n }\n+\n+#[test]\n+fn ref_pat_mutability() {\n+    check(\n+        r#\"\n+fn foo() {\n+    let &() = &();\n+    let &mut () = &mut ();\n+    let &mut () = &();\n+      //^^^^^^^ expected &(), got &mut ()\n+    let &() = &mut ();\n+      //^^^ expected &mut (), got &()\n+}\n+\"#,\n+    );\n+}"}, {"sha": "e6b4f13c8d113549c63c820afb4d5709e0c3941d", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -270,7 +270,7 @@ fn infer_std_crash_5() {\n             61..320 '{     ...     }': ()\n             75..79 'name': &{unknown}\n             82..166 'if doe...     }': &{unknown}\n-            85..98 'doesnt_matter': bool\n+            85..98 'doesnt_matter': {unknown}\n             99..128 '{     ...     }': &{unknown}\n             113..118 'first': &{unknown}\n             134..166 '{     ...     }': &{unknown}\n@@ -279,7 +279,7 @@ fn infer_std_crash_5() {\n             181..188 'content': &{unknown}\n             191..313 'if ICE...     }': &{unknown}\n             194..231 'ICE_RE..._VALUE': {unknown}\n-            194..247 'ICE_RE...&name)': bool\n+            194..247 'ICE_RE...&name)': {unknown}\n             241..246 '&name': &&{unknown}\n             242..246 'name': &{unknown}\n             248..276 '{     ...     }': &{unknown}\n@@ -1015,9 +1015,9 @@ fn cfg_tail() {\n             20..31 '{ \"first\" }': ()\n             22..29 '\"first\"': &str\n             72..190 '{     ...] 13 }': ()\n-            78..88 '{ \"fake\" }': &str\n+            78..88 '{ \"fake\" }': ()\n             80..86 '\"fake\"': &str\n-            93..103 '{ \"fake\" }': &str\n+            93..103 '{ \"fake\" }': ()\n             95..101 '\"fake\"': &str\n             108..120 '{ \"second\" }': ()\n             110..118 '\"second\"': &str\n@@ -1744,3 +1744,15 @@ fn foo(b: Bar) {\n \"#,\n     );\n }\n+\n+#[test]\n+fn regression_14305() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: add\n+trait Tr {}\n+impl Tr for [u8; C] {}\n+const C: usize = 2 + 2;\n+\"#,\n+    );\n+}"}, {"sha": "0e9c349afef365f8140e9ce4b4c6c70a09e8d399", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -352,15 +352,13 @@ unsafe fn baz(u: MyUnion) {\n             71..89 'MyUnio...o: 0 }': MyUnion\n             86..87 '0': u32\n             95..113 'unsafe...(u); }': ()\n-            95..113 'unsafe...(u); }': ()\n             104..107 'baz': fn baz(MyUnion)\n             104..110 'baz(u)': ()\n             108..109 'u': MyUnion\n             122..123 'u': MyUnion\n             126..146 'MyUnio... 0.0 }': MyUnion\n             141..144 '0.0': f32\n             152..170 'unsafe...(u); }': ()\n-            152..170 'unsafe...(u); }': ()\n             161..164 'baz': fn baz(MyUnion)\n             161..167 'baz(u)': ()\n             165..166 'u': MyUnion\n@@ -2077,22 +2075,17 @@ async fn main() {\n             16..193 '{     ...2 }; }': ()\n             26..27 'x': i32\n             30..43 'unsafe { 92 }': i32\n-            30..43 'unsafe { 92 }': i32\n             39..41 '92': i32\n             53..54 'y': impl Future<Output = ()>\n-            57..85 'async ...wait }': ()\n             57..85 'async ...wait }': impl Future<Output = ()>\n-            65..77 'async { () }': ()\n             65..77 'async { () }': impl Future<Output = ()>\n             65..83 'async ....await': ()\n             73..75 '()': ()\n             95..96 'z': ControlFlow<(), ()>\n-            130..140 'try { () }': ()\n             130..140 'try { () }': ControlFlow<(), ()>\n             136..138 '()': ()\n             150..151 'w': i32\n             154..166 'const { 92 }': i32\n-            154..166 'const { 92 }': i32\n             162..164 '92': i32\n             176..177 't': i32\n             180..190 ''a: { 92 }': i32\n@@ -2122,7 +2115,6 @@ fn main() {\n             83..84 'f': F\n             89..91 '{}': ()\n             103..231 '{     ... }); }': ()\n-            109..161 'async ...     }': Result<(), ()>\n             109..161 'async ...     }': impl Future<Output = Result<(), ()>>\n             125..139 'return Err(())': !\n             132..135 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -2134,7 +2126,6 @@ fn main() {\n             167..171 'test': fn test<(), (), || -> impl Future<Output = Result<(), ()>>, impl Future<Output = Result<(), ()>>>(|| -> impl Future<Output = Result<(), ()>>)\n             167..228 'test(|...    })': ()\n             172..227 '|| asy...     }': || -> impl Future<Output = Result<(), ()>>\n-            175..227 'async ...     }': Result<(), ()>\n             175..227 'async ...     }': impl Future<Output = Result<(), ()>>\n             191..205 'return Err(())': !\n             198..201 'Err': Err<(), ()>(()) -> Result<(), ()>\n@@ -3283,3 +3274,18 @@ fn func() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn issue_14275() {\n+    // FIXME: evaluate const generic\n+    check_types(\n+        r#\"\n+struct Foo<const T: bool>;\n+fn main() {\n+    const B: bool = false;\n+    let foo = Foo::<B>;\n+      //^^^ Foo<_>\n+}\n+\"#,\n+    );\n+}"}, {"sha": "34d957e26ef5bf0ceb411972c50e277fb5d60800", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,6 +5,7 @@ use std::iter;\n \n use base_db::CrateId;\n use chalk_ir::{cast::Cast, fold::Shift, BoundVar, DebruijnIndex};\n+use either::Either;\n use hir_def::{\n     db::DefDatabase,\n     generics::{\n@@ -19,7 +20,6 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n use intern::Interned;\n-use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n \n@@ -315,7 +315,10 @@ fn parent_generic_def(db: &dyn DefDatabase, def: GenericDefId) -> Option<Generic\n         GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n         GenericDefId::ConstId(it) => it.lookup(db).container,\n         GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n-        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n+        GenericDefId::AdtId(_)\n+        | GenericDefId::TraitId(_)\n+        | GenericDefId::ImplId(_)\n+        | GenericDefId::TraitAliasId(_) => return None,\n     };\n \n     match container {"}, {"sha": "db0b84ef0887b7d53f87e9f68fcfbf61130ab333", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -14,7 +14,8 @@ use syntax::{ast, AstNode};\n \n use crate::{\n     Adt, AssocItem, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam,\n-    Macro, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    Macro, Module, ModuleDef, Static, Struct, Trait, TraitAlias, TypeAlias, TypeParam, Union,\n+    Variant,\n };\n \n pub trait HasAttrs {\n@@ -60,6 +61,7 @@ impl_has_attrs![\n     (Static, StaticId),\n     (Const, ConstId),\n     (Trait, TraitId),\n+    (TraitAlias, TraitAliasId),\n     (TypeAlias, TypeAliasId),\n     (Macro, MacroId),\n     (Function, FunctionId),\n@@ -134,6 +136,7 @@ fn resolve_doc_path(\n         AttrDefId::StaticId(it) => it.resolver(db.upcast()),\n         AttrDefId::ConstId(it) => it.resolver(db.upcast()),\n         AttrDefId::TraitId(it) => it.resolver(db.upcast()),\n+        AttrDefId::TraitAliasId(it) => it.resolver(db.upcast()),\n         AttrDefId::TypeAliasId(it) => it.resolver(db.upcast()),\n         AttrDefId::ImplId(it) => it.resolver(db.upcast()),\n         AttrDefId::ExternBlockId(it) => it.resolver(db.upcast()),"}, {"sha": "cd465739139654bad7532e898d322c0dd5bb3ead", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,8 +5,9 @@\n //! But we need this for at least LRU caching at the query level.\n pub use hir_def::db::*;\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, HygieneFrameQuery, InternMacroCallQuery,\n-    MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroExpansionQuery,\n+    AstDatabase, AstDatabaseStorage, AstIdMapQuery, ExpandProcMacroQuery, HygieneFrameQuery,\n+    InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandErrorQuery,\n+    MacroExpandQuery, ParseMacroExpansionQuery,\n };\n pub use hir_ty::db::*;\n "}, {"sha": "8f019a81b2db4f73d64a23cbf89c9689f1a50810", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{AssocItem, Field, MacroKind, Type};\n+use crate::{AssocItem, Field, Local, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -31,6 +31,7 @@ macro_rules! diagnostics {\n \n diagnostics![\n     BreakOutsideOfLoop,\n+    ExpectedFunction,\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n@@ -40,17 +41,21 @@ diagnostics![\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    NeedMut,\n     NoSuchField,\n     PrivateAssocItem,\n     PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n+    UnresolvedField,\n     UnresolvedImport,\n     UnresolvedMacroCall,\n+    UnresolvedMethodCall,\n     UnresolvedModule,\n     UnresolvedProcMacro,\n+    UnusedMut,\n ];\n \n #[derive(Debug)]\n@@ -130,6 +135,28 @@ pub struct PrivateAssocItem {\n     pub item: AssocItem,\n }\n \n+#[derive(Debug)]\n+pub struct ExpectedFunction {\n+    pub call: InFile<AstPtr<ast::Expr>>,\n+    pub found: Type,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedField {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub method_with_same_name_exists: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnresolvedMethodCall {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub field_with_same_name: Option<Type>,\n+}\n+\n #[derive(Debug)]\n pub struct PrivateField {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n@@ -140,6 +167,7 @@ pub struct PrivateField {\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n     pub is_break: bool,\n+    pub bad_value_break: bool,\n }\n \n #[derive(Debug)]\n@@ -171,17 +199,26 @@ pub struct MismatchedArgCount {\n \n #[derive(Debug)]\n pub struct MissingMatchArms {\n-    pub file: HirFileId,\n-    pub match_expr: AstPtr<ast::Expr>,\n+    pub scrutinee_expr: InFile<AstPtr<ast::Expr>>,\n     pub uncovered_patterns: String,\n }\n \n #[derive(Debug)]\n pub struct TypeMismatch {\n-    // FIXME: add mismatches in patterns as well\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub expr_or_pat: Either<InFile<AstPtr<ast::Expr>>, InFile<AstPtr<ast::Pat>>>,\n     pub expected: Type,\n     pub actual: Type,\n }\n \n+#[derive(Debug)]\n+pub struct NeedMut {\n+    pub local: Local,\n+    pub span: InFile<SyntaxNodePtr>,\n+}\n+\n+#[derive(Debug)]\n+pub struct UnusedMut {\n+    pub local: Local,\n+}\n+\n pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "5aae92efd19ed7c8685960db82ff33a955b8986c", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -17,15 +17,23 @@ use hir_ty::{\n };\n \n use crate::{\n-    Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n-    LifetimeParam, Macro, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias,\n-    TypeOrConstParam, TypeParam, Union, Variant,\n+    Adt, AsAssocItem, AssocItemContainer, Const, ConstParam, Enum, Field, Function, GenericParam,\n+    HasCrate, HasVisibility, LifetimeParam, Macro, Module, Static, Struct, Trait, TraitAlias,\n+    TyBuilder, Type, TypeAlias, TypeOrConstParam, TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        let data = f.db.function_data(self.id);\n-        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let db = f.db;\n+        let data = db.function_data(self.id);\n+        let container = self.as_assoc_item(db).map(|it| it.container(db));\n+        let mut module = self.module(db);\n+        if let Some(AssocItemContainer::Impl(_)) = container {\n+            // Block-local impls are \"hoisted\" to the nearest (non-block) module.\n+            module = module.nearest_non_block_module(db);\n+        }\n+        let module_id = module.id;\n+        write_visibility(module_id, self.visibility(db), f)?;\n         if data.has_default_kw() {\n             f.write_str(\"default \")?;\n         }\n@@ -35,7 +43,7 @@ impl HirDisplay for Function {\n         if data.has_async_kw() {\n             f.write_str(\"async \")?;\n         }\n-        if self.is_unsafe_to_call(f.db) {\n+        if self.is_unsafe_to_call(db) {\n             f.write_str(\"unsafe \")?;\n         }\n         if let Some(abi) = &data.abi {\n@@ -50,7 +58,7 @@ impl HirDisplay for Function {\n \n         let write_self_param = |ty: &TypeRef, f: &mut HirFormatter<'_>| match ty {\n             TypeRef::Path(p) if p.is_self_type() => f.write_str(\"self\"),\n-            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n+            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner, TypeRef::Path(p) if p.is_self_type()) =>\n             {\n                 f.write_char('&')?;\n                 if let Some(lifetime) = lifetime {\n@@ -442,8 +450,15 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n \n impl HirDisplay for Const {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n-        let data = f.db.const_data(self.id);\n+        let db = f.db;\n+        let container = self.as_assoc_item(db).map(|it| it.container(db));\n+        let mut module = self.module(db);\n+        if let Some(AssocItemContainer::Impl(_)) = container {\n+            // Block-local impls are \"hoisted\" to the nearest (non-block) module.\n+            module = module.nearest_non_block_module(db);\n+        }\n+        write_visibility(module.id, self.visibility(db), f)?;\n+        let data = db.const_data(self.id);\n         f.write_str(\"const \")?;\n         match &data.name {\n             Some(name) => write!(f, \"{name}: \")?,\n@@ -486,6 +501,22 @@ impl HirDisplay for Trait {\n     }\n }\n \n+impl HirDisplay for TraitAlias {\n+    fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.trait_alias_data(self.id);\n+        write!(f, \"trait {}\", data.name)?;\n+        let def_id = GenericDefId::TraitAliasId(self.id);\n+        write_generic_params(def_id, f)?;\n+        f.write_str(\" = \")?;\n+        // FIXME: Currently we lower every bounds in a trait alias as a trait bound on `Self` i.e.\n+        // `trait Foo = Bar` is stored and displayed as `trait Foo = where Self: Bar`, which might\n+        // be less readable.\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for TypeAlias {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;"}, {"sha": "aaaa7abf3863c35057113075133e3b5d399493ee", "filename": "crates/hir/src/from_id.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -4,7 +4,7 @@\n //! are splitting the hir.\n \n use hir_def::{\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, GenericDefId, GenericParamId,\n     ModuleDefId, VariantId,\n };\n@@ -37,6 +37,7 @@ from_id![\n     (hir_def::EnumId, crate::Enum),\n     (hir_def::TypeAliasId, crate::TypeAlias),\n     (hir_def::TraitId, crate::Trait),\n+    (hir_def::TraitAliasId, crate::TraitAlias),\n     (hir_def::StaticId, crate::Static),\n     (hir_def::ConstId, crate::Const),\n     (hir_def::FunctionId, crate::Function),\n@@ -110,6 +111,7 @@ impl From<ModuleDefId> for ModuleDef {\n             ModuleDefId::ConstId(it) => ModuleDef::Const(it.into()),\n             ModuleDefId::StaticId(it) => ModuleDef::Static(it.into()),\n             ModuleDefId::TraitId(it) => ModuleDef::Trait(it.into()),\n+            ModuleDefId::TraitAliasId(it) => ModuleDef::TraitAlias(it.into()),\n             ModuleDefId::TypeAliasId(it) => ModuleDef::TypeAlias(it.into()),\n             ModuleDefId::BuiltinType(it) => ModuleDef::BuiltinType(it.into()),\n             ModuleDefId::MacroId(it) => ModuleDef::Macro(it.into()),\n@@ -127,6 +129,7 @@ impl From<ModuleDef> for ModuleDefId {\n             ModuleDef::Const(it) => ModuleDefId::ConstId(it.into()),\n             ModuleDef::Static(it) => ModuleDefId::StaticId(it.into()),\n             ModuleDef::Trait(it) => ModuleDefId::TraitId(it.into()),\n+            ModuleDef::TraitAlias(it) => ModuleDefId::TraitAliasId(it.into()),\n             ModuleDef::TypeAlias(it) => ModuleDefId::TypeAliasId(it.into()),\n             ModuleDef::BuiltinType(it) => ModuleDefId::BuiltinType(it.into()),\n             ModuleDef::Macro(it) => ModuleDefId::MacroId(it.into()),\n@@ -172,6 +175,7 @@ impl From<GenericDef> for GenericDefId {\n             GenericDef::Function(it) => GenericDefId::FunctionId(it.id),\n             GenericDef::Adt(it) => GenericDefId::AdtId(it.into()),\n             GenericDef::Trait(it) => GenericDefId::TraitId(it.id),\n+            GenericDef::TraitAlias(it) => GenericDefId::TraitAliasId(it.id),\n             GenericDef::TypeAlias(it) => GenericDefId::TypeAliasId(it.id),\n             GenericDef::Impl(it) => GenericDefId::ImplId(it.id),\n             GenericDef::Variant(it) => GenericDefId::EnumVariantId(it.into()),\n@@ -186,6 +190,7 @@ impl From<GenericDefId> for GenericDef {\n             GenericDefId::FunctionId(it) => GenericDef::Function(it.into()),\n             GenericDefId::AdtId(it) => GenericDef::Adt(it.into()),\n             GenericDefId::TraitId(it) => GenericDef::Trait(it.into()),\n+            GenericDefId::TraitAliasId(it) => GenericDef::TraitAlias(it.into()),\n             GenericDefId::TypeAliasId(it) => GenericDef::TypeAlias(it.into()),\n             GenericDefId::ImplId(it) => GenericDef::Impl(it.into()),\n             GenericDefId::EnumVariantId(it) => GenericDef::Variant(it.into()),\n@@ -246,9 +251,9 @@ impl From<AssocItem> for GenericDefId {\n     }\n }\n \n-impl From<(DefWithBodyId, PatId)> for Local {\n-    fn from((parent, pat_id): (DefWithBodyId, PatId)) -> Self {\n-        Local { parent, pat_id }\n+impl From<(DefWithBodyId, BindingId)> for Local {\n+    fn from((parent, binding_id): (DefWithBodyId, BindingId)) -> Self {\n+        Local { parent, binding_id }\n     }\n }\n "}, {"sha": "9f6b5c0a9fcc9edf3f1cde479bdbe2058aff3f71", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -10,8 +10,9 @@ use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam, Macro,\n-    Module, Static, Struct, Trait, TypeAlias, TypeOrConstParam, Union, Variant,\n+    db::HirDatabase, Adt, Const, Enum, Field, FieldSource, Function, Impl, LifetimeParam,\n+    LocalSource, Macro, Module, Static, Struct, Trait, TraitAlias, TypeAlias, TypeOrConstParam,\n+    Union, Variant,\n };\n \n pub trait HasSource {\n@@ -122,6 +123,12 @@ impl HasSource for Trait {\n         Some(self.id.lookup(db.upcast()).source(db.upcast()))\n     }\n }\n+impl HasSource for TraitAlias {\n+    type Ast = ast::TraitAlias;\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.id.lookup(db.upcast()).source(db.upcast()))\n+    }\n+}\n impl HasSource for TypeAlias {\n     type Ast = ast::TypeAlias;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n@@ -158,7 +165,7 @@ impl HasSource for Impl {\n }\n \n impl HasSource for TypeOrConstParam {\n-    type Ast = Either<ast::TypeOrConstParam, ast::Trait>;\n+    type Ast = Either<ast::TypeOrConstParam, ast::TraitOrAlias>;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n         let child_source = self.id.parent.child_source(db.upcast());\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n@@ -172,3 +179,11 @@ impl HasSource for LifetimeParam {\n         Some(child_source.map(|it| it[self.id.local_id].clone()))\n     }\n }\n+\n+impl HasSource for LocalSource {\n+    type Ast = Either<ast::IdentPat, ast::SelfParam>;\n+\n+    fn source(self, _: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        Some(self.source)\n+    }\n+}"}, {"sha": "25c07a2fbd3f973583e51d04a771a86839c80fee", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 409, "deletions": 103, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -41,34 +41,34 @@ use either::Either;\n use hir_def::{\n     adt::VariantData,\n     body::{BodyDiagnostic, SyntheticSyntax},\n-    expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n-    generics::{TypeOrConstParamData, TypeParamProvenance},\n+    expr::{BindingAnnotation, BindingId, ExprOrPatId, LabelId, Pat},\n+    generics::{LifetimeParamData, TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n-    nameres::{self, diagnostics::DefDiagnostic},\n+    nameres::{self, diagnostics::DefDiagnostic, ModuleOrigin},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n-    type_ref::ConstScalar,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n+    TraitAliasId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId,\n };\n use hir_expand::{name::name, MacroCallKind};\n use hir_ty::{\n     all_super_traits, autoderef,\n-    consteval::{unknown_const_as_generic, ComputedExpr, ConstEvalError, ConstExt},\n+    consteval::{try_const_usize, unknown_const_as_generic, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n+    display::HexifiedConst,\n     layout::layout_of_ty,\n     method_resolution::{self, TyFingerprint},\n+    mir::{self, interpret_mir},\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n-    ConcreteConst, ConstValue, GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar,\n-    Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind,\n-    WhereClause,\n+    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n+    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -77,20 +77,20 @@ use rustc_hash::FxHashSet;\n use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n-    AstNode, AstPtr, SmolStr, SyntaxNodePtr, TextRange, T,\n+    AstNode, AstPtr, SmolStr, SyntaxNode, SyntaxNodePtr, TextRange, T,\n };\n \n use crate::db::{DefDatabase, HirDatabase};\n \n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n-        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -130,6 +130,7 @@ pub use {\n     },\n     hir_ty::{\n         display::{HirDisplay, HirDisplayError, HirWrite},\n+        mir::MirEvalError,\n         PointerCast, Safety,\n     },\n };\n@@ -272,6 +273,7 @@ pub enum ModuleDef {\n     Const(Const),\n     Static(Static),\n     Trait(Trait),\n+    TraitAlias(TraitAlias),\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n     Macro(Macro),\n@@ -284,6 +286,7 @@ impl_from!(\n     Const,\n     Static,\n     Trait,\n+    TraitAlias,\n     TypeAlias,\n     BuiltinType,\n     Macro\n@@ -310,6 +313,7 @@ impl ModuleDef {\n             ModuleDef::Const(it) => Some(it.module(db)),\n             ModuleDef::Static(it) => Some(it.module(db)),\n             ModuleDef::Trait(it) => Some(it.module(db)),\n+            ModuleDef::TraitAlias(it) => Some(it.module(db)),\n             ModuleDef::TypeAlias(it) => Some(it.module(db)),\n             ModuleDef::Macro(it) => Some(it.module(db)),\n             ModuleDef::BuiltinType(_) => None,\n@@ -338,6 +342,7 @@ impl ModuleDef {\n             ModuleDef::Const(it) => it.name(db)?,\n             ModuleDef::Adt(it) => it.name(db),\n             ModuleDef::Trait(it) => it.name(db),\n+            ModuleDef::TraitAlias(it) => it.name(db),\n             ModuleDef::Function(it) => it.name(db),\n             ModuleDef::Variant(it) => it.name(db),\n             ModuleDef::TypeAlias(it) => it.name(db),\n@@ -356,6 +361,7 @@ impl ModuleDef {\n                 Adt::Union(it) => it.id.into(),\n             },\n             ModuleDef::Trait(it) => it.id.into(),\n+            ModuleDef::TraitAlias(it) => it.id.into(),\n             ModuleDef::Function(it) => it.id.into(),\n             ModuleDef::TypeAlias(it) => it.id.into(),\n             ModuleDef::Module(it) => it.id.into(),\n@@ -398,6 +404,7 @@ impl ModuleDef {\n             ModuleDef::Module(_)\n             | ModuleDef::Adt(_)\n             | ModuleDef::Trait(_)\n+            | ModuleDef::TraitAlias(_)\n             | ModuleDef::TypeAlias(_)\n             | ModuleDef::Macro(_)\n             | ModuleDef::BuiltinType(_) => None,\n@@ -413,6 +420,7 @@ impl ModuleDef {\n             ModuleDef::Const(it) => it.attrs(db),\n             ModuleDef::Static(it) => it.attrs(db),\n             ModuleDef::Trait(it) => it.attrs(db),\n+            ModuleDef::TraitAlias(it) => it.attrs(db),\n             ModuleDef::TypeAlias(it) => it.attrs(db),\n             ModuleDef::Macro(it) => it.attrs(db),\n             ModuleDef::BuiltinType(_) => return None,\n@@ -429,6 +437,7 @@ impl HasVisibility for ModuleDef {\n             ModuleDef::Const(it) => it.visibility(db),\n             ModuleDef::Static(it) => it.visibility(db),\n             ModuleDef::Trait(it) => it.visibility(db),\n+            ModuleDef::TraitAlias(it) => it.visibility(db),\n             ModuleDef::TypeAlias(it) => it.visibility(db),\n             ModuleDef::Variant(it) => it.visibility(db),\n             ModuleDef::Macro(it) => it.visibility(db),\n@@ -488,6 +497,20 @@ impl Module {\n         Some(Module { id: def_map.module_id(parent_id) })\n     }\n \n+    /// Finds nearest non-block ancestor `Module` (`self` included).\n+    pub fn nearest_non_block_module(self, db: &dyn HirDatabase) -> Module {\n+        let mut id = self.id;\n+        loop {\n+            let def_map = id.def_map(db.upcast());\n+            let origin = def_map[id.local_id].origin;\n+            if matches!(origin, ModuleOrigin::BlockExpr { .. }) {\n+                id = id.containing_module(db.upcast()).expect(\"block without parent module\")\n+            } else {\n+                return Module { id };\n+            }\n+        }\n+    }\n+\n     pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {\n         let mut res = vec![self];\n         let mut curr = self;\n@@ -1092,8 +1115,8 @@ impl Variant {\n         self.source(db)?.value.expr()\n     }\n \n-    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n-        db.const_eval_variant(self.into())\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<i128, ConstEvalError> {\n+        db.const_eval_discriminant(self.into())\n     }\n }\n \n@@ -1170,6 +1193,25 @@ impl Adt {\n         }\n     }\n \n+    /// Returns the lifetime of the DataType\n+    pub fn lifetime(&self, db: &dyn HirDatabase) -> Option<LifetimeParamData> {\n+        let resolver = match self {\n+            Adt::Struct(s) => s.id.resolver(db.upcast()),\n+            Adt::Union(u) => u.id.resolver(db.upcast()),\n+            Adt::Enum(e) => e.id.resolver(db.upcast()),\n+        };\n+        resolver\n+            .generic_params()\n+            .and_then(|gp| {\n+                (&gp.lifetimes)\n+                    .iter()\n+                    // there should only be a single lifetime\n+                    // but `Arena` requires to use an iterator\n+                    .nth(0)\n+            })\n+            .map(|arena| arena.1.clone())\n+    }\n+\n     pub fn as_enum(&self) -> Option<Enum> {\n         if let Self::Enum(v) = self {\n             Some(*v)\n@@ -1285,6 +1327,15 @@ impl DefWithBody {\n         body.pretty_print(db.upcast(), self.id())\n     }\n \n+    /// A textual representation of the MIR of this def's body for debugging purposes.\n+    pub fn debug_mir(self, db: &dyn HirDatabase) -> String {\n+        let body = db.mir_body(self.id());\n+        match body {\n+            Ok(body) => body.pretty_print(db),\n+            Err(e) => format!(\"error:\\n{e:?}\"),\n+        }\n+    }\n+\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let krate = self.module(db).id.krate();\n \n@@ -1334,42 +1385,35 @@ impl DefWithBody {\n \n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n+        let expr_syntax = |expr| source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n         for d in &infer.diagnostics {\n             match d {\n-                hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(*expr);\n+                &hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n+                    let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n-                    let expr = source_map\n-                        .expr_syntax(expr)\n-                        .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n+                    expr,\n+                    is_break,\n+                    bad_value_break,\n+                } => {\n+                    let expr = expr_syntax(expr);\n+                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(*call_expr) {\n-                        Ok(source_ptr) => acc.push(\n-                            MismatchedArgCount {\n-                                call_expr: source_ptr,\n-                                expected: *expected,\n-                                found: *found,\n-                            }\n+                &hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n+                    acc.push(\n+                        MismatchedArgCount { call_expr: expr_syntax(call_expr), expected, found }\n                             .into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n+                    )\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateField { expr, field } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n+                    let expr = expr_syntax(expr);\n                     let field = field.into();\n                     acc.push(PrivateField { expr, field }.into())\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateAssocItem { id, item } => {\n                     let expr_or_pat = match id {\n-                        ExprOrPatId::ExprId(expr) => source_map\n-                            .expr_syntax(expr)\n-                            .expect(\"unexpected synthetic\")\n-                            .map(Either::Left),\n+                        ExprOrPatId::ExprId(expr) => expr_syntax(expr).map(Either::Left),\n                         ExprOrPatId::PatId(pat) => source_map\n                             .pat_syntax(pat)\n                             .expect(\"unexpected synthetic\")\n@@ -1378,16 +1422,76 @@ impl DefWithBody {\n                     let item = item.into();\n                     acc.push(PrivateAssocItem { expr_or_pat, item }.into())\n                 }\n+                hir_ty::InferenceDiagnostic::ExpectedFunction { call_expr, found } => {\n+                    let call_expr = expr_syntax(*call_expr);\n+\n+                    acc.push(\n+                        ExpectedFunction {\n+                            call: call_expr,\n+                            found: Type::new(db, DefWithBodyId::from(self), found.clone()),\n+                        }\n+                        .into(),\n+                    )\n+                }\n+                hir_ty::InferenceDiagnostic::UnresolvedField {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    method_with_same_name_exists,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedField {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            method_with_same_name_exists: *method_with_same_name_exists,\n+                        }\n+                        .into(),\n+                    )\n+                }\n+                hir_ty::InferenceDiagnostic::UnresolvedMethodCall {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    field_with_same_name,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedMethodCall {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            field_with_same_name: field_with_same_name\n+                                .clone()\n+                                .map(|ty| Type::new(db, DefWithBodyId::from(self), ty)),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n-        for (expr, mismatch) in infer.expr_type_mismatches() {\n-            let expr = match source_map.expr_syntax(expr) {\n-                Ok(expr) => expr,\n-                Err(SyntheticSyntax) => continue,\n+        for (pat_or_expr, mismatch) in infer.type_mismatches() {\n+            let expr_or_pat = match pat_or_expr {\n+                ExprOrPatId::ExprId(expr) => source_map.expr_syntax(expr).map(Either::Left),\n+                // FIXME: Re-enable these once we have less false positives\n+                ExprOrPatId::PatId(_pat) => continue,\n+                #[allow(unreachable_patterns)]\n+                ExprOrPatId::PatId(pat) => source_map.pat_syntax(pat).map(Either::Right),\n             };\n+            let expr_or_pat = match expr_or_pat {\n+                Ok(Either::Left(expr)) => Either::Left(expr),\n+                Ok(Either::Right(InFile { file_id, value: Either::Left(pat) })) => {\n+                    Either::Right(InFile { file_id, value: pat })\n+                }\n+                Ok(Either::Right(_)) | Err(SyntheticSyntax) => continue,\n+            };\n+\n             acc.push(\n                 TypeMismatch {\n-                    expr,\n+                    expr_or_pat,\n                     expected: Type::new(db, DefWithBodyId::from(self), mismatch.expected.clone()),\n                     actual: Type::new(db, DefWithBodyId::from(self), mismatch.actual.clone()),\n                 }\n@@ -1405,6 +1509,41 @@ impl DefWithBody {\n             }\n         }\n \n+        let hir_body = db.body(self.into());\n+\n+        if let Ok(borrowck_result) = db.borrowck(self.into()) {\n+            let mir_body = &borrowck_result.mir_body;\n+            let mol = &borrowck_result.mutability_of_locals;\n+            for (binding_id, _) in hir_body.bindings.iter() {\n+                let need_mut = &mol[mir_body.binding_locals[binding_id]];\n+                let local = Local { parent: self.into(), binding_id };\n+                match (need_mut, local.is_mut(db)) {\n+                    (mir::MutabilityReason::Mut { .. }, true)\n+                    | (mir::MutabilityReason::Not, false) => (),\n+                    (mir::MutabilityReason::Mut { spans }, false) => {\n+                        for span in spans {\n+                            let span: InFile<SyntaxNodePtr> = match span {\n+                                mir::MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                                    Ok(s) => s.map(|x| x.into()),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                                    Ok(s) => s.map(|x| match x {\n+                                        Either::Left(e) => e.into(),\n+                                        Either::Right(e) => e.into(),\n+                                    }),\n+                                    Err(_) => continue,\n+                                },\n+                                mir::MirSpan::Unknown => continue,\n+                            };\n+                            acc.push(NeedMut { local, span }.into());\n+                        }\n+                    }\n+                    (mir::MutabilityReason::Not, true) => acc.push(UnusedMut { local }.into()),\n+                }\n+            }\n+        }\n+\n         for diagnostic in BodyValidationDiagnostic::collect(db, self.into()) {\n             match diagnostic {\n                 BodyValidationDiagnostic::RecordMissingFields {\n@@ -1489,11 +1628,13 @@ impl DefWithBody {\n                             if let ast::Expr::MatchExpr(match_expr) =\n                                 &source_ptr.value.to_node(&root)\n                             {\n-                                if let Some(match_expr) = match_expr.expr() {\n+                                if let Some(scrut_expr) = match_expr.expr() {\n                                     acc.push(\n                                         MissingMatchArms {\n-                                            file: source_ptr.file_id,\n-                                            match_expr: AstPtr::new(&match_expr),\n+                                            scrutinee_expr: InFile::new(\n+                                                source_ptr.file_id,\n+                                                AstPtr::new(&scrut_expr),\n+                                            ),\n                                             uncovered_patterns,\n                                         }\n                                         .into(),\n@@ -1582,6 +1723,10 @@ impl Function {\n             .collect()\n     }\n \n+    pub fn num_params(self, db: &dyn HirDatabase) -> usize {\n+        db.function_data(self.id).params.len()\n+    }\n+\n     pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param>> {\n         if self.self_param(db).is_none() {\n             return None;\n@@ -1639,6 +1784,14 @@ impl Function {\n         let def_map = db.crate_def_map(loc.krate(db).into());\n         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })\n     }\n+\n+    pub fn eval(self, db: &dyn HirDatabase) -> Result<(), MirEvalError> {\n+        let body = db\n+            .mir_body(self.id.into())\n+            .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))?;\n+        interpret_mir(db, &body, false)?;\n+        Ok(())\n+    }\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n@@ -1679,8 +1832,8 @@ impl Param {\n         let parent = DefWithBodyId::FunctionId(self.func.into());\n         let body = db.body(parent);\n         let pat_id = body.params[self.idx];\n-        if let Pat::Bind { .. } = &body[pat_id] {\n-            Some(Local { parent, pat_id: body.params[self.idx] })\n+        if let Pat::Bind { id, .. } = &body[pat_id] {\n+            Some(Local { parent, binding_id: *id })\n         } else {\n             None\n         }\n@@ -1781,8 +1934,18 @@ impl Const {\n         Type::new_with_resolver_inner(db, &resolver, ty)\n     }\n \n-    pub fn eval(self, db: &dyn HirDatabase) -> Result<ComputedExpr, ConstEvalError> {\n-        db.const_eval(self.id)\n+    pub fn render_eval(self, db: &dyn HirDatabase) -> Result<String, ConstEvalError> {\n+        let c = db.const_eval(self.id)?;\n+        let r = format!(\"{}\", HexifiedConst(c).display(db));\n+        // We want to see things like `<utf8-error>` and `<layout-error>` as they are probably bug in our\n+        // implementation, but there is no need to show things like `<enum-not-supported>` or `<ref-not-supported>` to\n+        // the user.\n+        if r.contains(\"not-supported>\") {\n+            return Err(ConstEvalError::MirEvalError(MirEvalError::NotSupported(\n+                \"rendering complex constants\".to_string(),\n+            )));\n+        }\n+        return Ok(r);\n     }\n }\n \n@@ -1893,6 +2056,27 @@ impl HasVisibility for Trait {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TraitAlias {\n+    pub(crate) id: TraitAliasId,\n+}\n+\n+impl TraitAlias {\n+    pub fn module(self, db: &dyn HirDatabase) -> Module {\n+        Module { id: self.id.lookup(db.upcast()).container }\n+    }\n+\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        db.trait_alias_data(self.id).name.clone()\n+    }\n+}\n+\n+impl HasVisibility for TraitAlias {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.trait_alias_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAlias {\n     pub(crate) id: TypeAliasId,\n@@ -2265,6 +2449,7 @@ pub enum GenericDef {\n     Function(Function),\n     Adt(Adt),\n     Trait(Trait),\n+    TraitAlias(TraitAlias),\n     TypeAlias(TypeAlias),\n     Impl(Impl),\n     // enum variants cannot have generics themselves, but their parent enums\n@@ -2277,6 +2462,7 @@ impl_from!(\n     Function,\n     Adt(Struct, Enum, Union),\n     Trait,\n+    TraitAlias,\n     TypeAlias,\n     Impl,\n     Variant,\n@@ -2317,20 +2503,53 @@ impl GenericDef {\n }\n \n /// A single local definition.\n-///\n-/// If the definition of this is part of a \"MultiLocal\", that is a local that has multiple declarations due to or-patterns\n-/// then this only references a single one of those.\n-/// To retrieve the other locals you should use [`Local::associated_locals`]\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBodyId,\n-    pub(crate) pat_id: PatId,\n+    pub(crate) binding_id: BindingId,\n+}\n+\n+pub struct LocalSource {\n+    pub local: Local,\n+    pub source: InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+}\n+\n+impl LocalSource {\n+    pub fn as_ident_pat(&self) -> Option<&ast::IdentPat> {\n+        match &self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn into_ident_pat(self) -> Option<ast::IdentPat> {\n+        match self.source.value {\n+            Either::Left(x) => Some(x),\n+            Either::Right(_) => None,\n+        }\n+    }\n+\n+    pub fn original_file(&self, db: &dyn HirDatabase) -> FileId {\n+        self.source.file_id.original_file(db.upcast())\n+    }\n+\n+    pub fn name(&self) -> Option<ast::Name> {\n+        self.source.value.name()\n+    }\n+\n+    pub fn syntax(&self) -> &SyntaxNode {\n+        self.source.value.syntax()\n+    }\n+\n+    pub fn syntax_ptr(self) -> InFile<SyntaxNodePtr> {\n+        self.source.map(|x| SyntaxNodePtr::new(x.syntax()))\n+    }\n }\n \n impl Local {\n     pub fn is_param(self, db: &dyn HirDatabase) -> bool {\n-        let src = self.source(db);\n-        match src.value {\n+        let src = self.primary_source(db);\n+        match src.source.value {\n             Either::Left(pat) => pat\n                 .syntax()\n                 .ancestors()\n@@ -2350,13 +2569,7 @@ impl Local {\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n         let body = db.body(self.parent);\n-        match &body[self.pat_id] {\n-            Pat::Bind { name, .. } => name.clone(),\n-            _ => {\n-                stdx::never!(\"hir::Local is missing a name!\");\n-                Name::missing()\n-            }\n-        }\n+        body[self.binding_id].name.clone()\n     }\n \n     pub fn is_self(self, db: &dyn HirDatabase) -> bool {\n@@ -2365,15 +2578,12 @@ impl Local {\n \n     pub fn is_mut(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(&body[self.pat_id], Pat::Bind { mode: BindingAnnotation::Mutable, .. })\n+        body[self.binding_id].mode == BindingAnnotation::Mutable\n     }\n \n     pub fn is_ref(self, db: &dyn HirDatabase) -> bool {\n         let body = db.body(self.parent);\n-        matches!(\n-            &body[self.pat_id],\n-            Pat::Bind { mode: BindingAnnotation::Ref | BindingAnnotation::RefMut, .. }\n-        )\n+        matches!(body[self.binding_id].mode, BindingAnnotation::Ref | BindingAnnotation::RefMut)\n     }\n \n     pub fn parent(self, _db: &dyn HirDatabase) -> DefWithBody {\n@@ -2387,34 +2597,33 @@ impl Local {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let def = self.parent;\n         let infer = db.infer(def);\n-        let ty = infer[self.pat_id].clone();\n+        let ty = infer[self.binding_id].clone();\n         Type::new(db, def, ty)\n     }\n \n-    pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n-        let body = db.body(self.parent);\n-        body.ident_patterns_for(&self.pat_id)\n+    /// All definitions for this local. Example: `let (a$0, _) | (_, a$0) = x;`\n+    pub fn sources(self, db: &dyn HirDatabase) -> Vec<LocalSource> {\n+        let (body, source_map) = db.body_with_source_map(self.parent);\n+        body[self.binding_id]\n+            .definitions\n             .iter()\n-            .map(|&pat_id| Local { parent: self.parent, pat_id })\n+            .map(|&definition| {\n+                let src = source_map.pat_syntax(definition).unwrap(); // Hmm...\n+                let root = src.file_syntax(db.upcast());\n+                src.map(|ast| match ast {\n+                    // Suspicious unwrap\n+                    Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n+                    Either::Right(it) => Either::Right(it.to_node(&root)),\n+                })\n+            })\n+            .map(|source| LocalSource { local: self, source })\n             .collect()\n     }\n \n-    /// If this local is part of a multi-local, retrieve the representative local.\n-    /// That is the local that references are being resolved to.\n-    pub fn representative(self, db: &dyn HirDatabase) -> Local {\n-        let body = db.body(self.parent);\n-        Local { pat_id: body.pattern_representative(self.pat_id), ..self }\n-    }\n-\n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n-        let (_body, source_map) = db.body_with_source_map(self.parent);\n-        let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n-        let root = src.file_syntax(db.upcast());\n-        src.map(|ast| match ast {\n-            // Suspicious unwrap\n-            Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n-            Either::Right(it) => Either::Right(it.to_node(&root)),\n-        })\n+    /// The leftmost definition for this local. Example: `let (a$0, _) | (_, a) = x;`\n+    pub fn primary_source(self, db: &dyn HirDatabase) -> LocalSource {\n+        let all_sources = self.sources(db);\n+        all_sources.into_iter().next().unwrap()\n     }\n }\n \n@@ -3190,6 +3399,14 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Raw(..))\n     }\n \n+    pub fn remove_raw_ptr(&self) -> Option<Type> {\n+        if let TyKind::Raw(_, ty) = self.ty.kind(Interner) {\n+            Some(self.derived(ty.clone()))\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn contains_unknown(&self) -> bool {\n         // FIXME: When we get rid of `ConstScalar::Unknown`, we can just look at precomputed\n         // `TypeFlags` in `TyData`.\n@@ -3260,12 +3477,7 @@ impl Type {\n \n     pub fn as_array(&self, _db: &dyn HirDatabase) -> Option<(Type, usize)> {\n         if let TyKind::Array(ty, len) = &self.ty.kind(Interner) {\n-            match len.data(Interner).value {\n-                ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(len) }) => {\n-                    Some((self.derived(ty.clone()), len as usize))\n-                }\n-                _ => None,\n-            }\n+            try_const_usize(len).map(|x| (self.derived(ty.clone()), x as usize))\n         } else {\n             None\n         }\n@@ -3321,6 +3533,24 @@ impl Type {\n         }\n     }\n \n+    /// Iterates its type arguments\n+    ///\n+    /// It iterates the actual type arguments when concrete types are used\n+    /// and otherwise the generic names.\n+    /// It does not include `const` arguments.\n+    ///\n+    /// For code, such as:\n+    /// ```text\n+    /// struct Foo<T, U>\n+    ///\n+    /// impl<U> Foo<String, U>\n+    /// ```\n+    ///\n+    /// It iterates:\n+    /// ```text\n+    /// - \"String\"\n+    /// - \"U\"\n+    /// ```\n     pub fn type_arguments(&self) -> impl Iterator<Item = Type> + '_ {\n         self.ty\n             .strip_references()\n@@ -3331,12 +3561,62 @@ impl Type {\n             .map(move |ty| self.derived(ty))\n     }\n \n-    pub fn iterate_method_candidates<T>(\n+    /// Iterates its type and const arguments\n+    ///\n+    /// It iterates the actual type and const arguments when concrete types\n+    /// are used and otherwise the generic names.\n+    ///\n+    /// For code, such as:\n+    /// ```text\n+    /// struct Foo<T, const U: usize, const X: usize>\n+    ///\n+    /// impl<U> Foo<String, U, 12>\n+    /// ```\n+    ///\n+    /// It iterates:\n+    /// ```text\n+    /// - \"String\"\n+    /// - \"U\"\n+    /// - \"12\"\n+    /// ```\n+    pub fn type_and_const_arguments<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+    ) -> impl Iterator<Item = SmolStr> + 'a {\n+        self.ty\n+            .strip_references()\n+            .as_adt()\n+            .into_iter()\n+            .flat_map(|(_, substs)| substs.iter(Interner))\n+            .filter_map(|arg| {\n+                // arg can be either a `Ty` or `constant`\n+                if let Some(ty) = arg.ty(Interner) {\n+                    Some(SmolStr::new(ty.display(db).to_string()))\n+                } else if let Some(const_) = arg.constant(Interner) {\n+                    Some(SmolStr::new_inline(&const_.display(db).to_string()))\n+                } else {\n+                    None\n+                }\n+            })\n+    }\n+\n+    /// Combines lifetime indicators, type and constant parameters into a single `Iterator`\n+    pub fn generic_parameters<'a>(\n+        &'a self,\n+        db: &'a dyn HirDatabase,\n+    ) -> impl Iterator<Item = SmolStr> + 'a {\n+        // iterate the lifetime\n+        self.as_adt()\n+            .and_then(|a| a.lifetime(db).and_then(|lt| Some((&lt.name).to_smol_str())))\n+            .into_iter()\n+            // add the type and const paramaters\n+            .chain(self.type_and_const_arguments(db))\n+    }\n+\n+    pub fn iterate_method_candidates_with_traits<T>(\n         &self,\n         db: &dyn HirDatabase,\n         scope: &SemanticsScope<'_>,\n-        // FIXME this can be retrieved from `scope`, except autoimport uses this\n-        // to specify a different set, so the method needs to be split\n         traits_in_scope: &FxHashSet<TraitId>,\n         with_local_impls: Option<Module>,\n         name: Option<&Name>,\n@@ -3364,6 +3644,24 @@ impl Type {\n         slot\n     }\n \n+    pub fn iterate_method_candidates<T>(\n+        &self,\n+        db: &dyn HirDatabase,\n+        scope: &SemanticsScope<'_>,\n+        with_local_impls: Option<Module>,\n+        name: Option<&Name>,\n+        callback: impl FnMut(Function) -> Option<T>,\n+    ) -> Option<T> {\n+        self.iterate_method_candidates_with_traits(\n+            db,\n+            scope,\n+            &scope.visible_traits().0,\n+            with_local_impls,\n+            name,\n+            callback,\n+        )\n+    }\n+\n     fn iterate_method_candidates_dyn(\n         &self,\n         db: &dyn HirDatabase,\n@@ -3632,11 +3930,13 @@ impl Type {\n     }\n }\n \n+// FIXME: Document this\n #[derive(Debug)]\n pub struct Callable {\n     ty: Type,\n     sig: CallableSig,\n     callee: Callee,\n+    /// Whether this is a method that was called with method call syntax.\n     pub(crate) is_bound_method: bool,\n }\n \n@@ -3670,14 +3970,14 @@ impl Callable {\n             Other => CallableKind::Other,\n         }\n     }\n-    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<(ast::SelfParam, Type)> {\n         let func = match self.callee {\n             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,\n             _ => return None,\n         };\n         let src = func.lookup(db.upcast()).source(db.upcast());\n         let param_list = src.value.param_list()?;\n-        param_list.self_param()\n+        Some((param_list.self_param()?, self.ty.derived(self.sig.params()[0].clone())))\n     }\n     pub fn n_params(&self) -> usize {\n         self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n@@ -3936,6 +4236,12 @@ impl HasCrate for Trait {\n     }\n }\n \n+impl HasCrate for TraitAlias {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n+    }\n+}\n+\n impl HasCrate for Static {\n     fn krate(&self, db: &dyn HirDatabase) -> Crate {\n         self.module(db).krate()"}, {"sha": "8bd905d0113a1530c78c051040ae1de3a2a13a42", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n     macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n-    AsMacroCall, DefWithBodyId, FunctionId, MacroId, TraitId, VariantId,\n+    AsMacroCall, DefWithBodyId, FieldId, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n     db::AstDatabase,\n@@ -68,7 +68,8 @@ impl PathResolution {\n                 | ModuleDef::Function(_)\n                 | ModuleDef::Module(_)\n                 | ModuleDef::Static(_)\n-                | ModuleDef::Trait(_),\n+                | ModuleDef::Trait(_)\n+                | ModuleDef::TraitAlias(_),\n             ) => None,\n             PathResolution::Def(ModuleDef::TypeAlias(alias)) => {\n                 Some(TypeNs::TypeAliasId((*alias).into()))\n@@ -365,6 +366,16 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n+    /// Attempts to resolve this call expression as a method call falling back to resolving it as a field.\n+    pub fn resolve_method_call_field_fallback(\n+        &self,\n+        call: &ast::MethodCallExpr,\n+    ) -> Option<Either<Function, Field>> {\n+        self.imp\n+            .resolve_method_call_fallback(call)\n+            .map(|it| it.map_left(Function::from).map_right(Field::from))\n+    }\n+\n     pub fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<Function> {\n         self.imp.resolve_await_to_poll(await_expr).map(Function::from)\n     }\n@@ -527,8 +538,8 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn expand_derive_as_pseudo_attr_macro(&self, attr: &ast::Attr) -> Option<SyntaxNode> {\n-        let src = self.wrap_node_infile(attr.clone());\n         let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let src = self.wrap_node_infile(attr.clone());\n         let call_id = self.with_ctx(|ctx| {\n             ctx.attr_to_derive_macro_call(src.with_value(&adt), src).map(|(_, it, _)| it)\n         })?;\n@@ -1092,7 +1103,10 @@ impl<'db> SemanticsImpl<'db> {\n                     let kind = match adjust.kind {\n                         hir_ty::Adjust::NeverToAny => Adjust::NeverToAny,\n                         hir_ty::Adjust::Deref(Some(hir_ty::OverloadedDeref(m))) => {\n-                            Adjust::Deref(Some(OverloadedDeref(mutability(m))))\n+                            // FIXME: Should we handle unknown mutability better?\n+                            Adjust::Deref(Some(OverloadedDeref(\n+                                m.map(mutability).unwrap_or(Mutability::Shared),\n+                            )))\n                         }\n                         hir_ty::Adjust::Deref(None) => Adjust::Deref(None),\n                         hir_ty::Adjust::Borrow(hir_ty::AutoBorrow::RawPtr(m)) => {\n@@ -1145,6 +1159,13 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_method_call_fallback(\n+        &self,\n+        call: &ast::MethodCallExpr,\n+    ) -> Option<Either<FunctionId, FieldId>> {\n+        self.analyze(call.syntax())?.resolve_method_call_fallback(self.db, call)\n+    }\n+\n     fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<FunctionId> {\n         self.analyze(await_expr.syntax())?.resolve_await_to_poll(self.db, await_expr)\n     }\n@@ -1330,6 +1351,7 @@ impl<'db> SemanticsImpl<'db> {\n                 })\n             }\n             ChildContainer::TraitId(it) => it.resolver(self.db.upcast()),\n+            ChildContainer::TraitAliasId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::ImplId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::ModuleId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::EnumId(it) => it.resolver(self.db.upcast()),\n@@ -1556,6 +1578,7 @@ to_def_impls![\n     (crate::Enum, ast::Enum, enum_to_def),\n     (crate::Union, ast::Union, union_to_def),\n     (crate::Trait, ast::Trait, trait_to_def),\n+    (crate::TraitAlias, ast::TraitAlias, trait_alias_to_def),\n     (crate::Impl, ast::Impl, impl_to_def),\n     (crate::TypeAlias, ast::TypeAlias, type_alias_to_def),\n     (crate::Const, ast::Const, const_to_def),\n@@ -1634,8 +1657,8 @@ impl<'a> SemanticsScope<'a> {\n                     resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                     resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n                     resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(id.into()),\n-                    resolver::ScopeDef::Local(pat_id) => match self.resolver.body_owner() {\n-                        Some(parent) => ScopeDef::Local(Local { parent, pat_id }),\n+                    resolver::ScopeDef::Local(binding_id) => match self.resolver.body_owner() {\n+                        Some(parent) => ScopeDef::Local(Local { parent, binding_id }),\n                         None => continue,\n                     },\n                     resolver::ScopeDef::Label(label_id) => match self.resolver.body_owner() {\n@@ -1673,6 +1696,7 @@ impl<'a> SemanticsScope<'a> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct VisibleTraits(pub FxHashSet<TraitId>);\n \n impl ops::Deref for VisibleTraits {"}, {"sha": "f6f8c9a250f06cbf16ac88c5c8b3b5b022b46347", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -89,16 +89,16 @@ use base_db::FileId;\n use hir_def::{\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n-    expr::{LabelId, PatId},\n+    expr::{BindingId, LabelId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n     GenericDefId, GenericParamId, ImplId, LifetimeParamId, MacroId, ModuleId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n+    TraitAliasId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{attrs::AttrId, name::AsName, HirFileId, MacroCallId};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n-use stdx::impl_from;\n+use stdx::{impl_from, never};\n use syntax::{\n     ast::{self, HasName},\n     AstNode, SyntaxNode,\n@@ -159,6 +159,12 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn trait_to_def(&mut self, src: InFile<ast::Trait>) -> Option<TraitId> {\n         self.to_def(src, keys::TRAIT)\n     }\n+    pub(super) fn trait_alias_to_def(\n+        &mut self,\n+        src: InFile<ast::TraitAlias>,\n+    ) -> Option<TraitAliasId> {\n+        self.to_def(src, keys::TRAIT_ALIAS)\n+    }\n     pub(super) fn impl_to_def(&mut self, src: InFile<ast::Impl>) -> Option<ImplId> {\n         self.to_def(src, keys::IMPL)\n     }\n@@ -210,26 +216,31 @@ impl SourceToDefCtx<'_, '_> {\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n         src: InFile<ast::IdentPat>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n         let (body, source_map) = self.db.body_with_source_map(container);\n         let src = src.map(ast::Pat::from);\n         let pat_id = source_map.node_pat(src.as_ref())?;\n         // the pattern could resolve to a constant, verify that that is not the case\n-        if let crate::Pat::Bind { .. } = body[pat_id] {\n-            Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n         } else {\n             None\n         }\n     }\n     pub(super) fn self_param_to_def(\n         &mut self,\n         src: InFile<ast::SelfParam>,\n-    ) -> Option<(DefWithBodyId, PatId)> {\n+    ) -> Option<(DefWithBodyId, BindingId)> {\n         let container = self.find_pat_or_label_container(src.syntax())?;\n-        let (_body, source_map) = self.db.body_with_source_map(container);\n+        let (body, source_map) = self.db.body_with_source_map(container);\n         let pat_id = source_map.node_self_param(src.as_ref())?;\n-        Some((container, pat_id))\n+        if let crate::Pat::Bind { id, .. } = body[pat_id] {\n+            Some((container, id))\n+        } else {\n+            never!();\n+            None\n+        }\n     }\n     pub(super) fn label_to_def(\n         &mut self,\n@@ -353,6 +364,9 @@ impl SourceToDefCtx<'_, '_> {\n             match item {\n                 ast::Item::Module(it) => self.module_to_def(container.with_value(it))?.into(),\n                 ast::Item::Trait(it) => self.trait_to_def(container.with_value(it))?.into(),\n+                ast::Item::TraitAlias(it) => {\n+                    self.trait_alias_to_def(container.with_value(it))?.into()\n+                }\n                 ast::Item::Impl(it) => self.impl_to_def(container.with_value(it))?.into(),\n                 ast::Item::Enum(it) => self.enum_to_def(container.with_value(it))?.into(),\n                 ast::Item::TypeAlias(it) => {\n@@ -400,6 +414,9 @@ impl SourceToDefCtx<'_, '_> {\n                 ast::Item::Struct(it) => self.struct_to_def(InFile::new(file_id, it))?.into(),\n                 ast::Item::Enum(it) => self.enum_to_def(InFile::new(file_id, it))?.into(),\n                 ast::Item::Trait(it) => self.trait_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::TraitAlias(it) => {\n+                    self.trait_alias_to_def(InFile::new(file_id, it))?.into()\n+                }\n                 ast::Item::TypeAlias(it) => {\n                     self.type_alias_to_def(InFile::new(file_id, it))?.into()\n                 }\n@@ -435,6 +452,7 @@ pub(crate) enum ChildContainer {\n     DefWithBodyId(DefWithBodyId),\n     ModuleId(ModuleId),\n     TraitId(TraitId),\n+    TraitAliasId(TraitAliasId),\n     ImplId(ImplId),\n     EnumId(EnumId),\n     VariantId(VariantId),\n@@ -447,6 +465,7 @@ impl_from! {\n     DefWithBodyId,\n     ModuleId,\n     TraitId,\n+    TraitAliasId,\n     ImplId,\n     EnumId,\n     VariantId,\n@@ -462,6 +481,7 @@ impl ChildContainer {\n             ChildContainer::DefWithBodyId(it) => it.child_by_source(db, file_id),\n             ChildContainer::ModuleId(it) => it.child_by_source(db, file_id),\n             ChildContainer::TraitId(it) => it.child_by_source(db, file_id),\n+            ChildContainer::TraitAliasId(_) => DynMap::default(),\n             ChildContainer::ImplId(it) => it.child_by_source(db, file_id),\n             ChildContainer::EnumId(it) => it.child_by_source(db, file_id),\n             ChildContainer::VariantId(it) => it.child_by_source(db, file_id),"}, {"sha": "133fa810d66133d332b7ffcf30d4b67bb02c8a76", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -10,6 +10,7 @@ use std::{\n     sync::Arc,\n };\n \n+use either::Either;\n use hir_def::{\n     body::{\n         self,\n@@ -51,7 +52,7 @@ use syntax::{\n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, AssocItem, BindingMode, BuiltinAttr,\n     BuiltinType, Callable, Const, DeriveHelper, Field, Function, Local, Macro, ModuleDef, Static,\n-    Struct, ToolModule, Trait, Type, TypeAlias, Variant,\n+    Struct, ToolModule, Trait, TraitAlias, Type, TypeAlias, Variant,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -266,6 +267,21 @@ impl SourceAnalyzer {\n         Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs))\n     }\n \n+    pub(crate) fn resolve_method_call_fallback(\n+        &self,\n+        db: &dyn HirDatabase,\n+        call: &ast::MethodCallExpr,\n+    ) -> Option<Either<FunctionId, FieldId>> {\n+        let expr_id = self.expr_id(db, &call.clone().into())?;\n+        let inference_result = self.infer.as_ref()?;\n+        match inference_result.method_resolution(expr_id) {\n+            Some((f_in_trait, substs)) => {\n+                Some(Either::Left(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs)))\n+            }\n+            None => inference_result.field_resolution(expr_id).map(Either::Right),\n+        }\n+    }\n+\n     pub(crate) fn resolve_await_to_poll(\n         &self,\n         db: &dyn HirDatabase,\n@@ -406,8 +422,8 @@ impl SourceAnalyzer {\n             // Shorthand syntax, resolve to the local\n             let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n-                Some(ValueNs::LocalBinding(pat_id)) => {\n-                    Some(Local { pat_id, parent: self.resolver.body_owner()? })\n+                Some(ValueNs::LocalBinding(binding_id)) => {\n+                    Some(Local { binding_id, parent: self.resolver.body_owner()? })\n                 }\n                 _ => None,\n             }\n@@ -791,7 +807,7 @@ impl SourceAnalyzer {\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-        method_resolution::lookup_impl_method(db, env, func, substs)\n+        method_resolution::lookup_impl_method(db, env, func, substs).0\n     }\n \n     fn resolve_impl_const_or_trait_def(\n@@ -809,7 +825,7 @@ impl SourceAnalyzer {\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-        method_resolution::lookup_impl_const(db, env, const_id, subs)\n+        method_resolution::lookup_impl_const(db, env, const_id, subs).0\n     }\n \n     fn lang_trait_fn(\n@@ -943,17 +959,17 @@ fn resolve_hir_path_(\n                 res.map(|ty_ns| (ty_ns, path.segments().first()))\n             }\n             None => {\n-                let (ty, remaining) =\n+                let (ty, remaining_idx) =\n                     resolver.resolve_path_in_type_ns(db.upcast(), path.mod_path())?;\n-                match remaining {\n-                    Some(remaining) if remaining > 1 => {\n-                        if remaining + 1 == path.segments().len() {\n+                match remaining_idx {\n+                    Some(remaining_idx) => {\n+                        if remaining_idx + 1 == path.segments().len() {\n                             Some((ty, path.segments().last()))\n                         } else {\n                             None\n                         }\n                     }\n-                    _ => Some((ty, path.segments().get(1))),\n+                    None => Some((ty, None)),\n                 }\n             }\n         }?;\n@@ -978,6 +994,7 @@ fn resolve_hir_path_(\n             TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n             TypeNs::BuiltinType(it) => PathResolution::Def(BuiltinType::from(it).into()),\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+            TypeNs::TraitAliasId(it) => PathResolution::Def(TraitAlias::from(it).into()),\n         };\n         match unresolved {\n             Some(unresolved) => resolver\n@@ -1001,8 +1018,8 @@ fn resolve_hir_path_(\n     let values = || {\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n             let res = match val {\n-                ValueNs::LocalBinding(pat_id) => {\n-                    let var = Local { parent: body_owner?, pat_id };\n+                ValueNs::LocalBinding(binding_id) => {\n+                    let var = Local { parent: body_owner?, binding_id };\n                     PathResolution::Local(var)\n                 }\n                 ValueNs::FunctionId(it) => PathResolution::Def(Function::from(it).into()),\n@@ -1065,6 +1082,7 @@ fn resolve_hir_path_qualifier(\n             TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n             TypeNs::BuiltinType(it) => PathResolution::Def(BuiltinType::from(it).into()),\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+            TypeNs::TraitAliasId(it) => PathResolution::Def(TraitAlias::from(it).into()),\n         })\n         .or_else(|| {\n             resolver"}, {"sha": "a9afa1c6f4519bc4eef7a4795bba209fcd8c1d1b", "filename": "crates/hir/src/symbols.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsymbols.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -68,6 +68,7 @@ pub enum FileSymbolKind {\n     Static,\n     Struct,\n     Trait,\n+    TraitAlias,\n     TypeAlias,\n     Union,\n }\n@@ -153,6 +154,9 @@ impl<'a> SymbolCollector<'a> {\n                     self.push_decl(id, FileSymbolKind::Trait);\n                     self.collect_from_trait(id);\n                 }\n+                ModuleDefId::TraitAliasId(id) => {\n+                    self.push_decl(id, FileSymbolKind::TraitAlias);\n+                }\n                 ModuleDefId::TypeAliasId(id) => {\n                     self.push_decl_assoc(id, FileSymbolKind::TypeAlias);\n                 }"}, {"sha": "785ae3d09c6e3b32e7dca42ce9b42659fc2626e5", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -211,10 +211,8 @@ fn main() {\n         check_assist_not_applicable(\n             add_explicit_type,\n             r#\"\n-//- minicore: option\n-\n fn main() {\n-    let $0l = [0.0; Some(2).unwrap()];\n+    let $0l = [0.0; unresolved_function(5)];\n }\n \"#,\n         );"}, {"sha": "9e1d9a702a15f3a7d8e4856453577bc1ee2a0814", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -157,19 +157,12 @@ fn is_ref_and_impls_iter_method(\n     let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n \n     let has_wanted_method = ty\n-        .iterate_method_candidates(\n-            sema.db,\n-            &scope,\n-            &scope.visible_traits().0,\n-            None,\n-            Some(&wanted_method),\n-            |func| {\n-                if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n-                    return Some(());\n-                }\n-                None\n-            },\n-        )\n+        .iterate_method_candidates(sema.db, &scope, None, Some(&wanted_method), |func| {\n+            if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                return Some(());\n+            }\n+            None\n+        })\n         .is_some();\n     if !has_wanted_method {\n         return None;"}, {"sha": "7f2c01772baefa8861c9e055415feee02186ee27", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,6 +1,6 @@\n use ide_db::defs::{Definition, NameRefClass};\n use syntax::{\n-    ast::{self, HasName},\n+    ast::{self, HasName, Name},\n     ted, AstNode, SyntaxNode,\n };\n \n@@ -48,15 +48,15 @@ pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'\n         other => format!(\"{{ {other} }}\"),\n     };\n     let extracting_arm_pat = extracting_arm.pat()?;\n-    let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n+    let extracted_variable_positions = find_extracted_variable(ctx, &extracting_arm)?;\n \n     acc.add(\n         AssistId(\"convert_match_to_let_else\", AssistKind::RefactorRewrite),\n         \"Convert match to let-else\",\n         let_stmt.syntax().text_range(),\n         |builder| {\n             let extracting_arm_pat =\n-                rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+                rename_variable(&extracting_arm_pat, &extracted_variable_positions, binding);\n             builder.replace(\n                 let_stmt.syntax().text_range(),\n                 format!(\"let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};\"),\n@@ -95,14 +95,15 @@ fn find_arms(\n }\n \n // Given an extracting arm, find the extracted variable.\n-fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<ast::Name> {\n+fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<Vec<Name>> {\n     match arm.expr()? {\n         ast::Expr::PathExpr(path) => {\n             let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n             match NameRefClass::classify(&ctx.sema, &name_ref)? {\n                 NameRefClass::Definition(Definition::Local(local)) => {\n-                    let source = local.source(ctx.db()).value.left()?;\n-                    Some(source.name()?)\n+                    let source =\n+                        local.sources(ctx.db()).into_iter().map(|x| x.into_ident_pat()?.name());\n+                    source.collect()\n                 }\n                 _ => None,\n             }\n@@ -115,27 +116,34 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n }\n \n // Rename `extracted` with `binding` in `pat`.\n-fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::Pat) -> SyntaxNode {\n+fn rename_variable(pat: &ast::Pat, extracted: &[Name], binding: ast::Pat) -> SyntaxNode {\n     let syntax = pat.syntax().clone_for_update();\n-    let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n-\n-    // If `extracted` variable is a record field, we should rename it to `binding`,\n-    // otherwise we just need to replace `extracted` with `binding`.\n-\n-    if let Some(record_pat_field) = extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n-    {\n-        if let Some(name_ref) = record_pat_field.field_name() {\n-            ted::replace(\n-                record_pat_field.syntax(),\n-                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding)\n+    let extracted = extracted\n+        .iter()\n+        .map(|e| syntax.covering_element(e.syntax().text_range()))\n+        .collect::<Vec<_>>();\n+    for extracted_syntax in extracted {\n+        // If `extracted` variable is a record field, we should rename it to `binding`,\n+        // otherwise we just need to replace `extracted` with `binding`.\n+\n+        if let Some(record_pat_field) =\n+            extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n+        {\n+            if let Some(name_ref) = record_pat_field.field_name() {\n+                ted::replace(\n+                    record_pat_field.syntax(),\n+                    ast::make::record_pat_field(\n+                        ast::make::name_ref(&name_ref.text()),\n+                        binding.clone(),\n+                    )\n                     .syntax()\n                     .clone_for_update(),\n-            );\n+                );\n+            }\n+        } else {\n+            ted::replace(extracted_syntax, binding.clone().syntax().clone_for_update());\n         }\n-    } else {\n-        ted::replace(extracted_syntax, binding.syntax().clone_for_update());\n     }\n-\n     syntax\n }\n \n@@ -162,6 +170,39 @@ fn foo(opt: Option<()>) {\n         );\n     }\n \n+    #[test]\n+    fn or_pattern_multiple_binding() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+enum Foo {\n+    A(u32),\n+    B(u32),\n+    C(String),\n+}\n+\n+fn foo(opt: Option<Foo>) -> Result<u32, ()> {\n+    let va$0lue = match opt {\n+        Some(Foo::A(it) | Foo::B(it)) => it,\n+        _ => return Err(()),\n+    };\n+}\n+    \"#,\n+            r#\"\n+enum Foo {\n+    A(u32),\n+    B(u32),\n+    C(String),\n+}\n+\n+fn foo(opt: Option<Foo>) -> Result<u32, ()> {\n+    let Some(Foo::A(value) | Foo::B(value)) = opt else { return Err(()) };\n+}\n+    \"#,\n+        );\n+    }\n+\n     #[test]\n     fn should_not_be_applicable_if_extracting_arm_is_not_an_identity_expr() {\n         cov_mark::check_count!(extracting_arm_is_not_an_identity_expr, 2);"}, {"sha": "0b90c9ba34f5fb9ce7353197bb3018640e8394b3", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -3,7 +3,8 @@ use std::iter;\n use ast::make;\n use either::Either;\n use hir::{\n-    HasSource, HirDisplay, InFile, Local, ModuleDef, PathResolution, Semantics, TypeInfo, TypeParam,\n+    HasSource, HirDisplay, InFile, Local, LocalSource, ModuleDef, PathResolution, Semantics,\n+    TypeInfo, TypeParam,\n };\n use ide_db::{\n     defs::{Definition, NameRefClass},\n@@ -710,7 +711,7 @@ impl FunctionBody {\n                     ) => local_ref,\n                     _ => return,\n                 };\n-            let InFile { file_id, value } = local_ref.source(sema.db);\n+            let InFile { file_id, value } = local_ref.primary_source(sema.db).source;\n             // locals defined inside macros are not relevant to us\n             if !file_id.is_macro() {\n                 match value {\n@@ -972,11 +973,11 @@ impl FunctionBody {\n         locals: impl Iterator<Item = Local>,\n     ) -> Vec<Param> {\n         locals\n-            .map(|local| (local, local.source(ctx.db())))\n+            .map(|local| (local, local.primary_source(ctx.db())))\n             .filter(|(_, src)| is_defined_outside_of_body(ctx, self, src))\n-            .filter_map(|(local, src)| match src.value {\n-                Either::Left(src) => Some((local, src)),\n-                Either::Right(_) => {\n+            .filter_map(|(local, src)| match src.into_ident_pat() {\n+                Some(src) => Some((local, src)),\n+                None => {\n                     stdx::never!(false, \"Local::is_self returned false, but source is SelfParam\");\n                     None\n                 }\n@@ -1238,17 +1239,9 @@ fn local_outlives_body(\n fn is_defined_outside_of_body(\n     ctx: &AssistContext<'_>,\n     body: &FunctionBody,\n-    src: &hir::InFile<Either<ast::IdentPat, ast::SelfParam>>,\n+    src: &LocalSource,\n ) -> bool {\n-    src.file_id.original_file(ctx.db()) == ctx.file_id()\n-        && !body.contains_node(either_syntax(&src.value))\n-}\n-\n-fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n-    match value {\n-        Either::Left(pat) => pat.syntax(),\n-        Either::Right(it) => it.syntax(),\n-    }\n+    src.original_file(ctx.db()) == ctx.file_id() && !body.contains_node(src.syntax())\n }\n \n /// find where to put extracted function definition"}, {"sha": "16356141288d57cac87c155d8de07e72c3bbc2ad", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -287,7 +287,7 @@ fn foo() {\n             extract_variable,\n             r\"\n fn foo() {\n-    $0{ let x = 0; x }$0\n+    $0{ let x = 0; x }$0;\n     something_else();\n }\",\n             r\""}, {"sha": "4c61678eab4f2318d2ed946d76f26988cfd7414d", "filename": "crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -192,6 +192,10 @@ fn target_data_for_def(\n             target_name = Some(t.name(db));\n             offset_target_and_file_id(db, t)?\n         }\n+        hir::ModuleDef::TraitAlias(t) => {\n+            target_name = Some(t.name(db));\n+            offset_target_and_file_id(db, t)?\n+        }\n         hir::ModuleDef::TypeAlias(t) => {\n             target_name = Some(t.name(db));\n             offset_target_and_file_id(db, t)?"}, {"sha": "eef037f98754aa8010357002ce7e4ea6bf774827", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 125, "deletions": 23, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,6 +5,7 @@ use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n     famous_defs::FamousDefs,\n+    helpers::is_editable_crate,\n     path_transform::PathTransform,\n     FxHashMap, FxHashSet, RootDatabase, SnippetCap,\n };\n@@ -65,6 +66,13 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let fn_name = &*name_ref.text();\n     let TargetInfo { target_module, adt_name, target, file, insert_offset } =\n         fn_target_info(ctx, path, &call, fn_name)?;\n+\n+    if let Some(m) = target_module {\n+        if !is_editable_crate(m.krate(), ctx.db()) {\n+            return None;\n+        }\n+    }\n+\n     let function_builder = FunctionBuilder::from_call(ctx, &call, fn_name, target_module, target)?;\n     let text_range = call.syntax().text_range();\n     let label = format!(\"Generate {} function\", function_builder.fn_name);\n@@ -141,12 +149,11 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let receiver_ty = ctx.sema.type_of_expr(&call.receiver()?)?.original().strip_references();\n     let adt = receiver_ty.as_adt()?;\n \n-    let current_module = ctx.sema.scope(call.syntax())?.module();\n     let target_module = adt.module(ctx.sema.db);\n-\n-    if current_module.krate() != target_module.krate() {\n+    if !is_editable_crate(target_module.krate(), ctx.db()) {\n         return None;\n     }\n+\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n     let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n \n@@ -253,7 +260,7 @@ struct FunctionBuilder {\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n-    needs_pub: bool,\n+    visibility: Visibility,\n     is_async: bool,\n }\n \n@@ -264,12 +271,14 @@ impl FunctionBuilder {\n         ctx: &AssistContext<'_>,\n         call: &ast::CallExpr,\n         fn_name: &str,\n-        target_module: Option<hir::Module>,\n+        target_module: Option<Module>,\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n-        let needs_pub = target_module.is_some();\n         let target_module =\n             target_module.or_else(|| ctx.sema.scope(target.syntax()).map(|it| it.module()))?;\n+\n+        let current_module = ctx.sema.scope(call.syntax())?.module();\n+        let visibility = calculate_necessary_visibility(current_module, target_module, ctx);\n         let fn_name = make::name(fn_name);\n         let mut necessary_generic_params = FxHashSet::default();\n         let params = fn_args(\n@@ -300,7 +309,7 @@ impl FunctionBuilder {\n             params,\n             ret_type,\n             should_focus_return_type,\n-            needs_pub,\n+            visibility,\n             is_async,\n         })\n     }\n@@ -313,8 +322,9 @@ impl FunctionBuilder {\n         target_module: Module,\n         target: GeneratedFunctionTarget,\n     ) -> Option<Self> {\n-        let needs_pub =\n-            !module_is_descendant(&ctx.sema.scope(call.syntax())?.module(), &target_module, ctx);\n+        let current_module = ctx.sema.scope(call.syntax())?.module();\n+        let visibility = calculate_necessary_visibility(current_module, target_module, ctx);\n+\n         let fn_name = make::name(&name.text());\n         let mut necessary_generic_params = FxHashSet::default();\n         necessary_generic_params.extend(receiver_ty.generic_params(ctx.db()));\n@@ -346,15 +356,19 @@ impl FunctionBuilder {\n             params,\n             ret_type,\n             should_focus_return_type,\n-            needs_pub,\n+            visibility,\n             is_async,\n         })\n     }\n \n     fn render(self, is_method: bool) -> FunctionTemplate {\n         let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n-        let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n+        let visibility = match self.visibility {\n+            Visibility::None => None,\n+            Visibility::Crate => Some(make::visibility_pub_crate()),\n+            Visibility::Pub => Some(make::visibility_pub()),\n+        };\n         let mut fn_def = make::fn_(\n             visibility,\n             self.fn_name,\n@@ -527,7 +541,7 @@ impl GeneratedFunctionTarget {\n /// Computes parameter list for the generated function.\n fn fn_args(\n     ctx: &AssistContext<'_>,\n-    target_module: hir::Module,\n+    target_module: Module,\n     call: ast::CallableExpr,\n     necessary_generic_params: &mut FxHashSet<hir::GenericParam>,\n ) -> Option<ast::ParamList> {\n@@ -957,13 +971,13 @@ fn fn_arg_name(sema: &Semantics<'_, RootDatabase>, arg_expr: &ast::Expr) -> Stri\n \n fn fn_arg_type(\n     ctx: &AssistContext<'_>,\n-    target_module: hir::Module,\n+    target_module: Module,\n     fn_arg: &ast::Expr,\n     generic_params: &mut FxHashSet<hir::GenericParam>,\n ) -> String {\n     fn maybe_displayed_type(\n         ctx: &AssistContext<'_>,\n-        target_module: hir::Module,\n+        target_module: Module,\n         fn_arg: &ast::Expr,\n         generic_params: &mut FxHashSet<hir::GenericParam>,\n     ) -> Option<String> {\n@@ -1048,16 +1062,29 @@ fn next_space_for_fn_in_impl(impl_: &ast::Impl) -> Option<GeneratedFunctionTarge\n     }\n }\n \n-fn module_is_descendant(module: &hir::Module, ans: &hir::Module, ctx: &AssistContext<'_>) -> bool {\n-    if module == ans {\n-        return true;\n-    }\n-    for c in ans.children(ctx.sema.db) {\n-        if module_is_descendant(module, &c, ctx) {\n-            return true;\n-        }\n+#[derive(Clone, Copy)]\n+enum Visibility {\n+    None,\n+    Crate,\n+    Pub,\n+}\n+\n+fn calculate_necessary_visibility(\n+    current_module: Module,\n+    target_module: Module,\n+    ctx: &AssistContext<'_>,\n+) -> Visibility {\n+    let db = ctx.db();\n+    let current_module = current_module.nearest_non_block_module(db);\n+    let target_module = target_module.nearest_non_block_module(db);\n+\n+    if target_module.krate() != current_module.krate() {\n+        Visibility::Pub\n+    } else if current_module.path_to_root(db).contains(&target_module) {\n+        Visibility::None\n+    } else {\n+        Visibility::Crate\n     }\n-    false\n }\n \n // This is never intended to be used as a generic graph strucuture. If there's ever another need of\n@@ -2656,4 +2683,79 @@ fn main() {\n \",\n         )\n     }\n+\n+    #[test]\n+    fn applicable_in_different_local_crate() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+//- /lib.rs crate:lib new_source_root:local\n+fn dummy() {}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn main() {\n+    lib::foo$0();\n+}\n+\",\n+            r\"\n+fn dummy() {}\n+\n+pub fn foo() ${0:-> _} {\n+    todo!()\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn applicable_in_different_local_crate_method() {\n+        check_assist(\n+            generate_function,\n+            r\"\n+//- /lib.rs crate:lib new_source_root:local\n+pub struct S;\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn main() {\n+    lib::S.foo$0();\n+}\n+\",\n+            r\"\n+pub struct S;\n+impl S {\n+    pub fn foo(&self) ${0:-> _} {\n+        todo!()\n+    }\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_different_library_crate() {\n+        check_assist_not_applicable(\n+            generate_function,\n+            r\"\n+//- /lib.rs crate:lib new_source_root:library\n+fn dummy() {}\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn main() {\n+    lib::foo$0();\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_different_library_crate_method() {\n+        check_assist_not_applicable(\n+            generate_function,\n+            r\"\n+//- /lib.rs crate:lib new_source_root:library\n+pub struct S;\n+//- /main.rs crate:main deps:lib new_source_root:local\n+fn main() {\n+    lib::S.foo$0();\n+}\n+\",\n+        );\n+    }\n }"}, {"sha": "442918619604448b7950f5796c0a27c160872162", "filename": "crates/ide-assists/src/handlers/generate_is_empty_from_len.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -95,14 +95,7 @@ fn get_impl_method(\n \n     let scope = ctx.sema.scope(impl_.syntax())?;\n     let ty = impl_def.self_ty(db);\n-    ty.iterate_method_candidates(\n-        db,\n-        &scope,\n-        &scope.visible_traits().0,\n-        None,\n-        Some(fn_name),\n-        |func| Some(func),\n-    )\n+    ty.iterate_method_candidates(db, &scope, None, Some(fn_name), |func| Some(func))\n }\n \n #[cfg(test)]"}, {"sha": "e30a3e942c4cc8e79c67f6b0628a3e2f2c4fdde9", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,5 +1,5 @@\n use ide_db::{\n-    imports::import_assets::item_for_path_search, use_trivial_contructor::use_trivial_constructor,\n+    imports::import_assets::item_for_path_search, use_trivial_constructor::use_trivial_constructor,\n };\n use itertools::Itertools;\n use stdx::format_to;"}, {"sha": "e69d1a29677a9fec828968777af14c23e7132b95", "filename": "crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,4 +1,3 @@\n-use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -205,12 +204,14 @@ fn inline_usage(\n         return None;\n     }\n \n-    // FIXME: Handle multiple local definitions\n-    let bind_pat = match local.source(sema.db).value {\n-        Either::Left(ident) => ident,\n-        _ => return None,\n+    let sources = local.sources(sema.db);\n+    let [source] = sources.as_slice() else {\n+        // Not applicable with locals with multiple definitions (i.e. or patterns)\n+        return None;\n     };\n \n+    let bind_pat = source.as_ident_pat()?;\n+\n     let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n \n     let UsageSearchResult { mut references } = Definition::Local(local).usages(sema).all();"}, {"sha": "1361cdf00cc6d56234b7b33bbe7000ecb5cbebca", "filename": "crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 114, "deletions": 20, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n-    match_ast, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n+    ast::{self, make, AstNode, AstToken},\n+    match_ast, ted, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -12,24 +12,28 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //\n // ```\n // fn main() {\n-//     $0dbg!(92);\n+//     let x = $0dbg!(42 * dbg!(4 + 2));$0\n // }\n // ```\n // ->\n // ```\n // fn main() {\n-//     92;\n+//     let x = 42 * (4 + 2);\n // }\n // ```\n pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let macro_calls = if ctx.has_empty_selection() {\n-        vec![ctx.find_node_at_offset::<ast::MacroCall>()?]\n+        vec![ctx.find_node_at_offset::<ast::MacroExpr>()?]\n     } else {\n         ctx.covering_element()\n             .as_node()?\n             .descendants()\n             .filter(|node| ctx.selection_trimmed().contains_range(node.text_range()))\n+            // When the selection exactly covers the macro call to be removed, `covering_element()`\n+            // returns `ast::MacroCall` instead of its parent `ast::MacroExpr` that we want. So\n+            // first try finding `ast::MacroCall`s and then retrieve their parent.\n             .filter_map(ast::MacroCall::cast)\n+            .filter_map(|it| it.syntax().parent().and_then(ast::MacroExpr::cast))\n             .collect()\n     };\n \n@@ -44,14 +48,25 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n         \"Remove dbg!()\",\n         ctx.selection_trimmed(),\n         |builder| {\n-            for (range, text) in replacements {\n-                builder.replace(range, text);\n+            for (range, expr) in replacements {\n+                if let Some(expr) = expr {\n+                    builder.replace(range, expr.to_string());\n+                } else {\n+                    builder.delete(range);\n+                }\n             }\n         },\n     )\n }\n \n-fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, String)> {\n+/// Returns `None` when either\n+/// - macro call is not `dbg!()`\n+/// - any node inside `dbg!()` could not be parsed as an expression\n+/// - (`macro_expr` has no parent - is that possible?)\n+///\n+/// Returns `Some(_, None)` when the macro call should just be removed.\n+fn compute_dbg_replacement(macro_expr: ast::MacroExpr) -> Option<(TextRange, Option<ast::Expr>)> {\n+    let macro_call = macro_expr.macro_call()?;\n     let tt = macro_call.token_tree()?;\n     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);\n     if macro_call.path()?.segment()?.name_ref()?.text() != \"dbg\"\n@@ -68,40 +83,43 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n         .map(|mut tokens| syntax::hacks::parse_expr_from_str(&tokens.join(\"\")))\n         .collect::<Option<Vec<ast::Expr>>>()?;\n \n-    let macro_expr = ast::MacroExpr::cast(macro_call.syntax().parent()?)?;\n     let parent = macro_expr.syntax().parent()?;\n     Some(match &*input_expressions {\n         // dbg!()\n         [] => {\n             match_ast! {\n                 match parent {\n-                    ast::StmtList(__) => {\n+                    ast::StmtList(_) => {\n                         let range = macro_expr.syntax().text_range();\n                         let range = match whitespace_start(macro_expr.syntax().prev_sibling_or_token()) {\n                             Some(start) => range.cover_offset(start),\n                             None => range,\n                         };\n-                        (range, String::new())\n+                        (range, None)\n                     },\n                     ast::ExprStmt(it) => {\n                         let range = it.syntax().text_range();\n                         let range = match whitespace_start(it.syntax().prev_sibling_or_token()) {\n                             Some(start) => range.cover_offset(start),\n                             None => range,\n                         };\n-                        (range, String::new())\n+                        (range, None)\n                     },\n-                    _ => (macro_call.syntax().text_range(), \"()\".to_owned())\n+                    _ => (macro_call.syntax().text_range(), Some(make::expr_unit())),\n                 }\n             }\n         }\n         // dbg!(expr0)\n         [expr] => {\n+            // dbg!(expr, &parent);\n             let wrap = match ast::Expr::cast(parent) {\n                 Some(parent) => match (expr, parent) {\n                     (ast::Expr::CastExpr(_), ast::Expr::CastExpr(_)) => false,\n                     (\n-                        ast::Expr::BoxExpr(_) | ast::Expr::PrefixExpr(_) | ast::Expr::RefExpr(_),\n+                        ast::Expr::BoxExpr(_)\n+                        | ast::Expr::PrefixExpr(_)\n+                        | ast::Expr::RefExpr(_)\n+                        | ast::Expr::MacroExpr(_),\n                         ast::Expr::AwaitExpr(_)\n                         | ast::Expr::CallExpr(_)\n                         | ast::Expr::CastExpr(_)\n@@ -112,7 +130,10 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n                         | ast::Expr::TryExpr(_),\n                     ) => true,\n                     (\n-                        ast::Expr::BinExpr(_) | ast::Expr::CastExpr(_) | ast::Expr::RangeExpr(_),\n+                        ast::Expr::BinExpr(_)\n+                        | ast::Expr::CastExpr(_)\n+                        | ast::Expr::RangeExpr(_)\n+                        | ast::Expr::MacroExpr(_),\n                         ast::Expr::AwaitExpr(_)\n                         | ast::Expr::BinExpr(_)\n                         | ast::Expr::CallExpr(_)\n@@ -129,16 +150,61 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n                 },\n                 None => false,\n             };\n-            (\n-                macro_call.syntax().text_range(),\n-                if wrap { format!(\"({expr})\") } else { expr.to_string() },\n-            )\n+            let expr = replace_nested_dbgs(expr.clone());\n+            let expr = if wrap { make::expr_paren(expr) } else { expr.clone_subtree() };\n+            (macro_call.syntax().text_range(), Some(expr))\n         }\n         // dbg!(expr0, expr1, ...)\n-        exprs => (macro_call.syntax().text_range(), format!(\"({})\", exprs.iter().format(\", \"))),\n+        exprs => {\n+            let exprs = exprs.iter().cloned().map(replace_nested_dbgs);\n+            let expr = make::expr_tuple(exprs);\n+            (macro_call.syntax().text_range(), Some(expr))\n+        }\n     })\n }\n \n+fn replace_nested_dbgs(expanded: ast::Expr) -> ast::Expr {\n+    if let ast::Expr::MacroExpr(mac) = &expanded {\n+        // Special-case when `expanded` itself is `dbg!()` since we cannot replace the whole tree\n+        // with `ted`. It should be fairly rare as it means the user wrote `dbg!(dbg!(..))` but you\n+        // never know how code ends up being!\n+        let replaced = if let Some((_, expr_opt)) = compute_dbg_replacement(mac.clone()) {\n+            match expr_opt {\n+                Some(expr) => expr,\n+                None => {\n+                    stdx::never!(\"dbg! inside dbg! should not be just removed\");\n+                    expanded\n+                }\n+            }\n+        } else {\n+            expanded\n+        };\n+\n+        return replaced;\n+    }\n+\n+    let expanded = expanded.clone_for_update();\n+\n+    // We need to collect to avoid mutation during traversal.\n+    let macro_exprs: Vec<_> =\n+        expanded.syntax().descendants().filter_map(ast::MacroExpr::cast).collect();\n+\n+    for mac in macro_exprs {\n+        let expr_opt = match compute_dbg_replacement(mac.clone()) {\n+            Some((_, expr)) => expr,\n+            None => continue,\n+        };\n+\n+        if let Some(expr) = expr_opt {\n+            ted::replace(mac.syntax(), expr.syntax().clone_for_update());\n+        } else {\n+            ted::remove(mac.syntax());\n+        }\n+    }\n+\n+    expanded\n+}\n+\n fn whitespace_start(it: Option<SyntaxElement>) -> Option<TextSize> {\n     Some(it?.into_token().and_then(ast::Whitespace::cast)?.syntax().text_range().start())\n }\n@@ -287,4 +353,32 @@ fn f() {\n         check_assist_not_applicable(remove_dbg, r#\"$0dbg$0!(0)\"#);\n         check_assist_not_applicable(remove_dbg, r#\"$0dbg!(0$0)\"#);\n     }\n+\n+    #[test]\n+    fn test_nested_dbg() {\n+        check(\n+            r#\"$0let x = dbg!(dbg!(dbg!(dbg!(0 + 1)) * 2) + dbg!(3));$0\"#,\n+            r#\"let x = ((0 + 1) * 2) + 3;\"#,\n+        );\n+        check(r#\"$0dbg!(10, dbg!(), dbg!(20, 30))$0\"#, r#\"(10, (), (20, 30))\"#);\n+    }\n+\n+    #[test]\n+    fn test_multiple_nested_dbg() {\n+        check(\n+            r#\"\n+fn f() {\n+    $0dbg!();\n+    let x = dbg!(dbg!(dbg!(0 + 1)) + 2) + dbg!(3);\n+    dbg!(10, dbg!(), dbg!(20, 30));$0\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let x = ((0 + 1) + 2) + 3;\n+    (10, (), (20, 30));\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "5e31d38fbd6aeeade9602c8f3d4a0bdcf0b7c820", "filename": "crates/ide-assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -102,9 +102,11 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext<'\n         return None;\n     }\n \n+    let let_ = if pat_seen { \" let\" } else { \"\" };\n+\n     acc.add(\n         AssistId(\"replace_if_let_with_match\", AssistKind::RefactorRewrite),\n-        \"Replace if let with match\",\n+        format!(\"Replace if{let_} with match\"),\n         available_range,\n         move |edit| {\n             let match_expr = {\n@@ -210,8 +212,17 @@ fn make_else_arm(\n // ```\n pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let match_expr: ast::MatchExpr = ctx.find_node_at_offset()?;\n+    let match_arm_list = match_expr.match_arm_list()?;\n+    let available_range = TextRange::new(\n+        match_expr.syntax().text_range().start(),\n+        match_arm_list.syntax().text_range().start(),\n+    );\n+    let cursor_in_range = available_range.contains_range(ctx.selection_trimmed());\n+    if !cursor_in_range {\n+        return None;\n+    }\n \n-    let mut arms = match_expr.match_arm_list()?.arms();\n+    let mut arms = match_arm_list.arms();\n     let (first_arm, second_arm) = (arms.next()?, arms.next()?);\n     if arms.next().is_some() || first_arm.guard().is_some() || second_arm.guard().is_some() {\n         return None;\n@@ -226,10 +237,20 @@ pub(crate) fn replace_match_with_if_let(acc: &mut Assists, ctx: &AssistContext<'\n     )?;\n     let scrutinee = match_expr.expr()?;\n \n+    let let_ = match &if_let_pat {\n+        ast::Pat::LiteralPat(p)\n+            if p.literal()\n+                .map(|it| it.token().kind())\n+                .map_or(false, |it| it == T![true] || it == T![false]) =>\n+        {\n+            \"\"\n+        }\n+        _ => \" let\",\n+    };\n     let target = match_expr.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_match_with_if_let\", AssistKind::RefactorRewrite),\n-        \"Replace match with if let\",\n+        format!(\"Replace match with if{let_}\"),\n         target,\n         move |edit| {\n             fn make_block_expr(expr: ast::Expr) -> ast::BlockExpr {"}, {"sha": "a7e3ed793f1726e8c5d07203cf4c6ad6562be7e9", "filename": "crates/ide-assists/src/handlers/replace_method_eager_lazy.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,310 @@\n+use ide_db::assists::{AssistId, AssistKind};\n+use syntax::{\n+    ast::{self, make, Expr, HasArgList},\n+    AstNode,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: replace_with_lazy_method\n+//\n+// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n+//\n+// ```\n+// # //- minicore:option, fn\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or(2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or_else(|| 2);\n+// }\n+// ```\n+pub(crate) fn replace_with_lazy_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let scope = ctx.sema.scope(call.syntax())?;\n+\n+    let last_arg = call.arg_list()?.args().next()?;\n+    let method_name = call.name_ref()?;\n+\n+    let callable = ctx.sema.resolve_method_call_as_callable(&call)?;\n+    let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;\n+    let n_params = callable.n_params() + 1;\n+\n+    let method_name_lazy = format!(\n+        \"{method_name}{}\",\n+        if method_name.text().ends_with(\"or\") { \"_else\" } else { \"_with\" }\n+    );\n+\n+    receiver_ty.iterate_method_candidates_with_traits(\n+        ctx.sema.db,\n+        &scope,\n+        &scope.visible_traits().0,\n+        None,\n+        None,\n+        |func| {\n+            let valid = func.name(ctx.sema.db).as_str() == Some(&*method_name_lazy)\n+                && func.num_params(ctx.sema.db) == n_params\n+                && {\n+                    let params = func.params_without_self(ctx.sema.db);\n+                    let last_p = params.first()?;\n+                    // FIXME: Check that this has the form of `() -> T` where T is the current type of the argument\n+                    last_p.ty().impls_fnonce(ctx.sema.db)\n+                };\n+            valid.then_some(func)\n+        },\n+    )?;\n+\n+    acc.add(\n+        AssistId(\"replace_with_lazy_method\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {method_name} with {method_name_lazy}\"),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(method_name.syntax().text_range(), method_name_lazy);\n+            let closured = into_closure(&last_arg);\n+            builder.replace_ast(last_arg, closured);\n+        },\n+    )\n+}\n+\n+fn into_closure(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::CallExpr(call) = param {\n+            if call.arg_list()?.args().count() == 0 {\n+                Some(call.expr()?)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n+}\n+\n+// Assist: replace_with_eager_method\n+//\n+// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n+//\n+// ```\n+// # //- minicore:option, fn\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or_else(|| 2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or(2);\n+// }\n+// ```\n+pub(crate) fn replace_with_eager_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let scope = ctx.sema.scope(call.syntax())?;\n+\n+    let last_arg = call.arg_list()?.args().next()?;\n+    let method_name = call.name_ref()?;\n+\n+    let callable = ctx.sema.resolve_method_call_as_callable(&call)?;\n+    let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;\n+    let n_params = callable.n_params() + 1;\n+    let params = callable.params(ctx.sema.db);\n+\n+    // FIXME: Check that the arg is of the form `() -> T`\n+    if !params.first()?.1.impls_fnonce(ctx.sema.db) {\n+        return None;\n+    }\n+\n+    let method_name_text = method_name.text();\n+    let method_name_eager = method_name_text\n+        .strip_suffix(\"_else\")\n+        .or_else(|| method_name_text.strip_suffix(\"_with\"))?;\n+\n+    receiver_ty.iterate_method_candidates_with_traits(\n+        ctx.sema.db,\n+        &scope,\n+        &scope.visible_traits().0,\n+        None,\n+        None,\n+        |func| {\n+            let valid = func.name(ctx.sema.db).as_str() == Some(&*method_name_eager)\n+                && func.num_params(ctx.sema.db) == n_params;\n+            valid.then_some(func)\n+        },\n+    )?;\n+\n+    acc.add(\n+        AssistId(\"replace_with_eager_method\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {method_name} with {method_name_eager}\"),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(method_name.syntax().text_range(), method_name_eager);\n+            let called = into_call(&last_arg);\n+            builder.replace_ast(last_arg, called);\n+        },\n+    )\n+}\n+\n+fn into_call(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::ClosureExpr(closure) = param {\n+            if closure.param_list()?.params().count() == 0 {\n+                Some(closure.body()?)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn replace_or_with_or_else_simple() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| 2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_call() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(x());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_block() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or({\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| {\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_simple() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(|| 2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_call() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\n+fn x() -> i32 { 0 }\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(x());\n+}\n+\n+fn x() -> i32 { 0 }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_map() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(\"foo\");\n+    return foo.map$0_or_else(|| 42, |v| v.len());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(\"foo\");\n+    return foo.map_or(42, |v| v.len());\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "f0ed3c4fe6f50f397168365a2a0afe876e6a84b7", "filename": "crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=15b867b5db35d67e0f1026b55f22ba6b25ad6dcb", "patch": "@@ -1,364 +0,0 @@\n-use ide_db::{\n-    assists::{AssistId, AssistKind},\n-    famous_defs::FamousDefs,\n-};\n-use syntax::{\n-    ast::{self, make, Expr, HasArgList},\n-    AstNode,\n-};\n-\n-use crate::{AssistContext, Assists};\n-\n-// Assist: replace_or_with_or_else\n-//\n-// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n-//\n-// ```\n-// # //- minicore:option\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwra$0p_or(2);\n-// }\n-// ```\n-// ->\n-// ```\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwrap_or_else(|| 2);\n-// }\n-// ```\n-pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n-\n-    let kind = is_option_or_result(call.receiver()?, ctx)?;\n-\n-    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n-\n-    let mut map_or = false;\n-\n-    let replace = match &*name.text() {\n-        \"unwrap_or\" => \"unwrap_or_else\".to_string(),\n-        \"or\" => \"or_else\".to_string(),\n-        \"ok_or\" if kind == Kind::Option => \"ok_or_else\".to_string(),\n-        \"map_or\" => {\n-            map_or = true;\n-            \"map_or_else\".to_string()\n-        }\n-        _ => return None,\n-    };\n-\n-    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n-        [] => make::arg_list(Vec::new()),\n-        [first] => {\n-            let param = into_closure(first);\n-            make::arg_list(vec![param])\n-        }\n-        [first, second] if map_or => {\n-            let param = into_closure(first);\n-            make::arg_list(vec![param, second.clone()])\n-        }\n-        _ => return None,\n-    };\n-\n-    acc.add(\n-        AssistId(\"replace_or_with_or_else\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {name} with {replace}\"),\n-        call.syntax().text_range(),\n-        |builder| {\n-            builder.replace(name.syntax().text_range(), replace);\n-            builder.replace_ast(arg_list, arg)\n-        },\n-    )\n-}\n-\n-fn into_closure(param: &Expr) -> Expr {\n-    (|| {\n-        if let ast::Expr::CallExpr(call) = param {\n-            if call.arg_list()?.args().count() == 0 {\n-                Some(call.expr()?)\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    })()\n-    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n-}\n-\n-// Assist: replace_or_else_with_or\n-//\n-// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n-//\n-// ```\n-// # //- minicore:option\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwra$0p_or_else(|| 2);\n-// }\n-// ```\n-// ->\n-// ```\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwrap_or(2);\n-// }\n-// ```\n-pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n-\n-    let kind = is_option_or_result(call.receiver()?, ctx)?;\n-\n-    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n-\n-    let mut map_or = false;\n-    let replace = match &*name.text() {\n-        \"unwrap_or_else\" => \"unwrap_or\".to_string(),\n-        \"or_else\" => \"or\".to_string(),\n-        \"ok_or_else\" if kind == Kind::Option => \"ok_or\".to_string(),\n-        \"map_or_else\" => {\n-            map_or = true;\n-            \"map_or\".to_string()\n-        }\n-        _ => return None,\n-    };\n-\n-    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n-        [] => make::arg_list(Vec::new()),\n-        [first] => {\n-            let param = into_call(first);\n-            make::arg_list(vec![param])\n-        }\n-        [first, second] if map_or => {\n-            let param = into_call(first);\n-            make::arg_list(vec![param, second.clone()])\n-        }\n-        _ => return None,\n-    };\n-\n-    acc.add(\n-        AssistId(\"replace_or_else_with_or\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {name} with {replace}\"),\n-        call.syntax().text_range(),\n-        |builder| {\n-            builder.replace(name.syntax().text_range(), replace);\n-            builder.replace_ast(arg_list, arg)\n-        },\n-    )\n-}\n-\n-fn into_call(param: &Expr) -> Expr {\n-    (|| {\n-        if let ast::Expr::ClosureExpr(closure) = param {\n-            if closure.param_list()?.params().count() == 0 {\n-                Some(closure.body()?)\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    })()\n-    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n-}\n-\n-#[derive(PartialEq, Eq)]\n-enum Kind {\n-    Option,\n-    Result,\n-}\n-\n-fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<Kind> {\n-    let ty = ctx.sema.type_of_expr(&receiver)?.adjusted().as_adt()?.as_enum()?;\n-    let option_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_option_Option();\n-\n-    if let Some(option_enum) = option_enum {\n-        if ty == option_enum {\n-            return Some(Kind::Option);\n-        }\n-    }\n-\n-    let result_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_result_Result();\n-\n-    if let Some(result_enum) = result_enum {\n-        if ty == result_enum {\n-            return Some(Kind::Result);\n-        }\n-    }\n-\n-    None\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn replace_or_with_or_else_simple() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or(2);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(|| 2);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_with_or_else_call() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or(x());\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(x);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_with_or_else_block() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or({\n-        let mut x = bar();\n-        for i in 0..10 {\n-            x += i;\n-        }\n-        x\n-    });\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(|| {\n-        let mut x = bar();\n-        for i in 0..10 {\n-            x += i;\n-        }\n-        x\n-    });\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_simple() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or_else(|| 2);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or(2);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_call() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or(x());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_result() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: result\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_or(x());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_map() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: result\n-fn foo() {\n-    let foo = Ok(\"foo\");\n-    return foo.map$0_or_else(|| 42, |v| v.len());\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(\"foo\");\n-    return foo.map_or(42, |v| v.len());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_not_applicable() {\n-        check_assist_not_applicable(\n-            replace_or_else_with_or,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "4d489b62b5c88ccca7032bc00bedc9098b5a7cc3", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -188,7 +188,7 @@ mod handlers {\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n-    mod replace_or_with_or_else;\n+    mod replace_method_eager_lazy;\n     mod replace_arith_op;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n@@ -297,8 +297,8 @@ mod handlers {\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_if_let_with_match::replace_match_with_if_let,\n             replace_let_with_if_let::replace_let_with_if_let,\n-            replace_or_with_or_else::replace_or_else_with_or,\n-            replace_or_with_or_else::replace_or_with_or_else,\n+            replace_method_eager_lazy::replace_with_eager_method,\n+            replace_method_eager_lazy::replace_with_lazy_method,\n             replace_turbofish_with_explicit_type::replace_turbofish_with_explicit_type,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_arith_op::replace_arith_with_wrapping,"}, {"sha": "e5a8d675a9ead0e924909c82538580381a52e26c", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -2006,12 +2006,12 @@ fn doctest_remove_dbg() {\n         \"remove_dbg\",\n         r#####\"\n fn main() {\n-    $0dbg!(92);\n+    let x = $0dbg!(42 * dbg!(4 + 2));$0\n }\n \"#####,\n         r#####\"\n fn main() {\n-    92;\n+    let x = 42 * (4 + 2);\n }\n \"#####,\n     )\n@@ -2313,46 +2313,6 @@ fn handle(action: Action) {\n     )\n }\n \n-#[test]\n-fn doctest_replace_or_else_with_or() {\n-    check_doc_test(\n-        \"replace_or_else_with_or\",\n-        r#####\"\n-//- minicore:option\n-fn foo() {\n-    let a = Some(1);\n-    a.unwra$0p_or_else(|| 2);\n-}\n-\"#####,\n-        r#####\"\n-fn foo() {\n-    let a = Some(1);\n-    a.unwrap_or(2);\n-}\n-\"#####,\n-    )\n-}\n-\n-#[test]\n-fn doctest_replace_or_with_or_else() {\n-    check_doc_test(\n-        \"replace_or_with_or_else\",\n-        r#####\"\n-//- minicore:option\n-fn foo() {\n-    let a = Some(1);\n-    a.unwra$0p_or(2);\n-}\n-\"#####,\n-        r#####\"\n-fn foo() {\n-    let a = Some(1);\n-    a.unwrap_or_else(|| 2);\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_replace_qualified_name_with_use() {\n     check_doc_test(\n@@ -2427,6 +2387,46 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_replace_with_eager_method() {\n+    check_doc_test(\n+        \"replace_with_eager_method\",\n+        r#####\"\n+//- minicore:option, fn\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or_else(|| 2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_with_lazy_method() {\n+    check_doc_test(\n+        \"replace_with_lazy_method\",\n+        r#####\"\n+//- minicore:option, fn\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or(2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or_else(|| 2);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_sort_items() {\n     check_doc_test("}, {"sha": "09ac57153ae8b65df027bcda23b0ed7d98a84fdc", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -122,7 +122,7 @@ fn complete_methods(\n     mut f: impl FnMut(hir::Function),\n ) {\n     let mut seen_methods = FxHashSet::default();\n-    receiver.iterate_method_candidates(\n+    receiver.iterate_method_candidates_with_traits(\n         ctx.db,\n         &ctx.scope,\n         &ctx.traits_in_scope(),"}, {"sha": "0979f6a6dfc7d492e8b5bc619a719d572b9faf8f", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,10 +5,7 @@ use ide_db::imports::{\n     insert_use::ImportScope,\n };\n use itertools::Itertools;\n-use syntax::{\n-    ast::{self},\n-    AstNode, SyntaxNode, T,\n-};\n+use syntax::{ast, AstNode, SyntaxNode, T};\n \n use crate::{\n     context::{"}, {"sha": "69c05a76df4cea54332fe5b348530415ab52f6dd", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -33,7 +33,9 @@ pub(crate) fn complete_type_path(\n             // Don't suggest attribute macros and derives.\n             ScopeDef::ModuleDef(Macro(mac)) => mac.is_fn_like(ctx.db),\n             // Type things are fine\n-            ScopeDef::ModuleDef(BuiltinType(_) | Adt(_) | Module(_) | Trait(_) | TypeAlias(_))\n+            ScopeDef::ModuleDef(\n+                BuiltinType(_) | Adt(_) | Module(_) | Trait(_) | TraitAlias(_) | TypeAlias(_),\n+            )\n             | ScopeDef::AdtSelfType(_)\n             | ScopeDef::Unknown\n             | ScopeDef::GenericParam(TypeParam(_)) => true,"}, {"sha": "7dc29c3d5acad7d5358645088e79dae996486184", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -6,13 +6,13 @@ mod tests;\n \n use std::iter;\n \n-use base_db::SourceDatabaseExt;\n use hir::{\n     HasAttrs, Local, Name, PathResolution, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo,\n };\n use ide_db::{\n     base_db::{FilePosition, SourceDatabase},\n     famous_defs::FamousDefs,\n+    helpers::is_editable_crate,\n     FxHashMap, FxHashSet, RootDatabase,\n };\n use syntax::{\n@@ -387,8 +387,7 @@ pub(crate) struct CompletionContext<'a> {\n impl<'a> CompletionContext<'a> {\n     /// The range of the identifier that is being completed.\n     pub(crate) fn source_range(&self) -> TextRange {\n-        // check kind of macro-expanded token, but use range of original token\n-        let kind = self.token.kind();\n+        let kind = self.original_token.kind();\n         match kind {\n             CHAR => {\n                 // assume we are completing a lifetime but the user has only typed the '\n@@ -416,6 +415,7 @@ impl<'a> CompletionContext<'a> {\n                 hir::ModuleDef::Const(it) => self.is_visible(it),\n                 hir::ModuleDef::Static(it) => self.is_visible(it),\n                 hir::ModuleDef::Trait(it) => self.is_visible(it),\n+                hir::ModuleDef::TraitAlias(it) => self.is_visible(it),\n                 hir::ModuleDef::TypeAlias(it) => self.is_visible(it),\n                 hir::ModuleDef::Macro(it) => self.is_visible(it),\n                 hir::ModuleDef::BuiltinType(_) => Visible::Yes,\n@@ -525,10 +525,11 @@ impl<'a> CompletionContext<'a> {\n                 return Visible::No;\n             }\n             // If the definition location is editable, also show private items\n-            let root_file = defining_crate.root_file(self.db);\n-            let source_root_id = self.db.file_source_root(root_file);\n-            let is_editable = !self.db.source_root(source_root_id).is_library;\n-            return if is_editable { Visible::Editable } else { Visible::No };\n+            return if is_editable_crate(defining_crate, self.db) {\n+                Visible::Editable\n+            } else {\n+                Visible::No\n+            };\n         }\n \n         if self.is_doc_hidden(attrs, defining_crate) {"}, {"sha": "bb9fa7ccaccc6b92c4eb40ffc3cfbb858384e45e", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -288,7 +288,7 @@ impl_from!(SymbolKind for CompletionItemKind);\n \n impl CompletionItemKind {\n     #[cfg(test)]\n-    pub(crate) fn tag(&self) -> &'static str {\n+    pub(crate) fn tag(self) -> &'static str {\n         match self {\n             CompletionItemKind::SymbolKind(kind) => match kind {\n                 SymbolKind::Attribute => \"at\",\n@@ -312,6 +312,7 @@ impl CompletionItemKind {\n                 SymbolKind::Struct => \"st\",\n                 SymbolKind::ToolModule => \"tm\",\n                 SymbolKind::Trait => \"tt\",\n+                SymbolKind::TraitAlias => \"tr\",\n                 SymbolKind::TypeAlias => \"ta\",\n                 SymbolKind::TypeParam => \"tp\",\n                 SymbolKind::Union => \"un\","}, {"sha": "c1f51aabb96761d99dadf3536cc161b9f84193c4", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -367,6 +367,9 @@ fn res_to_kind(resolution: ScopeDef) -> CompletionItemKind {\n         ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n         ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n         ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n+        ScopeDef::ModuleDef(TraitAlias(..)) => {\n+            CompletionItemKind::SymbolKind(SymbolKind::TraitAlias)\n+        }\n         ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::SymbolKind(SymbolKind::TypeAlias),\n         ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n         ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {"}, {"sha": "44e8860763329abd27997f1c726ab443171db2a3", "filename": "crates/ide-completion/src/render/macro_.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fmacro_.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -264,6 +264,65 @@ macro_rules! foo {\n fn main() {\n     foo!($0)\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn complete_missing_macro_arg() {\n+        // Regression test for https://github.com/rust-lang/rust-analyzer/issues/14246\n+        check_edit(\n+            \"BAR\",\n+            r#\"\n+macro_rules! foo {\n+    ($val:ident,  $val2: ident) => {\n+        $val $val2\n+    };\n+}\n+\n+const BAR: u32 = 9;\n+fn main() {\n+    foo!(BAR, $0)\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    ($val:ident,  $val2: ident) => {\n+        $val $val2\n+    };\n+}\n+\n+const BAR: u32 = 9;\n+fn main() {\n+    foo!(BAR, BAR)\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"BAR\",\n+            r#\"\n+macro_rules! foo {\n+    ($val:ident,  $val2: ident) => {\n+        $val $val2\n+    };\n+}\n+\n+const BAR: u32 = 9;\n+fn main() {\n+    foo!($0)\n+}\n+\"#,\n+            r#\"\n+macro_rules! foo {\n+    ($val:ident,  $val2: ident) => {\n+        $val $val2\n+    };\n+}\n+\n+const BAR: u32 = 9;\n+fn main() {\n+    foo!(BAR)\n+}\n \"#,\n         );\n     }"}, {"sha": "0da4e729a8ddd450231c54f05d29f878b60d93c3", "filename": "crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -96,6 +96,7 @@ pub fn generic_def_for_node(\n                     hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n                     hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n                     hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::TraitAlias(it)) => it.into(),\n                     hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n                     hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n                     hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))"}, {"sha": "244e99fe2e27d2359b1431f44778f14cf5e39ed1", "filename": "crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -73,68 +73,96 @@ impl RootDatabase {\n \n             // AstDatabase\n             hir::db::AstIdMapQuery\n+            hir::db::ParseMacroExpansionQuery\n+            hir::db::InternMacroCallQuery\n             hir::db::MacroArgTextQuery\n             hir::db::MacroDefQuery\n-            hir::db::ParseMacroExpansionQuery\n             hir::db::MacroExpandQuery\n+            hir::db::ExpandProcMacroQuery\n+            hir::db::MacroExpandErrorQuery\n             hir::db::HygieneFrameQuery\n-            hir::db::InternMacroCallQuery\n \n             // DefDatabase\n             hir::db::FileItemTreeQuery\n-            hir::db::BlockDefMapQuery\n             hir::db::CrateDefMapQueryQuery\n-            hir::db::FieldsAttrsQuery\n-            hir::db::VariantsAttrsQuery\n-            hir::db::FieldsAttrsSourceMapQuery\n-            hir::db::VariantsAttrsSourceMapQuery\n+            hir::db::BlockDefMapQuery\n             hir::db::StructDataQuery\n+            hir::db::StructDataWithDiagnosticsQuery\n             hir::db::UnionDataQuery\n+            hir::db::UnionDataWithDiagnosticsQuery\n             hir::db::EnumDataQuery\n+            hir::db::EnumDataWithDiagnosticsQuery\n             hir::db::ImplDataQuery\n+            hir::db::ImplDataWithDiagnosticsQuery\n             hir::db::TraitDataQuery\n+            hir::db::TraitDataWithDiagnosticsQuery\n+            hir::db::TraitAliasDataQuery\n             hir::db::TypeAliasDataQuery\n             hir::db::FunctionDataQuery\n             hir::db::ConstDataQuery\n             hir::db::StaticDataQuery\n+            hir::db::Macro2DataQuery\n+            hir::db::MacroRulesDataQuery\n+            hir::db::ProcMacroDataQuery\n             hir::db::BodyWithSourceMapQuery\n             hir::db::BodyQuery\n             hir::db::ExprScopesQuery\n             hir::db::GenericParamsQuery\n+            hir::db::VariantsAttrsQuery\n+            hir::db::FieldsAttrsQuery\n+            hir::db::VariantsAttrsSourceMapQuery\n+            hir::db::FieldsAttrsSourceMapQuery\n             hir::db::AttrsQuery\n             hir::db::CrateLangItemsQuery\n             hir::db::LangItemQuery\n             hir::db::ImportMapQuery\n+            hir::db::FieldVisibilitiesQuery\n+            hir::db::FunctionVisibilityQuery\n+            hir::db::ConstVisibilityQuery\n+            hir::db::CrateSupportsNoStdQuery\n \n             // HirDatabase\n             hir::db::InferQueryQuery\n+            hir::db::MirBodyQuery\n+            hir::db::BorrowckQuery\n             hir::db::TyQuery\n             hir::db::ValueTyQuery\n             hir::db::ImplSelfTyQuery\n+            hir::db::ConstParamTyQuery\n+            hir::db::ConstEvalQuery\n+            hir::db::ConstEvalDiscriminantQuery\n             hir::db::ImplTraitQuery\n             hir::db::FieldTypesQuery\n+            hir::db::LayoutOfAdtQuery\n+            hir::db::TargetDataLayoutQuery\n             hir::db::CallableItemSignatureQuery\n+            hir::db::ReturnTypeImplTraitsQuery\n             hir::db::GenericPredicatesForParamQuery\n             hir::db::GenericPredicatesQuery\n+            hir::db::TraitEnvironmentQuery\n             hir::db::GenericDefaultsQuery\n             hir::db::InherentImplsInCrateQuery\n-            hir::db::TraitEnvironmentQuery\n+            hir::db::InherentImplsInBlockQuery\n+            hir::db::IncoherentInherentImplCratesQuery\n             hir::db::TraitImplsInCrateQuery\n+            hir::db::TraitImplsInBlockQuery\n             hir::db::TraitImplsInDepsQuery\n-            hir::db::AssociatedTyDataQuery\n+            hir::db::InternCallableDefQuery\n+            hir::db::InternLifetimeParamIdQuery\n+            hir::db::InternImplTraitIdQuery\n+            hir::db::InternTypeOrConstParamIdQuery\n+            hir::db::InternClosureQuery\n+            hir::db::InternGeneratorQuery\n             hir::db::AssociatedTyDataQuery\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n             hir::db::FnDefDatumQuery\n-            hir::db::ReturnTypeImplTraitsQuery\n-            hir::db::InternCallableDefQuery\n-            hir::db::InternTypeOrConstParamIdQuery\n-            hir::db::InternImplTraitIdQuery\n-            hir::db::InternClosureQuery\n+            hir::db::FnDefVarianceQuery\n+            hir::db::AdtVarianceQuery\n             hir::db::AssociatedTyValueQuery\n             hir::db::TraitSolveQueryQuery\n-            hir::db::InternTypeOrConstParamIdQuery\n+            hir::db::ProgramClausesForChalkEnvQuery\n \n             // SymbolsDatabase\n             crate::symbol_index::ModuleSymbolsQuery\n@@ -153,8 +181,14 @@ impl RootDatabase {\n             hir::db::InternConstQuery\n             hir::db::InternStaticQuery\n             hir::db::InternTraitQuery\n+            hir::db::InternTraitAliasQuery\n             hir::db::InternTypeAliasQuery\n             hir::db::InternImplQuery\n+            hir::db::InternExternBlockQuery\n+            hir::db::InternBlockQuery\n+            hir::db::InternMacro2Query\n+            hir::db::InternProcMacroQuery\n+            hir::db::InternMacroRulesQuery\n         ];\n \n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));"}, {"sha": "1322f5228e8b9994181b6590889c9e66f5f03a11", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -9,7 +9,8 @@ use arrayvec::ArrayVec;\n use hir::{\n     Adt, AsAssocItem, AssocItem, BuiltinAttr, BuiltinType, Const, Crate, DeriveHelper, Field,\n     Function, GenericParam, HasVisibility, Impl, ItemInNs, Label, Local, Macro, Module, ModuleDef,\n-    Name, PathResolution, Semantics, Static, ToolModule, Trait, TypeAlias, Variant, Visibility,\n+    Name, PathResolution, Semantics, Static, ToolModule, Trait, TraitAlias, TypeAlias, Variant,\n+    Visibility,\n };\n use stdx::impl_from;\n use syntax::{\n@@ -31,6 +32,7 @@ pub enum Definition {\n     Const(Const),\n     Static(Static),\n     Trait(Trait),\n+    TraitAlias(TraitAlias),\n     TypeAlias(TypeAlias),\n     BuiltinType(BuiltinType),\n     SelfType(Impl),\n@@ -64,6 +66,7 @@ impl Definition {\n             Definition::Const(it) => it.module(db),\n             Definition::Static(it) => it.module(db),\n             Definition::Trait(it) => it.module(db),\n+            Definition::TraitAlias(it) => it.module(db),\n             Definition::TypeAlias(it) => it.module(db),\n             Definition::Variant(it) => it.module(db),\n             Definition::SelfType(it) => it.module(db),\n@@ -87,6 +90,7 @@ impl Definition {\n             Definition::Const(it) => it.visibility(db),\n             Definition::Static(it) => it.visibility(db),\n             Definition::Trait(it) => it.visibility(db),\n+            Definition::TraitAlias(it) => it.visibility(db),\n             Definition::TypeAlias(it) => it.visibility(db),\n             Definition::Variant(it) => it.visibility(db),\n             Definition::BuiltinType(_) => Visibility::Public,\n@@ -113,6 +117,7 @@ impl Definition {\n             Definition::Const(it) => it.name(db)?,\n             Definition::Static(it) => it.name(db),\n             Definition::Trait(it) => it.name(db),\n+            Definition::TraitAlias(it) => it.name(db),\n             Definition::TypeAlias(it) => it.name(db),\n             Definition::BuiltinType(it) => it.name(),\n             Definition::SelfType(_) => return None,\n@@ -300,6 +305,7 @@ impl NameClass {\n                 ast::Item::Module(it) => Definition::Module(sema.to_def(&it)?),\n                 ast::Item::Static(it) => Definition::Static(sema.to_def(&it)?),\n                 ast::Item::Trait(it) => Definition::Trait(sema.to_def(&it)?),\n+                ast::Item::TraitAlias(it) => Definition::TraitAlias(sema.to_def(&it)?),\n                 ast::Item::TypeAlias(it) => Definition::TypeAlias(sema.to_def(&it)?),\n                 ast::Item::Enum(it) => Definition::Adt(hir::Adt::Enum(sema.to_def(&it)?)),\n                 ast::Item::Struct(it) => Definition::Adt(hir::Adt::Struct(sema.to_def(&it)?)),\n@@ -463,9 +469,12 @@ impl NameRefClass {\n         match_ast! {\n             match parent {\n                 ast::MethodCallExpr(method_call) => {\n-                    sema.resolve_method_call(&method_call)\n-                        .map(Definition::Function)\n-                        .map(NameRefClass::Definition)\n+                    sema.resolve_method_call_field_fallback(&method_call)\n+                        .map(|it| {\n+                            it.map_left(Definition::Function)\n+                                .map_right(Definition::Field)\n+                                .either(NameRefClass::Definition, NameRefClass::Definition)\n+                        })\n                 },\n                 ast::FieldExpr(field_expr) => {\n                     sema.resolve_field(&field_expr)\n@@ -542,7 +551,7 @@ impl NameRefClass {\n }\n \n impl_from!(\n-    Field, Module, Function, Adt, Variant, Const, Static, Trait, TypeAlias, BuiltinType, Local,\n+    Field, Module, Function, Adt, Variant, Const, Static, Trait, TraitAlias, TypeAlias, BuiltinType, Local,\n     GenericParam, Label, Macro\n     for Definition\n );\n@@ -599,6 +608,7 @@ impl From<ModuleDef> for Definition {\n             ModuleDef::Const(it) => Definition::Const(it),\n             ModuleDef::Static(it) => Definition::Static(it),\n             ModuleDef::Trait(it) => Definition::Trait(it),\n+            ModuleDef::TraitAlias(it) => Definition::TraitAlias(it),\n             ModuleDef::TypeAlias(it) => Definition::TypeAlias(it),\n             ModuleDef::Macro(it) => Definition::Macro(it),\n             ModuleDef::BuiltinType(it) => Definition::BuiltinType(it),\n@@ -616,6 +626,7 @@ impl From<Definition> for Option<ItemInNs> {\n             Definition::Const(it) => ModuleDef::Const(it),\n             Definition::Static(it) => ModuleDef::Static(it),\n             Definition::Trait(it) => ModuleDef::Trait(it),\n+            Definition::TraitAlias(it) => ModuleDef::TraitAlias(it),\n             Definition::TypeAlias(it) => ModuleDef::TypeAlias(it),\n             Definition::BuiltinType(it) => ModuleDef::BuiltinType(it),\n             _ => return None,"}, {"sha": "8e3b1eef15b2d2c7f1611398d1179f1d95ac1928", "filename": "crates/ide-db/src/helpers.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fhelpers.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -2,8 +2,8 @@\n \n use std::collections::VecDeque;\n \n-use base_db::FileId;\n-use hir::{ItemInNs, ModuleDef, Name, Semantics};\n+use base_db::{FileId, SourceDatabaseExt};\n+use hir::{Crate, ItemInNs, ModuleDef, Name, Semantics};\n use syntax::{\n     ast::{self, make},\n     AstToken, SyntaxKind, SyntaxToken, TokenAtOffset,\n@@ -103,3 +103,9 @@ pub fn lint_eq_or_in_group(lint: &str, lint_is: &str) -> bool {\n         false\n     }\n }\n+\n+pub fn is_editable_crate(krate: Crate, db: &RootDatabase) -> bool {\n+    let root_file = krate.root_file(db);\n+    let source_root_id = db.file_source_root(root_file);\n+    !db.source_root(source_root_id).is_library\n+}"}, {"sha": "b26b0a9087ea2f3858efbe7a9d31bd2c3dabd49b", "filename": "crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -528,7 +528,7 @@ fn trait_applicable_items(\n             },\n         )\n     } else {\n-        trait_candidate.receiver_ty.iterate_method_candidates(\n+        trait_candidate.receiver_ty.iterate_method_candidates_with_traits(\n             db,\n             scope,\n             &trait_candidates,"}, {"sha": "ae120470047e43e99d9a5be5724b0f7e784de8ee", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -22,7 +22,7 @@ pub mod source_change;\n pub mod symbol_index;\n pub mod traits;\n pub mod ty_filter;\n-pub mod use_trivial_contructor;\n+pub mod use_trivial_constructor;\n \n pub mod imports {\n     pub mod import_assets;\n@@ -191,6 +191,7 @@ pub enum SymbolKind {\n     Struct,\n     ToolModule,\n     Trait,\n+    TraitAlias,\n     TypeAlias,\n     TypeParam,\n     Union,\n@@ -221,6 +222,7 @@ impl From<FileSymbolKind> for SymbolKind {\n             FileSymbolKind::Static => SymbolKind::Static,\n             FileSymbolKind::Struct => SymbolKind::Struct,\n             FileSymbolKind::Trait => SymbolKind::Trait,\n+            FileSymbolKind::TraitAlias => SymbolKind::TraitAlias,\n             FileSymbolKind::TypeAlias => SymbolKind::TypeAlias,\n             FileSymbolKind::Union => SymbolKind::Union,\n         }"}, {"sha": "f710211c8cb0f0ed977af7b86d4c5574ed5b57c0", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -119,15 +119,9 @@ impl Definition {\n             Definition::Const(it) => name_range(it, sema),\n             Definition::Static(it) => name_range(it, sema),\n             Definition::Trait(it) => name_range(it, sema),\n+            Definition::TraitAlias(it) => name_range(it, sema),\n             Definition::TypeAlias(it) => name_range(it, sema),\n-            Definition::Local(local) => {\n-                let src = local.source(sema.db);\n-                let name = match &src.value {\n-                    Either::Left(bind_pat) => bind_pat.name()?,\n-                    Either::Right(_) => return None,\n-                };\n-                src.with_value(name.syntax()).original_file_range_opt(sema.db)\n-            }\n+            Definition::Local(it) => name_range(it.primary_source(sema.db), sema),\n             Definition::GenericParam(generic_param) => match generic_param {\n                 hir::GenericParam::LifetimeParam(lifetime_param) => {\n                     let src = lifetime_param.source(sema.db)?;\n@@ -301,13 +295,7 @@ fn rename_reference(\n         source_change.insert_source_edit(file_id, edit);\n         Ok(())\n     };\n-    match def {\n-        Definition::Local(l) => l\n-            .associated_locals(sema.db)\n-            .iter()\n-            .try_for_each(|&local| insert_def_edit(Definition::Local(local))),\n-        def => insert_def_edit(def),\n-    }?;\n+    insert_def_edit(def)?;\n     Ok(source_change)\n }\n \n@@ -470,59 +458,64 @@ fn source_edit_from_def(\n     def: Definition,\n     new_name: &str,\n ) -> Result<(FileId, TextEdit)> {\n-    let FileRange { file_id, range } = def\n-        .range_for_rename(sema)\n-        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-\n     let mut edit = TextEdit::builder();\n     if let Definition::Local(local) = def {\n-        if let Either::Left(pat) = local.source(sema.db).value {\n-            // special cases required for renaming fields/locals in Record patterns\n-            if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+        let mut file_id = None;\n+        for source in local.sources(sema.db) {\n+            let source = source.source;\n+            file_id = source.file_id.file_id();\n+            if let Either::Left(pat) = source.value {\n                 let name_range = pat.name().unwrap().syntax().text_range();\n-                if let Some(name_ref) = pat_field.name_ref() {\n-                    if new_name == name_ref.text() && pat.at_token().is_none() {\n-                        // Foo { field: ref mut local } -> Foo { ref mut field }\n-                        //       ^^^^^^ delete this\n-                        //                      ^^^^^ replace this with `field`\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n-                        edit.delete(\n-                            name_ref\n-                                .syntax()\n-                                .text_range()\n-                                .cover_offset(pat.syntax().text_range().start()),\n-                        );\n-                        edit.replace(name_range, name_ref.text().to_string());\n+                // special cases required for renaming fields/locals in Record patterns\n+                if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                    if let Some(name_ref) = pat_field.name_ref() {\n+                        if new_name == name_ref.text() && pat.at_token().is_none() {\n+                            // Foo { field: ref mut local } -> Foo { ref mut field }\n+                            //       ^^^^^^ delete this\n+                            //                      ^^^^^ replace this with `field`\n+                            cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n+                            edit.delete(\n+                                name_ref\n+                                    .syntax()\n+                                    .text_range()\n+                                    .cover_offset(pat.syntax().text_range().start()),\n+                            );\n+                            edit.replace(name_range, name_ref.text().to_string());\n+                        } else {\n+                            // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n+                            // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n+                            //                      ^^^^^ replace this with `new_name`\n+                            edit.replace(name_range, new_name.to_string());\n+                        }\n                     } else {\n-                        // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n-                        // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n-                        //                      ^^^^^ replace this with `new_name`\n+                        // Foo { ref mut field } -> Foo { field: ref mut new_name }\n+                        //      ^ insert `field: `\n+                        //               ^^^^^ replace this with `new_name`\n+                        edit.insert(\n+                            pat.syntax().text_range().start(),\n+                            format!(\"{}: \", pat_field.field_name().unwrap()),\n+                        );\n                         edit.replace(name_range, new_name.to_string());\n                     }\n                 } else {\n-                    // Foo { ref mut field } -> Foo { field: ref mut new_name }\n-                    //      ^ insert `field: `\n-                    //               ^^^^^ replace this with `new_name`\n-                    edit.insert(\n-                        pat.syntax().text_range().start(),\n-                        format!(\"{}: \", pat_field.field_name().unwrap()),\n-                    );\n                     edit.replace(name_range, new_name.to_string());\n                 }\n             }\n         }\n+        let Some(file_id) = file_id else { bail!(\"No file available to rename\") };\n+        return Ok((file_id, edit.finish()));\n     }\n-    if edit.is_empty() {\n-        let (range, new_name) = match def {\n-            Definition::GenericParam(hir::GenericParam::LifetimeParam(_))\n-            | Definition::Label(_) => (\n-                TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n-                new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n-            ),\n-            _ => (range, new_name.to_owned()),\n-        };\n-        edit.replace(range, new_name);\n-    }\n+    let FileRange { file_id, range } = def\n+        .range_for_rename(sema)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+    let (range, new_name) = match def {\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_) => (\n+            TextRange::new(range.start() + syntax::TextSize::from(1), range.end()),\n+            new_name.strip_prefix('\\'').unwrap_or(new_name).to_owned(),\n+        ),\n+        _ => (range, new_name.to_owned()),\n+    };\n+    edit.replace(range, new_name);\n     Ok((file_id, edit.finish()))\n }\n "}, {"sha": "12f5e4e2a23a85c000d7537172a8819927dcd8bb", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 9, "deletions": 41, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -244,14 +244,14 @@ impl Definition {\n                 DefWithBody::Variant(v) => v.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n \n         if let Definition::SelfType(impl_) = self {\n             return match impl_.source(db).map(|src| src.syntax().cloned()) {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n@@ -261,13 +261,14 @@ impl Definition {\n                 hir::GenericDef::Function(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::Adt(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::Trait(it) => it.source(db).map(|src| src.syntax().cloned()),\n+                hir::GenericDef::TraitAlias(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::TypeAlias(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::Impl(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::Variant(it) => it.source(db).map(|src| src.syntax().cloned()),\n                 hir::GenericDef::Const(it) => it.source(db).map(|src| src.syntax().cloned()),\n             };\n             return match def {\n-                Some(def) => SearchScope::file_range(def.as_ref().original_file_range(db)),\n+                Some(def) => SearchScope::file_range(def.as_ref().original_file_range_full(db)),\n                 None => SearchScope::single_file(file_id),\n             };\n         }\n@@ -318,10 +319,6 @@ impl Definition {\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n-            local_repr: match self {\n-                Definition::Local(local) => Some(local.representative(sema.db)),\n-                _ => None,\n-            },\n             search_self_mod: false,\n         }\n     }\n@@ -336,9 +333,6 @@ pub struct FindUsages<'a> {\n     assoc_item_container: Option<hir::AssocItemContainer>,\n     /// whether to search for the `Self` type of the definition\n     include_self_kw_refs: Option<hir::Type>,\n-    /// the local representative for the local definition we are searching for\n-    /// (this is required for finding all local declarations in a or-pattern)\n-    local_repr: Option<hir::Local>,\n     /// whether to search for the `self` module\n     search_self_mod: bool,\n }\n@@ -643,19 +637,6 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n-            Some(NameRefClass::Definition(def @ Definition::Local(local)))\n-                if matches!(\n-                    self.local_repr, Some(repr) if repr == local.representative(self.sema.db)\n-                ) =>\n-            {\n-                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = FileReference {\n-                    range,\n-                    name: ast::NameLike::NameRef(name_ref.clone()),\n-                    category: ReferenceCategory::new(&def, name_ref),\n-                };\n-                sink(file_id, reference)\n-            }\n             Some(NameRefClass::Definition(def))\n                 if self.def == def\n                     // is our def a trait assoc item? then we want to find all assoc items from trait impls of our trait\n@@ -700,14 +681,16 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n-                let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+\n+                let field = Definition::Field(field);\n+                let local = Definition::Local(local);\n                 let access = match self.def {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local.representative(self.sema.db)) => {\n-                        ReferenceCategory::new(&Definition::Local(local), name_ref)\n+                    Definition::Local(_) if local == self.def => {\n+                        ReferenceCategory::new(&local, name_ref)\n                     }\n                     _ => return false,\n                 };\n@@ -751,21 +734,6 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n-                if matches!(\n-                    self.local_repr,\n-                    Some(repr) if local.representative(self.sema.db) == repr\n-                ) {\n-                    let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n-                    let reference = FileReference {\n-                        range,\n-                        name: ast::NameLike::Name(name.clone()),\n-                        category: None,\n-                    };\n-                    return sink(file_id, reference);\n-                }\n-                false\n-            }\n             Some(NameClass::Definition(def)) if def != self.def => {\n                 match (&self.assoc_item_container, self.def) {\n                     // for type aliases we always want to reference the trait def and all the trait impl counterparts"}, {"sha": "936354f296134c81fef7282fc82e62f4638580ef", "filename": "crates/ide-db/src/source_change.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsource_change.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -83,6 +83,14 @@ impl From<NoHashHashMap<FileId, TextEdit>> for SourceChange {\n     }\n }\n \n+impl FromIterator<(FileId, TextEdit)> for SourceChange {\n+    fn from_iter<T: IntoIterator<Item = (FileId, TextEdit)>>(iter: T) -> Self {\n+        let mut this = SourceChange::default();\n+        this.extend(iter);\n+        this\n+    }\n+}\n+\n pub struct SourceChangeBuilder {\n     pub edit: TextEditBuilder,\n     pub file_id: FileId,"}, {"sha": "39431bed3821c8e5560a1dc13c0078f2f30dba56", "filename": "crates/ide-db/src/use_trivial_constructor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fuse_trivial_constructor.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "previous_filename": "crates/ide-db/src/use_trivial_contructor.rs"}, {"sha": "114face2dca8566ed569c5bddfd2dfc813dcf1f8", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -7,10 +7,15 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n-    let construct = if d.is_break { \"break\" } else { \"continue\" };\n+    let message = if d.bad_value_break {\n+        \"can't break with a value in this position\".to_owned()\n+    } else {\n+        let construct = if d.is_break { \"break\" } else { \"continue\" };\n+        format!(\"{construct} outside of loop\")\n+    };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        format!(\"{construct} outside of loop\"),\n+        message,\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -132,6 +137,20 @@ fn foo() {\n       //^^^^^^^^^^^ error: continue outside of loop\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn value_break_in_for_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn test() {\n+    for _ in [()] {\n+        break 3;\n+     // ^^^^^^^ error: can't break with a value in this position\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "d2f27664d6f9ec7cd1256c703d1d0d27164972bc", "filename": "crates/ide-diagnostics/src/handlers/expected_function.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fexpected_function.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,39 @@\n+use hir::HirDisplay;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: expected-function\n+//\n+// This diagnostic is triggered if a call is made on something that is not callable.\n+pub(crate) fn expected_function(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ExpectedFunction,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"expected-function\",\n+        format!(\"expected function, found {}\", d.found.display(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.call.clone().map(|it| it.into())).range,\n+    )\n+    .experimental()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let x = 3;\n+    x();\n+ // ^^^ error: expected function, found i32\n+    \"\"();\n+ // ^^^^ error: expected function, found &str\n+    foo();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "14039087b3fd669c5a86e9170849f5085052924f", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,7 +5,7 @@ use hir::{\n };\n use ide_db::{\n     assists::Assist, famous_defs::FamousDefs, imports::import_assets::item_for_path_search,\n-    source_change::SourceChange, use_trivial_contructor::use_trivial_constructor, FxHashMap,\n+    source_change::SourceChange, use_trivial_constructor::use_trivial_constructor, FxHashMap,\n };\n use stdx::format_to;\n use syntax::{"}, {"sha": "ac4463331f2d27998cd21d29ff98d2f2cb3c0a6e", "filename": "crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,5 +1,3 @@\n-use hir::InFile;\n-\n use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-match-arm\n@@ -12,7 +10,7 @@ pub(crate) fn missing_match_arms(\n     Diagnostic::new(\n         \"missing-match-arm\",\n         format!(\"missing match arm: {}\", d.uncovered_patterns),\n-        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.match_expr.clone().into())).range,\n+        ctx.sema.diagnostics_display_range(d.scrutinee_expr.clone().map(Into::into)).range,\n     )\n }\n \n@@ -1038,7 +1036,6 @@ fn main() {\n         #[test]\n         fn reference_patterns_in_fields() {\n             cov_mark::check_count!(validate_match_bailed_out, 2);\n-\n             check_diagnostics(\n                 r#\"\n fn main() {"}, {"sha": "84189a5d560f97b9291ad471a2ef4e735100ad65", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "added", "additions": 625, "deletions": 0, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,625 @@\n+use ide_db::source_change::SourceChange;\n+use syntax::{AstNode, SyntaxKind, SyntaxNode, SyntaxToken, T};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: need-mut\n+//\n+// This diagnostic is triggered on mutating an immutable variable.\n+pub(crate) fn need_mut(ctx: &DiagnosticsContext<'_>, d: &hir::NeedMut) -> Diagnostic {\n+    let fixes = (|| {\n+        if d.local.is_ref(ctx.sema.db) {\n+            // There is no simple way to add `mut` to `ref x` and `ref mut x`\n+            return None;\n+        }\n+        let file_id = d.span.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = d.span.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let Some(ast) = source.name() else { continue };\n+            edit_builder.insert(ast.syntax().text_range().start(), \"mut \".to_string());\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"add_mut\",\n+            \"Change it to be mutable\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n+    Diagnostic::new(\n+        \"need-mut\",\n+        format!(\"cannot mutate immutable variable `{}`\", d.local.name(ctx.sema.db)),\n+        ctx.sema.diagnostics_display_range(d.span.clone()).range,\n+    )\n+    .with_fixes(fixes)\n+}\n+\n+// Diagnostic: unused-mut\n+//\n+// This diagnostic is triggered when a mutable variable isn't actually mutated.\n+pub(crate) fn unused_mut(ctx: &DiagnosticsContext<'_>, d: &hir::UnusedMut) -> Diagnostic {\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n+    let fixes = (|| {\n+        let file_id = ast.file_id.file_id()?;\n+        let mut edit_builder = TextEdit::builder();\n+        let use_range = ast.value.text_range();\n+        for source in d.local.sources(ctx.sema.db) {\n+            let ast = source.syntax();\n+            let Some(mut_token) = token(ast, T![mut]) else { continue };\n+            edit_builder.delete(mut_token.text_range());\n+            if let Some(token) = mut_token.next_token() {\n+                if token.kind() == SyntaxKind::WHITESPACE {\n+                    edit_builder.delete(token.text_range());\n+                }\n+            }\n+        }\n+        let edit = edit_builder.finish();\n+        Some(vec![fix(\n+            \"remove_mut\",\n+            \"Remove unnecessary `mut`\",\n+            SourceChange::from_text_edit(file_id, edit),\n+            use_range,\n+        )])\n+    })();\n+    let ast = d.local.primary_source(ctx.sema.db).syntax_ptr();\n+    Diagnostic::new(\n+        \"unused-mut\",\n+        \"variable does not need to be mutable\",\n+        ctx.sema.diagnostics_display_range(ast).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+    .experimental() // Not supporting `#[allow(unused_mut)]` leads to false positive.\n+    .with_fixes(fixes)\n+}\n+\n+pub(super) fn token(parent: &SyntaxNode, kind: SyntaxKind) -> Option<SyntaxToken> {\n+    parent.children_with_tokens().filter_map(|it| it.into_token()).find(|it| it.kind() == kind)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn unused_mut_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_false_positive_simple() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_errors_for_single_variable() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x = 10;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    x = 5;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    &mut x;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unused_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mu$0t x = 2;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mu$0t x, _) | (_, mut x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix() {\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = 2;\n+    x$0 = 5;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = 2;\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((x, _) | (_, x)) = (2, 3);\n+    x =$0 4;\n+    f(x);\n+}\n+\"#,\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let ((mut x, _) | (_, mut x)) = (2, 3);\n+    x = 4;\n+    f(x);\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(self) {\n+        self = Fo$0o(5);\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Foo(i32);\n+\n+impl Foo {\n+    fn foo(mut self) {\n+        self = Foo(5);\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn need_mut_fix_not_applicable_on_ref() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref x = 2;\n+    x = &5;\n+  //^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let ref mut x = 2;\n+    x = &mut 5;\n+  //^^^^^^^^^^ error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field_mutate() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x = (2, 7);\n+    x.0 = 5;\n+    f(x.1);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x = (2, 7);\n+    x.0 = 5;\n+  //^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x.1);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutable_reference() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let mut x = &mut 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    *x = 5;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x = 2;\n+    &mut x;\n+  //^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let x_own = 2;\n+    let ref mut x_ref = x_own;\n+      //^^^^^^^^^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x_own`\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn method(&mut self, x: i32) {}\n+}\n+fn main() {\n+    let x = Foo;\n+    x.method(2);\n+  //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn regression_14310() {\n+        check_diagnostics(\n+            r#\"\n+            fn clone(mut i: &!) -> ! {\n+                   //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+                *i\n+            }\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_bindings() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (2, 3) {\n+        (x, mut y) => {\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            x = 7;\n+          //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn mutation_in_dead_code() {\n+        // This one is interesting. Dead code is not represented at all in the MIR, so\n+        // there would be no mutablility error for locals in dead code. Rustc tries to\n+        // not emit `unused_mut` in this case, but since it works without `mut`, and\n+        // special casing it is not trivial, we emit it.\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    return;\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    loop {}\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+enum X {}\n+fn g() -> X {\n+    loop {}\n+}\n+fn f() -> ! {\n+    loop {}\n+}\n+fn main(b: bool) {\n+    if b {\n+        f();\n+    } else {\n+        g();\n+    }\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn main(b: bool) {\n+    if b {\n+        loop {}\n+    } else {\n+        return;\n+    }\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn initialization_is_not_mutation() {\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let mut x;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x = 5;\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let mut x;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    if b {\n+        x = 1;\n+    } else {\n+        x = 3;\n+    }\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main(b: bool) {\n+    let x;\n+    if b {\n+        x = 1;\n+    }\n+    x = 3;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+    f(x);\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    let x;\n+    loop {\n+        x = 1;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+        f(x);\n+    }\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    loop {\n+        let mut x = 1;\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        f(x);\n+        if let mut y = 2 {\n+             //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            f(y);\n+        }\n+        match 3 {\n+            mut z => f(z),\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_arguments_are_initialized() {\n+        check_diagnostics(\n+            r#\"\n+fn f(mut x: i32) {\n+   //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+fn f(x: i32) {\n+   x = 5;\n+ //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn for_loop() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: iterators\n+fn f(x: [(i32, u8); 10]) {\n+    for (a, mut b) in x {\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        a = 2;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn overloaded_deref() {\n+        // FIXME: check for false negative\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref_mut\n+use core::ops::{Deref, DerefMut};\n+\n+struct Foo;\n+impl Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 {\n+        &5\n+    }\n+}\n+impl DerefMut for Foo {\n+    fn deref_mut(&mut self) -> &mut i32 {\n+        &mut 5\n+    }\n+}\n+fn f() {\n+    let x = Foo;\n+    let y = &*x;\n+    let x = Foo;\n+    let mut x = Foo;\n+    let y: &mut i32 = &mut x;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option\n+fn f(_: i32) {}\n+fn main() {\n+    let ((Some(mut x), None) | (_, Some(mut x))) = (None, Some(7));\n+             //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn or_pattern_no_terminator() {\n+        check_diagnostics(\n+            r#\"\n+enum Foo {\n+    A, B, C, D\n+}\n+\n+use Foo::*;\n+\n+fn f(inp: (Foo, Foo, Foo, Foo)) {\n+    let ((A, B, _, x) | (B, C | D, x, _)) = inp else {\n+        return;\n+    };\n+    x = B;\n+  //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn respect_allow_unused_mut() {\n+        // FIXME: respect\n+        check_diagnostics(\n+            r#\"\n+fn f(_: i32) {}\n+fn main() {\n+    #[allow(unused_mut)]\n+    let mut x = 2;\n+      //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    f(x);\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "67da5c7f27d148fd1f8958090aa0c5011dd53c8c", "filename": "crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -115,6 +115,44 @@ mod module {\n fn main(s: module::Struct) {\n     s.method();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn can_see_through_top_level_anonymous_const() {\n+        // regression test for #14046.\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) fn method(self) {}\n+            pub(crate) const A: usize = 42;\n+        }\n+    };\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) fn method2(self) {}\n+                pub(crate) const B: usize = 42;\n+                pub(super) fn private(self) {}\n+                pub(super) const PRIVATE: usize = 42;\n+            }\n+        };\n+    }\n+}\n+fn main() {\n+    S.method();\n+    S::A;\n+    S.method2();\n+    S::B;\n+    S.private();\n+  //^^^^^^^^^^^ error: function `private` is private\n+    S::PRIVATE;\n+  //^^^^^^^^^^ error: const `PRIVATE` is private\n+}\n \"#,\n         );\n     }"}, {"sha": "a0c276cc3328b94bc32c313211f087b2581a836b", "filename": "crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -55,7 +55,18 @@ fn fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_diagnostics, check_fix};\n+    use crate::{\n+        tests::{check_diagnostics_with_config, check_fix},\n+        DiagnosticsConfig,\n+    };\n+\n+    #[track_caller]\n+    pub(crate) fn check_diagnostics(ra_fixture: &str) {\n+        let mut config = DiagnosticsConfig::test_sample();\n+        config.disabled.insert(\"inactive-code\".to_string());\n+        config.disabled.insert(\"unresolved-method\".to_string());\n+        check_diagnostics_with_config(config, ra_fixture)\n+    }\n \n     #[test]\n     fn replace_filter_map_next_with_find_map2() {"}, {"sha": "b57a13e53e6b6ba7d7df87e87d33b8777efee387", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1,28 +1,33 @@\n-use hir::{db::AstDatabase, HirDisplay, Type};\n+use either::Either;\n+use hir::{db::AstDatabase, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},\n-    AstNode,\n+    AstNode, AstPtr,\n };\n use text_edit::TextEdit;\n \n use crate::{adjusted_display_range, fix, Assist, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: type-mismatch\n //\n-// This diagnostic is triggered when the type of an expression does not match\n+// This diagnostic is triggered when the type of an expression or pattern does not match\n // the expected type.\n pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Diagnostic {\n-    let display_range = adjusted_display_range::<ast::BlockExpr>(\n-        ctx,\n-        d.expr.clone().map(|it| it.into()),\n-        &|block| {\n-            let r_curly_range = block.stmt_list()?.r_curly_token()?.text_range();\n-            cov_mark::hit!(type_mismatch_on_block);\n-            Some(r_curly_range)\n-        },\n-    );\n-\n+    let display_range = match &d.expr_or_pat {\n+        Either::Left(expr) => adjusted_display_range::<ast::BlockExpr>(\n+            ctx,\n+            expr.clone().map(|it| it.into()),\n+            &|block| {\n+                let r_curly_range = block.stmt_list()?.r_curly_token()?.text_range();\n+                cov_mark::hit!(type_mismatch_on_block);\n+                Some(r_curly_range)\n+            },\n+        ),\n+        Either::Right(pat) => {\n+            ctx.sema.diagnostics_display_range(pat.clone().map(|it| it.into())).range\n+        }\n+    };\n     let mut diag = Diagnostic::new(\n         \"type-mismatch\",\n         format!(\n@@ -42,10 +47,15 @@ pub(crate) fn type_mismatch(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch)\n fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assist>> {\n     let mut fixes = Vec::new();\n \n-    add_reference(ctx, d, &mut fixes);\n-    add_missing_ok_or_some(ctx, d, &mut fixes);\n-    remove_semicolon(ctx, d, &mut fixes);\n-    str_ref_to_owned(ctx, d, &mut fixes);\n+    match &d.expr_or_pat {\n+        Either::Left(expr_ptr) => {\n+            add_reference(ctx, d, expr_ptr, &mut fixes);\n+            add_missing_ok_or_some(ctx, d, expr_ptr, &mut fixes);\n+            remove_semicolon(ctx, d, expr_ptr, &mut fixes);\n+            str_ref_to_owned(ctx, d, expr_ptr, &mut fixes);\n+        }\n+        Either::Right(_pat_ptr) => {}\n+    }\n \n     if fixes.is_empty() {\n         None\n@@ -57,9 +67,10 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::TypeMismatch) -> Option<Vec<Assi\n fn add_reference(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let range = ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range;\n+    let range = ctx.sema.diagnostics_display_range(expr_ptr.clone().map(|it| it.into())).range;\n \n     let (_, mutability) = d.expected.as_reference()?;\n     let actual_with_ref = Type::reference(&d.actual, mutability);\n@@ -71,18 +82,19 @@ fn add_reference(\n \n     let edit = TextEdit::insert(range.start(), ampersands);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"add_reference_here\", \"Add reference here\", source_change, range));\n     Some(())\n }\n \n fn add_missing_ok_or_some(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     let expr_range = expr.syntax().text_range();\n     let scope = ctx.sema.scope(expr.syntax())?;\n \n@@ -109,7 +121,7 @@ fn add_missing_ok_or_some(\n     builder.insert(expr.syntax().text_range().start(), format!(\"{variant_name}(\"));\n     builder.insert(expr.syntax().text_range().end(), \")\".to_string());\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), builder.finish());\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), builder.finish());\n     let name = format!(\"Wrap in {variant_name}\");\n     acc.push(fix(\"wrap_in_constructor\", &name, source_change, expr_range));\n     Some(())\n@@ -118,10 +130,11 @@ fn add_missing_ok_or_some(\n fn remove_semicolon(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     if !d.actual.is_unit() {\n         return None;\n     }\n@@ -136,7 +149,7 @@ fn remove_semicolon(\n \n     let edit = TextEdit::delete(semicolon_range);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n \n     acc.push(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon_range));\n     Some(())\n@@ -145,24 +158,26 @@ fn remove_semicolon(\n fn str_ref_to_owned(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::TypeMismatch,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n     acc: &mut Vec<Assist>,\n ) -> Option<()> {\n     let expected = d.expected.display(ctx.sema.db);\n     let actual = d.actual.display(ctx.sema.db);\n \n+    // FIXME do this properly\n     if expected.to_string() != \"String\" || actual.to_string() != \"&str\" {\n         return None;\n     }\n \n-    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n-    let expr = d.expr.value.to_node(&root);\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n     let expr_range = expr.syntax().text_range();\n \n     let to_owned = format!(\".to_owned()\");\n \n     let edit = TextEdit::insert(expr.syntax().text_range().end(), to_owned);\n     let source_change =\n-        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+        SourceChange::from_text_edit(expr_ptr.file_id.original_file(ctx.sema.db), edit);\n     acc.push(fix(\"str_ref_to_owned\", \"Add .to_owned() here\", source_change, expr_range));\n \n     Some(())\n@@ -592,6 +607,21 @@ fn f() -> i32 {\n     let _ = x + y;\n   }\n //^ error: expected i32, found ()\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn type_mismatch_pat_smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn f() {\n+    let &() = &mut ();\n+    match &() {\n+        &9 => ()\n+       //^ error: expected (), found i32\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "7de03416e5625ca198a9dde58b5ee96200749df3", "filename": "crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,148 @@\n+use hir::{db::AstDatabase, HirDisplay, InFile};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, AstPtr};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-field\n+//\n+// This diagnostic is triggered if a field does not exist on a given type.\n+pub(crate) fn unresolved_field(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedField,\n+) -> Diagnostic {\n+    let method_suffix = if d.method_with_same_name_exists {\n+        \", but a method with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-field\",\n+        format!(\n+            \"no field `{}` on type `{}`{method_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+    .experimental()\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField) -> Option<Vec<Assist>> {\n+    if d.method_with_same_name_exists {\n+        method_fix(ctx, &d.expr)\n+    } else {\n+        // FIXME: add quickfix\n+\n+        None\n+    }\n+}\n+\n+// FIXME: We should fill out the call here, mvoe the cursor and trigger signature help\n+fn method_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n+) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let FileRange { range, file_id } = ctx.sema.original_range_opt(expr.syntax())?;\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-field-found-method-call-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the method\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_text_edit(\n+            file_id,\n+            TextEdit::insert(range.end(), \"()\".to_owned()),\n+        )),\n+        trigger_signature_help: false,\n+    }])\n+}\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo;\n+ // ^^^^^^ error: no field `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_clash() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self) {}\n+}\n+impl Bar for Foo {}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_2() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self);\n+}\n+impl Bar for Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_diagnostic_on_unknown() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    x.foo;\n+    (&x).foo;\n+    (&((x,),),).foo;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "4b0e64cb896d58f8fead0374fe6159474f72bc42", "filename": "crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,131 @@\n+use hir::{db::AstDatabase, HirDisplay};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, TextRange};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-method\n+//\n+// This diagnostic is triggered if a method does not exist on a given type.\n+pub(crate) fn unresolved_method(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+) -> Diagnostic {\n+    let field_suffix = if d.field_with_same_name.is_some() {\n+        \", but a field with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-method\",\n+        format!(\n+            \"no method `{}` on type `{}`{field_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+    .experimental()\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedMethodCall) -> Option<Vec<Assist>> {\n+    if let Some(ty) = &d.field_with_same_name {\n+        field_fix(ctx, d, ty)\n+    } else {\n+        // FIXME: add quickfix\n+        None\n+    }\n+}\n+\n+fn field_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedMethodCall,\n+    ty: &hir::Type,\n+) -> Option<Vec<Assist>> {\n+    if !ty.impls_fnonce(ctx.sema.db) {\n+        return None;\n+    }\n+    let expr_ptr = &d.expr;\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let (file_id, range) = match expr {\n+        ast::Expr::MethodCallExpr(mcall) => {\n+            let FileRange { range, file_id } =\n+                ctx.sema.original_range_opt(mcall.receiver()?.syntax())?;\n+            let FileRange { range: range2, file_id: file_id2 } =\n+                ctx.sema.original_range_opt(mcall.name_ref()?.syntax())?;\n+            if file_id != file_id2 {\n+                return None;\n+            }\n+            (file_id, TextRange::new(range.start(), range2.end()))\n+        }\n+        _ => return None,\n+    };\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-method-found-field-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the value of the field\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_iter([\n+            (file_id, TextEdit::insert(range.start(), \"(\".to_owned())),\n+            (file_id, TextEdit::insert(range.end(), \")\".to_owned())),\n+        ])),\n+        trigger_signature_help: false,\n+    }])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo();\n+ // ^^^^^^^^ error: no method `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { bar: i32 }\n+fn foo() {\n+    Foo { bar: i32 }.bar();\n+ // ^^^^^^^^^^^^^^^^^^^^^^ error: no method `bar` on type `Foo`, but a field with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn callable_field() {\n+        check_fix(\n+            r#\"\n+//- minicore: fn\n+struct Foo { bar: fn() }\n+fn foo() {\n+    Foo { bar: foo }.b$0ar();\n+}\n+\"#,\n+            r#\"\n+struct Foo { bar: fn() }\n+fn foo() {\n+    (Foo { bar: foo }.bar)();\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f6c9b79c30c3cf31f101cda55a4b80046eb84149", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -27,6 +27,7 @@\n \n mod handlers {\n     pub(crate) mod break_outside_of_loop;\n+    pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n@@ -36,13 +37,16 @@ mod handlers {\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod mutability_errors;\n     pub(crate) mod no_such_field;\n     pub(crate) mod private_assoc_item;\n     pub(crate) mod private_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n+    pub(crate) mod unresolved_field;\n+    pub(crate) mod unresolved_method;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n@@ -248,6 +252,7 @@ pub fn diagnostics(\n         #[rustfmt::skip]\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n+            AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n@@ -267,7 +272,10 @@ pub fn diagnostics(\n             AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n-\n+            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n+            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n+            AnyDiagnostic::UnusedMut(d) => handlers::mutability_errors::unused_mut(&ctx, &d),\n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n                 None => continue,"}, {"sha": "a8e883690883751813ebd656edc87a50f8205685", "filename": "crates/ide-ssr/src/matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fmatching.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -561,7 +561,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                             .sema\n                             .resolve_method_call_as_callable(code)\n                             .and_then(|callable| callable.receiver_param(self.sema.db))\n-                            .map(|self_param| self_param.kind())\n+                            .map(|(self_param, _)| self_param.kind())\n                             .unwrap_or(ast::SelfParamKind::Owned);\n                     }\n                 }"}, {"sha": "fae25f3102333b0764e27af203de984aa75a273d", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -107,7 +107,18 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     out\n }\n \n-/// Retrieve a link to documentation for the given symbol.\n+// Feature: Open Docs\n+//\n+// Retrieve a link to documentation for the given symbol.\n+//\n+// The simplest way to use this feature is via the context menu. Right-click on\n+// the selected item. The context menu opens. Select **Open Docs**.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **rust-analyzer: Open Docs**\n+// |===\n pub(crate) fn external_docs(\n     db: &RootDatabase,\n     position: &FilePosition,\n@@ -181,6 +192,7 @@ pub(crate) fn resolve_doc_path_for_def(\n         Definition::Const(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Static(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Trait(it) => it.resolve_doc_path(db, link, ns),\n+        Definition::TraitAlias(it) => it.resolve_doc_path(db, link, ns),\n         Definition::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n@@ -493,6 +505,7 @@ fn filename_and_frag_for_def(\n             None => String::from(\"index.html\"),\n         },\n         Definition::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+        Definition::TraitAlias(t) => format!(\"traitalias.{}.html\", t.name(db)),\n         Definition::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n         Definition::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n         Definition::Function(f) => format!(\"fn.{}.html\", f.name(db)),"}, {"sha": "a32ac35496aa4942e4db180b80f85049916c3c4f", "filename": "crates/ide/src/file_structure.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffile_structure.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -149,6 +149,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             ast::Enum(it) => decl(it, StructureNodeKind::SymbolKind(SymbolKind::Enum)),\n             ast::Variant(it) => decl(it, StructureNodeKind::SymbolKind(SymbolKind::Variant)),\n             ast::Trait(it) => decl(it, StructureNodeKind::SymbolKind(SymbolKind::Trait)),\n+            ast::TraitAlias(it) => decl(it, StructureNodeKind::SymbolKind(SymbolKind::TraitAlias)),\n             ast::Module(it) => decl(it, StructureNodeKind::SymbolKind(SymbolKind::Module)),\n             ast::TypeAlias(it) => decl_with_type_ref(&it, it.ty(), StructureNodeKind::SymbolKind(SymbolKind::TypeAlias)),\n             ast::RecordField(it) => decl_with_type_ref(&it, it.ty(), StructureNodeKind::SymbolKind(SymbolKind::Field)),\n@@ -262,6 +263,8 @@ enum E { X, Y(i32) }\n type T = ();\n static S: i32 = 92;\n const C: i32 = 92;\n+trait Tr {}\n+trait Alias = Tr;\n \n impl E {}\n \n@@ -457,11 +460,33 @@ fn g() {}\n                         ),\n                         deprecated: false,\n                     },\n+                    StructureNode {\n+                        parent: None,\n+                        label: \"Tr\",\n+                        navigation_range: 239..241,\n+                        node_range: 233..244,\n+                        kind: SymbolKind(\n+                            Trait,\n+                        ),\n+                        detail: None,\n+                        deprecated: false,\n+                    },\n+                    StructureNode {\n+                        parent: None,\n+                        label: \"Alias\",\n+                        navigation_range: 251..256,\n+                        node_range: 245..262,\n+                        kind: SymbolKind(\n+                            TraitAlias,\n+                        ),\n+                        detail: None,\n+                        deprecated: false,\n+                    },\n                     StructureNode {\n                         parent: None,\n                         label: \"impl E\",\n-                        navigation_range: 239..240,\n-                        node_range: 234..243,\n+                        navigation_range: 269..270,\n+                        node_range: 264..273,\n                         kind: SymbolKind(\n                             Impl,\n                         ),\n@@ -471,8 +496,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"impl fmt::Debug for E\",\n-                        navigation_range: 265..266,\n-                        node_range: 245..269,\n+                        navigation_range: 295..296,\n+                        node_range: 275..299,\n                         kind: SymbolKind(\n                             Impl,\n                         ),\n@@ -482,8 +507,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"mc\",\n-                        navigation_range: 284..286,\n-                        node_range: 271..303,\n+                        navigation_range: 314..316,\n+                        node_range: 301..333,\n                         kind: SymbolKind(\n                             Macro,\n                         ),\n@@ -493,8 +518,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"mcexp\",\n-                        navigation_range: 334..339,\n-                        node_range: 305..356,\n+                        navigation_range: 364..369,\n+                        node_range: 335..386,\n                         kind: SymbolKind(\n                             Macro,\n                         ),\n@@ -504,8 +529,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"mcexp\",\n-                        navigation_range: 387..392,\n-                        node_range: 358..409,\n+                        navigation_range: 417..422,\n+                        node_range: 388..439,\n                         kind: SymbolKind(\n                             Macro,\n                         ),\n@@ -515,8 +540,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"obsolete\",\n-                        navigation_range: 428..436,\n-                        node_range: 411..441,\n+                        navigation_range: 458..466,\n+                        node_range: 441..471,\n                         kind: SymbolKind(\n                             Function,\n                         ),\n@@ -528,8 +553,8 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"very_obsolete\",\n-                        navigation_range: 481..494,\n-                        node_range: 443..499,\n+                        navigation_range: 511..524,\n+                        node_range: 473..529,\n                         kind: SymbolKind(\n                             Function,\n                         ),\n@@ -541,17 +566,17 @@ fn g() {}\n                     StructureNode {\n                         parent: None,\n                         label: \"Some region name\",\n-                        navigation_range: 501..528,\n-                        node_range: 501..528,\n+                        navigation_range: 531..558,\n+                        node_range: 531..558,\n                         kind: Region,\n                         detail: None,\n                         deprecated: false,\n                     },\n                     StructureNode {\n                         parent: None,\n                         label: \"m\",\n-                        navigation_range: 568..569,\n-                        node_range: 543..606,\n+                        navigation_range: 598..599,\n+                        node_range: 573..636,\n                         kind: SymbolKind(\n                             Module,\n                         ),\n@@ -560,22 +585,22 @@ fn g() {}\n                     },\n                     StructureNode {\n                         parent: Some(\n-                            20,\n+                            22,\n                         ),\n                         label: \"dontpanic\",\n-                        navigation_range: 543..563,\n-                        node_range: 543..563,\n+                        navigation_range: 573..593,\n+                        node_range: 573..593,\n                         kind: Region,\n                         detail: None,\n                         deprecated: false,\n                     },\n                     StructureNode {\n                         parent: Some(\n-                            20,\n+                            22,\n                         ),\n                         label: \"f\",\n-                        navigation_range: 575..576,\n-                        node_range: 572..581,\n+                        navigation_range: 605..606,\n+                        node_range: 602..611,\n                         kind: SymbolKind(\n                             Function,\n                         ),\n@@ -586,11 +611,11 @@ fn g() {}\n                     },\n                     StructureNode {\n                         parent: Some(\n-                            20,\n+                            22,\n                         ),\n                         label: \"g\",\n-                        navigation_range: 598..599,\n-                        node_range: 582..604,\n+                        navigation_range: 628..629,\n+                        node_range: 612..634,\n                         kind: SymbolKind(\n                             Function,\n                         ),"}, {"sha": "cf0819a2524b91418aa52a2b2f14ea8380eb44b3", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -764,6 +764,13 @@ trait Foo$0 { }\n \"#,\n         );\n \n+        check(\n+            r#\"\n+trait Foo$0 = ;\n+    //^^^\n+\"#,\n+        );\n+\n         check(\n             r#\"\n mod bar$0 { }\n@@ -1065,6 +1072,23 @@ fn f() -> impl Sub<Item$0 = u8> {}\n         );\n     }\n \n+    #[test]\n+    fn goto_def_for_module_declaration_in_path_if_types_and_values_same_name() {\n+        check(\n+            r#\"\n+mod bar {\n+    pub struct Foo {}\n+             //^^^\n+    pub fn Foo() {}\n+}\n+\n+fn baz() {\n+    let _foo_enum: bar::Foo$0 = bar::Foo {};\n+}\n+        \"#,\n+        )\n+    }\n+\n     #[test]\n     fn unknown_assoc_ty() {\n         check_unresolved(\n@@ -1406,7 +1430,6 @@ include!(\"included.rs$0\");\n         );\n     }\n \n-    #[cfg(test)]\n     mod goto_impl_of_trait_fn {\n         use super::check;\n         #[test]"}, {"sha": "d88ffd25c40fe008bf3cee63c2e15e15afba7583", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, T,\n };\n \n-use crate::{references, NavigationTarget, TryToNav};\n+use crate::{navigation_target::ToNav, references, NavigationTarget, TryToNav};\n \n #[derive(PartialEq, Eq, Hash)]\n pub struct HighlightedRange {\n@@ -98,32 +98,39 @@ fn highlight_references(\n             category: access,\n         });\n     let mut res = FxHashSet::default();\n-\n-    let mut def_to_hl_range = |def| {\n-        let hl_range = match def {\n-            Definition::Module(module) => {\n-                Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-            }\n-            def => def.try_to_nav(sema.db),\n-        }\n-        .filter(|decl| decl.file_id == file_id)\n-        .and_then(|decl| decl.focus_range)\n-        .map(|range| {\n-            let category =\n-                references::decl_mutability(&def, node, range).then_some(ReferenceCategory::Write);\n-            HighlightedRange { range, category }\n-        });\n-        if let Some(hl_range) = hl_range {\n-            res.insert(hl_range);\n-        }\n-    };\n     for &def in &defs {\n         match def {\n-            Definition::Local(local) => local\n-                .associated_locals(sema.db)\n-                .iter()\n-                .for_each(|&local| def_to_hl_range(Definition::Local(local))),\n-            def => def_to_hl_range(def),\n+            Definition::Local(local) => {\n+                let category = local.is_mut(sema.db).then_some(ReferenceCategory::Write);\n+                local\n+                    .sources(sema.db)\n+                    .into_iter()\n+                    .map(|x| x.to_nav(sema.db))\n+                    .filter(|decl| decl.file_id == file_id)\n+                    .filter_map(|decl| decl.focus_range)\n+                    .map(|range| HighlightedRange { range, category })\n+                    .for_each(|x| {\n+                        res.insert(x);\n+                    });\n+            }\n+            def => {\n+                let hl_range = match def {\n+                    Definition::Module(module) => {\n+                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                    }\n+                    def => def.try_to_nav(sema.db),\n+                }\n+                .filter(|decl| decl.file_id == file_id)\n+                .and_then(|decl| decl.focus_range)\n+                .map(|range| {\n+                    let category = references::decl_mutability(&def, node, range)\n+                        .then_some(ReferenceCategory::Write);\n+                    HighlightedRange { range, category }\n+                });\n+                if let Some(hl_range) = hl_range {\n+                    res.insert(hl_range);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "64b2221bdeab4cab2b3c5738a2e960f00c1f5b3e", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -30,6 +30,7 @@ pub struct HoverConfig {\n     pub documentation: bool,\n     pub keywords: bool,\n     pub format: HoverDocFormat,\n+    pub interpret_tests: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "da725ce502b8da62348946ab08242c6405de24f2", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -3,7 +3,8 @@ use std::fmt::Display;\n \n use either::Either;\n use hir::{\n-    Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo,\n+    db::DefDatabase, Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay,\n+    MirEvalError, Semantics, TypeInfo,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -402,25 +403,38 @@ pub(super) fn definition(\n             ))\n         }),\n         Definition::Module(it) => label_and_docs(db, it),\n-        Definition::Function(it) => label_and_docs(db, it),\n+        Definition::Function(it) => label_and_layout_info_and_docs(db, it, |_| {\n+            if !config.interpret_tests {\n+                return None;\n+            }\n+            match it.eval(db) {\n+                Ok(()) => Some(\"pass\".into()),\n+                Err(MirEvalError::Panic) => Some(\"fail\".into()),\n+                Err(MirEvalError::MirLowerError(f, e)) => {\n+                    let name = &db.function_data(f).name;\n+                    Some(format!(\"error: fail to lower {name} due {e:?}\"))\n+                }\n+                Err(e) => Some(format!(\"error: {e:?}\")),\n+            }\n+        }),\n         Definition::Adt(it) => label_and_layout_info_and_docs(db, it, |&it| {\n             let layout = it.layout(db).ok()?;\n             Some(format!(\"size = {}, align = {}\", layout.size.bytes(), layout.align.abi.bytes()))\n         }),\n         Definition::Variant(it) => label_value_and_docs(db, it, |&it| {\n             if !it.parent_enum(db).is_data_carrying(db) {\n                 match it.eval(db) {\n-                    Ok(x) => Some(format!(\"{x}\")),\n+                    Ok(x) => Some(if x >= 10 { format!(\"{x} ({x:#X})\") } else { format!(\"{x}\") }),\n                     Err(_) => it.value(db).map(|x| format!(\"{x:?}\")),\n                 }\n             } else {\n                 None\n             }\n         }),\n         Definition::Const(it) => label_value_and_docs(db, it, |it| {\n-            let body = it.eval(db);\n+            let body = it.render_eval(db);\n             match body {\n-                Ok(x) => Some(format!(\"{x}\")),\n+                Ok(x) => Some(x),\n                 Err(_) => {\n                     let source = it.source(db)?;\n                     let mut body = source.value.body()?.syntax().clone();\n@@ -440,6 +454,7 @@ pub(super) fn definition(\n             Some(body.to_string())\n         }),\n         Definition::Trait(it) => label_and_docs(db, it),\n+        Definition::TraitAlias(it) => label_and_docs(db, it),\n         Definition::TypeAlias(it) => label_and_docs(db, it),\n         Definition::BuiltinType(it) => {\n             return famous_defs\n@@ -620,8 +635,8 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n     let ty = it.ty(db);\n     let ty = ty.display_truncated(db, None);\n     let is_mut = if it.is_mut(db) { \"mut \" } else { \"\" };\n-    let desc = match it.source(db).value {\n-        Either::Left(ident) => {\n+    let desc = match it.primary_source(db).into_ident_pat() {\n+        Some(ident) => {\n             let name = it.name(db);\n             let let_kw = if ident\n                 .syntax()\n@@ -634,7 +649,7 @@ fn local(db: &RootDatabase, it: hir::Local) -> Option<Markup> {\n             };\n             format!(\"{let_kw}{is_mut}{name}: {ty}\")\n         }\n-        Either::Right(_) => format!(\"{is_mut}self: {ty}\"),\n+        None => format!(\"{is_mut}self: {ty}\"),\n     };\n     markup(None, desc, None)\n }"}, {"sha": "57bf0f9ad5f3cbd95370caf003ed7efcbff24c31", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 272, "deletions": 78, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -4,16 +4,19 @@ use syntax::TextRange;\n \n use crate::{fixture, HoverConfig, HoverDocFormat};\n \n+const HOVER_BASE_CONFIG: HoverConfig = HoverConfig {\n+    links_in_hover: false,\n+    documentation: true,\n+    format: HoverDocFormat::Markdown,\n+    keywords: true,\n+    interpret_tests: false,\n+};\n+\n fn check_hover_no_result(ra_fixture: &str) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap();\n@@ -25,12 +28,7 @@ fn check(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -47,12 +45,7 @@ fn check_hover_no_links(ra_fixture: &str, expect: Expect) {\n     let (analysis, position) = fixture::position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HOVER_BASE_CONFIG,\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n         .unwrap()\n@@ -71,9 +64,8 @@ fn check_hover_no_markdown(ra_fixture: &str, expect: Expect) {\n         .hover(\n             &HoverConfig {\n                 links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n                 format: HoverDocFormat::PlainText,\n+                ..HOVER_BASE_CONFIG\n             },\n             FileRange { file_id: position.file_id, range: TextRange::empty(position.offset) },\n         )\n@@ -91,12 +83,7 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n     let (analysis, file_id, position) = fixture::range_or_position(ra_fixture);\n     let hover = analysis\n         .hover(\n-            &HoverConfig {\n-                links_in_hover: true,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n+            &HoverConfig { links_in_hover: true, ..HOVER_BASE_CONFIG },\n             FileRange { file_id, range: position.range_or_empty() },\n         )\n         .unwrap()\n@@ -106,34 +93,13 @@ fn check_actions(ra_fixture: &str, expect: Expect) {\n \n fn check_hover_range(ra_fixture: &str, expect: Expect) {\n     let (analysis, range) = fixture::range(ra_fixture);\n-    let hover = analysis\n-        .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n-            range,\n-        )\n-        .unwrap()\n-        .unwrap();\n+    let hover = analysis.hover(&HOVER_BASE_CONFIG, range).unwrap().unwrap();\n     expect.assert_eq(hover.info.markup.as_str())\n }\n \n fn check_hover_range_no_results(ra_fixture: &str) {\n     let (analysis, range) = fixture::range(ra_fixture);\n-    let hover = analysis\n-        .hover(\n-            &HoverConfig {\n-                links_in_hover: false,\n-                documentation: true,\n-                keywords: true,\n-                format: HoverDocFormat::Markdown,\n-            },\n-            range,\n-        )\n-        .unwrap();\n+    let hover = analysis.hover(&HOVER_BASE_CONFIG, range).unwrap();\n     assert!(hover.is_none());\n }\n \n@@ -490,7 +456,6 @@ fn hover_field_offset() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { fiel$0d_a: u8, field_b: i32, field_c: i16 }\n \"#,\n         expect![[r#\"\n@@ -512,7 +477,6 @@ fn hover_shows_struct_field_info() {\n     // Hovering over the field when instantiating\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a: u32 }\n \n fn main() {\n@@ -535,7 +499,6 @@ fn main() {\n     // Hovering over the field in the definition\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n struct Foo { field_a$0: u32 }\n \n fn main() {\n@@ -610,6 +573,27 @@ const foo$0: u32 = {\n     );\n }\n \n+#[test]\n+fn hover_eval_complex_constants() {\n+    check(\n+        r#\"\n+        struct X { f1: (), f2: i32 }\n+        const foo$0: (i8, X, i64) = (1, X { f2: 5 - 1, f1: () }, 1 - 2);\n+        \"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const foo: (i8, X, i64) = (1, X { f1: (), f2: 4 }, -1)\n+            ```\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn hover_default_generic_types() {\n     check(\n@@ -1467,8 +1451,6 @@ fn my() {}\n fn test_hover_struct_doc_comment() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n /// This is an example\n /// multiline doc\n ///\n@@ -1527,7 +1509,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1556,7 +1538,7 @@ fn foo() { let bar = Ba$0r; }\n             ```\n \n             ```rust\n-            struct Bar\n+            struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1584,7 +1566,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -1611,7 +1593,7 @@ pub struct B$0ar\n             ```\n \n             ```rust\n-            pub struct Bar\n+            pub struct Bar // size = 0, align = 1\n             ```\n \n             ---\n@@ -2913,8 +2895,6 @@ fn main() { let foo_test = name_with_dashes::wrapper::Thing::new$0(); }\n fn hover_field_pat_shorthand_ref_match_ergonomics() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n struct S {\n     f: i32,\n }\n@@ -3506,8 +3486,8 @@ impl<const LEN: usize> Foo<LEN$0> {}\n }\n \n #[test]\n-fn hover_const_eval_variant() {\n-    // show hex for <10\n+fn hover_const_eval_discriminant() {\n+    // Don't show hex for <10\n     check(\n         r#\"\n #[repr(u8)]\n@@ -3532,7 +3512,7 @@ enum E {\n             This is a doc\n         \"#]],\n     );\n-    // show hex for >10\n+    // Show hex for >10\n     check(\n         r#\"\n #[repr(u8)]\n@@ -3656,7 +3636,7 @@ trait T {\n }\n impl T for i32 {\n     const AA: A = A {\n-        i: 2\n+        i: 2 + 3\n     }\n }\n fn main() {\n@@ -3671,9 +3651,7 @@ fn main() {\n         ```\n \n         ```rust\n-        const AA: A = A {\n-                i: 2\n-            }\n+        const AA: A = A { i: 5 }\n         ```\n     \"#]],\n     );\n@@ -3792,7 +3770,6 @@ const FOO$0: usize = 1 << 3;\n             This is a doc\n         \"#]],\n     );\n-    // show hex for >10\n     check(\n         r#\"\n /// This is a doc\n@@ -3850,7 +3827,7 @@ const FOO$0: i32 = 2 - 3;\n             ```\n \n             ```rust\n-            const FOO: i32 = -1\n+            const FOO: i32 = -1 (0xFFFFFFFF)\n             ```\n \n             ---\n@@ -4011,6 +3988,28 @@ const FOO$0: f32 = 1f32;\n             This is a doc\n         \"#]],\n     );\n+    // Don't show `<ref-not-supported>` in const hover\n+    check(\n+        r#\"\n+/// This is a doc\n+const FOO$0: &i32 = &2;\n+\"#,\n+        expect![[r#\"\n+            *FOO*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            const FOO: &i32 = &2\n+            ```\n+\n+            ---\n+\n+            This is a doc\n+        \"#]],\n+    );\n     //show f64 typecasted from float\n     check(\n         r#\"\n@@ -4354,8 +4353,6 @@ fn main() {\n fn hover_intra_doc_links() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n pub mod theitem {\n     /// This is the item. Cool!\n     pub struct TheItem;\n@@ -4496,7 +4493,7 @@ trait A where\n fn string_shadowed_with_inner_items() {\n     check(\n         r#\"\n-//- /main.rs crate:main deps:alloc target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n+//- /main.rs crate:main deps:alloc\n \n /// Custom `String` type.\n struct String;\n@@ -5191,7 +5188,7 @@ foo_macro!(\n             ```\n \n             ```rust\n-            pub struct Foo\n+            pub struct Foo // size = 0, align = 1\n             ```\n \n             ---\n@@ -5205,8 +5202,6 @@ foo_macro!(\n fn hover_intra_in_attr() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n #[doc = \"Doc comment for [`Foo$0`]\"]\n pub struct Foo(i32);\n \"#,\n@@ -5295,7 +5290,7 @@ pub struct Type;\n             ```\n \n             ```rust\n-            const KONST: dep::Type = $crate::Type\n+            const KONST: dep::Type = Type\n             ```\n         \"#]],\n     );\n@@ -5327,8 +5322,6 @@ enum Enum {\n fn hover_record_variant_field() {\n     check(\n         r#\"\n-//- /main.rs target_data_layout:e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\n-\n enum Enum {\n     RecordV { field$0: u32 }\n }\n@@ -5647,3 +5640,204 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn assoc_fn_in_block_local_impl() {\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) fn foo() {}\n+        }\n+    };\n+}\n+fn test() {\n+    S::foo$0();\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(crate) fn foo()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) fn foo() {}\n+            }\n+        };\n+    };\n+}\n+fn test() {\n+    S::foo$0();\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(crate) fn foo()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(super) fn foo() {}\n+            }\n+        };\n+    }\n+\n+    fn test() {\n+        crate::S::foo$0();\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(super) fn foo()\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn assoc_const_in_block_local_impl() {\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) const A: () = ();\n+        }\n+    };\n+}\n+fn test() {\n+    S::A$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(crate) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) const A: () = ();\n+            }\n+        };\n+    };\n+}\n+fn test() {\n+    S::A$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(crate) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(super) const A: () = ();\n+            }\n+        };\n+    }\n+\n+    fn test() {\n+        crate::S::A$0;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(super) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn field_as_method_call_fallback() {\n+    check(\n+        r#\"\n+struct S { f: u32 }\n+fn test() {\n+    S { f: 0 }.f$0();\n+}\n+\"#,\n+        expect![[r#\"\n+            *f*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            f: u32 // size = 4, align = 4, offset = 0\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "729780fa0c919903a1be2102cc02a70bc6920c78", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -606,14 +606,13 @@ fn a() {\n     }\n \n     #[test]\n-    fn bug() {\n+    fn let_stmt_explicit_ty() {\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\"\n fn main() {\n-    // These should be identical, but they are not...\n-\n     let () = return;\n+           //^^^^^^<never-to-any>\n     let (): () = return;\n                //^^^^^^<never-to-any>\n }"}, {"sha": "6a50927333d4f6b47433cbb701cb4b54145536f1", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 12, "deletions": 105, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -176,15 +176,12 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir\n mod tests {\n     // This module also contains tests for super::closure_ret\n \n-    use expect_test::expect;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n     use crate::{fixture, inlay_hints::InlayHintsConfig};\n \n-    use crate::inlay_hints::tests::{\n-        check, check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG,\n-    };\n+    use crate::inlay_hints::tests::{check, check_with_config, DISABLED_CONFIG, TEST_CONFIG};\n     use crate::ClosureReturnTypeHints;\n \n     #[track_caller]\n@@ -278,8 +275,7 @@ fn main() {\n     #[test]\n     fn iterator_hint_regression_issue_12674() {\n         // Ensure we don't crash while solving the projection type of iterators.\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+        let (analysis, file_id) = fixture::file(\n             r#\"\n //- minicore: iterators\n struct S<T>(T);\n@@ -302,107 +298,18 @@ impl<'a, T> Iterator for SliceIter<'a, T> {\n \n fn main(a: SliceIter<'_, Container>) {\n     a\n-    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n-    .map(|e| e);\n+        .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+        .map(|e| e);\n }\n-            \"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 484..554,\n-                        kind: Chaining,\n-                        label: [\n-                            \"impl \",\n-                            InlayHintLabelPart {\n-                                text: \"Iterator\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2611..2619,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Item\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2643..2647,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \" = impl \",\n-                            InlayHintLabelPart {\n-                                text: \"Iterator\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2611..2619,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Item\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2643..2647,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \" = &&str>>\",\n-                        ],\n-                    },\n-                    InlayHint {\n-                        range: 484..485,\n-                        kind: Chaining,\n-                        label: [\n-                            \"\",\n-                            InlayHintLabelPart {\n-                                text: \"SliceIter\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            0,\n-                                        ),\n-                                        range: 289..298,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Container\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            0,\n-                                        ),\n-                                        range: 238..247,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \">\",\n-                        ],\n-                    },\n-                ]\n-            \"#]],\n+\"#,\n         );\n+        analysis\n+            .inlay_hints(\n+                &InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+                file_id,\n+                None,\n+            )\n+            .unwrap();\n     }\n \n     #[test]"}, {"sha": "0a7513e465a57766be3db556ad41512d61ed4746", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "67eaa553ada4eb79f771466f3e8145f4d3280de1", "filename": "crates/ide/src/inlay_hints/discriminant.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fdiscriminant.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -59,8 +59,14 @@ fn variant_hints(\n         },\n         kind: InlayKind::Discriminant,\n         label: InlayHintLabel::simple(\n-            match &d {\n-                Ok(v) => format!(\"{}\", v),\n+            match d {\n+                Ok(x) => {\n+                    if x >= 10 {\n+                        format!(\"{x} ({x:#X})\")\n+                    } else {\n+                        format!(\"{x}\")\n+                    }\n+                }\n                 Err(_) => \"?\".into(),\n             },\n             Some(InlayTooltip::String(match &d {"}, {"sha": "078b66dd3955f2fd4604ca81dcba912e44bb918f", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -55,6 +55,7 @@ mod syntax_tree;\n mod typing;\n mod view_crate_graph;\n mod view_hir;\n+mod view_mir;\n mod view_item_tree;\n mod shuffle_crate_graph;\n \n@@ -308,6 +309,10 @@ impl Analysis {\n         self.with_db(|db| view_hir::view_hir(db, position))\n     }\n \n+    pub fn view_mir(&self, position: FilePosition) -> Cancellable<String> {\n+        self.with_db(|db| view_mir::view_mir(db, position))\n+    }\n+\n     pub fn view_item_tree(&self, file_id: FileId) -> Cancellable<String> {\n         self.with_db(|db| view_item_tree::view_item_tree(db, file_id))\n     }"}, {"sha": "411eb695fbf2752c6a443f73c19f7e15534262aa", "filename": "crates/ide/src/markup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmarkup.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -32,7 +32,7 @@ impl Markup {\n     pub fn as_str(&self) -> &str {\n         self.text.as_str()\n     }\n-    pub fn fenced_block(contents: &impl fmt::Display) -> Markup {\n+    pub fn fenced_block(contents: impl fmt::Display) -> Markup {\n         format!(\"```rust\\n{contents}\\n```\").into()\n     }\n }"}, {"sha": "349e79ecfdda078eb746954204dcf95e4ec072e7", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -208,6 +208,9 @@ pub(crate) fn def_to_moniker(\n         Definition::Trait(trait_) => {\n             MonikerDescriptor { name: trait_.name(db), desc: MonikerDescriptorKind::Type }\n         }\n+        Definition::TraitAlias(ta) => {\n+            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n         Definition::TypeAlias(ta) => {\n             MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::TypeParameter }\n         }"}, {"sha": "b955ea99f0c04618c4b3108840b507835d74122f", "filename": "crates/ide/src/move_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmove_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fmove_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmove_item.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -73,6 +73,7 @@ fn find_ancestors(item: SyntaxElement, direction: Direction, range: TextRange) -\n         SyntaxKind::MACRO_CALL,\n         SyntaxKind::TYPE_ALIAS,\n         SyntaxKind::TRAIT,\n+        SyntaxKind::TRAIT_ALIAS,\n         SyntaxKind::IMPL,\n         SyntaxKind::MACRO_DEF,\n         SyntaxKind::STRUCT,"}, {"sha": "6aae82f98160025169032477e7ad1a648697960e", "filename": "crates/ide/src/navigation_target.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fnavigation_target.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use either::Either;\n use hir::{\n     symbols::FileSymbol, AssocItem, Documentation, FieldSource, HasAttrs, HasSource, HirDisplay,\n-    InFile, ModuleSource, Semantics,\n+    InFile, LocalSource, ModuleSource, Semantics,\n };\n use ide_db::{\n     base_db::{FileId, FileRange},\n@@ -192,6 +192,7 @@ impl TryToNav for Definition {\n             Definition::Const(it) => it.try_to_nav(db),\n             Definition::Static(it) => it.try_to_nav(db),\n             Definition::Trait(it) => it.try_to_nav(db),\n+            Definition::TraitAlias(it) => it.try_to_nav(db),\n             Definition::TypeAlias(it) => it.try_to_nav(db),\n             Definition::BuiltinType(_) => None,\n             Definition::ToolModule(_) => None,\n@@ -212,6 +213,7 @@ impl TryToNav for hir::ModuleDef {\n             hir::ModuleDef::Const(it) => it.try_to_nav(db),\n             hir::ModuleDef::Static(it) => it.try_to_nav(db),\n             hir::ModuleDef::Trait(it) => it.try_to_nav(db),\n+            hir::ModuleDef::TraitAlias(it) => it.try_to_nav(db),\n             hir::ModuleDef::TypeAlias(it) => it.try_to_nav(db),\n             hir::ModuleDef::Macro(it) => it.try_to_nav(db),\n             hir::ModuleDef::BuiltinType(_) => None,\n@@ -249,6 +251,9 @@ impl ToNavFromAst for hir::TypeAlias {\n impl ToNavFromAst for hir::Trait {\n     const KIND: SymbolKind = SymbolKind::Trait;\n }\n+impl ToNavFromAst for hir::TraitAlias {\n+    const KIND: SymbolKind = SymbolKind::TraitAlias;\n+}\n \n impl<D> TryToNav for D\n where\n@@ -382,9 +387,11 @@ impl TryToNav for hir::GenericParam {\n     }\n }\n \n-impl ToNav for hir::Local {\n+impl ToNav for LocalSource {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n-        let InFile { file_id, value } = self.source(db);\n+        let InFile { file_id, value } = &self.source;\n+        let file_id = *file_id;\n+        let local = self.local;\n         let (node, name) = match &value {\n             Either::Left(bind_pat) => (bind_pat.syntax(), bind_pat.name()),\n             Either::Right(it) => (it.syntax(), it.name()),\n@@ -393,10 +400,10 @@ impl ToNav for hir::Local {\n         let FileRange { file_id, range: full_range } =\n             InFile::new(file_id, node).original_file_range(db);\n \n-        let name = self.name(db).to_smol_str();\n-        let kind = if self.is_self(db) {\n+        let name = local.name(db).to_smol_str();\n+        let kind = if local.is_self(db) {\n             SymbolKind::SelfParam\n-        } else if self.is_param(db) {\n+        } else if local.is_param(db) {\n             SymbolKind::ValueParam\n         } else {\n             SymbolKind::Local\n@@ -414,6 +421,12 @@ impl ToNav for hir::Local {\n     }\n }\n \n+impl ToNav for hir::Local {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        self.primary_source(db).to_nav(db)\n+    }\n+}\n+\n impl ToNav for hir::Label {\n     fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n         let InFile { file_id, value } = self.source(db);\n@@ -544,6 +557,7 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n             ast::Struct(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n             ast::Enum(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n             ast::Trait(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n+            ast::TraitAlias(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n             ast::Module(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n             ast::TypeAlias(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),\n             ast::Const(it) => sema.to_def(&it).map(|it| it.display(db).to_string()),"}, {"sha": "3684c1033f32fa7e8faf8d153e633ebb5cdf58aa", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -1355,6 +1355,38 @@ impl Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_trait_alias() {\n+        check(\n+            r#\"\n+trait Foo {}\n+trait Bar$0 = Foo where Self: ;\n+fn foo<T: Bar>(_: impl Bar, _: &dyn Bar) {}\n+\"#,\n+            expect![[r#\"\n+                Bar TraitAlias FileId(0) 13..42 19..22\n+\n+                FileId(0) 53..56\n+                FileId(0) 66..69\n+                FileId(0) 79..82\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_trait_alias_self() {\n+        check(\n+            r#\"\n+trait Foo = where Self$0: ;\n+\"#,\n+            expect![[r#\"\n+                Self TypeParam FileId(0) 6..9 6..9\n+\n+                FileId(0) 18..22\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_attr_differs_from_fn_with_same_name() {\n         check("}, {"sha": "e10c463810220e4d8970086cf2432dcdd7863d94", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -353,6 +353,11 @@ mod tests {\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);\n+        if !ra_fixture_after.starts_with(\"error: \") {\n+            if let Err(err) = analysis.prepare_rename(position).unwrap() {\n+                panic!(\"Prepare rename to '{new_name}' was failed: {err}\")\n+            }\n+        }\n         let rename_result = analysis\n             .rename(position, new_name)\n             .unwrap_or_else(|err| panic!(\"Rename to '{new_name}' was cancelled: {err}\"));\n@@ -1709,6 +1714,23 @@ fn foo(bar: i32) -> Foo {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_local_simple() {\n+        check(\n+            \"i\",\n+            r#\"\n+fn foo(bar$0: i32) -> i32 {\n+    bar\n+}\n+\"#,\n+            r#\"\n+fn foo(i: i32) -> i32 {\n+    i\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_local_put_init_shorthand() {\n         cov_mark::check!(test_rename_local_put_init_shorthand);"}, {"sha": "8a8a9151c425729a62c8554266bc0aae0df6f57f", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 277, "deletions": 13, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n \n use ast::HasName;\n use cfg::CfgExpr;\n-use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n@@ -195,14 +195,13 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n //\n // Provides a sneak peek of all tests where the current item is used.\n //\n-// The simplest way to use this feature is via the context menu:\n-//  - Right-click on the selected item. The context menu opens.\n-//  - Select **Peek related tests**\n+// The simplest way to use this feature is via the context menu. Right-click on\n+// the selected item. The context menu opens. Select **Peek Related Tests**.\n //\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **rust-analyzer: Peek related tests**\n+// | VS Code | **rust-analyzer: Peek Related Tests**\n // |===\n pub(crate) fn related_tests(\n     db: &RootDatabase,\n@@ -371,9 +370,9 @@ pub(crate) fn runnable_impl(\n     let nav = def.try_to_nav(sema.db)?;\n     let ty = def.self_ty(sema.db);\n     let adt_name = ty.as_adt()?.name(sema.db);\n-    let mut ty_args = ty.type_arguments().peekable();\n+    let mut ty_args = ty.generic_parameters(sema.db).peekable();\n     let params = if ty_args.peek().is_some() {\n-        format!(\"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty.display(sema.db))))\n+        format!(\"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty)))\n     } else {\n         String::new()\n     };\n@@ -417,6 +416,7 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n         Definition::Const(it) => it.attrs(db),\n         Definition::Static(it) => it.attrs(db),\n         Definition::Trait(it) => it.attrs(db),\n+        Definition::TraitAlias(it) => it.attrs(db),\n         Definition::TypeAlias(it) => it.attrs(db),\n         Definition::Macro(it) => it.attrs(db),\n         Definition::SelfType(it) => it.attrs(db),\n@@ -437,14 +437,10 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n                 let ty = imp.self_ty(db);\n                 if let Some(adt) = ty.as_adt() {\n                     let name = adt.name(db);\n-                    let mut ty_args = ty.type_arguments().peekable();\n+                    let mut ty_args = ty.generic_parameters(db).peekable();\n                     format_to!(path, \"{}\", name);\n                     if ty_args.peek().is_some() {\n-                        format_to!(\n-                            path,\n-                            \"<{}>\",\n-                            ty_args.format_with(\",\", |ty, cb| cb(&ty.display(db)))\n-                        );\n+                        format_to!(path, \"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty)));\n                     }\n                     format_to!(path, \"::{}\", def_name);\n                     path.retain(|c| c != ' ');\n@@ -1000,6 +996,221 @@ impl Data {\n         );\n     }\n \n+    #[test]\n+    fn test_runnables_doc_test_in_impl_with_lifetime() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+fn main() {}\n+\n+struct Data<'a>;\n+impl Data<'a> {\n+    /// ```\n+    /// let x = 5;\n+    /// ```\n+    fn foo() {}\n+}\n+\"#,\n+            &[Bin, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..13,\n+                            focus_range: 4..8,\n+                            name: \"main\",\n+                            kind: Function,\n+                        },\n+                        kind: Bin,\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 52..106,\n+                            name: \"foo\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Data<'a>::foo\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_runnables_doc_test_in_impl_with_lifetime_and_types() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+fn main() {}\n+\n+struct Data<'a, T, U>;\n+impl<T, U> Data<'a, T, U> {\n+    /// ```\n+    /// let x = 5;\n+    /// ```\n+    fn foo() {}\n+}\n+\"#,\n+            &[Bin, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..13,\n+                            focus_range: 4..8,\n+                            name: \"main\",\n+                            kind: Function,\n+                        },\n+                        kind: Bin,\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 70..124,\n+                            name: \"foo\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Data<'a,T,U>::foo\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_runnables_doc_test_in_impl_with_const() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+fn main() {}\n+\n+struct Data<const N: usize>;\n+impl<const N: usize> Data<N> {\n+    /// ```\n+    /// let x = 5;\n+    /// ```\n+    fn foo() {}\n+}\n+\"#,\n+            &[Bin, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..13,\n+                            focus_range: 4..8,\n+                            name: \"main\",\n+                            kind: Function,\n+                        },\n+                        kind: Bin,\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 79..133,\n+                            name: \"foo\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Data<N>::foo\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_runnables_doc_test_in_impl_with_lifetime_types_and_const() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+fn main() {}\n+\n+struct Data<'a, T, const N: usize>;\n+impl<'a, T, const N: usize> Data<'a, T, N> {\n+    /// ```\n+    /// let x = 5;\n+    /// ```\n+    fn foo() {}\n+}\n+\"#,\n+            &[Bin, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..13,\n+                            focus_range: 4..8,\n+                            name: \"main\",\n+                            kind: Function,\n+                        },\n+                        kind: Bin,\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 100..154,\n+                            name: \"foo\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Data<'a,T,N>::foo\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n     #[test]\n     fn test_runnables_module() {\n         check(\n@@ -2062,6 +2273,59 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_runnables_doc_test_in_impl_with_lifetime_type_const_value() {\n+        check(\n+            r#\"\n+//- /lib.rs\n+$0\n+fn main() {}\n+\n+struct Data<'a, A, const B: usize, C, const D: u32>;\n+impl<A, C, const D: u32> Data<'a, A, 12, C, D> {\n+    /// ```\n+    /// ```\n+    fn foo() {}\n+}\n+\"#,\n+            &[Bin, DocTest],\n+            expect![[r#\"\n+                [\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 1..13,\n+                            focus_range: 4..8,\n+                            name: \"main\",\n+                            kind: Function,\n+                        },\n+                        kind: Bin,\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 121..156,\n+                            name: \"foo\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Data<'a,A,12,C,D>::foo\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn doc_test_type_params() {\n         check("}, {"sha": "2c08c457b338c513281f4291dbaf63e1bccaa5ba", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -172,7 +172,7 @@ fn signature_help_for_call(\n \n     res.signature.push('(');\n     {\n-        if let Some(self_param) = callable.receiver_param(db) {\n+        if let Some((self_param, _)) = callable.receiver_param(db) {\n             format_to!(res.signature, \"{}\", self_param)\n         }\n         let mut buf = String::new();\n@@ -252,6 +252,10 @@ fn signature_help_for_generics(\n             res.doc = it.docs(db).map(|it| it.into());\n             format_to!(res.signature, \"trait {}\", it.name(db));\n         }\n+        hir::GenericDef::TraitAlias(it) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"trait {}\", it.name(db));\n+        }\n         hir::GenericDef::TypeAlias(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n             format_to!(res.signature, \"type {}\", it.name(db));"}, {"sha": "c97691b14a57f1848f2043686d83c3cc851a80f1", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -139,6 +139,7 @@ impl StaticIndex<'_> {\n             documentation: true,\n             keywords: true,\n             format: crate::HoverDocFormat::Markdown,\n+            interpret_tests: false,\n         };\n         let tokens = tokens.filter(|token| {\n             matches!("}, {"sha": "2111baad74d74ecaf9fe910916b56dd449f250d3", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -217,7 +217,9 @@ fn highlight_name_ref(\n         // to anything when used.\n         // We can fix this for derive attributes since derive helpers are recorded, but not for\n         // general attributes.\n-        None if name_ref.syntax().ancestors().any(|it| it.kind() == ATTR) => {\n+        None if name_ref.syntax().ancestors().any(|it| it.kind() == ATTR)\n+            && !sema.hir_file_for(name_ref.syntax()).is_derive_attr_pseudo_expansion(sema.db) =>\n+        {\n             return HlTag::Symbol(SymbolKind::Attribute).into();\n         }\n         None => return HlTag::UnresolvedReference.into(),\n@@ -410,6 +412,7 @@ fn highlight_def(\n             h\n         }\n         Definition::Trait(_) => Highlight::new(HlTag::Symbol(SymbolKind::Trait)),\n+        Definition::TraitAlias(_) => Highlight::new(HlTag::Symbol(SymbolKind::TraitAlias)),\n         Definition::TypeAlias(type_) => {\n             let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n "}, {"sha": "3c4cfc78152ddd4e22222b1d9d580c6d0cc4bb47", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -274,6 +274,7 @@ fn module_def_to_hl_tag(def: Definition) -> HlTag {\n         Definition::Const(_) => SymbolKind::Const,\n         Definition::Static(_) => SymbolKind::Static,\n         Definition::Trait(_) => SymbolKind::Trait,\n+        Definition::TraitAlias(_) => SymbolKind::TraitAlias,\n         Definition::TypeAlias(_) => SymbolKind::TypeAlias,\n         Definition::BuiltinType(_) => return HlTag::BuiltinType,\n         Definition::Macro(_) => SymbolKind::Macro,"}, {"sha": "a81c4ee0cbd417b1d777374914cd2a5c14c31b13", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -150,6 +150,7 @@ impl HlTag {\n                 SymbolKind::Struct => \"struct\",\n                 SymbolKind::ToolModule => \"tool_module\",\n                 SymbolKind::Trait => \"trait\",\n+                SymbolKind::TraitAlias => \"trait_alias\",\n                 SymbolKind::TypeAlias => \"type_alias\",\n                 SymbolKind::TypeParam => \"type_param\",\n                 SymbolKind::Union => \"union\","}, {"sha": "567ab8ccc11df227f9485f14f51c40e99de293ce", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_attributes.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_attributes.html", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_attributes.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_attributes.html?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -53,6 +53,6 @@\n <span class=\"comment\">// This is another normal comment</span>\n <span class=\"comment documentation\">/// This is another doc comment</span>\n <span class=\"comment\">// This is another normal comment</span>\n-<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"attribute attribute default_library library\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"derive attribute default_library library\">Copy</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n+<span class=\"attribute_bracket attribute\">#</span><span class=\"attribute_bracket attribute\">[</span><span class=\"attribute attribute default_library library\">derive</span><span class=\"parenthesis attribute\">(</span><span class=\"derive attribute default_library library\">Copy</span><span class=\"comma attribute\">,</span> <span class=\"unresolved_reference attribute\">Unresolved</span><span class=\"parenthesis attribute\">)</span><span class=\"attribute_bracket attribute\">]</span>\n <span class=\"comment\">// The reason for these being here is to test AttrIds</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span><span class=\"semicolon\">;</span></code></pre>\n\\ No newline at end of file"}, {"sha": "ac9bd8e39dc02f54bb0005a24aacc06ba8e4ec4a", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -34,7 +34,7 @@ fn attributes() {\n // This is another normal comment\n /// This is another doc comment\n // This is another normal comment\n-#[derive(Copy)]\n+#[derive(Copy, Unresolved)]\n // The reason for these being here is to test AttrIds\n struct Foo;\n \"#,"}, {"sha": "a36aba58bc0ed81e9a89a30578acf31fac4ee473", "filename": "crates/ide/src/view_mir.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fview_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fide%2Fsrc%2Fview_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_mir.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,29 @@\n+use hir::{DefWithBody, Semantics};\n+use ide_db::base_db::FilePosition;\n+use ide_db::RootDatabase;\n+use syntax::{algo::find_node_at_offset, ast, AstNode};\n+\n+// Feature: View Mir\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **rust-analyzer: View Mir**\n+// |===\n+pub(crate) fn view_mir(db: &RootDatabase, position: FilePosition) -> String {\n+    body_mir(db, position).unwrap_or_else(|| \"Not inside a function body\".to_string())\n+}\n+\n+fn body_mir(db: &RootDatabase, position: FilePosition) -> Option<String> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def: DefWithBody = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Const(it) => sema.to_def(&it)?.into(),\n+        ast::Item::Static(it) => sema.to_def(&it)?.into(),\n+        _ => return None,\n+    };\n+    Some(def.debug_mir(db))\n+}"}, {"sha": "15435a26cea98c0b02c03159c982b8c5a6bc7b8d", "filename": "crates/parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -198,6 +198,10 @@ impl BlockLike {\n     fn is_block(self) -> bool {\n         self == BlockLike::Block\n     }\n+\n+    fn is_blocklike(kind: SyntaxKind) -> bool {\n+        matches!(kind, BLOCK_EXPR | IF_EXPR | WHILE_EXPR | FOR_EXPR | LOOP_EXPR | MATCH_EXPR)\n+    }\n }\n \n const VISIBILITY_FIRST: TokenSet = TokenSet::new(&[T![pub], T![crate]]);"}, {"sha": "c13a1943792c1e9a44064df3dabaa365fc3d0f33", "filename": "crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -43,7 +43,7 @@ pub(super) fn meta(p: &mut Parser<'_>) {\n     match p.current() {\n         T![=] => {\n             p.bump(T![=]);\n-            if !expressions::expr(p) {\n+            if expressions::expr(p).is_none() {\n                 p.error(\"expected expression\");\n             }\n         }"}, {"sha": "a884d8b6ec801e3e89fb9349e11db7216617c468", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -16,9 +16,9 @@ pub(super) enum Semicolon {\n \n const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n-pub(super) fn expr(p: &mut Parser<'_>) -> bool {\n+pub(super) fn expr(p: &mut Parser<'_>) -> Option<CompletedMarker> {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n-    expr_bp(p, None, r, 1).is_some()\n+    expr_bp(p, None, r, 1).map(|(m, _)| m)\n }\n \n pub(super) fn expr_stmt(\n@@ -120,16 +120,27 @@ pub(super) fn stmt(p: &mut Parser<'_>, semicolon: Semicolon) {\n             // fn f() { let x: i32; }\n             types::ascription(p);\n         }\n+\n+        let mut expr_after_eq: Option<CompletedMarker> = None;\n         if p.eat(T![=]) {\n             // test let_stmt_init\n             // fn f() { let x = 92; }\n-            expressions::expr(p);\n+            expr_after_eq = expressions::expr(p);\n         }\n \n         if p.at(T![else]) {\n+            // test_err let_else_right_curly_brace\n+            // fn func() { let Some(_) = {Some(1)} else { panic!(\"h\") };}\n+            if let Some(expr) = expr_after_eq {\n+                if BlockLike::is_blocklike(expr.kind()) {\n+                    p.error(\n+                        \"right curly brace `}` before `else` in a `let...else` statement not allowed\",\n+                    )\n+                }\n+            }\n+\n             // test let_else\n             // fn f() { let Some(x) = opt else { return }; }\n-\n             let m = p.start();\n             p.bump(T![else]);\n             block_expr(p);\n@@ -578,7 +589,14 @@ fn arg_list(p: &mut Parser<'_>) {\n     // fn main() {\n     //     foo(#[attr] 92)\n     // }\n-    delimited(p, T!['('], T![')'], T![,], EXPR_FIRST.union(ATTRIBUTE_FIRST), expr);\n+    delimited(\n+        p,\n+        T!['('],\n+        T![')'],\n+        T![,],\n+        EXPR_FIRST.union(ATTRIBUTE_FIRST),\n+        |p: &mut Parser<'_>| expr(p).is_some(),\n+    );\n     m.complete(p, ARG_LIST);\n }\n "}, {"sha": "d051dd2682f942c6318dcaaaa633ad2b13e10d93", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -163,10 +163,8 @@ pub(super) fn atom_expr(\n             return None;\n         }\n     };\n-    let blocklike = match done.kind() {\n-        IF_EXPR | WHILE_EXPR | FOR_EXPR | LOOP_EXPR | MATCH_EXPR | BLOCK_EXPR => BlockLike::Block,\n-        _ => BlockLike::NotBlock,\n-    };\n+    let blocklike =\n+        if BlockLike::is_blocklike(done.kind()) { BlockLike::Block } else { BlockLike::NotBlock };\n     Some((done, blocklike))\n }\n \n@@ -188,7 +186,7 @@ fn tuple_expr(p: &mut Parser<'_>) -> CompletedMarker {\n \n         // test tuple_attrs\n         // const A: (i64, i64) = (1, #[cfg(test)] 2);\n-        if !expr(p) {\n+        if expr(p).is_none() {\n             break;\n         }\n \n@@ -221,7 +219,7 @@ fn array_expr(p: &mut Parser<'_>) -> CompletedMarker {\n \n         // test array_attrs\n         // const A: &[i64] = &[1, #[cfg(test)] 2];\n-        if !expr(p) {\n+        if expr(p).is_none() {\n             break;\n         }\n "}, {"sha": "a8a1ccb15e6c21cc14134a4ac59fdc2d34407e76", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -20,7 +20,7 @@ pub(super) fn trait_(p: &mut Parser<'_>, m: Marker) {\n         // trait Z<U> = where Self: T<U>;\n         generic_params::opt_where_clause(p);\n         p.expect(T![;]);\n-        m.complete(p, TRAIT);\n+        m.complete(p, TRAIT_ALIAS);\n         return;\n     }\n "}, {"sha": "26490aa97e0a0a2e46829c1590fb6d63e104adbe", "filename": "crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -77,6 +77,9 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n     // type X = <A as B>::Output;\n     // fn foo() { <usize as Default>::default(); }\n     if first && p.eat(T![<]) {\n+        // test_err angled_path_without_qual\n+        // type X = <()>;\n+        // type Y = <A as B>;\n         types::type_(p);\n         if p.eat(T![as]) {\n             if is_use_path_start(p) {\n@@ -86,6 +89,9 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n             }\n         }\n         p.expect(T![>]);\n+        if !p.at(T![::]) {\n+            p.error(\"expected `::`\");\n+        }\n     } else {\n         let empty = if first {\n             p.eat(T![::]);"}, {"sha": "cd87b304a2fb3e5ae894b3a998274919451a3650", "filename": "crates/parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -135,6 +135,7 @@ pub enum SyntaxKind {\n     STATIC,\n     CONST,\n     TRAIT,\n+    TRAIT_ALIAS,\n     IMPL,\n     TYPE_ALIAS,\n     MACRO_CALL,"}, {"sha": "026fecf4c9d53d04d18f4361e3703cace79e4d16", "filename": "crates/parser/test_data/parser/err/0049_let_else_right_curly_brace_for.rast", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15", "patch": "@@ -0,0 +1,58 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"f\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          WILDCARD_PAT\n+            UNDERSCORE \"_\"\n+          WHITESPACE \" \"\n+          EQ \"=\"\n+          WHITESPACE \" \"\n+          FOR_EXPR\n+            FOR_KW \"for\"\n+            WHITESPACE \" \"\n+            WILDCARD_PAT\n+              UNDERSCORE \"_\"\n+            WHITESPACE \" \"\n+            IN_KW \"in\"\n+            WHITESPACE \" \"\n+            RANGE_EXPR\n+              LITERAL\n+                INT_NUMBER \"0\"\n+              DOT2 \"..\"\n+              LITERAL\n+                INT_NUMBER \"10\"\n+            WHITESPACE \" \"\n+            BLOCK_EXPR\n+              STMT_LIST\n+                L_CURLY \"{\"\n+                WHITESPACE \"\\n    \"\n+                R_CURLY \"}\"\n+          WHITESPACE \" \"\n+          LET_ELSE\n+            ELSE_KW \"else\"\n+            WHITESPACE \" \"\n+            BLOCK_EXPR\n+              STMT_LIST\n+                L_CURLY \"{\"\n+                WHITESPACE \"\\n        \"\n+                RETURN_EXPR\n+                  RETURN_KW \"return\"\n+                WHITESPACE \"\\n    \"\n+                R_CURLY \"}\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+error 43: right curly brace `}` before `else` in a `let...else` statement not allowed"}, {"sha": "d410274198d1d492e0b4ffd8c23a2feb7b141957", "filename": "crates/parser/test_data/parser/err/0049_let_else_right_curly_brace_for.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0049_let_else_right_curly_brace_for.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "102321954130d2d3c49a1bfe73fd75f73d9fcd97", "filename": "crates/parser/test_data/parser/err/0050_let_else_right_curly_brace_loop.rast", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "28b892869a18e7692a27d647df288f83f0bd937e", "filename": "crates/parser/test_data/parser/err/0050_let_else_right_curly_brace_loop.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0050_let_else_right_curly_brace_loop.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "6e1181246c06381d2fbd715956324af493397e02", "filename": "crates/parser/test_data/parser/err/0051_let_else_right_curly_brace_match.rast", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "902d70daed52c2f362c2bae3f332f2d091a0638a", "filename": "crates/parser/test_data/parser/err/0051_let_else_right_curly_brace_match.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0051_let_else_right_curly_brace_match.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "298d47d5394b3b247b8beb7bbf3ab7f27087e2d9", "filename": "crates/parser/test_data/parser/err/0052_let_else_right_curly_brace_while.rast", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "a52343d8e6f456a2311942df62df96744b6e795f", "filename": "crates/parser/test_data/parser/err/0052_let_else_right_curly_brace_while.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0052_let_else_right_curly_brace_while.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "c0a4b0400d89dd0663cd741063ec71053314fb97", "filename": "crates/parser/test_data/parser/err/0053_let_else_right_curly_brace_if.rast", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "9a87aecbd4137e71106cb7f43495c54c2aa3337e", "filename": "crates/parser/test_data/parser/err/0053_let_else_right_curly_brace_if.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0053_let_else_right_curly_brace_if.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "0529e9750e7f03af3221382ba6009cf480b9a72c", "filename": "crates/parser/test_data/parser/inline/err/0016_angled_path_without_qual.rast", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "802d6cc14a49aa41bf331cb62444803ae3229495", "filename": "crates/parser/test_data/parser/inline/err/0016_angled_path_without_qual.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0016_angled_path_without_qual.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "6ec580212b4f5e6033434e7589875261f44457ae", "filename": "crates/parser/test_data/parser/inline/err/0017_let_else_right_curly_brace.rast", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "30d52fea3b28385a780245ebe52b750d875463ca", "filename": "crates/parser/test_data/parser/inline/err/0017_let_else_right_curly_brace.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0017_let_else_right_curly_brace.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "c45f870898007e52fae3631cc054f55a360c0bc5", "filename": "crates/parser/test_data/parser/inline/ok/0151_trait_alias.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0151_trait_alias.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0151_trait_alias.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0151_trait_alias.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "8f678247731dc3ed6b57660e631db4ec3380c4b0", "filename": "crates/parser/test_data/parser/inline/ok/0177_trait_alias_where_clause.rast", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0177_trait_alias_where_clause.rast", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0177_trait_alias_where_clause.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0177_trait_alias_where_clause.rast?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "6df1273edd65dc0e14c10f1abff4cca56d7fc72d", "filename": "crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 81, "deletions": 3, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "732adc50b5001182ffb9a3b37b8896b9f0730562", "filename": "crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "74e41eda7638497044b1cd4f1d8ce43230d053a7", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "749eee531eed1bcca44bf0e8fe5992edec3a48f0", "filename": "crates/project-model/src/tests.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Ftests.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "faa6816fdc203c95122310ce84cc9681b34b7c39", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "e49d7c144922d09aeca6dc5f31c8791b6c0939e2", "filename": "crates/rust-analyzer/default_12483297303756020505_0.profraw", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb/crates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "raw_url": "https://github.com/rust-lang/rust/raw/15b867b5db35d67e0f1026b55f22ba6b25ad6dcb/crates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw?ref=15b867b5db35d67e0f1026b55f22ba6b25ad6dcb"}, {"sha": "e8c10927d62c4db971187f841e183d638ee059a9", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 179, "deletions": 8, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "0721d486ef1f969182cc51b1c2a5637c1b04a6e0", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "9b5451496c6c5c0377a7b8a5ed39062b5a6c2c55", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "df5c26cf77a940685a8e3ab7c6e173a75192c3b6", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "35a874f89207ba974cdbf8b0b5e72fac919c2672", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "75233dbb2abec4a709dba3eeda9c91fbe1bc1fa2", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "32ac9a42dec33c99ca4905b94a3ccd9e4458868f", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "c7b513db981ea1607d23ae3ce9e8e54190fdb0b0", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "dd0804b4398a9599eeb21e146eb79f8f5536fdd2", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "28d37f5685ae9559e1aa1981ed7218d0e5a199d5", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "7d97b69f8ea053517e0cc692e71381bec579344d", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "305cf2d394b44586c0e67180963c1750956d09f2", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "548b5ba8b8b6d97797859e7616e74747e06b4657", "filename": "crates/syntax/rust.ungram", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Frust.ungram?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "1e691befff62a9cd12a4ba5313671b57078956ef", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "fe324845360d7b0ad95a3ff412628d74cf66fe73", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "15bd5ab3c7299e7921f0f1a27ccf813db436926c", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "3e43df2d0d52b57f5024c1133e71fd5ecb63187b", "filename": "crates/syntax/src/ast/traits.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftraits.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "ccce71966ff889455c8bb3e3184e38b382a140f6", "filename": "crates/syntax/src/tests/ast_src.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "e954b58251faaf5bac7664f3fd48dd1a57c26468", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "cd1235fa6dc4e04f1c5938ddba6292567c2b77ce", "filename": "crates/test-utils/src/fixture.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "93ff76a040c6d44eadd3384e8339d853bcc4715b", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "729f84a8150c58e2963161b56db3b8d0ef1f447c", "filename": "crates/toolchain/src/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftoolchain%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/crates%2Ftoolchain%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftoolchain%2Fsrc%2Flib.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "de1422032088f536ff065d068cd2a62a59dd9aad", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "6937a7ed9a2dddd518c059ffe6e542665600b0eb", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "a3b1a3107d0c94b681cbf8d5b81b8765c986b8b1", "filename": "editors/code/package.json", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "f4a4579a92c9b4d348a08f028f88bfb04024b546", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "1708d47cee77da95246ae2f8546470c8274b272e", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "400cd207d41b0a3a0541ddeaa015bdc1c5e78025", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "8a2412af849cd2e31a7932a95e0b202d8fa2753b", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "eb70b88871e3d1c5d970540205fe1d86bc725cf9", "filename": "editors/code/src/toolchain.ts", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/editors%2Fcode%2Fsrc%2Ftoolchain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Ftoolchain.ts?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}, {"sha": "7fff2b09c97b5e8effdf0e53ad004e39403e7555", "filename": "lib/la-arena/src/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/lib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15/lib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Fmap.rs?ref=b2f6fd4f961fc7e4fbfdb80cae2e6065f8436f15"}]}