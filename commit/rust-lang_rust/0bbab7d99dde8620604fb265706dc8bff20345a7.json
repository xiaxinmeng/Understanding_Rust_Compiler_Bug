{"sha": "0bbab7d99dde8620604fb265706dc8bff20345a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYmFiN2Q5OWRkZTg2MjA2MDRmYjI2NTcwNmRjOGJmZjIwMzQ1YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T02:33:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T02:33:15Z"}, "message": "Auto merge of #64470 - ecstatic-morse:split-promotion-and-validation, r=eddyb,oli-obk\n\nImplement dataflow-based const validation\n\nThis PR adds a separate, dataflow-enabled pass that checks the bodies of `const`s, `static`s and `const fn`s for [const safety](https://github.com/rust-rfcs/const-eval/blob/master/const.md). This is based on my work in #63860, which tried to integrate into the existing pass in [`qualify_consts.rs`](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs). However, the resulting pass was even more unwieldy than the original. Unlike its predecessor, this PR is designed to be combined with #63812 to replace the existing pass completely.\n\nThe new checker lives in [`librustc_mir/transform/check_consts`](https://github.com/ecstatic-morse/rust/tree/split-promotion-and-validation/src/librustc_mir/transform/check_consts).\n\n[`qualifs.rs`](https://github.com/ecstatic-morse/rust/blob/split-promotion-and-validation/src/librustc_mir/transform/check_consts/qualifs.rs) contains small modifications to the existing `Qualif` trait and its implementors, but is mostly unchanged except for the removal of `IsNotPromotable` and `IsNotImplicitlyPromotable`, which are only necessary for promotion.\n\n[`resolver.rs`](https://github.com/ecstatic-morse/rust/blob/split-promotion-and-validation/src/librustc_mir/transform/check_consts/resolver.rs) contains the dataflow analysis used to propagate qualifs between locals.\n\nFinally, [`validation.rs`](https://github.com/ecstatic-morse/rust/blob/split-promotion-and-validation/src/librustc_mir/transform/check_consts/validation.rs) contains a refactored version of the existing [`Visitor`](https://github.com/rust-lang/rust/blob/ca3766e2e58f462a20922e42c821a37eaf0e13db/src/librustc_mir/transform/qualify_consts.rs#L1024) in `qualfy_consts.rs`. All errors have been associated with a `struct` to make [comparison with the existing pass](https://github.com/ecstatic-morse/rust/blob/1c19f2d540ca0a964900449d79a5d5181b43146d/src/librustc_mir/transform/qualify_consts.rs#L1006) simple.\n\nThe existing validation logic in [`qualify_consts`](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/transform/qualify_consts.rs) has been modified to allow it to run in parallel with the new validator. If [`use_new_validator`](https://github.com/rust-lang/rust/pull/64470/files#diff-c2552a106550d05b69d5e07612f0f812R950) is not set, the old validation will be responsible for actually generating the errors, but those errors can be compared with the ones from the new validator.", "tree": {"sha": "3a0815f104740464713c6ba68615de8502d89819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a0815f104740464713c6ba68615de8502d89819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bbab7d99dde8620604fb265706dc8bff20345a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bbab7d99dde8620604fb265706dc8bff20345a7", "html_url": "https://github.com/rust-lang/rust/commit/0bbab7d99dde8620604fb265706dc8bff20345a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bbab7d99dde8620604fb265706dc8bff20345a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b61e69433951e31f7bd746e22f516a48ad41623b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b61e69433951e31f7bd746e22f516a48ad41623b", "html_url": "https://github.com/rust-lang/rust/commit/b61e69433951e31f7bd746e22f516a48ad41623b"}, {"sha": "0bf1a80b322f285efb9ea45b62e7dc764ebe1954", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bf1a80b322f285efb9ea45b62e7dc764ebe1954", "html_url": "https://github.com/rust-lang/rust/commit/0bf1a80b322f285efb9ea45b62e7dc764ebe1954"}], "stats": {"total": 2299, "additions": 2009, "deletions": 290}, "files": [{"sha": "7c97fd11af2a534eb0b0d48cf3e8e6f185d3bbdb", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1359,6 +1359,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"describes how to render the `rendered` field of json diagnostics\"),\n     unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n         \"take the breaks off const evaluation. NOTE: this is unsound\"),\n+    suppress_const_validation_back_compat_ice: bool = (false, parse_bool, [TRACKED],\n+        \"silence ICE triggered when the new const validator disagrees with the old\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],"}, {"sha": "7d20248ebd1f567cdad232410d926ee1cc7304dd", "filename": "src/librustc_mir/dataflow/impls/indirect_mutation.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Findirect_mutation.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,148 @@\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::{self, Local, Location};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::bit_set::BitSet;\n+use syntax_pos::DUMMY_SP;\n+\n+use crate::dataflow::{self, GenKillSet};\n+\n+/// Whether a borrow to a `Local` has been created that could allow that `Local` to be mutated\n+/// indirectly. This could either be a mutable reference (`&mut`) or a shared borrow if the type of\n+/// that `Local` allows interior mutability. Operations that can mutate local's indirectly include:\n+/// assignments through a pointer (`*p = 42`), function calls, drop terminators and inline assembly.\n+///\n+/// If this returns false for a `Local` at a given statement (or terminator), that `Local` could\n+/// not possibly have been mutated indirectly prior to that statement.\n+#[derive(Copy, Clone)]\n+pub struct IndirectlyMutableLocals<'mir, 'tcx> {\n+    body: &'mir mir::Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'mir, 'tcx> IndirectlyMutableLocals<'mir, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        IndirectlyMutableLocals { body, tcx, param_env }\n+    }\n+\n+    fn transfer_function<'a>(\n+        &self,\n+        trans: &'a mut GenKillSet<Local>,\n+    ) -> TransferFunction<'a, 'mir, 'tcx> {\n+        TransferFunction {\n+            body: self.body,\n+            tcx: self.tcx,\n+            param_env: self.param_env,\n+            trans\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> dataflow::BitDenotation<'tcx> for IndirectlyMutableLocals<'mir, 'tcx> {\n+    type Idx = Local;\n+\n+    fn name() -> &'static str { \"mut_borrowed_locals\" }\n+\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, _entry_set: &mut BitSet<Local>) {\n+        // Nothing is borrowed on function entry\n+    }\n+\n+    fn statement_effect(\n+        &self,\n+        trans: &mut GenKillSet<Local>,\n+        loc: Location,\n+    ) {\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+        self.transfer_function(trans).visit_statement(stmt, loc);\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut GenKillSet<Local>,\n+        loc: Location,\n+    ) {\n+        let terminator = self.body[loc.block].terminator();\n+        self.transfer_function(trans).visit_terminator(terminator, loc);\n+    }\n+\n+    fn propagate_call_return(\n+        &self,\n+        _in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}\n+\n+impl<'mir, 'tcx> dataflow::BottomValue for IndirectlyMutableLocals<'mir, 'tcx> {\n+    // bottom = unborrowed\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+/// A `Visitor` that defines the transfer function for `IndirectlyMutableLocals`.\n+struct TransferFunction<'a, 'mir, 'tcx> {\n+    trans: &'a mut GenKillSet<Local>,\n+    body: &'mir mir::Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx> {\n+    fn visit_rvalue(\n+        &mut self,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        if let mir::Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n+            let is_mut = match kind {\n+                mir::BorrowKind::Mut { .. } => true,\n+\n+                | mir::BorrowKind::Shared\n+                | mir::BorrowKind::Shallow\n+                | mir::BorrowKind::Unique\n+                => {\n+                    !borrowed_place\n+                        .ty(self.body, self.tcx)\n+                        .ty\n+                        .is_freeze(self.tcx, self.param_env, DUMMY_SP)\n+                }\n+            };\n+\n+            if is_mut {\n+                match borrowed_place.base {\n+                    mir::PlaceBase::Local(borrowed_local) if !borrowed_place.is_indirect()\n+                        => self.trans.gen(borrowed_local),\n+\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        // This method purposely does nothing except call `super_terminator`. It exists solely to\n+        // document the subtleties around drop terminators.\n+\n+        self.super_terminator(terminator, location);\n+\n+        if let mir::TerminatorKind::Drop { location: _, .. }\n+             | mir::TerminatorKind::DropAndReplace { location: _, .. } = &terminator.kind\n+        {\n+            // Although drop terminators mutably borrow the location being dropped, that borrow\n+            // cannot live beyond the drop terminator because the dropped location is invalidated.\n+        }\n+    }\n+}"}, {"sha": "d669c786c09df984a5b0edcbcccef29197eb945e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -18,13 +18,13 @@ use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;\n use super::on_lookup_result_bits;\n \n-mod storage_liveness;\n-\n-pub use self::storage_liveness::*;\n-\n mod borrowed_locals;\n+mod indirect_mutation;\n+mod storage_liveness;\n \n pub use self::borrowed_locals::*;\n+pub use self::indirect_mutation::IndirectlyMutableLocals;\n+pub use self::storage_liveness::*;\n \n pub(super) mod borrows;\n "}, {"sha": "47eb47cf664ded1c239a46546b79b1e90975c6d5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -23,6 +23,7 @@ pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::HaveBeenBorrowedLocals;\n+pub use self::impls::IndirectlyMutableLocals;\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n "}, {"sha": "3a959a86edd83001039303b2c3d7e80b068bd60b", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,52 @@\n+//! Check the bodies of `const`s, `static`s and `const fn`s for illegal operations.\n+//!\n+//! This module will eventually replace the parts of `qualify_consts.rs` that check whether a local\n+//! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n+//! it finds operations that are invalid in a certain context.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+use rustc::ty::{self, TyCtxt};\n+\n+pub use self::qualifs::Qualif;\n+\n+pub mod ops;\n+mod qualifs;\n+mod resolver;\n+pub mod validation;\n+\n+/// Information about the item currently being validated, as well as a reference to the global\n+/// context.\n+pub struct Item<'mir, 'tcx> {\n+    body: &'mir mir::Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    mode: validation::Mode,\n+}\n+\n+impl Item<'mir, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+    ) -> Self {\n+        let param_env = tcx.param_env(def_id);\n+        let mode = validation::Mode::for_item(tcx, def_id)\n+            .expect(\"const validation must only be run inside a const context\");\n+\n+        Item {\n+            body,\n+            tcx,\n+            def_id,\n+            param_env,\n+            mode,\n+        }\n+    }\n+}\n+\n+\n+fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    Some(def_id) == tcx.lang_items().panic_fn() ||\n+    Some(def_id) == tcx.lang_items().begin_panic_fn()\n+}"}, {"sha": "f457b739949c1244cc6b597283b05b9ade8c56e2", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,339 @@\n+//! Concrete error types for all operations which may be invalid in a certain const context.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::BorrowKind;\n+use rustc::session::config::nightly_options;\n+use rustc::ty::TyCtxt;\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n+use syntax_pos::{Span, Symbol};\n+\n+use super::Item;\n+use super::validation::Mode;\n+\n+/// An operation that is not *always* allowed in a const context.\n+pub trait NonConstOp: std::fmt::Debug {\n+    /// Whether this operation can be evaluated by miri.\n+    const IS_SUPPORTED_IN_MIRI: bool = true;\n+\n+    /// Returns a boolean indicating whether the feature gate that would allow this operation is\n+    /// enabled, or `None` if such a feature gate does not exist.\n+    fn feature_gate(_tcx: TyCtxt<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Returns `true` if this operation is allowed in the given item.\n+    ///\n+    /// This check should assume that we are not in a non-const `fn`, where all operations are\n+    /// legal.\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        Self::feature_gate(item.tcx).unwrap_or(false)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            item.tcx.sess,\n+            span,\n+            E0019,\n+            \"{} contains unimplemented expression type\",\n+            item.mode\n+        );\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\"A function call isn't allowed in the const's initialization expression \\\n+                      because the expression's value must be known at compile-time.\");\n+            err.note(\"Remember: you can't use a function call inside a const's initialization \\\n+                      expression! However, you can use it anywhere else.\");\n+        }\n+        err.emit();\n+    }\n+}\n+\n+/// A `Downcast` projection.\n+#[derive(Debug)]\n+pub struct Downcast;\n+impl NonConstOp for Downcast {}\n+\n+/// A function call where the callee is a pointer.\n+#[derive(Debug)]\n+pub struct FnCallIndirect;\n+impl NonConstOp for FnCallIndirect {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = item.tcx.sess.struct_span_err(\n+            span,\n+            &format!(\"function pointers are not allowed in const fn\"));\n+        err.emit();\n+    }\n+}\n+\n+/// A function call where the callee is not marked as `const`.\n+#[derive(Debug)]\n+pub struct FnCallNonConst(pub DefId);\n+impl NonConstOp for FnCallNonConst {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            item.tcx.sess,\n+            span,\n+            E0015,\n+            \"calls in {}s are limited to constant functions, \\\n+             tuple structs and tuple variants\",\n+            item.mode,\n+        );\n+        err.emit();\n+    }\n+}\n+\n+/// A function call where the callee is not a function definition or function pointer, e.g. a\n+/// closure.\n+///\n+/// This can be subdivided in the future to produce a better error message.\n+#[derive(Debug)]\n+pub struct FnCallOther;\n+impl NonConstOp for FnCallOther {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+}\n+\n+/// A call to a `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n+///\n+/// Contains the name of the feature that would allow the use of this function.\n+#[derive(Debug)]\n+pub struct FnCallUnstable(pub DefId, pub Symbol);\n+impl NonConstOp for FnCallUnstable {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let FnCallUnstable(def_id, feature) = *self;\n+\n+        let mut err = item.tcx.sess.struct_span_err(span,\n+            &format!(\"`{}` is not yet stable as a const fn\",\n+                    item.tcx.def_path_str(def_id)));\n+        if nightly_options::is_nightly_build() {\n+            help!(&mut err,\n+                  \"add `#![feature({})]` to the \\\n+                   crate attributes to enable\",\n+                  feature);\n+        }\n+        err.emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct HeapAllocation;\n+impl NonConstOp for HeapAllocation {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n+                                       \"allocations are not allowed in {}s\", item.mode);\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"The value of statics and constants must be known at compile time, \\\n+                 and they live for the entire lifetime of a program. Creating a boxed \\\n+                 value allocates memory on the heap at runtime, and therefore cannot \\\n+                 be done at compile time.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct IfOrMatch;\n+impl NonConstOp for IfOrMatch {}\n+\n+#[derive(Debug)]\n+pub struct LiveDrop;\n+impl NonConstOp for LiveDrop {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        struct_span_err!(item.tcx.sess, span, E0493,\n+                         \"destructors cannot be evaluated at compile-time\")\n+            .span_label(span, format!(\"{}s cannot evaluate destructors\",\n+                                      item.mode))\n+            .emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Loop;\n+impl NonConstOp for Loop {}\n+\n+#[derive(Debug)]\n+pub struct MutBorrow(pub BorrowKind);\n+impl NonConstOp for MutBorrow {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let kind = self.0;\n+        if let BorrowKind::Mut { .. } = kind {\n+            let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n+                                           \"references in {}s may only refer \\\n+                                            to immutable values\", item.mode);\n+            err.span_label(span, format!(\"{}s require immutable values\",\n+                                                item.mode));\n+            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\"References in statics and constants may only refer \\\n+                          to immutable values.\\n\\n\\\n+                          Statics are shared everywhere, and if they refer to \\\n+                          mutable data one might violate memory safety since \\\n+                          holding multiple mutable references to shared data \\\n+                          is not allowed.\\n\\n\\\n+                          If you really want global mutable state, try using \\\n+                          static mut or a global UnsafeCell.\");\n+            }\n+            err.emit();\n+        } else {\n+            span_err!(item.tcx.sess, span, E0492,\n+                      \"cannot borrow a constant which may contain \\\n+                       interior mutability, create a static instead\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MutDeref;\n+impl NonConstOp for MutDeref {}\n+\n+#[derive(Debug)]\n+pub struct Panic;\n+impl NonConstOp for Panic {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_panic)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_panic,\n+            span,\n+            GateIssue::Language,\n+            &format!(\"panicking in {}s is unstable\", item.mode),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrComparison;\n+impl NonConstOp for RawPtrComparison {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_compare_raw_pointers)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_compare_raw_pointers,\n+            span,\n+            GateIssue::Language,\n+            &format!(\"comparing raw pointers inside {}\", item.mode),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrDeref;\n+impl NonConstOp for RawPtrDeref {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_raw_ptr_deref)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n+            span, GateIssue::Language,\n+            &format!(\n+                \"dereferencing raw pointers in {}s is unstable\",\n+                item.mode,\n+            ),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrToIntCast;\n+impl NonConstOp for RawPtrToIntCast {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_raw_ptr_to_usize_cast)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n+            span, GateIssue::Language,\n+            &format!(\n+                \"casting pointers to integers in {}s is unstable\",\n+                item.mode,\n+            ),\n+        );\n+    }\n+}\n+\n+/// An access to a (non-thread-local) `static`.\n+#[derive(Debug)]\n+pub struct StaticAccess;\n+impl NonConstOp for StaticAccess {\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        item.mode.is_static()\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n+                                        \"{}s cannot refer to statics, use \\\n+                                        a constant instead\", item.mode);\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"Static and const variables can refer to other const variables. \\\n+                    But a const variable cannot refer to a static variable.\"\n+            );\n+            err.help(\n+                \"To fix this, the value can be extracted as a const and then used.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+}\n+\n+/// An access to a thread-local `static`.\n+#[derive(Debug)]\n+pub struct ThreadLocalAccess;\n+impl NonConstOp for ThreadLocalAccess {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        span_err!(item.tcx.sess, span, E0625,\n+            \"thread-local statics cannot be \\\n+            accessed at compile-time\");\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Transmute;\n+impl NonConstOp for Transmute {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_transmute)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_transmute,\n+            span, GateIssue::Language,\n+            &format!(\"The use of std::mem::transmute() \\\n+            is gated in {}s\", item.mode));\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnionAccess;\n+impl NonConstOp for UnionAccess {\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        // Union accesses are stable in all contexts except `const fn`.\n+        item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+    }\n+\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_fn_union)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_fn_union,\n+            span, GateIssue::Language,\n+            \"unions in const fn are unstable\",\n+        );\n+    }\n+}"}, {"sha": "d9d0ce18555730be2d096e188a87112bfbc33f78", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,284 @@\n+//! A copy of the `Qualif` trait in `qualify_consts.rs` that is suitable for the new validator.\n+\n+use rustc::mir::*;\n+use rustc::mir::interpret::ConstValue;\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::bit_set::BitSet;\n+use syntax_pos::DUMMY_SP;\n+\n+use super::Item as ConstCx;\n+use super::validation::Mode;\n+\n+#[derive(Clone, Copy)]\n+pub struct QualifSet(u8);\n+\n+impl QualifSet {\n+    fn contains<Q: ?Sized + Qualif>(self) -> bool {\n+        self.0 & (1 << Q::IDX) != 0\n+    }\n+}\n+\n+/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n+/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n+/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n+/// definitely cannot find anything bad anywhere.\n+///\n+/// The default implementations proceed structurally.\n+pub trait Qualif {\n+    const IDX: usize;\n+\n+    /// Whether this `Qualif` is cleared when a local is moved from.\n+    const IS_CLEARED_ON_MOVE: bool = false;\n+\n+    /// Return the qualification that is (conservatively) correct for any value\n+    /// of the type.\n+    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n+\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+        // FIXME(eddyb) should we do anything here for value properties?\n+        false\n+    }\n+\n+    fn in_projection_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n+        if let [proj_base @ .., elem] = place.projection {\n+            let base_qualif = Self::in_place(cx, per_local, PlaceRef {\n+                base: place.base,\n+                projection: proj_base,\n+            });\n+            let qualif = base_qualif && Self::in_any_value_of_ty(\n+                cx,\n+                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                    .projection_ty(cx.tcx, elem)\n+                    .ty,\n+            );\n+            match elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Downcast(..) => qualif,\n+\n+                ProjectionElem::Index(local) => qualif || per_local.contains(*local),\n+            }\n+        } else {\n+            bug!(\"This should be called if projection is not empty\");\n+        }\n+    }\n+\n+    fn in_projection(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n+        Self::in_projection_structurally(cx, per_local, place)\n+    }\n+\n+    fn in_place(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        place: PlaceRef<'_, 'tcx>,\n+    ) -> bool {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: [],\n+            } => per_local.contains(*local),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted(..),\n+                    ..\n+                }),\n+                projection: [],\n+            } => bug!(\"qualifying already promoted MIR\"),\n+            PlaceRef {\n+                base: PlaceBase::Static(static_),\n+                projection: [],\n+            } => {\n+                Self::in_static(cx, static_)\n+            },\n+            PlaceRef {\n+                base: _,\n+                projection: [.., _],\n+            } => Self::in_projection(cx, per_local, place),\n+        }\n+    }\n+\n+    fn in_operand(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        operand: &Operand<'tcx>,\n+    ) -> bool {\n+        match *operand {\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n+\n+            Operand::Constant(ref constant) => {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n+                    // Don't peek inside trait associated constants.\n+                    if cx.tcx.trait_of_item(def_id).is_some() {\n+                        Self::in_any_value_of_ty(cx, constant.literal.ty)\n+                    } else {\n+                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+\n+                        let qualif = QualifSet(bits).contains::<Self>();\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g., impl associated const\n+                        // with type parameters, take it into account.\n+                        qualif && Self::in_any_value_of_ty(cx, constant.literal.ty)\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        per_local: &BitSet<Local>,\n+        rvalue: &Rvalue<'tcx>,\n+    ) -> bool {\n+        match *rvalue {\n+            Rvalue::NullaryOp(..) => false,\n+\n+            Rvalue::Discriminant(ref place) |\n+            Rvalue::Len(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) |\n+            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, per_local, operand),\n+\n+            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n+                Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n+            }\n+\n+            Rvalue::Ref(_, _, ref place) => {\n+                // Special-case reborrows to be more like a copy of the reference.\n+                if let box [proj_base @ .., elem] = &place.projection {\n+                    if ProjectionElem::Deref == *elem {\n+                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n+                        if let ty::Ref(..) = base_ty.kind {\n+                            return Self::in_place(cx, per_local, PlaceRef {\n+                                base: &place.base,\n+                                projection: proj_base,\n+                            });\n+                        }\n+                    }\n+                }\n+\n+                Self::in_place(cx, per_local, place.as_ref())\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                operands.iter().any(|o| Self::in_operand(cx, per_local, o))\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+    }\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        _per_local: &BitSet<Local>,\n+        _callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Be conservative about the returned value of a const fn.\n+        Self::in_any_value_of_ty(cx, return_ty)\n+    }\n+}\n+\n+/// Constant containing interior mutability (`UnsafeCell<T>`).\n+/// This must be ruled out to make sure that evaluating the constant at compile-time\n+/// and at *any point* during the run-time would produce the same result. In particular,\n+/// promotion of temporaries must not change program behavior; if the promoted could be\n+/// written to, that would be a problem.\n+pub struct HasMutInterior;\n+\n+impl Qualif for HasMutInterior {\n+    const IDX: usize = 0;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n+            // allowed in constants (and the `Checker` will error), and/or it\n+            // won't be promoted, due to `&mut ...` or interior mutability.\n+            Rvalue::Ref(_, kind, ref place) => {\n+                let ty = place.ty(cx.body, cx.tcx).ty;\n+\n+                if let BorrowKind::Mut { .. } = kind {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences.\n+                    match ty.kind {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        ty::Array(..) | ty::Slice(_) if cx.mode == Mode::StaticMut => {},\n+\n+                        // FIXME(ecstaticmorse): uncomment the following match arm to stop marking\n+                        // `&mut []` as `HasMutInterior`.\n+                        /*\n+                        ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                            => {},\n+                        */\n+\n+                        _ => return true,\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, ..) = **kind {\n+                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n+                        let ty = rvalue.ty(cx.body, cx.tcx);\n+                        assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+    }\n+}\n+\n+/// Constant containing an ADT that implements `Drop`.\n+/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n+/// as that might not be a `const fn`, and (b) because implicit promotion would\n+/// remove side-effects that occur as part of dropping that value.\n+pub struct NeedsDrop;\n+\n+impl Qualif for NeedsDrop {\n+    const IDX: usize = 1;\n+    const IS_CLEARED_ON_MOVE: bool = true;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        ty.needs_drop(cx.tcx, cx.param_env)\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, per_local: &BitSet<Local>, rvalue: &Rvalue<'tcx>) -> bool {\n+        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+            if let AggregateKind::Adt(def, ..) = **kind {\n+                if def.has_dtor(cx.tcx) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+    }\n+}"}, {"sha": "2789693ecb6ec25100988cb78b5b25475b036b54", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,349 @@\n+//! Propagate `Qualif`s between locals and query the results.\n+//!\n+//! This also contains the dataflow analysis used to track `Qualif`s on complex control-flow\n+//! graphs.\n+\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::{self, BasicBlock, Local, Location};\n+use rustc_data_structures::bit_set::BitSet;\n+\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+\n+use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use super::{Item, Qualif};\n+use self::old_dataflow::IndirectlyMutableLocals;\n+\n+/// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n+/// `FlowSensitiveAnalysis` as well as the logic underlying `TempPromotionResolver`.\n+///\n+/// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n+/// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n+/// an indirect assignment or function call.\n+struct TransferFunction<'a, 'mir, 'tcx, Q> {\n+    item: &'a Item<'mir, 'tcx>,\n+    qualifs_per_local: &'a mut BitSet<Local>,\n+\n+    _qualif: PhantomData<Q>,\n+}\n+\n+impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn new(\n+        item: &'a Item<'mir, 'tcx>,\n+        qualifs_per_local: &'a mut BitSet<Local>,\n+    ) -> Self {\n+        TransferFunction {\n+            item,\n+            qualifs_per_local,\n+            _qualif: PhantomData,\n+        }\n+    }\n+\n+    fn initialize_state(&mut self) {\n+        self.qualifs_per_local.clear();\n+\n+        for arg in self.item.body.args_iter() {\n+            let arg_ty = self.item.body.local_decls[arg].ty;\n+            if Q::in_any_value_of_ty(self.item, arg_ty) {\n+                self.qualifs_per_local.insert(arg);\n+            }\n+        }\n+    }\n+\n+    fn assign_qualif_direct(&mut self, place: &mir::Place<'tcx>, value: bool) {\n+        debug_assert!(!place.is_indirect());\n+\n+        match (value, place) {\n+            (true, mir::Place { base: mir::PlaceBase::Local(local), .. }) => {\n+                self.qualifs_per_local.insert(*local);\n+            }\n+\n+            // For now, we do not clear the qualif if a local is overwritten in full by\n+            // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n+            // with aggregates where we overwrite all fields with assignments, which would not\n+            // get this feature.\n+            (false, mir::Place { base: mir::PlaceBase::Local(_local), projection: box [] }) => {\n+                // self.qualifs_per_local.remove(*local);\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    fn apply_call_return_effect(\n+        &mut self,\n+        _block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n+        let qualif = Q::in_call(self.item, &mut self.qualifs_per_local, func, args, return_ty);\n+        if !return_place.is_indirect() {\n+            self.assign_qualif_direct(return_place, qualif);\n+        }\n+    }\n+}\n+\n+impl<Q> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>, location: Location) {\n+        self.super_operand(operand, location);\n+\n+        if !Q::IS_CLEARED_ON_MOVE {\n+            return;\n+        }\n+\n+        // If a local with no projections is moved from (e.g. `x` in `y = x`), record that\n+        // it no longer needs to be dropped.\n+        if let mir::Operand::Move(mir::Place {\n+            base: mir::PlaceBase::Local(local),\n+            projection: box [],\n+        }) = *operand {\n+            self.qualifs_per_local.remove(local);\n+        }\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        place: &mir::Place<'tcx>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        let qualif = Q::in_rvalue(self.item, self.qualifs_per_local, rvalue);\n+        if !place.is_indirect() {\n+            self.assign_qualif_direct(place, qualif);\n+        }\n+\n+        // We need to assign qualifs to the left-hand side before visiting `rvalue` since\n+        // qualifs can be cleared on move.\n+        self.super_assign(place, rvalue, location);\n+    }\n+\n+    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n+        // The effect of assignment to the return place in `TerminatorKind::Call` is not applied\n+        // here; that occurs in `apply_call_return_effect`.\n+\n+        if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n+            let qualif = Q::in_operand(self.item, self.qualifs_per_local, value);\n+            if !dest.is_indirect() {\n+                self.assign_qualif_direct(dest, qualif);\n+            }\n+        }\n+\n+        // We need to assign qualifs to the dropped location before visiting the operand that\n+        // replaces it since qualifs can be cleared on move.\n+        self.super_terminator_kind(kind, location);\n+    }\n+}\n+\n+/// Types that can compute the qualifs of each local at each location in a `mir::Body`.\n+///\n+/// Code that wishes to use a `QualifResolver` must call `visit_{statement,terminator}` for each\n+/// statement or terminator, processing blocks in reverse post-order beginning from the\n+/// `START_BLOCK`. Calling code may optionally call `get` after visiting each statement or\n+/// terminator to query the qualification state immediately before that statement or terminator.\n+///\n+/// These conditions are much more restrictive than woud be required by `FlowSensitiveResolver`\n+/// alone. This is to allow a linear, on-demand `TempPromotionResolver` that can operate\n+/// efficiently on simple CFGs.\n+pub trait QualifResolver<Q> {\n+    /// Get the qualifs of each local at the last location visited.\n+    ///\n+    /// This takes `&mut self` so qualifs can be computed lazily.\n+    fn get(&mut self) -> &BitSet<Local>;\n+\n+    /// A convenience method for `self.get().contains(local)`.\n+    fn contains(&mut self, local: Local) -> bool {\n+        self.get().contains(local)\n+    }\n+\n+    /// Resets the resolver to the `START_BLOCK`. This allows a resolver to be reused\n+    /// for multiple passes over a `mir::Body`.\n+    fn reset(&mut self);\n+}\n+\n+pub type IndirectlyMutableResults<'mir, 'tcx> =\n+    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n+\n+/// A resolver for qualifs that works on arbitrarily complex CFGs.\n+///\n+/// As soon as a `Local` becomes writable through a reference (as determined by the\n+/// `IndirectlyMutableLocals` dataflow pass), we must assume that it takes on all other qualifs\n+/// possible for its type. This is because no effort is made to track qualifs across indirect\n+/// assignments (e.g. `*p = x` or calls to opaque functions).\n+///\n+/// It is possible to be more precise here by waiting until an indirect assignment actually occurs\n+/// before marking a borrowed `Local` as qualified.\n+pub struct FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    location: Location,\n+    indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n+    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n+    qualifs_per_local: BitSet<Local>,\n+\n+    /// The value of `Q::in_any_value_of_ty` for each local.\n+    qualifs_in_any_value_of_ty: BitSet<Local>,\n+}\n+\n+impl<Q> FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    pub fn new(\n+        _: Q,\n+        item: &'a Item<'mir, 'tcx>,\n+        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n+        dead_unwinds: &BitSet<BasicBlock>,\n+    ) -> Self {\n+        let analysis = FlowSensitiveAnalysis {\n+            item,\n+            _qualif: PhantomData,\n+        };\n+        let results =\n+            dataflow::Engine::new(item.body, dead_unwinds, analysis).iterate_to_fixpoint();\n+        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+\n+        let mut qualifs_in_any_value_of_ty = BitSet::new_empty(item.body.local_decls.len());\n+        for (local, decl) in item.body.local_decls.iter_enumerated() {\n+            if Q::in_any_value_of_ty(item, decl.ty) {\n+                qualifs_in_any_value_of_ty.insert(local);\n+            }\n+        }\n+\n+        FlowSensitiveResolver {\n+            cursor,\n+            indirectly_mutable_locals,\n+            qualifs_per_local: BitSet::new_empty(item.body.local_decls.len()),\n+            qualifs_in_any_value_of_ty,\n+            location: Location { block: mir::START_BLOCK, statement_index: 0 },\n+        }\n+    }\n+}\n+\n+impl<Q> Visitor<'tcx> for FlowSensitiveResolver<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif\n+{\n+    fn visit_statement(&mut self, _: &mir::Statement<'tcx>, location: Location) {\n+        self.location = location;\n+    }\n+\n+    fn visit_terminator(&mut self, _: &mir::Terminator<'tcx>, location: Location) {\n+        self.location = location;\n+    }\n+}\n+\n+impl<Q> QualifResolver<Q> for FlowSensitiveResolver<'_, '_, '_, Q>\n+where\n+    Q: Qualif\n+{\n+    fn get(&mut self) -> &BitSet<Local> {\n+        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n+\n+        indirectly_mutable_locals.seek(self.location);\n+        self.cursor.seek_before(self.location);\n+\n+        self.qualifs_per_local.overwrite(indirectly_mutable_locals.get());\n+        self.qualifs_per_local.union(self.cursor.get());\n+        self.qualifs_per_local.intersect(&self.qualifs_in_any_value_of_ty);\n+        &self.qualifs_per_local\n+    }\n+\n+    fn contains(&mut self, local: Local) -> bool {\n+        // No need to update the cursor if we know that `Local` cannot possibly be qualified.\n+        if !self.qualifs_in_any_value_of_ty.contains(local) {\n+            return false;\n+        }\n+\n+        // Otherwise, return `true` if this local is qualified or was indirectly mutable at any\n+        // point before this statement.\n+        self.cursor.seek_before(self.location);\n+        if self.cursor.get().contains(local) {\n+            return true;\n+        }\n+\n+        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n+        indirectly_mutable_locals.seek(self.location);\n+        indirectly_mutable_locals.get().contains(local)\n+    }\n+\n+    fn reset(&mut self)  {\n+        self.location = Location { block: mir::START_BLOCK, statement_index: 0 };\n+    }\n+}\n+\n+/// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n+pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n+    item: &'a Item<'mir, 'tcx>,\n+    _qualif: PhantomData<Q>,\n+}\n+\n+impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn transfer_function(\n+        &self,\n+        state: &'a mut BitSet<Local>,\n+    ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n+        TransferFunction::<Q>::new(self.item, state)\n+    }\n+}\n+\n+impl<Q> old_dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl<Q> dataflow::Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    type Idx = Local;\n+\n+    const NAME: &'static str = \"flow_sensitive_qualif\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n+    }\n+\n+    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        self.transfer_function(state).initialize_state();\n+    }\n+\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(state).visit_statement(statement, location);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(state).visit_terminator(terminator, location);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        self.transfer_function(state).apply_call_return_effect(block, func, args, return_place)\n+    }\n+}"}, {"sha": "7e876dd1d9980da097a839e8e9343a15bf405c00", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,597 @@\n+//! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n+\n+use rustc::hir::{self, def_id::DefId};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::*;\n+use rustc::ty::cast::CastTy;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc_target::spec::abi::Abi;\n+use syntax::symbol::sym;\n+use syntax_pos::Span;\n+\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::ops::Deref;\n+\n+use crate::dataflow as old_dataflow;\n+use super::{Item, Qualif, is_lang_panic_fn};\n+use super::resolver::{FlowSensitiveResolver, IndirectlyMutableResults, QualifResolver};\n+use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::ops::{self, NonConstOp};\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CheckOpResult {\n+    Forbidden,\n+    Unleashed,\n+    Allowed,\n+}\n+\n+/// What kind of item we are in.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Mode {\n+    /// A `static` item.\n+    Static,\n+    /// A `static mut` item.\n+    StaticMut,\n+    /// A `const fn` item.\n+    ConstFn,\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+}\n+\n+impl Mode {\n+    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n+    /// does not require validation (e.g. a non-const `fn`).\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+        use hir::BodyOwnerKind as HirKind;\n+\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = match tcx.hir().body_owner_kind(hir_id) {\n+            HirKind::Closure => return None,\n+\n+            HirKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n+            HirKind::Fn => return None,\n+\n+            HirKind::Const => Mode::Const,\n+\n+            HirKind::Static(hir::MutImmutable) => Mode::Static,\n+            HirKind::Static(hir::MutMutable) => Mode::StaticMut,\n+        };\n+\n+        Some(mode)\n+    }\n+\n+    pub fn is_static(self) -> bool {\n+        match self {\n+            Mode::Static | Mode::StaticMut => true,\n+            Mode::ConstFn | Mode::Const => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the value returned by this item must be `Sync`.\n+    ///\n+    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n+    pub fn requires_sync(self) -> bool {\n+        match self {\n+            Mode::Static => true,\n+            Mode::ConstFn | Mode::Const |  Mode::StaticMut => false,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Mode::Const => write!(f, \"constant\"),\n+            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n+            Mode::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n+\n+pub struct Qualifs<'a, 'mir, 'tcx> {\n+    has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n+    needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n+}\n+\n+pub struct Validator<'a, 'mir, 'tcx> {\n+    item: &'a Item<'mir, 'tcx>,\n+    qualifs: Qualifs<'a, 'mir, 'tcx>,\n+\n+    /// The span of the current statement.\n+    span: Span,\n+\n+    /// True if the local was assigned the result of an illegal borrow (`ops::MutBorrow`).\n+    ///\n+    /// This is used to hide errors from {re,}borrowing the newly-assigned local, instead pointing\n+    /// the user to the place where the illegal borrow occurred. This set is only populated once an\n+    /// error has been emitted, so it will never cause an erroneous `mir::Body` to pass validation.\n+    ///\n+    /// FIXME(ecstaticmorse): assert at the end of checking that if `tcx.has_errors() == false`,\n+    /// this set is empty. Note that if we start removing locals from\n+    /// `derived_from_illegal_borrow`, just checking at the end won't be enough.\n+    derived_from_illegal_borrow: BitSet<Local>,\n+\n+    errors: Vec<(Span, String)>,\n+\n+    /// Whether to actually emit errors or just store them in `errors`.\n+    pub(crate) suppress_errors: bool,\n+}\n+\n+impl Deref for Validator<'_, 'mir, 'tcx> {\n+    type Target = Item<'mir, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.item\n+    }\n+}\n+\n+pub fn compute_indirectly_mutable_locals<'mir, 'tcx>(\n+    item: &Item<'mir, 'tcx>,\n+) -> RefCell<IndirectlyMutableResults<'mir, 'tcx>> {\n+    let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n+\n+    let indirectly_mutable_locals = old_dataflow::do_dataflow(\n+        item.tcx,\n+        item.body,\n+        item.def_id,\n+        &[],\n+        &dead_unwinds,\n+        old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+        |_, local| old_dataflow::DebugFormatted::new(&local),\n+    );\n+\n+    let indirectly_mutable_locals = old_dataflow::DataflowResultsCursor::new(\n+        indirectly_mutable_locals,\n+        item.body,\n+    );\n+\n+    RefCell::new(indirectly_mutable_locals)\n+}\n+\n+impl Validator<'a, 'mir, 'tcx> {\n+    pub fn new(\n+        item: &'a Item<'mir, 'tcx>,\n+        indirectly_mutable_locals: &'a RefCell<IndirectlyMutableResults<'mir, 'tcx>>,\n+    ) -> Self {\n+        let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n+\n+        let needs_drop = FlowSensitiveResolver::new(\n+            NeedsDrop,\n+            item,\n+            indirectly_mutable_locals,\n+            &dead_unwinds,\n+        );\n+\n+        let has_mut_interior = FlowSensitiveResolver::new(\n+            HasMutInterior,\n+            item,\n+            indirectly_mutable_locals,\n+            &dead_unwinds,\n+        );\n+\n+        let qualifs = Qualifs {\n+            needs_drop,\n+            has_mut_interior,\n+        };\n+\n+        Validator {\n+            span: item.body.span,\n+            item,\n+            qualifs,\n+            errors: vec![],\n+            derived_from_illegal_borrow: BitSet::new_empty(item.body.local_decls.len()),\n+            suppress_errors: false,\n+        }\n+    }\n+\n+    /// Resets the `QualifResolver`s used by this `Validator` and returns them so they can be\n+    /// reused.\n+    pub fn into_qualifs(mut self) -> Qualifs<'a, 'mir, 'tcx> {\n+        self.qualifs.needs_drop.reset();\n+        self.qualifs.has_mut_interior.reset();\n+        self.qualifs\n+    }\n+\n+    pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n+        std::mem::replace(&mut self.errors, vec![])\n+    }\n+\n+    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n+    /// context. Returns `Forbidden` if an error was emitted.\n+    pub fn check_op_spanned<O>(&mut self, op: O, span: Span) -> CheckOpResult\n+    where\n+        O: NonConstOp + fmt::Debug\n+    {\n+        trace!(\"check_op: op={:?}\", op);\n+\n+        if op.is_allowed_in_item(self) {\n+            return CheckOpResult::Allowed;\n+        }\n+\n+        // If an operation is supported in miri (and is not already controlled by a feature gate) it\n+        // can be turned on with `-Zunleash-the-miri-inside-of-you`.\n+        let is_unleashable = O::IS_SUPPORTED_IN_MIRI\n+            && O::feature_gate(self.tcx).is_none();\n+\n+        if is_unleashable && self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+            self.tcx.sess.span_warn(span, \"skipping const checks\");\n+            return CheckOpResult::Unleashed;\n+        }\n+\n+        if !self.suppress_errors {\n+            op.emit_error(self, span);\n+        }\n+\n+        self.errors.push((span, format!(\"{:?}\", op)));\n+        CheckOpResult::Forbidden\n+    }\n+\n+    /// Emits an error if an expression cannot be evaluated in the current context.\n+    pub fn check_op(&mut self, op: impl NonConstOp + fmt::Debug) -> CheckOpResult {\n+        let span = self.span;\n+        self.check_op_spanned(op, span)\n+    }\n+}\n+\n+impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n+\n+        // Check nested operands and places.\n+        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n+            // Special-case reborrows to be more like a copy of a reference.\n+            let mut reborrow_place = None;\n+            if let box [proj_base @ .., elem] = &place.projection {\n+                if *elem == ProjectionElem::Deref {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        reborrow_place = Some(proj_base);\n+                    }\n+                }\n+            }\n+\n+            if let Some(proj) = reborrow_place {\n+                let ctx = match kind {\n+                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::SharedBorrow,\n+                    ),\n+                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::ShallowBorrow,\n+                    ),\n+                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::UniqueBorrow,\n+                    ),\n+                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                        MutatingUseContext::Borrow,\n+                    ),\n+                };\n+                self.visit_place_base(&place.base, ctx, location);\n+                self.visit_projection(&place.base, proj, ctx, location);\n+            } else {\n+                self.super_rvalue(rvalue, location);\n+            }\n+        } else {\n+            self.super_rvalue(rvalue, location);\n+        }\n+\n+        match *rvalue {\n+            Rvalue::Use(_) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::UnaryOp(UnOp::Neg, _) |\n+            Rvalue::UnaryOp(UnOp::Not, _) |\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::Cast(CastKind::Pointer(_), ..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Len(_) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Aggregate(..) => {}\n+\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n+                let operand_ty = operand.ty(self.body, self.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+\n+                if let (CastTy::Ptr(_), CastTy::Int(_))\n+                     | (CastTy::FnPtr,  CastTy::Int(_)) = (cast_in, cast_out) {\n+                    self.check_op(ops::RawPtrToIntCast);\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+\n+                    self.check_op(ops::RawPtrComparison);\n+                }\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n+                self.check_op(ops::HeapAllocation);\n+            }\n+        }\n+    }\n+\n+    fn visit_place_base(\n+        &mut self,\n+        place_base: &PlaceBase<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        trace!(\n+            \"visit_place_base: place_base={:?} context={:?} location={:?}\",\n+            place_base,\n+            context,\n+            location,\n+        );\n+        self.super_place_base(place_base, context, location);\n+\n+        match place_base {\n+            PlaceBase::Local(_) => {}\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n+                bug!(\"Promotion must be run after const validation\");\n+            }\n+\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n+                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n+                if is_thread_local {\n+                    self.check_op(ops::ThreadLocalAccess);\n+                } else if self.mode == Mode::Static && context.is_mutating_use() {\n+                    // this is not strictly necessary as miri will also bail out\n+                    // For interior mutability we can't really catch this statically as that\n+                    // goes through raw pointers and intermediate temporaries, so miri has\n+                    // to catch this anyway\n+\n+                    self.tcx.sess.span_err(\n+                        self.span,\n+                        \"cannot mutate statics in the initializer of another static\",\n+                    );\n+                } else {\n+                    self.check_op(ops::StaticAccess);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_assign(&mut self, dest: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        trace!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n+\n+        // Error on mutable borrows or shared borrows of values with interior mutability.\n+        //\n+        // This replicates the logic at the start of `assign` in the old const checker.  Note that\n+        // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n+        // interior mutability.\n+        if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n+            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n+                &self.item,\n+                self.qualifs.has_mut_interior.get(),\n+                rvalue,\n+            );\n+\n+            if rvalue_has_mut_interior {\n+                let is_derived_from_illegal_borrow = match *borrowed_place {\n+                    // If an unprojected local was borrowed and its value was the result of an\n+                    // illegal borrow, suppress this error and mark the result of this borrow as\n+                    // illegal as well.\n+                    Place { base: PlaceBase::Local(borrowed_local), projection: box [] }\n+                        if self.derived_from_illegal_borrow.contains(borrowed_local) => true,\n+\n+                    // Otherwise proceed normally: check the legality of a mutable borrow in this\n+                    // context.\n+                    _ => self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden,\n+                };\n+\n+                // When the target of the assignment is a local with no projections, mark it as\n+                // derived from an illegal borrow if necessary.\n+                //\n+                // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n+                // assigned a new value?\n+                if is_derived_from_illegal_borrow {\n+                    if let Place { base: PlaceBase::Local(dest), projection: box [] } = *dest {\n+                        self.derived_from_illegal_borrow.insert(dest);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_assign(dest, rvalue, location);\n+    }\n+\n+    fn visit_projection(\n+        &mut self,\n+        place_base: &PlaceBase<'tcx>,\n+        proj: &[PlaceElem<'tcx>],\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        trace!(\n+            \"visit_place_projection: proj={:?} context={:?} location={:?}\",\n+            proj,\n+            context,\n+            location,\n+        );\n+        self.super_projection(place_base, proj, context, location);\n+\n+        let (elem, proj_base) = match proj.split_last() {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        match elem {\n+            ProjectionElem::Deref => {\n+                if context.is_mutating_use() {\n+                    self.check_op(ops::MutDeref);\n+                }\n+\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                if let ty::RawPtr(_) = base_ty.kind {\n+                    self.check_op(ops::RawPtrDeref);\n+                }\n+            }\n+\n+            ProjectionElem::ConstantIndex {..} |\n+            ProjectionElem::Subslice {..} |\n+            ProjectionElem::Field(..) |\n+            ProjectionElem::Index(_) => {\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                match base_ty.ty_adt_def() {\n+                    Some(def) if def.is_union() => {\n+                        self.check_op(ops::UnionAccess);\n+                    }\n+\n+                    _ => {}\n+                }\n+            }\n+\n+            ProjectionElem::Downcast(..) => {\n+                self.check_op(ops::Downcast);\n+            }\n+        }\n+    }\n+\n+\n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        trace!(\"visit_source_info: source_info={:?}\", source_info);\n+        self.span = source_info.span;\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n+\n+        self.qualifs.needs_drop.visit_statement(statement, location);\n+        self.qualifs.has_mut_interior.visit_statement(statement, location);\n+        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n+        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n+\n+        match statement.kind {\n+            StatementKind::Assign(..) => {\n+                self.super_statement(statement, location);\n+            }\n+            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+                self.check_op(ops::IfOrMatch);\n+            }\n+            // FIXME(eddyb) should these really do nothing?\n+            StatementKind::FakeRead(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) |\n+            StatementKind::InlineAsm {..} |\n+            StatementKind::Retag { .. } |\n+            StatementKind::AscribeUserType(..) |\n+            StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n+\n+        self.qualifs.needs_drop.visit_terminator(terminator, location);\n+        self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n+        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n+        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n+\n+        self.super_terminator(terminator, location);\n+    }\n+\n+    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n+        trace!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n+        self.super_terminator_kind(kind, location);\n+\n+        match kind {\n+            TerminatorKind::Call { func, .. } => {\n+                let fn_ty = func.ty(self.body, self.tcx);\n+\n+                let def_id = match fn_ty.kind {\n+                    ty::FnDef(def_id, _) => def_id,\n+\n+                    ty::FnPtr(_) => {\n+                        self.check_op(ops::FnCallIndirect);\n+                        return;\n+                    }\n+                    _ => {\n+                        self.check_op(ops::FnCallOther);\n+                        return;\n+                    }\n+                };\n+\n+                // At this point, we are calling a function whose `DefId` is known...\n+\n+                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = self.tcx.fn_sig(def_id).abi() {\n+                    assert!(!self.tcx.is_const_fn(def_id));\n+\n+                    if self.tcx.item_name(def_id) == sym::transmute {\n+                        self.check_op(ops::Transmute);\n+                        return;\n+                    }\n+\n+                    // To preserve the current semantics, we return early, allowing all\n+                    // intrinsics (except `transmute`) to pass unchecked to miri.\n+                    //\n+                    // FIXME: We should keep a whitelist of allowed intrinsics (or at least a\n+                    // blacklist of unimplemented ones) and fail here instead.\n+                    return;\n+                }\n+\n+                if self.tcx.is_const_fn(def_id) {\n+                    return;\n+                }\n+\n+                if is_lang_panic_fn(self.tcx, def_id) {\n+                    self.check_op(ops::Panic);\n+                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                    // Exempt unstable const fns inside of macros with\n+                    // `#[allow_internal_unstable]`.\n+                    if !self.span.allows_unstable(feature) {\n+                        self.check_op(ops::FnCallUnstable(def_id, feature));\n+                    }\n+                } else {\n+                    self.check_op(ops::FnCallNonConst(def_id));\n+                }\n+\n+            }\n+\n+            // Forbid all `Drop` terminators unless the place being dropped is a local with no\n+            // projections that cannot be `NeedsDrop`.\n+            | TerminatorKind::Drop { location: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { location: dropped_place, .. }\n+            => {\n+                let mut err_span = self.span;\n+\n+                // Check to see if the type of this place can ever have a drop impl. If not, this\n+                // `Drop` terminator is frivolous.\n+                let ty_needs_drop = dropped_place\n+                    .ty(self.body, self.tcx)\n+                    .ty\n+                    .needs_drop(self.tcx, self.param_env);\n+\n+                if !ty_needs_drop {\n+                    return;\n+                }\n+\n+                let needs_drop = if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: box [],\n+                } = *dropped_place {\n+                    // Use the span where the local was declared as the span of the drop error.\n+                    err_span = self.body.local_decls[local].source_info.span;\n+                    self.qualifs.needs_drop.contains(local)\n+                } else {\n+                    true\n+                };\n+\n+                if needs_drop {\n+                    self.check_op_spanned(ops::LiveDrop, err_span);\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "5037c791cb68892fc26fddf110ed621bc0af4a69", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -15,6 +15,7 @@ use syntax_pos::Span;\n pub mod add_retag;\n pub mod add_moves_for_packed_drops;\n pub mod cleanup_post_borrowck;\n+pub mod check_consts;\n pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify;"}, {"sha": "387540655f07b72665109053a466d1a1e867d84a", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 121, "deletions": 28, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -34,6 +34,7 @@ use std::usize;\n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n+use crate::transform::check_consts::ops::{self, NonConstOp};\n \n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -673,12 +674,18 @@ struct Checker<'a, 'tcx> {\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n+\n+    /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n+    suppress_errors: bool,\n+    errors: Vec<(Span, String)>,\n }\n \n macro_rules! unleash_miri {\n     ($this:expr) => {{\n         if $this.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n+            if $this.mode.requires_const_checking() && !$this.suppress_errors {\n+                $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n+            }\n             return;\n         }\n     }}\n@@ -734,16 +741,19 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             def_id,\n             rpo,\n             temp_promotion_state: temps,\n-            promotion_candidates: vec![]\n+            promotion_candidates: vec![],\n+            errors: vec![],\n+            suppress_errors: false,\n         }\n     }\n \n     // FIXME(eddyb) we could split the errors into meaningful\n     // categories, but enabling full miri would make that\n     // slightly pointless (even with feature-gating).\n-    fn not_const(&mut self) {\n+    fn not_const(&mut self, op: impl NonConstOp) {\n         unleash_miri!(self);\n-        if self.mode.requires_const_checking() {\n+        if self.mode.requires_const_checking() && !self.suppress_errors {\n+            self.record_error(op);\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n                 self.span,\n@@ -761,6 +771,14 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n     }\n \n+    fn record_error(&mut self, op: impl NonConstOp) {\n+        self.record_error_spanned(op, self.span);\n+    }\n+\n+    fn record_error_spanned(&mut self, op: impl NonConstOp, span: Span) {\n+        self.errors.push((span, format!(\"{:?}\", op)));\n+    }\n+\n     /// Assigns an rvalue/call qualification to the given destination.\n     fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n         trace!(\"assign: {:?} <- {:?}\", dest, source);\n@@ -779,8 +797,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     qualifs[HasMutInterior] = false;\n                     qualifs[IsNotPromotable] = true;\n \n-                    if self.mode.requires_const_checking() {\n+                    debug!(\"suppress_errors: {}\", self.suppress_errors);\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n                         if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                            self.record_error(ops::MutBorrow(kind));\n                             if let BorrowKind::Mut { .. } = kind {\n                                 let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                                                \"references in {}s may only refer \\\n@@ -925,8 +945,24 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n     /// Check a whole const, static initializer or const fn.\n     fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n+        use crate::transform::check_consts as new_checker;\n+\n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n+        // FIXME: Also use the new validator when features that require it (e.g. `const_if`) are\n+        // enabled.\n+        let use_new_validator = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+        if use_new_validator {\n+            debug!(\"Using dataflow-based const validator\");\n+        }\n+\n+        let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n+        let mut_borrowed_locals = new_checker::validation::compute_indirectly_mutable_locals(&item);\n+        let mut validator = new_checker::validation::Validator::new(&item, &mut_borrowed_locals);\n+\n+        validator.suppress_errors = !use_new_validator;\n+        self.suppress_errors = use_new_validator;\n+\n         let body = self.body;\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n@@ -935,6 +971,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             seen_blocks.insert(bb.index());\n \n             self.visit_basic_block_data(bb, &body[bb]);\n+            validator.visit_basic_block_data(bb, &body[bb]);\n \n             let target = match body[bb].terminator().kind {\n                 TerminatorKind::Goto { target } |\n@@ -970,12 +1007,42 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n-                    self.not_const();\n+                    self.not_const(ops::Loop);\n+                    validator.check_op(ops::Loop);\n                     break;\n                 }\n             }\n         }\n \n+        // The new validation pass should agree with the old when running on simple const bodies\n+        // (e.g. no `if` or `loop`).\n+        if !use_new_validator {\n+            let mut new_errors = validator.take_errors();\n+\n+            // FIXME: each checker sometimes emits the same error with the same span twice in a row.\n+            self.errors.dedup();\n+            new_errors.dedup();\n+\n+            if self.errors != new_errors {\n+                error!(\"old validator: {:?}\", self.errors);\n+                error!(\"new validator: {:?}\", new_errors);\n+\n+                // ICE on nightly if the validators do not emit exactly the same errors.\n+                // Users can supress this panic with an unstable compiler flag (hopefully after\n+                // filing an issue).\n+                let opts = &self.tcx.sess.opts;\n+                let trigger_ice = opts.unstable_features.is_nightly_build()\n+                    && !opts.debugging_opts.suppress_const_validation_back_compat_ice;\n+\n+                if trigger_ice {\n+                    span_bug!(\n+                        body.span,\n+                        \"{}\",\n+                        VALIDATOR_MISMATCH_ERR,\n+                    );\n+                }\n+            }\n+        }\n \n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n@@ -1041,7 +1108,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         .get_attrs(*def_id)\n                         .iter()\n                         .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode.requires_const_checking() {\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n+                        self.record_error(ops::ThreadLocalAccess);\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                     \"thread-local statics cannot be \\\n                                     accessed at compile-time\");\n@@ -1051,7 +1119,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 // Only allow statics (not consts) to refer to other statics.\n                 if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    if self.mode == Mode::Static && context.is_mutating_use() {\n+                    if self.mode == Mode::Static\n+                        && context.is_mutating_use()\n+                        && !self.suppress_errors\n+                    {\n                         // this is not strictly necessary as miri will also bail out\n                         // For interior mutability we can't really catch this statically as that\n                         // goes through raw pointers and intermediate temporaries, so miri has\n@@ -1065,7 +1136,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 unleash_miri!(self);\n \n-                if self.mode.requires_const_checking() {\n+                if self.mode.requires_const_checking() && !self.suppress_errors {\n+                    self.record_error(ops::StaticAccess);\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n                                                     \"{}s cannot refer to statics, use \\\n                                                     a constant instead\", self.mode);\n@@ -1102,14 +1174,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 ProjectionElem::Deref => {\n                     if context.is_mutating_use() {\n                         // `not_const` errors out in const contexts\n-                        self.not_const()\n+                        self.not_const(ops::MutDeref)\n                     }\n                     let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n                     match self.mode {\n-                        Mode::NonConstFn => {},\n+                        Mode::NonConstFn => {}\n+                        _ if self.suppress_errors => {}\n                         _ => {\n                             if let ty::RawPtr(_) = base_ty.kind {\n                                 if !self.tcx.features().const_raw_ptr_deref {\n+                                    self.record_error(ops::RawPtrDeref);\n                                     emit_feature_err(\n                                         &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                         self.span, GateIssue::Language,\n@@ -1133,7 +1207,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         if def.is_union() {\n                             match self.mode {\n                                 Mode::ConstFn => {\n-                                    if !self.tcx.features().const_fn_union {\n+                                    if !self.tcx.features().const_fn_union\n+                                        && !self.suppress_errors\n+                                    {\n+                                        self.record_error(ops::UnionAccess);\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess, sym::const_fn_union,\n                                             self.span, GateIssue::Language,\n@@ -1153,7 +1230,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n \n                 ProjectionElem::Downcast(..) => {\n-                    self.not_const()\n+                    self.not_const(ops::Downcast)\n                 }\n             }\n         }\n@@ -1239,9 +1316,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n                     (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n                         unleash_miri!(self);\n-                        if !self.tcx.features().const_raw_ptr_to_usize_cast {\n+                        if !self.tcx.features().const_raw_ptr_to_usize_cast\n+                            && !self.suppress_errors\n+                        {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n+                            self.record_error(ops::RawPtrToIntCast);\n                             emit_feature_err(\n                                 &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n                                 self.span, GateIssue::Language,\n@@ -1265,8 +1345,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                     unleash_miri!(self);\n                     if self.mode.requires_const_checking() &&\n-                        !self.tcx.features().const_compare_raw_pointers\n+                        !self.tcx.features().const_compare_raw_pointers &&\n+                        !self.suppress_errors\n                     {\n+                        self.record_error(ops::RawPtrComparison);\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -1282,7 +1364,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                if self.mode.requires_const_checking() {\n+                if self.mode.requires_const_checking() && !self.suppress_errors {\n+                    self.record_error(ops::HeapAllocation);\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n                     err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n@@ -1327,9 +1410,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n-                                    if self.mode.requires_const_checking() {\n+                                    if self.mode.requires_const_checking()\n+                                        && !self.suppress_errors\n+                                    {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n+                                            self.record_error(ops::Transmute);\n                                             emit_feature_err(\n                                                 &self.tcx.sess.parse_sess, sym::const_transmute,\n                                                 self.span, GateIssue::Language,\n@@ -1357,7 +1443,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     .opts\n                                     .debugging_opts\n                                     .unleash_the_miri_inside_of_you;\n-                                if self.tcx.is_const_fn(def_id) || unleash_miri {\n+                                if self.tcx.is_const_fn(def_id)\n+                                    || unleash_miri\n+                                    || self.suppress_errors\n+                                {\n                                     // stable const fns or unstable const fns\n                                     // with their feature gate active\n                                     // FIXME(eddyb) move stability checks from `is_const_fn` here.\n@@ -1368,6 +1457,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // since the macro is marked with the attribute.\n                                     if !self.tcx.features().const_panic {\n                                         // Don't allow panics in constants without the feature gate.\n+                                        self.record_error(ops::Panic);\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n                                             sym::const_panic,\n@@ -1382,6 +1472,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n                                     if !self.span.allows_unstable(feature) {\n+                                        self.record_error(ops::FnCallUnstable(def_id, feature));\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.def_path_str(def_id)));\n@@ -1394,6 +1485,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         err.emit();\n                                     }\n                                 } else {\n+                                    self.record_error(ops::FnCallNonConst(def_id));\n                                     let mut err = struct_span_err!(\n                                         self.tcx.sess,\n                                         self.span,\n@@ -1409,13 +1501,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 ty::FnPtr(_) => {\n-                    let unleash_miri = self\n-                        .tcx\n-                        .sess\n-                        .opts\n-                        .debugging_opts\n-                        .unleash_the_miri_inside_of_you;\n-                    if self.mode.requires_const_checking() && !unleash_miri {\n+                    unleash_miri!(self);\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n+                        self.record_error(ops::FnCallIndirect);\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             \"function pointers are not allowed in const fn\"\n@@ -1424,7 +1512,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    self.not_const();\n+                    self.not_const(ops::FnCallOther);\n                 }\n             }\n \n@@ -1482,7 +1570,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             // Deny *any* live drops anywhere other than functions.\n-            if self.mode.requires_const_checking() {\n+            if self.mode.requires_const_checking() && !self.suppress_errors {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n@@ -1503,6 +1591,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     // Double-check the type being dropped, to minimize false positives.\n                     let ty = place.ty(self.body, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n+                        self.record_error_spanned(ops::LiveDrop, span);\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")\n                             .span_label(span, format!(\"{}s cannot evaluate destructors\",\n@@ -1547,7 +1636,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.super_statement(statement, location);\n             }\n             StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n-                self.not_const();\n+                self.not_const(ops::IfOrMatch);\n             }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |\n@@ -1775,3 +1864,7 @@ fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize\n     }\n     Some(ret)\n }\n+\n+const VALIDATOR_MISMATCH_ERR: &str =\n+    r\"Disagreement between legacy and dataflow-based const validators.\n+    After filing an issue, use `-Zsuppress-const-validation-back-compat-ice` to compile your code.\";"}, {"sha": "2fbb19322442b3dcab4fef3ab2280ff572dce32e", "filename": "src/test/ui/consts/const-eval/const_fn_ptr.stderr", "status": "modified", "additions": 9, "deletions": 135, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,146 +1,20 @@\n warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:25:5\n+  --> $DIR/const_fn_ptr.rs:12:5\n    |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:25:5\n-   |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:25:5\n-   |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:27:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:27:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:27:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:29:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:29:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |     X(x)\n+   |     ^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:29:5\n-   |\n-LL |     assert_eq!(y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n+  --> $DIR/const_fn_ptr.rs:16:5\n    |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |     X_const(x)\n+   |     ^^^^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:32:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:32:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:32:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:34:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:34:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:34:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:36:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:36:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr.rs:36:5\n-   |\n-LL |     assert_eq!(z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n+  --> $DIR/const_fn_ptr.rs:20:5\n    |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |     x(y)\n+   |     ^^^^\n \n warning: constant `X_const` should have an upper case name\n   --> $DIR/const_fn_ptr.rs:9:7"}, {"sha": "90d3cba07a5987ea53e7a6e1f589c011bdbc0630", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -8,6 +8,7 @@ const X: fn(usize) -> usize = double;\n \n const fn bar(x: usize) -> usize {\n     X(x) // FIXME: this should error someday\n+    //~^ WARN: skipping const checks\n }\n \n fn main() {}"}, {"sha": "e80f363ff8be49cc603dd543bde85fb75f88b09a", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,6 @@\n+warning: skipping const checks\n+  --> $DIR/const_fn_ptr_fail.rs:10:5\n+   |\n+LL |     X(x) // FIXME: this should error someday\n+   |     ^^^^\n+"}, {"sha": "b300119509ce444910c52fb93627674b344e0629", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -6,7 +6,7 @@ fn double(x: usize) -> usize { x * 2 }\n const X: fn(usize) -> usize = double;\n \n const fn bar(x: fn(usize) -> usize, y: usize) -> usize {\n-    x(y)\n+    x(y) //~ WARN skipping const checks\n }\n \n const Y: usize = bar(X, 2); // FIXME: should fail to typeck someday\n@@ -15,12 +15,6 @@ const Z: usize = bar(double, 2); // FIXME: should fail to typeck someday\n fn main() {\n     assert_eq!(Y, 4);\n     //~^ ERROR evaluation of constant expression failed\n-    //~^^ WARN skipping const checks\n-    //~^^^ WARN skipping const checks\n-    //~^^^^ WARN skipping const checks\n     assert_eq!(Z, 4);\n     //~^ ERROR evaluation of constant expression failed\n-    //~^^ WARN skipping const checks\n-    //~^^^ WARN skipping const checks\n-    //~^^^^ WARN skipping const checks\n }"}, {"sha": "9d74d3b0bf22930b25573af32807baca4b46ae6b", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.stderr", "status": "modified", "additions": 4, "deletions": 46, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,50 +1,8 @@\n warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:16:5\n-   |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:16:5\n-   |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:16:5\n-   |\n-LL |     assert_eq!(Y, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:21:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:21:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/const_fn_ptr_fail2.rs:21:5\n-   |\n-LL |     assert_eq!(Z, 4);\n-   |     ^^^^^^^^^^^^^^^^^\n+  --> $DIR/const_fn_ptr_fail2.rs:9:5\n    |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |     x(y)\n+   |     ^^^^\n \n error[E0080]: evaluation of constant expression failed\n   --> $DIR/const_fn_ptr_fail2.rs:16:5\n@@ -57,7 +15,7 @@ LL |     assert_eq!(Y, 4);\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error[E0080]: evaluation of constant expression failed\n-  --> $DIR/const_fn_ptr_fail2.rs:21:5\n+  --> $DIR/const_fn_ptr_fail2.rs:18:5\n    |\n LL |     assert_eq!(Z, 4);\n    |     ^^^^^^^^^^^-^^^^^"}, {"sha": "9bb5bcc499e619fdeb13ecbd7d938e47731ada55", "filename": "src/test/ui/consts/const-if.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-if.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,5 @@\n+const _X: i32 = if true { 5 } else { 6 };\n+//~^ ERROR constant contains unimplemented expression type\n+//~| ERROR constant contains unimplemented expression type\n+\n+fn main() {}"}, {"sha": "655fcdae587484aef4613c08cafd833f5f06a8f4", "filename": "src/test/ui/consts/const-if.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-if.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,15 @@\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-if.rs:1:20\n+   |\n+LL | const _X: i32 = if true { 5 } else { 6 };\n+   |                    ^^^^\n+\n+error[E0019]: constant contains unimplemented expression type\n+  --> $DIR/const-if.rs:1:17\n+   |\n+LL | const _X: i32 = if true { 5 } else { 6 };\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0019`."}, {"sha": "498e99e668b43312c95db24106d7066881377a9d", "filename": "src/test/ui/consts/const-multi-ref.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,11 @@\n+const _X: i32 = {\n+    let mut a = 5;\n+    let p = &mut a;      //~ ERROR references in constants may only refer to immutable values\n+\n+    let reborrow = {p};  //~ ERROR references in constants may only refer to immutable values\n+    let pp = &reborrow;\n+    let ppp = &pp;\n+    ***ppp\n+};\n+\n+fn main() {}"}, {"sha": "9e525ef9aac75bcf4b4d70ba49b2ca8042edb789", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -0,0 +1,15 @@\n+error[E0017]: references in constants may only refer to immutable values\n+  --> $DIR/const-multi-ref.rs:3:13\n+   |\n+LL |     let p = &mut a;\n+   |             ^^^^^^ constants require immutable values\n+\n+error[E0017]: references in constants may only refer to immutable values\n+  --> $DIR/const-multi-ref.rs:5:21\n+   |\n+LL |     let reborrow = {p};\n+   |                     ^ constants require immutable values\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0017`."}, {"sha": "6a6cb343f17d58aa89117b5163e80d4ff568ec58", "filename": "src/test/ui/consts/miri_unleashed/assoc_const.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,8 +1,8 @@\n warning: skipping const checks\n-  --> $DIR/assoc_const.rs:12:31\n+  --> $DIR/assoc_const.rs:12:20\n    |\n LL |     const F: u32 = (U::X, 42).1;\n-   |                               ^\n+   |                    ^^^^^^^^^^\n \n error[E0080]: erroneous constant used\n   --> $DIR/assoc_const.rs:29:13"}, {"sha": "df366ba22e4d122189df8257c1f826ab7b83022a", "filename": "src/test/ui/consts/miri_unleashed/enum_discriminants.stderr", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fenum_discriminants.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -22,51 +22,3 @@ warning: skipping const checks\n LL |     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n    |            ^^^^^^^^^^^^^\n \n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:108:5\n-   |\n-LL |     assert_eq!(OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:108:5\n-   |\n-LL |     assert_eq!(OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:108:5\n-   |\n-LL |     assert_eq!(OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:109:5\n-   |\n-LL |     assert_eq!(MORE_OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:109:5\n-   |\n-LL |     assert_eq!(MORE_OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-\n-warning: skipping const checks\n-  --> $DIR/enum_discriminants.rs:109:5\n-   |\n-LL |     assert_eq!(MORE_OVERFLOW, 0);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n-"}, {"sha": "44b408494679c1eca307ffe20076bcf4dcc93aac", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -7,6 +7,7 @@ use std::cell::UnsafeCell;\n \n // make sure we do not just intern this as mutable\n const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+//~^ WARN: skipping const checks\n \n const MUTATING_BEHIND_RAW: () = {\n     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time."}, {"sha": "757f0ffb59ff7540114aad37a6d90a762bac8ea1", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,11 +1,17 @@\n warning: skipping const checks\n-  --> $DIR/mutable_const.rs:14:9\n+  --> $DIR/mutable_const.rs:9:38\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_const.rs:15:9\n    |\n LL |         *MUTABLE_BEHIND_RAW = 99\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: any use of this value will cause an error\n-  --> $DIR/mutable_const.rs:14:9\n+  --> $DIR/mutable_const.rs:15:9\n    |\n LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time."}, {"sha": "59dafcbf4d50c06fef31a564b2491bf0285f6592", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -6,12 +6,15 @@ use std::cell::UnsafeCell;\n // a test demonstrating what things we could allow with a smarter const qualification\n \n static FOO: &&mut u32 = &&mut 42;\n+//~^ WARN: skipping const checks\n \n static BAR: &mut () = &mut ();\n+//~^ WARN: skipping const checks\n \n struct Foo<T>(T);\n \n static BOO: &mut Foo<()> = &mut Foo(());\n+//~^ WARN: skipping const checks\n \n struct Meh {\n     x: &'static UnsafeCell<i32>,\n@@ -21,15 +24,15 @@ unsafe impl Sync for Meh {}\n \n static MEH: Meh = Meh {\n     x: &UnsafeCell::new(42),\n+    //~^ WARN: skipping const checks\n };\n \n static OH_YES: &mut i32 = &mut 42;\n+//~^ WARN: skipping const checks\n \n fn main() {\n     unsafe {\n-        *MEH.x.get() = 99; //~ WARN skipping const checks\n-        //~^ WARN skipping const checks\n+        *MEH.x.get() = 99;\n     }\n     *OH_YES = 99; //~ ERROR cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n-    //~^ WARN skipping const checks\n }"}, {"sha": "e8a867307ce19d1f5cabd43c7de95d992ce618a6", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,23 +1,35 @@\n warning: skipping const checks\n-  --> $DIR/mutable_references.rs:30:10\n+  --> $DIR/mutable_references.rs:8:26\n    |\n-LL |         *MEH.x.get() = 99;\n-   |          ^^^^^\n+LL | static FOO: &&mut u32 = &&mut 42;\n+   |                          ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/mutable_references.rs:30:9\n+  --> $DIR/mutable_references.rs:11:23\n    |\n-LL |         *MEH.x.get() = 99;\n-   |         ^^^^^^^^^^^^^^^^^\n+LL | static BAR: &mut () = &mut ();\n+   |                       ^^^^^^^\n \n warning: skipping const checks\n-  --> $DIR/mutable_references.rs:33:5\n+  --> $DIR/mutable_references.rs:16:28\n    |\n-LL |     *OH_YES = 99;\n-   |     ^^^^^^^^^^^^\n+LL | static BOO: &mut Foo<()> = &mut Foo(());\n+   |                            ^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:26:8\n+   |\n+LL |     x: &UnsafeCell::new(42),\n+   |        ^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:30:27\n+   |\n+LL | static OH_YES: &mut i32 = &mut 42;\n+   |                           ^^^^^^^\n \n error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n-  --> $DIR/mutable_references.rs:33:5\n+  --> $DIR/mutable_references.rs:37:5\n    |\n LL |     *OH_YES = 99;\n    |     ^^^^^^^^^^^^ cannot assign"}, {"sha": "635cad81c97987168f624392809c4f32647c32cb", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -19,11 +19,11 @@ unsafe impl Sync for Meh {}\n \n // the following will never be ok!\n const MUH: Meh = Meh {\n-    x: &UnsafeCell::new(42),\n+    x: &UnsafeCell::new(42), //~ WARN: skipping const checks\n };\n \n fn main() {\n     unsafe {\n-        *MUH.x.get() = 99; //~ WARN skipping const checks\n+        *MUH.x.get() = 99;\n     }\n }"}, {"sha": "c148842bcbc66a778276f71d00947a05dab06524", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0bbab7d99dde8620604fb265706dc8bff20345a7/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=0bbab7d99dde8620604fb265706dc8bff20345a7", "patch": "@@ -1,8 +1,8 @@\n warning: skipping const checks\n-  --> $DIR/mutable_references_ice.rs:27:9\n+  --> $DIR/mutable_references_ice.rs:22:8\n    |\n-LL |         *MUH.x.get() = 99;\n-   |         ^^^^^^^^^^^^^^^^^\n+LL |     x: &UnsafeCell::new(42),\n+   |        ^^^^^^^^^^^^^^^^^^^^\n \n thread 'rustc' panicked at 'assertion failed: `(left != right)`\n   left: `Const`,"}]}