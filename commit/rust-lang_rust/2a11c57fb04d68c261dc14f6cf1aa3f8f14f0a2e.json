{"sha": "2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMTFjNTdmYjA0ZDY4YzI2MWRjMTRmNmNmMWFhM2Y4ZjE0ZjBhMmU=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-01-23T16:11:04Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-01-23T16:11:51Z"}, "message": "Fix and simplify", "tree": {"sha": "6e570ef6dd466dd93f3796d13e06733b3b3658ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e570ef6dd466dd93f3796d13e06733b3b3658ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAmAMSscACgkQztOS3gxI\nPQCVEA/9H0t91xNqkc36XyU4TL1WHQfgQJ8HSyxehqqRbuSHf7k2eeIbX9YUed30\nOEx28A2l4xGd+PjaRidfdjj0q4ksKs0VbWssXsBY0Yw8jKSlZITQLCwSsqAoDVaB\nxP8r1JemKhOXkWmU/0cTGajUx3zEycu+mR23mgbPAPKHuSdbfbiMuH3cHWqs+rXQ\nrz16ZST7Dm6tvaE7+V06cXwPo8I3WnL9NFHx2DTPgbwRdhmlNVUBYTZNkOBJJAnc\n8WkZFq52zdNxpom/JBXk+N6WDJrHX8cQI5rUFHMDE+0VOgpXwXjvz3kukbCaAP5S\nASi+0DNPmvmkf7OJ0bxTqf+Lj1aaK3tFVp4sT+XpyuMNlTRZC0CdKgn9Rty8Ajwi\n+irSsRgQ+cOnYVgH0AUk3tNhMXOD1OVTXgWDBdSX6UcKaOlfRIjKC9itMKUcV9fy\nwSrb5w/5LAaOMF3GXNKhx1Ho5BbvAZTFm988jfeKsc8zpL6DG0Qte/YDZwHMCcW1\nLab0Q9iKZRG7Fki8M+9KHT8BfKDw3GINH/ghJZN0q4Mxe22nVHnaeG5Q2uVpGQnl\ng7KOFAvKeICyKGO8DkARqez+xffKLS/P0tfAq0wILnmnUUhbV1KTDAOIh+k+NH/V\nWl50ZhTN1SAMDMHb62xYVhGHhLrvFmaINIns3qPLlWplng0KNbw=\n=zXyG\n-----END PGP SIGNATURE-----", "payload": "tree 6e570ef6dd466dd93f3796d13e06733b3b3658ca\nparent 969e5523554a6d53a385be35bab449d9b69a82d4\nauthor oxalica <oxalicc@pm.me> 1611418264 +0800\ncommitter oxalica <oxalicc@pm.me> 1611418311 +0800\n\nFix and simplify\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "html_url": "https://github.com/rust-lang/rust/commit/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "969e5523554a6d53a385be35bab449d9b69a82d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/969e5523554a6d53a385be35bab449d9b69a82d4", "html_url": "https://github.com/rust-lang/rust/commit/969e5523554a6d53a385be35bab449d9b69a82d4"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "aa6c0d1f06dd0a28ae526d8b9a858b95a7c1bcd7", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=2a11c57fb04d68c261dc14f6cf1aa3f8f14f0a2e", "patch": "@@ -1370,7 +1370,7 @@ impl<T, A: Allocator> Vec<T, A> {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        let len = self.len();\n+        let original_len = self.len();\n         // Avoid double drop if the drop guard is not executed,\n         // since we may make some holes during the process.\n         unsafe { self.set_len(0) };\n@@ -1396,49 +1396,49 @@ impl<T, A: Allocator> Vec<T, A> {\n         impl<T, A: Allocator> Drop for BackshiftOnDrop<'_, T, A> {\n             fn drop(&mut self) {\n                 if self.deleted_cnt > 0 {\n-                    // SAFETY: Fill the hole of dropped or moved\n+                    // SAFETY: Trailing unchecked items must be valid since we never touch them.\n                     unsafe {\n                         ptr::copy(\n-                            self.v.as_ptr().offset(self.processed_len as isize),\n-                            self.v\n-                                .as_mut_ptr()\n-                                .offset(self.processed_len as isize - self.deleted_cnt as isize),\n+                            self.v.as_ptr().add(self.processed_len),\n+                            self.v.as_mut_ptr().add(self.processed_len - self.deleted_cnt),\n                             self.original_len - self.processed_len,\n                         );\n-                        self.v.set_len(self.original_len - self.deleted_cnt);\n                     }\n                 }\n+                // SAFETY: After filling holes, all items are in contiguous memory.\n+                unsafe {\n+                    self.v.set_len(self.original_len - self.deleted_cnt);\n+                }\n             }\n         }\n \n-        let mut guard =\n-            BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len: len };\n+        let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n \n-        let mut del = 0usize;\n-        for i in 0..len {\n+        while g.processed_len < original_len {\n             // SAFETY: Unchecked element must be valid.\n-            let cur = unsafe { &mut *guard.v.as_mut_ptr().offset(i as isize) };\n+            let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n             if !f(cur) {\n-                del += 1;\n                 // Advance early to avoid double drop if `drop_in_place` panicked.\n-                guard.processed_len = i + 1;\n-                guard.deleted_cnt = del;\n+                g.processed_len += 1;\n+                g.deleted_cnt += 1;\n                 // SAFETY: We never touch this element again after dropped.\n                 unsafe { ptr::drop_in_place(cur) };\n-            } else if del > 0 {\n-                // SAFETY: `del` > 0 so the hole slot must not overlap with current element.\n+                // We already advanced the counter.\n+                continue;\n+            }\n+            if g.deleted_cnt > 0 {\n+                // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n                 // We use copy for move, and never touch this element again.\n                 unsafe {\n-                    let hole_slot = guard.v.as_mut_ptr().offset(i as isize - del as isize);\n+                    let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n                     ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                 }\n-                guard.processed_len = i + 1;\n             }\n+            g.processed_len += 1;\n         }\n \n-        // All holes are at the end now. Simply cut them out.\n-        unsafe { guard.v.set_len(len - del) };\n-        mem::forget(guard);\n+        // All item are processed. This can be optimized to `set_len` by LLVM.\n+        drop(g);\n     }\n \n     /// Removes all but the first of consecutive elements in the vector that resolve to the same"}]}