{"sha": "355e1dda1df8a8106a1692eb7f019fb00df8c3ab", "node_id": "C_kwDOAAsO6NoAKDM1NWUxZGRhMWRmOGE4MTA2YTE2OTJlYjdmMDE5ZmIwMGRmOGMzYWI", "commit": {"author": {"name": "Martin Gammels\u00e6ter", "email": "martin@mg.am", "date": "2023-03-16T19:20:37Z"}, "committer": {"name": "Martin Gammels\u00e6ter", "email": "martin@mg.am", "date": "2023-03-16T20:42:15Z"}, "message": "Improve case mapping encoding scheme\n\nThe indices are encoded as `u32`s in the range of invalid `char`s, so\nthat we know that if any mapping fails to parse as a `char` we should\nuse the value for lookup in the multi-table.\n\nThis avoids the second binary search in cases where a multi-`char`\nmapping is needed.\n\nIdea from @nikic", "tree": {"sha": "5427f796e7b8219263a016a2f1139c07ab4610ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5427f796e7b8219263a016a2f1139c07ab4610ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/355e1dda1df8a8106a1692eb7f019fb00df8c3ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/355e1dda1df8a8106a1692eb7f019fb00df8c3ab", "html_url": "https://github.com/rust-lang/rust/commit/355e1dda1df8a8106a1692eb7f019fb00df8c3ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/355e1dda1df8a8106a1692eb7f019fb00df8c3ab/comments", "author": {"login": "martingms", "id": 458783, "node_id": "MDQ6VXNlcjQ1ODc4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/458783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martingms", "html_url": "https://github.com/martingms", "followers_url": "https://api.github.com/users/martingms/followers", "following_url": "https://api.github.com/users/martingms/following{/other_user}", "gists_url": "https://api.github.com/users/martingms/gists{/gist_id}", "starred_url": "https://api.github.com/users/martingms/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martingms/subscriptions", "organizations_url": "https://api.github.com/users/martingms/orgs", "repos_url": "https://api.github.com/users/martingms/repos", "events_url": "https://api.github.com/users/martingms/events{/privacy}", "received_events_url": "https://api.github.com/users/martingms/received_events", "type": "User", "site_admin": false}, "committer": {"login": "martingms", "id": 458783, "node_id": "MDQ6VXNlcjQ1ODc4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/458783?v=4", "gravatar_id": "", "url": "https://api.github.com/users/martingms", "html_url": "https://github.com/martingms", "followers_url": "https://api.github.com/users/martingms/followers", "following_url": "https://api.github.com/users/martingms/following{/other_user}", "gists_url": "https://api.github.com/users/martingms/gists{/gist_id}", "starred_url": "https://api.github.com/users/martingms/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/martingms/subscriptions", "organizations_url": "https://api.github.com/users/martingms/orgs", "repos_url": "https://api.github.com/users/martingms/repos", "events_url": "https://api.github.com/users/martingms/events{/privacy}", "received_events_url": "https://api.github.com/users/martingms/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9bd88438589fa6fcc8eefe97061a7a3703ca625", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bd88438589fa6fcc8eefe97061a7a3703ca625", "html_url": "https://github.com/rust-lang/rust/commit/f9bd88438589fa6fcc8eefe97061a7a3703ca625"}], "stats": {"total": 1927, "additions": 833, "deletions": 1094}, "files": [{"sha": "091259e4d3877238d89543137354d6b102fd85b0", "filename": "library/core/src/unicode/unicode_data.rs", "status": "modified", "additions": 779, "deletions": 1045, "changes": 1824, "blob_url": "https://github.com/rust-lang/rust/blob/355e1dda1df8a8106a1692eb7f019fb00df8c3ab/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355e1dda1df8a8106a1692eb7f019fb00df8c3ab/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Funicode%2Funicode_data.rs?ref=355e1dda1df8a8106a1692eb7f019fb00df8c3ab"}, {"sha": "58d9959ca7b3419ffc9a2a90cacc555455b85ea5", "filename": "src/tools/unicode-table-generator/src/case_mapping.rs", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/355e1dda1df8a8106a1692eb7f019fb00df8c3ab/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/355e1dda1df8a8106a1692eb7f019fb00df8c3ab/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fcase_mapping.rs?ref=355e1dda1df8a8106a1692eb7f019fb00df8c3ab", "patch": "@@ -1,60 +1,64 @@\n use crate::{fmt_list, UnicodeData};\n use std::{\n+    char,\n     collections::BTreeMap,\n     fmt::{self, Write},\n };\n \n+const INDEX_MASK: u32 = 1 << 22;\n+\n pub(crate) fn generate_case_mapping(data: &UnicodeData) -> String {\n     let mut file = String::new();\n \n+    write!(file, \"const INDEX_MASK: u32 = {};\", INDEX_MASK).unwrap();\n+    file.push_str(\"\\n\\n\");\n     file.push_str(HEADER.trim_start());\n+    file.push('\\n');\n     file.push_str(&generate_tables(\"LOWER\", &data.to_lower));\n     file.push_str(\"\\n\\n\");\n     file.push_str(&generate_tables(\"UPPER\", &data.to_upper));\n     file\n }\n \n fn generate_tables(case: &str, data: &BTreeMap<u32, (u32, u32, u32)>) -> String {\n-    let (single, multi): (Vec<_>, Vec<_>) = data\n-        .iter()\n-        .map(to_mapping)\n-        .filter(|(k, _)| !k.0.is_ascii())\n-        .partition(|(_, [_, s, t])| s.0 == '\\0' && t.0 == '\\0');\n+    let mut mappings = Vec::with_capacity(data.len());\n+    let mut multis = Vec::new();\n+\n+    for (&key, &(a, b, c)) in data.iter() {\n+        let key = char::from_u32(key).unwrap();\n+\n+        if key.is_ascii() {\n+            continue;\n+        }\n+\n+        let value = if b == 0 && c == 0 {\n+            a\n+        } else {\n+            multis.push([\n+                CharEscape(char::from_u32(a).unwrap()),\n+                CharEscape(char::from_u32(b).unwrap()),\n+                CharEscape(char::from_u32(c).unwrap()),\n+            ]);\n+\n+            INDEX_MASK | (u32::try_from(multis.len()).unwrap() - 1)\n+        };\n+\n+        mappings.push((CharEscape(key), value));\n+    }\n \n     let mut tables = String::new();\n \n-    write!(\n-        tables,\n-        \"static {}CASE_TABLE_SINGLE: &[(char, char)] = &[{}];\",\n-        case,\n-        fmt_list(single.into_iter().map(|(k, [v, _, _])| (k, v)))\n-    )\n-    .unwrap();\n+    write!(tables, \"static {}CASE_TABLE: &[(char, u32)] = &[{}];\", case, fmt_list(mappings))\n+        .unwrap();\n \n     tables.push_str(\"\\n\\n\");\n \n-    write!(\n-        tables,\n-        \"static {}CASE_TABLE_MULTI: &[(char, [char; 3])] = &[{}];\",\n-        case,\n-        fmt_list(multi)\n-    )\n-    .unwrap();\n+    write!(tables, \"static {}CASE_TABLE_MULTI: &[[char; 3]] = &[{}];\", case, fmt_list(multis))\n+        .unwrap();\n \n     tables\n }\n \n-fn to_mapping((key, (a, b, c)): (&u32, &(u32, u32, u32))) -> (CharEscape, [CharEscape; 3]) {\n-    (\n-        CharEscape(std::char::from_u32(*key).unwrap()),\n-        [\n-            CharEscape(std::char::from_u32(*a).unwrap()),\n-            CharEscape(std::char::from_u32(*b).unwrap()),\n-            CharEscape(std::char::from_u32(*c).unwrap()),\n-        ],\n-    )\n-}\n-\n struct CharEscape(char);\n \n impl fmt::Debug for CharEscape {\n@@ -68,32 +72,33 @@ pub fn to_lower(c: char) -> [char; 3] {\n     if c.is_ascii() {\n         [(c as u8).to_ascii_lowercase() as char, '\\0', '\\0']\n     } else {\n-        match bsearch_case_tables(c, LOWERCASE_TABLE_SINGLE, LOWERCASE_TABLE_MULTI) {\n-            Some(replacement) => replacement,\n-            None => [c, '\\0', '\\0'],\n-        }\n+        LOWERCASE_TABLE\n+            .binary_search_by(|&(key, _)| key.cmp(&c))\n+            .map(|i| {\n+                let u = LOWERCASE_TABLE[i].1;\n+                char::from_u32(u).map(|c| [c, '\\0', '\\0']).unwrap_or_else(|| {\n+                    // SAFETY: Index comes from statically generated table\n+                    unsafe { *LOWERCASE_TABLE_MULTI.get_unchecked((u & (INDEX_MASK - 1)) as usize) }\n+                })\n+            })\n+            .unwrap_or([c, '\\0', '\\0'])\n     }\n }\n \n pub fn to_upper(c: char) -> [char; 3] {\n     if c.is_ascii() {\n         [(c as u8).to_ascii_uppercase() as char, '\\0', '\\0']\n     } else {\n-        match bsearch_case_tables(c, UPPERCASE_TABLE_SINGLE, UPPERCASE_TABLE_MULTI) {\n-            Some(replacement) => replacement,\n-            None => [c, '\\0', '\\0'],\n-        }\n-    }\n-}\n-\n-fn bsearch_case_tables(\n-    c: char,\n-    single: &[(char, char)],\n-    multi: &[(char, [char; 3])],\n-) -> Option<[char; 3]> {\n-    match single.binary_search_by(|&(key, _)| key.cmp(&c)) {\n-        Ok(i) => Some([single[i].1, '\\0', '\\0']),\n-        Err(_) => multi.binary_search_by(|&(key, _)| key.cmp(&c)).map(|i| multi[i].1).ok(),\n+        UPPERCASE_TABLE\n+            .binary_search_by(|&(key, _)| key.cmp(&c))\n+            .map(|i| {\n+                let u = UPPERCASE_TABLE[i].1;\n+                char::from_u32(u).map(|c| [c, '\\0', '\\0']).unwrap_or_else(|| {\n+                    // SAFETY: Index comes from statically generated table\n+                    unsafe { *UPPERCASE_TABLE_MULTI.get_unchecked((u & (INDEX_MASK - 1)) as usize) }\n+                })\n+            })\n+            .unwrap_or([c, '\\0', '\\0'])\n     }\n }\n \";"}]}