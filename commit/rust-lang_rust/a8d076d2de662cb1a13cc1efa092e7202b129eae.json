{"sha": "a8d076d2de662cb1a13cc1efa092e7202b129eae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDA3NmQyZGU2NjJjYjFhMTNjYzFlZmEwOTJlNzIwMmIxMjllYWU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T19:57:39Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-22T19:58:08Z"}, "message": "syntax/rustc: Make some metadata-related functions take slices, kill bad copies\n\nToo small to review.", "tree": {"sha": "03992d0115aa2063fdfbd5e991dc9baee0ec04a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03992d0115aa2063fdfbd5e991dc9baee0ec04a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d076d2de662cb1a13cc1efa092e7202b129eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d076d2de662cb1a13cc1efa092e7202b129eae", "html_url": "https://github.com/rust-lang/rust/commit/a8d076d2de662cb1a13cc1efa092e7202b129eae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d076d2de662cb1a13cc1efa092e7202b129eae/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8869e723869fe95af0cd022d84c134f7a84fd4a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8869e723869fe95af0cd022d84c134f7a84fd4a0", "html_url": "https://github.com/rust-lang/rust/commit/8869e723869fe95af0cd022d84c134f7a84fd4a0"}], "stats": {"total": 136, "additions": 67, "deletions": 69}, "files": [{"sha": "0633ce4f2e381185c2490d1d2af6b02b6aefd51b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 59, "deletions": 61, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a8d076d2de662cb1a13cc1efa092e7202b129eae", "patch": "@@ -68,7 +68,7 @@ type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n pub type encode_inlined_item = fn@(ecx: @encode_ctxt,\n                                    ebml_w: writer::Encoder,\n-                                   path: ast_map::path,\n+                                   path: &[ast_map::path_elt],\n                                    ii: ast::inlined_item);\n \n type encode_parms = {\n@@ -194,7 +194,7 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n }\n \n fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n-                            params: ~[ty_param]) {\n+                            params: &[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n@@ -268,9 +268,10 @@ fn encode_parent_item(ebml_w: writer::Encoder, id: def_id) {\n }\n \n fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                            id: node_id, variants: ~[variant],\n-                            path: ast_map::path, index: @mut ~[entry<int>],\n-                            ty_params: ~[ty_param]) {\n+                            id: node_id, variants: &[variant],\n+                            path: &[ast_map::path_elt],\n+                            index: @mut ~[entry<int>],\n+                            ty_params: &[ty_param]) {\n     let mut disr_val = 0;\n     let mut i = 0;\n     let vi = ty::enum_variants(ecx.tcx,\n@@ -297,8 +298,8 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n             disr_val = vi[i].disr_val;\n         }\n-        encode_type_param_bounds(ebml_w, ecx, /*bad*/copy ty_params);\n-        encode_path(ecx, ebml_w, &path,\n+        encode_type_param_bounds(ebml_w, ecx, ty_params);\n+        encode_path(ecx, ebml_w, path,\n                     ast_map::path_name(variant.node.name));\n         ebml_w.end_tag();\n         disr_val += 1;\n@@ -307,7 +308,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n }\n \n fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-               path: &ast_map::path, name: ast_map::path_elt) {\n+               path: &[ast_map::path_elt], name: ast_map::path_elt) {\n     fn encode_path_elt(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n@@ -328,7 +329,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n }\n \n fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                       md: _mod, id: node_id, +path: ast_map::path,\n+                       md: _mod, id: node_id, path: &[ast_map::path_elt],\n                        name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -357,7 +358,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         }\n     }\n \n-    encode_path(ecx, ebml_w, &path, ast_map::path_mod(name));\n+    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n \n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n@@ -434,8 +435,8 @@ fn encode_method_sort(ebml_w: writer::Encoder, sort: char) {\n \n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                         path: ast_map::path,\n-                         fields: ~[@struct_field],\n+                         path: &[ast_map::path_elt],\n+                         fields: &[@struct_field],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -455,7 +456,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        tcx.sess.str_of(nm), id);\n                 encode_visibility(ebml_w, vis);\n                 encode_name(ecx, ebml_w, nm);\n-                encode_path(ecx, ebml_w, &path, ast_map::path_name(nm));\n+                encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n                 encode_mutability(ebml_w, mt);\n                 encode_def_id(ebml_w, local_def(id));\n@@ -469,8 +470,8 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n // This is for encoding info for ctors and dtors\n fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                        id: node_id, ident: ident, +path: ast_map::path,\n-                        item: Option<inlined_item>, +tps: ~[ty_param]) {\n+                        id: node_id, ident: ident, path: &[ast_map::path_elt],\n+                        item: Option<inlined_item>, tps: &[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ecx, ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n@@ -481,7 +482,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n         match item {\n            Some(ref it) => {\n              (ecx.encode_inlined_item)(ecx, ebml_w, path, (*it));\n@@ -495,7 +496,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n fn encode_info_for_method(ecx: @encode_ctxt,\n                           ebml_w: writer::Encoder,\n-                          +impl_path: ast_map::path,\n+                          impl_path: &[ast_map::path_elt],\n                           should_inline: bool,\n                           parent_id: node_id,\n                           m: @method,\n@@ -514,7 +515,7 @@ fn encode_info_for_method(ecx: @encode_ctxt,\n     encode_type_param_bounds(ebml_w, ecx, all_tps);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, m.id));\n     encode_name(ecx, ebml_w, m.ident);\n-    encode_path(ecx, ebml_w, &impl_path, ast_map::path_name(m.ident));\n+    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n     encode_self_type(ebml_w, m.self_ty.node);\n     if len > 0u || should_inline {\n         (ecx.encode_inlined_item)(\n@@ -544,7 +545,7 @@ fn purity_static_method_family(p: purity) -> char {\n }\n \n \n-fn should_inline(attrs: ~[attribute]) -> bool {\n+fn should_inline(attrs: &[attribute]) -> bool {\n     match attr::find_inline_attr(attrs) {\n         attr::ia_none | attr::ia_never  => false,\n         attr::ia_hint | attr::ia_always => true\n@@ -554,7 +555,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                         item: @item, index: @mut ~[entry<int>],\n-                        +path: ast_map::path) {\n+                        path: &[ast_map::path_elt]) {\n \n     let tcx = ecx.tcx;\n     let must_write =\n@@ -582,7 +583,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_fn(_, purity, tps, _) => {\n@@ -593,8 +594,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         let tps_len = tps.len();\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n-        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         } else {\n@@ -612,7 +613,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n       }\n       item_ty(_, tps) => {\n@@ -623,7 +624,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         ebml_w.end_tag();\n       }\n@@ -632,44 +633,42 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         do ebml_w.wr_tag(tag_items_data_item) {\n             encode_def_id(ebml_w, local_def(item.id));\n             encode_family(ebml_w, 't');\n-            encode_type_param_bounds(ebml_w, ecx, /*bad*/copy *tps);\n+            encode_type_param_bounds(ebml_w, ecx, *tps);\n             encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n             encode_name(ecx, ebml_w, item.ident);\n             for (*enum_definition).variants.each |v| {\n                 encode_variant_id(ebml_w, local_def(v.node.id));\n             }\n-            (ecx.encode_inlined_item)(ecx, ebml_w, /*bad*/copy path,\n-                                      ii_item(item));\n-            encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n+            encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n             encode_region_param(ecx, ebml_w, item);\n         }\n         encode_enum_variant_info(ecx,\n                                  ebml_w,\n                                  item.id,\n-                                 /*bad*/copy (*enum_definition).variants,\n+                                 (*enum_definition).variants,\n                                  path,\n                                  index,\n-                                 /*bad*/copy *tps);\n+                                 *tps);\n       }\n       item_struct(struct_def, tps) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        // XXX: Bad copy of `path`.\n-        let idx = encode_info_for_struct(ecx, ebml_w, copy path,\n-                                        /*bad*/copy struct_def.fields, index);\n+        let idx = encode_info_for_struct(ecx, ebml_w, path,\n+                                         struct_def.fields, index);\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n             index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n           encode_info_for_ctor(ecx, ebml_w, dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n                                    ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n-                               /*bad*/copy path, if tps.len() > 0u {\n+                               path, if tps.len() > 0u {\n                                    Some(ii_dtor(*dtor, item.ident, tps,\n                                                 local_def(item.id))) }\n-                               else { None }, /*bad*/copy tps);\n+                               else { None }, tps);\n         }\n \n         /* Index the class*/\n@@ -681,7 +680,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n         /* Encode the dtor */\n         /* Encode id for dtor */\n@@ -718,11 +717,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i');\n         encode_region_param(ecx, ebml_w, item);\n-        // XXX: Bad copy.\n-        encode_type_param_bounds(ebml_w, ecx, copy tps);\n+        encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n+        encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n             ast::ty_path(path, _) if path.idents.len() == 1 => {\n                 encode_impl_type_basename(ecx, ebml_w,\n@@ -739,15 +737,17 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         do opt_trait.iter() |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait);\n         }\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();\n \n-        let impl_path = vec::append_one(path,\n-                                        ast_map::path_name(item.ident));\n+        // >:-<\n+        let mut impl_path = vec::append(~[], path);\n+        impl_path += ~[ast_map::path_name(item.ident)];\n+\n         for methods.each |m| {\n             index.push({val: m.id, pos: ebml_w.writer.tell()});\n-            encode_info_for_method(ecx, ebml_w, /*bad*/copy impl_path,\n-                                   should_inline(/*bad*/copy m.attrs),\n+            encode_info_for_method(ecx, ebml_w, impl_path,\n+                                   should_inline(m.attrs),\n                                    item.id, *m,\n                                    vec::append(/*bad*/copy tps, m.tps));\n         }\n@@ -760,10 +760,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I');\n         encode_region_param(ecx, ebml_w, item);\n-        encode_type_param_bounds(ebml_w, ecx, /*bad*/copy *tps);\n+        encode_type_param_bounds(ebml_w, ecx, *tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_attributes(ebml_w, /*bad*/copy item.attrs);\n+        encode_attributes(ebml_w, item.attrs);\n         let mut i = 0u;\n         for vec::each(*ty::trait_methods(tcx, local_def(item.id))) |mty| {\n             match (*ms)[i] {\n@@ -772,7 +772,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 encode_def_id(ebml_w, local_def((*ty_m).id));\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx,\n-                                         /*bad*/copy (*ty_m).tps);\n+                                         (*ty_m).tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n@@ -785,17 +785,17 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 ebml_w.start_tag(tag_item_trait_method);\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n-                encode_type_param_bounds(ebml_w, ecx, /*bad*/copy m.tps);\n+                encode_type_param_bounds(ebml_w, ecx, m.tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n                 encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n                 ebml_w.end_tag();\n               }\n             }\n-            i += 1u;\n+            i += 1;\n         }\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for traits.each |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait)\n         }\n@@ -821,9 +821,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n-            let m_path = vec::append_one(/*bad*/copy path,\n-                                         ast_map::path_name(item.ident));\n-            encode_path(ecx, ebml_w, &m_path, ast_map::path_name(ty_m.ident));\n+            let mut m_path = vec::append(~[], path); // :-(\n+            m_path += [ast_map::path_name(item.ident)];\n+            encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n             ebml_w.end_tag();\n         }\n \n@@ -855,20 +855,18 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         if abi == foreign_abi_rust_intrinsic {\n-            // XXX: Bad copy of `path`.\n-            (ecx.encode_inlined_item)(ecx, ebml_w, copy path,\n-                                      ii_foreign(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n       foreign_item_const(*) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, 'c');\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n-        encode_path(ecx, ebml_w, &path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n     ebml_w.end_tag();\n@@ -888,7 +886,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             visit::visit_item(i, cx, v);\n             match ecx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) => {\n-                encode_info_for_item(ecx, ebml_w, i, index, /*bad*/copy *pt);\n+                encode_info_for_item(ecx, ebml_w, i, index, *pt);\n               }\n               _ => fail ~\"bad item\"\n             }\n@@ -1001,7 +999,7 @@ fn encode_meta_item(ebml_w: writer::Encoder, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: writer::Encoder, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: writer::Encoder, attrs: &[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);"}, {"sha": "f412adb1a6db2f920ffc9b14b2c420eaaf9719f5", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a8d076d2de662cb1a13cc1efa092e7202b129eae", "patch": "@@ -93,7 +93,7 @@ trait tr_intern {\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ebml_w: writer::Encoder,\n-                       path: ast_map::path,\n+                       path: &[ast_map::path_elt],\n                        ii: ast::inlined_item,\n                        maps: maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\","}, {"sha": "9f088b38212f53d954583c07844ef1a00598daba", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a8d076d2de662cb1a13cc1efa092e7202b129eae", "patch": "@@ -2885,9 +2885,9 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n }\n \n fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n-    // XXX: Bad copy of `c`, whatever it is.\n     let encode_inlined_item: encoder::encode_inlined_item =\n-        |a,b,c,d| astencode::encode_inlined_item(a, b, copy c, d, cx.maps);\n+        |ecx, ebml_w, path, ii|\n+        astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n     return {\n         diag: cx.sess.diagnostic(),"}, {"sha": "804de5656ee2a3d57a616356b27e850dae569295", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a8d076d2de662cb1a13cc1efa092e7202b129eae", "patch": "@@ -56,9 +56,9 @@ impl path_elt : cmp::Eq {\n \n type path = ~[path_elt];\n \n-/* FIXMEs that say \"bad\" are as per #2543 */\n-fn path_to_str_with_sep(p: path, sep: ~str, itr: @ident_interner) -> ~str {\n-    let strs = do vec::map(p) |e| {\n+fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n+    -> ~str {\n+    let strs = do p.map |e| {\n         match *e {\n           path_mod(s) => *itr.get(s),\n           path_name(s) => *itr.get(s)\n@@ -76,7 +76,7 @@ fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n     }\n }\n \n-fn path_to_str(p: path, itr: @ident_interner) -> ~str {\n+fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n     path_to_str_with_sep(p, ~\"::\", itr)\n }\n "}, {"sha": "531b9501d6c87a809668b92f5c04e30595f2054e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d076d2de662cb1a13cc1efa092e7202b129eae/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a8d076d2de662cb1a13cc1efa092e7202b129eae", "patch": "@@ -369,7 +369,7 @@ impl inline_attr : cmp::Eq {\n }\n \n /// True if something like #[inline] is found in the list of attrs.\n-fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n+fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {\n         match attr.node.value.node {"}]}