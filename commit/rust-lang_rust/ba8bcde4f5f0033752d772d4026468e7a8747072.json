{"sha": "ba8bcde4f5f0033752d772d4026468e7a8747072", "node_id": "C_kwDOAAsO6NoAKGJhOGJjZGU0ZjVmMDAzMzc1MmQ3NzJkNDAyNjQ2OGU3YTg3NDcwNzI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-15T17:45:01Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-15T17:45:01Z"}, "message": "Also render coercions for ranged type hover on closures", "tree": {"sha": "b3773c19280169d3382cdc3785e6a457a0d8e3a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3773c19280169d3382cdc3785e6a457a0d8e3a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba8bcde4f5f0033752d772d4026468e7a8747072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba8bcde4f5f0033752d772d4026468e7a8747072", "html_url": "https://github.com/rust-lang/rust/commit/ba8bcde4f5f0033752d772d4026468e7a8747072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba8bcde4f5f0033752d772d4026468e7a8747072/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08dc0e21af8c3b7aeeac8cb428df02d83f514083", "url": "https://api.github.com/repos/rust-lang/rust/commits/08dc0e21af8c3b7aeeac8cb428df02d83f514083", "html_url": "https://github.com/rust-lang/rust/commit/08dc0e21af8c3b7aeeac8cb428df02d83f514083"}], "stats": {"total": 133, "additions": 74, "deletions": 59}, "files": [{"sha": "c2b9222cb959801dabf15ed8966702d60f23502e", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 69, "deletions": 57, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ba8bcde4f5f0033752d772d4026468e7a8747072/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba8bcde4f5f0033752d772d4026468e7a8747072/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=ba8bcde4f5f0033752d772d4026468e7a8747072", "patch": "@@ -47,60 +47,8 @@ pub(super) fn closure_expr(\n     config: &HoverConfig,\n     c: ast::ClosureExpr,\n ) -> Option<HoverResult> {\n-    let ty = sema.type_of_expr(&c.into())?;\n-    closure_ty(sema, config, &ty.original)\n-}\n-\n-fn closure_ty(\n-    sema: &Semantics<'_, RootDatabase>,\n-    config: &HoverConfig,\n-    ty: &hir::Type,\n-) -> Option<HoverResult> {\n-    let c = ty.as_closure()?;\n-    let layout = if config.memory_layout {\n-        ty.layout(sema.db)\n-            .map(|x| format!(\" // size = {}, align = {}\", x.size.bytes(), x.align.abi.bytes()))\n-            .unwrap_or_default()\n-    } else {\n-        String::default()\n-    };\n-    let mut captures_rendered = c.captured_items(sema.db)\n-        .into_iter()\n-        .map(|it| {\n-            let borrow_kind = match it.kind() {\n-                CaptureKind::SharedRef => \"immutable borrow\",\n-                CaptureKind::UniqueSharedRef => \"unique immutable borrow ([read more](https://doc.rust-lang.org/stable/reference/types/closure.html#unique-immutable-borrows-in-captures))\",\n-                CaptureKind::MutableRef => \"mutable borrow\",\n-                CaptureKind::Move => \"move\",\n-            };\n-            format!(\"* `{}` by {}\", it.display_place(sema.db), borrow_kind)\n-        })\n-        .join(\"\\n\");\n-    if captures_rendered.trim().is_empty() {\n-        captures_rendered = \"This closure captures nothing\".to_string();\n-    }\n-    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n-    let mut push_new_def = |item: hir::ModuleDef| {\n-        if !targets.contains(&item) {\n-            targets.push(item);\n-        }\n-    };\n-    walk_and_push_ty(sema.db, ty, &mut push_new_def);\n-    c.capture_types(sema.db).into_iter().for_each(|ty| {\n-        walk_and_push_ty(sema.db, &ty, &mut push_new_def);\n-    });\n-\n-    let mut res = HoverResult::default();\n-    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n-    res.markup = format!(\n-        \"```rust\\n{}{}\\n{}\\n```\\n\\n## Captures\\n{}\",\n-        c.display_with_id(sema.db),\n-        layout,\n-        c.display_with_impl(sema.db),\n-        captures_rendered,\n-    )\n-    .into();\n-    Some(res)\n+    let TypeInfo { original, .. } = sema.type_of_expr(&c.into())?;\n+    closure_ty(sema, config, &TypeInfo { original, adjusted: None })\n }\n \n pub(super) fn try_expr(\n@@ -542,11 +490,12 @@ pub(super) fn definition(\n fn type_info(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n-    TypeInfo { original, adjusted }: TypeInfo,\n+    ty: TypeInfo,\n ) -> Option<HoverResult> {\n-    if let Some(res) = closure_ty(sema, config, &original) {\n+    if let Some(res) = closure_ty(sema, config, &ty) {\n         return Some(res);\n-    }\n+    };\n+    let TypeInfo { original, adjusted } = ty;\n     let mut res = HoverResult::default();\n     let mut targets: Vec<hir::ModuleDef> = Vec::new();\n     let mut push_new_def = |item: hir::ModuleDef| {\n@@ -576,6 +525,69 @@ fn type_info(\n     Some(res)\n }\n \n+fn closure_ty(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &HoverConfig,\n+    TypeInfo { original, adjusted }: &TypeInfo,\n+) -> Option<HoverResult> {\n+    let c = original.as_closure()?;\n+    let layout = if config.memory_layout {\n+        original\n+            .layout(sema.db)\n+            .map(|x| format!(\" // size = {}, align = {}\", x.size.bytes(), x.align.abi.bytes()))\n+            .unwrap_or_default()\n+    } else {\n+        String::default()\n+    };\n+    let mut captures_rendered = c.captured_items(sema.db)\n+        .into_iter()\n+        .map(|it| {\n+            let borrow_kind = match it.kind() {\n+                CaptureKind::SharedRef => \"immutable borrow\",\n+                CaptureKind::UniqueSharedRef => \"unique immutable borrow ([read more](https://doc.rust-lang.org/stable/reference/types/closure.html#unique-immutable-borrows-in-captures))\",\n+                CaptureKind::MutableRef => \"mutable borrow\",\n+                CaptureKind::Move => \"move\",\n+            };\n+            format!(\"* `{}` by {}\", it.display_place(sema.db), borrow_kind)\n+        })\n+        .join(\"\\n\");\n+    if captures_rendered.trim().is_empty() {\n+        captures_rendered = \"This closure captures nothing\".to_string();\n+    }\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, original, &mut push_new_def);\n+    c.capture_types(sema.db).into_iter().for_each(|ty| {\n+        walk_and_push_ty(sema.db, &ty, &mut push_new_def);\n+    });\n+\n+    let adjusted = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        format!(\n+            \"\\nCoerced to: {}\",\n+            adjusted_ty.display(sema.db).with_closure_style(hir::ClosureStyle::ImplFn)\n+        )\n+    } else {\n+        String::new()\n+    };\n+\n+    let mut res = HoverResult::default();\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    res.markup = format!(\n+        \"```rust\\n{}{}\\n{}\\n```{adjusted}\\n\\n## Captures\\n{}\",\n+        c.display_with_id(sema.db),\n+        layout,\n+        c.display_with_impl(sema.db),\n+        captures_rendered,\n+    )\n+    .into();\n+    Some(res)\n+}\n+\n fn render_builtin_attr(db: &RootDatabase, attr: hir::BuiltinAttr) -> Option<Markup> {\n     let name = attr.name(db);\n     let desc = format!(\"#[{name}]\");"}, {"sha": "0d8fc8a5f72f2bb52f3c929a8f0defd9fce60634", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba8bcde4f5f0033752d772d4026468e7a8747072/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba8bcde4f5f0033752d772d4026468e7a8747072/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=ba8bcde4f5f0033752d772d4026468e7a8747072", "patch": "@@ -307,29 +307,32 @@ fn main() {\n fn hover_ranged_closure() {\n     check_hover_range(\n         r#\"\n+//- minicore: fn\n struct S;\n struct S2;\n fn main() {\n     let x = &S;\n-    let y = $0|| {x; S2}$0;\n+    let y = ($0|| {x; S2}$0).call();\n }\n \"#,\n         expect![[r#\"\n             ```rust\n             {closure#0} // size = 8, align = 8\n             impl FnOnce() -> S2\n             ```\n+            Coerced to: &impl FnOnce() -> S2\n \n             ## Captures\n             * `x` by move\"#]],\n     );\n     check_hover_range_actions(\n         r#\"\n+//- minicore: fn\n struct S;\n struct S2;\n fn main() {\n     let x = &S;\n-    let y = $0|| {x; S2}$0;\n+    let y = ($0|| {x; S2}$0).call();\n }\n \"#,\n         expect![[r#\""}]}