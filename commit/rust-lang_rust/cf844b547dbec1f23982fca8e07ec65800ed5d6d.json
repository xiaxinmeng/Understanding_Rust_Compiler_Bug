{"sha": "cf844b547dbec1f23982fca8e07ec65800ed5d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmODQ0YjU0N2RiZWMxZjIzOTgyZmNhOGUwN2VjNjU4MDBlZDVkNmQ=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-06T22:50:59Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-06-22T05:36:36Z"}, "message": "async await desugaring and tests", "tree": {"sha": "a5420599dea5829f105d2a12bb14a3102141a749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5420599dea5829f105d2a12bb14a3102141a749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf844b547dbec1f23982fca8e07ec65800ed5d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf844b547dbec1f23982fca8e07ec65800ed5d6d", "html_url": "https://github.com/rust-lang/rust/commit/cf844b547dbec1f23982fca8e07ec65800ed5d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf844b547dbec1f23982fca8e07ec65800ed5d6d/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "589446e19cbf7a2c7eddf80b490992d31134015c", "url": "https://api.github.com/repos/rust-lang/rust/commits/589446e19cbf7a2c7eddf80b490992d31134015c", "html_url": "https://github.com/rust-lang/rust/commit/589446e19cbf7a2c7eddf80b490992d31134015c"}], "stats": {"total": 1481, "additions": 1282, "deletions": 199}, "files": [{"sha": "6e6b15bdff7440a0700793ab6ba33dad6ab2ed2c", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -2131,5 +2131,10 @@ register_diagnostics! {\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0697, // closures cannot be static\n+\n+    E0906, // closures cannot be static\n+\n+    E0703, // multiple different lifetimes used in arguments of `async fn`\n+    E0704, // multiple elided lifetimes used in arguments of `async fn`\n+    E0705, // `async` non-`move` closures with arguments are not currently supported\n }"}, {"sha": "d0e6a5e2973d4e9a3db41d5cb0cc8a534f27495c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 520, "deletions": 151, "changes": 671, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -449,15 +449,15 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) {\n+    fn allocate_hir_id_counter<T: Debug>(&mut self, owner: NodeId, debug: &T) -> LoweredNodeId {\n         if self.item_local_id_counters.insert(owner, 0).is_some() {\n             bug!(\n                 \"Tried to allocate item_local_id_counter for {:?} twice\",\n                 debug\n             );\n         }\n         // Always allocate the first HirId for the owner itself\n-        self.lower_node_id_with_owner(owner, owner);\n+        self.lower_node_id_with_owner(owner, owner)\n     }\n \n     fn lower_node_id_generic<F>(&mut self, ast_node_id: NodeId, alloc_hir_id: F) -> LoweredNodeId\n@@ -501,7 +501,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let counter = self.item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n-            .unwrap();\n+            .unwrap_or_else(|| panic!(\"No item_local_id_counters entry for {:?}\", owner));\n         let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n         self.current_hir_id_owner.push((def_index, counter));\n         let ret = f(self);\n@@ -840,6 +840,46 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n+    fn make_async_expr(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_node_id: NodeId,\n+        ret_ty: Option<&Ty>,\n+        body: impl FnOnce(&mut LoweringContext) -> hir::Expr,\n+    ) -> hir::Expr_ {\n+        let prev_is_generator = mem::replace(&mut self.is_generator, true);\n+        let body_expr = body(self);\n+        let span = body_expr.span;\n+        let output = match ret_ty {\n+            Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n+            None => FunctionRetTy::Default(span),\n+        };\n+        let decl = FnDecl {\n+            inputs: vec![],\n+            output,\n+            variadic: false\n+        };\n+        let body_id = self.record_body(body_expr, Some(&decl));\n+        self.is_generator = prev_is_generator;\n+\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n+        let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n+        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, false);\n+        let generator = hir::Expr {\n+            id: closure_node_id,\n+            hir_id: closure_hir_id,\n+            node: hir::ExprClosure(capture_clause, decl, body_id, span,\n+                Some(hir::GeneratorMovability::Static)),\n+            span,\n+            attrs: ThinVec::new(),\n+        };\n+\n+        let unstable_span = self.allow_internal_unstable(CompilerDesugaringKind::Async, span);\n+        let gen_future = self.expr_std_path(\n+            unstable_span, &[\"raw\", \"future_from_generator\"], ThinVec::new());\n+        hir::ExprCall(P(gen_future), hir_vec![generator])\n+    }\n+\n     fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n     where\n         F: FnOnce(&mut LoweringContext) -> hir::Expr,\n@@ -1067,7 +1107,7 @@ impl<'a> LoweringContext<'a> {\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n-                                decl: this.lower_fn_decl(&f.decl, None, false),\n+                                decl: this.lower_fn_decl(&f.decl, None, false, false),\n                                 arg_names: this.lower_fn_args_to_names(&f.decl),\n                             }))\n                         },\n@@ -1132,92 +1172,10 @@ impl<'a> LoweringContext<'a> {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::Existential(fn_def_id) => {\n-\n-                        // We need to manually repeat the code of `next_id` because the lowering\n-                        // needs to happen while the owner_id is pointing to the item itself,\n-                        // because items are their own owners\n-                        let exist_ty_node_id = self.sess.next_node_id();\n-\n-                        // Make sure we know that some funky desugaring has been going on here.\n-                        // This is a first: there is code in other places like for loop\n-                        // desugaring that explicitly states that we don't want to track that.\n-                        // Not tracking it makes lints in rustc and clippy very fragile as\n-                        // frequently opened issues show.\n-                        let exist_ty_span = self.allow_internal_unstable(\n-                            CompilerDesugaringKind::ExistentialReturnType,\n-                            t.span,\n-                        );\n-\n-                        // Pull a new definition from the ether\n-                        let exist_ty_def_index = self\n-                            .resolver\n-                            .definitions()\n-                            .create_def_with_parent(\n-                            fn_def_id.index,\n-                            exist_ty_node_id,\n-                            DefPathData::ExistentialImplTrait,\n-                            DefIndexAddressSpace::High,\n-                            Mark::root(),\n-                            exist_ty_span,\n-                        );\n-\n-                        // the `t` is just for printing debug messages\n-                        self.allocate_hir_id_counter(exist_ty_node_id, t);\n-\n-                        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-                            lctx.lower_param_bounds(bounds, itctx)\n-                        });\n-\n-                        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-                            exist_ty_node_id,\n-                            exist_ty_def_index,\n-                            &hir_bounds,\n-                        );\n-\n-                        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-                            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n-                                generics: hir::Generics {\n-                                    params: lifetime_defs,\n-                                    where_clause: hir::WhereClause {\n-                                        id: lctx.next_id().node_id,\n-                                        predicates: Vec::new().into(),\n-                                    },\n-                                    span,\n-                                },\n-                                bounds: hir_bounds,\n-                                impl_trait_fn: Some(fn_def_id),\n-                            });\n-                            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n-                            // Generate an `existential type Foo: Trait;` declaration\n-                            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n-                            // Set the name to `impl Bound1 + Bound2`\n-                            let exist_ty_name = Symbol::intern(&pprust::ty_to_string(t));\n-\n-                            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n-                            let exist_ty_item = hir::Item {\n-                                id: exist_ty_id.node_id,\n-                                hir_id: exist_ty_id.hir_id,\n-                                name: exist_ty_name,\n-                                attrs: Default::default(),\n-                                node: exist_ty_item_kind,\n-                                vis: hir::Visibility::Inherited,\n-                                span: exist_ty_span,\n-                            };\n-\n-                            // Insert the item into the global list. This usually happens\n-                            // automatically for all AST items. But this existential type item\n-                            // does not actually exist in the AST.\n-                            lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n-\n-                            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n-                            hir::TyImplTraitExistential(\n-                                hir::ItemId {\n-                                    id: exist_ty_id.node_id\n-                                },\n-                                DefId::local(exist_ty_def_index),\n-                                lifetimes,\n-                            )\n-                        })\n+                        // Set the name to `impl Bound1 + Bound2`\n+                        let exist_ty_name = Symbol::intern(&pprust::ty_to_string(t));\n+                        self.lower_existential_impl_trait(\n+                            span, fn_def_id, exist_ty_name, |this| this.lower_bounds(bounds, itctx))\n                     }\n                     ImplTraitContext::Universal(def_id) => {\n                         let def_node_id = self.next_id().node_id;\n@@ -1281,6 +1239,95 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn lower_existential_impl_trait(\n+        &mut self,\n+        span: Span,\n+        fn_def_id: DefId,\n+        exist_ty_name: Name,\n+        lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::TyParamBounds,\n+    ) -> hir::Ty_ {\n+        // We need to manually repeat the code of `next_id` because the lowering\n+        // needs to happen while the owner_id is pointing to the item itself,\n+        // because items are their own owners\n+        let exist_ty_node_id = self.sess.next_node_id();\n+\n+        // Make sure we know that some funky desugaring has been going on here.\n+        // This is a first: there is code in other places like for loop\n+        // desugaring that explicitly states that we don't want to track that.\n+        // Not tracking it makes lints in rustc and clippy very fragile as\n+        // frequently opened issues show.\n+        let exist_ty_span = self.allow_internal_unstable(\n+            CompilerDesugaringKind::ExistentialReturnType,\n+            span,\n+        );\n+\n+        // Pull a new definition from the ether\n+        let exist_ty_def_index = self\n+            .resolver\n+            .definitions()\n+            .create_def_with_parent(\n+            fn_def_id.index,\n+            exist_ty_node_id,\n+            DefPathData::ExistentialImplTrait,\n+            DefIndexAddressSpace::High,\n+            Mark::root(),\n+            exist_ty_span,\n+        );\n+\n+        self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n+\n+        let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n+\n+        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n+            exist_ty_node_id,\n+            exist_ty_def_index,\n+            &hir_bounds,\n+        );\n+\n+        self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n+            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n+                generics: hir::Generics {\n+                    params: lifetime_defs,\n+                    where_clause: hir::WhereClause {\n+                        id: lctx.next_id().node_id,\n+                        predicates: Vec::new().into(),\n+                    },\n+                    span,\n+                },\n+                bounds: hir_bounds,\n+                impl_trait_fn: Some(fn_def_id),\n+            });\n+            let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n+            // Generate an `existential type Foo: Trait;` declaration\n+            trace!(\"creating existential type with id {:#?}\", exist_ty_id);\n+\n+            trace!(\"exist ty def index: {:#?}\", exist_ty_def_index);\n+            let exist_ty_item = hir::Item {\n+                id: exist_ty_id.node_id,\n+                hir_id: exist_ty_id.hir_id,\n+                name: exist_ty_name,\n+                attrs: Default::default(),\n+                node: exist_ty_item_kind,\n+                vis: hir::Visibility::Inherited,\n+                span: exist_ty_span,\n+            };\n+\n+            // Insert the item into the global list. This usually happens\n+            // automatically for all AST items. But this existential type item\n+            // does not actually exist in the AST.\n+            lctx.items.insert(exist_ty_id.node_id, exist_ty_item);\n+\n+            // `impl Trait` now just becomes `Foo<'a, 'b, ..>`\n+            hir::TyImplTraitExistential(\n+                hir::ItemId {\n+                    id: exist_ty_id.node_id\n+                },\n+                DefId::local(exist_ty_def_index),\n+                lifetimes,\n+            )\n+        })\n+    }\n+\n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n         exist_ty_id: NodeId,\n@@ -1829,39 +1876,53 @@ impl<'a> LoweringContext<'a> {\n             .collect()\n     }\n \n+    // Lowers a function declaration.\n+    //\n+    // decl: the unlowered (ast) function declaration.\n+    // fn_def_id: if `Some`, impl Trait arguments are lowered into generic parameters on the\n+    //      given DefId, otherwise impl Trait is disallowed. Must be `Some` if\n+    //      make_ret_async is true.\n+    // impl_trait_return_allow: determines whether impl Trait can be used in return position.\n+    //      This guards against trait declarations and implementations where impl Trait is\n+    //      disallowed.\n+    // make_ret_async: if enabled, converts `-> T` into `-> impl Future<Output = T>` in the\n+    //      return type. This is used for `async fn` declarations.\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n         fn_def_id: Option<DefId>,\n         impl_trait_return_allow: bool,\n+        make_ret_async: bool,\n     ) -> P<hir::FnDecl> {\n-        // NOTE: The two last parameters here have to do with impl Trait. If fn_def_id is Some,\n-        //       then impl Trait arguments are lowered into generic parameters on the given\n-        //       fn_def_id, otherwise impl Trait is disallowed. (for now)\n-        //\n-        //       Furthermore, if impl_trait_return_allow is true, then impl Trait may be used in\n-        //       return positions as well. This guards against trait declarations and their impls\n-        //       where impl Trait is disallowed. (again for now)\n-        P(hir::FnDecl {\n-            inputs: decl.inputs\n-                .iter()\n-                .map(|arg| {\n-                    if let Some(def_id) = fn_def_id {\n-                        self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n-                    } else {\n-                        self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n-                    }\n-                })\n-                .collect(),\n-            output: match decl.output {\n+        let inputs = decl.inputs\n+            .iter()\n+            .map(|arg| {\n+                if let Some(def_id) = fn_def_id {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n+                } else {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n+                }\n+            })\n+            .collect::<HirVec<_>>();\n+\n+        let output = if make_ret_async {\n+            self.lower_async_fn_ret_ty(\n+                &inputs, &decl.output, fn_def_id.expect(\"make_ret_async but no fn_def_id\"))\n+        } else {\n+            match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match fn_def_id {\n                     Some(def_id) if impl_trait_return_allow => {\n                         hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(def_id)))\n                     }\n                     _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n-            },\n+            }\n+        };\n+\n+        P(hir::FnDecl {\n+            inputs,\n+            output,\n             variadic: decl.variadic,\n             has_implicit_self: decl.inputs.get(0).map_or(false, |arg| match arg.ty.node {\n                 TyKind::ImplicitSelf => true,\n@@ -1871,6 +1932,243 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    // Transform `-> T` into `-> impl Future<Output = T>` for `async fn`\n+    //\n+    // fn_span: the span of the async function declaration. Used for error reporting.\n+    // inputs: lowered types of arguments to the function. Used to collect lifetimes.\n+    // output: unlowered output type (`T` in `-> T`)\n+    // fn_def_id: DefId of the parent function. Used to create child impl trait definition.\n+    fn lower_async_fn_ret_ty(\n+        &mut self,\n+        inputs: &[P<hir::Ty>],\n+        output: &FunctionRetTy,\n+        fn_def_id: DefId,\n+    ) -> hir::FunctionRetTy {\n+        // Get lifetimes used in the input arguments to the function. Our output type must also\n+        // have the same lifetime. FIXME(cramertj) multiple different lifetimes are not allowed\n+        // because `impl Trait + 'a + 'b` doesn't allow for capture `'a` and `'b` where neither\n+        // is a subset of the other. We really want some new lifetime that is a subset of all input\n+        // lifetimes, but that doesn't exist at the moment.\n+\n+        struct AsyncFnLifetimeCollector<'r, 'a: 'r> {\n+            context: &'r mut LoweringContext<'a>,\n+            // Lifetimes bound by HRTB\n+            currently_bound_lifetimes: Vec<hir::LifetimeName>,\n+            // Whether to count elided lifetimes.\n+            // Disabled inside of `Fn` or `fn` syntax.\n+            collect_elided_lifetimes: bool,\n+            // The lifetime found.\n+            // Multiple different or elided lifetimes cannot appear in async fn for now.\n+            output_lifetime: Option<(hir::LifetimeName, Span)>,\n+        }\n+\n+        impl<'r, 'a: 'r, 'v> hir::intravisit::Visitor<'v> for AsyncFnLifetimeCollector<'r, 'a> {\n+            fn nested_visit_map<'this>(\n+                &'this mut self,\n+            ) -> hir::intravisit::NestedVisitorMap<'this, 'v> {\n+                hir::intravisit::NestedVisitorMap::None\n+            }\n+\n+            fn visit_path_parameters(&mut self, span: Span, parameters: &'v hir::PathParameters) {\n+                // Don't collect elided lifetimes used inside of `Fn()` syntax.\n+                if parameters.parenthesized {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_path_parameters(self, span, parameters);\n+                }\n+            }\n+\n+            fn visit_ty(&mut self, t: &'v hir::Ty) {\n+                // Don't collect elided lifetimes used inside of `fn()` syntax\n+                if let &hir::Ty_::TyBareFn(_) = &t.node {\n+                    let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n+                    self.collect_elided_lifetimes = false;\n+\n+                    // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                    // to be able to later fully undo their introduction.\n+                    let old_len = self.currently_bound_lifetimes.len();\n+                    hir::intravisit::walk_ty(self, t);\n+                    self.currently_bound_lifetimes.truncate(old_len);\n+\n+                    self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n+                } else {\n+                    hir::intravisit::walk_ty(self, t);\n+                }\n+            }\n+\n+            fn visit_poly_trait_ref(\n+                &mut self,\n+                trait_ref: &'v hir::PolyTraitRef,\n+                modifier: hir::TraitBoundModifier,\n+            ) {\n+                // Record the \"stack height\" of `for<'a>` lifetime bindings\n+                // to be able to later fully undo their introduction.\n+                let old_len = self.currently_bound_lifetimes.len();\n+                hir::intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n+                self.currently_bound_lifetimes.truncate(old_len);\n+            }\n+\n+            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n+                // Record the introduction of 'a in `for<'a> ...`\n+                if let hir::GenericParam::Lifetime(ref lt_def) = *param {\n+                    // Introduce lifetimes one at a time so that we can handle\n+                    // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    self.currently_bound_lifetimes.push(lt_def.lifetime.name);\n+                }\n+\n+                hir::intravisit::walk_generic_param(self, param);\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n+                let name = match lifetime.name {\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n+                        if self.collect_elided_lifetimes {\n+                            // Use `'_` for both implicit and underscore lifetimes in\n+                            // `abstract type Foo<'_>: SomeTrait<'_>;`\n+                            hir::LifetimeName::Underscore\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    name @ hir::LifetimeName::Fresh(_) => name,\n+                    name @ hir::LifetimeName::Name(_) => name,\n+                    hir::LifetimeName::Static => return,\n+                };\n+\n+                if !self.currently_bound_lifetimes.contains(&name) {\n+                    if let Some((current_lt_name, current_lt_span)) = self.output_lifetime {\n+                        // We don't currently have a reliable way to desugar `async fn` with\n+                        // multiple potentially unrelated input lifetimes into\n+                        // `-> impl Trait + 'lt`, so we report an error in this case.\n+                        if current_lt_name != name {\n+                            struct_span_err!(\n+                                self.context.sess,\n+                                current_lt_span.between(lifetime.span),\n+                                E0703,\n+                                \"multiple different lifetimes used in arguments of `async fn`\",\n+                            )\n+                                .span_label(current_lt_span, \"first lifetime here\")\n+                                .span_label(lifetime.span, \"different lifetime here\")\n+                                .help(\"`async fn` can only accept borrowed values \\\n+                                      identical lifetimes\")\n+                                .emit()\n+                        } else if current_lt_name.is_elided() && name.is_elided() {\n+                            struct_span_err!(\n+                                self.context.sess,\n+                                current_lt_span.between(lifetime.span),\n+                                E0704,\n+                                \"multiple elided lifetimes used in arguments of `async fn`\",\n+                            )\n+                                .span_label(current_lt_span, \"first lifetime here\")\n+                                .span_label(lifetime.span, \"different lifetime here\")\n+                                .help(\"consider giving these arguments named lifetimes\")\n+                                .emit()\n+                        }\n+                    } else {\n+                        self.output_lifetime = Some((name, lifetime.span));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let bound_lifetime = {\n+            let mut lifetime_collector = AsyncFnLifetimeCollector {\n+                context: self,\n+                currently_bound_lifetimes: Vec::new(),\n+                collect_elided_lifetimes: true,\n+                output_lifetime: None,\n+            };\n+\n+            for arg in inputs {\n+                hir::intravisit::walk_ty(&mut lifetime_collector, arg);\n+            }\n+            lifetime_collector.output_lifetime\n+        };\n+\n+        let output_ty_name_owned;\n+        let (output_ty_name, span) = match output {\n+            FunctionRetTy::Ty(ty) => {\n+                output_ty_name_owned = pprust::ty_to_string(ty);\n+                (&*output_ty_name_owned, ty.span)\n+            },\n+            FunctionRetTy::Default(span) => (\"()\", *span),\n+        };\n+\n+        // FIXME(cramertj) add lifetimes (see FIXME below) to the name\n+        let exist_ty_name = Symbol::intern(&format!(\"impl Future<Output = {}>\", output_ty_name));\n+        let impl_trait_ty = self.lower_existential_impl_trait(\n+            span, fn_def_id, exist_ty_name, |this| {\n+            let output_ty = match output {\n+                FunctionRetTy::Ty(ty) =>\n+                    this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n+                FunctionRetTy::Default(span) => {\n+                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                    P(hir::Ty {\n+                        id: node_id,\n+                        hir_id: hir_id,\n+                        node: hir::TyTup(hir_vec![]),\n+                        span: *span,\n+                    })\n+                }\n+            };\n+\n+            let hir::Path { def, segments, .. } = this.std_path(span, &[\"future\", \"Future\"], false);\n+            let future_path = hir::Path {\n+                segments: segments.map_slice(|mut v| {\n+                    v.last_mut().unwrap().parameters = Some(P(hir::PathParameters {\n+                        lifetimes: hir_vec![],\n+                        types: hir_vec![],\n+                        bindings: hir_vec![hir::TypeBinding {\n+                            name: Symbol::intern(FN_OUTPUT_NAME),\n+                            ty: output_ty,\n+                            id: this.next_id().node_id,\n+                            span,\n+                        }],\n+                        parenthesized: false,\n+                    }));\n+                    v\n+                }),\n+                def, span\n+            };\n+\n+            // FIXME(cramertj) collect input lifetimes to function and add them to\n+            // the output `impl Trait` type here.\n+            let mut bounds = vec![\n+                hir::TyParamBound::TraitTyParamBound(\n+                    hir::PolyTraitRef {\n+                        trait_ref: hir::TraitRef {\n+                            path: future_path,\n+                            ref_id: this.next_id().node_id,\n+                        },\n+                        bound_generic_params: hir_vec![],\n+                        span,\n+                    },\n+                    hir::TraitBoundModifier::None\n+                ),\n+            ];\n+\n+            if let Some((name, span)) = bound_lifetime {\n+                bounds.push(hir::RegionTyParamBound(\n+                    hir::Lifetime { id: this.next_id().node_id, name, span }));\n+            }\n+\n+            hir::HirVec::from(bounds)\n+        });\n+\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let impl_trait_ty = P(hir::Ty {\n+            id: node_id,\n+            node: impl_trait_ty,\n+            span,\n+            hir_id,\n+        });\n+\n+        hir::FunctionRetTy::Return(impl_trait_ty)\n+    }\n+\n     fn lower_param_bound(\n         &mut self,\n         tpb: &GenericBound,\n@@ -2286,16 +2584,32 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n+\n                 self.with_new_scopes(|this| {\n+                    // Note: we can use non-async decl here because lower_body\n+                    // only cares about the input argument patterns,\n+                    // not the return types.\n                     let body_id = this.lower_body(Some(decl), |this| {\n-                        let body = this.lower_block(body, false);\n-                        this.expr_block(body, ThinVec::new())\n+                        if let IsAsync::Async(async_node_id) = header.asyncness {\n+                            let async_expr = this.make_async_expr(\n+                                CaptureBy::Value, async_node_id, None,\n+                                |this| {\n+                                    let body = this.lower_block(body, false);\n+                                    this.expr_block(body, ThinVec::new())\n+                                });\n+                            this.expr(body.span, async_expr, ThinVec::new())\n+                        } else {\n+                            let body = this.lower_block(body, false);\n+                            this.expr_block(body, ThinVec::new())\n+                        }\n                     });\n+\n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n-                        |this| this.lower_fn_decl(decl, Some(fn_def_id), true),\n+                        |this| this.lower_fn_decl(\n+                            decl, Some(fn_def_id), true, header.asyncness.is_async())\n                     );\n \n                     hir::ItemFn(\n@@ -2863,7 +3177,7 @@ impl<'a> LoweringContext<'a> {\n                         |this| {\n                             (\n                                 // Disallow impl Trait in foreign items\n-                                this.lower_fn_decl(fdec, None, false),\n+                                this.lower_fn_decl(fdec, None, false, false),\n                                 this.lower_fn_args_to_names(fdec),\n                             )\n                         },\n@@ -2890,7 +3204,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::MethodSig {\n         hir::MethodSig {\n             header: self.lower_fn_header(sig.header),\n-            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow),\n+            decl: self.lower_fn_decl(&sig.decl, Some(fn_def_id), impl_trait_return_allow, false),\n         }\n     }\n \n@@ -2926,7 +3240,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n         match a {\n-            IsAsync::Async => hir::IsAsync::Async,\n+            IsAsync::Async(_) => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n         }\n     }\n@@ -3218,46 +3532,101 @@ impl<'a> LoweringContext<'a> {\n                 arms.iter().map(|x| self.lower_arm(x)).collect(),\n                 hir::MatchSource::Normal,\n             ),\n-            ExprKind::Closure(capture_clause, movability, ref decl, ref body, fn_decl_span) => {\n+            ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n+                self.make_async_expr(capture_clause, closure_node_id, None, |this| {\n+                    this.with_new_scopes(|this| {\n+                        let block = this.lower_block(block, false);\n+                        this.expr_block(block, ThinVec::new())\n+                    })\n+                })\n+            },\n+            ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span) =>\n+            {\n                 self.with_new_scopes(|this| {\n-                    let mut is_generator = false;\n-                    let body_id = this.lower_body(Some(decl), |this| {\n-                        let e = this.lower_expr(body);\n-                        is_generator = this.is_generator;\n-                        e\n-                    });\n-                    let generator_option = if is_generator {\n-                        if !decl.inputs.is_empty() {\n-                            span_err!(\n+                    if let IsAsync::Async(async_closure_node_id) = asyncness {\n+                        // FIXME(cramertj) allow `async` non-`move` closures with\n+                        if capture_clause == CaptureBy::Ref &&\n+                            !decl.inputs.is_empty()\n+                        {\n+                            struct_span_err!(\n                                 this.sess,\n                                 fn_decl_span,\n-                                E0628,\n-                                \"generators cannot have explicit arguments\"\n-                            );\n-                            this.sess.abort_if_errors();\n+                                E0705,\n+                                \"`async` non-`move` closures with arguments \\\n+                                are not currently supported\",\n+                            )\n+                                .help(\"consider using `let` statements to manually capture \\\n+                                        variables by reference before entering an \\\n+                                        `async move` closure\")\n+                                .emit();\n                         }\n-                        Some(match movability {\n-                            Movability::Movable => hir::GeneratorMovability::Movable,\n-                            Movability::Static => hir::GeneratorMovability::Static,\n-                        })\n+\n+                        // Transform `async |x: u8| -> X { ... }` into\n+                        // `|x: u8| future_from_generator(|| -> X { ... })`\n+                        let outer_decl = FnDecl {\n+                            inputs: decl.inputs.clone(),\n+                            output: FunctionRetTy::Default(fn_decl_span),\n+                            variadic: false,\n+                        };\n+                        let body_id = this.lower_body(Some(&outer_decl), |this| {\n+                            let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n+                                Some(&**ty)\n+                            } else { None };\n+                            let async_body = this.make_async_expr(\n+                                capture_clause, async_closure_node_id, async_ret_ty,\n+                                |this| {\n+                                    this.with_new_scopes(|this| this.lower_expr(body))\n+                                });\n+                            this.expr(fn_decl_span, async_body, ThinVec::new())\n+                        });\n+                        hir::ExprClosure(\n+                            this.lower_capture_clause(capture_clause),\n+                            this.lower_fn_decl(&outer_decl, None, false, false),\n+                            body_id,\n+                            fn_decl_span,\n+                            None,\n+                        )\n                     } else {\n-                        if movability == Movability::Static {\n-                            span_err!(\n-                                this.sess,\n-                                fn_decl_span,\n-                                E0697,\n-                                \"closures cannot be static\"\n-                            );\n-                        }\n-                        None\n-                    };\n-                    hir::ExprClosure(\n-                        this.lower_capture_clause(capture_clause),\n-                        this.lower_fn_decl(decl, None, false),\n-                        body_id,\n-                        fn_decl_span,\n-                        generator_option,\n-                    )\n+                        let mut is_generator = false;\n+                        let body_id = this.lower_body(Some(decl), |this| {\n+                            let e = this.lower_expr(body);\n+                            is_generator = this.is_generator;\n+                            e\n+                        });\n+                        let generator_option = if is_generator {\n+                            if !decl.inputs.is_empty() {\n+                                span_err!(\n+                                    this.sess,\n+                                    fn_decl_span,\n+                                    E0628,\n+                                    \"generators cannot have explicit arguments\"\n+                                );\n+                                this.sess.abort_if_errors();\n+                            }\n+                            Some(match movability {\n+                                Movability::Movable => hir::GeneratorMovability::Movable,\n+                                Movability::Static => hir::GeneratorMovability::Static,\n+                            })\n+                        } else {\n+                            if movability == Movability::Static {\n+                                span_err!(\n+                                    this.sess,\n+                                    fn_decl_span,\n+                                    E0906,\n+                                    \"closures cannot be static\"\n+                                );\n+                            }\n+                            None\n+                        };\n+                        hir::ExprClosure(\n+                            this.lower_capture_clause(capture_clause),\n+                            this.lower_fn_decl(decl, None, false, false),\n+                            body_id,\n+                            fn_decl_span,\n+                            generator_option,\n+                        )\n+                    }\n                 })\n             }\n             ExprKind::Block(ref blk, opt_label) => {"}, {"sha": "335e38bbe7e220b7cdee577594ed4f0e26b92762", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -99,6 +99,21 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n+            ItemKind::Fn(_, FnHeader { asyncness: IsAsync::Async(async_node_id), .. }, ..) => {\n+                // For async functions, we need to create their inner defs inside of a\n+                // closure to match their desugared representation.\n+                let fn_def_data = DefPathData::ValueNs(i.ident.name.as_interned_str());\n+                let fn_def = self.create_def(i.id, fn_def_data, ITEM_LIKE_SPACE, i.span);\n+                return self.with_parent(fn_def, |this| {\n+                    let closure_def = this.create_def(async_node_id,\n+                                          DefPathData::ClosureExpr,\n+                                          REGULAR_SPACE,\n+                                          i.span);\n+                    this.with_parent(closure_def, |this| {\n+                        visit::walk_item(this, i);\n+                    })\n+                });\n+            }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_interned_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_interned_str()),\n@@ -227,15 +242,32 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(..) => {\n-                let def = self.create_def(expr.id,\n+            ExprKind::Closure(_, asyncness, ..) => {\n+                let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           REGULAR_SPACE,\n                                           expr.span);\n-                self.parent_def = Some(def);\n+                self.parent_def = Some(closure_def);\n+\n+                // Async closures desugar to closures inside of closures, so\n+                // we must create two defs.\n+                if let IsAsync::Async(async_id) = asyncness {\n+                    let async_def = self.create_def(async_id,\n+                                                    DefPathData::ClosureExpr,\n+                                                    REGULAR_SPACE,\n+                                                    expr.span);\n+                    self.parent_def = Some(async_def);\n+                }\n+            }\n+            ExprKind::Async(_, async_id, _) => {\n+                let async_def = self.create_def(async_id,\n+                                                DefPathData::ClosureExpr,\n+                                                REGULAR_SPACE,\n+                                                expr.span);\n+                self.parent_def = Some(async_def);\n             }\n             _ => {}\n-        }\n+        };\n \n         visit::walk_expr(self, expr);\n         self.parent_def = parent_def;"}, {"sha": "bd6bef29c29decca84acbda1e0d4d588454027bc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -245,6 +245,16 @@ pub enum LifetimeName {\n }\n \n impl LifetimeName {\n+    pub fn is_elided(self) -> bool {\n+        match self {\n+            LifetimeName::Implicit\n+            | LifetimeName::Underscore => true,\n+            LifetimeName::Fresh(_)\n+            | LifetimeName::Static\n+            | LifetimeName::Name(_) => false,\n+        }\n+    }\n+\n     pub fn name(&self) -> Name {\n         use self::LifetimeName::*;\n         match *self {"}, {"sha": "0f4603be39d326612d3a782abd69613853cc4ffd", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -409,6 +409,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    Async,\n     DotFill,\n     QuestionMark,\n     ExistentialReturnType,"}, {"sha": "ce270006a9d0ad187d1a1e213363238804dbc545", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -1245,7 +1245,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                         (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-                    if needs_inline || header.constness == hir::Constness::Const || always_encode_mir {\n+                    if needs_inline\n+                        || header.constness == hir::Constness::Const\n+                        || always_encode_mir\n+                    {\n                         self.encode_optimized_mir(def_id)\n                     } else {\n                         None"}, {"sha": "d3c1929159414a8f19e73ee38458954926c22d30", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -55,7 +55,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n-use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind, FnHeader};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n@@ -2054,13 +2054,54 @@ impl<'a> Resolver<'a> {\n         self.check_proc_macro_attrs(&item.attrs);\n \n         match item.node {\n+            ItemKind::Fn(ref declaration,\n+                         FnHeader { asyncness: IsAsync::Async(async_closure_id), .. },\n+                         ref generics,\n+                         ref body) => {\n+                // Async functions are desugared from `async fn foo() { .. }`\n+                // to `fn foo() { future_from_generator(move || ... ) }`,\n+                // so we have to visit the body inside the closure scope\n+                self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n+                    this.visit_vis(&item.vis);\n+                    this.visit_ident(item.ident);\n+                    this.visit_generics(generics);\n+                    let rib_kind = ItemRibKind;\n+                    this.ribs[ValueNS].push(Rib::new(rib_kind));\n+                    this.label_ribs.push(Rib::new(rib_kind));\n+                    let mut bindings_list = FxHashMap();\n+                    for argument in &declaration.inputs {\n+                        this.resolve_pattern(\n+                            &argument.pat, PatternSource::FnParam, &mut bindings_list);\n+                        this.visit_ty(&*argument.ty);\n+                    }\n+                    visit::walk_fn_ret_ty(this, &declaration.output);\n+\n+                    // Now resolve the inner closure\n+                    {\n+                        let rib_kind = ClosureRibKind(async_closure_id);\n+                        this.ribs[ValueNS].push(Rib::new(rib_kind));\n+                        this.label_ribs.push(Rib::new(rib_kind));\n+                        // No need to resolve either arguments nor return type,\n+                        // as this closure has neither\n+\n+                        // Resolve the body\n+                        this.visit_block(body);\n+                        this.label_ribs.pop();\n+                        this.ribs[ValueNS].pop();\n+                    }\n+                    this.label_ribs.pop();\n+                    this.ribs[ValueNS].pop();\n+\n+                    walk_list!(this, visit_attribute, &item.attrs);\n+                })\n+            }\n             ItemKind::Enum(_, ref generics) |\n             ItemKind::Ty(_, ref generics) |\n             ItemKind::Struct(_, ref generics) |\n             ItemKind::Union(_, ref generics) |\n-            ItemKind::Fn(.., ref generics, _) => {\n+            ItemKind::Fn(_, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind),\n-                                             |this| visit::walk_item(this, item));\n+                                         |this| visit::walk_item(this, item));\n             }\n \n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n@@ -3888,6 +3929,49 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n                 self.current_type_ascription.pop();\n             }\n+            // Resolve the body of async exprs inside the async closure to which they desugar\n+            ExprKind::Async(_, async_closure_id, ref block) => {\n+                let rib_kind = ClosureRibKind(async_closure_id);\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                self.label_ribs.push(Rib::new(rib_kind));\n+                self.visit_block(&block);\n+                self.label_ribs.pop();\n+                self.ribs[ValueNS].pop();\n+            }\n+            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n+            // resolve the arguments within the proper scopes so that usages of them inside the\n+            // closure are detected as upvars rather than normal closure arg usages.\n+            ExprKind::Closure(\n+                _, IsAsync::Async(inner_closure_id), _, ref fn_decl, ref body, _span) =>\n+            {\n+                let rib_kind = ClosureRibKind(expr.id);\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                self.label_ribs.push(Rib::new(rib_kind));\n+                // Resolve arguments:\n+                let mut bindings_list = FxHashMap();\n+                for argument in &fn_decl.inputs {\n+                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+                    self.visit_ty(&argument.ty);\n+                }\n+                // No need to resolve return type-- the outer closure return type is\n+                // FunctionRetTy::Default\n+\n+                // Now resolve the inner closure\n+                {\n+                    let rib_kind = ClosureRibKind(inner_closure_id);\n+                    self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                    self.label_ribs.push(Rib::new(rib_kind));\n+                    // No need to resolve arguments: the inner closure has none.\n+                    // Resolve the return type:\n+                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n+                    // Resolve the body\n+                    self.visit_expr(body);\n+                    self.label_ribs.pop();\n+                    self.ribs[ValueNS].pop();\n+                }\n+                self.label_ribs.pop();\n+                self.ribs[ValueNS].pop();\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "262c0e40abc549788d487b01c192a83e6bdbfd33", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -1555,7 +1555,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     }\n                 }\n             }\n-            ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {\n+            ast::ExprKind::Closure(_, _, _, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());\n "}, {"sha": "9f2ca20276cdc00910a12e149932f41fc88fb0cc", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -385,7 +385,7 @@ impl Sig for ast::Item {\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");\n                 }\n-                if header.asyncness == ast::IsAsync::Async {\n+                if header.asyncness.is_async() {\n                     text.push_str(\"async \");\n                 }\n                 if header.unsafety == ast::Unsafety::Unsafe {\n@@ -920,7 +920,7 @@ fn make_method_signature(\n     if m.header.constness.node == ast::Constness::Const {\n         text.push_str(\"const \");\n     }\n-    if m.header.asyncness == ast::IsAsync::Async {\n+    if m.header.asyncness.is_async() {\n         text.push_str(\"async \");\n     }\n     if m.header.unsafety == ast::Unsafety::Unsafe {"}, {"sha": "f149a9fe57140637b649cba5b9c1b76ac10670ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -1164,7 +1164,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, _, _, ref generics, _) = item.node {\n+                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,"}, {"sha": "a0f29f5918e1e7c81f059253188780f262960afa", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -2585,7 +2585,8 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it)?)?;\n     render_attributes(w, it)?;\n     write!(w,\n-           \"{vis}{constness}{asyncness}{unsafety}{abi}fn {name}{generics}{decl}{where_clause}</pre>\",\n+           \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n+           {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n            constness = ConstnessSpace(f.header.constness),\n            asyncness = AsyncSpace(f.header.asyncness),"}, {"sha": "c74cd3feca341c65d61632db60943698c95d8f00", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -263,6 +263,7 @@\n #![feature(fn_traits)]\n #![feature(fnbox)]\n #![feature(futures_api)]\n+#![feature(generator_trait)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n@@ -410,8 +411,6 @@ pub use core::ops;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::raw;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::option;\n@@ -496,6 +495,7 @@ pub mod os;\n pub mod panic;\n pub mod path;\n pub mod process;\n+pub mod raw;\n pub mod sync;\n pub mod time;\n "}, {"sha": "812b0b9fdda4726790baedb9ffc68bedd958c6e2", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -213,6 +213,26 @@ macro_rules! eprintln {\n     ($fmt:expr, $($arg:tt)*) => (eprint!(concat!($fmt, \"\\n\"), $($arg)*));\n }\n \n+#[macro_export]\n+#[unstable(feature = \"await_macro\", issue = \"50547\")]\n+#[allow_internal_unstable]\n+macro_rules! await {\n+    ($e:expr) => { {\n+        let mut pinned = $e;\n+        let mut pinned = unsafe { ::core::mem::PinMut::new_unchecked(&mut pinned) };\n+        loop {\n+            match ::std::raw::with_get_cx(|cx|\n+                      ::core::future::Future::poll(pinned.reborrow(), cx))\n+            {\n+                // FIXME(cramertj) prior to stabilizing await, we have to ensure that this\n+                // can't be used to create a generator on stable via `|| await!()`.\n+                ::core::task::Poll::Pending => yield,\n+                ::core::task::Poll::Ready(x) => break x,\n+            }\n+        }\n+    } }\n+}\n+\n /// A macro to select an event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of"}, {"sha": "62fd42c4de7afe9b784d5c0607c74adf66ba33e8", "filename": "src/libstd/raw.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibstd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fraw.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_docs)]\n+#![unstable(feature = \"raw\", issue = \"27751\")]\n+\n+//! Contains struct definitions for the layout of compiler built-in types.\n+//!\n+//! They can be used as targets of transmutes in unsafe code for manipulating\n+//! the raw representations directly.\n+//!\n+//! Their definition should always match the ABI defined in `rustc::back::abi`.\n+\n+use core::cell::Cell;\n+use core::future::Future;\n+use core::marker::Unpin;\n+use core::mem::PinMut;\n+use core::option::Option;\n+use core::ptr::NonNull;\n+use core::task::{self, Poll};\n+use core::ops::{Drop, Generator, GeneratorState};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::raw::*;\n+\n+/// Wrap a future in a generator.\n+///\n+/// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n+/// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+pub fn future_from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n+    GenFuture(x)\n+}\n+\n+/// A wrapper around generators used to implement `Future` for `async`/`await` code.\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+struct GenFuture<T: Generator<Yield = ()>>(T);\n+\n+// We rely on the fact that async/await futures are immovable in order to create\n+// self-referential borrows in the underlying generator.\n+impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n+    type Output = T::Return;\n+    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        with_set_cx(cx, || match unsafe { PinMut::get_mut(self).0.resume() } {\n+            GeneratorState::Yielded(()) => Poll::Pending,\n+            GeneratorState::Complete(x) => Poll::Ready(x),\n+        })\n+    }\n+}\n+\n+thread_local! {\n+    static TLS_CX: Cell<Option<NonNull<task::Context<'static>>>> = Cell::new(None);\n+}\n+\n+struct SetOnDrop(Option<NonNull<task::Context<'static>>>);\n+\n+impl Drop for SetOnDrop {\n+    fn drop(&mut self) {\n+        TLS_CX.with(|tls_cx| {\n+            tls_cx.set(self.0.take());\n+        });\n+    }\n+}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+pub fn with_set_cx<F, R>(cx: &mut task::Context, f: F) -> R\n+where\n+    F: FnOnce() -> R\n+{\n+    let old_cx = TLS_CX.with(|tls_cx| {\n+        let old_cx = tls_cx.get();\n+        tls_cx.set(NonNull::new(\n+                cx as *mut task::Context as *mut () as *mut task::Context<'static>));\n+        old_cx\n+    });\n+    let _reset_cx = SetOnDrop(old_cx);\n+    let res = f();\n+    res\n+}\n+\n+#[unstable(feature = \"gen_future\", issue = \"50547\")]\n+pub fn with_get_cx<F, R>(f: F) -> R\n+where\n+    F: FnOnce(&mut task::Context) -> R\n+{\n+    let cx_ptr = TLS_CX.with(|tls_cx| {\n+        let cx_ptr = tls_cx.get();\n+        // Clear the entry so that nested `with_get_cx` calls\n+        // will fail or set their own value.\n+        tls_cx.set(None);\n+        cx_ptr\n+    });\n+    let _reset_cx = SetOnDrop(cx_ptr);\n+\n+    let mut cx_ptr = cx_ptr.expect(\n+        \"TLS task::Context not set. This is a rustc bug. \\\n+        Please file an issue on https://github.com/rust-lang/rust.\");\n+    unsafe { f(cx_ptr.as_mut()) }\n+}"}, {"sha": "a57a9b95e5f776f3ad616aec9bc8de95cd7573a5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -987,6 +987,7 @@ impl Expr {\n             ExprKind::Closure(..) => ExprPrecedence::Closure,\n             ExprKind::Block(..) => ExprPrecedence::Block,\n             ExprKind::Catch(..) => ExprPrecedence::Catch,\n+            ExprKind::Async(..) => ExprPrecedence::Async,\n             ExprKind::Assign(..) => ExprPrecedence::Assign,\n             ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n             ExprKind::Field(..) => ExprPrecedence::Field,\n@@ -1094,9 +1095,18 @@ pub enum ExprKind {\n     /// A closure (for example, `move |a, b, c| a + b + c`)\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    Closure(CaptureBy, Movability, P<FnDecl>, P<Expr>, Span),\n+    Closure(CaptureBy, IsAsync, Movability, P<FnDecl>, P<Expr>, Span),\n     /// A block (`'label: { ... }`)\n     Block(P<Block>, Option<Label>),\n+    /// An async block (`async move { ... }`)\n+    ///\n+    /// The `NodeId` is the `NodeId` for the closure that results from\n+    /// desugaring an async block, just like the NodeId field in the\n+    /// `IsAsync` enum. This is necessary in order to create a def for the\n+    /// closure which can be used as a parent of any child defs. Defs\n+    /// created during lowering cannot be made the parent of any other\n+    /// preexisting defs.\n+    Async(CaptureBy, NodeId, P<Block>),\n     /// A catch block (`catch { ... }`)\n     Catch(P<Block>),\n \n@@ -1708,10 +1718,20 @@ pub enum Unsafety {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum IsAsync {\n-    Async,\n+    Async(NodeId),\n     NotAsync,\n }\n \n+impl IsAsync {\n+    pub fn is_async(self) -> bool {\n+        if let IsAsync::Async(_) = self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Constness {\n     Const,"}, {"sha": "6135650766569ece2945ac5c94e56f9feb9da821", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -915,6 +915,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                       fn_decl_span: Span) // span of the `|...|` part\n                       -> P<ast::Expr> {\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::IsAsync::NotAsync,\n                                                ast::Movability::Movable,\n                                                fn_decl,\n                                                body,\n@@ -935,6 +936,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         // the entire lambda body. Probably we should extend the API\n         // here, but that's not entirely clear.\n         self.expr(span, ast::ExprKind::Closure(ast::CaptureBy::Ref,\n+                                               ast::IsAsync::NotAsync,\n                                                ast::Movability::Movable,\n                                                fn_decl,\n                                                body,"}, {"sha": "ccb2f51f9641bd0d3a11c669b9e2e492bdacb7ed", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -308,7 +308,7 @@ declare_features! (\n     // Declarative macros 2.0 (`macro`).\n     (active, decl_macro, \"1.17.0\", Some(39412), None),\n \n-    // Allows #[link(kind=\"static-nobundle\"...]\n+    // Allows #[link(kind=\"static-nobundle\"...)]\n     (active, static_nobundle, \"1.16.0\", Some(37403), None),\n \n     // `extern \"msp430-interrupt\" fn()`\n@@ -474,7 +474,7 @@ declare_features! (\n     (active, doc_keyword, \"1.28.0\", Some(51315), None),\n \n     // Allows async and await syntax\n-    (active, async_await, \"1.28.0\", Some(0), Some(Edition::Edition2018)),\n+    (active, async_await, \"1.28.0\", Some(50547), None),\n );\n \n declare_features! (\n@@ -1722,6 +1722,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"labels on blocks are unstable\");\n                 }\n             }\n+            ast::ExprKind::Closure(_, ast::IsAsync::Async(_), ..) => {\n+                gate_feature_post!(&self, async_await, e.span, \"async closures are unstable\");\n+            }\n+            ast::ExprKind::Async(..) => {\n+                gate_feature_post!(&self, async_await, e.span, \"async blocks are unstable\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -1764,7 +1770,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match fn_kind {\n             FnKind::ItemFn(_, header, _, _) => {\n                 // check for const fn and async fn declarations\n-                if header.asyncness == ast::IsAsync::Async {\n+                if header.asyncness.is_async() {\n                     gate_feature_post!(&self, async_await, span, \"async fn is unstable\");\n                 }\n                 if header.constness.node == ast::Constness::Const {"}, {"sha": "ffea713f4ec76a359082178993b6fa09e1b5796e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -76,6 +76,10 @@ pub trait Folder : Sized {\n         noop_fold_item_simple(i, self)\n     }\n \n+    fn fold_fn_header(&mut self, header: FnHeader) -> FnHeader {\n+        noop_fold_fn_header(header, self)\n+    }\n+\n     fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n@@ -883,6 +887,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n         }\n         ItemKind::Fn(decl, header, generics, body) => {\n             let generics = folder.fold_generics(generics);\n+            let header = folder.fold_fn_header(header);\n             let decl = folder.fold_fn_decl(decl);\n             let body = folder.fold_block(body);\n             ItemKind::Fn(decl, header, generics, body)\n@@ -990,6 +995,14 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n     })\n }\n \n+pub fn noop_fold_fn_header<T: Folder>(mut header: FnHeader, folder: &mut T) -> FnHeader {\n+    header.asyncness = match header.asyncness {\n+        IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n+        IsAsync::NotAsync => IsAsync::NotAsync,\n+    };\n+    header\n+}\n+\n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n@@ -1082,7 +1095,7 @@ pub fn noop_fold_foreign_item_simple<T: Folder>(ni: ForeignItem, folder: &mut T)\n \n pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n     MethodSig {\n-        header: sig.header,\n+        header: folder.fold_fn_header(sig.header),\n         decl: folder.fold_fn_decl(sig.decl)\n     }\n }\n@@ -1235,8 +1248,13 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Match(folder.fold_expr(expr),\n                           arms.move_map(|x| folder.fold_arm(x)))\n             }\n-            ExprKind::Closure(capture_clause, movability, decl, body, span) => {\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, span) => {\n+                let asyncness = match asyncness {\n+                    IsAsync::Async(node_id) => IsAsync::Async(folder.new_id(node_id)),\n+                    IsAsync::NotAsync => IsAsync::NotAsync,\n+                };\n                 ExprKind::Closure(capture_clause,\n+                                  asyncness,\n                                   movability,\n                                   folder.fold_fn_decl(decl),\n                                   folder.fold_expr(body),\n@@ -1246,6 +1264,9 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::Block(folder.fold_block(blk),\n                                 opt_label.map(|label| folder.fold_label(label)))\n             }\n+            ExprKind::Async(capture_clause, node_id, body) => {\n+                ExprKind::Async(capture_clause, folder.new_id(node_id), folder.fold_block(body))\n+            }\n             ExprKind::Assign(el, er) => {\n                 ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n             }"}, {"sha": "e5ac0b8ed7cf28a9186af7cdb2b061ca42a4ae24", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -43,7 +43,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n-use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP};\n+use syntax_pos::{self, Span, MultiSpan, BytePos, FileName, DUMMY_SP, edition::Edition};\n use errors::{self, Applicability, DiagnosticBuilder};\n use parse::{self, SeqSep, classify, token};\n use parse::lexer::TokenAndSpan;\n@@ -2258,6 +2258,15 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n+                if syntax_pos::hygiene::default_edition() >= Edition::Edition2018 &&\n+                    self.check_keyword(keywords::Async)\n+                {\n+                    if self.is_async_block() { // check for `async {` and `async move {`\n+                        return self.parse_async_block(attrs);\n+                    } else {\n+                        return self.parse_lambda_expr(attrs);\n+                    }\n+                }\n                 if self.check_keyword(keywords::Move) || self.check_keyword(keywords::Static) {\n                     return self.parse_lambda_expr(attrs);\n                 }\n@@ -3252,6 +3261,13 @@ impl<'a> Parser<'a> {\n         } else {\n             Movability::Movable\n         };\n+        let asyncness = if syntax_pos::hygiene::default_edition() >= Edition::Edition2018\n+            && self.eat_keyword(keywords::Async)\n+        {\n+            IsAsync::Async(ast::DUMMY_NODE_ID)\n+        } else {\n+            IsAsync::NotAsync\n+        };\n         let capture_clause = if self.eat_keyword(keywords::Move) {\n             CaptureBy::Value\n         } else {\n@@ -3274,7 +3290,7 @@ impl<'a> Parser<'a> {\n \n         Ok(self.mk_expr(\n             lo.to(body.span),\n-            ExprKind::Closure(capture_clause, movability, decl, body, lo.to(decl_hi)),\n+            ExprKind::Closure(capture_clause, asyncness, movability, decl, body, lo.to(decl_hi)),\n             attrs))\n     }\n \n@@ -3352,6 +3368,24 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(span, ExprKind::Loop(body, opt_label), attrs))\n     }\n \n+    /// Parse an `async move {...}` expression\n+    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>)\n+        -> PResult<'a, P<Expr>>\n+    {\n+        let span_lo = self.span;\n+        self.expect_keyword(keywords::Async)?;\n+        let capture_clause = if self.eat_keyword(keywords::Move) {\n+            CaptureBy::Value\n+        } else {\n+            CaptureBy::Ref\n+        };\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        Ok(self.mk_expr(\n+            span_lo.to(body.span),\n+            ExprKind::Async(capture_clause, ast::DUMMY_NODE_ID, body), attrs))\n+    }\n+\n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)\n     fn parse_catch_expr(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)\n         -> PResult<'a, P<Expr>>\n@@ -4286,6 +4320,18 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn is_async_block(&mut self) -> bool {\n+        self.token.is_keyword(keywords::Async) &&\n+        (\n+            ( // `async move {`\n+                self.look_ahead(1, |t| t.is_keyword(keywords::Move)) &&\n+                self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n+            ) || ( // `async {`\n+                self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            )\n+        )\n+    }\n+\n     fn is_catch_expr(&mut self) -> bool {\n         self.token.is_keyword(keywords::Do) &&\n         self.look_ahead(1, |t| t.is_keyword(keywords::Catch)) &&\n@@ -6698,14 +6744,18 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        if self.eat_keyword(keywords::Async) {\n+        if self.check_keyword(keywords::Async) &&\n+            (self.look_ahead(1, |t| t.is_keyword(keywords::Fn)) ||\n+             self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe)))\n+        {\n             // ASYNC FUNCTION ITEM\n+            self.expect_keyword(keywords::Async)?;\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(keywords::Fn)?;\n             let fn_span = self.prev_span;\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(unsafety,\n-                                   IsAsync::Async,\n+                                   IsAsync::Async(ast::DUMMY_NODE_ID),\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;"}, {"sha": "743d36d8db5565cd0717d6502aeb53fe3862a1cd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -2171,8 +2171,10 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n-            ast::ExprKind::Closure(capture_clause, movability, ref decl, ref body, _) => {\n+            ast::ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n+                self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(decl)?;\n@@ -2196,6 +2198,12 @@ impl<'a> State<'a> {\n                 self.ibox(0)?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n+            ast::ExprKind::Async(capture_clause, _, ref blk) => {\n+                self.word_nbsp(\"async\")?;\n+                self.print_capture_clause(capture_clause)?;\n+                self.s.space()?;\n+                self.print_block_with_attrs(blk, attrs)?;\n+            }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1)?;\n@@ -2792,6 +2800,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+                                -> io::Result<()> {\n+        if asyncness.is_async() {\n+            self.word_nbsp(\"async\")?;\n+        }\n+        Ok(())\n+    }\n+\n     pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n                                 -> io::Result<()> {\n         match capture_clause {\n@@ -3122,11 +3138,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        match header.asyncness {\n-            ast::IsAsync::NotAsync => {}\n-            ast::IsAsync::Async => self.word_nbsp(\"async\")?\n-        }\n-\n+        self.print_asyncness(header.asyncness)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {"}, {"sha": "ed10857e4c56e81f470b6efe781d9d4dcb059b82", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -95,6 +95,16 @@ impl<T: 'static> P<T> {\n     }\n }\n \n+impl<T: 'static> P<[T]> {\n+    pub fn map_slice<F>(self, f: F) -> P<[T]> where\n+        F: FnOnce(Vec<T>) -> Vec<T>\n+    {\n+        P {\n+            ptr: f(self.ptr.into()).into(),\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Deref for P<T> {\n     type Target = T;\n "}, {"sha": "7722558514197cfc86faafb859afe267f87f33a1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -127,11 +127,17 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                 ast::ItemKind::Fn(_, header, _, _) => {\n                     if header.unsafety == ast::Unsafety::Unsafe {\n                         let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\").raise();\n+                        diag.span_fatal(\n+                            i.span,\n+                            \"unsafe functions cannot be used for tests\"\n+                        ).raise();\n                     }\n-                    if header.asyncness == ast::IsAsync::Async {\n+                    if header.asyncness.is_async() {\n                         let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(i.span, \"async functions cannot be used for tests\").raise();\n+                        diag.span_fatal(\n+                            i.span,\n+                            \"async functions cannot be used for tests\"\n+                        ).raise();\n                     }\n                 }\n                 _ => {},"}, {"sha": "15d910b33b064c9a3a37ca59b70421d965b0c930", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -277,6 +277,7 @@ pub enum ExprPrecedence {\n     Block,\n     Catch,\n     Struct,\n+    Async,\n }\n \n impl PartialOrd for ExprPrecedence {\n@@ -346,6 +347,7 @@ impl ExprPrecedence {\n             ExprPrecedence::Match |\n             ExprPrecedence::Block |\n             ExprPrecedence::Catch |\n+            ExprPrecedence::Async |\n             ExprPrecedence::Struct => PREC_PAREN,\n         }\n     }"}, {"sha": "41e3ad9d4f4b1c944d9e122b83f508c2c91b86e2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -235,7 +235,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n         }\n         ItemKind::Fn(ref declaration, header, ref generics, ref body) => {\n             visitor.visit_generics(generics);\n-            visitor.visit_fn(FnKind::ItemFn(item.ident, header, \n+            visitor.visit_fn(FnKind::ItemFn(item.ident, header,\n                                             &item.vis, body),\n                              declaration,\n                              item.span,\n@@ -735,7 +735,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprKind::Closure(_, _, ref function_declaration, ref body, _decl_span) => {\n+        ExprKind::Closure(_, _, _, ref function_declaration, ref body, _decl_span) => {\n             visitor.visit_fn(FnKind::Closure(body),\n                              function_declaration,\n                              expression.span,\n@@ -745,6 +745,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             walk_list!(visitor, visit_label, opt_label);\n             visitor.visit_block(block);\n         }\n+        ExprKind::Async(_, _, ref body) => {\n+            visitor.visit_block(body);\n+        }\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);"}, {"sha": "0ca42169b8ec5bbd18bd2d7df9c4a49e8b40c8a7", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -493,12 +493,14 @@ pub enum CompilerDesugaringKind {\n     /// to an `existential type Foo: Trait;` + replacing the\n     /// `impl Trait` with `Foo`.\n     ExistentialReturnType,\n+    Async,\n }\n \n impl CompilerDesugaringKind {\n     pub fn as_symbol(&self) -> Symbol {\n         use CompilerDesugaringKind::*;\n         let s = match *self {\n+            Async => \"async\",\n             DotFill => \"...\",\n             QuestionMark => \"?\",\n             Catch => \"do catch\","}, {"sha": "6b2c01f57694229dd437a87025b0b28173578282", "filename": "src/test/run-pass/async-await.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+use std::boxed::PinBox;\n+use std::mem::PinMut;\n+use std::future::Future;\n+use std::sync::{\n+    Arc,\n+    atomic::{self, AtomicUsize},\n+};\n+use std::task::{\n+    Context, Poll, Wake,\n+    Executor, TaskObj, SpawnObjError,\n+    local_waker_from_nonlocal,\n+};\n+\n+struct Counter {\n+    wakes: AtomicUsize,\n+}\n+\n+impl Wake for Counter {\n+    fn wake(this: &Arc<Self>) {\n+        this.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+}\n+\n+struct NoopExecutor;\n+impl Executor for NoopExecutor {\n+    fn spawn_obj(&mut self, _: TaskObj) -> Result<(), SpawnObjError> {\n+        Ok(())\n+    }\n+}\n+\n+struct WakeOnceThenComplete(bool);\n+\n+fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n+\n+impl Future for WakeOnceThenComplete {\n+    type Output = ();\n+    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+        if self.0 {\n+            Poll::Ready(())\n+        } else {\n+            cx.waker().wake();\n+            self.0 = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+fn async_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(wake_and_yield_once());\n+        x\n+    }\n+}\n+\n+fn async_nonmove_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        let future = async {\n+            await!(wake_and_yield_once());\n+            x\n+        };\n+        await!(future)\n+    }\n+}\n+\n+fn async_closure(x: u8) -> impl Future<Output = u8> {\n+    (async move |x: u8| -> u8 {\n+        await!(wake_and_yield_once());\n+        x\n+    })(x)\n+}\n+\n+async fn async_fn(x: u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+async fn async_fn_with_borrow(x: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(async_fn_with_borrow(&y))\n+    }\n+}\n+\n+fn test_future_yields_once_then_returns<F, Fut>(f: F)\n+where\n+    F: FnOnce(u8) -> Fut,\n+    Fut: Future<Output = u8>,\n+{\n+    let mut fut = PinBox::new(f(9));\n+    let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n+    let waker = local_waker_from_nonlocal(counter.clone());\n+    let executor = &mut NoopExecutor;\n+    let cx = &mut Context::new(&waker, executor);\n+\n+    assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Pending, fut.as_pin_mut().poll(cx));\n+    assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Ready(9), fut.as_pin_mut().poll(cx));\n+}\n+\n+fn main() {\n+    macro_rules! test {\n+        ($($fn_name:ident,)*) => { $(\n+            test_future_yields_once_then_returns($fn_name);\n+        )* }\n+    }\n+\n+    test! {\n+        async_block,\n+        async_nonmove_block,\n+        async_closure,\n+        async_fn,\n+        async_fn_with_internal_borrow,\n+    }\n+}"}, {"sha": "ce062ded7f73f03ddb7f9a619823424a23ac3d8f", "filename": "src/test/ui/async-fn-multiple-lifetimes.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+use std::ops::Add;\n+\n+async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n+//~^ ERROR multiple different lifetimes used in arguments of `async fn`\n+\n+async fn multiple_hrtb_and_single_named_lifetime_ok<'c>(\n+    _: impl for<'a> Add<&'a u8>,\n+    _: impl for<'b> Add<&'b u8>,\n+    _: &'c u8,\n+) {}\n+\n+async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+//~^ ERROR multiple elided lifetimes used\n+//~^^ ERROR missing lifetime specifier\n+\n+fn main() {}"}, {"sha": "227dd4483f2bf1e1db899fdee30753d5792a1199", "filename": "src/test/ui/async-fn-multiple-lifetimes.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-multiple-lifetimes.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,32 @@\n+error[E0703]: multiple different lifetimes used in arguments of `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:17:49\n+   |\n+LL | async fn multiple_named_lifetimes<'a, 'b>(_: &'a u8, _: &'b u8) {}\n+   |                                               --^^^^^^^^^-- different lifetime here\n+   |                                               |\n+   |                                               first lifetime here\n+   |\n+   = help: `async fn` can only accept borrowed values identical lifetimes\n+\n+error[E0704]: multiple elided lifetimes used in arguments of `async fn`\n+  --> $DIR/async-fn-multiple-lifetimes.rs:26:39\n+   |\n+LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+   |                                       -^^^^^^^- different lifetime here\n+   |                                       |\n+   |                                       first lifetime here\n+   |\n+   = help: consider giving these arguments named lifetimes\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/async-fn-multiple-lifetimes.rs:26:39\n+   |\n+LL | async fn multiple_elided_lifetimes(_: &u8, _: &u8) {}\n+   |                                       ^ expected lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `_` or `_`\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0106, E0703, E0704.\n+For more information about an error, try `rustc --explain E0106`."}, {"sha": "02dc8c8795675c34313c00a516449075e0eb0a20", "filename": "src/test/ui/edition-keywords-2018-2015-parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -25,7 +25,7 @@ pub fn check_async() {\n     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n     r#async = consumes_async_raw!(r#async); // OK\n \n-    if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n+    if passes_ident!(async) == 1 {}\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found reserved keyword `async`\n     module::r#async(); // OK"}, {"sha": "ceab5ea730ea88ee41ec45245fad64da2b84ecdb", "filename": "src/test/ui/edition-keywords-2018-2015-parsing.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2015-parsing.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -22,11 +22,11 @@ error: no rules expected the token `async`\n LL |     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n    |                                   ^^^^^\n \n-error: expected expression, found reserved keyword `async`\n-  --> $DIR/edition-keywords-2018-2015-parsing.rs:28:22\n+error: expected one of `move`, `|`, or `||`, found `<eof>`\n+  --> <passes_ident macros>:1:22\n    |\n-LL |     if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n-   |                      ^^^^^ expected expression\n+LL | ( $ i : ident ) => ( $ i )\n+   |                      ^^^ expected one of `move`, `|`, or `||` here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "f9b4d0e18c14b3e9c6d954a43287e3af3d3ab113", "filename": "src/test/ui/edition-keywords-2018-2018-parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -25,7 +25,7 @@ pub fn check_async() {\n     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n     r#async = consumes_async_raw!(r#async); // OK\n \n-    if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n+    if passes_ident!(async) == 1 {}\n     if passes_ident!(r#async) == 1 {} // OK\n     module::async(); //~ ERROR expected identifier, found reserved keyword `async`\n     module::r#async(); // OK"}, {"sha": "e48aac0a2bba9397512535d3ebce84ead33506e2", "filename": "src/test/ui/edition-keywords-2018-2018-parsing.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fedition-keywords-2018-2018-parsing.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -22,11 +22,11 @@ error: no rules expected the token `async`\n LL |     r#async = consumes_async_raw!(async); //~ ERROR no rules expected the token `async`\n    |                                   ^^^^^\n \n-error: expected expression, found reserved keyword `async`\n-  --> $DIR/edition-keywords-2018-2018-parsing.rs:28:22\n+error: expected one of `move`, `|`, or `||`, found `<eof>`\n+  --> <passes_ident macros>:1:22\n    |\n-LL |     if passes_ident!(async) == 1 {} //~ ERROR expected expression, found reserved keyword `async`\n-   |                      ^^^^^ expected expression\n+LL | ( $ i : ident ) => ( $ i )\n+   |                      ^^^ expected one of `move`, `|`, or `||` here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b1dd6a77e976a740bfa7ee3146adbed10918ae77", "filename": "src/test/ui/feature-gate-async-await-2015-edition.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2015\n+\n+#![feature(futures_api)]\n+\n+async fn foo() {} //~ ERROR async fn is unstable\n+\n+fn main() {\n+    let _ = async {}; //~ ERROR cannot find struct, variant or union type `async`\n+    let _ = async || {}; //~ ERROR cannot find value `async` in this scope\n+}"}, {"sha": "3db90a48e90b971d145bf3a1bc7bf1ee39a3bede", "filename": "src/test/ui/feature-gate-async-await-2015-edition.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await-2015-edition.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,24 @@\n+error[E0422]: cannot find struct, variant or union type `async` in this scope\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:18:13\n+   |\n+LL |     let _ = async {}; //~ ERROR cannot find struct, variant or union type `async`\n+   |             ^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `async` in this scope\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:19:13\n+   |\n+LL |     let _ = async || {}; //~ ERROR cannot find value `async` in this scope\n+   |             ^^^^^ not found in this scope\n+\n+error[E0658]: async fn is unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await-2015-edition.rs:15:1\n+   |\n+LL | async fn foo() {} //~ ERROR async fn is unstable\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0422, E0425, E0658.\n+For more information about an error, try `rustc --explain E0422`."}, {"sha": "971b75c6dd03653f286792e674e6297549301905", "filename": "src/test/ui/feature-gate-async-await.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+#![feature(futures_api)]\n+\n+async fn foo() {} //~ ERROR async fn is unstable\n+\n+fn main() {\n+    let _ = async {}; //~ ERROR async blocks are unstable\n+    let _ = async || {}; //~ ERROR async closures are unstable\n+}"}, {"sha": "fdee6e205750b0f39384d8b9944d782212cd1bb4", "filename": "src/test/ui/feature-gate-async-await.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-async-await.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,27 @@\n+error[E0658]: async fn is unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:14:1\n+   |\n+LL | async fn foo() {} //~ ERROR async fn is unstable\n+   | ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error[E0658]: async blocks are unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:17:13\n+   |\n+LL |     let _ = async {}; //~ ERROR async blocks are unstable\n+   |             ^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error[E0658]: async closures are unstable (see issue #50547)\n+  --> $DIR/feature-gate-async-await.rs:18:13\n+   |\n+LL |     let _ = async || {}; //~ ERROR async closures are unstable\n+   |             ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(async_await)] to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f2ecc44771883752d6296d7bbd38a82facf371e9", "filename": "src/test/ui/no-args-non-move-async-closure.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.rs?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --edition=2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n+\n+fn main() {\n+    let _ = async |x: u8| {};\n+    //~^ ERROR `async` non-`move` closures with arguments are not currently supported\n+}"}, {"sha": "1e49cb2e93c0529dff4736b651fb1e6dd2ddf30b", "filename": "src/test/ui/no-args-non-move-async-closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf844b547dbec1f23982fca8e07ec65800ed5d6d/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-args-non-move-async-closure.stderr?ref=cf844b547dbec1f23982fca8e07ec65800ed5d6d", "patch": "@@ -0,0 +1,11 @@\n+error[E0705]: `async` non-`move` closures with arguments are not currently supported\n+  --> $DIR/no-args-non-move-async-closure.rs:16:13\n+   |\n+LL |     let _ = async |x: u8| {};\n+   |             ^^^^^^^^^^^^^\n+   |\n+   = help: consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0705`."}]}