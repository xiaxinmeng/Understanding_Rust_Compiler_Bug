{"sha": "44e45d9fea9cae9b76927cf50bc05da3626244bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZTQ1ZDlmZWE5Y2FlOWI3NjkyN2NmNTBiYzA1ZGEzNjI2MjQ0YmM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-08-31T18:33:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-19T13:00:59Z"}, "message": "rework the README.md for rustc and add other readmes\n\nThis takes way longer than I thought it would. =)", "tree": {"sha": "8fd002e98073f830ea37b134fbc992001090a5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fd002e98073f830ea37b134fbc992001090a5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44e45d9fea9cae9b76927cf50bc05da3626244bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44e45d9fea9cae9b76927cf50bc05da3626244bc", "html_url": "https://github.com/rust-lang/rust/commit/44e45d9fea9cae9b76927cf50bc05da3626244bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44e45d9fea9cae9b76927cf50bc05da3626244bc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a00f3cc306f2f79bfbd54f1986d8ca7a74f6661", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a00f3cc306f2f79bfbd54f1986d8ca7a74f6661", "html_url": "https://github.com/rust-lang/rust/commit/9a00f3cc306f2f79bfbd54f1986d8ca7a74f6661"}], "stats": {"total": 514, "additions": 468, "deletions": 46}, "files": [{"sha": "f2abaa6f95730b094ab81d2ca91b2629ca2d80eb", "filename": "src/librustc/README.md", "status": "modified", "additions": 99, "deletions": 40, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -13,49 +13,82 @@ https://github.com/rust-lang/rust/issues\n \n Your concerns are probably the same as someone else's.\n \n-The crates of rustc\n-===================\n-\n-Rustc consists of a number of crates, including `libsyntax`,\n-`librustc`, `librustc_back`, `librustc_trans`, and `librustc_driver`\n-(the names and divisions are not set in stone and may change;\n-in general, a finer-grained division of crates is preferable):\n-\n-- [`libsyntax`][libsyntax] contains those things concerned purely with syntax \u2013\n-  that is, the AST, parser, pretty-printer, lexer, macro expander, and\n-  utilities for traversing ASTs \u2013 are in a separate crate called\n-  \"syntax\", whose files are in `./../libsyntax`, where `.` is the\n-  current directory (that is, the parent directory of front/, middle/,\n-  back/, and so on).\n-\n-- `librustc` (the current directory) contains the high-level analysis\n-  passes, such as the type checker, borrow checker, and so forth.\n-  It is the heart of the compiler.\n-\n-- [`librustc_back`][back] contains some very low-level details that are\n-  specific to different LLVM targets and so forth.\n+You may also be interested in the\n+[Rust Forge](https://forge.rust-lang.org/), which includes a number of\n+interesting bits of information.\n \n-- [`librustc_trans`][trans] contains the code to convert from Rust IR into LLVM\n-  IR, and then from LLVM IR into machine code, as well as the main\n-  driver that orchestrates all the other passes and various other bits\n-  of miscellany. In general it contains code that runs towards the\n-  end of the compilation process.\n-\n-- [`librustc_driver`][driver] invokes the compiler from\n-  [`libsyntax`][libsyntax], then the analysis phases from `librustc`, and\n-  finally the lowering and codegen passes from [`librustc_trans`][trans].\n-\n-Roughly speaking the \"order\" of the three crates is as follows:\n-\n-              librustc_driver\n-                      |\n-    +-----------------+-------------------+\n-    |                                     |\n-    libsyntax -> librustc -> librustc_trans\n+Finally, at the end of this file is a GLOSSARY defining a number of\n+common (and not necessarily obvious!) names that are used in the Rust\n+compiler code. If you see some funky name and you'd like to know what\n+it stands for, check there!\n \n+The crates of rustc\n+===================\n \n-The compiler process:\n-=====================\n+Rustc consists of a number of crates, including `syntax`,\n+`rustc`, `rustc_back`, `rustc_trans`, `rustc_driver`, and\n+many more. The source for each crate can be found in a directory\n+like `src/libXXX`, where `XXX` is the crate name.\n+\n+(NB. The names and divisions of these crates are not set in\n+stone and may change over time -- for the time being, we tend towards\n+a finer-grained division to help with compilation time, though as\n+incremental improves that may change.)\n+\n+The dependency structure of these crates is roughly a diamond:\n+\n+````\n+                  rustc_driver\n+                /      |       \\\n+              /        |         \\\n+            /          |           \\\n+          /            v             \\\n+rustc_trans    rustc_borrowck   ...  rustc_metadata\n+          \\            |            /\n+            \\          |          /\n+              \\        |        /\n+                \\      v      /\n+                    rustc\n+                       |\n+                       v\n+                    syntax\n+                    /    \\\n+                  /       \\\n+           syntax_pos  syntax_ext\n+```                    \n+\n+\n+The idea is that `rustc_driver`, at the top of this lattice, basically\n+defines the overall control-flow of the compiler. It doesn't have much\n+\"real code\", but instead ties together all of the code defined in the\n+other crates and defines the overall flow of execution.\n+\n+At the other extreme, the `rustc` crate defines the common and\n+pervasive data structures that all the rest of the compiler uses\n+(e.g., how to represent types, traits, and the program itself). It\n+also contains some amount of the compiler itself, although that is\n+relatively limited.\n+\n+Finally, all the crates in the bulge in the middle define the bulk of\n+the compiler -- they all depend on `rustc`, so that they can make use\n+of the various types defined there, and they export public routines\n+that `rustc_driver` will invoke as needed (more and more, what these\n+crates export are \"query definitions\", but those are covered later\n+on).\n+\n+Below `rustc` lie various crates that make up the parser and error\n+reporting mechanism. For historical reasons, these crates do not have\n+the `rustc_` prefix, but they are really just as much an internal part\n+of the compiler and not intended to be stable (though they do wind up\n+getting used by some crates in the wild; a practice we hope to\n+gradually phase out).\n+\n+Each crate has a `README.md` file that describes, at a high-level,\n+what it contains, and tries to give some kind of explanation (some\n+better than others).\n+\n+The compiler process\n+====================\n \n The Rust compiler is comprised of six main compilation phases.\n \n@@ -172,3 +205,29 @@ The 3 central data structures:\n [back]: https://github.com/rust-lang/rust/tree/master/src/librustc_back/\n [rustc]: https://github.com/rust-lang/rust/tree/master/src/librustc/\n [driver]: https://github.com/rust-lang/rust/tree/master/src/librustc_driver\n+\n+Glossary\n+========\n+\n+The compiler uses a number of...idiosyncratic abbreviations and\n+things. This glossary attempts to list them and give you a few\n+pointers for understanding them better.\n+\n+- AST -- the **abstract syntax tree** produced the `syntax` crate; reflects user syntax\n+  very closely.\n+- cx -- we tend to use \"cx\" as an abbrevation for context. See also tcx, infcx, etc.\n+- HIR -- the **High-level IR**, created by lowering and desugaring the AST. See `librustc/hir`.\n+- `'gcx` -- the lifetime of the global arena (see `librustc/ty`).\n+- generics -- the set of generic type parameters defined on a type or item\n+- infcx -- the inference context (see `librustc/infer`)\n+- MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n+  Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n+  found in `src/librustc_mir`.\n+- obligation -- something that must be proven by the trait system.\n+- sess -- the **compiler session**, which stores global data used throughout compilation\n+- substs -- the **substitutions** for a given generic type or item\n+  (e.g., the `i32, u32` in `HashMap<i32, u32>`)\n+- tcx -- the \"typing context\", main data structure of the compiler (see `librustc/ty`).\n+- trans -- the code to **translate** MIR into LLVM IR.\n+- trait reference -- a trait and values for its type parameters (see `librustc/ty`).\n+- ty -- the internal representation of a **type** (see `librustc/ty`)."}, {"sha": "d4f4e48963a342a60565116e9910069ed4286cc8", "filename": "src/librustc/hir/README.md", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,123 @@\n+# Introduction to the HIR\n+\n+The HIR -- \"High-level IR\" -- is the primary IR used in most of\n+rustc. It is a desugared version of the \"abstract syntax tree\" (AST)\n+that is generated after parsing, macro expansion, and name resolution\n+have completed. Many parts of HIR resemble Rust surface syntax quite\n+closely, with the exception that some of Rust's expression forms have\n+been desugared away (as an example, `for` loops are converted into a\n+`loop` and do not appear in the HIR).\n+\n+This README covers the main concepts of the HIR.\n+\n+### Out-of-band storage and the `Crate` type\n+\n+The top-level data-structure in the HIR is the `Crate`, which stores\n+the contents of the crate currently being compiled (we only ever\n+construct HIR for the current crate). Whereas in the AST the crate\n+data structure basically just contains the root module, the HIR\n+`Crate` structure contains a number of maps and other things that\n+serve to organize the content of the crate for easier access.\n+\n+For example, the contents of individual items (e.g., modules,\n+functions, traits, impls, etc) in the HIR are not immediately\n+accessible in the parents. So, for example, if had a module item `foo`\n+containing a function `bar()`:\n+\n+```\n+mod foo {\n+  fn bar() { }\n+}\n+```\n+\n+Then in the HIR the representation of module `foo` (the `Mod`\n+stuct) would have only the **`ItemId`** `I` of `bar()`. To get the\n+details of the function `bar()`, we would lookup `I` in the\n+`items` map.\n+\n+One nice result from this representation is that one can iterate\n+over all items in the crate by iterating over the key-value pairs\n+in these maps (without the need to trawl through the IR in total).\n+There are similar maps for things like trait items and impl items,\n+as well as \"bodies\" (explained below).\n+\n+The other reason to setup the representation this way is for better\n+integration with incremental compilation. This way, if you gain access\n+to a `&hir::Item` (e.g. for the mod `foo`), you do not immediately\n+gain access to the contents of the function `bar()`. Instead, you only\n+gain access to the **id** for `bar()`, and you must some function to\n+lookup the contents of `bar()` given its id; this gives us a change to\n+observe that you accessed the data for `bar()` and record the\n+dependency.\n+\n+### Identifiers in the HIR\n+\n+Most of the code that has to deal with things in HIR tends not to\n+carry around references into the HIR, but rather to carry around\n+*identifier numbers* (or just \"ids\"). Right now, you will find four\n+sorts of identifiers in active use:\n+\n+- `DefId`, which primarily name \"definitions\" or top-level items.\n+  - You can think of a `DefId` as being shorthand for a very explicit\n+    and complete path, like `std::collections::HashMap`. However,\n+    these paths are able to name things that are not nameable in\n+    normal Rust (e.g., impls), and they also include extra information\n+    about the crate (such as its version number, as two versions of\n+    the same crate can co-exist).\n+  - A `DefId` really consists of two parts, a `CrateNum` (which\n+    identifies the crate) and a `DefIndex` (which indixes into a list\n+    of items that is maintained per crate).\n+- `HirId`, which combines the index of a particular item with an\n+  offset within that item.\n+  - the key point of a `HirId` is that it is *relative* to some item (which is named\n+    via a `DefId`).\n+- `BodyId`, this is an absolute identifier that refers to a specific\n+  body (definition of a function or constant) in the crate. It is currently\n+  effectively a \"newtype'd\" `NodeId`.\n+- `NodeId`, which is an absolute id that identifies a single node in the HIR tree.\n+  - While these are still in common use, **they are being slowly phased out**.\n+  - Since they are absolute within the crate, adding a new node\n+    anywhere in the tree causes the node-ids of all subsequent code in\n+    the crate to change. This is terrible for incremental compilation,\n+    as you can perhaps imagine.\n+\n+### HIR Map\n+\n+Most of the time when you are working with the HIR, you will do so via\n+the **HIR Map**, accessible in the tcx via `tcx.hir` (and defined in\n+the `hir::map` module). The HIR map contains a number of methods to\n+convert between ids of various kinds and to lookup data associated\n+with a HIR node.\n+\n+For example, if you have a `DefId`, and you would like to convert it\n+to a `NodeId`, you can use `tcx.hir.as_local_node_id(def_id)`. This\n+returns an `Option<NodeId>` -- this will be `None` if the def-id\n+refers to something outside of the current crate (since then it has no\n+HIR node), but otherwise returns `Some(n)` where `n` is the node-id of\n+the definition.\n+\n+Similarly, you can use `tcx.hir.find(n)` to lookup the node for a\n+`NodeId`. This returns a `Option<Node<'tcx>>`, where `Node` is an enum\n+defined in the map; by matching on this you can find out what sort of\n+node the node-id referred to and also get a pointer to the data\n+itself. Often, you know what sort of node `n` is -- e.g., if you know\n+that `n` must be some HIR expression, you can do\n+`tcx.hir.expect_expr(n)`, which will extract and return the\n+`&hir::Expr`, panicking if `n` is not in fact an expression.\n+\n+Finally, you can use the HIR map to find the parents of nodes, via\n+calls like `tcx.hir.get_parent_node(n)`.\n+\n+### HIR Bodies\n+\n+A **body** represents some kind of executable code, such as the body\n+of a function/closure or the definition of a constant. Bodies are\n+associated with an **owner**, which is typically some kind of item\n+(e.g., a `fn()` or `const`), but could also be a closure expression\n+(e.g., `|x, y| x + y`). You can use the HIR map to find find the body\n+associated with a given def-id (`maybe_body_owned_by()`) or to find\n+the owner of a body (`body_owner_def_id()`).\n+\n+\n+\n+"}, {"sha": "34ed325705ab98c231f0ae9ac578fd252c6a6f1d", "filename": "src/librustc/hir/map/README.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,4 @@\n+The HIR map, accessible via `tcx.hir`, allows you to quickly navigate the\n+HIR and convert between various forms of identifiers. See [the HIR README] for more information.\n+\n+[the HIR README]: ../README.md"}, {"sha": "ea3cdbaad413efa0181e7bc651e414451ece18f0", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -413,6 +413,9 @@ pub struct WhereEqPredicate {\n \n pub type CrateConfig = HirVec<P<MetaItem>>;\n \n+/// The top-level data structure that stores the entire contents of\n+/// the crate currently being compiled.\n+///\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n@@ -927,7 +930,27 @@ pub struct BodyId {\n     pub node_id: NodeId,\n }\n \n-/// The body of a function or constant value.\n+/// The body of a function, closure, or constant value. In the case of\n+/// a function, the body contains not only the function body itself\n+/// (which is an expression), but also the argument patterns, since\n+/// those are something that the caller doesn't really care about.\n+///\n+/// Example:\n+///\n+/// ```rust\n+/// fn foo((x, y): (u32, u32)) -> u32 {\n+///     x + y\n+/// }\n+/// ```\n+///\n+/// Here, the `Body` associated with `foo()` would contain:\n+///\n+/// - an `arguments` array containing the `(x, y)` pattern\n+/// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n+/// - `is_generator` would be false\n+///\n+/// All bodies have an **owner**, which can be accessed via the HIR\n+/// map using `body_owner_def_id()`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,"}, {"sha": "cd39ef70946329857b49dfef39fcc973ef4112d9", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -8,7 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The Rust compiler.\n+//! The \"main crate\" of the Rust compiler. This crate contains common\n+//! type definitions that are used by the other crates in the rustc\n+//! \"family\". Some prominent examples (note that each of these modules\n+//! has their own README with further details).\n+//!\n+//! - **HIR.** The \"high-level (H) intermediate representation (IR)\" is\n+//!   defined in the `hir` module.\n+//! - **MIR.** The \"mid-level (M) intermediate representation (IR)\" is\n+//!   defined in the `mir` module. This module contains only the\n+//!   *definition* of the MIR; the passes that transform and operate\n+//!   on MIR are found in `librustc_mir` crate.\n+//! - **Types.** The internal representation of types used in rustc is\n+//!   defined in the `ty` module. This includes the **type context**\n+//!   (or `tcx`), which is the central context during most of\n+//!   compilation, containing the interners and other things.\n+//! - **Traits.** Trait resolution is implemented in the `traits` module.\n+//! - **Type inference.** The type inference code can be found in the `infer` module;\n+//!   this code handles low-level equality and subtyping operations. The\n+//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n+//!\n+//! For a deeper explanation of how the compiler works and is\n+//! organized, see the README.md file in this directory.\n //!\n //! # Note\n //!"}, {"sha": "0416be8b9ab34d45e5a1e6e01729bc1ac0338839", "filename": "src/librustc/ty/README.md", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fty%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fty%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,159 @@\n+# Types and the Type Context\n+\n+The `ty` module defines how the Rust compiler represents types\n+internally. It also defines the *typing context* (`tcx` or `TyCtxt`),\n+which is the central data structure in the compiler.\n+\n+## The tcx and how it uses lifetimes\n+\n+The `tcx` (\"typing context\") is the central data structure in the\n+compiler. It is the context that you use to perform all manner of\n+queries. The struct `TyCtxt` defines a reference to this shared context:\n+\n+```rust\n+tcx: TyCtxt<'a, 'gcx, 'tcx>\n+//          --  ----  ----\n+//          |   |     |\n+//          |   |     innermost arena lifetime (if any)\n+//          |   \"global arena\" lifetime\n+//          lifetime of this reference\n+```\n+\n+As you can see, the `TyCtxt` type takes three lifetime parameters.\n+These lifetimes are perhaps the most complex thing to understand about\n+the tcx. During rust compilation, we allocate most of our memory in\n+**arenas**, which are basically pools of memory that get freed all at\n+once. When you see a reference with a lifetime like `'tcx` or `'gcx`,\n+you know that it refers to arena-allocated data (or data that lives as\n+long as the arenas, anyhow).\n+\n+We use two distinct levels of arenas. The outer level is the \"global\n+arena\". This arena lasts for the entire compilation: so anything you\n+allocate in there is only freed once compilation is basically over\n+(actually, when we shift to executing LLVM).\n+\n+To reduce peak memory usage, when we do type inference, we also use an\n+inner level of arena. These arenas get thrown away once type inference\n+is over. This is done because type inference generates a lot of\n+\"throw-away\" types that are not particularly interesting after type\n+inference completes, so keeping around those allocations would be\n+wasteful.\n+\n+Often, we wish to write code that explicitly asserts that it is not\n+taking place during inference. In that case, there is no \"local\"\n+arena, and all the types that you can access are allocated in the\n+global arena.  To express this, the idea is to us the same lifetime\n+for the `'gcx` and `'tcx` parameters of `TyCtxt`. Just to be a touch\n+confusing, we tend to use the name `'tcx` in such contexts. Here is an\n+example:\n+\n+```rust\n+fn not_in_inference<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    //                                        ----  ----\n+    //                                        Using the same lifetime here asserts\n+    //                                        that the innermost arena accessible through\n+    //                                        this reference *is* the global arena.\n+}\n+```\n+\n+In contrast, if we want to code that can be usable during type inference, then you\n+need to declare a distinct `'gcx` and `'tcx` lifetime parameter:\n+\n+```rust\n+fn maybe_in_inference<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId) {\n+    //                                                ----  ----\n+    //                                        Using different lifetimes here means that\n+    //                                        the innermost arena *may* be distinct\n+    //                                        from the global arena (but doesn't have to be).\n+}\n+```\n+\n+### Allocating and working with types\n+\n+Rust types are represented using the `ty::Ty<'tcx>` type. This is in fact a simple type alias\n+for a reference with `'tcx` lifetime:\n+\n+```rust\n+pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n+```\n+\n+The `TyS` struct defines the actual details of how a type is\n+represented. The most interesting part of it is the `sty` field, which\n+contains an enum that lets us test what sort of type this is. For\n+example, it is very common to see code that tests what sort of type you have\n+that looks roughly like so:\n+\n+```rust\n+fn test_type<'tcx>(ty: Ty<'tcx>) {\n+    match ty.sty {\n+        ty::TyArray(elem_ty, len) => { ... }\n+        ...\n+    }\n+}\n+```\n+\n+(Note though that doing such low-level tests on types during inference\n+can be risky, as there are may be inference variables and other things\n+to consider, or sometimes types are not yet known that will become\n+known later.).\n+\n+To allocate a new type, you can use the various `mk_` methods defined\n+on the `tcx`. These have names that correpond mostly to the various kinds\n+of type variants. For example:\n+\n+```rust\n+let array_ty = tcx.mk_array(elem_ty, len * 2);\n+```\n+\n+These methods all return a `Ty<'tcx>` -- note that the lifetime you\n+get back is the lifetime of the innermost arena that this `tcx` has\n+access to. In fact, types are always canonicalized and interned (so we\n+never allocate exactly the same type twice) and are always allocated\n+in the outermost arena where they can be (so, if they do not contain\n+any inference variables or other \"temporary\" types, they will be\n+allocated in the global arena). However, the lifetime `'tcx` is always\n+a safe approximation, so that is what you get back.\n+\n+NB. Because types are interned, it is possible to compare them for\n+equality efficiently using `==` -- however, this is almost never what\n+you want to do unless you happen to be hashing and looking for\n+duplicates. This is because often in Rust there are multiple ways to\n+represent the same type, particularly once inference is involved. If\n+you are going to be testing for type equality, you probably need to\n+start looking into the inference code to do it right.\n+\n+You can also find various common types in the tcx itself by accessing\n+`tcx.types.bool`, `tcx.types.char`, etc (see `CommonTypes` for more).\n+\n+### Beyond types: Other kinds of arena-allocated data structures\n+\n+In addition to types, there are a number of other arena-allocated data\n+structures that you can allocate, and which are found in this\n+module. Here are a few examples:\n+\n+- `Substs`, allocated with `mk_substs` -- this will intern a slice of types, often used to\n+  specify the values to be substituted for generics (e.g., `HashMap<i32, u32>`\n+  would be represented as a slice `&'tcx [tcx.types.i32, tcx.types.u32]`.\n+- `TraitRef`, typically passed by value -- a **trait reference**\n+  consists of a reference to a trait along with its various type\n+  parameters (including `Self`), like `i32: Display` (here, the def-id\n+  would reference the `Display` trait, and the substs would contain\n+  `i32`).\n+- `Predicate` defines something the trait system has to prove (see `traits` module).\n+\n+### Import conventions\n+\n+Although there is no hard and fast rule, the `ty` module tends to be used like so:\n+\n+```rust\n+use ty::{self, Ty, TyCtxt};\n+```\n+\n+In particular, since they are so common, the `Ty` and `TyCtxt` types\n+are imported directly. Other types are often referenced with an\n+explicit `ty::` prefix (e.g., `ty::TraitRef<'tcx>`). But some modules\n+choose to import a larger or smaller set of names explicitly.\n+\n+\n+\n+"}, {"sha": "6a95c62a303f4478cab26a7e1eb6952a096867a3", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -793,9 +793,11 @@ impl<'tcx> CommonTypes<'tcx> {\n     }\n }\n \n-/// The data structure to keep track of all the information that typechecker\n-/// generates so that so that it can be reused and doesn't have to be redone\n-/// later on.\n+/// The central data structure of the compiler. Keeps track of all the\n+/// information that typechecker generates so that so that it can be\n+/// reused and doesn't have to be redone later on.\n+///\n+/// See [the README](README.md) for more deatils.\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     gcx: &'a GlobalCtxt<'gcx>,"}, {"sha": "bd99c687bb6ad91597414b3d491eecd40381ce82", "filename": "src/librustc_back/README.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_back%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_back%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,6 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+`librustc_back` contains some very low-level details that are\n+specific to different LLVM targets and so forth."}, {"sha": "5331a05b5cd8e4dd475f60aa78479731923c3eb2", "filename": "src/librustc_driver/README.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,12 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `driver` crate is effectively the \"main\" function for the rust\n+compiler.  It orchstrates the compilation process and \"knits together\"\n+the code from the other crates within rustc. This crate itself does\n+not contain any of the \"main logic\" of the compiler (though it does\n+have some code related to pretty printing or other minor compiler\n+options).\n+\n+"}, {"sha": "b69d632a6a0dfba36adbed00195a8b32583e04f2", "filename": "src/librustc_trans/README.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -1 +1,7 @@\n-See [librustc/README.md](../librustc/README.md).\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `trans` crate contains the code to convert from MIR into LLVM IR,\n+and then from LLVM IR into machine code. In general it contains code\n+that runs towards the end of the compilation process."}, {"sha": "3bf735ee868037f96feeb19c59b306d42583e959", "filename": "src/libsyntax/README.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/44e45d9fea9cae9b76927cf50bc05da3626244bc/src%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FREADME.md?ref=44e45d9fea9cae9b76927cf50bc05da3626244bc", "patch": "@@ -0,0 +1,7 @@\n+NB: This crate is part of the Rust compiler. For an overview of the\n+compiler as a whole, see\n+[the README.md file found in `librustc`](../librustc/README.md).\n+\n+The `syntax` crate contains those things concerned purely with syntax\n+\u2013 that is, the AST (\"abstract syntax tree\"), parser, pretty-printer,\n+lexer, macro expander, and utilities for traversing ASTs."}]}