{"sha": "a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "node_id": "C_kwDOAAsO6NoAKGEyNjc4ZTE1ZTU1OWJiN2Q3NzlmZDFlMDRkNzNkOGFlM2I5MDkzZTM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-15T17:00:16Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-15T17:00:16Z"}, "message": "Replace RelationDir with Variance", "tree": {"sha": "6e45a5ae01e2814a385428f4bdc3ce474efb7fda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e45a5ae01e2814a385428f4bdc3ce474efb7fda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "html_url": "https://github.com/rust-lang/rust/commit/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41501c74490570c24b38f55484981f22eebf0d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/41501c74490570c24b38f55484981f22eebf0d39", "html_url": "https://github.com/rust-lang/rust/commit/41501c74490570c24b38f55484981f22eebf0d39"}], "stats": {"total": 92, "additions": 29, "deletions": 63}, "files": [{"sha": "79fc02c6c7987b1d83f75fea874e7be6d2c44326", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 57, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "patch": "@@ -48,13 +48,6 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub define_opaque_types: DefineOpaqueTypes,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum RelationDir {\n-    SubtypeOf,\n-    SupertypeOf,\n-    EqTo,\n-}\n-\n impl<'tcx> InferCtxt<'tcx> {\n     pub fn super_combine_tys<R>(\n         &self,\n@@ -378,12 +371,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     pub fn instantiate(\n         &mut self,\n         a_ty: Ty<'tcx>,\n-        dir: RelationDir,\n+        ambient_variance: ty::Variance,\n         b_vid: ty::TyVid,\n         a_is_expected: bool,\n     ) -> RelateResult<'tcx, ()> {\n-        use self::RelationDir::*;\n-\n         // Get the actual variable that b_vid has been inferred to\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n@@ -398,7 +389,18 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let Generalization { value: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n+        let Generalization { value: b_ty, needs_wf } = generalize::generalize(\n+            self.infcx,\n+            &mut CombineDelegate {\n+                infcx: self.infcx,\n+                param_env: self.param_env,\n+                span: self.trace.span(),\n+            },\n+            a_ty,\n+            b_vid,\n+            ambient_variance,\n+        )?;\n+\n         debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n@@ -417,62 +419,23 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // relations wind up attributed to the same spans. We need\n         // to associate causes/spans with each of the relations in\n         // the stack to get this right.\n-        match dir {\n-            EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n-            SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n-            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+        match ambient_variance {\n+            ty::Variance::Invariant => self.equate(a_is_expected).relate(a_ty, b_ty),\n+            ty::Variance::Covariant => self.sub(a_is_expected).relate(a_ty, b_ty),\n+            ty::Variance::Contravariant => self.sub(a_is_expected).relate_with_variance(\n                 ty::Contravariant,\n                 ty::VarianceDiagInfo::default(),\n                 a_ty,\n                 b_ty,\n             ),\n+            ty::Variance::Bivariant => {\n+                unreachable!(\"no code should be generalizing bivariantly (currently)\")\n+            }\n         }?;\n \n         Ok(())\n     }\n \n-    /// Attempts to generalize `ty` for the type variable `for_vid`.\n-    /// This checks for cycle -- that is, whether the type `ty`\n-    /// references `for_vid`. The `dir` is the \"direction\" for which we\n-    /// a performing the generalization (i.e., are we producing a type\n-    /// that can be used as a supertype etc).\n-    ///\n-    /// Preconditions:\n-    ///\n-    /// - `for_vid` is a \"root vid\"\n-    #[instrument(skip(self), level = \"trace\", ret)]\n-    fn generalize(\n-        &mut self,\n-        ty: Ty<'tcx>,\n-        for_vid: ty::TyVid,\n-        dir: RelationDir,\n-    ) -> RelateResult<'tcx, Generalization<Ty<'tcx>>> {\n-        // Determine the ambient variance within which `ty` appears.\n-        // The surrounding equation is:\n-        //\n-        //     ty [op] ty2\n-        //\n-        // where `op` is either `==`, `<:`, or `:>`. This maps quite\n-        // naturally.\n-        let ambient_variance = match dir {\n-            RelationDir::EqTo => ty::Invariant,\n-            RelationDir::SubtypeOf => ty::Covariant,\n-            RelationDir::SupertypeOf => ty::Contravariant,\n-        };\n-\n-        generalize::generalize(\n-            self.infcx,\n-            &mut CombineDelegate {\n-                infcx: self.infcx,\n-                param_env: self.param_env,\n-                span: self.trace.span(),\n-            },\n-            ty,\n-            for_vid,\n-            ambient_variance,\n-        )\n-    }\n-\n     pub fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.obligations.extend(obligations.into_iter());\n     }"}, {"sha": "793505e4ab23dec08c3d25e85eef86dfc018e26f", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::DefineOpaqueTypes;\n use crate::traits::PredicateObligations;\n \n-use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n+use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::Subtype;\n \n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -88,11 +88,11 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n+                self.fields.instantiate(b, ty::Invariant, a_id, self.a_is_expected)?;\n             }\n \n             (_, &ty::Infer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, ty::Invariant, b_id, self.a_is_expected)?;\n             }\n \n             ("}, {"sha": "d4a1dacde1047520cf713ba0201f92f11dd1bbe8", "filename": "compiler/rustc_infer/src/infer/generalize.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs?ref=a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "patch": "@@ -10,6 +10,9 @@ use crate::infer::nll_relate::TypeRelatingDelegate;\n use crate::infer::type_variable::TypeVariableValue;\n use crate::infer::{InferCtxt, RegionVariableOrigin};\n \n+/// Attempts to generalize `term` for the type variable `for_vid`.\n+/// This checks for cycles -- that is, whether the type `term`\n+/// references `for_vid`.\n pub(super) fn generalize<'tcx, D: GeneralizerDelegate<'tcx>, T: Into<Term<'tcx>> + Relate<'tcx>>(\n     infcx: &InferCtxt<'tcx>,\n     delegate: &mut D,"}, {"sha": "e0f29a8de8fc823fef77096c8f46b4bd2403572a", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2678e15e559bb7d779fd1e04d73d8ae3b9093e3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=a2678e15e559bb7d779fd1e04d73d8ae3b9093e3", "patch": "@@ -1,4 +1,4 @@\n-use super::combine::{CombineFields, RelationDir};\n+use super::combine::CombineFields;\n use super::{DefineOpaqueTypes, ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n@@ -108,11 +108,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(a)\n             }\n             (&ty::Infer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n+                self.fields.instantiate(b, ty::Contravariant, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::Infer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, ty::Covariant, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}]}