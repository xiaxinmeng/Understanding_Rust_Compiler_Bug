{"sha": "42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "node_id": "C_kwDOAAsO6NoAKDQyZjFmNTRhNWUxNTYxNmYyM2QyMmQwOWNiZGQ1MTBlZTNkNWY3ODk", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-01-17T09:39:35Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-01-19T11:29:40Z"}, "message": "Don't treat closures from other crates as local", "tree": {"sha": "55c9e87d0b2c21daa418f46153502f908aa75294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55c9e87d0b2c21daa418f46153502f908aa75294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "html_url": "https://github.com/rust-lang/rust/commit/42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481725984b4cd94ef5c00917b01c1771b6e5299c", "url": "https://api.github.com/repos/rust-lang/rust/commits/481725984b4cd94ef5c00917b01c1771b6e5299c", "html_url": "https://github.com/rust-lang/rust/commit/481725984b4cd94ef5c00917b01c1771b6e5299c"}], "stats": {"total": 82, "additions": 58, "deletions": 24}, "files": [{"sha": "c8d56db2aa732e18144680acc62a8ec376d96f25", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "patch": "@@ -401,12 +401,12 @@ fn resolve_negative_obligation<'tcx>(\n     infcx.resolve_regions(&outlives_env).is_empty()\n }\n \n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn trait_ref_is_knowable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), Conflict> {\n-    debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n+    if orphan_check_trait_ref(trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n         return Err(Conflict::Downstream);\n@@ -429,11 +429,9 @@ pub fn trait_ref_is_knowable<'tcx>(\n     // and if we are an intermediate owner, then we don't care\n     // about future-compatibility, which means that we're OK if\n     // we are an owner.\n-    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n-        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+    if orphan_check_trait_ref(trait_ref, InCrate::Local).is_ok() {\n         Ok(())\n     } else {\n-        debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n         Err(Conflict::Upstream)\n     }\n }\n@@ -445,6 +443,7 @@ pub fn trait_ref_is_local_or_fundamental<'tcx>(\n     trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, sym::fundamental)\n }\n \n+#[derive(Debug)]\n pub enum OrphanCheckErr<'tcx> {\n     NonLocalInputType(Vec<(Ty<'tcx>, bool /* Is this the first input type? */)>),\n     UncoveredTy(Ty<'tcx>, Option<Ty<'tcx>>),\n@@ -456,21 +455,20 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanCheckErr<'_>> {\n-    debug!(\"orphan_check({:?})\", impl_def_id);\n-\n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity();\n-    debug!(\"orphan_check: trait_ref={:?}\", trait_ref);\n+    debug!(?trait_ref);\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.is_local() {\n         debug!(\"trait {:?} is local to current crate\", trait_ref.def_id);\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n+    orphan_check_trait_ref(trait_ref, InCrate::Local)\n }\n \n /// Checks whether a trait-ref is potentially implementable by a crate.\n@@ -559,21 +557,19 @@ pub fn orphan_check(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Result<(), OrphanChe\n ///\n /// Note that this function is never called for types that have both type\n /// parameters and inference variables.\n+#[instrument(level = \"trace\", ret)]\n fn orphan_check_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n     in_crate: InCrate,\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\", trait_ref, in_crate);\n-\n     if trait_ref.needs_infer() && trait_ref.needs_subst() {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref\n         );\n     }\n \n-    let mut checker = OrphanChecker::new(tcx, in_crate);\n+    let mut checker = OrphanChecker::new(in_crate);\n     match trait_ref.visit_with(&mut checker) {\n         ControlFlow::Continue(()) => Err(OrphanCheckErr::NonLocalInputType(checker.non_local_tys)),\n         ControlFlow::Break(OrphanCheckEarlyExit::ParamTy(ty)) => {\n@@ -592,7 +588,6 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n struct OrphanChecker<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n     in_crate: InCrate,\n     in_self_ty: bool,\n     /// Ignore orphan check failures and exclusively search for the first\n@@ -602,9 +597,8 @@ struct OrphanChecker<'tcx> {\n }\n \n impl<'tcx> OrphanChecker<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, in_crate: InCrate) -> Self {\n+    fn new(in_crate: InCrate) -> Self {\n         OrphanChecker {\n-            tcx,\n             in_crate,\n             in_self_ty: true,\n             search_first_local_ty: false,\n@@ -697,13 +691,17 @@ impl<'tcx> TypeVisitor<'tcx> for OrphanChecker<'tcx> {\n                 }\n             }\n             ty::Error(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n-            ty::Closure(..) | ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                self.tcx.sess.delay_span_bug(\n-                    DUMMY_SP,\n-                    format!(\"ty_is_local invoked on closure or generator: {:?}\", ty),\n-                );\n-                ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+            ty::Closure(did, ..) | ty::Generator(did, ..) => {\n+                if self.def_id_is_local(did) {\n+                    ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n+                } else {\n+                    self.found_non_local_ty(ty)\n+                }\n             }\n+            // This should only be created when checking whether we have to check whether some\n+            // auto trait impl applies. There will never be multiple impls, so we can just\n+            // act as if it were a local type here.\n+            ty::GeneratorWitness(_) => ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty)),\n             ty::Alias(ty::Opaque, ..) => {\n                 // This merits some explanation.\n                 // Normally, opaque types are not involved when performing"}, {"sha": "5eb8dc2a4687f53181f707efdea2267c79b558dd", "filename": "tests/ui/coherence/coherence-with-generator.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.rs?ref=42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "patch": "@@ -1,5 +1,11 @@\n // Test that encountering closures during coherence does not cause issues.\n #![feature(type_alias_impl_trait, generators)]\n+#![cfg_attr(specialized, feature(specialization))]\n+#![allow(incomplete_features)]\n+\n+// revisions: stock specialized\n+// [specialized]check-pass\n+\n type OpaqueGenerator = impl Sized;\n fn defining_use() -> OpaqueGenerator {\n     || {\n@@ -13,6 +19,6 @@ struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueGenerator> {}\n impl<T: Sync> Trait for Wrapper<T> {}\n-//~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n+//[stock]~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n \n fn main() {}"}, {"sha": "478ac4912646d8312fc12f9ae782ef5e34138f73", "filename": "tests/ui/coherence/coherence-with-generator.stock.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-with-generator.stock.stderr?ref=42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "patch": "@@ -1,5 +1,5 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n-  --> $DIR/coherence-with-generator.rs:15:1\n+  --> $DIR/coherence-with-generator.rs:21:1\n    |\n LL | impl Trait for Wrapper<OpaqueGenerator> {}\n    | --------------------------------------- first implementation here", "previous_filename": "tests/ui/coherence/coherence-with-generator.stderr"}, {"sha": "0d3bace4db1f4baa6414c7d3b85fd5c46704be8c", "filename": "tests/ui/type-alias-impl-trait/issue-104817.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.rs?ref=42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+#![cfg_attr(specialized, feature(specialization))]\n+#![allow(incomplete_features)]\n+\n+// revisions: stock specialized\n+// [specialized]check-pass\n+\n+trait OpaqueTrait {}\n+impl<T> OpaqueTrait for T {}\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType {\n+    || 0\n+}\n+trait AnotherTrait {}\n+impl<T: Send> AnotherTrait for T {}\n+impl AnotherTrait for OpaqueType {}\n+//[stock]~^ conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+\n+fn main() {}"}, {"sha": "47bae8bd12b6bba1731868e99e29b84fbdf88ad3", "filename": "tests/ui/type-alias-impl-trait/issue-104817.stock.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42f1f54a5e15616f23d22d09cbdd510ee3d5f789/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fissue-104817.stock.stderr?ref=42f1f54a5e15616f23d22d09cbdd510ee3d5f789", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n+  --> $DIR/issue-104817.rs:16:1\n+   |\n+LL | impl<T: Send> AnotherTrait for T {}\n+   | -------------------------------- first implementation here\n+LL | impl AnotherTrait for OpaqueType {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}]}