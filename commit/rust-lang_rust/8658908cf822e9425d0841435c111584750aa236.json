{"sha": "8658908cf822e9425d0841435c111584750aa236", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NTg5MDhjZjgyMmU5NDI1ZDA4NDE0MzVjMTExNTg0NzUwYWEyMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-15T06:14:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-15T06:14:11Z"}, "message": "Auto merge of #43185 - durka:thread-local-pub-restricted, r=alexcrichton\n\nsupport pub(restricted) in thread_local! (round 2)\n\nResurrected #40984 now that the issue blocking it was fixed. Original description:\n\n`pub(restricted)` was stabilized in #40556 so let's go!\n\nHere is a [playground](https://play.rust-lang.org/?gist=f55f32f164a6ed18c219fec8f8293b98&version=nightly&backtrace=1).\n\nI changed the interface of `__thread_local_inner!`, which is supposedly unstable but this is not checked for macros (#34097 cc @petrochenkov @jseyfried), so this may be an issue.", "tree": {"sha": "e892d86136cc2af79670e010416bc7a746ff0ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e892d86136cc2af79670e010416bc7a746ff0ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8658908cf822e9425d0841435c111584750aa236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8658908cf822e9425d0841435c111584750aa236", "html_url": "https://github.com/rust-lang/rust/commit/8658908cf822e9425d0841435c111584750aa236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8658908cf822e9425d0841435c111584750aa236/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4502f7c0b51526d0177204a71dc2b3200f7348b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4502f7c0b51526d0177204a71dc2b3200f7348b", "html_url": "https://github.com/rust-lang/rust/commit/b4502f7c0b51526d0177204a71dc2b3200f7348b"}, {"sha": "f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5", "html_url": "https://github.com/rust-lang/rust/commit/f9f4707469c2bc44ba3d643c805c8f3f62db7bd5"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "dda069324b08d0e78f990f075a9d8fb833a38503", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8658908cf822e9425d0841435c111584750aa236/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8658908cf822e9425d0841435c111584750aa236/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8658908cf822e9425d0841435c111584750aa236", "patch": "@@ -277,6 +277,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n+#![feature(macro_vis_matcher)]\n #![feature(needs_panic_runtime)]\n #![feature(needs_drop)]\n #![feature(never_type)]"}, {"sha": "be433e2b81e6b6758ea886803254488d88484718", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8658908cf822e9425d0841435c111584750aa236/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8658908cf822e9425d0841435c111584750aa236/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=8658908cf822e9425d0841435c111584750aa236", "patch": "@@ -110,12 +110,13 @@ impl<T: 'static> fmt::Debug for LocalKey<T> {\n     }\n }\n \n+#[cfg(not(stage0))]\n /// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n ///\n /// # Syntax\n ///\n /// The macro wraps any number of static declarations and makes them thread local.\n-/// Each static may be public or private, and attributes are allowed. Example:\n+/// Publicity and attributes for each static are allowed. Example:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -135,6 +136,60 @@ impl<T: 'static> fmt::Debug for LocalKey<T> {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n+macro_rules! thread_local {\n+    // empty (base case for the recursion)\n+    () => {};\n+\n+    // process multiple declarations\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; $($rest:tt)*) => (\n+        __thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n+        thread_local!($($rest)*);\n+    );\n+\n+    // handle a single declaration\n+    ($(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr) => (\n+        __thread_local_inner!($(#[$attr])* $vis $name, $t, $init);\n+    );\n+}\n+\n+#[cfg(not(stage0))]\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\",\n+           reason = \"should not be necessary\",\n+           issue = \"0\")]\n+#[macro_export]\n+#[allow_internal_unstable]\n+macro_rules! __thread_local_inner {\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n+        $(#[$attr])* $vis static $name: $crate::thread::LocalKey<$t> = {\n+            fn __init() -> $t { $init }\n+\n+            fn __getit() -> $crate::option::Option<\n+                &'static $crate::cell::UnsafeCell<\n+                    $crate::option::Option<$t>>>\n+            {\n+                #[thread_local]\n+                #[cfg(target_thread_local)]\n+                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                    $crate::thread::__FastLocalKeyInner::new();\n+\n+                #[cfg(not(target_thread_local))]\n+                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                    $crate::thread::__OsLocalKeyInner::new();\n+\n+                __KEY.get()\n+            }\n+\n+            $crate::thread::LocalKey::new(__getit, __init)\n+        };\n+    }\n+}\n+\n+#[cfg(stage0)]\n+/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n+#[macro_export]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow_internal_unstable]\n macro_rules! thread_local {\n     // rule 0: empty (base case for the recursion)\n     () => {};\n@@ -164,6 +219,7 @@ macro_rules! thread_local {\n     );\n }\n \n+#[cfg(stage0)]\n #[doc(hidden)]\n #[unstable(feature = \"thread_local_internals\",\n            reason = \"should not be necessary\","}, {"sha": "f786b1abb8a1b4252670e836d2d88bb811d7ec28", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8658908cf822e9425d0841435c111584750aa236/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8658908cf822e9425d0841435c111584750aa236/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8658908cf822e9425d0841435c111584750aa236", "patch": "@@ -222,7 +222,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n                         let tt = quoted::parse(tt.clone().into(), true, sess).pop().unwrap();\n-                        valid &= check_lhs_nt_follows(sess, features, &tt);\n+                        valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n                 }\n@@ -272,11 +272,12 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n \n fn check_lhs_nt_follows(sess: &ParseSess,\n                         features: &RefCell<Features>,\n+                        attrs: &[ast::Attribute],\n                         lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let quoted::TokenTree::Delimited(_, ref tts) = *lhs {\n-        check_matcher(sess, features, &tts.tts)\n+        check_matcher(sess, features, attrs, &tts.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -328,11 +329,12 @@ fn check_rhs(sess: &ParseSess, rhs: &quoted::TokenTree) -> bool {\n \n fn check_matcher(sess: &ParseSess,\n                  features: &RefCell<Features>,\n+                 attrs: &[ast::Attribute],\n                  matcher: &[quoted::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, features, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, features, attrs, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -575,6 +577,7 @@ impl TokenSet {\n // see `FirstSets::new`.\n fn check_matcher_core(sess: &ParseSess,\n                       features: &RefCell<Features>,\n+                      attrs: &[ast::Attribute],\n                       first_sets: &FirstSets,\n                       matcher: &[quoted::TokenTree],\n                       follow: &TokenSet) -> TokenSet {\n@@ -605,7 +608,7 @@ fn check_matcher_core(sess: &ParseSess,\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n                 let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, token) {\n+                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n                     let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n                     sess.span_diagnostic.struct_span_err(token.span(), &msg)\n                         .help(\"valid fragment specifiers are `ident`, `block`, `stmt`, `expr`, \\\n@@ -631,7 +634,7 @@ fn check_matcher_core(sess: &ParseSess,\n             }\n             TokenTree::Delimited(span, ref d) => {\n                 let my_suffix = TokenSet::singleton(d.close_tt(span));\n-                check_matcher_core(sess, features, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, features, attrs, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -663,7 +666,12 @@ fn check_matcher_core(sess: &ParseSess,\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next = check_matcher_core(sess, features, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess,\n+                                              features,\n+                                              attrs,\n+                                              first_sets,\n+                                              &seq_rep.tts,\n+                                              my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -836,12 +844,13 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> Result<bool, (String, &'\n \n fn has_legal_fragment_specifier(sess: &ParseSess,\n                                 features: &RefCell<Features>,\n+                                attrs: &[ast::Attribute],\n                                 tok: &quoted::TokenTree) -> Result<(), String> {\n     debug!(\"has_legal_fragment_specifier({:?})\", tok);\n     if let quoted::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n         let frag_name = frag_spec.name.as_str();\n         let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, &frag_name, frag_span) {\n+        if !is_legal_fragment_specifier(sess, features, attrs, &frag_name, frag_span) {\n             return Err(frag_name.to_string());\n         }\n     }\n@@ -850,13 +859,15 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n \n fn is_legal_fragment_specifier(sess: &ParseSess,\n                                features: &RefCell<Features>,\n+                               attrs: &[ast::Attribute],\n                                frag_name: &str,\n                                frag_span: Span) -> bool {\n     match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" |\n         \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"\" => true,\n         \"vis\" => {\n-            if !features.borrow().macro_vis_matcher {\n+            if     !features.borrow().macro_vis_matcher\n+                && !attr::contains_name(attrs, \"allow_internal_unstable\") {\n                 let explain = feature_gate::EXPLAIN_VIS_MATCHER;\n                 emit_feature_err(sess,\n                                  \"macro_vis_matcher\","}, {"sha": "373824122fd51d90eca3c39aa387f55e4357afb3", "filename": "src/test/run-pass/thread-local-syntax.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8658908cf822e9425d0841435c111584750aa236/src%2Ftest%2Frun-pass%2Fthread-local-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8658908cf822e9425d0841435c111584750aa236/src%2Ftest%2Frun-pass%2Fthread-local-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthread-local-syntax.rs?ref=8658908cf822e9425d0841435c111584750aa236", "patch": "@@ -11,13 +11,21 @@\n #![deny(missing_docs)]\n //! this tests the syntax of `thread_local!`\n \n-thread_local! {\n-    // no docs\n-    #[allow(unused)]\n-    static FOO: i32 = 42;\n-    /// docs\n-    pub static BAR: String = String::from(\"bar\");\n+mod foo {\n+    mod bar {\n+        thread_local! {\n+            // no docs\n+            #[allow(unused)]\n+            static FOO: i32 = 42;\n+            /// docs\n+            pub static BAR: String = String::from(\"bar\");\n+\n+            // look at these restrictions!!\n+            pub(crate) static BAZ: usize = 0;\n+            pub(in foo) static QUUX: usize = 0;\n+        }\n+        thread_local!(static SPLOK: u32 = 0);\n+    }\n }\n-thread_local!(static BAZ: u32 = 0);\n \n fn main() {}"}]}