{"sha": "27cb45e55d07baf1fe4cb4d80901100732d30a37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Y2I0NWU1NWQwN2JhZjFmZTRjYjRkODA5MDExMDA3MzJkMzBhMzc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-13T16:24:05Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-13T16:24:05Z"}, "message": "Merge pull request #160 from Manishearth/dogfood\n\nStart dogfooding clippy", "tree": {"sha": "af331a89e9c4309ab1fd6eb094f71301ed28bb25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af331a89e9c4309ab1fd6eb094f71301ed28bb25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27cb45e55d07baf1fe4cb4d80901100732d30a37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27cb45e55d07baf1fe4cb4d80901100732d30a37", "html_url": "https://github.com/rust-lang/rust/commit/27cb45e55d07baf1fe4cb4d80901100732d30a37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27cb45e55d07baf1fe4cb4d80901100732d30a37/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d8447e0f8f2b2243b75f6f12a8f98a6f0f72c2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8447e0f8f2b2243b75f6f12a8f98a6f0f72c2f", "html_url": "https://github.com/rust-lang/rust/commit/0d8447e0f8f2b2243b75f6f12a8f98a6f0f72c2f"}, {"sha": "3cf5c36296d3f6b2203109c6b1757c83a55f09f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf5c36296d3f6b2203109c6b1757c83a55f09f0", "html_url": "https://github.com/rust-lang/rust/commit/3cf5c36296d3f6b2203109c6b1757c83a55f09f0"}], "stats": {"total": 120, "additions": 79, "deletions": 41}, "files": [{"sha": "7eaa61c557212e6a1597ca1ecc9790face5c47ce", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -5,3 +5,4 @@ sudo: false\n script:\n  - python util/update_lints.py -c\n  - cargo test\n+ - bash util/dogfood.sh"}, {"sha": "be34458e0dc87b32a693fd8b232b13dda8c8c2a6", "filename": "src/collapsible_if.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcollapsible_if.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -45,8 +45,12 @@ fn check_expr_expd(cx: &Context, e: &Expr, info: Option<&ExpnInfo>) {\n     if in_macro(cx, info) { return; }\n \n     if let ExprIf(ref check, ref then, None) = e.node {\n-        if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), ..}) =\n+        if let Some(&Expr{ node: ExprIf(ref check_inner, ref content, None), span: sp, ..}) =\n             single_stmt_of_block(then) {\n+                if e.span.expn_id != sp.expn_id {\n+                    return;\n+                }\n+                cx.sess().note(&format!(\"{:?} -- {:?}\", e.span, sp));\n                 span_help_and_lint(cx, COLLAPSIBLE_IF, e.span,\n                     \"this if statement can be collapsed\",\n                     &format!(\"try\\nif {} && {} {}\","}, {"sha": "0b7511e7dbd9a8d1b5ac529f2b3de9be12240fd2", "filename": "src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -1,3 +1,4 @@\n+#![allow(redundant_closure)] // FIXME (#116)\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::ast_util as ast_util;"}, {"sha": "9135ecaca6c93dfbecbbcc395210d71693132f63", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -1,6 +1,6 @@\n #![feature(plugin_registrar, box_syntax)]\n #![feature(rustc_private, collections)]\n-#![allow(unused_imports)]\n+#![allow(unused_imports, unknown_lints)]\n \n #[macro_use]\n extern crate syntax;"}, {"sha": "c3c915ea777e7ef2a28259bec21fa1a26561b27e", "filename": "src/lifetimes.rs", "status": "modified", "additions": 51, "deletions": 11, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -18,14 +18,23 @@ impl LintPass for LifetimePass {\n         lint_array!(NEEDLESS_LIFETIMES)\n     }\n \n-    fn check_fn(&mut self, cx: &Context, kind: FnKind, decl: &FnDecl,\n-                _: &Block, span: Span, _: NodeId) {\n-        if in_external_macro(cx, span) {\n-            return;\n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+        if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n+            check_fn_inner(cx, decl, None, &generics.lifetimes, item.span);\n         }\n-        if could_use_elision(kind, decl) {\n-            span_lint(cx, NEEDLESS_LIFETIMES, span,\n-                      \"explicit lifetimes given in parameter types where they could be elided\");\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) {\n+        if let MethodImplItem(ref sig, _) = item.node {\n+            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+                           &sig.generics.lifetimes, item.span);\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+        if let MethodTraitItem(ref sig, _) = item.node {\n+            check_fn_inner(cx, &*sig.decl, Some(&sig.explicit_self),\n+                           &sig.generics.lifetimes, item.span);\n         }\n     }\n }\n@@ -39,19 +48,43 @@ enum RefLt {\n }\n use self::RefLt::*;\n \n-fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n+fn check_fn_inner(cx: &Context, decl: &FnDecl, slf: Option<&ExplicitSelf>,\n+                  named_lts: &[LifetimeDef], span: Span) {\n+    if in_external_macro(cx, span) {\n+        return;\n+    }\n+    if could_use_elision(decl, slf, named_lts) {\n+        span_lint(cx, NEEDLESS_LIFETIMES, span,\n+                  \"explicit lifetimes given in parameter types where they could be elided\");\n+    }\n+}\n+\n+fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n+                     named_lts: &[LifetimeDef]) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n+    // All lifetimes must be unnamed, 'static or defined without bounds on the\n+    // level of the current item.\n+\n+    // check named LTs\n+    let mut allowed_lts = HashSet::new();\n+    for lt in named_lts {\n+        if lt.bounds.is_empty() {\n+            allowed_lts.insert(Named(lt.lifetime.name));\n+        }\n+    }\n+    allowed_lts.insert(Unnamed);\n+    allowed_lts.insert(Static);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor(Vec::new());\n     let mut output_visitor = RefVisitor(Vec::new());\n \n     // extract lifetime in \"self\" argument for methods (there is a \"self\" argument\n     // in func.inputs, but its type is TyInfer)\n-    if let FnKind::FkMethod(_, sig, _) = kind {\n-        match sig.explicit_self.node {\n+    if let Some(slf) = slf {\n+        match slf.node {\n             SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n             SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n             _ => { }\n@@ -69,6 +102,13 @@ fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n     let input_lts = input_visitor.into_vec();\n     let output_lts = output_visitor.into_vec();\n \n+    // check for lifetimes from higher scopes\n+    for lt in input_lts.iter().chain(output_lts.iter()) {\n+        if !allowed_lts.contains(lt) {\n+            return false;\n+        }\n+    }\n+\n     // no input lifetimes? easy case!\n     if input_lts.is_empty() {\n         return false;\n@@ -103,7 +143,7 @@ fn could_use_elision(kind: FnKind, func: &FnDecl) -> bool {\n }\n \n /// Number of unique lifetimes in the given vector.\n-fn unique_lifetimes(lts: &Vec<RefLt>) -> usize {\n+fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<HashSet<_>>().len()\n }\n "}, {"sha": "74015bdc6beddf676a7645d293aada3104d93912", "filename": "src/loops.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -31,7 +31,7 @@ impl LintPass for LoopsPass {\n                     walk_expr(&mut visitor, body);\n                     // linting condition: we only indexed one variable\n                     if visitor.indexed.len() == 1 {\n-                        let indexed = visitor.indexed.into_iter().next().unwrap();\n+                        let indexed = visitor.indexed.into_iter().next().expect(\"Len was nonzero, but no contents found\");\n                         if visitor.nonindex {\n                             span_lint(cx, NEEDLESS_RANGE_LOOP, expr.span, &format!(\n                                 \"the loop variable `{}` is used to index `{}`. Consider using \\\n@@ -72,13 +72,12 @@ impl LintPass for LoopsPass {\n \n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n-fn recover_for_loop<'a>(expr: &'a Expr) -> Option<(&'a Pat, &'a Expr, &'a Expr)> {\n+fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n     if_let_chain! {\n         [\n             let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n             let ExprCall(_, ref iterargs) = iterexpr.node,\n-            iterargs.len() == 1,\n-            arms.len() == 1 && arms[0].guard.is_none(),\n+            iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n             let ExprLoop(ref block, _) = arms[0].body.node,\n             block.stmts.is_empty(),\n             let Some(ref loopexpr) = block.expr,"}, {"sha": "7372bfed6c5455f9cca7067d5e4f19fec6a9f644", "filename": "src/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -73,7 +73,7 @@ impl LintPass for TopLevelRefPass {\n     }\n \n     fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n-        for ref arg in decl.inputs.iter() {\n+        for ref arg in &decl.inputs {\n             if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n                 span_lint(cx,\n                     TOPLEVEL_REF_ARG,"}, {"sha": "c54a7f56f7e86781a7ea2dadab7b8c8b76661f81", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -86,7 +86,7 @@ pub fn span_help_and_lint(cx: &Context, lint: &'static Lint, span: Span,\n }\n \n /// return the base type for references and raw pointers\n-pub fn walk_ptrs_ty<'t>(ty: ty::Ty<'t>) -> ty::Ty<'t> {\n+pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) | ty::TyRawPtr(ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty"}, {"sha": "287a8199d2c148f31cd0359221e318135214e8b1", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(needless_lifetimes)]\n-\n+#![allow(dead_code)]\n fn distinct_lifetimes<'a, 'b>(_x: &'a u8, _y: &'b u8, _z: u8) { }\n //~^ERROR explicit lifetimes given\n \n@@ -31,11 +31,13 @@ fn deep_reference_3<'a>(x: &'a u8, _y: u8) -> Result<&'a u8, ()> { Ok(x) }\n \n type Ref<'r> = &'r u8;\n \n-fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) { }\n+fn lifetime_param_1<'a>(_x: Ref<'a>, _y: &'a u8) { } // no error, same lifetime on two params\n \n-fn lifetime_param_2<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { }\n+fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) { }\n //~^ERROR explicit lifetimes given\n \n+fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { } // no error, bounded lifetime\n+\n struct X {\n     x: u8,\n }\n@@ -52,26 +54,13 @@ impl X {\n     fn self_and_same_in<'s>(&'s self, _x: &'s u8) { } // no error, same lifetimes on two params\n }\n \n+struct Foo<'a>(&'a u8);\n+\n+impl<'a> Foo<'a> {\n+    fn self_shared_lifetime(&self, _: &'a u8) {} // no error, lifetime 'a not defined in method\n+    fn self_bound_lifetime<'b: 'a>(&self, _: &'b u8) {} // no error, bounds exist\n+}\n static STATIC: u8 = 1;\n \n fn main() {\n-    distinct_lifetimes(&1, &2, 3);\n-    distinct_and_static(&1, &2, &STATIC);\n-    same_lifetime_on_input(&1, &2);\n-    only_static_on_input(&1, &2, &STATIC);\n-    in_and_out(&1, 2);\n-    multiple_in_and_out_1(&1, &2);\n-    multiple_in_and_out_2(&1, &2);\n-    in_static_and_out(&1, &STATIC);\n-    let _ = deep_reference_1(&1, &2);\n-    let _ = deep_reference_2(Ok(&1));\n-    let _ = deep_reference_3(&1, 2);\n-    lifetime_param_1(&1, &2);\n-    lifetime_param_2(&1, &2);\n-\n-    let foo = X { x: 1 };\n-    foo.self_and_out();\n-    foo.self_and_in_out(&1);\n-    foo.distinct_self_and_in(&1);\n-    foo.self_and_same_in(&1);\n }"}, {"sha": "51dd465a25d7e5aed1d80b919ad31269156b9f97", "filename": "util/dogfood.sh", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27cb45e55d07baf1fe4cb4d80901100732d30a37/util%2Fdogfood.sh", "raw_url": "https://github.com/rust-lang/rust/raw/27cb45e55d07baf1fe4cb4d80901100732d30a37/util%2Fdogfood.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdogfood.sh?ref=27cb45e55d07baf1fe4cb4d80901100732d30a37", "patch": "@@ -0,0 +1,4 @@\n+rm -rf target*/*so\n+cargo build --lib && cp -R target target_recur && cargo rustc -- -Zextra-plugins=clippy -Ltarget_recur/debug   -Dclippy || exit 1\n+rm -rf target_recur\n+"}]}