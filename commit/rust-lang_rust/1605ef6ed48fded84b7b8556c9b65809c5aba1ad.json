{"sha": "1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MDVlZjZlZDQ4ZmRlZDg0YjdiODU1NmM5YjY1ODA5YzVhYmExYWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-12-31T20:39:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-02T10:40:15Z"}, "message": "Rustup to syntax::errors changes", "tree": {"sha": "e24bad1c3d1a9a4216b0a11f0a9e819834864fa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e24bad1c3d1a9a4216b0a11f0a9e819834864fa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "html_url": "https://github.com/rust-lang/rust/commit/1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70486b300659372b5c873f58e76df4ac599cf5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/70486b300659372b5c873f58e76df4ac599cf5e5", "html_url": "https://github.com/rust-lang/rust/commit/70486b300659372b5c873f58e76df4ac599cf5e5"}], "stats": {"total": 175, "additions": 107, "deletions": 68}, "files": [{"sha": "3ab2c9ef6e860f2a343c8458f51dfff7aa82d9b3", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.33\"\n+version = \"0.0.34\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "7beb3296aac354c22bd2f341cbde9d710819a09c", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -9,7 +9,7 @@ use syntax::attr::*;\n use syntax::ast::Attribute;\n use rustc_front::intravisit::{Visitor, walk_expr};\n \n-use utils::{in_macro, LimitStack};\n+use utils::{in_macro, LimitStack, span_help_and_lint};\n \n /// **What it does:** It `Warn`s on methods with high cyclomatic complexity\n ///\n@@ -59,8 +59,8 @@ impl CyclomaticComplexity {\n         } else {\n             let rust_cc = cc + divergence - narms;\n             if rust_cc > self.limit.limit() {\n-                cx.span_lint_help(CYCLOMATIC_COMPLEXITY, span,\n-                &format!(\"The function has a cyclomatic complexity of {}.\", rust_cc),\n+                span_help_and_lint(cx, CYCLOMATIC_COMPLEXITY, span,\n+                &format!(\"The function has a cyclomatic complexity of {}\", rust_cc),\n                 \"You could split it up into multiple smaller functions\");\n             }\n         }\n@@ -140,8 +140,9 @@ fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n #[cfg(not(feature=\"debugging\"))]\n fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, span: Span) {\n     if cx.current_level(CYCLOMATIC_COMPLEXITY) != Level::Allow {\n-        cx.sess().span_note(span, &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n-                                            (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n-                                            cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));\n+        cx.sess().span_note_without_error(span,\n+                                          &format!(\"Clippy encountered a bug calculating cyclomatic complexity \\\n+                                                    (hide this message with `#[allow(cyclomatic_complexity)]`): \\\n+                                                    cc = {}, arms = {}, div = {}. Please file a bug report.\", cc, narms, div));\n     }\n }"}, {"sha": "6b561ff7a0532d0267ed155de91242d25bad5a61", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -84,9 +84,9 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 }\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span,\n                                    \"redundant closure found\",\n-                                   || {\n+                                   |db| {\n                     if let Some(snippet) = snippet_opt(cx, caller.span) {\n-                        cx.sess().span_suggestion(expr.span,\n+                        db.span_suggestion(expr.span,\n                                                   \"remove closure as shown:\",\n                                                   snippet);\n                     }"}, {"sha": "d574fa2c336a618c9517c9049171d6f181ce0a40", "filename": "src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -135,7 +135,7 @@ fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n             has_is_empty(cx, &args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n                     \"consider replacing the len comparison with `{}{}.is_empty()`\",\n-                    op, snippet(cx, args[0].span, \"_\")))\n+                    op, snippet(cx, args[0].span, \"_\")));\n             }\n     }\n }"}, {"sha": "2a8e064f9f4a8fcb156647097dd9c369b24edf58", "filename": "src/minmax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -37,7 +37,7 @@ impl LateLintPass for MinMaxPass {\n                     (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span,\n-                            \"this min/max combination leads to constant result\")\n+                            \"this min/max combination leads to constant result\");\n                     }\n                 }\n             }"}, {"sha": "db6f0e0320bc159e7ff05d65c4f00677ab373084", "filename": "src/mut_mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_mut.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -30,8 +30,8 @@ impl LateLintPass for MutMut {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext, ty: &Ty) {\n-        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| span_lint(cx, MUT_MUT,\n-            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"))\n+        unwrap_mut(ty).and_then(unwrap_mut).map_or((), |_| { span_lint(cx, MUT_MUT,\n+            ty.span, \"generally you want to avoid `&mut &mut _` if possible\"); });\n     }\n }\n \n@@ -52,12 +52,12 @@ fn check_expr_mut(cx: &LateContext, expr: &Expr) {\n                     cx.tcx.expr_ty(e).sty {\n                         span_lint(cx, MUT_MUT, expr.span,\n                                   \"this expression mutably borrows a mutable reference. \\\n-                                   Consider reborrowing\")\n+                                   Consider reborrowing\");\n                 }\n             },\n             |_| {\n                 span_lint(cx, MUT_MUT, expr.span,\n-                          \"generally you want to avoid `&mut &mut _` if possible\")\n+                          \"generally you want to avoid `&mut &mut _` if possible\");\n             }\n         )\n     })"}, {"sha": "8899eb56d42043868cf84846862d1a640e656f83", "filename": "src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmutex_atomic.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -63,7 +63,7 @@ impl LateLintPass for MutexAtomic {\n                         ty::TyInt(t) if t != ast::TyIs =>\n                             span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg)\n-                    }\n+                    };\n                 }\n             }\n         }"}, {"sha": "91ff0680b3e2f8834fa70e8b331c143e328e76cc", "filename": "src/precedence.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprecedence.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -33,21 +33,27 @@ impl EarlyLintPass for Precedence {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if !is_bit_op(op) { return; }\n             match (is_arith_expr(left), is_arith_expr(right)) {\n-                (true, true) =>  span_lint(cx, PRECEDENCE, expr.span,\n+                (true, true) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (true, false) => span_lint(cx, PRECEDENCE, expr.span,\n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n+                (true, false) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `({}) {} {}`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n-                (false, true) => span_lint(cx, PRECEDENCE, expr.span,\n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n+                (false, true) => {\n+                    span_lint(cx, PRECEDENCE, expr.span, \n                     &format!(\"operator precedence can trip the unwary. \\\n                          Consider parenthesizing your expression:\\\n                          `{} {} ({})`\", snippet(cx, left.span, \"..\"),\n-                         op.to_string(), snippet(cx, right.span, \"..\"))),\n+                         op.to_string(), snippet(cx, right.span, \"..\")));\n+                },\n                 _ => (),\n             }\n         }\n@@ -57,12 +63,13 @@ impl EarlyLintPass for Precedence {\n                 if let Some(slf) = args.first() {\n                     if let ExprLit(ref lit) = slf.node {\n                         match lit.node {\n-                            LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) =>\n+                            LitInt(..) | LitFloat(..) | LitFloatUnsuffixed(..) => {\n                                 span_lint(cx, PRECEDENCE, expr.span, &format!(\n                                     \"unary minus has lower precedence than \\\n                                      method call. Consider adding parentheses \\\n                                      to clarify your intent: -({})\",\n-                                     snippet(cx, rhs.span, \"..\"))),\n+                                     snippet(cx, rhs.span, \"..\")));\n+                            }\n                             _ => ()\n                         }\n                     }"}, {"sha": "15f9bb80d95118dee37b1f16b705ca60a90714af", "filename": "src/returns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freturns.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -75,9 +75,9 @@ impl ReturnPass {\n         if in_external_macro(cx, spans.1) {return;}\n         span_lint_and_then(cx, NEEDLESS_RETURN, spans.0,\n                            \"unneeded return statement\",\n-                           || {\n+                           |db| {\n             if let Some(snippet) = snippet_opt(cx, spans.1) {\n-                cx.sess().span_suggestion(spans.0,\n+                db.span_suggestion(spans.0,\n                                           \"remove `return` as shown:\",\n                                           snippet);\n             }\n@@ -105,11 +105,11 @@ impl ReturnPass {\n \n     fn emit_let_lint(&mut self, cx: &EarlyContext, lint_span: Span, note_span: Span) {\n         if in_external_macro(cx, note_span) {return;}\n-        span_lint(cx, LET_AND_RETURN, lint_span,\n+        let mut db = span_lint(cx, LET_AND_RETURN, lint_span,\n                   \"returning the result of a let binding from a block. \\\n                    Consider returning the expression directly.\");\n         if cx.current_level(LET_AND_RETURN) != Level::Allow {\n-            cx.sess().span_note(note_span,\n+            db.span_note(note_span,\n                                 \"this expression can be directly returned\");\n         }\n     }"}, {"sha": "1210590bbcb83af2f99d342d0b8c162f48a5ae53", "filename": "src/shadow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -7,7 +7,7 @@ use rustc_front::intravisit::{Visitor, FnKind};\n use rustc::lint::*;\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n-use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint};\n+use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint, span_note_and_lint, DiagnosticWrapper};\n \n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability. It is `Allow` by default.\n ///\n@@ -180,39 +180,39 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span,\n \n fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, lspan: Span, init:\n         &Option<T>, prev_span: Span) where T: Deref<Target=Expr> {\n-    fn note_orig(cx: &LateContext, lint: &'static Lint, span: Span) {\n+    fn note_orig(cx: &LateContext, mut db: DiagnosticWrapper, lint: &'static Lint, span: Span) {\n         if cx.current_level(lint) != Level::Allow {\n-            cx.sess().span_note(span, \"previous binding is here\");\n+            db.span_note(span, \"previous binding is here\");\n         }\n     }\n     if let Some(ref expr) = *init {\n         if is_self_shadow(name, expr) {\n-            span_lint(cx, SHADOW_SAME, span, &format!(\n+            let db = span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n                 snippet(cx, expr.span, \"..\")));\n-                note_orig(cx, SHADOW_SAME, prev_span);\n+                note_orig(cx, db, SHADOW_SAME, prev_span);\n         } else {\n             if contains_self(name, expr) {\n-                span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n+                let db = span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n-                note_orig(cx, SHADOW_REUSE, prev_span);\n+                note_orig(cx, db, SHADOW_REUSE, prev_span);\n             } else {\n-                span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n+                let db = span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n                     \"{} is shadowed by {}\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n-                note_orig(cx, SHADOW_UNRELATED, prev_span);\n+                note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n             }\n         }\n     } else {\n-        span_lint(cx, SHADOW_UNRELATED, span, &format!(\n+        let db = span_lint(cx, SHADOW_UNRELATED, span, &format!(\n             \"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n-        note_orig(cx, SHADOW_UNRELATED, prev_span);\n+        note_orig(cx, db, SHADOW_UNRELATED, prev_span);\n     }\n }\n "}, {"sha": "861ae0bb012986e51fb0bcacc0ac925950398018", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -75,13 +75,13 @@ impl LateLintPass for StringAdd {\n                 }\n                 span_lint(cx, STRING_ADD, e.span,\n                     \"you added something to a string. \\\n-                     Consider using `String::push_str()` instead\")\n+                     Consider using `String::push_str()` instead\");\n             }\n         } else if let ExprAssign(ref target, ref src) = e.node {\n             if is_string(cx, target) && is_add(cx, src, target) {\n                 span_lint(cx, STRING_ADD_ASSIGN, e.span,\n                     \"you assigned the result of adding something to this string. \\\n-                     Consider using `String::push_str()` instead\")\n+                     Consider using `String::push_str()` instead\");\n             }\n         }\n     }"}, {"sha": "7c0ee09b3cd79adb656a4d35c514b4b29ad38f36", "filename": "src/utils.rs", "status": "modified", "additions": 56, "deletions": 26, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -8,10 +8,12 @@ use rustc::middle::ty;\n use std::borrow::Cow;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n use rustc::session::Session;\n use std::str::FromStr;\n+use std::ops::{Deref, DerefMut};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -307,63 +309,91 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n     } else { None }\n }\n \n+pub struct DiagnosticWrapper<'a>(pub DiagnosticBuilder<'a>);\n+\n+impl<'a> Drop for DiagnosticWrapper<'a> {\n+    fn drop(&mut self) {\n+        self.0.emit();\n+    }\n+}\n+\n+impl<'a> DerefMut for DiagnosticWrapper<'a> {\n+    fn deref_mut(&mut self) -> &mut DiagnosticBuilder<'a> {\n+        &mut self.0\n+    } \n+}\n+\n+impl<'a> Deref for DiagnosticWrapper<'a> {\n+    type Target = DiagnosticBuilder<'a>;\n+    fn deref(&self) -> &DiagnosticBuilder<'a> {\n+        &self.0\n+    } \n+}\n+\n #[cfg(not(feature=\"structured_logging\"))]\n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n-    cx.span_lint(lint, sp, msg);\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n+                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n #[cfg(feature=\"structured_logging\")]\n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint,\n+                                     sp: Span, msg: &str) -> DiagnosticWrapper<'a> {\n     // lint.name / lint.desc is can give details of the lint\n     // cx.sess().codemap() has all these nice functions for line/column/snippet details\n     // http://doc.rust-lang.org/syntax/codemap/struct.CodeMap.html#method.span_to_string\n-    cx.span_lint(lint, sp, msg);\n+    let mut db = cx.struct_span_lint(lint, sp, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_help_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n-        msg: &str, help: &str) {\n-    cx.span_lint(lint, span, msg);\n+pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n+        msg: &str, help: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n-        cx.sess().fileline_help(span, &format!(\"{}\\nfor further information \\\n+        db.fileline_help(span, &format!(\"{}\\nfor further information \\\n             visit https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            help, lint.name_lower()))\n+            help, lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_note_and_lint<T: LintContext>(cx: &T, lint: &'static Lint, span: Span,\n-        msg: &str, note_span: Span, note: &str) {\n-    cx.span_lint(lint, span, msg);\n+pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span,\n+        msg: &str, note_span: Span, note: &str) -> DiagnosticWrapper<'a> {\n+    let mut db = cx.struct_span_lint(lint, span, msg);\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n-            cx.sess().fileline_note(note_span, note)\n+            db.fileline_note(note_span, note);\n         } else {\n-            cx.sess().span_note(note_span, note)\n+            db.span_note(note_span, note);\n         }\n-        cx.sess().fileline_help(span, &format!(\"for further information visit \\\n+        db.fileline_help(span, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    DiagnosticWrapper(db)\n }\n \n-pub fn span_lint_and_then<T: LintContext, F>(cx: &T, lint: &'static Lint, sp: Span,\n-        msg: &str, f: F) where F: Fn() {\n-    cx.span_lint(lint, sp, msg);\n+pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span,\n+        msg: &str, f: F) -> DiagnosticWrapper<'a> where F: Fn(&mut DiagnosticWrapper) {\n+    let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n-        f();\n-        cx.sess().fileline_help(sp, &format!(\"for further information visit \\\n+        f(&mut db);\n+        db.fileline_help(sp, &format!(\"for further information visit \\\n             https://github.com/Manishearth/rust-clippy/wiki#{}\",\n-            lint.name_lower()))\n+            lint.name_lower()));\n     }\n+    db\n }\n \n /// return the base type for references and raw pointers"}, {"sha": "f79440af1210f6fc684822dc995ee0cc201eaa66", "filename": "tests/compile-fail/cyclomatic_complexity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1605ef6ed48fded84b7b8556c9b65809c5aba1ad/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcyclomatic_complexity.rs?ref=1605ef6ed48fded84b7b8556c9b65809c5aba1ad", "patch": "@@ -4,7 +4,8 @@\n #![deny(cyclomatic_complexity)]\n #![allow(unused)]\n \n-fn main() { //~ ERROR: The function has a cyclomatic complexity of 28.\n+\n+fn main() { //~ERROR The function has a cyclomatic complexity of 28\n     if true {\n         println!(\"a\");\n     }"}]}