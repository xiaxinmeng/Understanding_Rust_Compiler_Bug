{"sha": "1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYmQ2ZTYwOWNiMWZlZjE3ZTc0NTRiYjZjZWQ2NmEzN2Y3NDNkZWQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T12:47:14Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-05-22T12:47:14Z"}, "message": "get rid of Rc in data_race", "tree": {"sha": "661dfade6f8ad3df46cbefc1740fba2d6c43321b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/661dfade6f8ad3df46cbefc1740fba2d6c43321b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "html_url": "https://github.com/rust-lang/rust/commit/1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca7283d746012397faa266b39dee78609b74ed64", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7283d746012397faa266b39dee78609b74ed64", "html_url": "https://github.com/rust-lang/rust/commit/ca7283d746012397faa266b39dee78609b74ed64"}], "stats": {"total": 53, "additions": 23, "deletions": 30}, "files": [{"sha": "ff6c720740a1140c0c5e3ddb156f98fafe20e902", "filename": "src/data_race.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "patch": "@@ -65,7 +65,6 @@ use std::{\n     cell::{Cell, Ref, RefCell, RefMut},\n     fmt::Debug,\n     mem,\n-    rc::Rc,\n };\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -80,7 +79,7 @@ use crate::{\n };\n \n pub type AllocExtra = VClockAlloc;\n-pub type MemoryExtra = Rc<GlobalState>;\n+pub type MemoryExtra = GlobalState;\n \n /// Valid atomic read-write operations, alias of atomic::Ordering (not non-exhaustive).\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -488,7 +487,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         let this = self.eval_context_ref();\n         let scalar = this.allow_data_races_ref(move |this| this.read_scalar(&place.into()))?;\n-        self.validate_atomic_load(place, atomic)?;\n+        this.validate_atomic_load(place, atomic)?;\n         Ok(scalar)\n     }\n \n@@ -501,7 +500,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.allow_data_races_mut(move |this| this.write_scalar(val, &(*dest).into()))?;\n-        self.validate_atomic_store(dest, atomic)\n+        this.validate_atomic_store(dest, atomic)\n     }\n \n     /// Perform a atomic operation on a memory location.\n@@ -733,9 +732,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n pub struct VClockAlloc {\n     /// Assigning each byte a MemoryCellClocks.\n     alloc_ranges: RefCell<RangeMap<MemoryCellClocks>>,\n-\n-    /// Pointer to global state.\n-    global: MemoryExtra,\n }\n \n impl VClockAlloc {\n@@ -767,7 +763,6 @@ impl VClockAlloc {\n             | MemoryKind::Vtable => (0, VectorIdx::MAX_INDEX),\n         };\n         VClockAlloc {\n-            global: Rc::clone(global),\n             alloc_ranges: RefCell::new(RangeMap::new(\n                 len,\n                 MemoryCellClocks::new(alloc_timestamp, alloc_index),\n@@ -888,15 +883,15 @@ impl VClockAlloc {\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation for which data-race detection is handled separately, for example\n     /// atomic read operations.\n-    pub fn read<'tcx>(&self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        if self.global.multi_threaded.get() {\n-            let (index, clocks) = self.global.current_thread_state();\n+    pub fn read<'tcx>(&self, pointer: Pointer<Tag>, len: Size, global: &GlobalState) -> InterpResult<'tcx> {\n+        if global.multi_threaded.get() {\n+            let (index, clocks) = global.current_thread_state();\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (_, range) in alloc_ranges.iter_mut(pointer.offset, len) {\n                 if let Err(DataRace) = range.read_race_detect(&*clocks, index) {\n                     // Report data-race.\n                     return Self::report_data_race(\n-                        &self.global,\n+                        global,\n                         range,\n                         \"Read\",\n                         false,\n@@ -917,14 +912,15 @@ impl VClockAlloc {\n         pointer: Pointer<Tag>,\n         len: Size,\n         write_type: WriteType,\n+        global: &mut GlobalState,\n     ) -> InterpResult<'tcx> {\n-        if self.global.multi_threaded.get() {\n-            let (index, clocks) = self.global.current_thread_state();\n+        if global.multi_threaded.get() {\n+            let (index, clocks) = global.current_thread_state();\n             for (_, range) in self.alloc_ranges.get_mut().iter_mut(pointer.offset, len) {\n                 if let Err(DataRace) = range.write_race_detect(&*clocks, index, write_type) {\n                     // Report data-race\n                     return Self::report_data_race(\n-                        &self.global,\n+                        global,\n                         range,\n                         write_type.get_descriptor(),\n                         false,\n@@ -943,16 +939,16 @@ impl VClockAlloc {\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Write)\n+    pub fn write<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size, global: &mut GlobalState) -> InterpResult<'tcx> {\n+        self.unique_access(pointer, len, WriteType::Write, global)\n     }\n \n     /// Detect data-races for an unsynchronized deallocate operation, will not perform\n     /// data-race threads if `multi-threaded` is false, either due to no threads\n     /// being created or if it is temporarily disabled during a racy read or write\n     /// operation\n-    pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size) -> InterpResult<'tcx> {\n-        self.unique_access(pointer, len, WriteType::Deallocate)\n+    pub fn deallocate<'tcx>(&mut self, pointer: Pointer<Tag>, len: Size, global: &mut GlobalState) -> InterpResult<'tcx> {\n+        self.unique_access(pointer, len, WriteType::Deallocate, global)\n     }\n }\n \n@@ -1035,15 +1031,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n                 );\n \n                 // Perform the atomic operation.\n-                let data_race = &alloc_meta.global;\n                 data_race.maybe_perform_sync_operation(|index, mut clocks| {\n                     for (_, range) in\n                         alloc_meta.alloc_ranges.borrow_mut().iter_mut(place_ptr.offset, size)\n                     {\n                         if let Err(DataRace) = op(range, &mut *clocks, index, atomic) {\n                             mem::drop(clocks);\n                             return VClockAlloc::report_data_race(\n-                                &alloc_meta.global,\n+                                data_race,\n                                 range,\n                                 description,\n                                 true,"}, {"sha": "ce4b96ad4a46922994f5bce4cbdb8a322451767b", "filename": "src/machine.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "patch": "@@ -5,7 +5,6 @@ use std::borrow::Cow;\n use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n-use std::rc::Rc;\n use std::time::Instant;\n \n use log::trace;\n@@ -153,7 +152,7 @@ impl MemoryExtra {\n             None\n         };\n         let data_race = if config.data_race_detector {\n-            Some(Rc::new(data_race::GlobalState::new()))\n+            Some(data_race::GlobalState::new())\n         } else {\n             None\n         };\n@@ -513,7 +512,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n-            data_race.read(ptr, size)?;\n+            data_race.read(ptr, size, memory_extra.data_race.as_ref().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n             stacked_borrows.memory_read(ptr, size, memory_extra.stacked_borrows.as_ref().unwrap())\n@@ -530,7 +529,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         size: Size,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.write(ptr, size)?;\n+            data_race.write(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_written(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())\n@@ -550,7 +549,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             register_diagnostic(NonHaltingDiagnostic::FreedAlloc(ptr.alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n-            data_race.deallocate(ptr, size)?;\n+            data_race.deallocate(ptr, size, memory_extra.data_race.as_mut().unwrap())?;\n         }\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.memory_deallocated(ptr, size, memory_extra.stacked_borrows.as_mut().unwrap())"}, {"sha": "8aaeb7e349c62683c736721a655315ecad421d20", "filename": "src/thread.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbd6e609cb1fef17e7454bb6ced66a37f743ded/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=1bbd6e609cb1fef17e7454bb6ced66a37f743ded", "patch": "@@ -4,7 +4,6 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n use std::convert::TryFrom;\n use std::num::TryFromIntError;\n-use std::rc::Rc;\n use std::time::{Duration, Instant, SystemTime};\n \n use log::trace;\n@@ -333,7 +332,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn join_thread(\n         &mut self,\n         joined_thread_id: ThreadId,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n+        data_race: &Option<data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n         if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n             throw_ub_format!(\"trying to join a detached or already joined thread\");\n@@ -439,7 +438,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// The `AllocId` that can now be freed is returned.\n     fn thread_terminated(\n         &mut self,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n+        data_race: &Option<data_race::GlobalState>,\n     ) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n@@ -481,7 +480,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// blocked, terminated, or has explicitly asked to be preempted).\n     fn schedule(\n         &mut self,\n-        data_race: &Option<Rc<data_race::GlobalState>>,\n+        data_race: &Option<data_race::GlobalState>,\n     ) -> InterpResult<'tcx, SchedulingAction> {\n         // Check whether the thread has **just** terminated (`check_terminated`\n         // checks whether the thread has popped all its stack and if yes, sets"}]}