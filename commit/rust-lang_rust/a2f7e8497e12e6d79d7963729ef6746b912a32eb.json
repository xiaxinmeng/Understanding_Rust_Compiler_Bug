{"sha": "a2f7e8497e12e6d79d7963729ef6746b912a32eb", "node_id": "C_kwDOAAsO6NoAKGEyZjdlODQ5N2UxMmU2ZDc5ZDc5NjM3MjllZjY3NDZiOTEyYTMyZWI", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-30T21:56:49Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-11-05T21:47:51Z"}, "message": "use enum for condvar locks", "tree": {"sha": "412d4e7979790ec7519e81bc6c566ceecb3f02aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/412d4e7979790ec7519e81bc6c566ceecb3f02aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f7e8497e12e6d79d7963729ef6746b912a32eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f7e8497e12e6d79d7963729ef6746b912a32eb", "html_url": "https://github.com/rust-lang/rust/commit/a2f7e8497e12e6d79d7963729ef6746b912a32eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f7e8497e12e6d79d7963729ef6746b912a32eb/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1d94d43ac876975e15b5069da1f9b7a81e29733", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d94d43ac876975e15b5069da1f9b7a81e29733", "html_url": "https://github.com/rust-lang/rust/commit/a1d94d43ac876975e15b5069da1f9b7a81e29733"}], "stats": {"total": 120, "additions": 76, "deletions": 44}, "files": [{"sha": "ba5ae852c5a960663d694ca6eb9ca0020047730c", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=a2f7e8497e12e6d79d7963729ef6746b912a32eb", "patch": "@@ -116,15 +116,25 @@ struct RwLock {\n \n declare_id!(CondvarId);\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum RwLockMode {\n+    Read,\n+    Write,\n+}\n+\n+#[derive(Debug)]\n+pub enum CondvarLock {\n+    Mutex(MutexId),\n+    RwLock { id: RwLockId, mode: RwLockMode },\n+}\n+\n /// A thread waiting on a conditional variable.\n #[derive(Debug)]\n struct CondvarWaiter {\n     /// The thread that is waiting on this variable.\n     thread: ThreadId,\n     /// The mutex or rwlock on which the thread is waiting.\n-    lock: u32,\n-    /// If the lock is shared or exclusive\n-    shared: bool,\n+    lock: CondvarLock,\n }\n \n /// The conditional variable state.\n@@ -571,16 +581,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark that the thread is waiting on the conditional variable.\n-    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: u32, shared: bool) {\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: CondvarLock) {\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, lock, shared });\n+        waiters.push_back(CondvarWaiter { thread, lock });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional\n     /// variable.\n-    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, u32, bool)> {\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n@@ -594,7 +604,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n-            (waiter.thread, waiter.lock, waiter.shared)\n+            (waiter.thread, waiter.lock)\n         })\n     }\n "}, {"sha": "a7275646847e29ed42c09ceede08e0cea1f6ccb7", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=a2f7e8497e12e6d79d7963729ef6746b912a32eb", "patch": "@@ -3,6 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n+use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n \n@@ -696,9 +697,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        if let Some((thread, mutex, shared)) = this.condvar_signal(id) {\n-            assert!(!shared);\n-            post_cond_signal(this, thread, MutexId::from_u32(mutex))?;\n+        if let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -711,9 +715,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, mutex, shared)) = this.condvar_signal(id) {\n-            assert!(!shared);\n-            post_cond_signal(this, thread, MutexId::from_u32(mutex))?;\n+        while let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -731,7 +738,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id.to_u32(), false);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         Ok(0)\n     }\n@@ -770,7 +777,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id.to_u32(), false);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;"}, {"sha": "a34d142f4a5ef35405907ee3ecabe1aadce38540", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f7e8497e12e6d79d7963729ef6746b912a32eb/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=a2f7e8497e12e6d79d7963729ef6746b912a32eb", "patch": "@@ -3,6 +3,7 @@ use std::time::Duration;\n use rustc_target::abi::Size;\n \n use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::sync::{CondvarLock, RwLockMode};\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n@@ -18,23 +19,24 @@ pub trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tc\n         &mut self,\n         thread: ThreadId,\n         lock: RwLockId,\n-        shared: bool,\n+        mode: RwLockMode,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.unblock_thread(thread);\n \n-        if shared {\n-            if this.rwlock_is_locked(lock) {\n-                this.rwlock_enqueue_and_block_reader(lock, thread);\n-            } else {\n-                this.rwlock_reader_lock(lock, thread);\n-            }\n-        } else {\n-            if this.rwlock_is_write_locked(lock) {\n-                this.rwlock_enqueue_and_block_writer(lock, thread);\n-            } else {\n-                this.rwlock_writer_lock(lock, thread);\n-            }\n+        match mode {\n+            RwLockMode::Read =>\n+                if this.rwlock_is_locked(lock) {\n+                    this.rwlock_enqueue_and_block_reader(lock, thread);\n+                } else {\n+                    this.rwlock_reader_lock(lock, thread);\n+                },\n+            RwLockMode::Write =>\n+                if this.rwlock_is_write_locked(lock) {\n+                    this.rwlock_enqueue_and_block_writer(lock, thread);\n+                } else {\n+                    this.rwlock_writer_lock(lock, thread);\n+                },\n         }\n \n         Ok(())\n@@ -383,14 +385,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         let shared_mode = 0x1; // CONDITION_VARIABLE_LOCKMODE_SHARED is not in std\n-        let shared = flags == shared_mode;\n+        let mode = if flags == 0 {\n+            RwLockMode::Write\n+        } else if flags == shared_mode {\n+            RwLockMode::Read\n+        } else {\n+            throw_unsup_format!(\"unsupported `Flags` {flags} in `SleepConditionVariableSRW`\");\n+        };\n \n         let active_thread = this.get_active_thread();\n \n-        let was_locked = if shared {\n-            this.rwlock_reader_unlock(lock_id, active_thread)\n-        } else {\n-            this.rwlock_writer_unlock(lock_id, active_thread)\n+        let was_locked = match mode {\n+            RwLockMode::Read => this.rwlock_reader_unlock(lock_id, active_thread),\n+            RwLockMode::Write => this.rwlock_writer_unlock(lock_id, active_thread),\n         };\n \n         if !was_locked {\n@@ -400,27 +407,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         this.block_thread(active_thread);\n-        this.condvar_wait(condvar_id, active_thread, lock_id.to_u32(), shared);\n+        this.condvar_wait(condvar_id, active_thread, CondvarLock::RwLock { id: lock_id, mode });\n \n         if let Some(timeout_time) = timeout_time {\n             struct Callback<'tcx> {\n                 thread: ThreadId,\n                 condvar_id: CondvarId,\n                 lock_id: RwLockId,\n-                shared: bool,\n+                mode: RwLockMode,\n                 dest: PlaceTy<'tcx, Provenance>,\n             }\n \n             impl<'tcx> VisitTags for Callback<'tcx> {\n                 fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n-                    let Callback { thread: _, condvar_id: _, lock_id: _, shared: _, dest } = self;\n+                    let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n                     dest.visit_tags(visit);\n                 }\n             }\n \n             impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n                 fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n-                    this.reacquire_cond_lock(self.thread, self.lock_id, self.shared)?;\n+                    this.reacquire_cond_lock(self.thread, self.lock_id, self.mode)?;\n \n                     this.condvar_remove_waiter(self.condvar_id, self.thread);\n \n@@ -438,7 +445,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     thread: active_thread,\n                     condvar_id,\n                     lock_id,\n-                    shared,\n+                    mode,\n                     dest: dest.clone(),\n                 }),\n             );\n@@ -451,9 +458,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n \n-        if let Some((thread, lock, shared)) = this.condvar_signal(condvar_id) {\n-            this.reacquire_cond_lock(thread, RwLockId::from_u32(lock), shared)?;\n-            this.unregister_timeout_callback_if_exists(thread);\n+        if let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n         }\n \n         Ok(())\n@@ -466,9 +477,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, lock, shared)) = this.condvar_signal(condvar_id) {\n-            this.reacquire_cond_lock(thread, RwLockId::from_u32(lock), shared)?;\n-            this.unregister_timeout_callback_if_exists(thread);\n+        while let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n         }\n \n         Ok(())"}]}