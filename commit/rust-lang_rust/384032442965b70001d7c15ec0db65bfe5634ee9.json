{"sha": "384032442965b70001d7c15ec0db65bfe5634ee9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NDAzMjQ0Mjk2NWI3MDAwMWQ3YzE1ZWMwZGI2NWJmZTU2MzRlZTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-27T08:32:39Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-27T08:49:13Z"}, "message": "raw string assists work in macros", "tree": {"sha": "ec88b0a3e4142954a1f4a22c69639856ca5b0302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec88b0a3e4142954a1f4a22c69639856ca5b0302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/384032442965b70001d7c15ec0db65bfe5634ee9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/384032442965b70001d7c15ec0db65bfe5634ee9", "html_url": "https://github.com/rust-lang/rust/commit/384032442965b70001d7c15ec0db65bfe5634ee9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/384032442965b70001d7c15ec0db65bfe5634ee9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85f6d522af7630ab227762076a9fbf75de502de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85f6d522af7630ab227762076a9fbf75de502de", "html_url": "https://github.com/rust-lang/rust/commit/b85f6d522af7630ab227762076a9fbf75de502de"}], "stats": {"total": 107, "additions": 58, "deletions": 49}, "files": [{"sha": "9c996c9028c4aa4a1b8388a5b10de8ed1f5bc809", "filename": "crates/ra_assists/src/assists/raw_string.rs", "status": "modified", "additions": 58, "deletions": 49, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/384032442965b70001d7c15ec0db65bfe5634ee9/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384032442965b70001d7c15ec0db65bfe5634ee9/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs?ref=384032442965b70001d7c15ec0db65bfe5634ee9", "patch": "@@ -1,17 +1,19 @@\n //! FIXME: write short doc here\n \n use hir::db::HirDatabase;\n-use ra_syntax::{ast::AstNode, ast::Literal, TextRange, TextUnit};\n+use ra_syntax::{\n+    SyntaxKind::{RAW_STRING, STRING},\n+    SyntaxToken, TextRange, TextUnit,\n+};\n use rustc_lexer;\n \n use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::STRING {\n+    let token = ctx.token_at_offset().right_biased()?;\n+    if token.kind() != STRING {\n         return None;\n     }\n-    let token = literal.token();\n     let text = token.text().as_str();\n     let usual_string_range = find_usual_string_range(text)?;\n     let start_of_inside = usual_string_range.start().to_usize() + 1;\n@@ -30,85 +32,52 @@ pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n         return None;\n     }\n     ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+        edit.target(token.text_range());\n         let max_hash_streak = count_hashes(&unescaped);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n             hashes.push('#');\n         }\n-        edit.replace(\n-            literal.syntax().text_range(),\n-            format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes),\n-        );\n+        edit.replace(token.text_range(), format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes));\n     });\n     ctx.build()\n }\n \n-fn count_hashes(s: &str) -> usize {\n-    let mut max_hash_streak = 0usize;\n-    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n-        let (_, sub) = s.split_at(idx + 1);\n-        let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n-        if nb_hash > max_hash_streak {\n-            max_hash_streak = nb_hash;\n-        }\n-    }\n-    max_hash_streak\n-}\n-\n-fn find_usual_string_range(s: &str) -> Option<TextRange> {\n-    Some(TextRange::from_to(\n-        TextUnit::from(s.find('\"')? as u32),\n-        TextUnit::from(s.rfind('\"')? as u32),\n-    ))\n-}\n-\n pub(crate) fn make_usual_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n-    let token = literal.token();\n+    let token = raw_string_token(&ctx)?;\n     let text = token.text().as_str();\n     let usual_string_range = find_usual_string_range(text)?;\n     ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+        edit.target(token.text_range());\n         // parse inside string to escape `\"`\n         let start_of_inside = usual_string_range.start().to_usize() + 1;\n         let end_of_inside = usual_string_range.end().to_usize();\n         let inside_str = &text[start_of_inside..end_of_inside];\n         let escaped = inside_str.escape_default().to_string();\n-        edit.replace(literal.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n+        edit.replace(token.text_range(), format!(\"\\\"{}\\\"\", escaped));\n     });\n     ctx.build()\n }\n \n pub(crate) fn add_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n+    let token = raw_string_token(&ctx)?;\n     ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n-        edit.insert(literal.syntax().text_range().start() + TextUnit::of_char('r'), \"#\");\n-        edit.insert(literal.syntax().text_range().end(), \"#\");\n+        edit.target(token.text_range());\n+        edit.insert(token.text_range().start() + TextUnit::of_char('r'), \"#\");\n+        edit.insert(token.text_range().end(), \"#\");\n     });\n     ctx.build()\n }\n \n pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let literal = ctx.node_at_offset::<Literal>()?;\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n-        return None;\n-    }\n-    let token = literal.token();\n+    let token = raw_string_token(&ctx)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n     ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\n-        edit.target(literal.syntax().text_range());\n+        edit.target(token.text_range());\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with(\"\\\"\") {\n             // no more hash, escape\n@@ -117,11 +86,34 @@ pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist\n         } else {\n             result.to_owned()\n         };\n-        edit.replace(literal.syntax().text_range(), format!(\"r{}\", result));\n+        edit.replace(token.text_range(), format!(\"r{}\", result));\n     });\n     ctx.build()\n }\n \n+fn raw_string_token(ctx: &AssistCtx<impl HirDatabase>) -> Option<SyntaxToken> {\n+    ctx.token_at_offset().right_biased().filter(|it| it.kind() == RAW_STRING)\n+}\n+\n+fn count_hashes(s: &str) -> usize {\n+    let mut max_hash_streak = 0usize;\n+    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n+        let (_, sub) = s.split_at(idx + 1);\n+        let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n+        if nb_hash > max_hash_streak {\n+            max_hash_streak = nb_hash;\n+        }\n+    }\n+    max_hash_streak\n+}\n+\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\n+    Some(TextRange::from_to(\n+        TextUnit::from(s.find('\"')? as u32),\n+        TextUnit::from(s.rfind('\"')? as u32),\n+    ))\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -158,6 +150,23 @@ string\"#;\n         )\n     }\n \n+    #[test]\n+    fn make_raw_string_works_inside_macros() {\n+        check_assist(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                format!(<|>\"x = {}\", 92)\n+            }\n+            \"#,\n+            r##\"\n+            fn f() {\n+                format!(<|>r#\"x = {}\"#, 92)\n+            }\n+            \"##,\n+        )\n+    }\n+\n     #[test]\n     fn make_raw_string_hashes_inside_works() {\n         check_assist("}]}