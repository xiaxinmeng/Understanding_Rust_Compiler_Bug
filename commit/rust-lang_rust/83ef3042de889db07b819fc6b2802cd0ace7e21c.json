{"sha": "83ef3042de889db07b819fc6b2802cd0ace7e21c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZWYzMDQyZGU4ODlkYjA3YjgxOWZjNmIyODAyY2QwYWNlN2UyMWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-02T09:01:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-03T12:01:21Z"}, "message": "Modify `type_known_to_meet_builtin_bound` so that it doesn't suppress overflow,\nwhich should always result in an error.\n\nNB. Some of the hunks in this commit rely on a later commit which adds\n`tcx` into `param_env` and modifies `ParameterEnvironment` to\nimplement `Typer`.", "tree": {"sha": "646cc51892b652481984e7989823cd6fd6fd7f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/646cc51892b652481984e7989823cd6fd6fd7f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83ef3042de889db07b819fc6b2802cd0ace7e21c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83ef3042de889db07b819fc6b2802cd0ace7e21c", "html_url": "https://github.com/rust-lang/rust/commit/83ef3042de889db07b819fc6b2802cd0ace7e21c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83ef3042de889db07b819fc6b2802cd0ace7e21c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "429d9cce1b4b1f94672981986f049b52b341c9f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/429d9cce1b4b1f94672981986f049b52b341c9f7", "html_url": "https://github.com/rust-lang/rust/commit/429d9cce1b4b1f94672981986f049b52b341c9f7"}], "stats": {"total": 226, "additions": 149, "deletions": 77}, "files": [{"sha": "53249c724627e0839cb5197367d4b38b2f7086d3", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -1612,15 +1612,11 @@ impl LintPass for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        let parameter_environment = ty::empty_parameter_environment();\n-        if !ty::type_moves_by_default(cx.tcx,\n-                                      ty,\n-                                      &parameter_environment) {\n+        let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n+        if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n             return\n         }\n-        if ty::can_type_implement_copy(cx.tcx,\n-                                       ty,\n-                                       &parameter_environment).is_ok() {\n+        if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\"}, {"sha": "7952c99dd79b6763684001e8d333ebe0748c48c7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -1032,9 +1032,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 match p.node {\n                     ast::PatIdent(ast::BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n-                        if ty::type_moves_by_default(tcx,\n-                                                      pat_ty,\n-                                                      &cx.param_env) {\n+                        if ty::type_moves_by_default(&cx.param_env, pat.span, pat_ty) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }"}, {"sha": "1a7a642f82afc9ccaefefb9080297026010ecbc9", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n-        if !ty::type_is_sized(self.tcx, cmt.ty, self.param_env) {\n+        if !ty::type_is_sized(self.param_env, span, cmt.ty) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 ty_to_string(self.tcx, cmt.ty));"}, {"sha": "b2d866cf5861de38fb4e87f2c6b685f025c19626", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -367,10 +367,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n                         cmt: mc::cmt<'tcx>) {\n-        let mode = copy_or_move(self.tcx(),\n-                                cmt.ty,\n-                                self.param_env,\n-                                DirectRefMove);\n+        let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -1020,10 +1017,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     ast::PatIdent(ast::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n-                        match copy_or_move(tcx,\n-                                           cmt_pat.ty,\n-                                           self.param_env,\n-                                           PatBindingMove) {\n+                        match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n                         }\n@@ -1085,10 +1079,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                              r, bk, RefBinding);\n                     }\n                     ast::PatIdent(ast::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(typer.tcx(),\n-                                                cmt_pat.ty,\n-                                                param_env,\n-                                                PatBindingMove);\n+                        let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -1303,12 +1294,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     }\n }\n \n-fn copy_or_move<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      ty: Ty<'tcx>,\n-                      param_env: &ParameterEnvironment<'tcx>,\n+fn copy_or_move<'tcx>(typer: &mc::Typer<'tcx>,\n+                      cmt: &mc::cmt<'tcx>,\n                       move_reason: MoveReason)\n-                      -> ConsumeMode {\n-    if ty::type_moves_by_default(tcx, ty, param_env) {\n+                      -> ConsumeMode\n+{\n+    if typer.type_moves_by_default(cmt.span, cmt.ty) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "89ffcbf37a938bac172c6f8fcdc37ae708ca585c", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -170,6 +170,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n \n         let mut substs = param_env.free_substs.clone();\n         self.with_each_combination(\n+            span,\n             param_env,\n             param_env.free_substs.types.iter_enumerated(),\n             &mut substs,\n@@ -187,7 +188,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn with_each_combination(&self,\n-                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             span: Span,\n+                             param_env: &ty::ParameterEnvironment<'a,'tcx>,\n                              mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n                              substs: &mut Substs<'tcx>,\n                              callback: &mut FnMut(&Substs<'tcx>))\n@@ -210,15 +212,17 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n                 debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n                        space, index, param_ty.repr(self.tcx));\n \n-                if !ty::type_is_sized(self.tcx, param_ty, param_env) {\n+                if !ty::type_is_sized(param_env, span, param_ty) {\n                     debug!(\"with_each_combination: param_ty is not known to be sized\");\n \n                     substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n-                    self.with_each_combination(param_env, types_in_scope.clone(), substs, callback);\n+                    self.with_each_combination(span, param_env, types_in_scope.clone(),\n+                                               substs, callback);\n                 }\n \n                 substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n-                self.with_each_combination(param_env, types_in_scope, substs, callback);\n+                self.with_each_combination(span, param_env, types_in_scope,\n+                                           substs, callback);\n             }\n         }\n     }"}, {"sha": "05ea2f9a7d2580c0292e6d24834dc89f05cb8210", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -77,7 +77,7 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     \"overflow evaluating the requirement `{}`\",\n                     predicate.user_string(infcx.tcx)).as_slice());\n \n-            suggest_new_overflow_limit(infcx, obligation.cause.span);\n+            suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n             note_obligation_cause(infcx, obligation);\n         }\n@@ -332,10 +332,10 @@ fn note_obligation_cause_code<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n-pub fn suggest_new_overflow_limit(infcx: &InferCtxt, span: Span) {\n-    let current_limit = infcx.tcx.sess.recursion_limit.get();\n+pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n+    let current_limit = tcx.sess.recursion_limit.get();\n     let suggested_limit = current_limit * 2;\n-    infcx.tcx.sess.span_note(\n+    tcx.sess.span_note(\n         span,\n         format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\","}, {"sha": "1a1d52a047c84ac696840ca71a0fabc85c286134", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 80, "deletions": 11, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -15,16 +15,18 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{mod, Ty};\n use middle::infer::InferCtxt;\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::ppaux::Repr;\n+use util::ppaux::{Repr, UserString};\n \n pub use self::error_reporting::report_fulfillment_errors;\n+pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n@@ -288,29 +290,62 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n-                                                 ty: Ty<'tcx>,\n-                                                 bound: ty::BuiltinBound)\n-                                                 -> bool\n+pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                       typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                       ty: Ty<'tcx>,\n+                                       bound: ty::BuiltinBound,\n+                                       span: Span)\n+                                       -> SelectionResult<'tcx, ()>\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n            ty.repr(infcx.tcx),\n            bound);\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n-    // We can use dummy values here because we won't report any errors\n-    // that result nor will we pay any mind to region obligations that arise\n-    // (there shouldn't really be any anyhow).\n-    let cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+    // We can use a dummy node-id here because we won't pay any mind\n+    // to region obligations that arise (there shouldn't really be any\n+    // anyhow).\n+    let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n     fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n \n     // Note: we only assume something is `Copy` if we can\n     // *definitively* show that it implements `Copy`. Otherwise,\n     // assume it is move; linear is always ok.\n-    let result = fulfill_cx.select_all_or_error(infcx, param_env, infcx.tcx).is_ok();\n+    let result = match fulfill_cx.select_all_or_error(infcx, typer) {\n+        Ok(()) => Ok(Some(())), // Success, we know it implements Copy.\n+        Err(errors) => {\n+            // Check if overflow occurred anywhere and propagate that.\n+            if errors.iter().any(\n+                |err| match err.code { CodeSelectionError(Overflow) => true, _ => false })\n+            {\n+                return Err(Overflow);\n+            }\n+\n+            // Otherwise, if there were any hard errors, propagate an\n+            // arbitrary one of those. If no hard errors at all,\n+            // report ambiguity.\n+            let sel_error =\n+                errors.iter()\n+                      .filter_map(|err| {\n+                          match err.code {\n+                              CodeAmbiguity => None,\n+                              CodeSelectionError(ref e) => Some(e.clone()),\n+                              CodeProjectionError(_) => {\n+                                  infcx.tcx.sess.span_bug(\n+                                      span,\n+                                      \"projection error while selecting?\")\n+                              }\n+                          }\n+                      })\n+                      .next();\n+            match sel_error {\n+                None => { Ok(None) }\n+                Some(e) => { Err(e) }\n+            }\n+        }\n+    };\n \n     debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n            ty.repr(infcx.tcx),\n@@ -320,6 +355,40 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     result\n }\n \n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                                 typer: &ty::UnboxedClosureTyper<'tcx>,\n+                                                 ty: Ty<'tcx>,\n+                                                 bound: ty::BuiltinBound,\n+                                                 span: Span)\n+                                                 -> bool\n+{\n+    match evaluate_builtin_bound(infcx, typer, ty, bound, span) {\n+        Ok(Some(())) => {\n+            // definitely impl'd\n+            true\n+        }\n+        Ok(None) => {\n+            // ambiguous: if coherence check was successful, shouldn't\n+            // happen, but we might have reported an error and been\n+            // soldering on, so just treat this like not implemented\n+            false\n+        }\n+        Err(Overflow) => {\n+            infcx.tcx.sess.span_err(\n+                span,\n+                format!(\"overflow evaluating whether `{}` is `{}`\",\n+                        ty.user_string(infcx.tcx),\n+                        bound.user_string(infcx.tcx))[]);\n+            suggest_new_overflow_limit(infcx.tcx, span);\n+            false\n+        }\n+        Err(_) => {\n+            // other errors: not implemented.\n+            false\n+        }\n+    }\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "fd32e798689edfe79b95aa2ad549bbfeed01c7c7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -3548,11 +3548,12 @@ fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n         }\n     }\n \n-    let infcx = infer::new_infer_ctxt(cx);\n-    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound);\n+    let infcx = infer::new_infer_ctxt(param_env.tcx);\n+\n+    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound, span);\n \n     debug!(\"type_impls_bound({}, {}) = {}\",\n-           ty_to_string(cx, ty),\n+           ty.repr(param_env.tcx),\n            bound,\n            is_impld);\n \n@@ -3564,20 +3565,22 @@ fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n     is_impld\n }\n \n-pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n-                                   ty: Ty<'tcx>,\n-                                   param_env: &ParameterEnvironment<'tcx>)\n-                                   -> bool\n+pub fn type_moves_by_default<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                                      span: Span,\n+                                      ty: Ty<'tcx>)\n+                                      -> bool\n {\n-    !type_impls_bound(cx, &cx.type_impls_copy_cache, param_env, ty, ty::BoundCopy)\n+    let tcx = param_env.tcx;\n+    !type_impls_bound(param_env, &tcx.type_impls_copy_cache, ty, ty::BoundCopy, span)\n }\n \n-pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>,\n-                           ty: Ty<'tcx>,\n-                           param_env: &ParameterEnvironment<'tcx>)\n-                           -> bool\n+pub fn type_is_sized<'a,'tcx>(param_env: &ParameterEnvironment<'a,'tcx>,\n+                              span: Span,\n+                              ty: Ty<'tcx>)\n+                              -> bool\n {\n-    type_impls_bound(cx, &cx.type_impls_sized_cache, param_env, ty, ty::BoundSized)\n+    let tcx = param_env.tcx;\n+    type_impls_bound(param_env, &tcx.type_impls_sized_cache, ty, ty::BoundSized, span)\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -6562,6 +6565,10 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n                     -> ast::CaptureClause {\n         self.capture_modes.borrow()[closure_expr_id].clone()\n     }\n+\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        type_moves_by_default(self, span, ty)\n+    }\n }\n \n impl<'tcx> UnboxedClosureTyper<'tcx> for ty::ctxt<'tcx> {\n@@ -6944,15 +6951,18 @@ pub enum CopyImplementationError {\n     TypeIsStructural,\n }\n \n-pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n-                                     self_type: Ty<'tcx>,\n-                                     param_env: &ParameterEnvironment<'tcx>)\n-                                     -> Result<(),CopyImplementationError> {\n+pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tcx>,\n+                                        span: Span,\n+                                        self_type: Ty<'tcx>)\n+                                        -> Result<(),CopyImplementationError>\n+{\n+    let tcx = param_env.tcx;\n+\n     match self_type.sty {\n         ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n             for field in fields.iter() {\n-                if type_moves_by_default(tcx, field.mt.ty, param_env) {\n+                if type_moves_by_default(param_env, span, field.mt.ty) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n             }\n@@ -6963,9 +6973,7 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n                 for variant_arg_type in variant.args.iter() {\n                     let substd_arg_type =\n                         variant_arg_type.subst(tcx, substs);\n-                    if type_moves_by_default(tcx,\n-                                             substd_arg_type,\n-                                             param_env) {\n+                    if type_moves_by_default(param_env, span, substd_arg_type) {\n                         return Err(VariantDoesNotImplementCopy(variant.name))\n                     }\n                 }"}, {"sha": "0b1dfcb378ba0f65fa7cc518f377a7bc5fb080d1", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -1327,9 +1327,8 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n         let trmode;\n         match bm {\n             ast::BindByValue(_)\n-                if !ty::type_moves_by_default(tcx,\n-                                              variable_ty,\n-                                              &param_env) || reassigned => {\n+                if !ty::type_moves_by_default(&param_env, span, variable_ty) || reassigned =>\n+            {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n                                  \"__llmatch\");"}, {"sha": "660b7aeeb001b7aeb3c44fcdbce0c4a98b9afb8d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -625,6 +625,10 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n                     -> ast::CaptureClause {\n         self.tcx().capture_modes.borrow()[closure_expr_id].clone()\n     }\n+\n+    fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n+        self.param_env().type_moves_by_default(span, ty)\n+    }\n }\n \n impl<'blk, 'tcx> ty::UnboxedClosureTyper<'tcx> for BlockS<'blk, 'tcx> {"}, {"sha": "0afe3a8ef8d4ef7b26ae7552d88f9dd96313b928", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -543,8 +543,9 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n          * affine values (since they must never be duplicated).\n          */\n \n-        let param_env = ty::empty_parameter_environment();\n-        assert!(!ty::type_moves_by_default(bcx.tcx(), self.ty, &param_env));\n+        assert!(!ty::type_moves_by_default(&ty::empty_parameter_environment(bcx.tcx()),\n+                                           DUMMY_SP,\n+                                           self.ty));\n         self.shallow_copy_raw(bcx, dst)\n     }\n "}, {"sha": "37ec24ae23b465fbdc47207ff35bdfe88fe02bb1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -1462,7 +1462,7 @@ fn check_cast(fcx: &FnCtxt,\n         return\n     }\n \n-    if !fcx.type_is_known_to_be_sized(t_1) {\n+    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n         let tstr = fcx.infcx().ty_to_string(t_1);\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n@@ -1981,13 +1981,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_is_known_to_be_sized(&self,\n-                                     ty: Ty<'tcx>)\n+                                     ty: Ty<'tcx>,\n+                                     span: Span)\n                                      -> bool\n     {\n         traits::type_known_to_meet_builtin_bound(self.infcx(),\n                                                  self.param_env(),\n                                                  ty,\n-                                                 ty::BoundSized)\n+                                                 ty::BoundSized,\n+                                                 span)\n     }\n \n     pub fn register_builtin_bound(&self,"}, {"sha": "bb308198330f3408e87ce3b01dc8c1fae59adf7a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83ef3042de889db07b819fc6b2802cd0ace7e21c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=83ef3042de889db07b819fc6b2802cd0ace7e21c", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: self_type={} (free)\",\n                    self_type.repr(tcx));\n \n-            match ty::can_type_implement_copy(tcx, self_type, &param_env) {\n+            match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                     tcx.sess"}]}